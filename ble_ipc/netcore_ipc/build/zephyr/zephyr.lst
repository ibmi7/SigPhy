
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

01000000 <_vector_table>:
 1000000:	48 c9 00 21 6d 66 00 01 87 67 02 01 41 66 00 01     H..!mf...g..Af..
 1000010:	41 66 00 01 41 66 00 01 41 66 00 01 00 00 00 00     Af..Af..Af......
	...
 100002c:	6d 5f 00 01 41 66 00 01 00 00 00 00 15 5f 00 01     m_..Af......._..
 100003c:	41 66 00 01                                         Af..

01000040 <_irq_vector_table>:
 1000040:	ed 5f 00 01 ed 5f 00 01 ed 5f 00 01 ed 5f 00 01     ._..._..._..._..
 1000050:	ed 5f 00 01 ed 5f 00 01 ed 5f 00 01 ed 5f 00 01     ._..._..._..._..
 1000060:	5d b0 01 01 ed 5f 00 01 ed 5f 00 01 ed 5f 00 01     ]...._..._..._..
 1000070:	ed 5f 00 01 ed 5f 00 01 ed 5f 00 01 ed 5f 00 01     ._..._..._..._..
 1000080:	ed 5f 00 01 ed 5f 00 01 ed 5f 00 01 ed 5f 00 01     ._..._..._..._..
 1000090:	ed 5f 00 01 ed 5f 00 01 ed 5f 00 01 ed 5f 00 01     ._..._..._..._..
 10000a0:	ed 5f 00 01 ed 5f 00 01 ed 5f 00 01 ed 5f 00 01     ._..._..._..._..
 10000b0:	ed 5f 00 01 ed 5f 00 01                             ._..._..

Disassembly of section text:

010000b8 <__aeabi_uldivmod>:
 10000b8:	b953      	cbnz	r3, 10000d0 <__aeabi_uldivmod+0x18>
 10000ba:	b94a      	cbnz	r2, 10000d0 <__aeabi_uldivmod+0x18>
 10000bc:	2900      	cmp	r1, #0
 10000be:	bf08      	it	eq
 10000c0:	2800      	cmpeq	r0, #0
 10000c2:	bf1c      	itt	ne
 10000c4:	f04f 31ff 	movne.w	r1, #4294967295
 10000c8:	f04f 30ff 	movne.w	r0, #4294967295
 10000cc:	f000 b80c 	b.w	10000e8 <__aeabi_idiv0>
 10000d0:	f1ad 0c08 	sub.w	ip, sp, #8
 10000d4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 10000d8:	f000 f808 	bl	10000ec <__udivmoddi4>
 10000dc:	f8dd e004 	ldr.w	lr, [sp, #4]
 10000e0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 10000e4:	b004      	add	sp, #16
 10000e6:	4770      	bx	lr

010000e8 <__aeabi_idiv0>:
 10000e8:	4770      	bx	lr
 10000ea:	bf00      	nop

010000ec <__udivmoddi4>:
 10000ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 10000f0:	4686      	mov	lr, r0
 10000f2:	468c      	mov	ip, r1
 10000f4:	4608      	mov	r0, r1
 10000f6:	9e08      	ldr	r6, [sp, #32]
 10000f8:	4615      	mov	r5, r2
 10000fa:	4674      	mov	r4, lr
 10000fc:	4619      	mov	r1, r3
 10000fe:	2b00      	cmp	r3, #0
 1000100:	f040 80c1 	bne.w	1000286 <__udivmoddi4+0x19a>
 1000104:	4285      	cmp	r5, r0
 1000106:	fab2 f282 	clz	r2, r2
 100010a:	d945      	bls.n	1000198 <__udivmoddi4+0xac>
 100010c:	b14a      	cbz	r2, 1000122 <__udivmoddi4+0x36>
 100010e:	f1c2 0320 	rsb	r3, r2, #32
 1000112:	fa00 fc02 	lsl.w	ip, r0, r2
 1000116:	4095      	lsls	r5, r2
 1000118:	4094      	lsls	r4, r2
 100011a:	fa2e f303 	lsr.w	r3, lr, r3
 100011e:	ea43 0c0c 	orr.w	ip, r3, ip
 1000122:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 1000126:	b2a8      	uxth	r0, r5
 1000128:	0c23      	lsrs	r3, r4, #16
 100012a:	fbbc f8fe 	udiv	r8, ip, lr
 100012e:	fb0e cc18 	mls	ip, lr, r8, ip
 1000132:	fb08 f900 	mul.w	r9, r8, r0
 1000136:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
 100013a:	4599      	cmp	r9, r3
 100013c:	d928      	bls.n	1000190 <__udivmoddi4+0xa4>
 100013e:	18eb      	adds	r3, r5, r3
 1000140:	f108 37ff 	add.w	r7, r8, #4294967295
 1000144:	d204      	bcs.n	1000150 <__udivmoddi4+0x64>
 1000146:	4599      	cmp	r9, r3
 1000148:	d902      	bls.n	1000150 <__udivmoddi4+0x64>
 100014a:	f1a8 0702 	sub.w	r7, r8, #2
 100014e:	442b      	add	r3, r5
 1000150:	eba3 0309 	sub.w	r3, r3, r9
 1000154:	b2a4      	uxth	r4, r4
 1000156:	fbb3 fcfe 	udiv	ip, r3, lr
 100015a:	fb0e 331c 	mls	r3, lr, ip, r3
 100015e:	fb0c f000 	mul.w	r0, ip, r0
 1000162:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 1000166:	42a0      	cmp	r0, r4
 1000168:	d914      	bls.n	1000194 <__udivmoddi4+0xa8>
 100016a:	192c      	adds	r4, r5, r4
 100016c:	f10c 33ff 	add.w	r3, ip, #4294967295
 1000170:	d204      	bcs.n	100017c <__udivmoddi4+0x90>
 1000172:	42a0      	cmp	r0, r4
 1000174:	d902      	bls.n	100017c <__udivmoddi4+0x90>
 1000176:	f1ac 0302 	sub.w	r3, ip, #2
 100017a:	442c      	add	r4, r5
 100017c:	1a24      	subs	r4, r4, r0
 100017e:	ea43 4007 	orr.w	r0, r3, r7, lsl #16
 1000182:	b11e      	cbz	r6, 100018c <__udivmoddi4+0xa0>
 1000184:	40d4      	lsrs	r4, r2
 1000186:	2300      	movs	r3, #0
 1000188:	6034      	str	r4, [r6, #0]
 100018a:	6073      	str	r3, [r6, #4]
 100018c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1000190:	4647      	mov	r7, r8
 1000192:	e7dd      	b.n	1000150 <__udivmoddi4+0x64>
 1000194:	4663      	mov	r3, ip
 1000196:	e7f1      	b.n	100017c <__udivmoddi4+0x90>
 1000198:	bb92      	cbnz	r2, 1000200 <__udivmoddi4+0x114>
 100019a:	1b43      	subs	r3, r0, r5
 100019c:	2101      	movs	r1, #1
 100019e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 10001a2:	b2af      	uxth	r7, r5
 10001a4:	0c20      	lsrs	r0, r4, #16
 10001a6:	fbb3 fcfe 	udiv	ip, r3, lr
 10001aa:	fb0e 331c 	mls	r3, lr, ip, r3
 10001ae:	fb0c f807 	mul.w	r8, ip, r7
 10001b2:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 10001b6:	4598      	cmp	r8, r3
 10001b8:	d961      	bls.n	100027e <__udivmoddi4+0x192>
 10001ba:	18eb      	adds	r3, r5, r3
 10001bc:	f10c 30ff 	add.w	r0, ip, #4294967295
 10001c0:	d204      	bcs.n	10001cc <__udivmoddi4+0xe0>
 10001c2:	4598      	cmp	r8, r3
 10001c4:	d902      	bls.n	10001cc <__udivmoddi4+0xe0>
 10001c6:	f1ac 0002 	sub.w	r0, ip, #2
 10001ca:	442b      	add	r3, r5
 10001cc:	eba3 0308 	sub.w	r3, r3, r8
 10001d0:	b2a4      	uxth	r4, r4
 10001d2:	fbb3 fcfe 	udiv	ip, r3, lr
 10001d6:	fb0e 331c 	mls	r3, lr, ip, r3
 10001da:	fb0c f707 	mul.w	r7, ip, r7
 10001de:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 10001e2:	42a7      	cmp	r7, r4
 10001e4:	d94d      	bls.n	1000282 <__udivmoddi4+0x196>
 10001e6:	192c      	adds	r4, r5, r4
 10001e8:	f10c 33ff 	add.w	r3, ip, #4294967295
 10001ec:	d204      	bcs.n	10001f8 <__udivmoddi4+0x10c>
 10001ee:	42a7      	cmp	r7, r4
 10001f0:	d902      	bls.n	10001f8 <__udivmoddi4+0x10c>
 10001f2:	f1ac 0302 	sub.w	r3, ip, #2
 10001f6:	442c      	add	r4, r5
 10001f8:	1be4      	subs	r4, r4, r7
 10001fa:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 10001fe:	e7c0      	b.n	1000182 <__udivmoddi4+0x96>
 1000200:	f1c2 0320 	rsb	r3, r2, #32
 1000204:	4095      	lsls	r5, r2
 1000206:	4094      	lsls	r4, r2
 1000208:	fa20 f103 	lsr.w	r1, r0, r3
 100020c:	fa2e f303 	lsr.w	r3, lr, r3
 1000210:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 1000214:	4090      	lsls	r0, r2
 1000216:	b2af      	uxth	r7, r5
 1000218:	4303      	orrs	r3, r0
 100021a:	fbb1 fcfe 	udiv	ip, r1, lr
 100021e:	fb0e 101c 	mls	r0, lr, ip, r1
 1000222:	0c19      	lsrs	r1, r3, #16
 1000224:	fb0c f807 	mul.w	r8, ip, r7
 1000228:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 100022c:	4588      	cmp	r8, r1
 100022e:	d922      	bls.n	1000276 <__udivmoddi4+0x18a>
 1000230:	1869      	adds	r1, r5, r1
 1000232:	f10c 30ff 	add.w	r0, ip, #4294967295
 1000236:	d204      	bcs.n	1000242 <__udivmoddi4+0x156>
 1000238:	4588      	cmp	r8, r1
 100023a:	d902      	bls.n	1000242 <__udivmoddi4+0x156>
 100023c:	f1ac 0002 	sub.w	r0, ip, #2
 1000240:	4429      	add	r1, r5
 1000242:	eba1 0108 	sub.w	r1, r1, r8
 1000246:	b29b      	uxth	r3, r3
 1000248:	fbb1 fcfe 	udiv	ip, r1, lr
 100024c:	fb0e 111c 	mls	r1, lr, ip, r1
 1000250:	fb0c f707 	mul.w	r7, ip, r7
 1000254:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 1000258:	429f      	cmp	r7, r3
 100025a:	d90e      	bls.n	100027a <__udivmoddi4+0x18e>
 100025c:	18eb      	adds	r3, r5, r3
 100025e:	f10c 31ff 	add.w	r1, ip, #4294967295
 1000262:	d204      	bcs.n	100026e <__udivmoddi4+0x182>
 1000264:	429f      	cmp	r7, r3
 1000266:	d902      	bls.n	100026e <__udivmoddi4+0x182>
 1000268:	f1ac 0102 	sub.w	r1, ip, #2
 100026c:	442b      	add	r3, r5
 100026e:	1bdb      	subs	r3, r3, r7
 1000270:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 1000274:	e793      	b.n	100019e <__udivmoddi4+0xb2>
 1000276:	4660      	mov	r0, ip
 1000278:	e7e3      	b.n	1000242 <__udivmoddi4+0x156>
 100027a:	4661      	mov	r1, ip
 100027c:	e7f7      	b.n	100026e <__udivmoddi4+0x182>
 100027e:	4660      	mov	r0, ip
 1000280:	e7a4      	b.n	10001cc <__udivmoddi4+0xe0>
 1000282:	4663      	mov	r3, ip
 1000284:	e7b8      	b.n	10001f8 <__udivmoddi4+0x10c>
 1000286:	4283      	cmp	r3, r0
 1000288:	d906      	bls.n	1000298 <__udivmoddi4+0x1ac>
 100028a:	b916      	cbnz	r6, 1000292 <__udivmoddi4+0x1a6>
 100028c:	2100      	movs	r1, #0
 100028e:	4608      	mov	r0, r1
 1000290:	e77c      	b.n	100018c <__udivmoddi4+0xa0>
 1000292:	e9c6 e000 	strd	lr, r0, [r6]
 1000296:	e7f9      	b.n	100028c <__udivmoddi4+0x1a0>
 1000298:	fab3 f783 	clz	r7, r3
 100029c:	b98f      	cbnz	r7, 10002c2 <__udivmoddi4+0x1d6>
 100029e:	4283      	cmp	r3, r0
 10002a0:	d301      	bcc.n	10002a6 <__udivmoddi4+0x1ba>
 10002a2:	4572      	cmp	r2, lr
 10002a4:	d808      	bhi.n	10002b8 <__udivmoddi4+0x1cc>
 10002a6:	ebbe 0402 	subs.w	r4, lr, r2
 10002aa:	eb60 0303 	sbc.w	r3, r0, r3
 10002ae:	2001      	movs	r0, #1
 10002b0:	469c      	mov	ip, r3
 10002b2:	b91e      	cbnz	r6, 10002bc <__udivmoddi4+0x1d0>
 10002b4:	2100      	movs	r1, #0
 10002b6:	e769      	b.n	100018c <__udivmoddi4+0xa0>
 10002b8:	4638      	mov	r0, r7
 10002ba:	e7fa      	b.n	10002b2 <__udivmoddi4+0x1c6>
 10002bc:	e9c6 4c00 	strd	r4, ip, [r6]
 10002c0:	e7f8      	b.n	10002b4 <__udivmoddi4+0x1c8>
 10002c2:	f1c7 0c20 	rsb	ip, r7, #32
 10002c6:	40bb      	lsls	r3, r7
 10002c8:	fa0e f507 	lsl.w	r5, lr, r7
 10002cc:	fa22 f40c 	lsr.w	r4, r2, ip
 10002d0:	fa2e f10c 	lsr.w	r1, lr, ip
 10002d4:	40ba      	lsls	r2, r7
 10002d6:	431c      	orrs	r4, r3
 10002d8:	fa20 f30c 	lsr.w	r3, r0, ip
 10002dc:	40b8      	lsls	r0, r7
 10002de:	ea4f 4914 	mov.w	r9, r4, lsr #16
 10002e2:	4301      	orrs	r1, r0
 10002e4:	fa1f fe84 	uxth.w	lr, r4
 10002e8:	fbb3 f8f9 	udiv	r8, r3, r9
 10002ec:	fb09 3018 	mls	r0, r9, r8, r3
 10002f0:	0c0b      	lsrs	r3, r1, #16
 10002f2:	fb08 fa0e 	mul.w	sl, r8, lr
 10002f6:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 10002fa:	459a      	cmp	sl, r3
 10002fc:	d940      	bls.n	1000380 <__udivmoddi4+0x294>
 10002fe:	18e3      	adds	r3, r4, r3
 1000300:	f108 30ff 	add.w	r0, r8, #4294967295
 1000304:	d204      	bcs.n	1000310 <__udivmoddi4+0x224>
 1000306:	459a      	cmp	sl, r3
 1000308:	d902      	bls.n	1000310 <__udivmoddi4+0x224>
 100030a:	f1a8 0002 	sub.w	r0, r8, #2
 100030e:	4423      	add	r3, r4
 1000310:	eba3 030a 	sub.w	r3, r3, sl
 1000314:	b289      	uxth	r1, r1
 1000316:	fbb3 f8f9 	udiv	r8, r3, r9
 100031a:	fb09 3318 	mls	r3, r9, r8, r3
 100031e:	fb08 fe0e 	mul.w	lr, r8, lr
 1000322:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 1000326:	458e      	cmp	lr, r1
 1000328:	d92c      	bls.n	1000384 <__udivmoddi4+0x298>
 100032a:	1861      	adds	r1, r4, r1
 100032c:	f108 33ff 	add.w	r3, r8, #4294967295
 1000330:	d204      	bcs.n	100033c <__udivmoddi4+0x250>
 1000332:	458e      	cmp	lr, r1
 1000334:	d902      	bls.n	100033c <__udivmoddi4+0x250>
 1000336:	f1a8 0302 	sub.w	r3, r8, #2
 100033a:	4421      	add	r1, r4
 100033c:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 1000340:	eba1 010e 	sub.w	r1, r1, lr
 1000344:	fba0 9802 	umull	r9, r8, r0, r2
 1000348:	4541      	cmp	r1, r8
 100034a:	46ce      	mov	lr, r9
 100034c:	4643      	mov	r3, r8
 100034e:	d302      	bcc.n	1000356 <__udivmoddi4+0x26a>
 1000350:	d106      	bne.n	1000360 <__udivmoddi4+0x274>
 1000352:	454d      	cmp	r5, r9
 1000354:	d204      	bcs.n	1000360 <__udivmoddi4+0x274>
 1000356:	3801      	subs	r0, #1
 1000358:	ebb9 0e02 	subs.w	lr, r9, r2
 100035c:	eb68 0304 	sbc.w	r3, r8, r4
 1000360:	2e00      	cmp	r6, #0
 1000362:	d0a7      	beq.n	10002b4 <__udivmoddi4+0x1c8>
 1000364:	ebb5 020e 	subs.w	r2, r5, lr
 1000368:	eb61 0103 	sbc.w	r1, r1, r3
 100036c:	fa01 fc0c 	lsl.w	ip, r1, ip
 1000370:	fa22 f307 	lsr.w	r3, r2, r7
 1000374:	40f9      	lsrs	r1, r7
 1000376:	ea4c 0303 	orr.w	r3, ip, r3
 100037a:	e9c6 3100 	strd	r3, r1, [r6]
 100037e:	e799      	b.n	10002b4 <__udivmoddi4+0x1c8>
 1000380:	4640      	mov	r0, r8
 1000382:	e7c5      	b.n	1000310 <__udivmoddi4+0x224>
 1000384:	4643      	mov	r3, r8
 1000386:	e7d9      	b.n	100033c <__udivmoddi4+0x250>

01000388 <bt_init>:

	bt_dev_show_info();
}

static int bt_init(void)
{
 1000388:	b570      	push	{r4, r5, r6, lr}
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
 100038a:	4dc2      	ldr	r5, [pc, #776]	; (1000694 <bt_init+0x30c>)
{
 100038c:	b088      	sub	sp, #32
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
 100038e:	f8d5 3158 	ldr.w	r3, [r5, #344]	; 0x158
 1000392:	6899      	ldr	r1, [r3, #8]
 1000394:	f011 0101 	ands.w	r1, r1, #1
 1000398:	d119      	bne.n	10003ce <bt_init+0x46>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
 100039a:	f640 4003 	movw	r0, #3075	; 0xc03
 100039e:	aa02      	add	r2, sp, #8
 10003a0:	f007 fdca 	bl	1007f38 <bt_hci_cmd_send_sync>
		if (err) {
 10003a4:	4604      	mov	r4, r0
 10003a6:	2800      	cmp	r0, #0
 10003a8:	d167      	bne.n	100047a <bt_init+0xf2>
		hci_reset_complete(rsp);
 10003aa:	9802      	ldr	r0, [sp, #8]
	uint8_t status = buf->data[0];
 10003ac:	68c3      	ldr	r3, [r0, #12]
	if (status) {
 10003ae:	781b      	ldrb	r3, [r3, #0]
 10003b0:	b95b      	cbnz	r3, 10003ca <bt_init+0x42>
 *
 * @return Value of @a target.
 */
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 10003b2:	f105 03cc 	add.w	r3, r5, #204	; 0xcc
 10003b6:	e8d3 2faf 	lda	r2, [r3]
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 10003ba:	f002 0209 	and.w	r2, r2, #9
 10003be:	e8d3 1fef 	ldaex	r1, [r3]
 10003c2:	e8c3 2fe4 	stlex	r4, r2, [r3]
 10003c6:	2c00      	cmp	r4, #0
 10003c8:	d1f9      	bne.n	10003be <bt_init+0x36>
		net_buf_unref(rsp);
 10003ca:	f01d fe09 	bl	101dfe0 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
 10003ce:	2100      	movs	r1, #0
 10003d0:	f241 0003 	movw	r0, #4099	; 0x1003
 10003d4:	aa02      	add	r2, sp, #8
 10003d6:	f007 fdaf 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 10003da:	4604      	mov	r4, r0
 10003dc:	2800      	cmp	r0, #0
 10003de:	d14c      	bne.n	100047a <bt_init+0xf2>
	read_local_features_complete(rsp);
 10003e0:	9e02      	ldr	r6, [sp, #8]
	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
 10003e2:	2208      	movs	r2, #8
 10003e4:	68f1      	ldr	r1, [r6, #12]
 10003e6:	48ac      	ldr	r0, [pc, #688]	; (1000698 <bt_init+0x310>)
 10003e8:	3101      	adds	r1, #1
 10003ea:	f026 fac3 	bl	1026974 <memcpy>
	net_buf_unref(rsp);
 10003ee:	4630      	mov	r0, r6
 10003f0:	f01d fdf6 	bl	101dfe0 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
 10003f4:	4621      	mov	r1, r4
 10003f6:	f241 0001 	movw	r0, #4097	; 0x1001
 10003fa:	aa02      	add	r2, sp, #8
 10003fc:	f007 fd9c 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 1000400:	4604      	mov	r4, r0
 1000402:	2800      	cmp	r0, #0
 1000404:	d139      	bne.n	100047a <bt_init+0xf2>
	read_local_ver_complete(rsp);
 1000406:	9802      	ldr	r0, [sp, #8]
	struct bt_hci_rp_read_local_version_info *rp = (void *)buf->data;
 1000408:	68c3      	ldr	r3, [r0, #12]
	bt_dev.hci_version = rp->hci_version;
 100040a:	785a      	ldrb	r2, [r3, #1]
 100040c:	f885 2068 	strb.w	r2, [r5, #104]	; 0x68
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
 1000410:	885a      	ldrh	r2, [r3, #2]
 1000412:	f8a5 206a 	strh.w	r2, [r5, #106]	; 0x6a
	bt_dev.lmp_version = rp->lmp_version;
 1000416:	791a      	ldrb	r2, [r3, #4]
 1000418:	f885 2069 	strb.w	r2, [r5, #105]	; 0x69
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
 100041c:	f8b3 2007 	ldrh.w	r2, [r3, #7]
 1000420:	f8a5 206c 	strh.w	r2, [r5, #108]	; 0x6c
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
 1000424:	f8b3 3005 	ldrh.w	r3, [r3, #5]
 1000428:	f8a5 306e 	strh.w	r3, [r5, #110]	; 0x6e
	net_buf_unref(rsp);
 100042c:	f01d fdd8 	bl	101dfe0 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
 1000430:	4621      	mov	r1, r4
 1000432:	f241 0002 	movw	r0, #4098	; 0x1002
 1000436:	aa02      	add	r2, sp, #8
 1000438:	f007 fd7e 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 100043c:	4604      	mov	r4, r0
 100043e:	b9e0      	cbnz	r0, 100047a <bt_init+0xf2>
	read_supported_commands_complete(rsp);
 1000440:	9e02      	ldr	r6, [sp, #8]
	memcpy(bt_dev.supported_commands, rp->commands,
 1000442:	2240      	movs	r2, #64	; 0x40
 1000444:	68f1      	ldr	r1, [r6, #12]
 1000446:	4895      	ldr	r0, [pc, #596]	; (100069c <bt_init+0x314>)
 1000448:	3101      	adds	r1, #1
 100044a:	f026 fa93 	bl	1026974 <memcpy>
		bt_hci_ecc_supported_commands(bt_dev.supported_commands);
 100044e:	4893      	ldr	r0, [pc, #588]	; (100069c <bt_init+0x314>)
 1000450:	f026 fafe 	bl	1026a50 <bt_hci_ecc_supported_commands>
	net_buf_unref(rsp);
 1000454:	4630      	mov	r0, r6
 1000456:	f01d fdc3 	bl	101dfe0 <net_buf_unref>
	if (!BT_FEAT_LE(bt_dev.features)) {
 100045a:	f895 3074 	ldrb.w	r3, [r5, #116]	; 0x74
 100045e:	065a      	lsls	r2, r3, #25
 1000460:	d40e      	bmi.n	1000480 <bt_init+0xf8>
		LOG_ERR("Non-LE capable controller detected!");
 1000462:	4b8f      	ldr	r3, [pc, #572]	; (10006a0 <bt_init+0x318>)
		return -ENODEV;
 1000464:	f06f 0412 	mvn.w	r4, #18
		LOG_ERR("Non-LE capable controller detected!");
 1000468:	9307      	str	r3, [sp, #28]
 100046a:	2302      	movs	r3, #2
 100046c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1000470:	488c      	ldr	r0, [pc, #560]	; (10006a4 <bt_init+0x31c>)
 1000472:	aa06      	add	r2, sp, #24
 1000474:	9306      	str	r3, [sp, #24]
 1000476:	f026 fbb3 	bl	1026be0 <z_log_msg_static_create.constprop.0>
		atomic_set_bit(bt_dev.flags, BT_DEV_PRESET_ID);
	}

	bt_finalize_init();
	return 0;
}
 100047a:	4620      	mov	r0, r4
 100047c:	b008      	add	sp, #32
 100047e:	bd70      	pop	{r4, r5, r6, pc}
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
 1000480:	4621      	mov	r1, r4
 1000482:	f242 0003 	movw	r0, #8195	; 0x2003
 1000486:	aa02      	add	r2, sp, #8
 1000488:	f007 fd56 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 100048c:	4604      	mov	r4, r0
 100048e:	2800      	cmp	r0, #0
 1000490:	d1f3      	bne.n	100047a <bt_init+0xf2>
	read_le_features_complete(rsp);
 1000492:	9e02      	ldr	r6, [sp, #8]
	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
 1000494:	2208      	movs	r2, #8
 1000496:	68f1      	ldr	r1, [r6, #12]
 1000498:	4883      	ldr	r0, [pc, #524]	; (10006a8 <bt_init+0x320>)
 100049a:	3101      	adds	r1, #1
 100049c:	f026 fa6a 	bl	1026974 <memcpy>
	net_buf_unref(rsp);
 10004a0:	4630      	mov	r0, r6
 10004a2:	f01d fd9d 	bl	101dfe0 <net_buf_unref>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
 10004a6:	4621      	mov	r1, r4
 10004a8:	f242 0002 	movw	r0, #8194	; 0x2002
 10004ac:	aa02      	add	r2, sp, #8
 10004ae:	f007 fd43 	bl	1007f38 <bt_hci_cmd_send_sync>
		if (err) {
 10004b2:	4604      	mov	r4, r0
 10004b4:	2800      	cmp	r0, #0
 10004b6:	d1e0      	bne.n	100047a <bt_init+0xf2>
		le_read_buffer_size_complete(rsp);
 10004b8:	9c02      	ldr	r4, [sp, #8]
	struct bt_hci_rp_le_read_buffer_size *rp = (void *)buf->data;
 10004ba:	68e3      	ldr	r3, [r4, #12]
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->le_max_len);
 10004bc:	f8b3 2001 	ldrh.w	r2, [r3, #1]
 10004c0:	b291      	uxth	r1, r2
 10004c2:	f8a5 20fc 	strh.w	r2, [r5, #252]	; 0xfc
	if (!bt_dev.le.acl_mtu) {
 10004c6:	b121      	cbz	r1, 10004d2 <bt_init+0x14a>
	k_sem_init(&bt_dev.le.acl_pkts, rp->le_max_num, rp->le_max_num);
 10004c8:	78da      	ldrb	r2, [r3, #3]
		union { uintptr_t x; unsigned int val; } parm2 = { .val = limit };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_K_SEM_INIT);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_init(sem, initial_count, limit);
 10004ca:	4878      	ldr	r0, [pc, #480]	; (10006ac <bt_init+0x324>)
 10004cc:	4611      	mov	r1, r2
 10004ce:	f028 ff22 	bl	1029316 <z_impl_k_sem_init>
		net_buf_unref(rsp);
 10004d2:	4620      	mov	r0, r4
 10004d4:	f01d fd84 	bl	101dfe0 <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
 10004d8:	f895 6074 	ldrb.w	r6, [r5, #116]	; 0x74
 10004dc:	f016 0620 	ands.w	r6, r6, #32
 10004e0:	d118      	bne.n	1000514 <bt_init+0x18c>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
 10004e2:	2102      	movs	r1, #2
 10004e4:	f640 406d 	movw	r0, #3181	; 0xc6d
 10004e8:	f007 fbd0 	bl	1007c8c <bt_hci_cmd_create>
		if (!buf) {
 10004ec:	4604      	mov	r4, r0
 10004ee:	2800      	cmp	r0, #0
 10004f0:	f000 80cc 	beq.w	100068c <bt_init+0x304>
 *
 * @return The original tail of the buffer.
 */
static inline void *net_buf_add(struct net_buf *buf, size_t len)
{
	return net_buf_simple_add(&buf->b, len);
 10004f4:	2102      	movs	r1, #2
 10004f6:	300c      	adds	r0, #12
 10004f8:	f01d fece 	bl	101e298 <net_buf_simple_add>
		cp_le->le = 0x01;
 10004fc:	2301      	movs	r3, #1
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
 10004fe:	4621      	mov	r1, r4
		cp_le->le = 0x01;
 1000500:	7003      	strb	r3, [r0, #0]
		cp_le->simul = 0x00;
 1000502:	7046      	strb	r6, [r0, #1]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
 1000504:	4632      	mov	r2, r6
 1000506:	f640 406d 	movw	r0, #3181	; 0xc6d
 100050a:	f007 fd15 	bl	1007f38 <bt_hci_cmd_send_sync>
		if (err) {
 100050e:	4604      	mov	r4, r0
 1000510:	2800      	cmp	r0, #0
 1000512:	d1b2      	bne.n	100047a <bt_init+0xf2>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
 1000514:	f895 3094 	ldrb.w	r3, [r5, #148]	; 0x94
 1000518:	071b      	lsls	r3, r3, #28
 100051a:	d512      	bpl.n	1000542 <bt_init+0x1ba>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
 100051c:	2100      	movs	r1, #0
 100051e:	f242 001c 	movw	r0, #8220	; 0x201c
 1000522:	aa02      	add	r2, sp, #8
 1000524:	f007 fd08 	bl	1007f38 <bt_hci_cmd_send_sync>
		if (err) {
 1000528:	4604      	mov	r4, r0
 100052a:	2800      	cmp	r0, #0
 100052c:	d1a5      	bne.n	100047a <bt_init+0xf2>
		le_read_supp_states_complete(rsp);
 100052e:	9802      	ldr	r0, [sp, #8]
 *
 *  @return 64-bit integer in host endianness.
 */
static inline uint64_t sys_get_le64(const uint8_t src[8])
{
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
 1000530:	68c3      	ldr	r3, [r0, #12]
 1000532:	f8d3 2001 	ldr.w	r2, [r3, #1]
 1000536:	f8d3 3005 	ldr.w	r3, [r3, #5]
	bt_dev.le.states = sys_get_le64(rp->le_states);
 100053a:	e9c5 2336 	strd	r2, r3, [r5, #216]	; 0xd8
		net_buf_unref(rsp);
 100053e:	f01d fd4f 	bl	101dfe0 <net_buf_unref>
	if (IS_ENABLED(CONFIG_BT_CONN) &&
 1000542:	f895 30d0 	ldrb.w	r3, [r5, #208]	; 0xd0
 1000546:	069e      	lsls	r6, r3, #26
 1000548:	d524      	bpl.n	1000594 <bt_init+0x20c>
		err = hci_le_read_max_data_len(&tx_octets, &tx_time);
 100054a:	a901      	add	r1, sp, #4
 100054c:	f10d 0002 	add.w	r0, sp, #2
 1000550:	f007 fd6e 	bl	1008030 <hci_le_read_max_data_len>
		if (err) {
 1000554:	4604      	mov	r4, r0
 1000556:	2800      	cmp	r0, #0
 1000558:	d18f      	bne.n	100047a <bt_init+0xf2>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
 100055a:	2104      	movs	r1, #4
 100055c:	f242 0024 	movw	r0, #8228	; 0x2024
 1000560:	f007 fb94 	bl	1007c8c <bt_hci_cmd_create>
		if (!buf) {
 1000564:	4606      	mov	r6, r0
 1000566:	2800      	cmp	r0, #0
 1000568:	f000 8090 	beq.w	100068c <bt_init+0x304>
 100056c:	2104      	movs	r1, #4
 100056e:	300c      	adds	r0, #12
 1000570:	f01d fe92 	bl	101e298 <net_buf_simple_add>
		cp->max_tx_octets = sys_cpu_to_le16(tx_octets);
 1000574:	f8bd 3002 	ldrh.w	r3, [sp, #2]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
 1000578:	4622      	mov	r2, r4
		cp->max_tx_octets = sys_cpu_to_le16(tx_octets);
 100057a:	8003      	strh	r3, [r0, #0]
		cp->max_tx_time = sys_cpu_to_le16(tx_time);
 100057c:	f8bd 3004 	ldrh.w	r3, [sp, #4]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
 1000580:	4631      	mov	r1, r6
		cp->max_tx_time = sys_cpu_to_le16(tx_time);
 1000582:	8043      	strh	r3, [r0, #2]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
 1000584:	f242 0024 	movw	r0, #8228	; 0x2024
 1000588:	f007 fcd6 	bl	1007f38 <bt_hci_cmd_send_sync>
		if (err) {
 100058c:	4604      	mov	r4, r0
 100058e:	2800      	cmp	r0, #0
 1000590:	f47f af73 	bne.w	100047a <bt_init+0xf2>
	if (BT_FEAT_LE_PRIVACY(bt_dev.le.features)) {
 1000594:	f895 30d0 	ldrb.w	r3, [r5, #208]	; 0xd0
 1000598:	065c      	lsls	r4, r3, #25
 100059a:	d510      	bpl.n	10005be <bt_init+0x236>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_RL_SIZE, NULL,
 100059c:	2100      	movs	r1, #0
 100059e:	f242 002a 	movw	r0, #8234	; 0x202a
 10005a2:	aa02      	add	r2, sp, #8
 10005a4:	f007 fcc8 	bl	1007f38 <bt_hci_cmd_send_sync>
		if (err) {
 10005a8:	4604      	mov	r4, r0
 10005aa:	2800      	cmp	r0, #0
 10005ac:	f47f af65 	bne.w	100047a <bt_init+0xf2>
		le_read_resolving_list_size_complete(rsp);
 10005b0:	9802      	ldr	r0, [sp, #8]
	bt_dev.le.rl_size = rp->rl_size;
 10005b2:	68c3      	ldr	r3, [r0, #12]
 10005b4:	785b      	ldrb	r3, [r3, #1]
 10005b6:	f885 3118 	strb.w	r3, [r5, #280]	; 0x118
		net_buf_unref(rsp);
 10005ba:	f01d fd11 	bl	101dfe0 <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
 10005be:	2108      	movs	r1, #8
 10005c0:	f242 0001 	movw	r0, #8193	; 0x2001
 10005c4:	f007 fb62 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 10005c8:	4604      	mov	r4, r0
 10005ca:	2800      	cmp	r0, #0
 10005cc:	d05e      	beq.n	100068c <bt_init+0x304>
 10005ce:	2108      	movs	r1, #8
 10005d0:	300c      	adds	r0, #12
 10005d2:	f01d fe61 	bl	101e298 <net_buf_simple_add>
		     BT_FEAT_LE_PRIVACY(bt_dev.le.features)) ||
 10005d6:	f895 10d0 	ldrb.w	r1, [r5, #208]	; 0xd0
			mask |= BT_EVT_MASK_LE_CONN_COMPLETE;
 10005da:	f240 2302 	movw	r3, #514	; 0x202
 10005de:	f011 0f40 	tst.w	r1, #64	; 0x40
 10005e2:	bf08      	it	eq
 10005e4:	2303      	moveq	r3, #3
 10005e6:	4602      	mov	r2, r0
		if (BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features)) {
 10005e8:	0788      	lsls	r0, r1, #30
			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
 10005ea:	bf4c      	ite	mi
 10005ec:	f043 002c 	orrmi.w	r0, r3, #44	; 0x2c
		mask |= BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE;
 10005f0:	f043 000c 	orrpl.w	r0, r3, #12
		if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
 10005f4:	068b      	lsls	r3, r1, #26
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
 10005f6:	f895 30d1 	ldrb.w	r3, [r5, #209]	; 0xd1
			mask |= BT_EVT_MASK_LE_DATA_LEN_CHANGE;
 10005fa:	bf48      	it	mi
 10005fc:	f040 0040 	orrmi.w	r0, r0, #64	; 0x40
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
 1000600:	f013 0f09 	tst.w	r3, #9
	if (IS_ENABLED(CONFIG_BT_ECC) &&
 1000604:	f895 309a 	ldrb.w	r3, [r5, #154]	; 0x9a
			mask |= BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE;
 1000608:	bf18      	it	ne
 100060a:	f440 6000 	orrne.w	r0, r0, #2048	; 0x800
	if (IS_ENABLED(CONFIG_BT_ECC) &&
 100060e:	f003 0306 	and.w	r3, r3, #6
	if (IS_ENABLED(CONFIG_BT_SMP) &&
 1000612:	07ce      	lsls	r6, r1, #31
		mask |= BT_EVT_MASK_LE_LTK_REQUEST;
 1000614:	bf48      	it	mi
 1000616:	f040 0010 	orrmi.w	r0, r0, #16
	if (IS_ENABLED(CONFIG_BT_ECC) &&
 100061a:	2b06      	cmp	r3, #6
		mask |= BT_EVT_MASK_LE_GENERATE_DHKEY_COMPLETE;
 100061c:	bf08      	it	eq
 100061e:	f440 70c0 	orreq.w	r0, r0, #384	; 0x180
	sys_put_le64(mask, cp_mask->events);
 1000622:	2100      	movs	r1, #0
 1000624:	f026 fae7 	bl	1026bf6 <sys_put_le64>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
 1000628:	4621      	mov	r1, r4
 100062a:	2200      	movs	r2, #0
 100062c:	f242 0001 	movw	r0, #8193	; 0x2001
 1000630:	f007 fc82 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 1000634:	4604      	mov	r4, r0
 1000636:	2800      	cmp	r0, #0
 1000638:	f47f af1f 	bne.w	100047a <bt_init+0xf2>
	if (BT_FEAT_BREDR(bt_dev.features)) {
 100063c:	f895 3074 	ldrb.w	r3, [r5, #116]	; 0x74
	if (bt_dev.le.acl_mtu) {
 1000640:	f8b5 10fc 	ldrh.w	r1, [r5, #252]	; 0xfc
	if (BT_FEAT_BREDR(bt_dev.features)) {
 1000644:	0698      	lsls	r0, r3, #26
 1000646:	d433      	bmi.n	10006b0 <bt_init+0x328>
	if (bt_dev.le.acl_mtu) {
 1000648:	b9c9      	cbnz	r1, 100067e <bt_init+0x2f6>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &rsp);
 100064a:	f241 0005 	movw	r0, #4101	; 0x1005
 100064e:	aa02      	add	r2, sp, #8
 1000650:	f007 fc72 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 1000654:	4604      	mov	r4, r0
 1000656:	2800      	cmp	r0, #0
 1000658:	f47f af0f 	bne.w	100047a <bt_init+0xf2>
	if (bt_dev.le.acl_mtu) {
 100065c:	f8b5 30fc 	ldrh.w	r3, [r5, #252]	; 0xfc
	read_buffer_size_complete(rsp);
 1000660:	9c02      	ldr	r4, [sp, #8]
	if (bt_dev.le.acl_mtu) {
 1000662:	b94b      	cbnz	r3, 1000678 <bt_init+0x2f0>
	struct bt_hci_rp_read_buffer_size *rp = (void *)buf->data;
 1000664:	68e3      	ldr	r3, [r4, #12]
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->acl_max_len);
 1000666:	f8b3 2001 	ldrh.w	r2, [r3, #1]
 100066a:	f8a5 20fc 	strh.w	r2, [r5, #252]	; 0xfc
	k_sem_init(&bt_dev.le.acl_pkts, pkts, pkts);
 100066e:	889a      	ldrh	r2, [r3, #4]
 1000670:	480e      	ldr	r0, [pc, #56]	; (10006ac <bt_init+0x324>)
 1000672:	4611      	mov	r1, r2
 1000674:	f028 fe4f 	bl	1029316 <z_impl_k_sem_init>
	net_buf_unref(rsp);
 1000678:	4620      	mov	r0, r4
 100067a:	f01d fcb1 	bl	101dfe0 <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
 100067e:	2108      	movs	r1, #8
 1000680:	f640 4001 	movw	r0, #3073	; 0xc01
 1000684:	f007 fb02 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 1000688:	4604      	mov	r4, r0
 100068a:	bb00      	cbnz	r0, 10006ce <bt_init+0x346>
		return -ENOBUFS;
 100068c:	f06f 0468 	mvn.w	r4, #104	; 0x68
 1000690:	e6f3      	b.n	100047a <bt_init+0xf2>
 1000692:	bf00      	nop
 1000694:	21000000 	.word	0x21000000
 1000698:	21000070 	.word	0x21000070
 100069c:	21000078 	.word	0x21000078
 10006a0:	0102d368 	.word	0x0102d368
 10006a4:	010299a4 	.word	0x010299a4
 10006a8:	210000d0 	.word	0x210000d0
 10006ac:	21000100 	.word	0x21000100
	else if (!bt_dev.le.acl_mtu) {
 10006b0:	2900      	cmp	r1, #0
 10006b2:	d1e4      	bne.n	100067e <bt_init+0x2f6>
		LOG_ERR("ACL BR/EDR buffers not initialized");
 10006b4:	4b40      	ldr	r3, [pc, #256]	; (10007b8 <bt_init+0x430>)
 10006b6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10006ba:	9307      	str	r3, [sp, #28]
 10006bc:	2302      	movs	r3, #2
 10006be:	483f      	ldr	r0, [pc, #252]	; (10007bc <bt_init+0x434>)
 10006c0:	aa06      	add	r2, sp, #24
 10006c2:	9306      	str	r3, [sp, #24]
		return -EIO;
 10006c4:	f06f 0404 	mvn.w	r4, #4
		LOG_ERR("ACL BR/EDR buffers not initialized");
 10006c8:	f026 fa8a 	bl	1026be0 <z_log_msg_static_create.constprop.0>
	if (err) {
 10006cc:	e6d5      	b.n	100047a <bt_init+0xf2>
 10006ce:	2108      	movs	r1, #8
 10006d0:	300c      	adds	r0, #12
 10006d2:	f01d fde1 	bl	101e298 <net_buf_simple_add>
	if (IS_ENABLED(CONFIG_BT_SMP) &&
 10006d6:	f895 30d0 	ldrb.w	r3, [r5, #208]	; 0xd0
 10006da:	4602      	mov	r2, r0
 10006dc:	07d9      	lsls	r1, r3, #31
 10006de:	d431      	bmi.n	1000744 <bt_init+0x3bc>
		mask |= BT_EVT_MASK_REMOTE_VERSION_INFO;
 10006e0:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
 10006e4:	4836      	ldr	r0, [pc, #216]	; (10007c0 <bt_init+0x438>)
	sys_put_le64(mask, ev->events);
 10006e6:	f026 fa86 	bl	1026bf6 <sys_put_le64>
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
 10006ea:	4621      	mov	r1, r4
 10006ec:	2200      	movs	r2, #0
 10006ee:	f640 4001 	movw	r0, #3073	; 0xc01
 10006f2:	f007 fc21 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 10006f6:	4604      	mov	r4, r0
 10006f8:	2800      	cmp	r0, #0
 10006fa:	f47f aebe 	bne.w	100047a <bt_init+0xf2>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
 10006fe:	4601      	mov	r1, r0
 1000700:	aa01      	add	r2, sp, #4
 1000702:	f64f 4001 	movw	r0, #64513	; 0xfc01
 1000706:	f007 fc17 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 100070a:	4604      	mov	r4, r0
 100070c:	b1f0      	cbz	r0, 100074c <bt_init+0x3c4>
		LOG_WRN("Vendor HCI extensions not available");
 100070e:	4b2d      	ldr	r3, [pc, #180]	; (10007c4 <bt_init+0x43c>)
			LOG_WRN("Failed to read supported vendor features");
 1000710:	9307      	str	r3, [sp, #28]
 1000712:	2302      	movs	r3, #2
 1000714:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 1000718:	4828      	ldr	r0, [pc, #160]	; (10007bc <bt_init+0x434>)
 100071a:	aa06      	add	r2, sp, #24
 100071c:	9306      	str	r3, [sp, #24]
 100071e:	f026 fa5f 	bl	1026be0 <z_log_msg_static_create.constprop.0>
	err = bt_id_init();
 1000722:	f026 fc29 	bl	1026f78 <bt_id_init>
	if (err) {
 1000726:	4604      	mov	r4, r0
 1000728:	2800      	cmp	r0, #0
 100072a:	f47f aea6 	bne.w	100047a <bt_init+0xf2>
		err = bt_conn_init();
 100072e:	f00a f9d7 	bl	100aae0 <bt_conn_init>
		if (err) {
 1000732:	4604      	mov	r4, r0
 1000734:	2800      	cmp	r0, #0
 1000736:	f47f aea0 	bne.w	100047a <bt_init+0xf2>
}
 100073a:	b008      	add	sp, #32
 100073c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 1000740:	f008 b876 	b.w	1008830 <bt_init.part.0>
		mask |= BT_EVT_MASK_ENCRYPT_KEY_REFRESH_COMPLETE;
 1000744:	a11a      	add	r1, pc, #104	; (adr r1, 10007b0 <bt_init+0x428>)
 1000746:	e9d1 0100 	ldrd	r0, r1, [r1]
 100074a:	e7cc      	b.n	10006e6 <bt_init+0x35e>
	net_buf_unref(rsp);
 100074c:	9801      	ldr	r0, [sp, #4]
 100074e:	f01d fc47 	bl	101dfe0 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
 1000752:	4621      	mov	r1, r4
 1000754:	f64f 4002 	movw	r0, #64514	; 0xfc02
 1000758:	aa01      	add	r2, sp, #4
 100075a:	f007 fbed 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 100075e:	4604      	mov	r4, r0
 1000760:	b108      	cbz	r0, 1000766 <bt_init+0x3de>
		LOG_WRN("Failed to read supported vendor commands");
 1000762:	4b19      	ldr	r3, [pc, #100]	; (10007c8 <bt_init+0x440>)
 1000764:	e7d4      	b.n	1000710 <bt_init+0x388>
	rp.cmds = (void *)rsp->data;
 1000766:	9e01      	ldr	r6, [sp, #4]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
 1000768:	2202      	movs	r2, #2
 100076a:	68f1      	ldr	r1, [r6, #12]
 100076c:	4817      	ldr	r0, [pc, #92]	; (10007cc <bt_init+0x444>)
 100076e:	3101      	adds	r1, #1
 1000770:	f026 f900 	bl	1026974 <memcpy>
	net_buf_unref(rsp);
 1000774:	4630      	mov	r0, r6
 1000776:	f01d fc33 	bl	101dfe0 <net_buf_unref>
	if (BT_VS_CMD_SUP_FEAT(bt_dev.vs_commands)) {
 100077a:	f895 30b9 	ldrb.w	r3, [r5, #185]	; 0xb9
 100077e:	075b      	lsls	r3, r3, #29
 1000780:	d5cf      	bpl.n	1000722 <bt_init+0x39a>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
 1000782:	4621      	mov	r1, r4
 1000784:	f64f 4003 	movw	r0, #64515	; 0xfc03
 1000788:	aa01      	add	r2, sp, #4
 100078a:	f007 fbd5 	bl	1007f38 <bt_hci_cmd_send_sync>
		if (err) {
 100078e:	b108      	cbz	r0, 1000794 <bt_init+0x40c>
			LOG_WRN("Failed to read supported vendor features");
 1000790:	4b0f      	ldr	r3, [pc, #60]	; (10007d0 <bt_init+0x448>)
 1000792:	e7bd      	b.n	1000710 <bt_init+0x388>
		memcpy(bt_dev.vs_features, rp.feat->features,
 1000794:	2201      	movs	r2, #1
		rp.feat = (void *)rsp->data;
 1000796:	9c01      	ldr	r4, [sp, #4]
		memcpy(bt_dev.vs_features, rp.feat->features,
 1000798:	480e      	ldr	r0, [pc, #56]	; (10007d4 <bt_init+0x44c>)
 100079a:	68e1      	ldr	r1, [r4, #12]
 100079c:	4411      	add	r1, r2
 100079e:	f026 f8e9 	bl	1026974 <memcpy>
		net_buf_unref(rsp);
 10007a2:	4620      	mov	r0, r4
 10007a4:	f01d fc1c 	bl	101dfe0 <net_buf_unref>
 10007a8:	e7bb      	b.n	1000722 <bt_init+0x39a>
 10007aa:	bf00      	nop
 10007ac:	f3af 8000 	nop.w
 10007b0:	02008890 	.word	0x02008890
 10007b4:	20008000 	.word	0x20008000
 10007b8:	0102d38c 	.word	0x0102d38c
 10007bc:	010299a4 	.word	0x010299a4
 10007c0:	02008810 	.word	0x02008810
 10007c4:	0102d3af 	.word	0x0102d3af
 10007c8:	0102d3d3 	.word	0x0102d3d3
 10007cc:	210000b9 	.word	0x210000b9
 10007d0:	0102d3fc 	.word	0x0102d3fc
 10007d4:	210000b8 	.word	0x210000b8

010007d8 <ull_drift_ticks_get>:
 * @param ticks_drift_minus[out] Negative part of drift uncertainty window
 */
void ull_drift_ticks_get(struct node_rx_event_done *done,
			 uint32_t *ticks_drift_plus,
			 uint32_t *ticks_drift_minus)
{
 10007d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 10007dc:	460e      	mov	r6, r1

	start_to_address_actual_us =
		done->extra.drift.start_to_address_actual_us;
	window_widening_event_us =
		done->extra.drift.window_widening_event_us;
	preamble_to_addr_us =
 10007de:	e9d0 170c 	ldrd	r1, r7, [r0, #48]	; 0x30
	start_to_address_actual_us =
 10007e2:	f8d0 802c 	ldr.w	r8, [r0, #44]	; 0x2c
		done->extra.drift.preamble_to_addr_us;

	start_to_address_expected_us = EVENT_JITTER_US +
				       EVENT_TICKER_RES_MARGIN_US +
				       window_widening_event_us +
 10007e6:	19cc      	adds	r4, r1, r7
	start_to_address_expected_us = EVENT_JITTER_US +
 10007e8:	3430      	adds	r4, #48	; 0x30
				       preamble_to_addr_us;

	if (start_to_address_actual_us <= start_to_address_expected_us) {
 10007ea:	45a0      	cmp	r8, r4
{
 10007ec:	4615      	mov	r5, r2
	if (start_to_address_actual_us <= start_to_address_expected_us) {
 10007ee:	d819      	bhi.n	1000824 <ull_drift_ticks_get+0x4c>
		*ticks_drift_plus =
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
 10007f0:	a31b      	add	r3, pc, #108	; (adr r3, 1000860 <ull_drift_ticks_get+0x88>)
 10007f2:	e9d3 2300 	ldrd	r2, r3, [r3]
 10007f6:	4f1c      	ldr	r7, [pc, #112]	; (1000868 <ull_drift_ticks_get+0x90>)
 10007f8:	fba1 0107 	umull	r0, r1, r1, r7
 10007fc:	f7ff fc5c 	bl	10000b8 <__aeabi_uldivmod>
 1000800:	4603      	mov	r3, r0
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
 1000802:	eba4 0008 	sub.w	r0, r4, r8
 1000806:	fba0 0107 	umull	r0, r1, r0, r7
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
 100080a:	f023 447f 	bic.w	r4, r3, #4278190080	; 0xff000000
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
 100080e:	a314      	add	r3, pc, #80	; (adr r3, 1000860 <ull_drift_ticks_get+0x88>)
 1000810:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000814:	f7ff fc50 	bl	10000b8 <__aeabi_uldivmod>
 1000818:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
 100081c:	6034      	str	r4, [r6, #0]
		*ticks_drift_minus =
 100081e:	6028      	str	r0, [r5, #0]
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
					       EVENT_TICKER_RES_MARGIN_US +
					       preamble_to_addr_us);
	}
}
 1000820:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
 1000824:	f8df 9040 	ldr.w	r9, [pc, #64]	; 1000868 <ull_drift_ticks_get+0x90>
 1000828:	a30d      	add	r3, pc, #52	; (adr r3, 1000860 <ull_drift_ticks_get+0x88>)
 100082a:	e9d3 2300 	ldrd	r2, r3, [r3]
 100082e:	fba8 0109 	umull	r0, r1, r8, r9
 1000832:	f7ff fc41 	bl	10000b8 <__aeabi_uldivmod>
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
 1000836:	a30a      	add	r3, pc, #40	; (adr r3, 1000860 <ull_drift_ticks_get+0x88>)
 1000838:	e9d3 2300 	ldrd	r2, r3, [r3]
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
 100083c:	4604      	mov	r4, r0
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
 100083e:	f107 0030 	add.w	r0, r7, #48	; 0x30
 1000842:	fba0 0109 	umull	r0, r1, r0, r9
 1000846:	f7ff fc37 	bl	10000b8 <__aeabi_uldivmod>
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
 100084a:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
 100084e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
 1000852:	6034      	str	r4, [r6, #0]
		*ticks_drift_minus =
 1000854:	6028      	str	r0, [r5, #0]
}
 1000856:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 100085a:	bf00      	nop
 100085c:	f3af 8000 	nop.w
 1000860:	1afd498d 	.word	0x1afd498d
 1000864:	00000007 	.word	0x00000007
 1000868:	3b9aca00 	.word	0x3b9aca00
 100086c:	00000000 	.word	0x00000000

01000870 <ll_adv_enable>:
	struct ll_adv_set *adv;
	struct lll_adv *lll;
	uint8_t hci_err;
	uint32_t ret;

	if (!enable) {
 1000870:	2800      	cmp	r0, #0
 1000872:	f000 8163 	beq.w	1000b3c <ll_adv_enable+0x2cc>
{
 1000876:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
static inline struct ll_adv_set *is_disabled_get(uint8_t handle)
{
	struct ll_adv_set *adv;

	adv = ull_adv_set_get(handle);
	if (!adv || adv->is_enabled) {
 100087a:	4cb7      	ldr	r4, [pc, #732]	; (1000b58 <ll_adv_enable+0x2e8>)
{
 100087c:	b08f      	sub	sp, #60	; 0x3c
	if (!adv || adv->is_enabled) {
 100087e:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
 1000882:	07da      	lsls	r2, r3, #31
 1000884:	f100 81aa 	bmi.w	1000bdc <ll_adv_enable+0x36c>
	lll_adv_pdu_enqueue(&lll->adv_data, idx);
}

static inline struct pdu_adv *lll_adv_data_peek(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 1000888:	f894 2029 	ldrb.w	r2, [r4, #41]	; 0x29
	lll_adv_pdu_enqueue(&lll->scan_rsp, idx);
}

static inline struct pdu_adv *lll_adv_scan_rsp_peek(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 100088c:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 1000890:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 1000894:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 1000896:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 100089a:	f8d3 8038 	ldr.w	r8, [r3, #56]	; 0x38
#endif /* CONFIG_BT_CTLR_ADV_EXT */
	} else {
		pdu_adv_to_update = pdu;
	}

	if (pdu_adv_to_update) {
 100089e:	b376      	cbz	r6, 10008fe <ll_adv_enable+0x8e>
#if defined(CONFIG_BT_CTLR_ADV_EXT)
		} else if (ll_adv_cmds_is_ext() && pdu->tx_addr) {
			own_id_addr = adv->rnd_addr;
#endif
		} else {
			own_id_addr = ll_addr_get(pdu->tx_addr);
 10008a0:	4637      	mov	r7, r6
 10008a2:	f817 0b02 	ldrb.w	r0, [r7], #2
 10008a6:	f3c0 1080 	ubfx	r0, r0, #6, #1
 10008aa:	f011 fd13 	bl	10122d4 <ll_addr_get>
 10008ae:	4605      	mov	r5, r0
		}
	}

#if defined(CONFIG_BT_CTLR_CHECK_SAME_PEER_CONN)
	(void)memcpy(adv->own_id_addr, own_id_addr, BDADDR_SIZE);
 10008b0:	2206      	movs	r2, #6
 10008b2:	4629      	mov	r1, r5
 10008b4:	f104 006b 	add.w	r0, r4, #107	; 0x6b
 10008b8:	f026 f85c 	bl	1026974 <memcpy>
	} else {
		tx_addr = own_id_addr;
	}

	adv_addr = adv_pdu_adva_get(pdu);
	memcpy(adv_addr, tx_addr, BDADDR_SIZE);
 10008bc:	4629      	mov	r1, r5
 10008be:	2206      	movs	r2, #6
 10008c0:	4638      	mov	r0, r7
 10008c2:	f026 f857 	bl	1026974 <memcpy>
		if (pdu_adv_to_update->tx_addr &&
 10008c6:	7833      	ldrb	r3, [r6, #0]
 10008c8:	065b      	lsls	r3, r3, #25
 10008ca:	d506      	bpl.n	10008da <ll_adv_enable+0x6a>
		    !mem_nz((void *)adv_addr, BDADDR_SIZE)) {
 10008cc:	2106      	movs	r1, #6
 10008ce:	4638      	mov	r0, r7
 10008d0:	f010 faf6 	bl	1010ec0 <mem_nz>
		if (pdu_adv_to_update->tx_addr &&
 10008d4:	2800      	cmp	r0, #0
 10008d6:	f000 8183 	beq.w	1000be0 <ll_adv_enable+0x370>
			own_id_addr = ll_addr_get(pdu->tx_addr);
 10008da:	4647      	mov	r7, r8
 10008dc:	f817 0b02 	ldrb.w	r0, [r7], #2
 10008e0:	f3c0 1080 	ubfx	r0, r0, #6, #1
 10008e4:	f011 fcf6 	bl	10122d4 <ll_addr_get>
 10008e8:	4605      	mov	r5, r0
	(void)memcpy(adv->own_id_addr, own_id_addr, BDADDR_SIZE);
 10008ea:	2206      	movs	r2, #6
 10008ec:	4629      	mov	r1, r5
 10008ee:	489b      	ldr	r0, [pc, #620]	; (1000b5c <ll_adv_enable+0x2ec>)
 10008f0:	f026 f840 	bl	1026974 <memcpy>
	memcpy(adv_addr, tx_addr, BDADDR_SIZE);
 10008f4:	4629      	mov	r1, r5
 10008f6:	4638      	mov	r0, r7
 10008f8:	2206      	movs	r2, #6
 10008fa:	f026 f83b 	bl	1026974 <memcpy>
	if ((pdu_adv->type == PDU_ADV_TYPE_ADV_IND) ||
 10008fe:	7833      	ldrb	r3, [r6, #0]
 1000900:	f013 0f0e 	tst.w	r3, #14
 1000904:	f040 80b2 	bne.w	1000a6c <ll_adv_enable+0x1fc>
		if (lll->conn) {
 1000908:	6a23      	ldr	r3, [r4, #32]
 100090a:	b11b      	cbz	r3, 1000914 <ll_adv_enable+0xa4>
	return BT_HCI_ERR_CMD_DISALLOWED;
 100090c:	200c      	movs	r0, #12
}
 100090e:	b00f      	add	sp, #60	; 0x3c
 1000910:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		link = ll_rx_link_alloc();
 1000914:	f013 fcc0 	bl	1014298 <ll_rx_link_alloc>
		if (!link) {
 1000918:	4681      	mov	r9, r0
 100091a:	2800      	cmp	r0, #0
 100091c:	f000 816e 	beq.w	1000bfc <ll_adv_enable+0x38c>
		node_rx = ll_rx_alloc();
 1000920:	f013 fcc6 	bl	10142b0 <ll_rx_alloc>
		if (!node_rx) {
 1000924:	4682      	mov	sl, r0
 1000926:	2800      	cmp	r0, #0
 1000928:	f000 8165 	beq.w	1000bf6 <ll_adv_enable+0x386>
		conn = ll_conn_acquire();
 100092c:	f015 f8ee 	bl	1015b0c <ll_conn_acquire>
		if (!conn) {
 1000930:	4605      	mov	r5, r0
 1000932:	2800      	cmp	r0, #0
 1000934:	f000 8164 	beq.w	1000c00 <ll_adv_enable+0x390>
		conn_lll->handle = 0xFFFF;
 1000938:	f64f 73ff 	movw	r3, #65535	; 0xffff
 100093c:	8503      	strh	r3, [r0, #40]	; 0x28
		if (!conn_lll->link_tx_free) {
 100093e:	f8d0 0088 	ldr.w	r0, [r0, #136]	; 0x88
		conn_lll = &conn->lll;
 1000942:	f105 031c 	add.w	r3, r5, #28
 1000946:	930b      	str	r3, [sp, #44]	; 0x2c
		if (!conn_lll->link_tx_free) {
 1000948:	2800      	cmp	r0, #0
 100094a:	f000 814f 	beq.w	1000bec <ll_adv_enable+0x37c>
		memq_init(conn_lll->link_tx_free, &conn_lll->memq_tx.head,
 100094e:	f105 027c 	add.w	r2, r5, #124	; 0x7c
 1000952:	f105 0178 	add.w	r1, r5, #120	; 0x78
 1000956:	f010 fabf 	bl	1010ed8 <memq_init>
		conn->apto_expire = 0U;
 100095a:	f44f 23c0 	mov.w	r3, #393216	; 0x60000
		conn->own_id_addr_type = BT_ADDR_LE_NONE->type;
 100095e:	f8df b200 	ldr.w	fp, [pc, #512]	; 1000b60 <ll_adv_enable+0x2f0>
		conn_lll->link_tx_free = NULL;
 1000962:	2700      	movs	r7, #0
		conn->own_id_addr_type = BT_ADDR_LE_NONE->type;
 1000964:	4659      	mov	r1, fp
		conn->apto_expire = 0U;
 1000966:	f8c5 3180 	str.w	r3, [r5, #384]	; 0x180
			conn_lll->phy_tx = PHY_1M;
 100096a:	f8b5 3076 	ldrh.w	r3, [r5, #118]	; 0x76
		conn_lll->sn = 0;
 100096e:	f895 208e 	ldrb.w	r2, [r5, #142]	; 0x8e
			conn_lll->phy_tx = PHY_1M;
 1000972:	f423 63ef 	bic.w	r3, r3, #1912	; 0x778
 1000976:	f023 0307 	bic.w	r3, r3, #7
 100097a:	f443 7388 	orr.w	r3, r3, #272	; 0x110
 100097e:	f043 0301 	orr.w	r3, r3, #1
 1000982:	f8a5 3076 	strh.w	r3, [r5, #118]	; 0x76
		conn_lll->data_chan_sel = 0;
 1000986:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
		conn_lll->sn = 0;
 100098a:	f022 0207 	bic.w	r2, r2, #7
 100098e:	f885 208e 	strb.w	r2, [r5, #142]	; 0x8e
		conn_lll->data_chan_sel = 0;
 1000992:	f003 033f 	and.w	r3, r3, #63	; 0x3f
		conn_lll->periph.initiated = 0;
 1000996:	f895 203c 	ldrb.w	r2, [r5, #60]	; 0x3c
		conn_lll->data_chan_sel = 0;
 100099a:	f063 037f 	orn	r3, r3, #127	; 0x7f
 100099e:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
		conn_lll->periph.initiated = 0;
 10009a2:	f022 0207 	bic.w	r2, r2, #7
		conn->own_id_addr_type = BT_ADDR_LE_NONE->type;
 10009a6:	f811 3b01 	ldrb.w	r3, [r1], #1
		conn_lll->periph.initiated = 0;
 10009aa:	f885 203c 	strb.w	r2, [r5, #60]	; 0x3c
		conn->own_id_addr_type = BT_ADDR_LE_NONE->type;
 10009ae:	f895 2192 	ldrb.w	r2, [r5, #402]	; 0x192
 10009b2:	f003 0301 	and.w	r3, r3, #1
 10009b6:	f363 0200 	bfi	r2, r3, #0, #1
 10009ba:	f885 2192 	strb.w	r2, [r5, #402]	; 0x192
		conn_lll->periph.window_widening_event_us = 0;
 10009be:	e9c5 7712 	strd	r7, r7, [r5, #72]	; 0x48
		(void)memcpy(conn->own_id_addr, BT_ADDR_LE_NONE->a.val,
 10009c2:	2206      	movs	r2, #6
		conn_lll->link_tx_free = NULL;
 10009c4:	f8c5 7088 	str.w	r7, [r5, #136]	; 0x88
		conn_lll->packet_tx_head_len = 0;
 10009c8:	f8a5 708c 	strh.w	r7, [r5, #140]	; 0x8c
		conn_lll->event_counter = 0;
 10009cc:	866f      	strh	r7, [r5, #50]	; 0x32
		conn_lll->latency_prepare = 0;
 10009ce:	f8c5 702e 	str.w	r7, [r5, #46]	; 0x2e
		conn_lll->data_chan_use = 0;
 10009d2:	f885 703b 	strb.w	r7, [r5, #59]	; 0x3b
		conn_lll->periph.window_size_prepare_us = 0;
 10009d6:	652f      	str	r7, [r5, #80]	; 0x50
		conn->supervision_expire = 0;
 10009d8:	f8a5 7186 	strh.w	r7, [r5, #390]	; 0x186
		conn->appto_expire = 0U;
 10009dc:	f8a5 717c 	strh.w	r7, [r5, #380]	; 0x17c
		(void)memcpy(conn->own_id_addr, BT_ADDR_LE_NONE->a.val,
 10009e0:	f205 1093 	addw	r0, r5, #403	; 0x193
		conn->own_id_addr_type = BT_ADDR_LE_NONE->type;
 10009e4:	930b      	str	r3, [sp, #44]	; 0x2c
		(void)memcpy(conn->own_id_addr, BT_ADDR_LE_NONE->a.val,
 10009e6:	f025 ffc5 	bl	1026974 <memcpy>
		conn->peer_id_addr_type = BT_ADDR_LE_NONE->type;
 10009ea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 10009ec:	f895 2192 	ldrb.w	r2, [r5, #402]	; 0x192
		(void)memcpy(conn->peer_id_addr, BT_ADDR_LE_NONE->a.val,
 10009f0:	f10b 0101 	add.w	r1, fp, #1
		conn->peer_id_addr_type = BT_ADDR_LE_NONE->type;
 10009f4:	f363 0241 	bfi	r2, r3, #1, #1
 10009f8:	f885 2192 	strb.w	r2, [r5, #402]	; 0x192
		(void)memcpy(conn->peer_id_addr, BT_ADDR_LE_NONE->a.val,
 10009fc:	f205 1099 	addw	r0, r5, #409	; 0x199
 1000a00:	2206      	movs	r2, #6
 1000a02:	f025 ffb7 	bl	1026974 <memcpy>
		ull_llcp_init(conn);
 1000a06:	4628      	mov	r0, r5
 1000a08:	f017 fb44 	bl	1018094 <ull_llcp_init>
		conn->llcp_terminate.reason_final = 0;
 1000a0c:	f885 7148 	strb.w	r7, [r5, #328]	; 0x148
		conn->llcp_terminate.node_rx.hdr.link = link;
 1000a10:	f8c5 914c 	str.w	r9, [r5, #332]	; 0x14c
		conn->phy_pref_tx = ull_conn_default_phy_tx_get();
 1000a14:	f015 fb40 	bl	1016098 <ull_conn_default_phy_tx_get>
 1000a18:	f895 318c 	ldrb.w	r3, [r5, #396]	; 0x18c
 1000a1c:	f360 0302 	bfi	r3, r0, #0, #3
 1000a20:	f885 318c 	strb.w	r3, [r5, #396]	; 0x18c
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
 1000a24:	f015 fb3e 	bl	10160a4 <ull_conn_default_phy_rx_get>
 1000a28:	f895 318c 	ldrb.w	r3, [r5, #396]	; 0x18c
		ull_dle_init(conn, phy_in_use);
 1000a2c:	2101      	movs	r1, #1
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
 1000a2e:	f360 03c5 	bfi	r3, r0, #3, #3
 1000a32:	f885 318c 	strb.w	r3, [r5, #396]	; 0x18c
		conn->pause_rx_data = 0U;
 1000a36:	f895 3178 	ldrb.w	r3, [r5, #376]	; 0x178
		ull_dle_init(conn, phy_in_use);
 1000a3a:	4628      	mov	r0, r5
		conn->pause_rx_data = 0U;
 1000a3c:	f367 0341 	bfi	r3, r7, #1, #1
 1000a40:	f885 3178 	strb.w	r3, [r5, #376]	; 0x178
		ull_dle_init(conn, phy_in_use);
 1000a44:	f016 f8d8 	bl	1016bf8 <ull_dle_init>
		ull_tx_q_init(&conn->tx_q);
 1000a48:	f105 00d4 	add.w	r0, r5, #212	; 0xd4
 1000a4c:	f017 f90c 	bl	1017c68 <ull_tx_q_init>
		lll->conn = conn_lll;
 1000a50:	f105 031c 	add.w	r3, r5, #28
		adv->node_rx_cc_free = node_rx;
 1000a54:	e9c4 9a18 	strd	r9, sl, [r4, #96]	; 0x60
		lll->conn = conn_lll;
 1000a58:	6223      	str	r3, [r4, #32]
}

static inline void ull_hdr_init(struct ull_hdr *hdr)
{
	hdr->ref = 0U;
	hdr->disabled_cb = hdr->disabled_param = NULL;
 1000a5a:	e9c5 7705 	strd	r7, r7, [r5, #20]
	hdr->ref = 0U;
 1000a5e:	702f      	strb	r7, [r5, #0]

static inline void lll_hdr_init(void *lll, void *parent)
{
	struct lll_hdr *hdr = lll;

	hdr->parent = parent;
 1000a60:	61ed      	str	r5, [r5, #28]
		err = lll_clock_wait();
 1000a62:	f01b f865 	bl	101bb30 <lll_clock_wait>
		if (err) {
 1000a66:	2800      	cmp	r0, #0
 1000a68:	f040 80bc 	bne.w	1000be4 <ll_adv_enable+0x374>
	uint8_t ch_map = lll->chan_map;
 1000a6c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
 1000a70:	2101      	movs	r1, #1
	uint8_t ch_map = lll->chan_map;
 1000a72:	f3c3 0342 	ubfx	r3, r3, #1, #3
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
 1000a76:	f10d 0033 	add.w	r0, sp, #51	; 0x33
	uint8_t ch_map = lll->chan_map;
 1000a7a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
 1000a7e:	f010 fbb5 	bl	10111ec <util_ones_count_get>
	if (adv_chn_cnt == 0) {
 1000a82:	4602      	mov	r2, r0
 1000a84:	2800      	cmp	r0, #0
 1000a86:	d05b      	beq.n	1000b40 <ll_adv_enable+0x2d0>
	uint16_t time_us = adv_time_get(pdu_adv, pdu_scan, adv_chn_cnt, phy,
 1000a88:	f898 1001 	ldrb.w	r1, [r8, #1]
 1000a8c:	4630      	mov	r0, r6
 1000a8e:	f014 fb49 	bl	1015124 <adv_time_get.constprop.0.isra.0>
 1000a92:	2500      	movs	r5, #0
	adv->ull.ticks_prepare_to_start =
 1000a94:	2331      	movs	r3, #49	; 0x31
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
 1000a96:	4933      	ldr	r1, [pc, #204]	; (1000b64 <ll_adv_enable+0x2f4>)
	adv->ull.ticks_prepare_to_start =
 1000a98:	60a3      	str	r3, [r4, #8]
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
 1000a9a:	fba0 0101 	umull	r0, r1, r0, r1
 1000a9e:	a32c      	add	r3, pc, #176	; (adr r3, 1000b50 <ll_adv_enable+0x2e0>)
 1000aa0:	e9d3 2300 	ldrd	r2, r3, [r3]
	hdr->disabled_cb = hdr->disabled_param = NULL;
 1000aa4:	e9c4 5505 	strd	r5, r5, [r4, #20]
	hdr->ref = 0U;
 1000aa8:	7025      	strb	r5, [r4, #0]
	adv->ull.ticks_active_to_start = 0;
 1000aaa:	6065      	str	r5, [r4, #4]
	adv->ull.ticks_preempt_to_start =
 1000aac:	60e5      	str	r5, [r4, #12]
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
 1000aae:	f7ff fb03 	bl	10000b8 <__aeabi_uldivmod>
 1000ab2:	6120      	str	r0, [r4, #16]
	uint16_t interval = adv->interval;
 1000ab4:	f8b4 7068 	ldrh.w	r7, [r4, #104]	; 0x68
	ticks_anchor = ticker_ticks_now_get();
 1000ab8:	f011 fbea 	bl	1012290 <ticker_ticks_now_get>
	ticks_anchor += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);
 1000abc:	f100 0809 	add.w	r8, r0, #9
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
 1000ac0:	b93f      	cbnz	r7, 1000ad2 <ll_adv_enable+0x262>
 1000ac2:	7835      	ldrb	r5, [r6, #0]
 1000ac4:	f005 050f 	and.w	r5, r5, #15
 1000ac8:	f1a5 0501 	sub.w	r5, r5, #1
 1000acc:	fab5 f585 	clz	r5, r5
 1000ad0:	096d      	lsrs	r5, r5, #5
 1000ad2:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
				   (adv->ull.ticks_slot + ticks_slot_overhead),
 1000ad6:	6923      	ldr	r3, [r4, #16]
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
 1000ad8:	f365 0000 	bfi	r0, r5, #0, #1
	if (lll->is_hdcd) {
 1000adc:	f010 0501 	ands.w	r5, r0, #1
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
 1000ae0:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
	if (lll->is_hdcd) {
 1000ae4:	d046      	beq.n	1000b74 <ll_adv_enable+0x304>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000ae6:	2000      	movs	r0, #0
		ret_cb = TICKER_STATUS_BUSY;
 1000ae8:	2502      	movs	r5, #2
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000aea:	4a1f      	ldr	r2, [pc, #124]	; (1000b68 <ll_adv_enable+0x2f8>)
 1000aec:	4f1f      	ldr	r7, [pc, #124]	; (1000b6c <ll_adv_enable+0x2fc>)
 1000aee:	ae0d      	add	r6, sp, #52	; 0x34
 1000af0:	2103      	movs	r1, #3
 1000af2:	9304      	str	r3, [sp, #16]
 1000af4:	9301      	str	r3, [sp, #4]
 1000af6:	9205      	str	r2, [sp, #20]
 1000af8:	4643      	mov	r3, r8
 1000afa:	462a      	mov	r2, r5
 1000afc:	e9cd 0002 	strd	r0, r0, [sp, #8]
 1000b00:	9608      	str	r6, [sp, #32]
 1000b02:	9406      	str	r4, [sp, #24]
 1000b04:	9707      	str	r7, [sp, #28]
 1000b06:	9000      	str	r0, [sp, #0]
		ret_cb = TICKER_STATUS_BUSY;
 1000b08:	950d      	str	r5, [sp, #52]	; 0x34
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000b0a:	f011 fac7 	bl	101209c <ticker_start>
		ret = ull_ticker_status_take(ret, &ret_cb);
 1000b0e:	4631      	mov	r1, r6
 1000b10:	f013 fc8a 	bl	1014428 <ull_ticker_status_take>
		if (ret != TICKER_STATUS_SUCCESS) {
 1000b14:	b9a0      	cbnz	r0, 1000b40 <ll_adv_enable+0x2d0>
		ret_cb = TICKER_STATUS_BUSY;
 1000b16:	950d      	str	r5, [sp, #52]	; 0x34
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000b18:	f24a 35d8 	movw	r5, #41944	; 0xa3d8
 1000b1c:	4a14      	ldr	r2, [pc, #80]	; (1000b70 <ll_adv_enable+0x300>)
 1000b1e:	4643      	mov	r3, r8
 1000b20:	9205      	str	r2, [sp, #20]
 1000b22:	2103      	movs	r1, #3
 1000b24:	2201      	movs	r2, #1
 1000b26:	e9cd 0003 	strd	r0, r0, [sp, #12]
 1000b2a:	e9cd 0001 	strd	r0, r0, [sp, #4]
 1000b2e:	9707      	str	r7, [sp, #28]
 1000b30:	9608      	str	r6, [sp, #32]
 1000b32:	9406      	str	r4, [sp, #24]
 1000b34:	9500      	str	r5, [sp, #0]
 1000b36:	f011 fab1 	bl	101209c <ticker_start>
 1000b3a:	e044      	b.n	1000bc6 <ll_adv_enable+0x356>
		return disable(handle);
 1000b3c:	f014 ba4e 	b.w	1014fdc <disable.constprop.0>
	if (adv->lll.conn) {
 1000b40:	6a23      	ldr	r3, [r4, #32]
 1000b42:	2b00      	cmp	r3, #0
 1000b44:	f43f aee2 	beq.w	100090c <ll_adv_enable+0x9c>
		conn_release(adv);
 1000b48:	f014 fa06 	bl	1014f58 <conn_release.constprop.0>
 1000b4c:	e6de      	b.n	100090c <ll_adv_enable+0x9c>
 1000b4e:	bf00      	nop
 1000b50:	1afd498d 	.word	0x1afd498d
 1000b54:	00000007 	.word	0x00000007
 1000b58:	21006c80 	.word	0x21006c80
 1000b5c:	21006ceb 	.word	0x21006ceb
 1000b60:	0102cb72 	.word	0x0102cb72
 1000b64:	3b9aca00 	.word	0x3b9aca00
 1000b68:	0101519d 	.word	0x0101519d
 1000b6c:	010139e1 	.word	0x010139e1
 1000b70:	01014cf1 	.word	0x01014cf1
		ret = ticker_start_ext(
 1000b74:	f64f 72ff 	movw	r2, #65535	; 0xffff
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
 1000b78:	2191      	movs	r1, #145	; 0x91
		ret_cb = TICKER_STATUS_BUSY;
 1000b7a:	f04f 0902 	mov.w	r9, #2
		ret = ticker_start_ext(
 1000b7e:	9203      	str	r2, [sp, #12]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
 1000b80:	4825      	ldr	r0, [pc, #148]	; (1000c18 <ll_adv_enable+0x3a8>)
		ll_adv_ticker_ext[handle].ticks_slot_window =
 1000b82:	4a26      	ldr	r2, [pc, #152]	; (1000c1c <ll_adv_enable+0x3ac>)
		ret = ticker_start_ext(
 1000b84:	9304      	str	r3, [sp, #16]
			ULL_ADV_RANDOM_DELAY + ticks_slot;
 1000b86:	f203 1347 	addw	r3, r3, #327	; 0x147
		ret = ticker_start_ext(
 1000b8a:	9406      	str	r4, [sp, #24]
 1000b8c:	9502      	str	r5, [sp, #8]
		ll_adv_ticker_ext[handle].ticks_slot_window =
 1000b8e:	6013      	str	r3, [r2, #0]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
 1000b90:	fba7 0300 	umull	r0, r3, r7, r0
 1000b94:	fb01 3107 	mla	r1, r1, r7, r3
		ret = ticker_start_ext(
 1000b98:	4b21      	ldr	r3, [pc, #132]	; (1000c20 <ll_adv_enable+0x3b0>)
 1000b9a:	9209      	str	r2, [sp, #36]	; 0x24
 1000b9c:	9307      	str	r3, [sp, #28]
 1000b9e:	4b21      	ldr	r3, [pc, #132]	; (1000c24 <ll_adv_enable+0x3b4>)
 1000ba0:	ae0d      	add	r6, sp, #52	; 0x34
 1000ba2:	9305      	str	r3, [sp, #20]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
 1000ba4:	a31a      	add	r3, pc, #104	; (adr r3, 1000c10 <ll_adv_enable+0x3a0>)
 1000ba6:	e9d3 2300 	ldrd	r2, r3, [r3]
		ret_cb = TICKER_STATUS_BUSY;
 1000baa:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
		ret = ticker_start_ext(
 1000bae:	9608      	str	r6, [sp, #32]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
 1000bb0:	f7ff fa82 	bl	10000b8 <__aeabi_uldivmod>
 1000bb4:	4601      	mov	r1, r0
		ret = ticker_start_ext(
 1000bb6:	4643      	mov	r3, r8
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
 1000bb8:	9101      	str	r1, [sp, #4]
		ret = ticker_start_ext(
 1000bba:	464a      	mov	r2, r9
 1000bbc:	4628      	mov	r0, r5
 1000bbe:	2103      	movs	r1, #3
 1000bc0:	9500      	str	r5, [sp, #0]
 1000bc2:	f011 fa1d 	bl	1012000 <ticker_start_ext>
	ret = ull_ticker_status_take(ret, &ret_cb);
 1000bc6:	4631      	mov	r1, r6
 1000bc8:	f013 fc2e 	bl	1014428 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
 1000bcc:	2800      	cmp	r0, #0
 1000bce:	d1b7      	bne.n	1000b40 <ll_adv_enable+0x2d0>
	adv->is_enabled = 1;
 1000bd0:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
 1000bd4:	f043 0301 	orr.w	r3, r3, #1
 1000bd8:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a
			return 0;
 1000bdc:	2000      	movs	r0, #0
 1000bde:	e696      	b.n	100090e <ll_adv_enable+0x9e>
			return BT_HCI_ERR_INVALID_PARAM;
 1000be0:	2012      	movs	r0, #18
 1000be2:	e694      	b.n	100090e <ll_adv_enable+0x9e>
			conn_release(adv);
 1000be4:	f014 f9b8 	bl	1014f58 <conn_release.constprop.0>
			return BT_HCI_ERR_HW_FAILURE;
 1000be8:	2003      	movs	r0, #3
 1000bea:	e690      	b.n	100090e <ll_adv_enable+0x9e>
			conn_lll->link_tx_free = &conn_lll->link_tx;
 1000bec:	f105 0080 	add.w	r0, r5, #128	; 0x80
 1000bf0:	f8c5 0088 	str.w	r0, [r5, #136]	; 0x88
 1000bf4:	e6ab      	b.n	100094e <ll_adv_enable+0xde>
			ll_rx_link_release(link);
 1000bf6:	4648      	mov	r0, r9
 1000bf8:	f013 fb54 	bl	10142a4 <ll_rx_link_release>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
 1000bfc:	2007      	movs	r0, #7
 1000bfe:	e686      	b.n	100090e <ll_adv_enable+0x9e>
			ll_rx_release(node_rx);
 1000c00:	4650      	mov	r0, sl
 1000c02:	f013 fb5b 	bl	10142bc <ll_rx_release>
			ll_rx_link_release(link);
 1000c06:	4648      	mov	r0, r9
 1000c08:	f013 fb4c 	bl	10142a4 <ll_rx_link_release>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
 1000c0c:	e7f6      	b.n	1000bfc <ll_adv_enable+0x38c>
 1000c0e:	bf00      	nop
 1000c10:	1afd498d 	.word	0x1afd498d
 1000c14:	00000007 	.word	0x00000007
 1000c18:	84e72a00 	.word	0x84e72a00
 1000c1c:	21006c74 	.word	0x21006c74
 1000c20:	010139e1 	.word	0x010139e1
 1000c24:	0101519d 	.word	0x0101519d

01000c28 <ull_adv_time_update>:
{
 1000c28:	b570      	push	{r4, r5, r6, lr}
 1000c2a:	4604      	mov	r4, r0
	chan_map = lll->chan_map;
 1000c2c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
{
 1000c30:	b08a      	sub	sp, #40	; 0x28
	chan_map = lll->chan_map;
 1000c32:	f3c3 0342 	ubfx	r3, r3, #1, #3
{
 1000c36:	460d      	mov	r5, r1
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
 1000c38:	f10d 0023 	add.w	r0, sp, #35	; 0x23
 1000c3c:	2101      	movs	r1, #1
{
 1000c3e:	4616      	mov	r6, r2
	chan_map = lll->chan_map;
 1000c40:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
 1000c44:	f010 fad2 	bl	10111ec <util_ones_count_get>
	time_us = adv_time_get(pdu, pdu_scan, chan_cnt, phy, phy_flags);
 1000c48:	7871      	ldrb	r1, [r6, #1]
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
 1000c4a:	4602      	mov	r2, r0
	time_us = adv_time_get(pdu, pdu_scan, chan_cnt, phy, phy_flags);
 1000c4c:	4628      	mov	r0, r5
 1000c4e:	f014 fa69 	bl	1015124 <adv_time_get.constprop.0.isra.0>
	time_ticks = HAL_TICKER_US_TO_TICKS(time_us);
 1000c52:	a31f      	add	r3, pc, #124	; (adr r3, 1000cd0 <ull_adv_time_update+0xa8>)
 1000c54:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000c58:	4919      	ldr	r1, [pc, #100]	; (1000cc0 <ull_adv_time_update+0x98>)
 1000c5a:	fba0 0101 	umull	r0, r1, r0, r1
 1000c5e:	f7ff fa2b 	bl	10000b8 <__aeabi_uldivmod>
	if (adv->ull.ticks_slot > time_ticks) {
 1000c62:	6923      	ldr	r3, [r4, #16]
	time_ticks = HAL_TICKER_US_TO_TICKS(time_us);
 1000c64:	4605      	mov	r5, r0
	if (adv->ull.ticks_slot > time_ticks) {
 1000c66:	4298      	cmp	r0, r3
 1000c68:	d221      	bcs.n	1000cae <ull_adv_time_update+0x86>
		ticks_plus = 0U;
 1000c6a:	2200      	movs	r2, #0
		ticks_minus = adv->ull.ticks_slot - time_ticks;
 1000c6c:	1a19      	subs	r1, r3, r0
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 1000c6e:	9201      	str	r2, [sp, #4]
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
 1000c70:	4a14      	ldr	r2, [pc, #80]	; (1000cc4 <ull_adv_time_update+0x9c>)
 1000c72:	4b15      	ldr	r3, [pc, #84]	; (1000cc8 <ull_adv_time_update+0xa0>)
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 1000c74:	9102      	str	r1, [sp, #8]
	ret_cb = TICKER_STATUS_BUSY;
 1000c76:	2102      	movs	r1, #2
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
 1000c78:	1aa2      	subs	r2, r4, r2
 1000c7a:	fba3 3202 	umull	r3, r2, r3, r2
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 1000c7e:	2300      	movs	r3, #0
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
 1000c80:	0992      	lsrs	r2, r2, #6
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 1000c82:	440a      	add	r2, r1
	ret_cb = TICKER_STATUS_BUSY;
 1000c84:	9109      	str	r1, [sp, #36]	; 0x24
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 1000c86:	4911      	ldr	r1, [pc, #68]	; (1000ccc <ull_adv_time_update+0xa4>)
 1000c88:	ae09      	add	r6, sp, #36	; 0x24
 1000c8a:	9105      	str	r1, [sp, #20]
 1000c8c:	4618      	mov	r0, r3
 1000c8e:	2103      	movs	r1, #3
 1000c90:	e9cd 3303 	strd	r3, r3, [sp, #12]
 1000c94:	9606      	str	r6, [sp, #24]
 1000c96:	b2d2      	uxtb	r2, r2
 1000c98:	9300      	str	r3, [sp, #0]
 1000c9a:	f011 fa6f 	bl	101217c <ticker_update>
	ret = ull_ticker_status_take(ret, &ret_cb);
 1000c9e:	4631      	mov	r1, r6
 1000ca0:	f013 fbc2 	bl	1014428 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
 1000ca4:	b938      	cbnz	r0, 1000cb6 <ull_adv_time_update+0x8e>
	adv->ull.ticks_slot = time_ticks;
 1000ca6:	6125      	str	r5, [r4, #16]
		return BT_HCI_ERR_SUCCESS;
 1000ca8:	2000      	movs	r0, #0
}
 1000caa:	b00a      	add	sp, #40	; 0x28
 1000cac:	bd70      	pop	{r4, r5, r6, pc}
	} else if (adv->ull.ticks_slot < time_ticks) {
 1000cae:	d9fb      	bls.n	1000ca8 <ull_adv_time_update+0x80>
		ticks_minus = 0U;
 1000cb0:	2100      	movs	r1, #0
		ticks_plus = time_ticks - adv->ull.ticks_slot;
 1000cb2:	1aea      	subs	r2, r5, r3
 1000cb4:	e7db      	b.n	1000c6e <ull_adv_time_update+0x46>
		return BT_HCI_ERR_CMD_DISALLOWED;
 1000cb6:	200c      	movs	r0, #12
}
 1000cb8:	b00a      	add	sp, #40	; 0x28
 1000cba:	bd70      	pop	{r4, r5, r6, pc}
 1000cbc:	f3af 8000 	nop.w
 1000cc0:	3b9aca00 	.word	0x3b9aca00
 1000cc4:	21006c80 	.word	0x21006c80
 1000cc8:	8d3dcb09 	.word	0x8d3dcb09
 1000ccc:	010139e1 	.word	0x010139e1
 1000cd0:	1afd498d 	.word	0x1afd498d
 1000cd4:	00000007 	.word	0x00000007

01000cd8 <ull_conn_update_ticker.constprop.0>:
	/* Calculate current event counter */
	event_counter = lll->event_counter + lll->latency_prepare + lazy;

	return event_counter;
}
static void ull_conn_update_ticker(struct ll_conn *conn,
 1000cd8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1000cdc:	4605      	mov	r5, r0
 1000cde:	b08a      	sub	sp, #40	; 0x28
 1000ce0:	468a      	mov	sl, r1
#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* disable ticker job, in order to chain stop and start
	 * to avoid RTC being stopped if no tickers active.
	 */
	uint32_t mayfly_was_enabled =
		mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW);
 1000ce2:	2001      	movs	r0, #1
 1000ce4:	2102      	movs	r1, #2
static void ull_conn_update_ticker(struct ll_conn *conn,
 1000ce6:	4699      	mov	r9, r3
 1000ce8:	4614      	mov	r4, r2
		mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW);
 1000cea:	f01c fe7f 	bl	101d9ec <mayfly_is_enabled>

	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0U);
 1000cee:	2200      	movs	r2, #0
 1000cf0:	2102      	movs	r1, #2
		mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW);
 1000cf2:	4680      	mov	r8, r0
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0U);
 1000cf4:	2001      	movs	r0, #1
 1000cf6:	f010 f941 	bl	1010f7c <mayfly_enable>
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
 1000cfa:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 1000cfe:	4938      	ldr	r1, [pc, #224]	; (1000de0 <ull_conn_update_ticker.constprop.0+0x108>)
 1000d00:	4628      	mov	r0, r5
 1000d02:	f010 f8c9 	bl	1010e98 <mem_index_get>
 1000d06:	4606      	mov	r6, r0
#endif /* CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO */

	/* start periph/central with new timings */
	uint8_t ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 1000d08:	3603      	adds	r6, #3
 1000d0a:	b2f6      	uxtb	r6, r6
	uint32_t ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
 1000d0c:	4b35      	ldr	r3, [pc, #212]	; (1000de4 <ull_conn_update_ticker.constprop.0+0x10c>)
 1000d0e:	2101      	movs	r1, #1
 1000d10:	2000      	movs	r0, #0
 1000d12:	4632      	mov	r2, r6
 1000d14:	9500      	str	r5, [sp, #0]
 1000d16:	f011 fa4d 	bl	10121b4 <ticker_stop>
				    ticker_id_conn, ticker_stop_conn_op_cb, (void *)conn);
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 1000d1a:	f030 0302 	bics.w	r3, r0, #2
 1000d1e:	d00c      	beq.n	1000d3a <ull_conn_update_ticker.constprop.0+0x62>
 1000d20:	f641 731a 	movw	r3, #7962	; 0x1f1a
 1000d24:	4a30      	ldr	r2, [pc, #192]	; (1000de8 <ull_conn_update_ticker.constprop.0+0x110>)
 1000d26:	4931      	ldr	r1, [pc, #196]	; (1000dec <ull_conn_update_ticker.constprop.0+0x114>)
 1000d28:	4831      	ldr	r0, [pc, #196]	; (1000df0 <ull_conn_update_ticker.constprop.0+0x118>)
 1000d2a:	f023 ff54 	bl	1024bd6 <assert_print>
 1000d2e:	4040      	eors	r0, r0
 1000d30:	f380 8811 	msr	BASEPRI, r0
 1000d34:	f04f 0003 	mov.w	r0, #3
 1000d38:	df02      	svc	2
		  (ticker_status == TICKER_STATUS_BUSY));
	ticker_status = ticker_start(
		TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH, ticker_id_conn, ticks_at_expire,
		ticks_win_offset, HAL_TICKER_US_TO_TICKS(periodic_us),
 1000d3a:	a327      	add	r3, pc, #156	; (adr r3, 1000dd8 <ull_conn_update_ticker.constprop.0+0x100>)
 1000d3c:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000d40:	4f2c      	ldr	r7, [pc, #176]	; (1000df4 <ull_conn_update_ticker.constprop.0+0x11c>)
 1000d42:	fba4 4707 	umull	r4, r7, r4, r7
 1000d46:	4620      	mov	r0, r4
 1000d48:	4639      	mov	r1, r7
 1000d4a:	f7ff f9b5 	bl	10000b8 <__aeabi_uldivmod>
	ticker_status = ticker_start(
 1000d4e:	9508      	str	r5, [sp, #32]
 1000d50:	9506      	str	r5, [sp, #24]
 1000d52:	692b      	ldr	r3, [r5, #16]
		HAL_TICKER_REMAINDER(periodic_us),
 1000d54:	2207      	movs	r2, #7
	ticker_status = ticker_start(
 1000d56:	9304      	str	r3, [sp, #16]
 1000d58:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 1000d5c:	4926      	ldr	r1, [pc, #152]	; (1000df8 <ull_conn_update_ticker.constprop.0+0x120>)
 1000d5e:	9303      	str	r3, [sp, #12]
		HAL_TICKER_REMAINDER(periodic_us),
 1000d60:	4b26      	ldr	r3, [pc, #152]	; (1000dfc <ull_conn_update_ticker.constprop.0+0x124>)
 1000d62:	f020 457f 	bic.w	r5, r0, #4278190080	; 0xff000000
	ticker_status = ticker_start(
 1000d66:	9107      	str	r1, [sp, #28]
		HAL_TICKER_REMAINDER(periodic_us),
 1000d68:	fba5 3103 	umull	r3, r1, r5, r3
 1000d6c:	fb02 1105 	mla	r1, r2, r5, r1
 1000d70:	1ae0      	subs	r0, r4, r3
	ticker_status = ticker_start(
 1000d72:	4b23      	ldr	r3, [pc, #140]	; (1000e00 <ull_conn_update_ticker.constprop.0+0x128>)
		HAL_TICKER_REMAINDER(periodic_us),
 1000d74:	eb67 0101 	sbc.w	r1, r7, r1
 1000d78:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
	ticker_status = ticker_start(
 1000d7c:	9305      	str	r3, [sp, #20]
		HAL_TICKER_REMAINDER(periodic_us),
 1000d7e:	2300      	movs	r3, #0
 1000d80:	f7ff f99a 	bl	10000b8 <__aeabi_uldivmod>
	ticker_status = ticker_start(
 1000d84:	464b      	mov	r3, r9
 1000d86:	9002      	str	r0, [sp, #8]
 1000d88:	4632      	mov	r2, r6
 1000d8a:	2101      	movs	r1, #1
 1000d8c:	2000      	movs	r0, #0
 1000d8e:	e9cd a500 	strd	sl, r5, [sp]
 1000d92:	f011 f983 	bl	101209c <ticker_start>
		ull_periph_ticker_cb,
#else
		ull_central_ticker_cb,
#endif /* CONFIG_BT_PERIPHERAL && CONFIG_BT_CENTRAL */
		conn, ticker_start_conn_op_cb, (void *)conn);
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 1000d96:	f030 0302 	bics.w	r3, r0, #2
 1000d9a:	d00c      	beq.n	1000db6 <ull_conn_update_ticker.constprop.0+0xde>
 1000d9c:	f641 732f 	movw	r3, #7983	; 0x1f2f
 1000da0:	4a11      	ldr	r2, [pc, #68]	; (1000de8 <ull_conn_update_ticker.constprop.0+0x110>)
 1000da2:	4912      	ldr	r1, [pc, #72]	; (1000dec <ull_conn_update_ticker.constprop.0+0x114>)
 1000da4:	4812      	ldr	r0, [pc, #72]	; (1000df0 <ull_conn_update_ticker.constprop.0+0x118>)
 1000da6:	f023 ff16 	bl	1024bd6 <assert_print>
 1000daa:	4040      	eors	r0, r0
 1000dac:	f380 8811 	msr	BASEPRI, r0
 1000db0:	f04f 0003 	mov.w	r0, #3
 1000db4:	df02      	svc	2
		  (ticker_status == TICKER_STATUS_BUSY));

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* enable ticker job, if disabled in this function */
	if (mayfly_was_enabled) {
 1000db6:	f1b8 0f00 	cmp.w	r8, #0
 1000dba:	d102      	bne.n	1000dc2 <ull_conn_update_ticker.constprop.0+0xea>
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1U);
	}
#endif /* CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO */
}
 1000dbc:	b00a      	add	sp, #40	; 0x28
 1000dbe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1U);
 1000dc2:	2201      	movs	r2, #1
 1000dc4:	2102      	movs	r1, #2
 1000dc6:	4610      	mov	r0, r2
}
 1000dc8:	b00a      	add	sp, #40	; 0x28
 1000dca:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1U);
 1000dce:	f010 b8d5 	b.w	1010f7c <mayfly_enable>
 1000dd2:	bf00      	nop
 1000dd4:	f3af 8000 	nop.w
 1000dd8:	1afd498d 	.word	0x1afd498d
 1000ddc:	00000007 	.word	0x00000007
 1000de0:	210036f0 	.word	0x210036f0
 1000de4:	01015ab5 	.word	0x01015ab5
 1000de8:	0102a8dc 	.word	0x0102a8dc
 1000dec:	0102a9a0 	.word	0x0102a9a0
 1000df0:	0102a278 	.word	0x0102a278
 1000df4:	3b9aca00 	.word	0x3b9aca00
 1000df8:	01015a5d 	.word	0x01015a5d
 1000dfc:	1afd498d 	.word	0x1afd498d
 1000e00:	0101ad6d 	.word	0x0101ad6d
 1000e04:	00000000 	.word	0x00000000

01000e08 <ull_conn_update_parameters>:

void ull_conn_update_parameters(struct ll_conn *conn, uint8_t is_cu_proc, uint8_t win_size,
				uint16_t win_offset_us, uint16_t interval, uint16_t latency,
				uint16_t timeout, uint16_t instant)
{
 1000e08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint16_t lazy = conn->llcp.prep.lazy;
 1000e0c:	f8b0 9110 	ldrh.w	r9, [r0, #272]	; 0x110
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
 1000e10:	8e46      	ldrh	r6, [r0, #50]	; 0x32
 1000e12:	f8b0 b02e 	ldrh.w	fp, [r0, #46]	; 0x2e
{
 1000e16:	b087      	sub	sp, #28
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
 1000e18:	444e      	add	r6, r9
{
 1000e1a:	f8bd 4044 	ldrh.w	r4, [sp, #68]	; 0x44
 1000e1e:	f8bd 504c 	ldrh.w	r5, [sp, #76]	; 0x4c
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
 1000e22:	445e      	add	r6, fp
{
 1000e24:	e9cd 2304 	strd	r2, r3, [sp, #16]
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
 1000e28:	b2b6      	uxth	r6, r6

	ticks_at_expire = conn->llcp.prep.ticks_at_expire;

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED)
	/* restore to normal prepare */
	if (conn->ull.ticks_prepare_to_start & XON_BITMASK) {
 1000e2a:	6883      	ldr	r3, [r0, #8]
{
 1000e2c:	9402      	str	r4, [sp, #8]
	instant_latency = (event_counter - instant) & 0xFFFF;
 1000e2e:	1b72      	subs	r2, r6, r5
{
 1000e30:	f8bd 4048 	ldrh.w	r4, [sp, #72]	; 0x48
	instant_latency = (event_counter - instant) & 0xFFFF;
 1000e34:	b292      	uxth	r2, r2
	if (conn->ull.ticks_prepare_to_start & XON_BITMASK) {
 1000e36:	2b00      	cmp	r3, #0
{
 1000e38:	9403      	str	r4, [sp, #12]
 1000e3a:	f8bd 8040 	ldrh.w	r8, [sp, #64]	; 0x40
 1000e3e:	4604      	mov	r4, r0
	ticks_at_expire = conn->llcp.prep.ticks_at_expire;
 1000e40:	f8d0 710c 	ldr.w	r7, [r0, #268]	; 0x10c
{
 1000e44:	9101      	str	r1, [sp, #4]
	instant_latency = (event_counter - instant) & 0xFFFF;
 1000e46:	9200      	str	r2, [sp, #0]
	if (conn->ull.ticks_prepare_to_start & XON_BITMASK) {
 1000e48:	da09      	bge.n	1000e5e <ull_conn_update_parameters+0x56>
		uint32_t ticks_prepare_to_start =
 1000e4a:	68c1      	ldr	r1, [r0, #12]
 1000e4c:	6842      	ldr	r2, [r0, #4]
			MAX(conn->ull.ticks_active_to_start, conn->ull.ticks_preempt_to_start);

		conn->ull.ticks_prepare_to_start &= ~XON_BITMASK;
 1000e4e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 1000e52:	4291      	cmp	r1, r2
 1000e54:	bf2c      	ite	cs
 1000e56:	187f      	addcs	r7, r7, r1
 1000e58:	18bf      	addcc	r7, r7, r2
 1000e5a:	6083      	str	r3, [r0, #8]

		ticks_at_expire -= (conn->ull.ticks_prepare_to_start - ticks_prepare_to_start);
 1000e5c:	1aff      	subs	r7, r7, r3
	}
#endif /* CONFIG_BT_CTLR_XTAL_ADVANCED */

	/* compensate for instant_latency due to laziness */
	conn_interval_old = instant_latency * lll->interval;
 1000e5e:	9a00      	ldr	r2, [sp, #0]
 1000e60:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 1000e62:	fb02 f303 	mul.w	r3, r2, r3
 1000e66:	b29b      	uxth	r3, r3
	latency_upd = conn_interval_old / interval;
 1000e68:	fbb3 f2f8 	udiv	r2, r3, r8
	conn_interval_new = latency_upd * interval;
 1000e6c:	fb02 f008 	mul.w	r0, r2, r8
 1000e70:	b280      	uxth	r0, r0
	if (conn_interval_new > conn_interval_old) {
 1000e72:	4283      	cmp	r3, r0
	latency_upd = conn_interval_old / interval;
 1000e74:	fa1f fa82 	uxth.w	sl, r2
	if (conn_interval_new > conn_interval_old) {
 1000e78:	d25a      	bcs.n	1000f30 <ull_conn_update_parameters+0x128>
		ticks_at_expire += HAL_TICKER_US_TO_TICKS((conn_interval_new - conn_interval_old) *
 1000e7a:	1ac0      	subs	r0, r0, r3
 1000e7c:	f240 43e2 	movw	r3, #1250	; 0x4e2
 1000e80:	fb03 f000 	mul.w	r0, r3, r0
 1000e84:	a358      	add	r3, pc, #352	; (adr r3, 1000fe8 <ull_conn_update_parameters+0x1e0>)
 1000e86:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000e8a:	4959      	ldr	r1, [pc, #356]	; (1000ff0 <ull_conn_update_parameters+0x1e8>)
 1000e8c:	fba0 0101 	umull	r0, r1, r0, r1
 1000e90:	f7ff f912 	bl	10000b8 <__aeabi_uldivmod>
 1000e94:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 1000e98:	4407      	add	r7, r0
	} else {
		ticks_at_expire -= HAL_TICKER_US_TO_TICKS((conn_interval_old - conn_interval_new) *
							  CONN_INT_UNIT_US);
	}

	lll->latency_prepare += conn->llcp.prep.lazy;
 1000e9a:	44d9      	add	r9, fp
	lll->latency_prepare -= (instant_latency - latency_upd);
 1000e9c:	444d      	add	r5, r9
 1000e9e:	1bad      	subs	r5, r5, r6
	} else {
		ticks_slot_overhead = 0U;
	}

	/* calculate the window widening and interval */
	conn_interval_us = interval * CONN_INT_UNIT_US;
 1000ea0:	f240 46e2 	movw	r6, #1250	; 0x4e2
	periodic_us = conn_interval_us;

	switch (lll->role) {
 1000ea4:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
	lll->latency_prepare -= (instant_latency - latency_upd);
 1000ea8:	4455      	add	r5, sl
	switch (lll->role) {
 1000eaa:	09db      	lsrs	r3, r3, #7
	lll->latency_prepare -= (instant_latency - latency_upd);
 1000eac:	85e5      	strh	r5, [r4, #46]	; 0x2e
	conn_interval_us = interval * CONN_INT_UNIT_US;
 1000eae:	fb06 f508 	mul.w	r5, r6, r8
	switch (lll->role) {
 1000eb2:	d14e      	bne.n	1000f52 <ull_conn_update_parameters+0x14a>
		 */
		ticks_win_offset += 1U;
		break;
#endif /*CONFIG_BT_CENTRAL */
	default:
		LL_ASSERT(0);
 1000eb4:	f641 73a5 	movw	r3, #8101	; 0x1fa5
 1000eb8:	4a4e      	ldr	r2, [pc, #312]	; (1000ff4 <ull_conn_update_parameters+0x1ec>)
 1000eba:	494f      	ldr	r1, [pc, #316]	; (1000ff8 <ull_conn_update_parameters+0x1f0>)
 1000ebc:	484f      	ldr	r0, [pc, #316]	; (1000ffc <ull_conn_update_parameters+0x1f4>)
 1000ebe:	f023 fe8a 	bl	1024bd6 <assert_print>
 1000ec2:	4040      	eors	r0, r0
 1000ec4:	f380 8811 	msr	BASEPRI, r0
 1000ec8:	f04f 0003 	mov.w	r0, #3
 1000ecc:	df02      	svc	2
	uint32_t ticks_win_offset = 0U;
 1000ece:	2600      	movs	r6, #0
	periodic_us = conn_interval_us;
 1000ed0:	46ab      	mov	fp, r5
		break;
	}

	lll->interval = interval;
	lll->latency = latency;
 1000ed2:	9b02      	ldr	r3, [sp, #8]

	conn->supervision_timeout = timeout;
	ull_cp_prt_reload_set(conn, conn_interval_us);
 1000ed4:	4629      	mov	r1, r5
	lll->latency = latency;
 1000ed6:	85a3      	strh	r3, [r4, #44]	; 0x2c
	conn->supervision_timeout = timeout;
 1000ed8:	9b03      	ldr	r3, [sp, #12]
	ull_cp_prt_reload_set(conn, conn_interval_us);
 1000eda:	4620      	mov	r0, r4
	conn->supervision_timeout = timeout;
 1000edc:	f8a4 3184 	strh.w	r3, [r4, #388]	; 0x184
	lll->interval = interval;
 1000ee0:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
	ull_cp_prt_reload_set(conn, conn_interval_us);
 1000ee4:	f017 f94c 	bl	1018180 <ull_cp_prt_reload_set>

#if defined(CONFIG_BT_CTLR_LE_PING)
	/* APTO in no. of connection events */
	conn->apto_reload = RADIO_CONN_EVENTS((30U * 1000U * 1000U), conn_interval_us);
 1000ee8:	4b45      	ldr	r3, [pc, #276]	; (1001000 <ull_conn_update_parameters+0x1f8>)
	/* Dispatch LE Ping PDU 6 connection events (that peer would
	 * listen to) before 30s timeout
	 * TODO: "peer listens to" is greater than 30s due to latency
	 */
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6U)) ?
 1000eea:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
	conn->apto_reload = RADIO_CONN_EVENTS((30U * 1000U * 1000U), conn_interval_us);
 1000eec:	442b      	add	r3, r5
 1000eee:	fbb3 f3f5 	udiv	r3, r3, r5
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6U)) ?
 1000ef2:	1d88      	adds	r0, r1, #6
	conn->apto_reload = RADIO_CONN_EVENTS((30U * 1000U * 1000U), conn_interval_us);
 1000ef4:	b29a      	uxth	r2, r3
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6U)) ?
 1000ef6:	4290      	cmp	r0, r2
	conn->apto_reload = RADIO_CONN_EVENTS((30U * 1000U * 1000U), conn_interval_us);
 1000ef8:	f8a4 217e 	strh.w	r2, [r4, #382]	; 0x17e
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6U)) ?
 1000efc:	d202      	bcs.n	1000f04 <ull_conn_update_parameters+0xfc>
					   (conn->apto_reload - (lll->latency + 6U)) :
 1000efe:	1a52      	subs	r2, r2, r1
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6U)) ?
 1000f00:	3a06      	subs	r2, #6
 1000f02:	b292      	uxth	r2, r2
					   conn->apto_reload;
#endif /* CONFIG_BT_CTLR_LE_PING */

	if (is_cu_proc) {
 1000f04:	9b01      	ldr	r3, [sp, #4]
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6U)) ?
 1000f06:	f8a4 217a 	strh.w	r2, [r4, #378]	; 0x17a
	if (is_cu_proc) {
 1000f0a:	b113      	cbz	r3, 1000f12 <ull_conn_update_parameters+0x10a>
		conn->supervision_expire = 0U;
 1000f0c:	2300      	movs	r3, #0
 1000f0e:	f8a4 3186 	strh.w	r3, [r4, #390]	; 0x186
	}

	/* Update ACL ticker */
	ull_conn_update_ticker(conn, ticks_win_offset, ticks_slot_overhead, periodic_us,
 1000f12:	463b      	mov	r3, r7
 1000f14:	465a      	mov	r2, fp
 1000f16:	4631      	mov	r1, r6
 1000f18:	4620      	mov	r0, r4
 1000f1a:	f7ff fedd 	bl	1000cd8 <ull_conn_update_ticker.constprop.0>
			       ticks_at_expire);
	/* Signal that the prepare needs to be canceled */
	conn->cancel_prepare = 1U;
 1000f1e:	f894 3178 	ldrb.w	r3, [r4, #376]	; 0x178
 1000f22:	f043 0301 	orr.w	r3, r3, #1
 1000f26:	f884 3178 	strb.w	r3, [r4, #376]	; 0x178
}
 1000f2a:	b007      	add	sp, #28
 1000f2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		ticks_at_expire -= HAL_TICKER_US_TO_TICKS((conn_interval_old - conn_interval_new) *
 1000f30:	fb08 3112 	mls	r1, r8, r2, r3
 1000f34:	f240 43e2 	movw	r3, #1250	; 0x4e2
 1000f38:	b289      	uxth	r1, r1
 1000f3a:	fb03 f101 	mul.w	r1, r3, r1
 1000f3e:	a32a      	add	r3, pc, #168	; (adr r3, 1000fe8 <ull_conn_update_parameters+0x1e0>)
 1000f40:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000f44:	482a      	ldr	r0, [pc, #168]	; (1000ff0 <ull_conn_update_parameters+0x1e8>)
 1000f46:	fba1 0100 	umull	r0, r1, r1, r0
 1000f4a:	f7ff f8b5 	bl	10000b8 <__aeabi_uldivmod>
 1000f4e:	1a3f      	subs	r7, r7, r0
 1000f50:	e7a3      	b.n	1000e9a <ull_conn_update_parameters+0x92>
			lll->periph.window_widening_periodic_us * instant_latency;
 1000f52:	6c22      	ldr	r2, [r4, #64]	; 0x40
		lll->periph.window_widening_prepare_us -=
 1000f54:	9900      	ldr	r1, [sp, #0]
 1000f56:	6ca3      	ldr	r3, [r4, #72]	; 0x48
		ticks_at_expire -= HAL_TICKER_US_TO_TICKS(lll->periph.window_widening_periodic_us *
 1000f58:	f8df 9094 	ldr.w	r9, [pc, #148]	; 1000ff0 <ull_conn_update_parameters+0x1e8>
		lll->periph.window_widening_prepare_us -=
 1000f5c:	fb02 3311 	mls	r3, r2, r1, r3
 1000f60:	64a3      	str	r3, [r4, #72]	; 0x48
			ceiling_fraction(((lll_clock_ppm_local_get() +
 1000f62:	f01a fe2d 	bl	101bbc0 <lll_clock_ppm_local_get>
 1000f66:	4683      	mov	fp, r0
 1000f68:	f894 016c 	ldrb.w	r0, [r4, #364]	; 0x16c
 1000f6c:	f3c0 0042 	ubfx	r0, r0, #1, #3
 1000f70:	f01a fe28 	bl	101bbc4 <lll_clock_ppm_get>
		lll->periph.window_size_prepare_us = win_size * CONN_INT_UNIT_US;
 1000f74:	9b04      	ldr	r3, [sp, #16]
			ceiling_fraction(((lll_clock_ppm_local_get() +
 1000f76:	4483      	add	fp, r0
		lll->periph.window_size_prepare_us = win_size * CONN_INT_UNIT_US;
 1000f78:	fb06 f303 	mul.w	r3, r6, r3
			ceiling_fraction(((lll_clock_ppm_local_get() +
 1000f7c:	fb05 fb0b 	mul.w	fp, r5, fp
		lll->periph.window_size_prepare_us = win_size * CONN_INT_UNIT_US;
 1000f80:	6523      	str	r3, [r4, #80]	; 0x50
			ceiling_fraction(((lll_clock_ppm_local_get() +
 1000f82:	f50b 2b74 	add.w	fp, fp, #999424	; 0xf4000
 1000f86:	4b1f      	ldr	r3, [pc, #124]	; (1001004 <ull_conn_update_parameters+0x1fc>)
 1000f88:	f20b 2b3f 	addw	fp, fp, #575	; 0x23f
 1000f8c:	fba3 3b0b 	umull	r3, fp, r3, fp
 1000f90:	ea4f 439b 	mov.w	r3, fp, lsr #18
			lll->periph.window_widening_periodic_us * latency_upd;
 1000f94:	fb03 f00a 	mul.w	r0, r3, sl
		lll->periph.window_widening_periodic_us =
 1000f98:	6423      	str	r3, [r4, #64]	; 0x40
		periodic_us -= lll->periph.window_widening_periodic_us;
 1000f9a:	eba5 0b03 	sub.w	fp, r5, r3
		lll->periph.window_widening_prepare_us +=
 1000f9e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
		lll->periph.window_widening_max_us = (conn_interval_us >> 1U) - EVENT_IFS_US;
 1000fa0:	086a      	lsrs	r2, r5, #1
		lll->periph.window_widening_prepare_us +=
 1000fa2:	4403      	add	r3, r0
		lll->periph.window_widening_max_us = (conn_interval_us >> 1U) - EVENT_IFS_US;
 1000fa4:	3a96      	subs	r2, #150	; 0x96
 1000fa6:	4293      	cmp	r3, r2
 1000fa8:	bf28      	it	cs
 1000faa:	4613      	movcs	r3, r2
 1000fac:	e9c4 2311 	strd	r2, r3, [r4, #68]	; 0x44
		conn->periph.ticks_to_offset = 0U;
 1000fb0:	2300      	movs	r3, #0
		ticks_at_expire -= HAL_TICKER_US_TO_TICKS(lll->periph.window_widening_periodic_us *
 1000fb2:	fba0 0109 	umull	r0, r1, r0, r9
		conn->periph.ticks_to_offset = 0U;
 1000fb6:	f8c4 3174 	str.w	r3, [r4, #372]	; 0x174
		ticks_at_expire -= HAL_TICKER_US_TO_TICKS(lll->periph.window_widening_periodic_us *
 1000fba:	a30b      	add	r3, pc, #44	; (adr r3, 1000fe8 <ull_conn_update_parameters+0x1e0>)
 1000fbc:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000fc0:	f7ff f87a 	bl	10000b8 <__aeabi_uldivmod>
		ticks_win_offset = HAL_TICKER_US_TO_TICKS((win_offset_us / CONN_INT_UNIT_US) *
 1000fc4:	4b10      	ldr	r3, [pc, #64]	; (1001008 <ull_conn_update_parameters+0x200>)
 1000fc6:	9a05      	ldr	r2, [sp, #20]
		ticks_at_expire -= HAL_TICKER_US_TO_TICKS(lll->periph.window_widening_periodic_us *
 1000fc8:	1a3f      	subs	r7, r7, r0
		ticks_win_offset = HAL_TICKER_US_TO_TICKS((win_offset_us / CONN_INT_UNIT_US) *
 1000fca:	fba3 3002 	umull	r3, r0, r3, r2
 1000fce:	a306      	add	r3, pc, #24	; (adr r3, 1000fe8 <ull_conn_update_parameters+0x1e0>)
 1000fd0:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000fd4:	0a80      	lsrs	r0, r0, #10
 1000fd6:	fb06 f000 	mul.w	r0, r6, r0
 1000fda:	fba0 0109 	umull	r0, r1, r0, r9
 1000fde:	f7ff f86b 	bl	10000b8 <__aeabi_uldivmod>
 1000fe2:	4606      	mov	r6, r0
		break;
 1000fe4:	e775      	b.n	1000ed2 <ull_conn_update_parameters+0xca>
 1000fe6:	bf00      	nop
 1000fe8:	1afd498d 	.word	0x1afd498d
 1000fec:	00000007 	.word	0x00000007
 1000ff0:	3b9aca00 	.word	0x3b9aca00
 1000ff4:	0102a8dc 	.word	0x0102a8dc
 1000ff8:	0102a300 	.word	0x0102a300
 1000ffc:	0102a278 	.word	0x0102a278
 1001000:	01c9c37f 	.word	0x01c9c37f
 1001004:	431bde83 	.word	0x431bde83
 1001008:	d1b71759 	.word	0xd1b71759
 100100c:	00000000 	.word	0x00000000

01001010 <ull_periph_setup>:
static void ticker_update_latency_cancel_op_cb(uint32_t ticker_status,
					       void *param);

void ull_periph_setup(struct node_rx_hdr *rx, struct node_rx_ftr *ftr,
		     struct lll_conn *lll)
{
 1001010:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1001014:	4604      	mov	r4, r0
 1001016:	4615      	mov	r5, r2
	uint16_t win_offset;
	memq_link_t *link;
	uint8_t chan_sel;
	void *node;

	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
 1001018:	680b      	ldr	r3, [r1, #0]
{
 100101a:	b093      	sub	sp, #76	; 0x4c
	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
 100101c:	f8d3 9000 	ldr.w	r9, [r3]
	conn = lll->hdr.parent;

	/* Populate the peripheral context */
	pdu_adv = (void *)((struct node_rx_pdu *)rx)->pdu;

	peer_addr_type = pdu_adv->tx_addr;
 1001020:	7f23      	ldrb	r3, [r4, #28]
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
 1001022:	2206      	movs	r2, #6
	peer_addr_type = pdu_adv->tx_addr;
 1001024:	f3c3 1b80 	ubfx	fp, r3, #6, #1
{
 1001028:	4688      	mov	r8, r1
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
 100102a:	a810      	add	r0, sp, #64	; 0x40
 100102c:	f104 011e 	add.w	r1, r4, #30
	conn = lll->hdr.parent;
 1001030:	682e      	ldr	r6, [r5, #0]
	peer_addr_type = pdu_adv->tx_addr;
 1001032:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
 1001036:	f025 fc9d 	bl	1026974 <memcpy>
		peer_addr_type += 2;
	} else {
#else /* CONFIG_BT_CTLR_PRIVACY */
	if (1) {
#endif /* CONFIG_BT_CTLR_PRIVACY */
		memcpy(peer_id_addr, peer_addr, BDADDR_SIZE);
 100103a:	2206      	movs	r2, #6
 100103c:	a910      	add	r1, sp, #64	; 0x40
 100103e:	a80e      	add	r0, sp, #56	; 0x38
 1001040:	f025 fc98 	bl	1026974 <memcpy>
	 */
	link = rx->link;

#if defined(CONFIG_BT_CTLR_CHECK_SAME_PEER_CONN)
	const uint8_t peer_id_addr_type = (peer_addr_type & 0x01);
	const uint8_t own_id_addr_type = pdu_adv->rx_addr;
 1001044:	7f27      	ldrb	r7, [r4, #28]
	link = rx->link;
 1001046:	f8d4 c000 	ldr.w	ip, [r4]
	const uint8_t own_id_addr_type = pdu_adv->rx_addr;
 100104a:	09ff      	lsrs	r7, r7, #7
	const uint8_t *own_id_addr = adv->own_id_addr;
 100104c:	f109 0a6b 	add.w	sl, r9, #107	; 0x6b

	/* Do not connect twice to the same peer */
	if (ull_conn_peer_connected(own_id_addr_type, own_id_addr,
 1001050:	465a      	mov	r2, fp
 1001052:	4651      	mov	r1, sl
 1001054:	4638      	mov	r0, r7
 1001056:	ab0e      	add	r3, sp, #56	; 0x38
	link = rx->link;
 1001058:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
	if (ull_conn_peer_connected(own_id_addr_type, own_id_addr,
 100105c:	f015 f828 	bl	10160b0 <ull_conn_peer_connected>
 1001060:	2800      	cmp	r0, #0
 1001062:	d14b      	bne.n	10010fc <ull_periph_setup+0xec>

		return;
	}

	/* Remember peer and own identity address */
	conn->peer_id_addr_type = peer_id_addr_type;
 1001064:	f896 2192 	ldrb.w	r2, [r6, #402]	; 0x192
 1001068:	900c      	str	r0, [sp, #48]	; 0x30
 100106a:	f36b 0241 	bfi	r2, fp, #1, #1
 100106e:	f886 2192 	strb.w	r2, [r6, #402]	; 0x192
	(void)memcpy(conn->peer_id_addr, peer_id_addr,
 1001072:	a90e      	add	r1, sp, #56	; 0x38
 1001074:	2206      	movs	r2, #6
 1001076:	f206 1099 	addw	r0, r6, #409	; 0x199
 100107a:	f025 fc7b 	bl	1026974 <memcpy>
		     sizeof(conn->peer_id_addr));
	conn->own_id_addr_type = own_id_addr_type;
 100107e:	f896 2192 	ldrb.w	r2, [r6, #402]	; 0x192
	(void)memcpy(conn->own_id_addr, own_id_addr,
 1001082:	4651      	mov	r1, sl
	conn->own_id_addr_type = own_id_addr_type;
 1001084:	f367 0200 	bfi	r2, r7, #0, #1
 1001088:	f886 2192 	strb.w	r2, [r6, #402]	; 0x192
	(void)memcpy(conn->own_id_addr, own_id_addr,
 100108c:	f206 1093 	addw	r0, r6, #403	; 0x193
 1001090:	2206      	movs	r2, #6
 1001092:	f025 fc6f 	bl	1026974 <memcpy>
		     sizeof(conn->own_id_addr));
#endif /* CONFIG_BT_CTLR_CHECK_SAME_PEER_CONN */

	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
 1001096:	1d2f      	adds	r7, r5, #4
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
 1001098:	2203      	movs	r2, #3
 100109a:	f104 012e 	add.w	r1, r4, #46	; 0x2e
 100109e:	f105 0008 	add.w	r0, r5, #8
 10010a2:	f025 fc67 	bl	1026974 <memcpy>
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
 10010a6:	f105 0a18 	add.w	sl, r5, #24
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
 10010aa:	2204      	movs	r2, #4
 10010ac:	f104 012a 	add.w	r1, r4, #42	; 0x2a
 10010b0:	4638      	mov	r0, r7
 10010b2:	f025 fc5f 	bl	1026974 <memcpy>
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
 10010b6:	2205      	movs	r2, #5
 10010b8:	f104 013a 	add.w	r1, r4, #58	; 0x3a
 10010bc:	4650      	mov	r0, sl
 10010be:	f025 fc59 	bl	1026974 <memcpy>
	       sizeof(lll->data_chan_map));
	lll->data_chan_count = util_ones_count_get(&lll->data_chan_map[0],
 10010c2:	2105      	movs	r1, #5
 10010c4:	4650      	mov	r0, sl
 10010c6:	f010 f891 	bl	10111ec <util_ones_count_get>
 10010ca:	7f6a      	ldrb	r2, [r5, #29]
 10010cc:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 10010d0:	f360 0205 	bfi	r2, r0, #0, #6
 10010d4:	776a      	strb	r2, [r5, #29]
			       sizeof(lll->data_chan_map));
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
 10010d6:	f894 203f 	ldrb.w	r2, [r4, #63]	; 0x3f
	lll->interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
	if ((lll->data_chan_count < CHM_USED_COUNT_MIN) ||
 10010da:	2801      	cmp	r0, #1
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
 10010dc:	f3c2 0104 	ubfx	r1, r2, #0, #5
 10010e0:	77a9      	strb	r1, [r5, #30]
	lll->interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
 10010e2:	8ea1      	ldrh	r1, [r4, #52]	; 0x34
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
 10010e4:	f002 021f 	and.w	r2, r2, #31
	lll->interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
 10010e8:	81e9      	strh	r1, [r5, #14]
 10010ea:	b289      	uxth	r1, r1
	if ((lll->data_chan_count < CHM_USED_COUNT_MIN) ||
 10010ec:	d906      	bls.n	10010fc <ull_periph_setup+0xec>
 10010ee:	321b      	adds	r2, #27
 10010f0:	f002 021f 	and.w	r2, r2, #31
 10010f4:	2a0b      	cmp	r2, #11
 10010f6:	d801      	bhi.n	10010fc <ull_periph_setup+0xec>
	    (lll->data_chan_hop < CHM_HOP_COUNT_MIN) ||
	    (lll->data_chan_hop > CHM_HOP_COUNT_MAX) ||
 10010f8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 10010fa:	b9b9      	cbnz	r1, 100112c <ull_periph_setup+0x11c>

static void invalid_release(struct ull_hdr *hdr, struct lll_conn *lll,
			    memq_link_t *link, struct node_rx_hdr *rx)
{
	/* Reset the advertising disabled callback */
	hdr->disabled_cb = NULL;
 10010fc:	2200      	movs	r2, #0

	/* Let the advertiser continue with connectable advertising */
	lll->periph.initiated = 0U;

	/* Mark for buffer for release */
	rx->type = NODE_RX_TYPE_RELEASE;
 10010fe:	2601      	movs	r6, #1
	hdr->disabled_cb = NULL;
 1001100:	f8c9 2014 	str.w	r2, [r9, #20]
	lll->periph.initiated = 0U;
 1001104:	f895 3020 	ldrb.w	r3, [r5, #32]
		 * connection rx node.
		 */
		rx_csa = rx->rx_ftr.extra;

		/* Enqueue the connection event to be release */
		ll_rx_put(link, rx);
 1001108:	4621      	mov	r1, r4
	lll->periph.initiated = 0U;
 100110a:	f362 0300 	bfi	r3, r2, #0, #1
 100110e:	f885 3020 	strb.w	r3, [r5, #32]
		rx_csa = rx->rx_ftr.extra;
 1001112:	68e5      	ldr	r5, [r4, #12]
		ll_rx_put(link, rx);
 1001114:	980a      	ldr	r0, [sp, #40]	; 0x28
	rx->type = NODE_RX_TYPE_RELEASE;
 1001116:	7126      	strb	r6, [r4, #4]
		ll_rx_put(link, rx);
 1001118:	f013 f8d6 	bl	10142c8 <ll_rx_put>
		/* Mark for buffer for release */
		rx->type = NODE_RX_TYPE_RELEASE;
	}

	/* Enqueue connection or CSA event to be release */
	ll_rx_put_sched(link, rx);
 100111c:	4629      	mov	r1, r5
 100111e:	6828      	ldr	r0, [r5, #0]
		rx->type = NODE_RX_TYPE_RELEASE;
 1001120:	712e      	strb	r6, [r5, #4]
	ll_rx_put_sched(link, rx);
 1001122:	f013 f8db 	bl	10142dc <ll_rx_put_sched>
}
 1001126:	b013      	add	sp, #76	; 0x4c
 1001128:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	conn_interval_us = lll->interval * CONN_INT_UNIT_US;
 100112c:	f240 4be2 	movw	fp, #1250	; 0x4e2
	((struct lll_adv *)ftr->param)->conn = NULL;
 1001130:	f8d8 2000 	ldr.w	r2, [r8]
	ull_cp_state_set(conn, ULL_CP_CONNECTED);
 1001134:	4619      	mov	r1, r3
	((struct lll_adv *)ftr->param)->conn = NULL;
 1001136:	6053      	str	r3, [r2, #4]
	lll->latency = sys_le16_to_cpu(pdu_adv->connect_ind.latency);
 1001138:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
	ull_cp_state_set(conn, ULL_CP_CONNECTED);
 100113a:	4630      	mov	r0, r6
	lll->latency = sys_le16_to_cpu(pdu_adv->connect_ind.latency);
 100113c:	822b      	strh	r3, [r5, #16]
	win_offset = sys_le16_to_cpu(pdu_adv->connect_ind.win_offset);
 100113e:	8e62      	ldrh	r2, [r4, #50]	; 0x32
	conn_interval_us = lll->interval * CONN_INT_UNIT_US;
 1001140:	89eb      	ldrh	r3, [r5, #14]
	win_offset = sys_le16_to_cpu(pdu_adv->connect_ind.win_offset);
 1001142:	920c      	str	r2, [sp, #48]	; 0x30
	conn_interval_us = lll->interval * CONN_INT_UNIT_US;
 1001144:	fb0b fa03 	mul.w	sl, fp, r3
	ull_cp_state_set(conn, ULL_CP_CONNECTED);
 1001148:	f017 f82e 	bl	10181a8 <ull_cp_state_set>
	conn->periph.sca = pdu_adv->connect_ind.sca;
 100114c:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 1001150:	f896 216c 	ldrb.w	r2, [r6, #364]	; 0x16c
 1001154:	095b      	lsrs	r3, r3, #5
 1001156:	f363 0243 	bfi	r2, r3, #1, #3
 100115a:	f886 216c 	strb.w	r2, [r6, #364]	; 0x16c
		ceiling_fraction(((lll_clock_ppm_local_get() +
 100115e:	f01a fd2f 	bl	101bbc0 <lll_clock_ppm_local_get>
 1001162:	4603      	mov	r3, r0
 1001164:	f896 016c 	ldrb.w	r0, [r6, #364]	; 0x16c
 1001168:	930d      	str	r3, [sp, #52]	; 0x34
 100116a:	f3c0 0042 	ubfx	r0, r0, #1, #3
 100116e:	f01a fd29 	bl	101bbc4 <lll_clock_ppm_get>
 1001172:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 1001174:	4aac      	ldr	r2, [pc, #688]	; (1001428 <ull_periph_setup+0x418>)
 1001176:	4403      	add	r3, r0
 1001178:	fb0a f303 	mul.w	r3, sl, r3
 100117c:	f503 2374 	add.w	r3, r3, #999424	; 0xf4000
 1001180:	f203 233f 	addw	r3, r3, #575	; 0x23f
 1001184:	fba2 2303 	umull	r2, r3, r2, r3
 1001188:	0c9b      	lsrs	r3, r3, #18
	lll->periph.window_widening_periodic_us =
 100118a:	626b      	str	r3, [r5, #36]	; 0x24
	lll->periph.window_widening_max_us = (conn_interval_us >> 1) -
 100118c:	ea4f 035a 	mov.w	r3, sl, lsr #1
 1001190:	3b96      	subs	r3, #150	; 0x96
 1001192:	62ab      	str	r3, [r5, #40]	; 0x28
	lll->periph.window_size_event_us = pdu_adv->connect_ind.win_size *
 1001194:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
	ull_cp_prt_reload_set(conn, conn_interval_us);
 1001198:	4651      	mov	r1, sl
	lll->periph.window_size_event_us = pdu_adv->connect_ind.win_size *
 100119a:	fb0b f303 	mul.w	r3, fp, r3
 100119e:	63ab      	str	r3, [r5, #56]	; 0x38
	conn->supervision_timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
 10011a0:	8f23      	ldrh	r3, [r4, #56]	; 0x38
	ull_cp_prt_reload_set(conn, conn_interval_us);
 10011a2:	4630      	mov	r0, r6
	conn->supervision_timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
 10011a4:	f8a6 3184 	strh.w	r3, [r6, #388]	; 0x184
	ull_cp_prt_reload_set(conn, conn_interval_us);
 10011a8:	f016 ffea 	bl	1018180 <ull_cp_prt_reload_set>
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 10011ac:	4b9f      	ldr	r3, [pc, #636]	; (100142c <ull_periph_setup+0x41c>)
	conn->connect_accept_to = DEFAULT_CONNECTION_ACCEPT_TIMEOUT_US;
 10011ae:	4aa0      	ldr	r2, [pc, #640]	; (1001430 <ull_periph_setup+0x420>)
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 10011b0:	4453      	add	r3, sl
 10011b2:	fbb3 f3fa 	udiv	r3, r3, sl
	conn->connect_accept_to = DEFAULT_CONNECTION_ACCEPT_TIMEOUT_US;
 10011b6:	f8c6 2188 	str.w	r2, [r6, #392]	; 0x188
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 10011ba:	b29a      	uxth	r2, r3
 10011bc:	f8a6 217e 	strh.w	r2, [r6, #382]	; 0x17e
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 10011c0:	8a29      	ldrh	r1, [r5, #16]
 10011c2:	1d88      	adds	r0, r1, #6
 10011c4:	4282      	cmp	r2, r0
 10011c6:	dd04      	ble.n	10011d2 <ull_periph_setup+0x1c2>
 10011c8:	f5c1 417f 	rsb	r1, r1, #65280	; 0xff00
 10011cc:	31fa      	adds	r1, #250	; 0xfa
 10011ce:	440a      	add	r2, r1
 10011d0:	b292      	uxth	r2, r2
 10011d2:	f8a6 217a 	strh.w	r2, [r6, #378]	; 0x17a
	memcpy((void *)&conn->periph.force, &lll->access_addr[0],
 10011d6:	4639      	mov	r1, r7
 10011d8:	2204      	movs	r2, #4
 10011da:	f506 70b8 	add.w	r0, r6, #368	; 0x170
 10011de:	f025 fbc9 	bl	1026974 <memcpy>
		chan_sel = pdu_adv->chan_sel;
 10011e2:	4623      	mov	r3, r4
 10011e4:	f813 2f1c 	ldrb.w	r2, [r3, #28]!
 10011e8:	f3c2 1b40 	ubfx	fp, r2, #5, #1
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cc));
 10011ec:	07da      	lsls	r2, r3, #31
 10011ee:	f100 80df 	bmi.w	10013b0 <ull_periph_setup+0x3a0>
	cc->peer_addr_type = peer_addr_type;
 10011f2:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
	memcpy(cc->peer_addr, peer_id_addr, BDADDR_SIZE);
 10011f6:	2206      	movs	r2, #6
	cc->peer_addr_type = peer_addr_type;
 10011f8:	77a3      	strb	r3, [r4, #30]
	cc->status = 0U;
 10011fa:	f44f 7380 	mov.w	r3, #256	; 0x100
	memcpy(cc->peer_addr, peer_id_addr, BDADDR_SIZE);
 10011fe:	a90e      	add	r1, sp, #56	; 0x38
	cc->status = 0U;
 1001200:	83a3      	strh	r3, [r4, #28]
	memcpy(cc->peer_addr, peer_id_addr, BDADDR_SIZE);
 1001202:	f104 001f 	add.w	r0, r4, #31
 1001206:	f025 fbb5 	bl	1026974 <memcpy>
	cc->interval = lll->interval;
 100120a:	89eb      	ldrh	r3, [r5, #14]
	lll->handle = ll_conn_handle_get(conn);
 100120c:	4630      	mov	r0, r6
	cc->interval = lll->interval;
 100120e:	84e3      	strh	r3, [r4, #38]	; 0x26
	cc->latency = lll->latency;
 1001210:	8a2b      	ldrh	r3, [r5, #16]
 1001212:	8523      	strh	r3, [r4, #40]	; 0x28
	cc->timeout = conn->supervision_timeout;
 1001214:	f8b6 3184 	ldrh.w	r3, [r6, #388]	; 0x184
 1001218:	8563      	strh	r3, [r4, #42]	; 0x2a
	cc->sca = conn->periph.sca;
 100121a:	f896 316c 	ldrb.w	r3, [r6, #364]	; 0x16c
 100121e:	f3c3 0342 	ubfx	r3, r3, #1, #3
 1001222:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
	lll->handle = ll_conn_handle_get(conn);
 1001226:	f014 fc7d 	bl	1015b24 <ll_conn_handle_get>
 100122a:	4603      	mov	r3, r0
		ll_rx_put(link, rx);
 100122c:	4621      	mov	r1, r4
	lll->handle = ll_conn_handle_get(conn);
 100122e:	81ab      	strh	r3, [r5, #12]
		ll_rx_put(link, rx);
 1001230:	980a      	ldr	r0, [sp, #40]	; 0x28
	rx->handle = lll->handle;
 1001232:	80e3      	strh	r3, [r4, #6]
		rx_csa = (void *)ftr->extra;
 1001234:	f8d8 4004 	ldr.w	r4, [r8, #4]
		ll_rx_put(link, rx);
 1001238:	f013 f846 	bl	10142c8 <ll_rx_put>
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
 100123c:	231c      	movs	r3, #28
		rx->handle = lll->handle;
 100123e:	89aa      	ldrh	r2, [r5, #12]
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
 1001240:	7123      	strb	r3, [r4, #4]
		rx->handle = lll->handle;
 1001242:	80e2      	strh	r2, [r4, #6]
		link = rx->link;
 1001244:	6823      	ldr	r3, [r4, #0]
		if (chan_sel) {
 1001246:	f1bb 0f00 	cmp.w	fp, #0
 100124a:	f040 80c7 	bne.w	10013dc <ull_periph_setup+0x3cc>
	ll_rx_put_sched(link, rx);
 100124e:	4618      	mov	r0, r3
 1001250:	4621      	mov	r1, r4
			cs->csa = 0x00;
 1001252:	f884 b01c 	strb.w	fp, [r4, #28]
	ll_rx_put_sched(link, rx);
 1001256:	f013 f841 	bl	10142dc <ll_rx_put_sched>
	ready_delay_us = lll_radio_rx_ready_delay_get(lll->phy_rx, 1);
 100125a:	f895 005b 	ldrb.w	r0, [r5, #91]	; 0x5b
	max_tx_time = lll->dle.eff.max_tx_time;
 100125e:	f8b5 7050 	ldrh.w	r7, [r5, #80]	; 0x50
	max_rx_time = lll->dle.eff.max_rx_time;
 1001262:	f8b5 4052 	ldrh.w	r4, [r5, #82]	; 0x52
	ready_delay_us = lll_radio_rx_ready_delay_get(lll->phy_rx, 1);
 1001266:	2101      	movs	r1, #1
 1001268:	f000 0007 	and.w	r0, r0, #7
 100126c:	f01a fac4 	bl	101b7f8 <lll_radio_rx_ready_delay_get>
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1001270:	443c      	add	r4, r7
	conn->ull.ticks_prepare_to_start =
 1001272:	2331      	movs	r3, #49	; 0x31
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1001274:	f204 11a9 	addw	r1, r4, #425	; 0x1a9
	conn->ull.ticks_active_to_start = 0U;
 1001278:	2400      	movs	r4, #0
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 100127a:	4f6e      	ldr	r7, [pc, #440]	; (1001434 <ull_periph_setup+0x424>)
 100127c:	4401      	add	r1, r0
	ready_delay_us = lll_radio_rx_ready_delay_get(lll->phy_rx, 1);
 100127e:	4683      	mov	fp, r0
	conn->ull.ticks_prepare_to_start =
 1001280:	60b3      	str	r3, [r6, #8]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1001282:	fba1 0107 	umull	r0, r1, r1, r7
 1001286:	a366      	add	r3, pc, #408	; (adr r3, 1001420 <ull_periph_setup+0x410>)
 1001288:	e9d3 2300 	ldrd	r2, r3, [r3]
	conn->ull.ticks_active_to_start = 0U;
 100128c:	6074      	str	r4, [r6, #4]
	conn->ull.ticks_preempt_to_start =
 100128e:	60f4      	str	r4, [r6, #12]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1001290:	f7fe ff12 	bl	10000b8 <__aeabi_uldivmod>
 1001294:	4603      	mov	r3, r0
	conn_offset_us += win_offset * CONN_INT_UNIT_US;
 1001296:	f240 4ce2 	movw	ip, #1250	; 0x4e2
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 100129a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	conn->ull.ticks_slot =
 100129e:	6133      	str	r3, [r6, #16]
	conn_offset_us += win_offset * CONN_INT_UNIT_US;
 10012a0:	f8dd e030 	ldr.w	lr, [sp, #48]	; 0x30
	conn_offset_us = ftr->radio_end_us;
 10012a4:	f8d8 300c 	ldr.w	r3, [r8, #12]
	conn_interval_us -= lll->periph.window_widening_periodic_us;
 10012a8:	6a6d      	ldr	r5, [r5, #36]	; 0x24
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 10012aa:	4622      	mov	r2, r4
 10012ac:	2102      	movs	r1, #2
 10012ae:	2001      	movs	r0, #1
	conn_interval_us -= lll->periph.window_widening_periodic_us;
 10012b0:	ebaa 0505 	sub.w	r5, sl, r5
	conn_offset_us += win_offset * CONN_INT_UNIT_US;
 10012b4:	fb0c 3a0e 	mla	sl, ip, lr, r3
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 10012b8:	f00f fe60 	bl	1010f7c <mayfly_enable>
	ticker_id_adv = TICKER_ID_ADV_BASE + ull_adv_handle_get(adv);
 10012bc:	4648      	mov	r0, r9
 10012be:	f014 f91f 	bl	1015500 <ull_adv_handle_get>
 10012c2:	4602      	mov	r2, r0
	conn_offset_us -= EVENT_JITTER_US;
 10012c4:	f20a 4ab2 	addw	sl, sl, #1202	; 0x4b2
	conn_offset_us -= ready_delay_us;
 10012c8:	ebaa 0a0b 	sub.w	sl, sl, fp
			HAL_TICKER_US_TO_TICKS(conn_offset_us) -
 10012cc:	fbaa 0107 	umull	r0, r1, sl, r7
	ticker_id_adv = TICKER_ID_ADV_BASE + ull_adv_handle_get(adv);
 10012d0:	4617      	mov	r7, r2
			HAL_TICKER_US_TO_TICKS(conn_offset_us) -
 10012d2:	a353      	add	r3, pc, #332	; (adr r3, 1001420 <ull_periph_setup+0x410>)
 10012d4:	e9d3 2300 	ldrd	r2, r3, [r3]
 10012d8:	f7fe feee 	bl	10000b8 <__aeabi_uldivmod>
 10012dc:	4682      	mov	sl, r0
	ticker_status = ticker_stop_abs(TICKER_INSTANCE_ID_CTLR,
 10012de:	f8cd 9004 	str.w	r9, [sp, #4]
	ticks_at_stop = ftr->ticks_anchor +
 10012e2:	f8d8 3008 	ldr.w	r3, [r8, #8]
	ticker_status = ticker_stop_abs(TICKER_INSTANCE_ID_CTLR,
 10012e6:	4a54      	ldr	r2, [pc, #336]	; (1001438 <ull_periph_setup+0x428>)
	ticks_at_stop = ftr->ticks_anchor +
 10012e8:	3b3a      	subs	r3, #58	; 0x3a
	ticker_status = ticker_stop_abs(TICKER_INSTANCE_ID_CTLR,
 10012ea:	9200      	str	r2, [sp, #0]
			HAL_TICKER_US_TO_TICKS(conn_offset_us) -
 10012ec:	f02a 4a7f 	bic.w	sl, sl, #4278190080	; 0xff000000
	ticker_id_adv = TICKER_ID_ADV_BASE + ull_adv_handle_get(adv);
 10012f0:	1cba      	adds	r2, r7, #2
	ticker_status = ticker_stop_abs(TICKER_INSTANCE_ID_CTLR,
 10012f2:	4620      	mov	r0, r4
 10012f4:	2101      	movs	r1, #1
 10012f6:	b2d2      	uxtb	r2, r2
 10012f8:	4453      	add	r3, sl
 10012fa:	f010 ff91 	bl	1012220 <ticker_stop_abs>
}

static void ticker_op_stop_adv_cb(uint32_t status, void *param)
{
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 10012fe:	2801      	cmp	r0, #1
 1001300:	d079      	beq.n	10013f6 <ull_periph_setup+0x3e6>
	if (adv->lll.is_hdcd) {
 1001302:	f899 3024 	ldrb.w	r3, [r9, #36]	; 0x24
 1001306:	07db      	lsls	r3, r3, #31
 1001308:	d460      	bmi.n	10013cc <ull_periph_setup+0x3bc>
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 100130a:	4630      	mov	r0, r6
 100130c:	f014 fc0a 	bl	1015b24 <ll_conn_handle_get>
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1001310:	4b48      	ldr	r3, [pc, #288]	; (1001434 <ull_periph_setup+0x424>)
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 1001312:	4604      	mov	r4, r0
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1001314:	fba5 5903 	umull	r5, r9, r5, r3
 1001318:	a341      	add	r3, pc, #260	; (adr r3, 1001420 <ull_periph_setup+0x410>)
 100131a:	e9d3 2300 	ldrd	r2, r3, [r3]
 100131e:	4628      	mov	r0, r5
 1001320:	4649      	mov	r1, r9
 1001322:	f7fe fec9 	bl	10000b8 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1001326:	9606      	str	r6, [sp, #24]
 1001328:	f8d8 3008 	ldr.w	r3, [r8, #8]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 100132c:	2207      	movs	r2, #7
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 100132e:	f1a3 083a 	sub.w	r8, r3, #58	; 0x3a
 1001332:	f44f 73ee 	mov.w	r3, #476	; 0x1dc
 1001336:	f04f 0b00 	mov.w	fp, #0
 100133a:	9308      	str	r3, [sp, #32]
 100133c:	493f      	ldr	r1, [pc, #252]	; (100143c <ull_periph_setup+0x42c>)
				     HAL_TICKER_REMAINDER(conn_interval_us),
 100133e:	4b40      	ldr	r3, [pc, #256]	; (1001440 <ull_periph_setup+0x430>)
 1001340:	f020 477f 	bic.w	r7, r0, #4278190080	; 0xff000000
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1001344:	9107      	str	r1, [sp, #28]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 1001346:	fba7 3103 	umull	r3, r1, r7, r3
 100134a:	1ae8      	subs	r0, r5, r3
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 100134c:	4b3d      	ldr	r3, [pc, #244]	; (1001444 <ull_periph_setup+0x434>)
				     HAL_TICKER_REMAINDER(conn_interval_us),
 100134e:	fb02 1107 	mla	r1, r2, r7, r1
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1001352:	9305      	str	r3, [sp, #20]
 1001354:	6933      	ldr	r3, [r6, #16]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 1001356:	eb69 0101 	sbc.w	r1, r9, r1
 100135a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 100135e:	e9cd b303 	strd	fp, r3, [sp, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 1001362:	2300      	movs	r3, #0
 1001364:	f7fe fea8 	bl	10000b8 <__aeabi_uldivmod>
 1001368:	4601      	mov	r1, r0
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 100136a:	3403      	adds	r4, #3
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 100136c:	b2e4      	uxtb	r4, r4
 100136e:	4643      	mov	r3, r8
 1001370:	9102      	str	r1, [sp, #8]
 1001372:	4622      	mov	r2, r4
 1001374:	4658      	mov	r0, fp
 1001376:	2101      	movs	r1, #1
 1001378:	e9cd a700 	strd	sl, r7, [sp]
 100137c:	f010 fe8e 	bl	101209c <ticker_start>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 1001380:	f030 0302 	bics.w	r3, r0, #2
 1001384:	d00c      	beq.n	10013a0 <ull_periph_setup+0x390>
 1001386:	f240 13dd 	movw	r3, #477	; 0x1dd
 100138a:	4a2f      	ldr	r2, [pc, #188]	; (1001448 <ull_periph_setup+0x438>)
 100138c:	492f      	ldr	r1, [pc, #188]	; (100144c <ull_periph_setup+0x43c>)
 100138e:	4830      	ldr	r0, [pc, #192]	; (1001450 <ull_periph_setup+0x440>)
 1001390:	f023 fc21 	bl	1024bd6 <assert_print>
 1001394:	4040      	eors	r0, r0
 1001396:	f380 8811 	msr	BASEPRI, r0
 100139a:	f04f 0003 	mov.w	r0, #3
 100139e:	df02      	svc	2
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
 10013a0:	2201      	movs	r2, #1
 10013a2:	2102      	movs	r1, #2
 10013a4:	4610      	mov	r0, r2
 10013a6:	f00f fde9 	bl	1010f7c <mayfly_enable>
}
 10013aa:	b013      	add	sp, #76	; 0x4c
 10013ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cc));
 10013b0:	f44f 7381 	mov.w	r3, #258	; 0x102
 10013b4:	4a24      	ldr	r2, [pc, #144]	; (1001448 <ull_periph_setup+0x438>)
 10013b6:	4927      	ldr	r1, [pc, #156]	; (1001454 <ull_periph_setup+0x444>)
 10013b8:	4825      	ldr	r0, [pc, #148]	; (1001450 <ull_periph_setup+0x440>)
 10013ba:	f023 fc0c 	bl	1024bd6 <assert_print>
 10013be:	4040      	eors	r0, r0
 10013c0:	f380 8811 	msr	BASEPRI, r0
 10013c4:	f04f 0003 	mov.w	r0, #3
 10013c8:	df02      	svc	2
 10013ca:	e712      	b.n	10011f2 <ull_periph_setup+0x1e2>
		ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
 10013cc:	2300      	movs	r3, #0
 10013ce:	2201      	movs	r2, #1
 10013d0:	4618      	mov	r0, r3
 10013d2:	4611      	mov	r1, r2
 10013d4:	9300      	str	r3, [sp, #0]
 10013d6:	f010 feed 	bl	10121b4 <ticker_stop>
 10013da:	e796      	b.n	100130a <ull_periph_setup+0x2fa>
			lll->data_chan_sel = 1;
 10013dc:	7f6a      	ldrb	r2, [r5, #29]
			lll->data_chan_id = lll_chan_id(lll->access_addr);
 10013de:	4638      	mov	r0, r7
			lll->data_chan_sel = 1;
 10013e0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 10013e4:	776a      	strb	r2, [r5, #29]
			lll->data_chan_id = lll_chan_id(lll->access_addr);
 10013e6:	930a      	str	r3, [sp, #40]	; 0x28
 10013e8:	f019 fdc4 	bl	101af74 <lll_chan_id>
 10013ec:	f04f 0b01 	mov.w	fp, #1
 10013f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 10013f2:	83e8      	strh	r0, [r5, #30]
			cs->csa = 0x01;
 10013f4:	e72b      	b.n	100124e <ull_periph_setup+0x23e>
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 10013f6:	f013 f857 	bl	10144a8 <ull_disable_mark_get>
 10013fa:	4581      	cmp	r9, r0
 10013fc:	d081      	beq.n	1001302 <ull_periph_setup+0x2f2>
 10013fe:	f240 23a6 	movw	r3, #678	; 0x2a6
 1001402:	4a11      	ldr	r2, [pc, #68]	; (1001448 <ull_periph_setup+0x438>)
 1001404:	4914      	ldr	r1, [pc, #80]	; (1001458 <ull_periph_setup+0x448>)
 1001406:	4812      	ldr	r0, [pc, #72]	; (1001450 <ull_periph_setup+0x440>)
 1001408:	f023 fbe5 	bl	1024bd6 <assert_print>
 100140c:	4040      	eors	r0, r0
 100140e:	f380 8811 	msr	BASEPRI, r0
 1001412:	f04f 0003 	mov.w	r0, #3
 1001416:	df02      	svc	2
		  param == ull_disable_mark_get());
}
 1001418:	e773      	b.n	1001302 <ull_periph_setup+0x2f2>
 100141a:	bf00      	nop
 100141c:	f3af 8000 	nop.w
 1001420:	1afd498d 	.word	0x1afd498d
 1001424:	00000007 	.word	0x00000007
 1001428:	431bde83 	.word	0x431bde83
 100142c:	01c9c37f 	.word	0x01c9c37f
 1001430:	004c4b40 	.word	0x004c4b40
 1001434:	3b9aca00 	.word	0x3b9aca00
 1001438:	0101ad31 	.word	0x0101ad31
 100143c:	0101ad01 	.word	0x0101ad01
 1001440:	1afd498d 	.word	0x1afd498d
 1001444:	0101ad6d 	.word	0x0101ad6d
 1001448:	0102ade4 	.word	0x0102ade4
 100144c:	0102a9a0 	.word	0x0102a9a0
 1001450:	0102a278 	.word	0x0102a278
 1001454:	0102a470 	.word	0x0102a470
 1001458:	0102ae40 	.word	0x0102ae40
 100145c:	00000000 	.word	0x00000000

01001460 <lll_preempt_calc>:
	}
}

uint32_t lll_preempt_calc(struct ull_hdr *ull, uint8_t ticker_id,
		       uint32_t ticks_at_event)
{
 1001460:	b510      	push	{r4, lr}
 1001462:	4614      	mov	r4, r2
	uint32_t ticks_now;
	uint32_t diff;

	ticks_now = ticker_ticks_now_get();
 1001464:	f010 ff14 	bl	1012290 <ticker_ticks_now_get>
	diff = ticker_ticks_diff_get(ticks_now, ticks_at_event);
 1001468:	4621      	mov	r1, r4
 100146a:	f010 ff13 	bl	1012294 <ticker_ticks_diff_get>
 100146e:	4603      	mov	r3, r0
	if (diff & BIT(HAL_TICKER_CNTR_MSBIT)) {
 1001470:	f410 0000 	ands.w	r0, r0, #8388608	; 0x800000
 1001474:	d103      	bne.n	100147e <lll_preempt_calc+0x1e>
		return 0;
	}

	diff += HAL_TICKER_CNTR_CMP_OFFSET_MIN;
 1001476:	1cdc      	adds	r4, r3, #3
	if (diff > HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US)) {
 1001478:	2c09      	cmp	r4, #9
 100147a:	d802      	bhi.n	1001482 <lll_preempt_calc+0x22>

		return 1U;
	}

	return 0U;
}
 100147c:	bd10      	pop	{r4, pc}
		return 0;
 100147e:	2000      	movs	r0, #0
}
 1001480:	bd10      	pop	{r4, pc}
		LL_ASSERT_MSG(false, "%s: Actual EVENT_OVERHEAD_START_US = %u",
 1001482:	f240 13d9 	movw	r3, #473	; 0x1d9
 1001486:	4a10      	ldr	r2, [pc, #64]	; (10014c8 <lll_preempt_calc+0x68>)
 1001488:	4910      	ldr	r1, [pc, #64]	; (10014cc <lll_preempt_calc+0x6c>)
 100148a:	4811      	ldr	r0, [pc, #68]	; (10014d0 <lll_preempt_calc+0x70>)
 100148c:	f023 fba3 	bl	1024bd6 <assert_print>
 1001490:	2107      	movs	r1, #7
 1001492:	4810      	ldr	r0, [pc, #64]	; (10014d4 <lll_preempt_calc+0x74>)
 1001494:	fba4 0300 	umull	r0, r3, r4, r0
 1001498:	fb01 3104 	mla	r1, r1, r4, r3
 100149c:	a308      	add	r3, pc, #32	; (adr r3, 10014c0 <lll_preempt_calc+0x60>)
 100149e:	e9d3 2300 	ldrd	r2, r3, [r3]
 10014a2:	f7fe fe09 	bl	10000b8 <__aeabi_uldivmod>
 10014a6:	490c      	ldr	r1, [pc, #48]	; (10014d8 <lll_preempt_calc+0x78>)
 10014a8:	4602      	mov	r2, r0
 10014aa:	480c      	ldr	r0, [pc, #48]	; (10014dc <lll_preempt_calc+0x7c>)
 10014ac:	f023 fb93 	bl	1024bd6 <assert_print>
 10014b0:	4040      	eors	r0, r0
 10014b2:	f380 8811 	msr	BASEPRI, r0
 10014b6:	f04f 0003 	mov.w	r0, #3
 10014ba:	df02      	svc	2
		return 1U;
 10014bc:	2001      	movs	r0, #1
}
 10014be:	bd10      	pop	{r4, pc}
 10014c0:	3b9aca00 	.word	0x3b9aca00
 10014c4:	00000000 	.word	0x00000000
 10014c8:	0102ae70 	.word	0x0102ae70
 10014cc:	0102a300 	.word	0x0102a300
 10014d0:	0102a278 	.word	0x0102a278
 10014d4:	1afd498d 	.word	0x1afd498d
 10014d8:	0102b070 	.word	0x0102b070
 10014dc:	0102b010 	.word	0x0102b010

010014e0 <nrf_flash_sync_exe>:
	_ticker_sync_context.interval = duration - FLASH_SYNC_SWITCHING_TIME;
	_ticker_sync_context.slot = duration;
}

int nrf_flash_sync_exe(struct flash_op_desc *op_desc)
{
 10014e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10014e4:	b08f      	sub	sp, #60	; 0x3c
	uint8_t ticker_id;
	uint32_t ret;
	int result;

	/* Get the ticker instance and ticker id for flash operations */
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
 10014e6:	f10d 0137 	add.w	r1, sp, #55	; 0x37
{
 10014ea:	900b      	str	r0, [sp, #44]	; 0x2c
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
 10014ec:	f10d 0036 	add.w	r0, sp, #54	; 0x36
 10014f0:	f012 ff72 	bl	10143d8 <ll_timeslice_ticker_id_get>

	/* Start periodic flash operation prepare time slots */
	ret = ticker_start(instance_index,
 10014f4:	f89d a036 	ldrb.w	sl, [sp, #54]	; 0x36
 10014f8:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
 10014fc:	f010 fec8 	bl	1012290 <ticker_ticks_now_get>
			      /* (MAYFLY_CALL_ID_PROGRAM) */
			   ticker_id, /* flash ticker id */
			   ticker_ticks_now_get(), /* current tick */
			   0, /* first int. immediately */
			   /* period */
			   HAL_TICKER_US_TO_TICKS(
 1001500:	a335      	add	r3, pc, #212	; (adr r3, 10015d8 <nrf_flash_sync_exe+0xf8>)
 1001502:	e9d3 2300 	ldrd	r2, r3, [r3]
 1001506:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 10015e0 <nrf_flash_sync_exe+0x100>
 100150a:	4f36      	ldr	r7, [pc, #216]	; (10015e4 <nrf_flash_sync_exe+0x104>)
 100150c:	f8d8 4000 	ldr.w	r4, [r8]
	ret = ticker_start(instance_index,
 1001510:	2600      	movs	r6, #0
			   HAL_TICKER_US_TO_TICKS(
 1001512:	fba4 5407 	umull	r5, r4, r4, r7
	ret = ticker_start(instance_index,
 1001516:	900a      	str	r0, [sp, #40]	; 0x28
			   HAL_TICKER_US_TO_TICKS(
 1001518:	4621      	mov	r1, r4
 100151a:	4628      	mov	r0, r5
 100151c:	f7fe fdcc 	bl	10000b8 <__aeabi_uldivmod>
	ret = ticker_start(instance_index,
 1001520:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 1001522:	e9cd 6607 	strd	r6, r6, [sp, #28]
 1001526:	9306      	str	r3, [sp, #24]
 1001528:	4b2f      	ldr	r3, [pc, #188]	; (10015e8 <nrf_flash_sync_exe+0x108>)
			   HAL_TICKER_US_TO_TICKS(
 100152a:	4681      	mov	r9, r0
	ret = ticker_start(instance_index,
 100152c:	9305      	str	r3, [sp, #20]
				_ticker_sync_context.interval),
			   /* period remainder */
			   HAL_TICKER_REMAINDER(_ticker_sync_context.interval),
			   0, /* lazy, voluntary skips */
			   HAL_TICKER_US_TO_TICKS(_ticker_sync_context.slot),
 100152e:	f8d8 0004 	ldr.w	r0, [r8, #4]
 1001532:	a329      	add	r3, pc, #164	; (adr r3, 10015d8 <nrf_flash_sync_exe+0xf8>)
 1001534:	e9d3 2300 	ldrd	r2, r3, [r3]
 1001538:	fba0 0107 	umull	r0, r1, r0, r7
 100153c:	f7fe fdbc 	bl	10000b8 <__aeabi_uldivmod>
			   HAL_TICKER_REMAINDER(_ticker_sync_context.interval),
 1001540:	2207      	movs	r2, #7
 1001542:	4b2a      	ldr	r3, [pc, #168]	; (10015ec <nrf_flash_sync_exe+0x10c>)
 1001544:	f029 477f 	bic.w	r7, r9, #4278190080	; 0xff000000
 1001548:	fba7 3103 	umull	r3, r1, r7, r3
 100154c:	fb02 1107 	mla	r1, r2, r7, r1
	ret = ticker_start(instance_index,
 1001550:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 1001554:	e9cd 6003 	strd	r6, r0, [sp, #12]
			   HAL_TICKER_REMAINDER(_ticker_sync_context.interval),
 1001558:	1ae8      	subs	r0, r5, r3
 100155a:	eb64 0101 	sbc.w	r1, r4, r1
 100155e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 1001562:	2300      	movs	r3, #0
 1001564:	f7fe fda8 	bl	10000b8 <__aeabi_uldivmod>
	ret = ticker_start(instance_index,
 1001568:	465a      	mov	r2, fp
 100156a:	e9cd 7001 	strd	r7, r0, [sp, #4]
 100156e:	2103      	movs	r1, #3
 1001570:	4650      	mov	r0, sl
 1001572:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 1001574:	9600      	str	r6, [sp, #0]
 1001576:	f010 fd91 	bl	101209c <ticker_start>
			   time_slot_callback_prepare,
			   op_desc,
			   NULL, /* no op callback */
			   NULL);

	if (ret != TICKER_STATUS_SUCCESS && ret != TICKER_STATUS_BUSY) {
 100157a:	f030 0402 	bics.w	r4, r0, #2
 100157e:	d126      	bne.n	10015ce <nrf_flash_sync_exe+0xee>
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm1 = { .val = timeout };
		return (int) arch_syscall_invoke3(parm0.x, parm1.split.lo, parm1.split.hi, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
 1001580:	2300      	movs	r3, #0
 1001582:	4a1b      	ldr	r2, [pc, #108]	; (10015f0 <nrf_flash_sync_exe+0x110>)
 1001584:	481b      	ldr	r0, [pc, #108]	; (10015f4 <nrf_flash_sync_exe+0x114>)
 1001586:	f020 f8cf 	bl	1021728 <z_impl_k_sem_take>
		/* Failed to enqueue the ticker start operation request */
		result = -ECANCELED;
	} else if (k_sem_take(&sem_sync, K_MSEC(FLASH_TIMEOUT_MS)) != 0) {
 100158a:	b1c0      	cbz	r0, 10015be <nrf_flash_sync_exe+0xde>
		/* Stop any scheduled jobs, from thread context */
		ret = ticker_stop(instance_index, 3U, ticker_id, NULL, NULL);
 100158c:	4623      	mov	r3, r4
 100158e:	2103      	movs	r1, #3
 1001590:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 1001594:	f89d 0036 	ldrb.w	r0, [sp, #54]	; 0x36
 1001598:	9400      	str	r4, [sp, #0]
 100159a:	f010 fe0b 	bl	10121b4 <ticker_stop>
		__ASSERT((ret == TICKER_STATUS_SUCCESS ||
 100159e:	f030 0302 	bics.w	r3, r0, #2
 10015a2:	d011      	beq.n	10015c8 <nrf_flash_sync_exe+0xe8>
 10015a4:	4914      	ldr	r1, [pc, #80]	; (10015f8 <nrf_flash_sync_exe+0x118>)
 10015a6:	23e4      	movs	r3, #228	; 0xe4
 10015a8:	4a14      	ldr	r2, [pc, #80]	; (10015fc <nrf_flash_sync_exe+0x11c>)
 10015aa:	4815      	ldr	r0, [pc, #84]	; (1001600 <nrf_flash_sync_exe+0x120>)
 10015ac:	f023 fb13 	bl	1024bd6 <assert_print>
 10015b0:	4814      	ldr	r0, [pc, #80]	; (1001604 <nrf_flash_sync_exe+0x124>)
 10015b2:	f023 fb10 	bl	1024bd6 <assert_print>
 10015b6:	21e4      	movs	r1, #228	; 0xe4
 10015b8:	4810      	ldr	r0, [pc, #64]	; (10015fc <nrf_flash_sync_exe+0x11c>)
 10015ba:	f023 fb05 	bl	1024bc8 <assert_post_action>
			 "Failed to stop ticker.\n");

		/* wait for operation's complete overrun*/
		result = -ETIMEDOUT;
	} else {
		result = _ticker_sync_context.result;
 10015be:	f8d8 000c 	ldr.w	r0, [r8, #12]
	}

	return result;
}
 10015c2:	b00f      	add	sp, #60	; 0x3c
 10015c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		result = -ETIMEDOUT;
 10015c8:	f06f 0073 	mvn.w	r0, #115	; 0x73
 10015cc:	e7f9      	b.n	10015c2 <nrf_flash_sync_exe+0xe2>
		result = -ECANCELED;
 10015ce:	f06f 008b 	mvn.w	r0, #139	; 0x8b
	return result;
 10015d2:	e7f6      	b.n	10015c2 <nrf_flash_sync_exe+0xe2>
 10015d4:	f3af 8000 	nop.w
 10015d8:	1afd498d 	.word	0x1afd498d
 10015dc:	00000007 	.word	0x00000007
 10015e0:	21007fa0 	.word	0x21007fa0
 10015e4:	3b9aca00 	.word	0x3b9aca00
 10015e8:	0101efd5 	.word	0x0101efd5
 10015ec:	1afd498d 	.word	0x1afd498d
 10015f0:	0005bd92 	.word	0x0005bd92
 10015f4:	21007f88 	.word	0x21007f88
 10015f8:	0102f1c1 	.word	0x0102f1c1
 10015fc:	0102f15b 	.word	0x0102f15b
 1001600:	0102b695 	.word	0x0102b695
 1001604:	0102f206 	.word	0x0102f206

01001608 <nrf_flash_sync_check_time_limit>:
{
	_ticker_sync_context.ticks_begin = ticker_ticks_now_get();
}

bool nrf_flash_sync_check_time_limit(uint32_t iteration)
{
 1001608:	b538      	push	{r3, r4, r5, lr}
	uint32_t ticks_diff;

	ticks_diff = ticker_ticks_diff_get(ticker_ticks_now_get(),
 100160a:	4d0f      	ldr	r5, [pc, #60]	; (1001648 <nrf_flash_sync_check_time_limit+0x40>)
{
 100160c:	4604      	mov	r4, r0
	ticks_diff = ticker_ticks_diff_get(ticker_ticks_now_get(),
 100160e:	f010 fe3f 	bl	1012290 <ticker_ticks_now_get>
 1001612:	68a9      	ldr	r1, [r5, #8]
 1001614:	f010 fe3e 	bl	1012294 <ticker_ticks_diff_get>
					   _ticker_sync_context.ticks_begin);
	if (ticks_diff + ticks_diff/iteration >
	    HAL_TICKER_US_TO_TICKS(_ticker_sync_context.slot)) {
 1001618:	a309      	add	r3, pc, #36	; (adr r3, 1001640 <nrf_flash_sync_check_time_limit+0x38>)
 100161a:	e9d3 2300 	ldrd	r2, r3, [r3]
	if (ticks_diff + ticks_diff/iteration >
 100161e:	fbb0 f4f4 	udiv	r4, r0, r4
	    HAL_TICKER_US_TO_TICKS(_ticker_sync_context.slot)) {
 1001622:	6869      	ldr	r1, [r5, #4]
	if (ticks_diff + ticks_diff/iteration >
 1001624:	4404      	add	r4, r0
	    HAL_TICKER_US_TO_TICKS(_ticker_sync_context.slot)) {
 1001626:	4809      	ldr	r0, [pc, #36]	; (100164c <nrf_flash_sync_check_time_limit+0x44>)
 1001628:	fba1 0100 	umull	r0, r1, r1, r0
 100162c:	f7fe fd44 	bl	10000b8 <__aeabi_uldivmod>
 1001630:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		return true;
	}

	return false;
}
 1001634:	4284      	cmp	r4, r0
 1001636:	bf94      	ite	ls
 1001638:	2000      	movls	r0, #0
 100163a:	2001      	movhi	r0, #1
 100163c:	bd38      	pop	{r3, r4, r5, pc}
 100163e:	bf00      	nop
 1001640:	1afd498d 	.word	0x1afd498d
 1001644:	00000007 	.word	0x00000007
 1001648:	21007fa0 	.word	0x21007fa0
 100164c:	3b9aca00 	.word	0x3b9aca00

01001650 <bt_addr_le_to_str.constprop.0.isra.0>:
 *  @param len Length of data to be copied to user string buffer. Refer to
 *  BT_ADDR_LE_STR_LEN about recommended value.
 *
 *  @return Number of successfully formatted bytes from binary address.
 */
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
 1001650:	b570      	push	{r4, r5, r6, lr}
				    size_t len)
{
	char type[10];

	switch (addr->type) {
 1001652:	7803      	ldrb	r3, [r0, #0]
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
 1001654:	b08a      	sub	sp, #40	; 0x28
 1001656:	4604      	mov	r4, r0
 1001658:	460e      	mov	r6, r1
 100165a:	ad07      	add	r5, sp, #28
	switch (addr->type) {
 100165c:	2b03      	cmp	r3, #3
 100165e:	d820      	bhi.n	10016a2 <bt_addr_le_to_str.constprop.0.isra.0+0x52>
 1001660:	e8df f003 	tbb	[pc, r3]
 1001664:	1d1b1902 	.word	0x1d1b1902
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
 1001668:	4911      	ldr	r1, [pc, #68]	; (10016b0 <bt_addr_le_to_str.constprop.0.isra.0+0x60>)
		break;
	case BT_ADDR_LE_RANDOM:
		strcpy(type, "random");
 100166a:	4628      	mov	r0, r5
 100166c:	f025 f939 	bl	10268e2 <strcpy>
	default:
		snprintk(type, sizeof(type), "0x%02x", addr->type);
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
 1001670:	9505      	str	r5, [sp, #20]
 1001672:	7863      	ldrb	r3, [r4, #1]
 1001674:	211e      	movs	r1, #30
 1001676:	9304      	str	r3, [sp, #16]
 1001678:	78a3      	ldrb	r3, [r4, #2]
 100167a:	4630      	mov	r0, r6
 100167c:	9303      	str	r3, [sp, #12]
 100167e:	78e3      	ldrb	r3, [r4, #3]
 1001680:	4a0c      	ldr	r2, [pc, #48]	; (10016b4 <bt_addr_le_to_str.constprop.0.isra.0+0x64>)
 1001682:	9302      	str	r3, [sp, #8]
 1001684:	7923      	ldrb	r3, [r4, #4]
 1001686:	9301      	str	r3, [sp, #4]
 1001688:	7963      	ldrb	r3, [r4, #5]
 100168a:	9300      	str	r3, [sp, #0]
 100168c:	79a3      	ldrb	r3, [r4, #6]
 100168e:	f023 f8a7 	bl	10247e0 <snprintk>
			addr->a.val[5], addr->a.val[4], addr->a.val[3],
			addr->a.val[2], addr->a.val[1], addr->a.val[0], type);
}
 1001692:	b00a      	add	sp, #40	; 0x28
 1001694:	bd70      	pop	{r4, r5, r6, pc}
		strcpy(type, "random");
 1001696:	4908      	ldr	r1, [pc, #32]	; (10016b8 <bt_addr_le_to_str.constprop.0.isra.0+0x68>)
 1001698:	e7e7      	b.n	100166a <bt_addr_le_to_str.constprop.0.isra.0+0x1a>
		strcpy(type, "public-id");
 100169a:	4908      	ldr	r1, [pc, #32]	; (10016bc <bt_addr_le_to_str.constprop.0.isra.0+0x6c>)
 100169c:	e7e5      	b.n	100166a <bt_addr_le_to_str.constprop.0.isra.0+0x1a>
		strcpy(type, "random-id");
 100169e:	4908      	ldr	r1, [pc, #32]	; (10016c0 <bt_addr_le_to_str.constprop.0.isra.0+0x70>)
 10016a0:	e7e3      	b.n	100166a <bt_addr_le_to_str.constprop.0.isra.0+0x1a>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
 10016a2:	210a      	movs	r1, #10
 10016a4:	4628      	mov	r0, r5
 10016a6:	4a07      	ldr	r2, [pc, #28]	; (10016c4 <bt_addr_le_to_str.constprop.0.isra.0+0x74>)
 10016a8:	f023 f89a 	bl	10247e0 <snprintk>
		break;
 10016ac:	e7e0      	b.n	1001670 <bt_addr_le_to_str.constprop.0.isra.0+0x20>
 10016ae:	bf00      	nop
 10016b0:	0102b404 	.word	0x0102b404
 10016b4:	0102b426 	.word	0x0102b426
 10016b8:	0102b40b 	.word	0x0102b40b
 10016bc:	0102b412 	.word	0x0102b412
 10016c0:	0102b41c 	.word	0x0102b41c
 10016c4:	0102eaf6 	.word	0x0102eaf6

010016c8 <security_changed>:


#ifdef CONFIG_BT_NUS_SECURITY_ENABLED
static void security_changed(struct bt_conn *conn, bt_security_t level,
			     enum bt_security_err err)
{
 10016c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 10016ca:	4614      	mov	r4, r2
 10016cc:	b089      	sub	sp, #36	; 0x24
 10016ce:	af00      	add	r7, sp, #0
 10016d0:	460d      	mov	r5, r1
	char addr[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
 10016d2:	f025 fdfd 	bl	10272d0 <bt_conn_get_dst>
 10016d6:	4639      	mov	r1, r7
 10016d8:	f7ff ffba 	bl	1001650 <bt_addr_le_to_str.constprop.0.isra.0>

	if (!err) {
		LOG_INF("Security changed: %s level %u", (addr),
 10016dc:	466e      	mov	r6, sp
	if (!err) {
 10016de:	b9ac      	cbnz	r4, 100170c <security_changed+0x44>
		LOG_INF("Security changed: %s level %u", (addr),
 10016e0:	b08a      	sub	sp, #40	; 0x28
 10016e2:	466a      	mov	r2, sp
 10016e4:	4b12      	ldr	r3, [pc, #72]	; (1001730 <security_changed+0x68>)
 10016e6:	61d5      	str	r5, [r2, #28]
 10016e8:	e9c2 3705 	strd	r3, r7, [r2, #20]
 10016ec:	f44f 7300 	mov.w	r3, #512	; 0x200
 10016f0:	8413      	strh	r3, [r2, #32]
 10016f2:	4b10      	ldr	r3, [pc, #64]	; (1001734 <security_changed+0x6c>)
 10016f4:	f44f 5113 	mov.w	r1, #9408	; 0x24c0
 10016f8:	f842 3f10 	str.w	r3, [r2, #16]!
 10016fc:	4623      	mov	r3, r4
			level);
	} else {
		LOG_WRN("Security failed: %s level %u err %d", (addr),
 10016fe:	480e      	ldr	r0, [pc, #56]	; (1001738 <security_changed+0x70>)
 1001700:	f022 ff22 	bl	1024548 <z_log_msg_static_create>
 1001704:	46b5      	mov	sp, r6
			level, err);
	}
}
 1001706:	3724      	adds	r7, #36	; 0x24
 1001708:	46bd      	mov	sp, r7
 100170a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LOG_WRN("Security failed: %s level %u err %d", (addr),
 100170c:	b08a      	sub	sp, #40	; 0x28
 100170e:	466a      	mov	r2, sp
 1001710:	4b0a      	ldr	r3, [pc, #40]	; (100173c <security_changed+0x74>)
 1001712:	e9c2 5407 	strd	r5, r4, [r2, #28]
 1001716:	e9c2 3705 	strd	r3, r7, [r2, #20]
 100171a:	f44f 7300 	mov.w	r3, #512	; 0x200
 100171e:	8493      	strh	r3, [r2, #36]	; 0x24
 1001720:	4b07      	ldr	r3, [pc, #28]	; (1001740 <security_changed+0x78>)
 1001722:	f44f 5132 	mov.w	r1, #11392	; 0x2c80
 1001726:	f842 3f10 	str.w	r3, [r2, #16]!
 100172a:	2300      	movs	r3, #0
 100172c:	e7e7      	b.n	10016fe <security_changed+0x36>
 100172e:	bf00      	nop
 1001730:	0102b449 	.word	0x0102b449
 1001734:	01000004 	.word	0x01000004
 1001738:	01029a3c 	.word	0x01029a3c
 100173c:	0102b467 	.word	0x0102b467
 1001740:	01000005 	.word	0x01000005

01001744 <pairing_failed>:
		bonded);
}


static void pairing_failed(struct bt_conn *conn, enum bt_security_err reason)
{
 1001744:	b590      	push	{r4, r7, lr}
 1001746:	b089      	sub	sp, #36	; 0x24
 1001748:	af00      	add	r7, sp, #0
 100174a:	460c      	mov	r4, r1
	char addr[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
 100174c:	f025 fdc0 	bl	10272d0 <bt_conn_get_dst>
 1001750:	4639      	mov	r1, r7
 1001752:	f7ff ff7d 	bl	1001650 <bt_addr_le_to_str.constprop.0.isra.0>

	LOG_INF("Pairing failed conn: %s, reason %d", (addr),
 1001756:	b08a      	sub	sp, #40	; 0x28
 1001758:	466a      	mov	r2, sp
 100175a:	4b09      	ldr	r3, [pc, #36]	; (1001780 <pairing_failed+0x3c>)
 100175c:	61d4      	str	r4, [r2, #28]
 100175e:	e9c2 3705 	strd	r3, r7, [r2, #20]
 1001762:	f44f 7300 	mov.w	r3, #512	; 0x200
 1001766:	8413      	strh	r3, [r2, #32]
 1001768:	4b06      	ldr	r3, [pc, #24]	; (1001784 <pairing_failed+0x40>)
 100176a:	f44f 5113 	mov.w	r1, #9408	; 0x24c0
 100176e:	f842 3f10 	str.w	r3, [r2, #16]!
 1001772:	4805      	ldr	r0, [pc, #20]	; (1001788 <pairing_failed+0x44>)
 1001774:	2300      	movs	r3, #0
 1001776:	f022 fee7 	bl	1024548 <z_log_msg_static_create>
		reason);
}
 100177a:	3724      	adds	r7, #36	; 0x24
 100177c:	46bd      	mov	sp, r7
 100177e:	bd90      	pop	{r4, r7, pc}
 1001780:	0102b48b 	.word	0x0102b48b
 1001784:	01000004 	.word	0x01000004
 1001788:	01029a3c 	.word	0x01029a3c

0100178c <pairing_complete>:
{
 100178c:	b590      	push	{r4, r7, lr}
 100178e:	b089      	sub	sp, #36	; 0x24
 1001790:	af00      	add	r7, sp, #0
 1001792:	460c      	mov	r4, r1
	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
 1001794:	f025 fd9c 	bl	10272d0 <bt_conn_get_dst>
 1001798:	4639      	mov	r1, r7
 100179a:	f7ff ff59 	bl	1001650 <bt_addr_le_to_str.constprop.0.isra.0>
	LOG_INF("Pairing completed: %s, bonded: %d", (addr),
 100179e:	b08a      	sub	sp, #40	; 0x28
 10017a0:	466a      	mov	r2, sp
 10017a2:	4b09      	ldr	r3, [pc, #36]	; (10017c8 <pairing_complete+0x3c>)
 10017a4:	61d4      	str	r4, [r2, #28]
 10017a6:	e9c2 3705 	strd	r3, r7, [r2, #20]
 10017aa:	f44f 7300 	mov.w	r3, #512	; 0x200
 10017ae:	8413      	strh	r3, [r2, #32]
 10017b0:	4b06      	ldr	r3, [pc, #24]	; (10017cc <pairing_complete+0x40>)
 10017b2:	f44f 5113 	mov.w	r1, #9408	; 0x24c0
 10017b6:	f842 3f10 	str.w	r3, [r2, #16]!
 10017ba:	4805      	ldr	r0, [pc, #20]	; (10017d0 <pairing_complete+0x44>)
 10017bc:	2300      	movs	r3, #0
 10017be:	f022 fec3 	bl	1024548 <z_log_msg_static_create>
}
 10017c2:	3724      	adds	r7, #36	; 0x24
 10017c4:	46bd      	mov	sp, r7
 10017c6:	bd90      	pop	{r4, r7, pc}
 10017c8:	0102b4ae 	.word	0x0102b4ae
 10017cc:	01000004 	.word	0x01000004
 10017d0:	01029a3c 	.word	0x01029a3c

010017d4 <auth_cancel>:
{
 10017d4:	b580      	push	{r7, lr}
 10017d6:	b088      	sub	sp, #32
 10017d8:	af00      	add	r7, sp, #0
	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
 10017da:	f025 fd79 	bl	10272d0 <bt_conn_get_dst>
 10017de:	4639      	mov	r1, r7
 10017e0:	f7ff ff36 	bl	1001650 <bt_addr_le_to_str.constprop.0.isra.0>
	LOG_INF("Pairing cancelled: %s", (addr));
 10017e4:	b088      	sub	sp, #32
 10017e6:	466a      	mov	r2, sp
 10017e8:	4b08      	ldr	r3, [pc, #32]	; (100180c <auth_cancel+0x38>)
 10017ea:	f44f 51e6 	mov.w	r1, #7360	; 0x1cc0
 10017ee:	e9c2 3705 	strd	r3, r7, [r2, #20]
 10017f2:	f44f 7300 	mov.w	r3, #512	; 0x200
 10017f6:	8393      	strh	r3, [r2, #28]
 10017f8:	4b05      	ldr	r3, [pc, #20]	; (1001810 <auth_cancel+0x3c>)
 10017fa:	4806      	ldr	r0, [pc, #24]	; (1001814 <auth_cancel+0x40>)
 10017fc:	f842 3f10 	str.w	r3, [r2, #16]!
 1001800:	2300      	movs	r3, #0
 1001802:	f022 fea1 	bl	1024548 <z_log_msg_static_create>
}
 1001806:	3720      	adds	r7, #32
 1001808:	46bd      	mov	sp, r7
 100180a:	bd80      	pop	{r7, pc}
 100180c:	0102b4d0 	.word	0x0102b4d0
 1001810:	01000003 	.word	0x01000003
 1001814:	01029a3c 	.word	0x01029a3c

01001818 <disconnected>:
{
 1001818:	b5b0      	push	{r4, r5, r7, lr}
 100181a:	b088      	sub	sp, #32
 100181c:	af00      	add	r7, sp, #0
 100181e:	460c      	mov	r4, r1
	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
 1001820:	f025 fd56 	bl	10272d0 <bt_conn_get_dst>
 1001824:	4639      	mov	r1, r7
 1001826:	f7ff ff13 	bl	1001650 <bt_addr_le_to_str.constprop.0.isra.0>
	LOG_INF("Disconnected: %s (reason %u)", (addr), reason);
 100182a:	466d      	mov	r5, sp
 100182c:	b08a      	sub	sp, #40	; 0x28
 100182e:	466a      	mov	r2, sp
 1001830:	4b17      	ldr	r3, [pc, #92]	; (1001890 <disconnected+0x78>)
 1001832:	61d4      	str	r4, [r2, #28]
 1001834:	e9c2 3705 	strd	r3, r7, [r2, #20]
 1001838:	f44f 7300 	mov.w	r3, #512	; 0x200
 100183c:	8413      	strh	r3, [r2, #32]
 100183e:	4b15      	ldr	r3, [pc, #84]	; (1001894 <disconnected+0x7c>)
	if (current_conn) {
 1001840:	4c15      	ldr	r4, [pc, #84]	; (1001898 <disconnected+0x80>)
	LOG_INF("Disconnected: %s (reason %u)", (addr), reason);
 1001842:	4816      	ldr	r0, [pc, #88]	; (100189c <disconnected+0x84>)
 1001844:	f842 3f10 	str.w	r3, [r2, #16]!
 1001848:	f44f 5113 	mov.w	r1, #9408	; 0x24c0
 100184c:	2300      	movs	r3, #0
 100184e:	f022 fe7b 	bl	1024548 <z_log_msg_static_create>
	if (current_conn) {
 1001852:	6820      	ldr	r0, [r4, #0]
 1001854:	46ad      	mov	sp, r5
 1001856:	b118      	cbz	r0, 1001860 <disconnected+0x48>
		bt_conn_unref(current_conn);
 1001858:	f008 fc20 	bl	100a09c <bt_conn_unref>
		current_conn = NULL;		
 100185c:	2300      	movs	r3, #0
 100185e:	6023      	str	r3, [r4, #0]
	int err = net2app_send_conn_status(0);
 1001860:	2000      	movs	r0, #0
 1001862:	f022 fe86 	bl	1024572 <net2app_send_conn_status>
	if (err) {
 1001866:	b178      	cbz	r0, 1001888 <disconnected+0x70>
		LOG_ERR("send disconnected err %d", err);
 1001868:	466c      	mov	r4, sp
 100186a:	b088      	sub	sp, #32
 100186c:	466a      	mov	r2, sp
 100186e:	4b0c      	ldr	r3, [pc, #48]	; (10018a0 <disconnected+0x88>)
 1001870:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1001874:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1001878:	2303      	movs	r3, #3
 100187a:	4808      	ldr	r0, [pc, #32]	; (100189c <disconnected+0x84>)
 100187c:	f842 3f10 	str.w	r3, [r2, #16]!
 1001880:	2300      	movs	r3, #0
 1001882:	f022 fe61 	bl	1024548 <z_log_msg_static_create>
 1001886:	46a5      	mov	sp, r4
}
 1001888:	3720      	adds	r7, #32
 100188a:	46bd      	mov	sp, r7
 100188c:	bdb0      	pop	{r4, r5, r7, pc}
 100188e:	bf00      	nop
 1001890:	0102b4e6 	.word	0x0102b4e6
 1001894:	01000004 	.word	0x01000004
 1001898:	210045c8 	.word	0x210045c8
 100189c:	01029a3c 	.word	0x01029a3c
 10018a0:	0102b503 	.word	0x0102b503

010018a4 <connected>:
{
 10018a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10018a8:	b08e      	sub	sp, #56	; 0x38
 10018aa:	4605      	mov	r5, r0
	if (err) {
 10018ac:	460c      	mov	r4, r1
{
 10018ae:	af00      	add	r7, sp, #0
	if (err) {
 10018b0:	b199      	cbz	r1, 10018da <connected+0x36>
		LOG_ERR("Connection failed (err %u)", err);
 10018b2:	466d      	mov	r5, sp
 10018b4:	b088      	sub	sp, #32
 10018b6:	466a      	mov	r2, sp
 10018b8:	4b2d      	ldr	r3, [pc, #180]	; (1001970 <connected+0xcc>)
 10018ba:	482e      	ldr	r0, [pc, #184]	; (1001974 <connected+0xd0>)
 10018bc:	e9c2 3105 	strd	r3, r1, [r2, #20]
 10018c0:	2303      	movs	r3, #3
 10018c2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 10018c6:	f842 3f10 	str.w	r3, [r2, #16]!
 10018ca:	2300      	movs	r3, #0
 10018cc:	f022 fe3c 	bl	1024548 <z_log_msg_static_create>
 10018d0:	46ad      	mov	sp, r5
}
 10018d2:	3738      	adds	r7, #56	; 0x38
 10018d4:	46bd      	mov	sp, r7
 10018d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
 10018da:	f107 0618 	add.w	r6, r7, #24
 10018de:	f025 fcf7 	bl	10272d0 <bt_conn_get_dst>
 10018e2:	4631      	mov	r1, r6
 10018e4:	f7ff feb4 	bl	1001650 <bt_addr_le_to_str.constprop.0.isra.0>
	LOG_INF("Connected %s", (addr));
 10018e8:	46e8      	mov	r8, sp
 10018ea:	b088      	sub	sp, #32
 10018ec:	466a      	mov	r2, sp
 10018ee:	4b22      	ldr	r3, [pc, #136]	; (1001978 <connected+0xd4>)
 10018f0:	f44f 51e6 	mov.w	r1, #7360	; 0x1cc0
 10018f4:	e9c2 3605 	strd	r3, r6, [r2, #20]
 10018f8:	f44f 7300 	mov.w	r3, #512	; 0x200
 10018fc:	8393      	strh	r3, [r2, #28]
 10018fe:	4b1f      	ldr	r3, [pc, #124]	; (100197c <connected+0xd8>)
 1001900:	481c      	ldr	r0, [pc, #112]	; (1001974 <connected+0xd0>)
 1001902:	f842 3f10 	str.w	r3, [r2, #16]!
 1001906:	4623      	mov	r3, r4
 1001908:	f022 fe1e 	bl	1024548 <z_log_msg_static_create>
	current_conn = bt_conn_ref(conn);
 100190c:	4628      	mov	r0, r5
 100190e:	46c5      	mov	sp, r8
 1001910:	f008 fb9c 	bl	100a04c <bt_conn_ref>
 1001914:	4b1a      	ldr	r3, [pc, #104]	; (1001980 <connected+0xdc>)
 1001916:	6018      	str	r0, [r3, #0]
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
 1001918:	481a      	ldr	r0, [pc, #104]	; (1001984 <connected+0xe0>)
 100191a:	f01f fec1 	bl	10216a0 <z_impl_k_sem_give>
	if (bt_conn_set_security(conn, BT_SECURITY_L2)) {
 100191e:	2102      	movs	r1, #2
 1001920:	4628      	mov	r0, r5
 1001922:	f025 fc87 	bl	1027234 <bt_conn_set_security>
 1001926:	b158      	cbz	r0, 1001940 <connected+0x9c>
		LOG_INF("Failed to set security");
 1001928:	4b17      	ldr	r3, [pc, #92]	; (1001988 <connected+0xe4>)
 100192a:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
 100192e:	617b      	str	r3, [r7, #20]
 1001930:	2302      	movs	r3, #2
 1001932:	4810      	ldr	r0, [pc, #64]	; (1001974 <connected+0xd0>)
 1001934:	613b      	str	r3, [r7, #16]
 1001936:	f107 0210 	add.w	r2, r7, #16
 100193a:	4623      	mov	r3, r4
 100193c:	f022 fe04 	bl	1024548 <z_log_msg_static_create>
	err = net2app_send_conn_status(1);
 1001940:	2001      	movs	r0, #1
 1001942:	f022 fe16 	bl	1024572 <net2app_send_conn_status>
	if (err) {
 1001946:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 100194a:	d0c2      	beq.n	10018d2 <connected+0x2e>
		LOG_ERR("send connected err %d", err);
 100194c:	466c      	mov	r4, sp
 100194e:	b088      	sub	sp, #32
 1001950:	466a      	mov	r2, sp
 1001952:	4b0e      	ldr	r3, [pc, #56]	; (100198c <connected+0xe8>)
 1001954:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1001958:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100195c:	2303      	movs	r3, #3
 100195e:	4805      	ldr	r0, [pc, #20]	; (1001974 <connected+0xd0>)
 1001960:	f842 3f10 	str.w	r3, [r2, #16]!
 1001964:	2300      	movs	r3, #0
 1001966:	f022 fdef 	bl	1024548 <z_log_msg_static_create>
 100196a:	46a5      	mov	sp, r4
 100196c:	e7b1      	b.n	10018d2 <connected+0x2e>
 100196e:	bf00      	nop
 1001970:	0102b51c 	.word	0x0102b51c
 1001974:	01029a3c 	.word	0x01029a3c
 1001978:	0102b537 	.word	0x0102b537
 100197c:	01000003 	.word	0x01000003
 1001980:	210045c8 	.word	0x210045c8
 1001984:	21000c98 	.word	0x21000c98
 1001988:	0102b544 	.word	0x0102b544
 100198c:	0102b55b 	.word	0x0102b55b

01001990 <bt_nus_receive_cb>:
{	
 1001990:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char addr[BT_ADDR_LE_STR_LEN] = {0};
 1001994:	2500      	movs	r5, #0
{	
 1001996:	4604      	mov	r4, r0
 1001998:	b08b      	sub	sp, #44	; 0x2c
 100199a:	af00      	add	r7, sp, #0
 100199c:	4688      	mov	r8, r1
 100199e:	4691      	mov	r9, r2
	char addr[BT_ADDR_LE_STR_LEN] = {0};
 10019a0:	4629      	mov	r1, r5
 10019a2:	221a      	movs	r2, #26
 10019a4:	f107 000c 	add.w	r0, r7, #12
 10019a8:	60bd      	str	r5, [r7, #8]
 10019aa:	f024 ffee 	bl	102698a <memset>
	bt_addr_le_to_str(bt_conn_get_dst(conn), addr, ARRAY_SIZE(addr));
 10019ae:	4620      	mov	r0, r4
 10019b0:	f025 fc8e 	bl	10272d0 <bt_conn_get_dst>
 10019b4:	f107 0108 	add.w	r1, r7, #8
 10019b8:	f7ff fe4a 	bl	1001650 <bt_addr_le_to_str.constprop.0.isra.0>
	LOG_INF("Received data from: %s", (addr));
 10019bc:	466e      	mov	r6, sp
 10019be:	b088      	sub	sp, #32
 10019c0:	466c      	mov	r4, sp
 10019c2:	f44f 7b00 	mov.w	fp, #512	; 0x200
 10019c6:	4622      	mov	r2, r4
 10019c8:	4b1f      	ldr	r3, [pc, #124]	; (1001a48 <bt_nus_receive_cb+0xb8>)
 10019ca:	f8df a080 	ldr.w	sl, [pc, #128]	; 1001a4c <bt_nus_receive_cb+0xbc>
 10019ce:	6163      	str	r3, [r4, #20]
 10019d0:	f107 0308 	add.w	r3, r7, #8
 10019d4:	61a3      	str	r3, [r4, #24]
 10019d6:	f8a4 b01c 	strh.w	fp, [r4, #28]
 10019da:	462b      	mov	r3, r5
 10019dc:	f842 af10 	str.w	sl, [r2, #16]!
 10019e0:	f44f 51e6 	mov.w	r1, #7360	; 0x1cc0
 10019e4:	481a      	ldr	r0, [pc, #104]	; (1001a50 <bt_nus_receive_cb+0xc0>)
 10019e6:	607a      	str	r2, [r7, #4]
 10019e8:	f022 fdae 	bl	1024548 <z_log_msg_static_create>
 10019ec:	46b5      	mov	sp, r6
	LOG_HEXDUMP_INF(data, len, "data:");
 10019ee:	46a5      	mov	sp, r4
 10019f0:	4b18      	ldr	r3, [pc, #96]	; (1001a54 <bt_nus_receive_cb+0xc4>)
 10019f2:	f3c9 010b 	ubfx	r1, r9, #0, #12
 10019f6:	6163      	str	r3, [r4, #20]
 10019f8:	4b17      	ldr	r3, [pc, #92]	; (1001a58 <bt_nus_receive_cb+0xc8>)
 10019fa:	04c9      	lsls	r1, r1, #19
 10019fc:	4814      	ldr	r0, [pc, #80]	; (1001a50 <bt_nus_receive_cb+0xc0>)
 10019fe:	61a3      	str	r3, [r4, #24]
 1001a00:	f441 51e6 	orr.w	r1, r1, #7360	; 0x1cc0
 1001a04:	4643      	mov	r3, r8
 1001a06:	687a      	ldr	r2, [r7, #4]
 1001a08:	f8a4 b01c 	strh.w	fp, [r4, #28]
 1001a0c:	f8c4 a010 	str.w	sl, [r4, #16]
 1001a10:	f022 fd9a 	bl	1024548 <z_log_msg_static_create>
	err = net2app_send_nus((uint8_t *)data, len);
 1001a14:	4649      	mov	r1, r9
 1001a16:	46b5      	mov	sp, r6
 1001a18:	4640      	mov	r0, r8
 1001a1a:	f022 fd97 	bl	102454c <net2app_send_nus>
	if (err) {
 1001a1e:	b170      	cbz	r0, 1001a3e <bt_nus_receive_cb+0xae>
		LOG_ERR("network to application core nus send err %d", err);
 1001a20:	46a5      	mov	sp, r4
 1001a22:	466a      	mov	r2, sp
 1001a24:	4b0d      	ldr	r3, [pc, #52]	; (1001a5c <bt_nus_receive_cb+0xcc>)
 1001a26:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1001a2a:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1001a2e:	2303      	movs	r3, #3
 1001a30:	4807      	ldr	r0, [pc, #28]	; (1001a50 <bt_nus_receive_cb+0xc0>)
 1001a32:	f842 3f10 	str.w	r3, [r2, #16]!
 1001a36:	462b      	mov	r3, r5
 1001a38:	f022 fd86 	bl	1024548 <z_log_msg_static_create>
 1001a3c:	46b5      	mov	sp, r6
}
 1001a3e:	372c      	adds	r7, #44	; 0x2c
 1001a40:	46bd      	mov	sp, r7
 1001a42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1001a46:	bf00      	nop
 1001a48:	0102b571 	.word	0x0102b571
 1001a4c:	01000003 	.word	0x01000003
 1001a50:	01029a3c 	.word	0x01029a3c
 1001a54:	0102b4e3 	.word	0x0102b4e3
 1001a58:	0102b588 	.word	0x0102b588
 1001a5c:	0102b58e 	.word	0x0102b58e

01001a60 <ble_write_thread>:
		send_to_app();	
	}
}

void ble_write_thread(void)
{
 1001a60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1001a64:	af00      	add	r7, sp, #0
	return z_impl_k_sem_take(sem, timeout);
 1001a66:	f04f 33ff 	mov.w	r3, #4294967295
 1001a6a:	f04f 32ff 	mov.w	r2, #4294967295
 1001a6e:	481b      	ldr	r0, [pc, #108]	; (1001adc <ble_write_thread+0x7c>)
 1001a70:	f01f fe5a 	bl	1021728 <z_impl_k_sem_take>
	static uint8_t cnt;
	int err;

	/* Don't go any further until BLE is initialized */
	k_sem_take(&ble_conn_ok, K_FOREVER);
	cnt = 0;
 1001a74:	2300      	movs	r3, #0
 1001a76:	4c1a      	ldr	r4, [pc, #104]	; (1001ae0 <ble_write_thread+0x80>)
 1001a78:	f8df 8068 	ldr.w	r8, [pc, #104]	; 1001ae4 <ble_write_thread+0x84>

	for (;;) {
		k_sem_take(&sem_nus_op, K_FOREVER);		
		snprintf(data, 12, "HelloNet%d", cnt++);		
 1001a7c:	4e1a      	ldr	r6, [pc, #104]	; (1001ae8 <ble_write_thread+0x88>)
 1001a7e:	f8df 906c 	ldr.w	r9, [pc, #108]	; 1001aec <ble_write_thread+0x8c>
	cnt = 0;
 1001a82:	7023      	strb	r3, [r4, #0]
		data[11] = 0;		
 1001a84:	f04f 0a00 	mov.w	sl, #0
 1001a88:	f04f 32ff 	mov.w	r2, #4294967295
 1001a8c:	f04f 33ff 	mov.w	r3, #4294967295
 1001a90:	4640      	mov	r0, r8
 1001a92:	f01f fe49 	bl	1021728 <z_impl_k_sem_take>
		snprintf(data, 12, "HelloNet%d", cnt++);		
 1001a96:	7823      	ldrb	r3, [r4, #0]
 1001a98:	210c      	movs	r1, #12
 1001a9a:	1c5a      	adds	r2, r3, #1
 1001a9c:	7022      	strb	r2, [r4, #0]
 1001a9e:	4812      	ldr	r0, [pc, #72]	; (1001ae8 <ble_write_thread+0x88>)
 1001aa0:	464a      	mov	r2, r9
 1001aa2:	f005 f897 	bl	1006bd4 <snprintf>
		err = bt_nus_send(NULL, data, 12);
 1001aa6:	220c      	movs	r2, #12
 1001aa8:	4650      	mov	r0, sl
 1001aaa:	490f      	ldr	r1, [pc, #60]	; (1001ae8 <ble_write_thread+0x88>)
		data[11] = 0;		
 1001aac:	f886 a00b 	strb.w	sl, [r6, #11]
		err = bt_nus_send(NULL, data, 12);
 1001ab0:	f003 ffc8 	bl	1005a44 <bt_nus_send>
		if (err) {
 1001ab4:	2800      	cmp	r0, #0
 1001ab6:	d0e5      	beq.n	1001a84 <ble_write_thread+0x24>
			LOG_WRN("bt_nus_send err %d", err);
 1001ab8:	466d      	mov	r5, sp
 1001aba:	b088      	sub	sp, #32
 1001abc:	466a      	mov	r2, sp
 1001abe:	4b0c      	ldr	r3, [pc, #48]	; (1001af0 <ble_write_thread+0x90>)
 1001ac0:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 1001ac4:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1001ac8:	2303      	movs	r3, #3
 1001aca:	480a      	ldr	r0, [pc, #40]	; (1001af4 <ble_write_thread+0x94>)
 1001acc:	f842 3f10 	str.w	r3, [r2, #16]!
 1001ad0:	4653      	mov	r3, sl
 1001ad2:	f022 fd39 	bl	1024548 <z_log_msg_static_create>
 1001ad6:	46ad      	mov	sp, r5
	for (;;) {
 1001ad8:	e7d4      	b.n	1001a84 <ble_write_thread+0x24>
 1001ada:	bf00      	nop
 1001adc:	21000c98 	.word	0x21000c98
 1001ae0:	210081ee 	.word	0x210081ee
 1001ae4:	21000d10 	.word	0x21000d10
 1001ae8:	210081da 	.word	0x210081da
 1001aec:	0102b5ba 	.word	0x0102b5ba
 1001af0:	0102b5c5 	.word	0x0102b5c5
 1001af4:	01029a3c 	.word	0x01029a3c

01001af8 <ext_int_isr>:
{
 1001af8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	LOG_INF("button4 pressed and going to send nus packet\n");
 1001afa:	4b08      	ldr	r3, [pc, #32]	; (1001b1c <ext_int_isr+0x24>)
 1001afc:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
 1001b00:	9305      	str	r3, [sp, #20]
 1001b02:	2302      	movs	r3, #2
 1001b04:	4806      	ldr	r0, [pc, #24]	; (1001b20 <ext_int_isr+0x28>)
 1001b06:	9304      	str	r3, [sp, #16]
 1001b08:	aa04      	add	r2, sp, #16
 1001b0a:	2300      	movs	r3, #0
 1001b0c:	f022 fd1c 	bl	1024548 <z_log_msg_static_create>
	z_impl_k_sem_give(sem);
 1001b10:	4804      	ldr	r0, [pc, #16]	; (1001b24 <ext_int_isr+0x2c>)
}
 1001b12:	b007      	add	sp, #28
 1001b14:	f85d eb04 	ldr.w	lr, [sp], #4
 1001b18:	f01f bdc2 	b.w	10216a0 <z_impl_k_sem_give>
 1001b1c:	0102b5d8 	.word	0x0102b5d8
 1001b20:	01029a3c 	.word	0x01029a3c
 1001b24:	21000d10 	.word	0x21000d10

01001b28 <setup_ext_int>:
{
 1001b28:	b538      	push	{r3, r4, r5, lr}
		union { uintptr_t x; const char * val; } parm0 = { .val = name };
		return (const struct device *) arch_syscall_invoke1(parm0.x, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
 1001b2a:	4831      	ldr	r0, [pc, #196]	; (1001bf0 <setup_ext_int+0xc8>)
 1001b2c:	f01e fdf2 	bl	1020714 <z_impl_device_get_binding>
	gpio_dev = device_get_binding(DT_NODE_FULL_NAME(DT_NODELABEL(gpio0)));
 1001b30:	4c30      	ldr	r4, [pc, #192]	; (1001bf4 <setup_ext_int+0xcc>)
 1001b32:	6020      	str	r0, [r4, #0]
	if (gpio_dev == NULL) {
 1001b34:	b920      	cbnz	r0, 1001b40 <setup_ext_int+0x18>
}
 1001b36:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		printk("GPIO_0 bind error");
 1001b3a:	482f      	ldr	r0, [pc, #188]	; (1001bf8 <setup_ext_int+0xd0>)
 1001b3c:	f022 be43 	b.w	10247c6 <printk>
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
	}

	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;

	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
 1001b40:	6843      	ldr	r3, [r0, #4]
	const struct gpio_driver_api *api =
 1001b42:	6881      	ldr	r1, [r0, #8]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
 1001b44:	681b      	ldr	r3, [r3, #0]
	struct gpio_driver_data *data =
 1001b46:	6902      	ldr	r2, [r0, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
 1001b48:	059d      	lsls	r5, r3, #22
 1001b4a:	d40e      	bmi.n	1001b6a <setup_ext_int+0x42>
 1001b4c:	492b      	ldr	r1, [pc, #172]	; (1001bfc <setup_ext_int+0xd4>)
 1001b4e:	f240 23d2 	movw	r3, #722	; 0x2d2
 1001b52:	4a2b      	ldr	r2, [pc, #172]	; (1001c00 <setup_ext_int+0xd8>)
 1001b54:	482b      	ldr	r0, [pc, #172]	; (1001c04 <setup_ext_int+0xdc>)
 1001b56:	f023 f83e 	bl	1024bd6 <assert_print>
 1001b5a:	482b      	ldr	r0, [pc, #172]	; (1001c08 <setup_ext_int+0xe0>)
 1001b5c:	f023 f83b 	bl	1024bd6 <assert_print>
 1001b60:	f240 21d2 	movw	r1, #722	; 0x2d2
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
 1001b64:	4826      	ldr	r0, [pc, #152]	; (1001c00 <setup_ext_int+0xd8>)
 1001b66:	f023 f82f 	bl	1024bc8 <assert_post_action>
		 "Unsupported pin");

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 1001b6a:	6813      	ldr	r3, [r2, #0]
 1001b6c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 1001b70:	6013      	str	r3, [r2, #0]
	}

	return api->pin_configure(port, pin, flags);
 1001b72:	680b      	ldr	r3, [r1, #0]
 1001b74:	4a25      	ldr	r2, [pc, #148]	; (1001c0c <setup_ext_int+0xe4>)
 1001b76:	2109      	movs	r1, #9
 1001b78:	4798      	blx	r3
	if (err) {
 1001b7a:	4601      	mov	r1, r0
 1001b7c:	b120      	cbz	r0, 1001b88 <setup_ext_int+0x60>
		printk("GPIO_0 config error: %d", err);
 1001b7e:	4824      	ldr	r0, [pc, #144]	; (1001c10 <setup_ext_int+0xe8>)
}
 1001b80:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		printk("GPIO_0 add callback error: %d", err);
 1001b84:	f022 be1f 	b.w	10247c6 <printk>
	err = gpio_pin_interrupt_configure(gpio_dev, EXT_INT_IO,
 1001b88:	6820      	ldr	r0, [r4, #0]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
 1001b8a:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
 1001b8e:	6812      	ldr	r2, [r2, #0]
 1001b90:	0592      	lsls	r2, r2, #22
 1001b92:	d40c      	bmi.n	1001bae <setup_ext_int+0x86>
 1001b94:	4919      	ldr	r1, [pc, #100]	; (1001bfc <setup_ext_int+0xd4>)
 1001b96:	f44f 731d 	mov.w	r3, #628	; 0x274
 1001b9a:	4a19      	ldr	r2, [pc, #100]	; (1001c00 <setup_ext_int+0xd8>)
 1001b9c:	4819      	ldr	r0, [pc, #100]	; (1001c04 <setup_ext_int+0xdc>)
 1001b9e:	f023 f81a 	bl	1024bd6 <assert_print>
 1001ba2:	4819      	ldr	r0, [pc, #100]	; (1001c08 <setup_ext_int+0xe0>)
 1001ba4:	f023 f817 	bl	1024bd6 <assert_print>
 1001ba8:	f44f 711d 	mov.w	r1, #628	; 0x274
 1001bac:	e7da      	b.n	1001b64 <setup_ext_int+0x3c>
	return api->pin_interrupt_configure(port, pin, mode, trig);
 1001bae:	2109      	movs	r1, #9
 1001bb0:	699d      	ldr	r5, [r3, #24]
 1001bb2:	f04f 72a0 	mov.w	r2, #20971520	; 0x1400000
 1001bb6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 1001bba:	47a8      	blx	r5
	if (err) {
 1001bbc:	4601      	mov	r1, r0
 1001bbe:	b110      	cbz	r0, 1001bc6 <setup_ext_int+0x9e>
		printk("GPIO_0 enable callback error: %d", err);
 1001bc0:	4814      	ldr	r0, [pc, #80]	; (1001c14 <setup_ext_int+0xec>)
 1001bc2:	f022 fe00 	bl	10247c6 <printk>
				      gpio_port_pins_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
 1001bc6:	4914      	ldr	r1, [pc, #80]	; (1001c18 <setup_ext_int+0xf0>)
 1001bc8:	4b14      	ldr	r3, [pc, #80]	; (1001c1c <setup_ext_int+0xf4>)
	err = gpio_add_callback(gpio_dev, &ext_int_cb_data);
 1001bca:	6820      	ldr	r0, [r4, #0]
 1001bcc:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
 1001bce:	f44f 7300 	mov.w	r3, #512	; 0x200
 1001bd2:	608b      	str	r3, [r1, #8]
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;

	if (api->manage_callback == NULL) {
 1001bd4:	6883      	ldr	r3, [r0, #8]
 1001bd6:	69db      	ldr	r3, [r3, #28]
 1001bd8:	b12b      	cbz	r3, 1001be6 <setup_ext_int+0xbe>
		return -ENOTSUP;
	}

	return api->manage_callback(port, callback, true);
 1001bda:	2201      	movs	r2, #1
 1001bdc:	4798      	blx	r3
	if (err) {
 1001bde:	4601      	mov	r1, r0
 1001be0:	b120      	cbz	r0, 1001bec <setup_ext_int+0xc4>
		printk("GPIO_0 add callback error: %d", err);
 1001be2:	480f      	ldr	r0, [pc, #60]	; (1001c20 <setup_ext_int+0xf8>)
 1001be4:	e7cc      	b.n	1001b80 <setup_ext_int+0x58>
		return -ENOTSUP;
 1001be6:	f06f 0185 	mvn.w	r1, #133	; 0x85
 1001bea:	e7fa      	b.n	1001be2 <setup_ext_int+0xba>
}
 1001bec:	bd38      	pop	{r3, r4, r5, pc}
 1001bee:	bf00      	nop
 1001bf0:	0102b606 	.word	0x0102b606
 1001bf4:	210045c4 	.word	0x210045c4
 1001bf8:	0102b614 	.word	0x0102b614
 1001bfc:	0102b657 	.word	0x0102b657
 1001c00:	0102b626 	.word	0x0102b626
 1001c04:	0102b695 	.word	0x0102b695
 1001c08:	0102b6b2 	.word	0x0102b6b2
 1001c0c:	00010010 	.word	0x00010010
 1001c10:	0102b6c4 	.word	0x0102b6c4
 1001c14:	0102b6dc 	.word	0x0102b6dc
 1001c18:	210045b8 	.word	0x210045b8
 1001c1c:	01001af9 	.word	0x01001af9
 1001c20:	0102b6fd 	.word	0x0102b6fd

01001c24 <main>:
{
 1001c24:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1001c28:	b08f      	sub	sp, #60	; 0x3c
	LOG_INF("### netcore firmware compiled at %s %s", __TIME__, __DATE__);
 1001c2a:	46e8      	mov	r8, sp
{
 1001c2c:	af02      	add	r7, sp, #8
	LOG_INF("### netcore firmware compiled at %s %s", __TIME__, __DATE__);
 1001c2e:	b08a      	sub	sp, #40	; 0x28
 1001c30:	ab02      	add	r3, sp, #8
 1001c32:	f107 0018 	add.w	r0, r7, #24
 1001c36:	4606      	mov	r6, r0
 1001c38:	4965      	ldr	r1, [pc, #404]	; (1001dd0 <main+0x1ac>)
 1001c3a:	f103 0210 	add.w	r2, r3, #16
 1001c3e:	6159      	str	r1, [r3, #20]
 1001c40:	4964      	ldr	r1, [pc, #400]	; (1001dd4 <main+0x1b0>)
 1001c42:	f103 0423 	add.w	r4, r3, #35	; 0x23
 1001c46:	6199      	str	r1, [r3, #24]
 1001c48:	4963      	ldr	r1, [pc, #396]	; (1001dd8 <main+0x1b4>)
 1001c4a:	61b9      	str	r1, [r7, #24]
 1001c4c:	4963      	ldr	r1, [pc, #396]	; (1001ddc <main+0x1b8>)
 1001c4e:	61d9      	str	r1, [r3, #28]
 1001c50:	f103 011f 	add.w	r1, r3, #31
 1001c54:	f810 5b01 	ldrb.w	r5, [r0], #1
 1001c58:	f801 5f01 	strb.w	r5, [r1, #1]!
 1001c5c:	42a1      	cmp	r1, r4
 1001c5e:	d1f9      	bne.n	1001c54 <main+0x30>
 1001c60:	495f      	ldr	r1, [pc, #380]	; (1001de0 <main+0x1bc>)
 1001c62:	4860      	ldr	r0, [pc, #384]	; (1001de4 <main+0x1c0>)
 1001c64:	6119      	str	r1, [r3, #16]
 1001c66:	2300      	movs	r3, #0
 1001c68:	f44f 5123 	mov.w	r1, #10432	; 0x28c0
 1001c6c:	f022 fc6c 	bl	1024548 <z_log_msg_static_create>
 1001c70:	46c5      	mov	sp, r8
	setup_ext_int();
 1001c72:	f7ff ff59 	bl	1001b28 <setup_ext_int>
		err = bt_conn_auth_cb_register(&conn_auth_callbacks);
 1001c76:	485c      	ldr	r0, [pc, #368]	; (1001de8 <main+0x1c4>)
 1001c78:	f008 ff04 	bl	100aa84 <bt_conn_auth_cb_register>
		if (err) {
 1001c7c:	b130      	cbz	r0, 1001c8c <main+0x68>
			printk("Failed to register authorization callbacks.\n");
 1001c7e:	485b      	ldr	r0, [pc, #364]	; (1001dec <main+0x1c8>)
			printk("Failed to register authorization info callbacks.\n");
 1001c80:	f022 fda1 	bl	10247c6 <printk>
}
 1001c84:	3734      	adds	r7, #52	; 0x34
 1001c86:	46bd      	mov	sp, r7
 1001c88:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		err = bt_conn_auth_info_cb_register(&conn_auth_info_callbacks);
 1001c8c:	4858      	ldr	r0, [pc, #352]	; (1001df0 <main+0x1cc>)
 1001c8e:	f008 ff13 	bl	100aab8 <bt_conn_auth_info_cb_register>
		if (err) {
 1001c92:	4604      	mov	r4, r0
 1001c94:	b108      	cbz	r0, 1001c9a <main+0x76>
			printk("Failed to register authorization info callbacks.\n");
 1001c96:	4857      	ldr	r0, [pc, #348]	; (1001df4 <main+0x1d0>)
 1001c98:	e7f2      	b.n	1001c80 <main+0x5c>
	err = bt_enable(NULL);
 1001c9a:	f006 fdf5 	bl	1008888 <bt_enable>
	if (err) {
 1001c9e:	4605      	mov	r5, r0
 1001ca0:	b178      	cbz	r0, 1001cc2 <main+0x9e>
		LOG_INF("bt enable error %d", err);		
 1001ca2:	b088      	sub	sp, #32
 1001ca4:	aa02      	add	r2, sp, #8
 1001ca6:	4b54      	ldr	r3, [pc, #336]	; (1001df8 <main+0x1d4>)
 1001ca8:	f44f 51c6 	mov.w	r1, #6336	; 0x18c0
 1001cac:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1001cb0:	2303      	movs	r3, #3
 1001cb2:	f842 3f10 	str.w	r3, [r2, #16]!
 1001cb6:	4623      	mov	r3, r4
		LOG_ERR("Failed to initialize UART service (err: %d)", err);
 1001cb8:	484a      	ldr	r0, [pc, #296]	; (1001de4 <main+0x1c0>)
 1001cba:	f022 fc45 	bl	1024548 <z_log_msg_static_create>
 1001cbe:	46c5      	mov	sp, r8
		return;
 1001cc0:	e7e0      	b.n	1001c84 <main+0x60>
	smp_bt_register_ipc();
 1001cc2:	f000 fa99 	bl	10021f8 <smp_bt_register_ipc>
	LOG_INF("Bluetooth initialized");	
 1001cc6:	f04f 0902 	mov.w	r9, #2
 1001cca:	4b4c      	ldr	r3, [pc, #304]	; (1001dfc <main+0x1d8>)
 1001ccc:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
 1001cd0:	f107 0228 	add.w	r2, r7, #40	; 0x28
 1001cd4:	4843      	ldr	r0, [pc, #268]	; (1001de4 <main+0x1c0>)
 1001cd6:	62fb      	str	r3, [r7, #44]	; 0x2c
 1001cd8:	f8c7 9028 	str.w	r9, [r7, #40]	; 0x28
 1001cdc:	462b      	mov	r3, r5
 1001cde:	f022 fc33 	bl	1024548 <z_log_msg_static_create>
		settings_load();
 1001ce2:	f023 fb44 	bl	102536e <settings_load>
	err = bt_nus_init(&nus_cb);
 1001ce6:	4846      	ldr	r0, [pc, #280]	; (1001e00 <main+0x1dc>)
 1001ce8:	f003 fea0 	bl	1005a2c <bt_nus_init>
	if (err) {
 1001cec:	4604      	mov	r4, r0
 1001cee:	b158      	cbz	r0, 1001d08 <main+0xe4>
		LOG_ERR("Failed to initialize UART service (err: %d)", err);
 1001cf0:	b088      	sub	sp, #32
 1001cf2:	aa02      	add	r2, sp, #8
 1001cf4:	4b43      	ldr	r3, [pc, #268]	; (1001e04 <main+0x1e0>)
 1001cf6:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1001cfa:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1001cfe:	2303      	movs	r3, #3
 1001d00:	f842 3f10 	str.w	r3, [r2, #16]!
 1001d04:	462b      	mov	r3, r5
 1001d06:	e7d7      	b.n	1001cb8 <main+0x94>
	err = bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), NULL,
 1001d08:	f8df c0fc 	ldr.w	ip, [pc, #252]	; 1001e08 <main+0x1e4>
 1001d0c:	1d3d      	adds	r5, r7, #4
 1001d0e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 1001d12:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 1001d14:	f8dc 3000 	ldr.w	r3, [ip]
 1001d18:	464a      	mov	r2, r9
 1001d1a:	602b      	str	r3, [r5, #0]
 1001d1c:	493b      	ldr	r1, [pc, #236]	; (1001e0c <main+0x1e8>)
 1001d1e:	4623      	mov	r3, r4
 1001d20:	9400      	str	r4, [sp, #0]
 1001d22:	1d38      	adds	r0, r7, #4
 1001d24:	f007 fc8a 	bl	100963c <bt_le_adv_start>
	if (err) {
 1001d28:	b170      	cbz	r0, 1001d48 <main+0x124>
		LOG_ERR("Advertising failed to start (err %d)", err);
 1001d2a:	b088      	sub	sp, #32
 1001d2c:	aa02      	add	r2, sp, #8
 1001d2e:	4b38      	ldr	r3, [pc, #224]	; (1001e10 <main+0x1ec>)
 1001d30:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1001d34:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1001d38:	2303      	movs	r3, #3
 1001d3a:	482a      	ldr	r0, [pc, #168]	; (1001de4 <main+0x1c0>)
 1001d3c:	f842 3f10 	str.w	r3, [r2, #16]!
 1001d40:	4623      	mov	r3, r4
 1001d42:	f022 fc01 	bl	1024548 <z_log_msg_static_create>
 1001d46:	46c5      	mov	sp, r8
	LOG_INF("Started NUS example on netcore");
 1001d48:	4b32      	ldr	r3, [pc, #200]	; (1001e14 <main+0x1f0>)
		LOG_INF("netcore main");
 1001d4a:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 1001e18 <main+0x1f4>
	LOG_INF("Started NUS example on netcore");
 1001d4e:	62fb      	str	r3, [r7, #44]	; 0x2c
 1001d50:	2302      	movs	r3, #2
		LOG_INF("netcore main");
 1001d52:	4c24      	ldr	r4, [pc, #144]	; (1001de4 <main+0x1c0>)
	snprintf(&test_str[1], 16, "I am from NET %c", cnt++);
 1001d54:	4d31      	ldr	r5, [pc, #196]	; (1001e1c <main+0x1f8>)
	LOG_INF("Started NUS example on netcore");
 1001d56:	62bb      	str	r3, [r7, #40]	; 0x28
 1001d58:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
 1001d5c:	2300      	movs	r3, #0
 1001d5e:	4821      	ldr	r0, [pc, #132]	; (1001de4 <main+0x1c0>)
 1001d60:	f107 0228 	add.w	r2, r7, #40	; 0x28
 1001d64:	f022 fbf0 	bl	1024548 <z_log_msg_static_create>
	return z_impl_k_sleep(timeout);
 1001d68:	2100      	movs	r1, #0
 1001d6a:	f44f 3020 	mov.w	r0, #163840	; 0x28000
 1001d6e:	f021 fb3d 	bl	10233ec <z_impl_k_sleep>
		LOG_INF("netcore main");
 1001d72:	46e8      	mov	r8, sp
 1001d74:	2302      	movs	r3, #2
 1001d76:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
 1001d7a:	4620      	mov	r0, r4
 1001d7c:	62bb      	str	r3, [r7, #40]	; 0x28
 1001d7e:	f107 0228 	add.w	r2, r7, #40	; 0x28
 1001d82:	2300      	movs	r3, #0
 1001d84:	f8c7 902c 	str.w	r9, [r7, #44]	; 0x2c
 1001d88:	f022 fbde 	bl	1024548 <z_log_msg_static_create>
	test_str[0] = 0x1;
 1001d8c:	2301      	movs	r3, #1
 1001d8e:	763b      	strb	r3, [r7, #24]
	snprintf(&test_str[1], 16, "I am from NET %c", cnt++);
 1001d90:	782b      	ldrb	r3, [r5, #0]
 1001d92:	2110      	movs	r1, #16
 1001d94:	1c5a      	adds	r2, r3, #1
 1001d96:	702a      	strb	r2, [r5, #0]
 1001d98:	f107 0019 	add.w	r0, r7, #25
 1001d9c:	4a20      	ldr	r2, [pc, #128]	; (1001e20 <main+0x1fc>)
 1001d9e:	f004 ff19 	bl	1006bd4 <snprintf>
	ret = net2app_test(test_str, 16);
 1001da2:	2110      	movs	r1, #16
 1001da4:	4630      	mov	r0, r6
 1001da6:	f022 fc04 	bl	10245b2 <net2app_test>
	if (ret)
 1001daa:	2800      	cmp	r0, #0
 1001dac:	d0dc      	beq.n	1001d68 <main+0x144>
		LOG_ERR("ipc test error %d", ret);
 1001dae:	b088      	sub	sp, #32
 1001db0:	aa02      	add	r2, sp, #8
 1001db2:	4b1c      	ldr	r3, [pc, #112]	; (1001e24 <main+0x200>)
 1001db4:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1001db8:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1001dbc:	2303      	movs	r3, #3
 1001dbe:	4620      	mov	r0, r4
 1001dc0:	f842 3f10 	str.w	r3, [r2, #16]!
 1001dc4:	2300      	movs	r3, #0
 1001dc6:	f022 fbbf 	bl	1024548 <z_log_msg_static_create>
 1001dca:	46c5      	mov	sp, r8
	for (;;) {		
 1001dcc:	e7cc      	b.n	1001d68 <main+0x144>
 1001dce:	bf00      	nop
 1001dd0:	0102b71b 	.word	0x0102b71b
 1001dd4:	0102b742 	.word	0x0102b742
 1001dd8:	03010200 	.word	0x03010200
 1001ddc:	0102b74b 	.word	0x0102b74b
 1001de0:	02000004 	.word	0x02000004
 1001de4:	01029a3c 	.word	0x01029a3c
 1001de8:	21000180 	.word	0x21000180
 1001dec:	0102b757 	.word	0x0102b757
 1001df0:	21000170 	.word	0x21000170
 1001df4:	0102b784 	.word	0x0102b784
 1001df8:	0102b7b6 	.word	0x0102b7b6
 1001dfc:	0102b7c9 	.word	0x0102b7c9
 1001e00:	21000198 	.word	0x21000198
 1001e04:	0102b7df 	.word	0x0102b7df
 1001e08:	01029b00 	.word	0x01029b00
 1001e0c:	01029b98 	.word	0x01029b98
 1001e10:	0102b80b 	.word	0x0102b80b
 1001e14:	0102b830 	.word	0x0102b830
 1001e18:	0102b84f 	.word	0x0102b84f
 1001e1c:	210081ef 	.word	0x210081ef
 1001e20:	0102b85c 	.word	0x0102b85c
 1001e24:	0102b86d 	.word	0x0102b86d

01001e28 <ipc_net_rx_cb>:
	}	
}

static void ipc_net_rx_cb(uint8_t *data, uint16_t len)
{
	ipc_temp.len = len;
 1001e28:	4b02      	ldr	r3, [pc, #8]	; (1001e34 <ipc_net_rx_cb+0xc>)
 1001e2a:	8099      	strh	r1, [r3, #4]
	ipc_temp.data = data;
 1001e2c:	6018      	str	r0, [r3, #0]
	z_impl_k_sem_give(sem);
 1001e2e:	4802      	ldr	r0, [pc, #8]	; (1001e38 <ipc_net_rx_cb+0x10>)
 1001e30:	f01f bc36 	b.w	10216a0 <z_impl_k_sem_give>
 1001e34:	210045cc 	.word	0x210045cc
 1001e38:	21000cf8 	.word	0x21000cf8

01001e3c <net2app_send_bt_addr>:

int net2app_send_bt_addr(void)
{

	bt_addr_le_t addrs[CONFIG_BT_ID_MAX];
	size_t count = ARRAY_SIZE(addrs);
 1001e3c:	2301      	movs	r3, #1
{
 1001e3e:	b5b0      	push	{r4, r5, r7, lr}
 1001e40:	b094      	sub	sp, #80	; 0x50
 1001e42:	af06      	add	r7, sp, #24
	char addr_s[BT_ADDR_LE_STR_LEN];
	char data[8];
	int ret;

	bt_id_get(addrs, &count);
 1001e44:	4639      	mov	r1, r7
 1001e46:	1d38      	adds	r0, r7, #4
	size_t count = ARRAY_SIZE(addrs);
 1001e48:	603b      	str	r3, [r7, #0]
	bt_id_get(addrs, &count);
 1001e4a:	f007 f83b 	bl	1008ec4 <bt_id_get>
	switch (addr->type) {
 1001e4e:	793b      	ldrb	r3, [r7, #4]
 1001e50:	f107 040c 	add.w	r4, r7, #12
 1001e54:	2b03      	cmp	r3, #3
 1001e56:	d846      	bhi.n	1001ee6 <net2app_send_bt_addr+0xaa>
 1001e58:	e8df f003 	tbb	[pc, r3]
 1001e5c:	43413f02 	.word	0x43413f02
		strcpy(type, "public");
 1001e60:	4924      	ldr	r1, [pc, #144]	; (1001ef4 <net2app_send_bt_addr+0xb8>)
		strcpy(type, "random");
 1001e62:	4620      	mov	r0, r4
 1001e64:	f024 fd3d 	bl	10268e2 <strcpy>
	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
 1001e68:	7abb      	ldrb	r3, [r7, #10]
 1001e6a:	9405      	str	r4, [sp, #20]
 1001e6c:	797a      	ldrb	r2, [r7, #5]
 1001e6e:	211e      	movs	r1, #30
 1001e70:	9204      	str	r2, [sp, #16]
 1001e72:	79ba      	ldrb	r2, [r7, #6]
 1001e74:	f107 0018 	add.w	r0, r7, #24
 1001e78:	9203      	str	r2, [sp, #12]
 1001e7a:	79fa      	ldrb	r2, [r7, #7]
 1001e7c:	9202      	str	r2, [sp, #8]
 1001e7e:	7a3a      	ldrb	r2, [r7, #8]
 1001e80:	9201      	str	r2, [sp, #4]
 1001e82:	7a7a      	ldrb	r2, [r7, #9]
 1001e84:	9200      	str	r2, [sp, #0]
 1001e86:	4a1c      	ldr	r2, [pc, #112]	; (1001ef8 <net2app_send_bt_addr+0xbc>)
 1001e88:	f022 fcaa 	bl	10247e0 <snprintk>
	bt_addr_le_to_str(&addrs[0], addr_s, sizeof(addr_s));
	printk("===BT dev addr: %s ====\n", addr_s);
 1001e8c:	481b      	ldr	r0, [pc, #108]	; (1001efc <net2app_send_bt_addr+0xc0>)
 1001e8e:	f107 0118 	add.w	r1, r7, #24
 1001e92:	f022 fc98 	bl	10247c6 <printk>

	data[0] = NET2APP_BT_ADDR_SEND;
 1001e96:	2302      	movs	r3, #2
	memcpy(&data[1], (uint8_t *)&addrs[0], 7);
 1001e98:	2207      	movs	r2, #7
	data[0] = NET2APP_BT_ADDR_SEND;
 1001e9a:	733b      	strb	r3, [r7, #12]
	memcpy(&data[1], (uint8_t *)&addrs[0], 7);
 1001e9c:	1d39      	adds	r1, r7, #4
 1001e9e:	f107 000d 	add.w	r0, r7, #13
 1001ea2:	f024 fd67 	bl	1026974 <memcpy>

	ret = nrfx_ipc_send(data, sizeof(data));
 1001ea6:	4620      	mov	r0, r4
 1001ea8:	2108      	movs	r1, #8
 1001eaa:	f000 f8fb 	bl	10020a4 <nrfx_ipc_send>
	if (ret) {
 1001eae:	4604      	mov	r4, r0
 1001eb0:	b178      	cbz	r0, 1001ed2 <net2app_send_bt_addr+0x96>
		LOG_ERR("BT dev addr sent err %d", ret);
 1001eb2:	466d      	mov	r5, sp
 1001eb4:	b088      	sub	sp, #32
 1001eb6:	aa06      	add	r2, sp, #24
 1001eb8:	4b11      	ldr	r3, [pc, #68]	; (1001f00 <net2app_send_bt_addr+0xc4>)
 1001eba:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1001ebe:	2303      	movs	r3, #3
 1001ec0:	f842 3f10 	str.w	r3, [r2, #16]!
		(void) arch_syscall_invoke4(parm0.x, parm1.x, parm2.x, parm3.x, K_SYSCALL_Z_LOG_MSG_STATIC_CREATE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg_static_create(source, desc, package, data);
 1001ec4:	2300      	movs	r3, #0
 1001ec6:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1001eca:	480e      	ldr	r0, [pc, #56]	; (1001f04 <net2app_send_bt_addr+0xc8>)
 1001ecc:	f002 fc1c 	bl	1004708 <z_impl_z_log_msg_static_create>
 1001ed0:	46ad      	mov	sp, r5
	}	
	return ret;
	 
}
 1001ed2:	4620      	mov	r0, r4
 1001ed4:	3738      	adds	r7, #56	; 0x38
 1001ed6:	46bd      	mov	sp, r7
 1001ed8:	bdb0      	pop	{r4, r5, r7, pc}
		strcpy(type, "random");
 1001eda:	490b      	ldr	r1, [pc, #44]	; (1001f08 <net2app_send_bt_addr+0xcc>)
 1001edc:	e7c1      	b.n	1001e62 <net2app_send_bt_addr+0x26>
		strcpy(type, "public-id");
 1001ede:	490b      	ldr	r1, [pc, #44]	; (1001f0c <net2app_send_bt_addr+0xd0>)
 1001ee0:	e7bf      	b.n	1001e62 <net2app_send_bt_addr+0x26>
		strcpy(type, "random-id");
 1001ee2:	490b      	ldr	r1, [pc, #44]	; (1001f10 <net2app_send_bt_addr+0xd4>)
 1001ee4:	e7bd      	b.n	1001e62 <net2app_send_bt_addr+0x26>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
 1001ee6:	210a      	movs	r1, #10
 1001ee8:	4620      	mov	r0, r4
 1001eea:	4a0a      	ldr	r2, [pc, #40]	; (1001f14 <net2app_send_bt_addr+0xd8>)
 1001eec:	f022 fc78 	bl	10247e0 <snprintk>
		break;
 1001ef0:	e7ba      	b.n	1001e68 <net2app_send_bt_addr+0x2c>
 1001ef2:	bf00      	nop
 1001ef4:	0102b404 	.word	0x0102b404
 1001ef8:	0102b426 	.word	0x0102b426
 1001efc:	0102b8a5 	.word	0x0102b8a5
 1001f00:	0102b8be 	.word	0x0102b8be
 1001f04:	01029a14 	.word	0x01029a14
 1001f08:	0102b40b 	.word	0x0102b40b
 1001f0c:	0102b412 	.word	0x0102b412
 1001f10:	0102b41c 	.word	0x0102b41c
 1001f14:	0102eaf6 	.word	0x0102eaf6

01001f18 <net2app_send_bt_mtu>:
	return nrfx_ipc_send(data, sizeof(data));	
}

#ifdef CONFIG_IPC_SMP_BT
int net2app_send_bt_mtu(void)
{
 1001f18:	b507      	push	{r0, r1, r2, lr}
	uint8_t data[3];
	uint16_t mtu = bt_gatt_get_mtu(current_conn) - 3;
 1001f1a:	4b08      	ldr	r3, [pc, #32]	; (1001f3c <net2app_send_bt_mtu+0x24>)
 1001f1c:	6818      	ldr	r0, [r3, #0]
 1001f1e:	f026 fb39 	bl	1028594 <bt_gatt_get_mtu>
	LOG_DBG("smp BT MTU:%d", mtu);	

	data[0] = NET2APP_BT_SEND_MTU;
 1001f22:	2306      	movs	r3, #6
	uint16_t mtu = bt_gatt_get_mtu(current_conn) - 3;
 1001f24:	3803      	subs	r0, #3
	*((uint16_t *) &data[1]) = mtu;
 1001f26:	f8ad 0005 	strh.w	r0, [sp, #5]

	return nrfx_ipc_send(data, sizeof(data));	
 1001f2a:	2103      	movs	r1, #3
 1001f2c:	a801      	add	r0, sp, #4
	data[0] = NET2APP_BT_SEND_MTU;
 1001f2e:	f88d 3004 	strb.w	r3, [sp, #4]
	return nrfx_ipc_send(data, sizeof(data));	
 1001f32:	f000 f8b7 	bl	10020a4 <nrfx_ipc_send>
}
 1001f36:	b003      	add	sp, #12
 1001f38:	f85d fb04 	ldr.w	pc, [sp], #4
 1001f3c:	210045c8 	.word	0x210045c8

01001f40 <ipc_thread>:

	return nrfx_ipc_send(buf, len+1);	
}

void ipc_thread(void)
{
 1001f40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1001f44:	b086      	sub	sp, #24
 1001f46:	af00      	add	r7, sp, #0

	LOG_INF("Dual core communication by nrfx_ipc API");
 1001f48:	4b2c      	ldr	r3, [pc, #176]	; (1001ffc <ipc_thread+0xbc>)
 1001f4a:	617b      	str	r3, [r7, #20]
 1001f4c:	2302      	movs	r3, #2
 1001f4e:	613b      	str	r3, [r7, #16]
 1001f50:	2300      	movs	r3, #0
 1001f52:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
 1001f56:	f107 0210 	add.w	r2, r7, #16
 1001f5a:	4829      	ldr	r0, [pc, #164]	; (1002000 <ipc_thread+0xc0>)
 1001f5c:	f002 fbd4 	bl	1004708 <z_impl_z_log_msg_static_create>

	init_ipc(ipc_net_rx_cb);
 1001f60:	4828      	ldr	r0, [pc, #160]	; (1002004 <ipc_thread+0xc4>)
 1001f62:	f000 f8df 	bl	1002124 <init_ipc>
	return z_impl_k_sleep(timeout);
 1001f66:	2100      	movs	r1, #0
 1001f68:	f44f 30c0 	mov.w	r0, #98304	; 0x18000
 1001f6c:	f021 fa3e 	bl	10233ec <z_impl_k_sleep>
	k_sleep(K_SECONDS(3)); //wait for BT stack init
	net2app_send_bt_addr();
 1001f70:	f7ff ff64 	bl	1001e3c <net2app_send_bt_addr>
	return z_impl_k_sem_take(sem, timeout);
 1001f74:	4d24      	ldr	r5, [pc, #144]	; (1002008 <ipc_thread+0xc8>)

	while (1) {
		k_sem_take(&sem_ipc_rx, K_FOREVER);
		ipc_rx_handler(ipc_temp.data, ipc_temp.len);
 1001f76:	4c25      	ldr	r4, [pc, #148]	; (100200c <ipc_thread+0xcc>)
			ipc_net_bt_smp_send(current_conn, &data[1], len-1);			
 1001f78:	4e25      	ldr	r6, [pc, #148]	; (1002010 <ipc_thread+0xd0>)
 1001f7a:	f04f 32ff 	mov.w	r2, #4294967295
 1001f7e:	f04f 33ff 	mov.w	r3, #4294967295
 1001f82:	4628      	mov	r0, r5
 1001f84:	f01f fbd0 	bl	1021728 <z_impl_k_sem_take>
		ipc_rx_handler(ipc_temp.data, ipc_temp.len);
 1001f88:	6823      	ldr	r3, [r4, #0]
 1001f8a:	88a0      	ldrh	r0, [r4, #4]
	switch (data[0])
 1001f8c:	781a      	ldrb	r2, [r3, #0]
 1001f8e:	2a82      	cmp	r2, #130	; 0x82
 1001f90:	d01c      	beq.n	1001fcc <ipc_thread+0x8c>
 1001f92:	2a83      	cmp	r2, #131	; 0x83
 1001f94:	d01d      	beq.n	1001fd2 <ipc_thread+0x92>
 1001f96:	2a81      	cmp	r2, #129	; 0x81
 1001f98:	d122      	bne.n	1001fe0 <ipc_thread+0xa0>
			LOG_HEXDUMP_INF(&data[1], len-1, "IPC test:");
 1001f9a:	46e8      	mov	r8, sp
 1001f9c:	b088      	sub	sp, #32
 1001f9e:	466a      	mov	r2, sp
 1001fa0:	491c      	ldr	r1, [pc, #112]	; (1002014 <ipc_thread+0xd4>)
 1001fa2:	6151      	str	r1, [r2, #20]
 1001fa4:	491c      	ldr	r1, [pc, #112]	; (1002018 <ipc_thread+0xd8>)
 1001fa6:	6191      	str	r1, [r2, #24]
 1001fa8:	f44f 7100 	mov.w	r1, #512	; 0x200
 1001fac:	8391      	strh	r1, [r2, #28]
 1001fae:	491b      	ldr	r1, [pc, #108]	; (100201c <ipc_thread+0xdc>)
 1001fb0:	f842 1f10 	str.w	r1, [r2, #16]!
 1001fb4:	1e41      	subs	r1, r0, #1
 1001fb6:	f3c1 010b 	ubfx	r1, r1, #0, #12
 1001fba:	04c9      	lsls	r1, r1, #19
 1001fbc:	f441 51e6 	orr.w	r1, r1, #7360	; 0x1cc0
 1001fc0:	480f      	ldr	r0, [pc, #60]	; (1002000 <ipc_thread+0xc0>)
 1001fc2:	3301      	adds	r3, #1
 1001fc4:	f002 fba0 	bl	1004708 <z_impl_z_log_msg_static_create>
 1001fc8:	46c5      	mov	sp, r8
 1001fca:	e7d6      	b.n	1001f7a <ipc_thread+0x3a>
			net2app_send_bt_mtu();
 1001fcc:	f7ff ffa4 	bl	1001f18 <net2app_send_bt_mtu>
		break;
 1001fd0:	e7d3      	b.n	1001f7a <ipc_thread+0x3a>
			ipc_net_bt_smp_send(current_conn, &data[1], len-1);			
 1001fd2:	1e42      	subs	r2, r0, #1
 1001fd4:	b292      	uxth	r2, r2
 1001fd6:	6830      	ldr	r0, [r6, #0]
 1001fd8:	1c59      	adds	r1, r3, #1
 1001fda:	f000 f8f5 	bl	10021c8 <ipc_net_bt_smp_send>
		break;
 1001fde:	e7cc      	b.n	1001f7a <ipc_thread+0x3a>
			LOG_ERR("undefined IPC request");
 1001fe0:	4b0f      	ldr	r3, [pc, #60]	; (1002020 <ipc_thread+0xe0>)
 1001fe2:	617b      	str	r3, [r7, #20]
 1001fe4:	2302      	movs	r3, #2
 1001fe6:	613b      	str	r3, [r7, #16]
 1001fe8:	2300      	movs	r3, #0
 1001fea:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1001fee:	4804      	ldr	r0, [pc, #16]	; (1002000 <ipc_thread+0xc0>)
 1001ff0:	f107 0210 	add.w	r2, r7, #16
 1001ff4:	f002 fb88 	bl	1004708 <z_impl_z_log_msg_static_create>
	while (1) {
 1001ff8:	e7bf      	b.n	1001f7a <ipc_thread+0x3a>
 1001ffa:	bf00      	nop
 1001ffc:	0102b8d6 	.word	0x0102b8d6
 1002000:	01029a14 	.word	0x01029a14
 1002004:	01001e29 	.word	0x01001e29
 1002008:	21000cf8 	.word	0x21000cf8
 100200c:	210045cc 	.word	0x210045cc
 1002010:	210045c8 	.word	0x210045c8
 1002014:	0102b4e3 	.word	0x0102b4e3
 1002018:	0102b8fe 	.word	0x0102b8fe
 100201c:	01000003 	.word	0x01000003
 1002020:	0102b908 	.word	0x0102b908

01002024 <nrfx_ipc_handler.part.0>:
nrfx_ipc_data_t * ipc_tx_buf = (nrfx_ipc_data_t *) (SHARE_RAM_BASE_ADDR+IPC_DATA_MAX_SIZE);
nrfx_ipc_data_t * ipc_rx_buf = (nrfx_ipc_data_t *) SHARE_RAM_BASE_ADDR;
static ipc_rx_callback_t ipc_rx_callback;
K_SEM_DEFINE(sem_ipc_respone, 0, 1);

static void nrfx_ipc_handler(uint8_t event_mask, void *p_context)
 1002024:	b510      	push	{r4, lr}
{
	if (event_mask == CH_NO_RECEIVE) {

		if (ipc_rx_buf->response == MAGIC_RESPONSE)
 1002026:	4b16      	ldr	r3, [pc, #88]	; (1002080 <nrfx_ipc_handler.part.0+0x5c>)
 1002028:	4c16      	ldr	r4, [pc, #88]	; (1002084 <nrfx_ipc_handler.part.0+0x60>)
 100202a:	681b      	ldr	r3, [r3, #0]
static void nrfx_ipc_handler(uint8_t event_mask, void *p_context)
 100202c:	b086      	sub	sp, #24
		if (ipc_rx_buf->response == MAGIC_RESPONSE)
 100202e:	685a      	ldr	r2, [r3, #4]
 1002030:	42a2      	cmp	r2, r4
 1002032:	d107      	bne.n	1002044 <nrfx_ipc_handler.part.0+0x20>
		{
			LOG_DBG("ipc isr response %x", ipc_tx_buf->data[0]);
			ipc_rx_buf->response = 0;
 1002034:	2200      	movs	r2, #0
 1002036:	605a      	str	r2, [r3, #4]
	z_impl_k_sem_give(sem);
 1002038:	4813      	ldr	r0, [pc, #76]	; (1002088 <nrfx_ipc_handler.part.0+0x64>)
		else
		{
			LOG_WRN("invalid ipc data");
		}
	}
}
 100203a:	b006      	add	sp, #24
 100203c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 1002040:	f01f bb2e 	b.w	10216a0 <z_impl_k_sem_give>
		else if (ipc_rx_buf->requst == MAGIC_REQUEST)
 1002044:	6819      	ldr	r1, [r3, #0]
 1002046:	4a11      	ldr	r2, [pc, #68]	; (100208c <nrfx_ipc_handler.part.0+0x68>)
 1002048:	4291      	cmp	r1, r2
 100204a:	d10d      	bne.n	1002068 <nrfx_ipc_handler.part.0+0x44>
			if (ipc_rx_callback)
 100204c:	4a10      	ldr	r2, [pc, #64]	; (1002090 <nrfx_ipc_handler.part.0+0x6c>)
 100204e:	6812      	ldr	r2, [r2, #0]
 1002050:	b112      	cbz	r2, 1002058 <nrfx_ipc_handler.part.0+0x34>
				ipc_rx_callback(ipc_rx_buf->data, ipc_rx_buf->len);
 1002052:	8919      	ldrh	r1, [r3, #8]
 1002054:	68d8      	ldr	r0, [r3, #12]
 1002056:	4790      	blx	r2

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ipc_task_trigger(NRF_IPC_Type * p_reg, nrf_ipc_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1002058:	2201      	movs	r2, #1
			ipc_tx_buf->response = MAGIC_RESPONSE;
 100205a:	4b0e      	ldr	r3, [pc, #56]	; (1002094 <nrfx_ipc_handler.part.0+0x70>)
 100205c:	681b      	ldr	r3, [r3, #0]
 100205e:	605c      	str	r4, [r3, #4]
 1002060:	4b0d      	ldr	r3, [pc, #52]	; (1002098 <nrfx_ipc_handler.part.0+0x74>)
 1002062:	605a      	str	r2, [r3, #4]
}
 1002064:	b006      	add	sp, #24
 1002066:	bd10      	pop	{r4, pc}
			LOG_WRN("invalid ipc data");
 1002068:	4b0c      	ldr	r3, [pc, #48]	; (100209c <nrfx_ipc_handler.part.0+0x78>)
 100206a:	9305      	str	r3, [sp, #20]
 100206c:	2302      	movs	r3, #2
 100206e:	9304      	str	r3, [sp, #16]
 1002070:	2300      	movs	r3, #0
 1002072:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 1002076:	480a      	ldr	r0, [pc, #40]	; (10020a0 <nrfx_ipc_handler.part.0+0x7c>)
 1002078:	aa04      	add	r2, sp, #16
 100207a:	f002 fb45 	bl	1004708 <z_impl_z_log_msg_static_create>
}
 100207e:	e7f1      	b.n	1002064 <nrfx_ipc_handler.part.0+0x40>
 1002080:	210001a4 	.word	0x210001a4
 1002084:	20220616 	.word	0x20220616
 1002088:	21000ce0 	.word	0x21000ce0
 100208c:	20220408 	.word	0x20220408
 1002090:	210045d4 	.word	0x210045d4
 1002094:	210001a8 	.word	0x210001a8
 1002098:	41012000 	.word	0x41012000
 100209c:	0102b934 	.word	0x0102b934
 10020a0:	01029a1c 	.word	0x01029a1c

010020a4 <nrfx_ipc_send>:

int nrfx_ipc_send(const uint8_t *data, uint16_t size)
{
 10020a4:	b530      	push	{r4, r5, lr}
	int ret;
	
	LOG_DBG("ipc send %x", data[0]);
	if (size > (IPC_DATA_MAX_SIZE - IPC_DATA_HEADER_LEN) )
 10020a6:	f5b1 6ffe 	cmp.w	r1, #2032	; 0x7f0
{
 10020aa:	460a      	mov	r2, r1
 10020ac:	b087      	sub	sp, #28
	if (size > (IPC_DATA_MAX_SIZE - IPC_DATA_HEADER_LEN) )
 10020ae:	d829      	bhi.n	1002104 <nrfx_ipc_send+0x60>
	{
		return -EINVAL;
	}
	if (ipc_tx_buf->requst == MAGIC_REQUEST)
 10020b0:	4c16      	ldr	r4, [pc, #88]	; (100210c <nrfx_ipc_send+0x68>)
 10020b2:	4917      	ldr	r1, [pc, #92]	; (1002110 <nrfx_ipc_send+0x6c>)
 10020b4:	6823      	ldr	r3, [r4, #0]
 10020b6:	681d      	ldr	r5, [r3, #0]
 10020b8:	428d      	cmp	r5, r1
 10020ba:	d10e      	bne.n	10020da <nrfx_ipc_send+0x36>
	{
		LOG_ERR("ipc is busy");
 10020bc:	4b15      	ldr	r3, [pc, #84]	; (1002114 <nrfx_ipc_send+0x70>)
 10020be:	9305      	str	r3, [sp, #20]
 10020c0:	2302      	movs	r3, #2
 10020c2:	9304      	str	r3, [sp, #16]
 10020c4:	2300      	movs	r3, #0
 10020c6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10020ca:	4813      	ldr	r0, [pc, #76]	; (1002118 <nrfx_ipc_send+0x74>)
 10020cc:	aa04      	add	r2, sp, #16
 10020ce:	f002 fb1b 	bl	1004708 <z_impl_z_log_msg_static_create>
		return -EBUSY;
 10020d2:	f06f 000f 	mvn.w	r0, #15
	{
		return -EBUSY;
	}
	ipc_tx_buf->requst = 0;	
	return 0;
}
 10020d6:	b007      	add	sp, #28
 10020d8:	bd30      	pop	{r4, r5, pc}
	ipc_tx_buf->requst = MAGIC_REQUEST;
 10020da:	6019      	str	r1, [r3, #0]
	ipc_tx_buf->len = size;
 10020dc:	6823      	ldr	r3, [r4, #0]
	memcpy(ipc_tx_buf->data, data, size);
 10020de:	4601      	mov	r1, r0
	ipc_tx_buf->len = size;
 10020e0:	609a      	str	r2, [r3, #8]
	memcpy(ipc_tx_buf->data, data, size);
 10020e2:	68d8      	ldr	r0, [r3, #12]
 10020e4:	f024 fc46 	bl	1026974 <memcpy>
 10020e8:	2201      	movs	r2, #1
 10020ea:	4b0c      	ldr	r3, [pc, #48]	; (100211c <nrfx_ipc_send+0x78>)
 10020ec:	605a      	str	r2, [r3, #4]
	return z_impl_k_sem_take(sem, timeout);
 10020ee:	f640 42cd 	movw	r2, #3277	; 0xccd
 10020f2:	2300      	movs	r3, #0
 10020f4:	480a      	ldr	r0, [pc, #40]	; (1002120 <nrfx_ipc_send+0x7c>)
 10020f6:	f01f fb17 	bl	1021728 <z_impl_k_sem_take>
	if (ret)
 10020fa:	2800      	cmp	r0, #0
 10020fc:	d1e9      	bne.n	10020d2 <nrfx_ipc_send+0x2e>
	ipc_tx_buf->requst = 0;	
 10020fe:	6823      	ldr	r3, [r4, #0]
 1002100:	6018      	str	r0, [r3, #0]
	return 0;
 1002102:	e7e8      	b.n	10020d6 <nrfx_ipc_send+0x32>
		return -EINVAL;
 1002104:	f06f 0015 	mvn.w	r0, #21
 1002108:	e7e5      	b.n	10020d6 <nrfx_ipc_send+0x32>
 100210a:	bf00      	nop
 100210c:	210001a8 	.word	0x210001a8
 1002110:	20220408 	.word	0x20220408
 1002114:	0102b945 	.word	0x0102b945
 1002118:	01029a1c 	.word	0x01029a1c
 100211c:	41012000 	.word	0x41012000
 1002120:	21000ce0 	.word	0x21000ce0

01002124 <init_ipc>:

int init_ipc(ipc_rx_callback_t cb)
{
	int ret;

	ret = nrfx_ipc_init(0, nrfx_ipc_handler, NULL);
 1002124:	2200      	movs	r2, #0
{
 1002126:	b598      	push	{r3, r4, r7, lr}
	ret = nrfx_ipc_init(0, nrfx_ipc_handler, NULL);
 1002128:	491f      	ldr	r1, [pc, #124]	; (10021a8 <init_ipc+0x84>)
{
 100212a:	4604      	mov	r4, r0
 100212c:	af00      	add	r7, sp, #0
	ret = nrfx_ipc_init(0, nrfx_ipc_handler, NULL);
 100212e:	4610      	mov	r0, r2
 1002130:	f01e f972 	bl	1020418 <nrfx_ipc_init>
	if (ret != NRFX_SUCCESS)
 1002134:	4b1d      	ldr	r3, [pc, #116]	; (10021ac <init_ipc+0x88>)
 1002136:	4298      	cmp	r0, r3
 1002138:	d013      	beq.n	1002162 <init_ipc+0x3e>
	{
		LOG_ERR("ipc init err %x", ret);
 100213a:	466c      	mov	r4, sp
 100213c:	b088      	sub	sp, #32
 100213e:	466a      	mov	r2, sp
 1002140:	4b1b      	ldr	r3, [pc, #108]	; (10021b0 <init_ipc+0x8c>)
 1002142:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1002146:	2303      	movs	r3, #3
 1002148:	f842 3f10 	str.w	r3, [r2, #16]!
 100214c:	4819      	ldr	r0, [pc, #100]	; (10021b4 <init_ipc+0x90>)
 100214e:	2300      	movs	r3, #0
 1002150:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1002154:	f002 fad8 	bl	1004708 <z_impl_z_log_msg_static_create>
		return -EIO;
 1002158:	f06f 0004 	mvn.w	r0, #4
 100215c:	46a5      	mov	sp, r4
	nrf_ipc_send_config_set(NRF_IPC, CH_NO_SEND, 1 << CH_NO_SEND);
	nrf_ipc_receive_config_set(NRF_IPC, CH_NO_RECEIVE, 1 << CH_NO_RECEIVE);
	nrf_ipc_int_enable(NRF_IPC, 1 << CH_NO_RECEIVE);

	return 0;	
}
 100215e:	46bd      	mov	sp, r7
 1002160:	bd98      	pop	{r3, r4, r7, pc}
	ipc_rx_callback = cb;
 1002162:	4b15      	ldr	r3, [pc, #84]	; (10021b8 <init_ipc+0x94>)
	IRQ_CONNECT(NRFX_IRQ_NUMBER_GET(NRF_IPC), 4,
 1002164:	2200      	movs	r2, #0
 1002166:	2104      	movs	r1, #4
 1002168:	2012      	movs	r0, #18
	ipc_rx_callback = cb;
 100216a:	601c      	str	r4, [r3, #0]
	IRQ_CONNECT(NRFX_IRQ_NUMBER_GET(NRF_IPC), 4,
 100216c:	f003 fe6c 	bl	1005e48 <z_arm_irq_priority_set>
	ipc_tx_buf->data = (void *)((uint32_t) ipc_tx_buf + IPC_DATA_HEADER_LEN);
 1002170:	4912      	ldr	r1, [pc, #72]	; (10021bc <init_ipc+0x98>)
 1002172:	680a      	ldr	r2, [r1, #0]
 1002174:	f102 0310 	add.w	r3, r2, #16
 1002178:	60d3      	str	r3, [r2, #12]
	ipc_rx_buf->data = (void *)((uint32_t) ipc_rx_buf + IPC_DATA_HEADER_LEN);
 100217a:	4b11      	ldr	r3, [pc, #68]	; (10021c0 <init_ipc+0x9c>)
 100217c:	6818      	ldr	r0, [r3, #0]
 100217e:	f100 0410 	add.w	r4, r0, #16
 1002182:	60c4      	str	r4, [r0, #12]
	ipc_tx_buf->requst = 0;
 1002184:	2000      	movs	r0, #0
 1002186:	6010      	str	r0, [r2, #0]
	ipc_tx_buf->response = 0;
 1002188:	680a      	ldr	r2, [r1, #0]
 100218a:	6050      	str	r0, [r2, #4]
	ipc_rx_buf->requst = 0;
 100218c:	681a      	ldr	r2, [r3, #0]
 100218e:	6010      	str	r0, [r2, #0]

NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
                                               uint8_t        index,
                                               uint32_t       channels_mask)
{
    p_reg->SEND_CNF[index] = channels_mask;
 1002190:	2202      	movs	r2, #2
	ipc_rx_buf->response = 0;		
 1002192:	681b      	ldr	r3, [r3, #0]
 1002194:	6058      	str	r0, [r3, #4]
 1002196:	4b0b      	ldr	r3, [pc, #44]	; (10021c4 <init_ipc+0xa0>)
 1002198:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514

NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
                                                  uint8_t        index,
                                                  uint32_t       channels_mask)
{
    p_reg->RECEIVE_CNF[index] = channels_mask;
 100219c:	2201      	movs	r2, #1
 100219e:	f8c3 2590 	str.w	r2, [r3, #1424]	; 0x590
    p_reg->INTENSET = mask;
 10021a2:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	return 0;	
 10021a6:	e7da      	b.n	100215e <init_ipc+0x3a>
 10021a8:	010245df 	.word	0x010245df
 10021ac:	0bad0000 	.word	0x0bad0000
 10021b0:	0102b951 	.word	0x0102b951
 10021b4:	01029a1c 	.word	0x01029a1c
 10021b8:	210045d4 	.word	0x210045d4
 10021bc:	210001a8 	.word	0x210001a8
 10021c0:	210001a4 	.word	0x210001a4
 10021c4:	41012000 	.word	0x41012000

010021c8 <ipc_net_bt_smp_send>:

/**
 * Transmits an SMP response over the specified Bluetooth connection.
 */
void ipc_net_bt_smp_send(struct bt_conn *conn, void *data, uint16_t len)
{	
 10021c8:	b570      	push	{r4, r5, r6, lr}
 10021ca:	4604      	mov	r4, r0
 10021cc:	460e      	mov	r6, r1
 10021ce:	4615      	mov	r5, r2
 10021d0:	b086      	sub	sp, #24
				 const struct bt_gatt_attr *attr,
				 const void *data, uint16_t len)
{
	struct bt_gatt_notify_params params;

	memset(&params, 0, sizeof(params));
 10021d2:	2218      	movs	r2, #24
 10021d4:	2100      	movs	r1, #0
 10021d6:	4668      	mov	r0, sp
 10021d8:	f024 fbd7 	bl	102698a <memset>

	params.attr = attr;
 10021dc:	4b05      	ldr	r3, [pc, #20]	; (10021f4 <ipc_net_bt_smp_send+0x2c>)
	params.len = len;
#if defined(CONFIG_BT_EATT)
	params.chan_opt = BT_ATT_CHAN_OPT_NONE;
#endif /* CONFIG_BT_EATT */

	return bt_gatt_notify_cb(conn, &params);
 10021de:	4669      	mov	r1, sp
 10021e0:	4620      	mov	r0, r4
	params.data = data;
 10021e2:	e9cd 3601 	strd	r3, r6, [sp, #4]
	params.len = len;
 10021e6:	f8ad 500c 	strh.w	r5, [sp, #12]
	return bt_gatt_notify_cb(conn, &params);
 10021ea:	f00c fa83 	bl	100e6f4 <bt_gatt_notify_cb>
	LOG_HEXDUMP_DBG(data, len, "bt notify: ");
	bt_gatt_notify(conn, smp_bt_attrs + 2, data, len);	
}
 10021ee:	b006      	add	sp, #24
 10021f0:	bd70      	pop	{r4, r5, r6, pc}
 10021f2:	bf00      	nop
 10021f4:	210001e0 	.word	0x210001e0

010021f8 <smp_bt_register_ipc>:

int smp_bt_register_ipc(void)
{
 10021f8:	b508      	push	{r3, lr}
	printk("register smp bt\r");
 10021fa:	4804      	ldr	r0, [pc, #16]	; (100220c <smp_bt_register_ipc+0x14>)
 10021fc:	f022 fae3 	bl	10247c6 <printk>
	return bt_gatt_service_register(&smp_bt_svc);
}
 1002200:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return bt_gatt_service_register(&smp_bt_svc);
 1002204:	4802      	ldr	r0, [pc, #8]	; (1002210 <smp_bt_register_ipc+0x18>)
 1002206:	f00b bd85 	b.w	100dd14 <bt_gatt_service_register>
 100220a:	bf00      	nop
 100220c:	0102b969 	.word	0x0102b969
 1002210:	210001ac 	.word	0x210001ac

01002214 <cbvprintf_package>:
	return cb(str, strl, ctx);
}

int cbvprintf_package(void *packaged, size_t len, uint32_t flags,
		      const char *fmt, va_list ap)
{
 1002214:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1002218:	b091      	sub	sp, #68	; 0x44
 100221a:	9300      	str	r3, [sp, #0]
	const char *s;
	bool parsing = false;
	/* Flag indicates that rw strings are stored as array with positions,
	 * instead of appending them to the package.
	 */
	bool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);
 100221c:	f002 0304 	and.w	r3, r2, #4
 1002220:	9301      	str	r3, [sp, #4]
	/* Get number of first read only strings present in the string.
	 * There is always at least 1 (fmt) but flags can indicate more, e.g
	 * fixed prefix appended to all strings.
	 */
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
 1002222:	f3c2 03c2 	ubfx	r3, r2, #3, #3
 1002226:	3301      	adds	r3, #1
 1002228:	9304      	str	r3, [sp, #16]
	bool is_str_arg = false;
	union cbprintf_package_hdr *pkg_hdr = packaged;

	/* Buffer must be aligned at least to size of a pointer. */
	if ((uintptr_t)packaged % sizeof(void *)) {
 100222a:	0783      	lsls	r3, r0, #30
{
 100222c:	4605      	mov	r5, r0
 100222e:	460e      	mov	r6, r1
 1002230:	f8dd 9068 	ldr.w	r9, [sp, #104]	; 0x68
 1002234:	9202      	str	r2, [sp, #8]
	if ((uintptr_t)packaged % sizeof(void *)) {
 1002236:	f040 81fe 	bne.w	1002636 <cbvprintf_package+0x422>
	 * which is guaranteed to be at least 4 bytes, we just reserve
	 * multiple of pointer size for the above to preserve alignment.
	 *
	 * Refer to union cbprintf_package_hdr for more details.
	 */
	buf += sizeof(*pkg_hdr);
 100223a:	1d04      	adds	r4, r0, #4
	 * When buf0 is NULL we don't store anything.
	 * Instead we count the needed space to store the data.
	 * In this case, incoming len argument indicates the anticipated
	 * buffer "misalignment" offset.
	 */
	if (buf0 == NULL) {
 100223c:	b130      	cbz	r0, 100224c <cbvprintf_package+0x38>

	/*
	 * Otherwise we must ensure we can store at least
	 * the pointer to the format string itself.
	 */
	if (buf0 != NULL && BUF_OFFSET + sizeof(char *) > len) {
 100223e:	2907      	cmp	r1, #7
 1002240:	d809      	bhi.n	1002256 <cbvprintf_package+0x42>
		return -ENOSPC;
 1002242:	f06f 001b 	mvn.w	r0, #27
	return BUF_OFFSET;

#undef BUF_OFFSET
#undef STR_POS_RO_FLAG
#undef STR_POS_MASK
}
 1002246:	b011      	add	sp, #68	; 0x44
 1002248:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
 100224c:	f001 0607 	and.w	r6, r1, #7
 1002250:	1d34      	adds	r4, r6, #4
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
 1002252:	f1c6 0608 	rsb	r6, r6, #8
	unsigned int s_ro_cnt = 0; /* number of ro strings */
 1002256:	f04f 0800 	mov.w	r8, #0
	align = VA_STACK_ALIGN(char *);
 100225a:	f04f 0b04 	mov.w	fp, #4
	s = fmt--;
 100225e:	9b00      	ldr	r3, [sp, #0]
	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
 1002260:	4647      	mov	r7, r8
	s = fmt--;
 1002262:	1e59      	subs	r1, r3, #1
	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
 1002264:	f04f 32ff 	mov.w	r2, #4294967295
	bool parsing = false;
 1002268:	4643      	mov	r3, r8
	size = sizeof(char *);
 100226a:	46da      	mov	sl, fp
	unsigned int s_rw_cnt = 0; /* number of rw strings */
 100226c:	f8cd 800c 	str.w	r8, [sp, #12]
			if (buf0 != NULL) {
 1002270:	b10d      	cbz	r5, 1002276 <cbvprintf_package+0x62>
				*(const char **)buf = s;
 1002272:	9800      	ldr	r0, [sp, #0]
 1002274:	6020      	str	r0, [r4, #0]
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
 1002276:	9804      	ldr	r0, [sp, #16]
 1002278:	2800      	cmp	r0, #0
 100227a:	f300 80e1 	bgt.w	1002440 <cbvprintf_package+0x22c>
#else
	#define RO_START 0
	#define RO_END 0
#endif

	return (((const char *)addr >= (const char *)RO_START) &&
 100227e:	489c      	ldr	r0, [pc, #624]	; (10024f0 <cbvprintf_package+0x2dc>)
 1002280:	f8dd c000 	ldr.w	ip, [sp]
 1002284:	4584      	cmp	ip, r0
 1002286:	d303      	bcc.n	1002290 <cbvprintf_package+0x7c>
 1002288:	489a      	ldr	r0, [pc, #616]	; (10024f4 <cbvprintf_package+0x2e0>)
 100228a:	4584      	cmp	ip, r0
 100228c:	f0c0 80d8 	bcc.w	1002440 <cbvprintf_package+0x22c>
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
 1002290:	f8dd c008 	ldr.w	ip, [sp, #8]
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
 1002294:	eba4 0e05 	sub.w	lr, r4, r5
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
 1002298:	f01c 0f02 	tst.w	ip, #2
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
 100229c:	ea4f 009e 	mov.w	r0, lr, lsr #2
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
 10022a0:	f000 80e9 	beq.w	1002476 <cbvprintf_package+0x262>
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
 10022a4:	f04f 0c00 	mov.w	ip, #0
 10022a8:	e0d3      	b.n	1002452 <cbvprintf_package+0x23e>
			switch (*fmt) {
 10022aa:	287a      	cmp	r0, #122	; 0x7a
 10022ac:	d864      	bhi.n	1002378 <cbvprintf_package+0x164>
 10022ae:	284b      	cmp	r0, #75	; 0x4b
 10022b0:	d80f      	bhi.n	10022d2 <cbvprintf_package+0xbe>
 10022b2:	2847      	cmp	r0, #71	; 0x47
 10022b4:	d860      	bhi.n	1002378 <cbvprintf_package+0x164>
 10022b6:	2829      	cmp	r0, #41	; 0x29
 10022b8:	d82f      	bhi.n	100231a <cbvprintf_package+0x106>
 10022ba:	2825      	cmp	r0, #37	; 0x25
 10022bc:	d05b      	beq.n	1002376 <cbvprintf_package+0x162>
 10022be:	d85b      	bhi.n	1002378 <cbvprintf_package+0x164>
 10022c0:	2820      	cmp	r0, #32
 10022c2:	d07f      	beq.n	10023c4 <cbvprintf_package+0x1b0>
 10022c4:	f1a0 0923 	sub.w	r9, r0, #35	; 0x23
 10022c8:	f1d9 0300 	rsbs	r3, r9, #0
 10022cc:	eb43 0309 	adc.w	r3, r3, r9
 10022d0:	e078      	b.n	10023c4 <cbvprintf_package+0x1b0>
 10022d2:	f1a0 0e4c 	sub.w	lr, r0, #76	; 0x4c
 10022d6:	f1be 0f2e 	cmp.w	lr, #46	; 0x2e
 10022da:	d84d      	bhi.n	1002378 <cbvprintf_package+0x164>
 10022dc:	e8df f00e 	tbb	[pc, lr]
 10022e0:	4c4c4c72 	.word	0x4c4c4c72
 10022e4:	4c4c4c4c 	.word	0x4c4c4c4c
 10022e8:	4c4c4c4c 	.word	0x4c4c4c4c
 10022ec:	4c4c4c4e 	.word	0x4c4c4c4e
 10022f0:	4c4c4c4c 	.word	0x4c4c4c4c
 10022f4:	4e4c5c4c 	.word	0x4e4c5c4c
 10022f8:	5c5c5c4e 	.word	0x5c5c5c4e
 10022fc:	4c6f4e72 	.word	0x4c6f4e72
 1002300:	4e184c72 	.word	0x4e184c72
 1002304:	814c4c18 	.word	0x814c4c18
 1002308:	4c4c4e7e 	.word	0x4c4c4e7e
 100230c:	4c4e      	.short	0x4c4e
 100230e:	7e          	.byte	0x7e
 100230f:	00          	.byte	0x00
 1002310:	2000      	movs	r0, #0
 1002312:	2300      	movs	r3, #0
				align = VA_STACK_ALIGN(void *);
 1002314:	f04f 0b04 	mov.w	fp, #4
 1002318:	e03c      	b.n	1002394 <cbvprintf_package+0x180>
			switch (*fmt) {
 100231a:	f1a0 0e2a 	sub.w	lr, r0, #42	; 0x2a
 100231e:	2001      	movs	r0, #1
 1002320:	fa5f fe8e 	uxtb.w	lr, lr
 1002324:	fa00 fe0e 	lsl.w	lr, r0, lr
 1002328:	f64f 70da 	movw	r0, #65498	; 0xffda
 100232c:	ea1e 0f00 	tst.w	lr, r0
 1002330:	d148      	bne.n	10023c4 <cbvprintf_package+0x1b0>
 1002332:	f01e 5062 	ands.w	r0, lr, #947912704	; 0x38800000
 1002336:	d12f      	bne.n	1002398 <cbvprintf_package+0x184>
 1002338:	f01e 0301 	ands.w	r3, lr, #1
 100233c:	d042      	beq.n	10023c4 <cbvprintf_package+0x1b0>
		buf = (void *) ROUND_UP(buf, align);
 100233e:	3c01      	subs	r4, #1
 1002340:	445c      	add	r4, fp
 1002342:	f1cb 0e00 	rsb	lr, fp, #0
 1002346:	ea04 040e 	and.w	r4, r4, lr
		if (buf0 != NULL && BUF_OFFSET + size > len) {
 100234a:	2d00      	cmp	r5, #0
 100234c:	d05e      	beq.n	100240c <cbvprintf_package+0x1f8>
 100234e:	ebaa 0e05 	sub.w	lr, sl, r5
 1002352:	44a6      	add	lr, r4
 1002354:	45b6      	cmp	lr, r6
 1002356:	f63f af74 	bhi.w	1002242 <cbvprintf_package+0x2e>
		if (is_str_arg) {
 100235a:	2800      	cmp	r0, #0
 100235c:	d168      	bne.n	1002430 <cbvprintf_package+0x21c>
		} else if (size == sizeof(int)) {
 100235e:	f1ba 0f04 	cmp.w	sl, #4
 1002362:	d143      	bne.n	10023ec <cbvprintf_package+0x1d8>
			int v = va_arg(ap, int);
 1002364:	46e1      	mov	r9, ip
 1002366:	f859 0b04 	ldr.w	r0, [r9], #4
				*(int *)buf = v;
 100236a:	6020      	str	r0, [r4, #0]
			buf += sizeof(int);
 100236c:	46cc      	mov	ip, r9
 100236e:	f04f 0a04 	mov.w	sl, #4
 1002372:	3404      	adds	r4, #4
 1002374:	e026      	b.n	10023c4 <cbvprintf_package+0x1b0>
				arg_idx--;
 1002376:	3a01      	subs	r2, #1
				parsing = false;
 1002378:	2300      	movs	r3, #0
				continue;
 100237a:	e023      	b.n	10023c4 <cbvprintf_package+0x1b0>
				if (fmt[-1] == 'l') {
 100237c:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 1002380:	2b6c      	cmp	r3, #108	; 0x6c
 1002382:	d130      	bne.n	10023e6 <cbvprintf_package+0x1d2>
					if (fmt[-2] == 'l') {
 1002384:	2000      	movs	r0, #0
 1002386:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 100238a:	2b6c      	cmp	r3, #108	; 0x6c
				parsing = false;
 100238c:	4603      	mov	r3, r0
					if (fmt[-2] == 'l') {
 100238e:	d1c1      	bne.n	1002314 <cbvprintf_package+0x100>
						align = VA_STACK_ALIGN(long long);
 1002390:	f04f 0b08 	mov.w	fp, #8
				size = sizeof(void *);
 1002394:	46da      	mov	sl, fp
 1002396:	e7d2      	b.n	100233e <cbvprintf_package+0x12a>
					v.ld = va_arg(ap, long double);
 1002398:	f10c 0907 	add.w	r9, ip, #7
 100239c:	f029 0c07 	bic.w	ip, r9, #7
				buf = (void *) ROUND_UP(buf, align);
 10023a0:	3407      	adds	r4, #7
 10023a2:	f024 0407 	bic.w	r4, r4, #7
					v.ld = va_arg(ap, long double);
 10023a6:	e8fc ab02 	ldrd	sl, fp, [ip], #8
				if (buf0 != NULL) {
 10023aa:	b135      	cbz	r5, 10023ba <cbvprintf_package+0x1a6>
					if (BUF_OFFSET + size > len) {
 10023ac:	9805      	ldr	r0, [sp, #20]
 10023ae:	4420      	add	r0, r4
 10023b0:	42b0      	cmp	r0, r6
 10023b2:	f63f af46 	bhi.w	1002242 <cbvprintf_package+0x2e>
						*(long double *)buf = v.ld;
 10023b6:	e9c4 ab00 	strd	sl, fp, [r4]
				parsing = false;
 10023ba:	2300      	movs	r3, #0
				buf += size;
 10023bc:	3408      	adds	r4, #8
			switch (*fmt) {
 10023be:	f04f 0b08 	mov.w	fp, #8
 10023c2:	46da      	mov	sl, fp
			if (*++fmt == '\0') {
 10023c4:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 10023c8:	2800      	cmp	r0, #0
 10023ca:	f000 80bc 	beq.w	1002546 <cbvprintf_package+0x332>
			if (!parsing) {
 10023ce:	2b00      	cmp	r3, #0
 10023d0:	f47f af6b 	bne.w	10022aa <cbvprintf_package+0x96>
				if (*fmt == '%') {
 10023d4:	2825      	cmp	r0, #37	; 0x25
 10023d6:	d1f5      	bne.n	10023c4 <cbvprintf_package+0x1b0>
					parsing = true;
 10023d8:	2301      	movs	r3, #1
					arg_idx++;
 10023da:	3201      	adds	r2, #1
				align = VA_STACK_ALIGN(size_t);
 10023dc:	f04f 0b04 	mov.w	fp, #4
 10023e0:	e7ef      	b.n	10023c2 <cbvprintf_package+0x1ae>
			switch (*fmt) {
 10023e2:	4618      	mov	r0, r3
 10023e4:	e795      	b.n	1002312 <cbvprintf_package+0xfe>
 10023e6:	2000      	movs	r0, #0
				parsing = false;
 10023e8:	4603      	mov	r3, r0
 10023ea:	e7a8      	b.n	100233e <cbvprintf_package+0x12a>
		} else if (size == sizeof(long long)) {
 10023ec:	f1ba 0f08 	cmp.w	sl, #8
 10023f0:	f040 809b 	bne.w	100252a <cbvprintf_package+0x316>
			long long v = va_arg(ap, long long);
 10023f4:	f10c 0907 	add.w	r9, ip, #7
 10023f8:	f029 0c07 	bic.w	ip, r9, #7
 10023fc:	e8fc 9a02 	ldrd	r9, sl, [ip], #8
					*(long long *)buf = v;
 1002400:	e9c4 9a00 	strd	r9, sl, [r4]
			buf += sizeof(long long);
 1002404:	f04f 0a08 	mov.w	sl, #8
 1002408:	3408      	adds	r4, #8
 100240a:	e7db      	b.n	10023c4 <cbvprintf_package+0x1b0>
		if (is_str_arg) {
 100240c:	b980      	cbnz	r0, 1002430 <cbvprintf_package+0x21c>
		} else if (size == sizeof(int)) {
 100240e:	f1ba 0f04 	cmp.w	sl, #4
 1002412:	d102      	bne.n	100241a <cbvprintf_package+0x206>
			int v = va_arg(ap, int);
 1002414:	f10c 0904 	add.w	r9, ip, #4
			if (buf0 != NULL) {
 1002418:	e7a8      	b.n	100236c <cbvprintf_package+0x158>
		} else if (size == sizeof(long long)) {
 100241a:	f1ba 0f08 	cmp.w	sl, #8
 100241e:	f040 8084 	bne.w	100252a <cbvprintf_package+0x316>
			long long v = va_arg(ap, long long);
 1002422:	f10c 0907 	add.w	r9, ip, #7
 1002426:	f029 0907 	bic.w	r9, r9, #7
 100242a:	f109 0c08 	add.w	ip, r9, #8
			if (buf0 != NULL) {
 100242e:	e7e9      	b.n	1002404 <cbvprintf_package+0x1f0>
			s = va_arg(ap, char *);
 1002430:	46e1      	mov	r9, ip
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
 1002432:	9804      	ldr	r0, [sp, #16]
 1002434:	3801      	subs	r0, #1
 1002436:	9004      	str	r0, [sp, #16]
			s = va_arg(ap, char *);
 1002438:	f859 0b04 	ldr.w	r0, [r9], #4
 100243c:	9000      	str	r0, [sp, #0]
 100243e:	e717      	b.n	1002270 <cbvprintf_package+0x5c>
			if (is_ro && !do_ro) {
 1002440:	9802      	ldr	r0, [sp, #8]
 1002442:	0780      	lsls	r0, r0, #30
 1002444:	d548      	bpl.n	10024d8 <cbvprintf_package+0x2c4>
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
 1002446:	f04f 0c01 	mov.w	ip, #1
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
 100244a:	eba4 0e05 	sub.w	lr, r4, r5
 100244e:	ea4f 009e 	mov.w	r0, lr, lsr #2
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
 1002452:	f5be 7f00 	cmp.w	lr, #512	; 0x200
 1002456:	d31d      	bcc.n	1002494 <cbvprintf_package+0x280>
					__ASSERT(false, "String with too many arguments");
 1002458:	4927      	ldr	r1, [pc, #156]	; (10024f8 <cbvprintf_package+0x2e4>)
 100245a:	f240 237b 	movw	r3, #635	; 0x27b
 100245e:	4a27      	ldr	r2, [pc, #156]	; (10024fc <cbvprintf_package+0x2e8>)
 1002460:	4827      	ldr	r0, [pc, #156]	; (1002500 <cbvprintf_package+0x2ec>)
 1002462:	f022 fbb8 	bl	1024bd6 <assert_print>
 1002466:	4827      	ldr	r0, [pc, #156]	; (1002504 <cbvprintf_package+0x2f0>)
 1002468:	f022 fbb5 	bl	1024bd6 <assert_print>
 100246c:	f240 217b 	movw	r1, #635	; 0x27b
					__ASSERT(false, "str_ptr_pos[] too small");
 1002470:	4822      	ldr	r0, [pc, #136]	; (10024fc <cbvprintf_package+0x2e8>)
 1002472:	f022 fba9 	bl	1024bc8 <assert_post_action>
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
 1002476:	2f0f      	cmp	r7, #15
 1002478:	d80e      	bhi.n	1002498 <cbvprintf_package+0x284>
				if (buf0 != NULL) {
 100247a:	2d00      	cmp	r5, #0
 100247c:	d046      	beq.n	100250c <cbvprintf_package+0x2f8>
					str_ptr_pos[s_idx] = s_ptr_idx;
 100247e:	f107 0c40 	add.w	ip, r7, #64	; 0x40
 1002482:	44ec      	add	ip, sp
 1002484:	f80c 0c20 	strb.w	r0, [ip, #-32]
					str_ptr_arg[s_idx] = arg_idx;
 1002488:	f80c 2c10 	strb.w	r2, [ip, #-16]
						s_rw_cnt++;
 100248c:	9803      	ldr	r0, [sp, #12]
 100248e:	3001      	adds	r0, #1
 1002490:	9003      	str	r0, [sp, #12]
 1002492:	e020      	b.n	10024d6 <cbvprintf_package+0x2c2>
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
 1002494:	2f0f      	cmp	r7, #15
 1002496:	d90c      	bls.n	10024b2 <cbvprintf_package+0x29e>
					__ASSERT(false, "str_ptr_pos[] too small");
 1002498:	4917      	ldr	r1, [pc, #92]	; (10024f8 <cbvprintf_package+0x2e4>)
 100249a:	f44f 7320 	mov.w	r3, #640	; 0x280
 100249e:	4a17      	ldr	r2, [pc, #92]	; (10024fc <cbvprintf_package+0x2e8>)
 10024a0:	4817      	ldr	r0, [pc, #92]	; (1002500 <cbvprintf_package+0x2ec>)
 10024a2:	f022 fb98 	bl	1024bd6 <assert_print>
 10024a6:	4818      	ldr	r0, [pc, #96]	; (1002508 <cbvprintf_package+0x2f4>)
 10024a8:	f022 fb95 	bl	1024bd6 <assert_print>
 10024ac:	f44f 7120 	mov.w	r1, #640	; 0x280
 10024b0:	e7de      	b.n	1002470 <cbvprintf_package+0x25c>
				if (buf0 != NULL) {
 10024b2:	b1bd      	cbz	r5, 10024e4 <cbvprintf_package+0x2d0>
					str_ptr_pos[s_idx] = s_ptr_idx;
 10024b4:	f107 0e40 	add.w	lr, r7, #64	; 0x40
 10024b8:	44ee      	add	lr, sp
 10024ba:	b2c0      	uxtb	r0, r0
 10024bc:	f80e 0c20 	strb.w	r0, [lr, #-32]
					str_ptr_arg[s_idx] = arg_idx;
 10024c0:	f80e 2c10 	strb.w	r2, [lr, #-16]
					if (is_ro) {
 10024c4:	f1bc 0f00 	cmp.w	ip, #0
 10024c8:	d0e0      	beq.n	100248c <cbvprintf_package+0x278>
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
 10024ca:	f060 007f 	orn	r0, r0, #127	; 0x7f
 10024ce:	f80e 0c20 	strb.w	r0, [lr, #-32]
						s_ro_cnt++;
 10024d2:	f108 0801 	add.w	r8, r8, #1
				s_idx++;
 10024d6:	3701      	adds	r7, #1
					if (BUF_OFFSET + size > len) {
 10024d8:	f1c5 0008 	rsb	r0, r5, #8
 10024dc:	46cc      	mov	ip, r9
			buf += sizeof(char *);
 10024de:	3404      	adds	r4, #4
					if (BUF_OFFSET + size > len) {
 10024e0:	9005      	str	r0, [sp, #20]
 10024e2:	e76f      	b.n	10023c4 <cbvprintf_package+0x1b0>
				} else if (is_ro) {
 10024e4:	f1bc 0f00 	cmp.w	ip, #0
 10024e8:	d010      	beq.n	100250c <cbvprintf_package+0x2f8>
					len += 1;
 10024ea:	3601      	adds	r6, #1
 10024ec:	e7f3      	b.n	10024d6 <cbvprintf_package+0x2c2>
 10024ee:	bf00      	nop
 10024f0:	01029660 	.word	0x01029660
 10024f4:	0102ffdc 	.word	0x0102ffdc
 10024f8:	0102ff6e 	.word	0x0102ff6e
 10024fc:	0102b985 	.word	0x0102b985
 1002500:	0102b695 	.word	0x0102b695
 1002504:	0102b9b3 	.word	0x0102b9b3
 1002508:	0102b9d4 	.word	0x0102b9d4
				} else if (rws_pos_en) {
 100250c:	9801      	ldr	r0, [sp, #4]
					len += 2;
 100250e:	3602      	adds	r6, #2
				} else if (rws_pos_en) {
 1002510:	2800      	cmp	r0, #0
 1002512:	d1e0      	bne.n	10024d6 <cbvprintf_package+0x2c2>
					len += strlen(s) + 1 + 1;
 1002514:	9800      	ldr	r0, [sp, #0]
 1002516:	e9cd 3106 	strd	r3, r1, [sp, #24]
 100251a:	9205      	str	r2, [sp, #20]
 100251c:	f024 f9eb 	bl	10268f6 <strlen>
 1002520:	e9dd 3106 	ldrd	r3, r1, [sp, #24]
 1002524:	9a05      	ldr	r2, [sp, #20]
 1002526:	4406      	add	r6, r0
 1002528:	e7d5      	b.n	10024d6 <cbvprintf_package+0x2c2>
			__ASSERT(false, "unexpected size %u", size);
 100252a:	f240 23c5 	movw	r3, #709	; 0x2c5
 100252e:	4a43      	ldr	r2, [pc, #268]	; (100263c <cbvprintf_package+0x428>)
 1002530:	4943      	ldr	r1, [pc, #268]	; (1002640 <cbvprintf_package+0x42c>)
 1002532:	4844      	ldr	r0, [pc, #272]	; (1002644 <cbvprintf_package+0x430>)
 1002534:	f022 fb4f 	bl	1024bd6 <assert_print>
 1002538:	4651      	mov	r1, sl
 100253a:	4843      	ldr	r0, [pc, #268]	; (1002648 <cbvprintf_package+0x434>)
 100253c:	f022 fb4b 	bl	1024bd6 <assert_print>
 1002540:	f240 21c5 	movw	r1, #709	; 0x2c5
 1002544:	e794      	b.n	1002470 <cbvprintf_package+0x25c>
	if (BUF_OFFSET / sizeof(int) > 255) {
 1002546:	1b63      	subs	r3, r4, r5
 1002548:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 100254c:	d30c      	bcc.n	1002568 <cbvprintf_package+0x354>
		__ASSERT(false, "too many format args");
 100254e:	493c      	ldr	r1, [pc, #240]	; (1002640 <cbvprintf_package+0x42c>)
 1002550:	f240 23d1 	movw	r3, #721	; 0x2d1
 1002554:	4a39      	ldr	r2, [pc, #228]	; (100263c <cbvprintf_package+0x428>)
 1002556:	483b      	ldr	r0, [pc, #236]	; (1002644 <cbvprintf_package+0x430>)
 1002558:	f022 fb3d 	bl	1024bd6 <assert_print>
 100255c:	483b      	ldr	r0, [pc, #236]	; (100264c <cbvprintf_package+0x438>)
 100255e:	f022 fb3a 	bl	1024bd6 <assert_print>
 1002562:	f240 21d1 	movw	r1, #721	; 0x2d1
 1002566:	e783      	b.n	1002470 <cbvprintf_package+0x25c>
	if (buf0 == NULL) {
 1002568:	b91d      	cbnz	r5, 1002572 <cbvprintf_package+0x35e>
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
 100256a:	f1a6 0408 	sub.w	r4, r6, #8
 100256e:	18e0      	adds	r0, r4, r3
 1002570:	e669      	b.n	1002246 <cbvprintf_package+0x32>
	if (rws_pos_en) {
 1002572:	9a01      	ldr	r2, [sp, #4]
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
 1002574:	089b      	lsrs	r3, r3, #2
	*(char **)buf0 = NULL;
 1002576:	6028      	str	r0, [r5, #0]
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
 1002578:	702b      	strb	r3, [r5, #0]
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
 100257a:	f89d 300c 	ldrb.w	r3, [sp, #12]
	if (rws_pos_en) {
 100257e:	b1c2      	cbz	r2, 10025b2 <cbvprintf_package+0x39e>
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
 1002580:	70eb      	strb	r3, [r5, #3]
	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
 1002582:	f885 8002 	strb.w	r8, [r5, #2]
	if (s_ro_cnt) {
 1002586:	f1b8 0f00 	cmp.w	r8, #0
 100258a:	d005      	beq.n	1002598 <cbvprintf_package+0x384>
		for (i = 0; i < s_idx; i++) {
 100258c:	2200      	movs	r2, #0
 100258e:	a808      	add	r0, sp, #32
			if (BUF_OFFSET + 1 > len) {
 1002590:	f1c5 0c01 	rsb	ip, r5, #1
		for (i = 0; i < s_idx; i++) {
 1002594:	4297      	cmp	r7, r2
 1002596:	d10e      	bne.n	10025b6 <cbvprintf_package+0x3a2>
			*buf++ = str_ptr_arg[i];
 1002598:	f04f 0a00 	mov.w	sl, #0
		if (BUF_OFFSET + 1 + size > len) {
 100259c:	f1c5 0301 	rsb	r3, r5, #1
 10025a0:	f10d 0920 	add.w	r9, sp, #32
 10025a4:	9302      	str	r3, [sp, #8]
			*buf++ = str_ptr_arg[i];
 10025a6:	f10d 0b30 	add.w	fp, sp, #48	; 0x30
	for (i = 0; i < s_idx; i++) {
 10025aa:	4557      	cmp	r7, sl
 10025ac:	d112      	bne.n	10025d4 <cbvprintf_package+0x3c0>
	return BUF_OFFSET;
 10025ae:	1b60      	subs	r0, r4, r5
 10025b0:	e649      	b.n	1002246 <cbvprintf_package+0x32>
		pkg_hdr->desc.str_cnt = s_rw_cnt;
 10025b2:	706b      	strb	r3, [r5, #1]
		pkg_hdr->desc.rw_str_cnt = 0;
 10025b4:	e7e5      	b.n	1002582 <cbvprintf_package+0x36e>
			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
 10025b6:	f810 3b01 	ldrb.w	r3, [r0], #1
 10025ba:	0619      	lsls	r1, r3, #24
 10025bc:	d508      	bpl.n	10025d0 <cbvprintf_package+0x3bc>
			if (BUF_OFFSET + 1 > len) {
 10025be:	eb04 0e0c 	add.w	lr, r4, ip
 10025c2:	45b6      	cmp	lr, r6
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
 10025c4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
			if (BUF_OFFSET + 1 > len) {
 10025c8:	f63f ae3b 	bhi.w	1002242 <cbvprintf_package+0x2e>
			*buf++ = pos;
 10025cc:	f804 3b01 	strb.w	r3, [r4], #1
		for (i = 0; i < s_idx; i++) {
 10025d0:	3201      	adds	r2, #1
 10025d2:	e7df      	b.n	1002594 <cbvprintf_package+0x380>
		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
 10025d4:	f1b8 0f00 	cmp.w	r8, #0
 10025d8:	d003      	beq.n	10025e2 <cbvprintf_package+0x3ce>
 10025da:	f999 2000 	ldrsb.w	r2, [r9]
 10025de:	2a00      	cmp	r2, #0
 10025e0:	db17      	blt.n	1002612 <cbvprintf_package+0x3fe>
		if (rws_pos_en) {
 10025e2:	9b01      	ldr	r3, [sp, #4]
 10025e4:	b1d3      	cbz	r3, 100261c <cbvprintf_package+0x408>
			*buf++ = str_ptr_arg[i];
 10025e6:	f81a 200b 	ldrb.w	r2, [sl, fp]
 10025ea:	f804 2b01 	strb.w	r2, [r4], #1
			size = 0;
 10025ee:	2200      	movs	r2, #0
		if (BUF_OFFSET + 1 + size > len) {
 10025f0:	9b02      	ldr	r3, [sp, #8]
 10025f2:	1898      	adds	r0, r3, r2
 10025f4:	4420      	add	r0, r4
 10025f6:	42b0      	cmp	r0, r6
 10025f8:	f63f ae23 	bhi.w	1002242 <cbvprintf_package+0x2e>
		*buf++ = str_ptr_pos[i];
 10025fc:	f899 0000 	ldrb.w	r0, [r9]
		memcpy(buf, s, size);
 1002600:	9900      	ldr	r1, [sp, #0]
		*buf++ = str_ptr_pos[i];
 1002602:	f804 0b01 	strb.w	r0, [r4], #1
		memcpy(buf, s, size);
 1002606:	4620      	mov	r0, r4
 1002608:	9203      	str	r2, [sp, #12]
 100260a:	f024 f9b3 	bl	1026974 <memcpy>
		buf += size;
 100260e:	9a03      	ldr	r2, [sp, #12]
 1002610:	4414      	add	r4, r2
	for (i = 0; i < s_idx; i++) {
 1002612:	f10a 0a01 	add.w	sl, sl, #1
 1002616:	f109 0901 	add.w	r9, r9, #1
 100261a:	e7c6      	b.n	10025aa <cbvprintf_package+0x396>
			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
 100261c:	f899 2000 	ldrb.w	r2, [r9]
 1002620:	f855 3022 	ldr.w	r3, [r5, r2, lsl #2]
 1002624:	9300      	str	r3, [sp, #0]
			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
 1002626:	9b01      	ldr	r3, [sp, #4]
			size = strlen(s) + 1;
 1002628:	9800      	ldr	r0, [sp, #0]
			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
 100262a:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
			size = strlen(s) + 1;
 100262e:	f024 f962 	bl	10268f6 <strlen>
 1002632:	1c42      	adds	r2, r0, #1
 1002634:	e7dc      	b.n	10025f0 <cbvprintf_package+0x3dc>
		return -EFAULT;
 1002636:	f06f 000d 	mvn.w	r0, #13
 100263a:	e604      	b.n	1002246 <cbvprintf_package+0x32>
 100263c:	0102b985 	.word	0x0102b985
 1002640:	0102ff6e 	.word	0x0102ff6e
 1002644:	0102b695 	.word	0x0102b695
 1002648:	0102b9ee 	.word	0x0102b9ee
 100264c:	0102ba03 	.word	0x0102ba03

01002650 <cbprintf_package_convert>:
			     cbprintf_convert_cb cb,
			     void *ctx,
			     uint32_t flags,
			     uint16_t *strl,
			     size_t strl_len)
{
 1002650:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1002654:	b095      	sub	sp, #84	; 0x54
 1002656:	af00      	add	r7, sp, #0
	__ASSERT_NO_MSG(in_packaged != NULL);
 1002658:	4604      	mov	r4, r0
{
 100265a:	e9c7 1208 	strd	r1, r2, [r7, #32]
 100265e:	f8d7 b078 	ldr.w	fp, [r7, #120]	; 0x78
 1002662:	61bb      	str	r3, [r7, #24]
	__ASSERT_NO_MSG(in_packaged != NULL);
 1002664:	b958      	cbnz	r0, 100267e <cbprintf_package_convert+0x2e>
 1002666:	49aa      	ldr	r1, [pc, #680]	; (1002910 <cbprintf_package_convert+0x2c0>)
 1002668:	f44f 7365 	mov.w	r3, #916	; 0x394
 100266c:	4aa9      	ldr	r2, [pc, #676]	; (1002914 <cbprintf_package_convert+0x2c4>)
 100266e:	48aa      	ldr	r0, [pc, #680]	; (1002918 <cbprintf_package_convert+0x2c8>)
 1002670:	f022 fab1 	bl	1024bd6 <assert_print>
 1002674:	f44f 7165 	mov.w	r1, #916	; 0x394
			continue;
		}

		if (is_ro) {
			if (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) {
				__ASSERT_NO_MSG(scpy_cnt < sizeof(cpy_str_pos));
 1002678:	48a6      	ldr	r0, [pc, #664]	; (1002914 <cbprintf_package_convert+0x2c4>)
 100267a:	f022 faa5 	bl	1024bc8 <assert_post_action>
	bool fmt_present = flags & CBPRINTF_PACKAGE_CONVERT_PTR_CHECK ? true : false;
 100267e:	f3cb 03c0 	ubfx	r3, fp, #3, #1
 1002682:	613b      	str	r3, [r7, #16]
	in_len = in_len != 0 ? in_len : get_package_len(in_packaged);
 1002684:	6a3b      	ldr	r3, [r7, #32]
 1002686:	b953      	cbnz	r3, 100269e <cbprintf_package_convert+0x4e>
	args_size = buf[0] * sizeof(int);
 1002688:	7803      	ldrb	r3, [r0, #0]
	s_nbr     = buf[1];
 100268a:	7846      	ldrb	r6, [r0, #1]
	ros_nbr   = buf[2];
 100268c:	7880      	ldrb	r0, [r0, #2]
	for (int i = 0; i < s_nbr; i++) {
 100268e:	6a3d      	ldr	r5, [r7, #32]
	buf += ros_nbr;
 1002690:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 1002694:	4420      	add	r0, r4
	for (int i = 0; i < s_nbr; i++) {
 1002696:	42ae      	cmp	r6, r5
 1002698:	d81a      	bhi.n	10026d0 <cbprintf_package_convert+0x80>
	return (size_t)(uintptr_t)(buf - start);
 100269a:	1b03      	subs	r3, r0, r4
 100269c:	623b      	str	r3, [r7, #32]
	ros_nbr = in_desc->ro_str_cnt;
 100269e:	f894 9002 	ldrb.w	r9, [r4, #2]
	rws_nbr = in_desc->rw_str_cnt;
 10026a2:	78e3      	ldrb	r3, [r4, #3]
	ros_nbr = in_desc->ro_str_cnt;
 10026a4:	464e      	mov	r6, r9
	rws_nbr = in_desc->rw_str_cnt;
 10026a6:	617b      	str	r3, [r7, #20]
	ro_cpy = ros_nbr &&
 10026a8:	f1b9 0f00 	cmp.w	r9, #0
 10026ac:	d002      	beq.n	10026b4 <cbprintf_package_convert+0x64>
 10026ae:	f01b 0f01 	tst.w	fp, #1
 10026b2:	d116      	bne.n	10026e2 <cbprintf_package_convert+0x92>
	rw_cpy = rws_nbr > 0 &&
 10026b4:	697b      	ldr	r3, [r7, #20]
 10026b6:	bb53      	cbnz	r3, 100270e <cbprintf_package_convert+0xbe>
		if (cb) {
 10026b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 10026ba:	b11b      	cbz	r3, 10026c4 <cbprintf_package_convert+0x74>
			cb(in_packaged, in_len, ctx);
 10026bc:	4620      	mov	r0, r4
 10026be:	69ba      	ldr	r2, [r7, #24]
 10026c0:	6a39      	ldr	r1, [r7, #32]
 10026c2:	4798      	blx	r3
		return in_len;
 10026c4:	6a3d      	ldr	r5, [r7, #32]

	/* Empty call (can be interpreted as flushing) */
	(void)cb(NULL, 0, ctx);

	return out_len;
}
 10026c6:	4628      	mov	r0, r5
 10026c8:	3754      	adds	r7, #84	; 0x54
 10026ca:	46bd      	mov	sp, r7
 10026cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		buf++;
 10026d0:	f100 0801 	add.w	r8, r0, #1
		buf += strlen((const char *)buf) + 1;
 10026d4:	4640      	mov	r0, r8
 10026d6:	f024 f90e 	bl	10268f6 <strlen>
 10026da:	3001      	adds	r0, #1
 10026dc:	4440      	add	r0, r8
	for (int i = 0; i < s_nbr; i++) {
 10026de:	3501      	adds	r5, #1
 10026e0:	e7d9      	b.n	1002696 <cbprintf_package_convert+0x46>
	rw_cpy = rws_nbr > 0 &&
 10026e2:	6863      	ldr	r3, [r4, #4]
 10026e4:	f894 a000 	ldrb.w	sl, [r4]
	const char *fmt = *(const char **)(buf + sizeof(void *));
 10026e8:	61fb      	str	r3, [r7, #28]
	if (cb == NULL) {
 10026ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	args_size = in_desc->len * sizeof(int);
 10026ec:	ea4f 028a 	mov.w	r2, sl, lsl #2
 10026f0:	60fa      	str	r2, [r7, #12]
	uint8_t *str_pos = &buf[args_size];
 10026f2:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
	if (cb == NULL) {
 10026f6:	2b00      	cmp	r3, #0
 10026f8:	f040 8105 	bne.w	1002906 <cbprintf_package_convert+0x2b6>
		out_len = (int)in_len;
 10026fc:	46d0      	mov	r8, sl
	size_t strl_cnt = 0;
 10026fe:	2600      	movs	r6, #0
		out_len = (int)in_len;
 1002700:	6a3d      	ldr	r5, [r7, #32]
		if (ro_cpy) {
 1002702:	eb09 030a 	add.w	r3, r9, sl
			for (int i = 0; i < ros_nbr; i++) {
 1002706:	4598      	cmp	r8, r3
 1002708:	d14e      	bne.n	10027a8 <cbprintf_package_convert+0x158>
 100270a:	44ca      	add	sl, r9
 100270c:	e013      	b.n	1002736 <cbprintf_package_convert+0xe6>
	rw_cpy = rws_nbr > 0 &&
 100270e:	f01b 0f02 	tst.w	fp, #2
 1002712:	d0d1      	beq.n	10026b8 <cbprintf_package_convert+0x68>
	args_size = in_desc->len * sizeof(int);
 1002714:	f894 a000 	ldrb.w	sl, [r4]
 1002718:	ea4f 038a 	mov.w	r3, sl, lsl #2
 100271c:	60fb      	str	r3, [r7, #12]
	const char *fmt = *(const char **)(buf + sizeof(void *));
 100271e:	6863      	ldr	r3, [r4, #4]
	uint8_t *str_pos = &buf[args_size];
 1002720:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
	const char *fmt = *(const char **)(buf + sizeof(void *));
 1002724:	61fb      	str	r3, [r7, #28]
	if (cb == NULL) {
 1002726:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 1002728:	2b00      	cmp	r3, #0
 100272a:	d178      	bne.n	100281e <cbprintf_package_convert+0x1ce>
		out_len = (int)in_len;
 100272c:	6a3d      	ldr	r5, [r7, #32]
			if (ros_nbr && flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) {
 100272e:	f1b9 0f00 	cmp.w	r9, #0
 1002732:	d14e      	bne.n	10027d2 <cbprintf_package_convert+0x182>
	size_t strl_cnt = 0;
 1002734:	464e      	mov	r6, r9
		for (int i = 0; i < rws_nbr; i++) {
 1002736:	f01b 0f05 	tst.w	fp, #5
 100273a:	bf0c      	ite	eq
 100273c:	2302      	moveq	r3, #2
 100273e:	2301      	movne	r3, #1
 1002740:	627b      	str	r3, [r7, #36]	; 0x24
 1002742:	697b      	ldr	r3, [r7, #20]
 1002744:	eb0a 0943 	add.w	r9, sl, r3, lsl #1
			} else if (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) {
 1002748:	f00b 0302 	and.w	r3, fp, #2
 100274c:	623b      	str	r3, [r7, #32]
		for (int i = 0; i < rws_nbr; i++) {
 100274e:	45ca      	cmp	sl, r9
 1002750:	d0b9      	beq.n	10026c6 <cbprintf_package_convert+0x76>
			uint8_t arg_idx = *str_pos++;
 1002752:	f81a 1b02 	ldrb.w	r1, [sl], #2
			const char *str = *(const char **)&buf32[arg_pos];
 1002756:	f81a 3c01 	ldrb.w	r3, [sl, #-1]
 100275a:	f854 8023 	ldr.w	r8, [r4, r3, lsl #2]
 100275e:	4b6f      	ldr	r3, [pc, #444]	; (100291c <cbprintf_package_convert+0x2cc>)
 1002760:	4598      	cmp	r8, r3
 1002762:	d302      	bcc.n	100276a <cbprintf_package_convert+0x11a>
 1002764:	4b6e      	ldr	r3, [pc, #440]	; (1002920 <cbprintf_package_convert+0x2d0>)
 1002766:	4598      	cmp	r8, r3
 1002768:	d339      	bcc.n	10027de <cbprintf_package_convert+0x18e>
			if (fmt_present && is_ptr(fmt, arg_idx)) {
 100276a:	693b      	ldr	r3, [r7, #16]
 100276c:	2b00      	cmp	r3, #0
 100276e:	d043      	beq.n	10027f8 <cbprintf_package_convert+0x1a8>
 1002770:	69f8      	ldr	r0, [r7, #28]
 1002772:	f021 ff73 	bl	102465c <is_ptr>
 1002776:	2800      	cmp	r0, #0
 1002778:	d03e      	beq.n	10027f8 <cbprintf_package_convert+0x1a8>
				LOG_WRN("(unsigned) char * used for %%p argument. "
 100277a:	46e8      	mov	r8, sp
 100277c:	b08a      	sub	sp, #40	; 0x28
 100277e:	466a      	mov	r2, sp
 1002780:	4b68      	ldr	r3, [pc, #416]	; (1002924 <cbprintf_package_convert+0x2d4>)
 1002782:	6153      	str	r3, [r2, #20]
 1002784:	69fb      	ldr	r3, [r7, #28]
 1002786:	e9c2 3106 	strd	r3, r1, [r2, #24]
 100278a:	f44f 7300 	mov.w	r3, #512	; 0x200
 100278e:	8413      	strh	r3, [r2, #32]
 1002790:	4b65      	ldr	r3, [pc, #404]	; (1002928 <cbprintf_package_convert+0x2d8>)
 1002792:	f842 3f10 	str.w	r3, [r2, #16]!
 1002796:	2300      	movs	r3, #0
 1002798:	f44f 5112 	mov.w	r1, #9344	; 0x2480
 100279c:	4863      	ldr	r0, [pc, #396]	; (100292c <cbprintf_package_convert+0x2dc>)
 100279e:	f001 ffb3 	bl	1004708 <z_impl_z_log_msg_static_create>
				out_len -= 2;
 10027a2:	3d02      	subs	r5, #2
 10027a4:	46c5      	mov	sp, r8
				continue;
 10027a6:	e7d2      	b.n	100274e <cbprintf_package_convert+0xfe>
				const char *str = *(const char **)&buf32[*str_pos];
 10027a8:	f818 2b01 	ldrb.w	r2, [r8], #1
 10027ac:	627b      	str	r3, [r7, #36]	; 0x24
		return 1 + strlen(str);
 10027ae:	f854 0022 	ldr.w	r0, [r4, r2, lsl #2]
 10027b2:	f024 f8a0 	bl	10268f6 <strlen>
				if (strl && strl_cnt < strl_len) {
 10027b6:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 10027b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
		return 1 + strlen(str);
 10027ba:	3001      	adds	r0, #1
				if (strl && strl_cnt < strl_len) {
 10027bc:	b13a      	cbz	r2, 10027ce <cbprintf_package_convert+0x17e>
 10027be:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 10027c2:	4296      	cmp	r6, r2
					strl[strl_cnt++] = (uint16_t)len;
 10027c4:	bf3e      	ittt	cc
 10027c6:	6ffa      	ldrcc	r2, [r7, #124]	; 0x7c
 10027c8:	f822 0016 	strhcc.w	r0, [r2, r6, lsl #1]
 10027cc:	3601      	addcc	r6, #1
				out_len += len;
 10027ce:	4405      	add	r5, r0
			for (int i = 0; i < ros_nbr; i++) {
 10027d0:	e799      	b.n	1002706 <cbprintf_package_convert+0xb6>
			if (ros_nbr && flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) {
 10027d2:	f01b 0604 	ands.w	r6, fp, #4
	size_t strl_cnt = 0;
 10027d6:	bf1c      	itt	ne
 10027d8:	6a7e      	ldrne	r6, [r7, #36]	; 0x24
				str_pos += ros_nbr;
 10027da:	44ca      	addne	sl, r9
 10027dc:	e7ab      	b.n	1002736 <cbprintf_package_convert+0xe6>
			if (fmt_present && is_ptr(fmt, arg_idx)) {
 10027de:	693b      	ldr	r3, [r7, #16]
 10027e0:	b123      	cbz	r3, 10027ec <cbprintf_package_convert+0x19c>
 10027e2:	69f8      	ldr	r0, [r7, #28]
 10027e4:	f021 ff3a 	bl	102465c <is_ptr>
 10027e8:	2800      	cmp	r0, #0
 10027ea:	d1c6      	bne.n	100277a <cbprintf_package_convert+0x12a>
				if (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) {
 10027ec:	f01b 0f01 	tst.w	fp, #1
 10027f0:	d105      	bne.n	10027fe <cbprintf_package_convert+0x1ae>
					out_len -= drop_ro_str_pos ? 2 : 1;
 10027f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 10027f4:	1aed      	subs	r5, r5, r3
 10027f6:	e7aa      	b.n	100274e <cbprintf_package_convert+0xfe>
			} else if (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) {
 10027f8:	6a3b      	ldr	r3, [r7, #32]
 10027fa:	2b00      	cmp	r3, #0
 10027fc:	d0a7      	beq.n	100274e <cbprintf_package_convert+0xfe>
		return 1 + strlen(str);
 10027fe:	4640      	mov	r0, r8
 1002800:	f024 f879 	bl	10268f6 <strlen>
				if (strl && strl_cnt < strl_len) {
 1002804:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 1002806:	b143      	cbz	r3, 100281a <cbprintf_package_convert+0x1ca>
 1002808:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 100280c:	429e      	cmp	r6, r3
					strl[strl_cnt++] = (uint16_t)len;
 100280e:	bf3f      	itttt	cc
 1002810:	6ffa      	ldrcc	r2, [r7, #124]	; 0x7c
		return 1 + strlen(str);
 1002812:	1c43      	addcc	r3, r0, #1
					strl[strl_cnt++] = (uint16_t)len;
 1002814:	f822 3016 	strhcc.w	r3, [r2, r6, lsl #1]
 1002818:	3601      	addcc	r6, #1
				out_len += (len - 1);
 100281a:	4405      	add	r5, r0
		for (int i = 0; i < rws_nbr; i++) {
 100281c:	e797      	b.n	100274e <cbprintf_package_convert+0xfe>
	} else if (ros_nbr && flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) {
 100281e:	f1b9 0f00 	cmp.w	r9, #0
 1002822:	f000 8085 	beq.w	1002930 <cbprintf_package_convert+0x2e0>
 1002826:	f01b 0604 	ands.w	r6, fp, #4
 100282a:	f000 8084 	beq.w	1002936 <cbprintf_package_convert+0x2e6>
		keep_cnt = ros_nbr;
 100282e:	46c8      	mov	r8, r9
		scpy_cnt = 0;
 1002830:	2600      	movs	r6, #0
		dst = keep_str_pos;
 1002832:	f107 0040 	add.w	r0, r7, #64	; 0x40
		memcpy(dst, str_pos, ros_nbr);
 1002836:	464a      	mov	r2, r9
 1002838:	4651      	mov	r1, sl
 100283a:	f024 f89b 	bl	1026974 <memcpy>
	str_pos += ros_nbr;
 100283e:	697b      	ldr	r3, [r7, #20]
 1002840:	44ca      	add	sl, r9
	for (int i = 0; i < rws_nbr; i++) {
 1002842:	005b      	lsls	r3, r3, #1
 1002844:	60bb      	str	r3, [r7, #8]
 1002846:	697b      	ldr	r3, [r7, #20]
 1002848:	eb0a 0343 	add.w	r3, sl, r3, lsl #1
 100284c:	617b      	str	r3, [r7, #20]
			if (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) {
 100284e:	f00b 0302 	and.w	r3, fp, #2
 1002852:	607b      	str	r3, [r7, #4]
	for (int i = 0; i < rws_nbr; i++) {
 1002854:	697b      	ldr	r3, [r7, #20]
 1002856:	459a      	cmp	sl, r3
 1002858:	d16f      	bne.n	100293a <cbprintf_package_convert+0x2ea>
	out_desc.len = in_desc->len;
 100285a:	7823      	ldrb	r3, [r4, #0]
	out_desc.rw_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) ? 0 : (keep_cnt / 2);
 100285c:	f01b 0f02 	tst.w	fp, #2
	out_desc.len = in_desc->len;
 1002860:	617b      	str	r3, [r7, #20]
	out_desc.str_cnt = in_desc->str_cnt + scpy_cnt;
 1002862:	7863      	ldrb	r3, [r4, #1]
	out_desc.rw_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) ? 0 : (keep_cnt / 2);
 1002864:	bf18      	it	ne
 1002866:	2100      	movne	r1, #0
	out_desc.str_cnt = in_desc->str_cnt + scpy_cnt;
 1002868:	eb06 0203 	add.w	r2, r6, r3
	out_desc.rw_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) ? 0 : (keep_cnt / 2);
 100286c:	bf08      	it	eq
 100286e:	ea4f 0158 	moveq.w	r1, r8, lsr #1
	out_desc.ro_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) ? 0 :
 1002872:	f01b 0f01 	tst.w	fp, #1
	out_desc.str_cnt = in_desc->str_cnt + scpy_cnt;
 1002876:	b2d2      	uxtb	r2, r2
	out_desc.ro_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) ? 0 :
 1002878:	f040 80e4 	bne.w	1002a44 <cbprintf_package_convert+0x3f4>
 100287c:	f01b 0f04 	tst.w	fp, #4
 1002880:	bf14      	ite	ne
 1002882:	4640      	movne	r0, r8
 1002884:	2000      	moveq	r0, #0
 1002886:	613b      	str	r3, [r7, #16]
	struct cbprintf_package_desc in_desc_backup = *in_desc;
 1002888:	78a3      	ldrb	r3, [r4, #2]
 100288a:	f894 b003 	ldrb.w	fp, [r4, #3]
 100288e:	61fb      	str	r3, [r7, #28]
	*in_desc = out_desc;
 1002890:	7062      	strb	r2, [r4, #1]
 1002892:	70a0      	strb	r0, [r4, #2]
 1002894:	70e1      	strb	r1, [r4, #3]
	rv = cb(in_packaged, args_size, ctx);
 1002896:	4620      	mov	r0, r4
 1002898:	69ba      	ldr	r2, [r7, #24]
 100289a:	68f9      	ldr	r1, [r7, #12]
 100289c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 100289e:	4798      	blx	r3
	if (rv < 0) {
 10028a0:	1e05      	subs	r5, r0, #0
 10028a2:	f6ff af10 	blt.w	10026c6 <cbprintf_package_convert+0x76>
	*in_desc = in_desc_backup;
 10028a6:	697b      	ldr	r3, [r7, #20]
	rv = cb(keep_str_pos, keep_cnt, ctx);
 10028a8:	4641      	mov	r1, r8
	*in_desc = in_desc_backup;
 10028aa:	7023      	strb	r3, [r4, #0]
 10028ac:	693b      	ldr	r3, [r7, #16]
	rv = cb(keep_str_pos, keep_cnt, ctx);
 10028ae:	69ba      	ldr	r2, [r7, #24]
	*in_desc = in_desc_backup;
 10028b0:	7063      	strb	r3, [r4, #1]
 10028b2:	69fb      	ldr	r3, [r7, #28]
 10028b4:	f884 b003 	strb.w	fp, [r4, #3]
 10028b8:	70a3      	strb	r3, [r4, #2]
	rv = cb(keep_str_pos, keep_cnt, ctx);
 10028ba:	f107 0040 	add.w	r0, r7, #64	; 0x40
 10028be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 10028c0:	4798      	blx	r3
	if (rv < 0) {
 10028c2:	f1b0 0800 	subs.w	r8, r0, #0
 10028c6:	f2c0 80ea 	blt.w	1002a9e <cbprintf_package_convert+0x44e>
	size_t strs_len = in_len - (args_size + ros_nbr + 2 * rws_nbr);
 10028ca:	6a3b      	ldr	r3, [r7, #32]
	rv = cb(str_pos, strs_len, ctx);
 10028cc:	4650      	mov	r0, sl
	size_t strs_len = in_len - (args_size + ros_nbr + 2 * rws_nbr);
 10028ce:	eba3 0109 	sub.w	r1, r3, r9
 10028d2:	68fb      	ldr	r3, [r7, #12]
	rv = cb(str_pos, strs_len, ctx);
 10028d4:	69ba      	ldr	r2, [r7, #24]
	size_t strs_len = in_len - (args_size + ros_nbr + 2 * rws_nbr);
 10028d6:	1ac9      	subs	r1, r1, r3
	rv = cb(str_pos, strs_len, ctx);
 10028d8:	68bb      	ldr	r3, [r7, #8]
 10028da:	1ac9      	subs	r1, r1, r3
 10028dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 10028de:	4798      	blx	r3
	if (rv < 0) {
 10028e0:	2800      	cmp	r0, #0
 10028e2:	f2c0 80de 	blt.w	1002aa2 <cbprintf_package_convert+0x452>
	for (int i = 0; i < scpy_cnt; i++) {
 10028e6:	f04f 0b00 	mov.w	fp, #0
	out_len += rv;
 10028ea:	44a8      	add	r8, r5
	out_len += rv;
 10028ec:	eb08 0500 	add.w	r5, r8, r0
		uint8_t loc = cpy_str_pos[i];
 10028f0:	f107 0a30 	add.w	sl, r7, #48	; 0x30
	for (int i = 0; i < scpy_cnt; i++) {
 10028f4:	45b3      	cmp	fp, r6
 10028f6:	f2c0 80a7 	blt.w	1002a48 <cbprintf_package_convert+0x3f8>
	(void)cb(NULL, 0, ctx);
 10028fa:	2100      	movs	r1, #0
 10028fc:	69ba      	ldr	r2, [r7, #24]
 10028fe:	4608      	mov	r0, r1
 1002900:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 1002902:	4798      	blx	r3
	return out_len;
 1002904:	e6df      	b.n	10026c6 <cbprintf_package_convert+0x76>
	if (cb == NULL) {
 1002906:	f04f 0800 	mov.w	r8, #0
 100290a:	f107 0030 	add.w	r0, r7, #48	; 0x30
 100290e:	e792      	b.n	1002836 <cbprintf_package_convert+0x1e6>
 1002910:	0102ba1a 	.word	0x0102ba1a
 1002914:	0102b985 	.word	0x0102b985
 1002918:	0102b695 	.word	0x0102b695
 100291c:	01029660 	.word	0x01029660
 1002920:	0102ffdc 	.word	0x0102ffdc
 1002924:	0102ba35 	.word	0x0102ba35
 1002928:	01000004 	.word	0x01000004
 100292c:	010299ec 	.word	0x010299ec
		scpy_cnt = 0;
 1002930:	464e      	mov	r6, r9
		keep_cnt = 0;
 1002932:	46c8      	mov	r8, r9
 1002934:	e783      	b.n	100283e <cbprintf_package_convert+0x1ee>
 1002936:	46b0      	mov	r8, r6
 1002938:	e781      	b.n	100283e <cbprintf_package_convert+0x1ee>
		uint8_t arg_idx = *str_pos++;
 100293a:	f81a 1b02 	ldrb.w	r1, [sl], #2
 100293e:	4b5a      	ldr	r3, [pc, #360]	; (1002aa8 <cbprintf_package_convert+0x458>)
		uint8_t arg_pos = *str_pos++;
 1002940:	f81a 5c01 	ldrb.w	r5, [sl, #-1]
		const char *str = *(const char **)&buf32[arg_pos];
 1002944:	f854 2025 	ldr.w	r2, [r4, r5, lsl #2]
 1002948:	429a      	cmp	r2, r3
 100294a:	d302      	bcc.n	1002952 <cbprintf_package_convert+0x302>
 100294c:	4b57      	ldr	r3, [pc, #348]	; (1002aac <cbprintf_package_convert+0x45c>)
 100294e:	429a      	cmp	r2, r3
 1002950:	d316      	bcc.n	1002980 <cbprintf_package_convert+0x330>
		if (fmt_present && is_ptr(fmt, arg_idx)) {
 1002952:	693b      	ldr	r3, [r7, #16]
 1002954:	b12b      	cbz	r3, 1002962 <cbprintf_package_convert+0x312>
 1002956:	69f8      	ldr	r0, [r7, #28]
 1002958:	f021 fe80 	bl	102465c <is_ptr>
 100295c:	2800      	cmp	r0, #0
 100295e:	f47f af79 	bne.w	1002854 <cbprintf_package_convert+0x204>
			if (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) {
 1002962:	687b      	ldr	r3, [r7, #4]
 1002964:	2b00      	cmp	r3, #0
 1002966:	d04a      	beq.n	10029fe <cbprintf_package_convert+0x3ae>
				__ASSERT_NO_MSG(scpy_cnt < sizeof(cpy_str_pos));
 1002968:	2e0f      	cmp	r6, #15
 100296a:	d93e      	bls.n	10029ea <cbprintf_package_convert+0x39a>
 100296c:	4950      	ldr	r1, [pc, #320]	; (1002ab0 <cbprintf_package_convert+0x460>)
 100296e:	f44f 6389 	mov.w	r3, #1096	; 0x448
 1002972:	4a50      	ldr	r2, [pc, #320]	; (1002ab4 <cbprintf_package_convert+0x464>)
 1002974:	4850      	ldr	r0, [pc, #320]	; (1002ab8 <cbprintf_package_convert+0x468>)
 1002976:	f022 f92e 	bl	1024bd6 <assert_print>
 100297a:	f44f 6189 	mov.w	r1, #1096	; 0x448
 100297e:	e67b      	b.n	1002678 <cbprintf_package_convert+0x28>
		if (fmt_present && is_ptr(fmt, arg_idx)) {
 1002980:	693b      	ldr	r3, [r7, #16]
 1002982:	b12b      	cbz	r3, 1002990 <cbprintf_package_convert+0x340>
 1002984:	69f8      	ldr	r0, [r7, #28]
 1002986:	f021 fe69 	bl	102465c <is_ptr>
 100298a:	2800      	cmp	r0, #0
 100298c:	f47f af62 	bne.w	1002854 <cbprintf_package_convert+0x204>
			if (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) {
 1002990:	f01b 0f01 	tst.w	fp, #1
 1002994:	d00b      	beq.n	10029ae <cbprintf_package_convert+0x35e>
				__ASSERT_NO_MSG(scpy_cnt < sizeof(cpy_str_pos));
 1002996:	2e0f      	cmp	r6, #15
 1002998:	d927      	bls.n	10029ea <cbprintf_package_convert+0x39a>
 100299a:	4945      	ldr	r1, [pc, #276]	; (1002ab0 <cbprintf_package_convert+0x460>)
 100299c:	f240 433e 	movw	r3, #1086	; 0x43e
 10029a0:	4a44      	ldr	r2, [pc, #272]	; (1002ab4 <cbprintf_package_convert+0x464>)
 10029a2:	4845      	ldr	r0, [pc, #276]	; (1002ab8 <cbprintf_package_convert+0x468>)
 10029a4:	f022 f917 	bl	1024bd6 <assert_print>
 10029a8:	f240 413e 	movw	r1, #1086	; 0x43e
 10029ac:	e664      	b.n	1002678 <cbprintf_package_convert+0x28>
			} else if (flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) {
 10029ae:	f01b 0f04 	tst.w	fp, #4
 10029b2:	f43f af4f 	beq.w	1002854 <cbprintf_package_convert+0x204>
				__ASSERT_NO_MSG(keep_cnt < sizeof(keep_str_pos));
 10029b6:	f1b8 0f0f 	cmp.w	r8, #15
 10029ba:	d909      	bls.n	10029d0 <cbprintf_package_convert+0x380>
 10029bc:	493f      	ldr	r1, [pc, #252]	; (1002abc <cbprintf_package_convert+0x46c>)
 10029be:	f240 4341 	movw	r3, #1089	; 0x441
 10029c2:	4a3c      	ldr	r2, [pc, #240]	; (1002ab4 <cbprintf_package_convert+0x464>)
 10029c4:	483c      	ldr	r0, [pc, #240]	; (1002ab8 <cbprintf_package_convert+0x468>)
 10029c6:	f022 f906 	bl	1024bd6 <assert_print>
 10029ca:	f240 4141 	movw	r1, #1089	; 0x441
 10029ce:	e653      	b.n	1002678 <cbprintf_package_convert+0x28>
				keep_str_pos[keep_cnt++] = arg_pos;
 10029d0:	f108 0328 	add.w	r3, r8, #40	; 0x28
 10029d4:	f107 0128 	add.w	r1, r7, #40	; 0x28
 10029d8:	f108 0201 	add.w	r2, r8, #1
 10029dc:	eb03 0801 	add.w	r8, r3, r1
 10029e0:	f808 5c10 	strb.w	r5, [r8, #-16]
 10029e4:	fa5f f882 	uxtb.w	r8, r2
 10029e8:	e734      	b.n	1002854 <cbprintf_package_convert+0x204>
				cpy_str_pos[scpy_cnt++] = arg_pos;
 10029ea:	f106 0328 	add.w	r3, r6, #40	; 0x28
 10029ee:	f107 0128 	add.w	r1, r7, #40	; 0x28
 10029f2:	1c72      	adds	r2, r6, #1
 10029f4:	185e      	adds	r6, r3, r1
 10029f6:	f806 5c20 	strb.w	r5, [r6, #-32]
 10029fa:	b2d6      	uxtb	r6, r2
 10029fc:	e72a      	b.n	1002854 <cbprintf_package_convert+0x204>
				__ASSERT_NO_MSG(keep_cnt < sizeof(keep_str_pos));
 10029fe:	f1b8 0f0f 	cmp.w	r8, #15
 1002a02:	d909      	bls.n	1002a18 <cbprintf_package_convert+0x3c8>
 1002a04:	492d      	ldr	r1, [pc, #180]	; (1002abc <cbprintf_package_convert+0x46c>)
 1002a06:	f240 434b 	movw	r3, #1099	; 0x44b
 1002a0a:	4a2a      	ldr	r2, [pc, #168]	; (1002ab4 <cbprintf_package_convert+0x464>)
 1002a0c:	482a      	ldr	r0, [pc, #168]	; (1002ab8 <cbprintf_package_convert+0x468>)
 1002a0e:	f022 f8e2 	bl	1024bd6 <assert_print>
 1002a12:	f240 414b 	movw	r1, #1099	; 0x44b
 1002a16:	e62f      	b.n	1002678 <cbprintf_package_convert+0x28>
				keep_str_pos[keep_cnt++] = arg_idx;
 1002a18:	f108 0201 	add.w	r2, r8, #1
 1002a1c:	f108 0328 	add.w	r3, r8, #40	; 0x28
 1002a20:	b2d2      	uxtb	r2, r2
 1002a22:	f107 0028 	add.w	r0, r7, #40	; 0x28
 1002a26:	1818      	adds	r0, r3, r0
				keep_str_pos[keep_cnt++] = arg_pos;
 1002a28:	f102 0328 	add.w	r3, r2, #40	; 0x28
 1002a2c:	f107 0228 	add.w	r2, r7, #40	; 0x28
 1002a30:	f108 0802 	add.w	r8, r8, #2
 1002a34:	189a      	adds	r2, r3, r2
				keep_str_pos[keep_cnt++] = arg_idx;
 1002a36:	f800 1c10 	strb.w	r1, [r0, #-16]
				keep_str_pos[keep_cnt++] = arg_pos;
 1002a3a:	fa5f f888 	uxtb.w	r8, r8
 1002a3e:	f802 5c10 	strb.w	r5, [r2, #-16]
	for (int i = 0; i < rws_nbr; i++) {
 1002a42:	e707      	b.n	1002854 <cbprintf_package_convert+0x204>
	out_desc.ro_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) ? 0 :
 1002a44:	2000      	movs	r0, #0
 1002a46:	e71e      	b.n	1002886 <cbprintf_package_convert+0x236>
		uint8_t loc = cpy_str_pos[i];
 1002a48:	f81b 300a 	ldrb.w	r3, [fp, sl]
		const char *str = *(const char **)&buf32[loc];
 1002a4c:	f854 9023 	ldr.w	r9, [r4, r3, lsl #2]
		uint8_t loc = cpy_str_pos[i];
 1002a50:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		uint16_t str_len = strl ? strl[i] : 0;
 1002a54:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 1002a56:	b1fb      	cbz	r3, 1002a98 <cbprintf_package_convert+0x448>
 1002a58:	f833 801b 	ldrh.w	r8, [r3, fp, lsl #1]
		rv = cb(&loc, 1, ctx);
 1002a5c:	2101      	movs	r1, #1
 1002a5e:	69ba      	ldr	r2, [r7, #24]
 1002a60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 1002a62:	f107 002f 	add.w	r0, r7, #47	; 0x2f
 1002a66:	4798      	blx	r3
		if (rv < 0) {
 1002a68:	2800      	cmp	r0, #0
 1002a6a:	db1a      	blt.n	1002aa2 <cbprintf_package_convert+0x452>
		out_len += rv;
 1002a6c:	4405      	add	r5, r0
	strl = strl > 0 ? strl : strlen(str) + 1;
 1002a6e:	f1b8 0f00 	cmp.w	r8, #0
 1002a72:	d106      	bne.n	1002a82 <cbprintf_package_convert+0x432>
 1002a74:	4648      	mov	r0, r9
 1002a76:	f023 ff3e 	bl	10268f6 <strlen>
 1002a7a:	f100 0801 	add.w	r8, r0, #1
 1002a7e:	fa1f f888 	uxth.w	r8, r8
	return cb(str, strl, ctx);
 1002a82:	4641      	mov	r1, r8
 1002a84:	4648      	mov	r0, r9
 1002a86:	69ba      	ldr	r2, [r7, #24]
 1002a88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 1002a8a:	4798      	blx	r3
		if (rv < 0) {
 1002a8c:	2800      	cmp	r0, #0
 1002a8e:	db08      	blt.n	1002aa2 <cbprintf_package_convert+0x452>
		out_len += rv;
 1002a90:	4405      	add	r5, r0
	for (int i = 0; i < scpy_cnt; i++) {
 1002a92:	f10b 0b01 	add.w	fp, fp, #1
 1002a96:	e72d      	b.n	10028f4 <cbprintf_package_convert+0x2a4>
		uint16_t str_len = strl ? strl[i] : 0;
 1002a98:	f8d7 807c 	ldr.w	r8, [r7, #124]	; 0x7c
 1002a9c:	e7de      	b.n	1002a5c <cbprintf_package_convert+0x40c>
 1002a9e:	4645      	mov	r5, r8
 1002aa0:	e611      	b.n	10026c6 <cbprintf_package_convert+0x76>
 1002aa2:	4605      	mov	r5, r0
 1002aa4:	e60f      	b.n	10026c6 <cbprintf_package_convert+0x76>
 1002aa6:	bf00      	nop
 1002aa8:	01029660 	.word	0x01029660
 1002aac:	0102ffdc 	.word	0x0102ffdc
 1002ab0:	0102bad8 	.word	0x0102bad8
 1002ab4:	0102b985 	.word	0x0102b985
 1002ab8:	0102b695 	.word	0x0102b695
 1002abc:	0102baf7 	.word	0x0102baf7

01002ac0 <__printk_hook_install>:
 * routine that outputs one ASCII character at a time.
 * @param fn putc routine to install
 */
void __printk_hook_install(int (*fn)(int c))
{
	_char_out = fn;
 1002ac0:	4b01      	ldr	r3, [pc, #4]	; (1002ac8 <__printk_hook_install+0x8>)
 1002ac2:	6018      	str	r0, [r3, #0]
}
 1002ac4:	4770      	bx	lr
 1002ac6:	bf00      	nop
 1002ac8:	21000270 	.word	0x21000270

01002acc <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
 1002acc:	b530      	push	{r4, r5, lr}
	struct str_context ctx = { str, size, 0 };
 1002ace:	2500      	movs	r5, #0
{
 1002ad0:	b087      	sub	sp, #28
	struct str_context ctx = { str, size, 0 };
 1002ad2:	e9cd 0103 	strd	r0, r1, [sp, #12]
{
 1002ad6:	4604      	mov	r4, r0
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
 1002ad8:	9500      	str	r5, [sp, #0]
 1002ada:	a903      	add	r1, sp, #12
 1002adc:	4805      	ldr	r0, [pc, #20]	; (1002af4 <vsnprintk+0x28>)
	struct str_context ctx = { str, size, 0 };
 1002ade:	9505      	str	r5, [sp, #20]
 1002ae0:	f000 fca6 	bl	1003430 <z_cbvprintf_impl>

	cbvprintf(str_out, &ctx, fmt, ap);

	if (ctx.count < ctx.max) {
 1002ae4:	e9dd 3004 	ldrd	r3, r0, [sp, #16]
 1002ae8:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
 1002aea:	bfb8      	it	lt
 1002aec:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
 1002aee:	b007      	add	sp, #28
 1002af0:	bd30      	pop	{r4, r5, pc}
 1002af2:	bf00      	nop
 1002af4:	0102479d 	.word	0x0102479d

01002af8 <sys_heap_free>:
	uint8_t *mem = p, *base = (uint8_t *)chunk_buf(h);
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
}

void sys_heap_free(struct sys_heap *heap, void *mem)
{
 1002af8:	b570      	push	{r4, r5, r6, lr}
	if (mem == NULL) {
 1002afa:	460c      	mov	r4, r1
 1002afc:	2900      	cmp	r1, #0
 1002afe:	d034      	beq.n	1002b6a <sys_heap_free+0x72>
		return; /* ISO C free() semantics */
	}
	struct z_heap *h = heap->heap;
 1002b00:	6802      	ldr	r2, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 1002b02:	1f0b      	subs	r3, r1, #4
 1002b04:	1a9b      	subs	r3, r3, r2
 1002b06:	08d9      	lsrs	r1, r3, #3

static inline chunkid_t chunk_field(struct z_heap *h, chunkid_t c,
				    enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
 1002b08:	f023 0307 	bic.w	r3, r3, #7

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
 1002b0c:	4413      	add	r3, r2
	}
}

static inline bool chunk_used(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
 1002b0e:	885d      	ldrh	r5, [r3, #2]

	/*
	 * This should catch many double-free cases.
	 * This is cheap enough so let's do it all the time.
	 */
	__ASSERT(chunk_used(h, c),
 1002b10:	07e8      	lsls	r0, r5, #31
 1002b12:	d40d      	bmi.n	1002b30 <sys_heap_free+0x38>
 1002b14:	23af      	movs	r3, #175	; 0xaf
 1002b16:	4a15      	ldr	r2, [pc, #84]	; (1002b6c <sys_heap_free+0x74>)
 1002b18:	4915      	ldr	r1, [pc, #84]	; (1002b70 <sys_heap_free+0x78>)
 1002b1a:	4816      	ldr	r0, [pc, #88]	; (1002b74 <sys_heap_free+0x7c>)
 1002b1c:	f022 f85b 	bl	1024bd6 <assert_print>
 1002b20:	4621      	mov	r1, r4
 1002b22:	4815      	ldr	r0, [pc, #84]	; (1002b78 <sys_heap_free+0x80>)
 1002b24:	f022 f857 	bl	1024bd6 <assert_print>
 1002b28:	21af      	movs	r1, #175	; 0xaf
	/*
	 * It is easy to catch many common memory overflow cases with
	 * a quick check on this and next chunk header fields that are
	 * immediately before and after the freed memory.
	 */
	__ASSERT(left_chunk(h, right_chunk(h, c)) == c,
 1002b2a:	4810      	ldr	r0, [pc, #64]	; (1002b6c <sys_heap_free+0x74>)
 1002b2c:	f022 f84c 	bl	1024bc8 <assert_post_action>
	return c - chunk_field(h, c, LEFT_SIZE);
}

static inline chunkid_t right_chunk(struct z_heap *h, chunkid_t c)
{
	return c + chunk_size(h, c);
 1002b30:	4610      	mov	r0, r2
 1002b32:	f021 fe6c 	bl	102480e <chunk_size>
 1002b36:	4408      	add	r0, r1
		return ((uint16_t *)cmem)[f];
 1002b38:	f832 6030 	ldrh.w	r6, [r2, r0, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
 1002b3c:	1b80      	subs	r0, r0, r6
 1002b3e:	4281      	cmp	r1, r0
 1002b40:	d00b      	beq.n	1002b5a <sys_heap_free+0x62>
 1002b42:	23b7      	movs	r3, #183	; 0xb7
 1002b44:	4a09      	ldr	r2, [pc, #36]	; (1002b6c <sys_heap_free+0x74>)
 1002b46:	490d      	ldr	r1, [pc, #52]	; (1002b7c <sys_heap_free+0x84>)
 1002b48:	480a      	ldr	r0, [pc, #40]	; (1002b74 <sys_heap_free+0x7c>)
 1002b4a:	f022 f844 	bl	1024bd6 <assert_print>
 1002b4e:	4621      	mov	r1, r4
 1002b50:	480b      	ldr	r0, [pc, #44]	; (1002b80 <sys_heap_free+0x88>)
 1002b52:	f022 f840 	bl	1024bd6 <assert_print>
 1002b56:	21b7      	movs	r1, #183	; 0xb7
 1002b58:	e7e7      	b.n	1002b2a <sys_heap_free+0x32>
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
 1002b5a:	f025 0501 	bic.w	r5, r5, #1
 1002b5e:	805d      	strh	r5, [r3, #2]
#ifdef CONFIG_SYS_HEAP_LISTENER
	heap_listener_notify_free(HEAP_ID_FROM_POINTER(heap), mem,
				  chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	free_chunk(h, c);
 1002b60:	4610      	mov	r0, r2
}
 1002b62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	free_chunk(h, c);
 1002b66:	f021 bf0f 	b.w	1024988 <free_chunk>
}
 1002b6a:	bd70      	pop	{r4, r5, r6, pc}
 1002b6c:	0102bb28 	.word	0x0102bb28
 1002b70:	0102bb49 	.word	0x0102bb49
 1002b74:	0102b695 	.word	0x0102b695
 1002b78:	0102bb5a 	.word	0x0102bb5a
 1002b7c:	0102bb92 	.word	0x0102bb92
 1002b80:	0102bbb8 	.word	0x0102bbb8

01002b84 <sys_heap_aligned_alloc>:
	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
 1002b84:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1002b88:	1e4b      	subs	r3, r1, #1
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
	if (align != rew) {
 1002b8a:	400b      	ands	r3, r1
{
 1002b8c:	460f      	mov	r7, r1
 1002b8e:	4614      	mov	r4, r2
	struct z_heap *h = heap->heap;
 1002b90:	6806      	ldr	r6, [r0, #0]
	if (align != rew) {
 1002b92:	d010      	beq.n	1002bb6 <sys_heap_aligned_alloc+0x32>
	rew = align & -align;
 1002b94:	f1c1 0900 	rsb	r9, r1, #0
 1002b98:	ea09 0901 	and.w	r9, r9, r1
		align -= rew;
		gap = MIN(rew, chunk_header_bytes(h));
 1002b9c:	464a      	mov	r2, r9
			return sys_heap_alloc(heap, bytes);
		}
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
 1002b9e:	1e59      	subs	r1, r3, #1
		gap = MIN(rew, chunk_header_bytes(h));
 1002ba0:	2a04      	cmp	r2, #4
 1002ba2:	bf28      	it	cs
 1002ba4:	2204      	movcs	r2, #4
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
 1002ba6:	4219      	tst	r1, r3
 1002ba8:	d10c      	bne.n	1002bc4 <sys_heap_aligned_alloc+0x40>
 1002baa:	461f      	mov	r7, r3

	if (bytes == 0 || size_too_big(h, bytes)) {
 1002bac:	b9e4      	cbnz	r4, 1002be8 <sys_heap_aligned_alloc+0x64>
		return NULL;
 1002bae:	2500      	movs	r5, #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
 1002bb0:	4628      	mov	r0, r5
 1002bb2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
 1002bb6:	2904      	cmp	r1, #4
 1002bb8:	d813      	bhi.n	1002be2 <sys_heap_aligned_alloc+0x5e>
}
 1002bba:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
 1002bbe:	4611      	mov	r1, r2
 1002bc0:	f021 bf13 	b.w	10249ea <sys_heap_alloc>
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
 1002bc4:	492c      	ldr	r1, [pc, #176]	; (1002c78 <sys_heap_aligned_alloc+0xf4>)
 1002bc6:	f44f 73a2 	mov.w	r3, #324	; 0x144
 1002bca:	4a2c      	ldr	r2, [pc, #176]	; (1002c7c <sys_heap_aligned_alloc+0xf8>)
 1002bcc:	482c      	ldr	r0, [pc, #176]	; (1002c80 <sys_heap_aligned_alloc+0xfc>)
 1002bce:	f022 f802 	bl	1024bd6 <assert_print>
 1002bd2:	482c      	ldr	r0, [pc, #176]	; (1002c84 <sys_heap_aligned_alloc+0x100>)
 1002bd4:	f021 ffff 	bl	1024bd6 <assert_print>
 1002bd8:	f44f 71a2 	mov.w	r1, #324	; 0x144
 1002bdc:	4827      	ldr	r0, [pc, #156]	; (1002c7c <sys_heap_aligned_alloc+0xf8>)
 1002bde:	f021 fff3 	bl	1024bc8 <assert_post_action>
		rew = 0;
 1002be2:	4699      	mov	r9, r3
		gap = chunk_header_bytes(h);
 1002be4:	2204      	movs	r2, #4
 1002be6:	e7e1      	b.n	1002bac <sys_heap_aligned_alloc+0x28>
	if (bytes == 0 || size_too_big(h, bytes)) {
 1002be8:	68b3      	ldr	r3, [r6, #8]
 1002bea:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
 1002bee:	d9de      	bls.n	1002bae <sys_heap_aligned_alloc+0x2a>
	return big_heap_bytes(size) ? 8 : 4;
}

static inline chunksz_t chunksz(size_t bytes)
{
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 1002bf0:	f104 010b 	add.w	r1, r4, #11
 1002bf4:	4439      	add	r1, r7
 1002bf6:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
 1002bf8:	4630      	mov	r0, r6
 1002bfa:	08c9      	lsrs	r1, r1, #3
 1002bfc:	f021 fe5d 	bl	10248ba <alloc_chunk>
	if (c0 == 0) {
 1002c00:	4680      	mov	r8, r0
 1002c02:	2800      	cmp	r0, #0
 1002c04:	d0d3      	beq.n	1002bae <sys_heap_aligned_alloc+0x2a>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
 1002c06:	f109 0504 	add.w	r5, r9, #4
 1002c0a:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
 1002c0e:	1e7b      	subs	r3, r7, #1
 1002c10:	4435      	add	r5, r6
 1002c12:	441d      	add	r5, r3
 1002c14:	427f      	negs	r7, r7
 1002c16:	403d      	ands	r5, r7
 1002c18:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
 1002c1c:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 1002c1e:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
 1002c20:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 1002c22:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
 1002c24:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
 1002c28:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
 1002c2a:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 1002c2e:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
 1002c32:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
 1002c36:	d208      	bcs.n	1002c4a <sys_heap_aligned_alloc+0xc6>
		split_chunks(h, c0, c);
 1002c38:	4601      	mov	r1, r0
 1002c3a:	463a      	mov	r2, r7
 1002c3c:	4630      	mov	r0, r6
 1002c3e:	f021 fe89 	bl	1024954 <split_chunks>
		free_list_add(h, c0);
 1002c42:	4641      	mov	r1, r8
 1002c44:	4630      	mov	r0, r6
 1002c46:	f021 fde7 	bl	1024818 <free_list_add>
	return c + chunk_size(h, c);
 1002c4a:	4639      	mov	r1, r7
 1002c4c:	4630      	mov	r0, r6
 1002c4e:	f021 fdde 	bl	102480e <chunk_size>
 1002c52:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
 1002c54:	4284      	cmp	r4, r0
 1002c56:	d207      	bcs.n	1002c68 <sys_heap_aligned_alloc+0xe4>
		split_chunks(h, c, c_end);
 1002c58:	4630      	mov	r0, r6
 1002c5a:	4622      	mov	r2, r4
 1002c5c:	f021 fe7a 	bl	1024954 <split_chunks>
		free_list_add(h, c_end);
 1002c60:	4621      	mov	r1, r4
 1002c62:	4630      	mov	r0, r6
 1002c64:	f021 fdd8 	bl	1024818 <free_list_add>
	void *cmem = &buf[c];
 1002c68:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 1002c6c:	8873      	ldrh	r3, [r6, #2]
 1002c6e:	f043 0301 	orr.w	r3, r3, #1
 1002c72:	8073      	strh	r3, [r6, #2]
 1002c74:	e79c      	b.n	1002bb0 <sys_heap_aligned_alloc+0x2c>
 1002c76:	bf00      	nop
 1002c78:	0102bbf4 	.word	0x0102bbf4
 1002c7c:	0102bb28 	.word	0x0102bb28
 1002c80:	0102b695 	.word	0x0102b695
 1002c84:	0102bc0f 	.word	0x0102bc0f

01002c88 <sys_heap_init>:
{
	IF_ENABLED(CONFIG_MSAN, (__sanitizer_dtor_callback(mem, bytes)));

	if (IS_ENABLED(CONFIG_SYS_HEAP_SMALL_ONLY)) {
		/* Must fit in a 15 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffU, "heap size is too big");
 1002c88:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
{
 1002c8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1002c8e:	4604      	mov	r4, r0
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffU, "heap size is too big");
 1002c90:	d30e      	bcc.n	1002cb0 <sys_heap_init+0x28>
 1002c92:	493a      	ldr	r1, [pc, #232]	; (1002d7c <sys_heap_init+0xf4>)
 1002c94:	f240 13eb 	movw	r3, #491	; 0x1eb
 1002c98:	4a39      	ldr	r2, [pc, #228]	; (1002d80 <sys_heap_init+0xf8>)
 1002c9a:	483a      	ldr	r0, [pc, #232]	; (1002d84 <sys_heap_init+0xfc>)
 1002c9c:	f021 ff9b 	bl	1024bd6 <assert_print>
 1002ca0:	4839      	ldr	r0, [pc, #228]	; (1002d88 <sys_heap_init+0x100>)
 1002ca2:	f021 ff98 	bl	1024bd6 <assert_print>
 1002ca6:	f240 11eb 	movw	r1, #491	; 0x1eb
		/* Must fit in a 31 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
 1002caa:	4835      	ldr	r0, [pc, #212]	; (1002d80 <sys_heap_init+0xf8>)
 1002cac:	f021 ff8c 	bl	1024bc8 <assert_post_action>
 1002cb0:	2a04      	cmp	r2, #4
 1002cb2:	d80c      	bhi.n	1002cce <sys_heap_init+0x46>
 1002cb4:	4935      	ldr	r1, [pc, #212]	; (1002d8c <sys_heap_init+0x104>)
 1002cb6:	f44f 73f9 	mov.w	r3, #498	; 0x1f2
 1002cba:	4a31      	ldr	r2, [pc, #196]	; (1002d80 <sys_heap_init+0xf8>)
 1002cbc:	4831      	ldr	r0, [pc, #196]	; (1002d84 <sys_heap_init+0xfc>)
 1002cbe:	f021 ff8a 	bl	1024bd6 <assert_print>
 1002cc2:	4833      	ldr	r0, [pc, #204]	; (1002d90 <sys_heap_init+0x108>)
 1002cc4:	f021 ff87 	bl	1024bd6 <assert_print>
 1002cc8:	f44f 71f9 	mov.w	r1, #498	; 0x1f2
 1002ccc:	e7ed      	b.n	1002caa <sys_heap_init+0x22>
	bytes -= heap_footer_bytes(bytes);
 1002cce:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
 1002cd0:	1dc8      	adds	r0, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 1002cd2:	440a      	add	r2, r1
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
 1002cd4:	f020 0007 	bic.w	r0, r0, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 1002cd8:	f022 0207 	bic.w	r2, r2, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
 1002cdc:	1a12      	subs	r2, r2, r0

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");
 1002cde:	2a17      	cmp	r2, #23
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
 1002ce0:	ea4f 03d2 	mov.w	r3, r2, lsr #3
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");
 1002ce4:	d80c      	bhi.n	1002d00 <sys_heap_init+0x78>
 1002ce6:	492b      	ldr	r1, [pc, #172]	; (1002d94 <sys_heap_init+0x10c>)
 1002ce8:	f240 13fb 	movw	r3, #507	; 0x1fb
 1002cec:	4a24      	ldr	r2, [pc, #144]	; (1002d80 <sys_heap_init+0xf8>)
 1002cee:	4825      	ldr	r0, [pc, #148]	; (1002d84 <sys_heap_init+0xfc>)
 1002cf0:	f021 ff71 	bl	1024bd6 <assert_print>
 1002cf4:	4826      	ldr	r0, [pc, #152]	; (1002d90 <sys_heap_init+0x108>)
 1002cf6:	f021 ff6e 	bl	1024bd6 <assert_print>
 1002cfa:	f240 11fb 	movw	r1, #507	; 0x1fb
 1002cfe:	e7d4      	b.n	1002caa <sys_heap_init+0x22>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
 1002d00:	fab3 f183 	clz	r1, r3

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
 1002d04:	6020      	str	r0, [r4, #0]
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
 1002d06:	2400      	movs	r4, #0
	h->free_bytes = 0;
	h->allocated_bytes = 0;
	h->max_allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
 1002d08:	f1c1 0620 	rsb	r6, r1, #32
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
 1002d0c:	f1c1 0124 	rsb	r1, r1, #36	; 0x24
 1002d10:	0089      	lsls	r1, r1, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 1002d12:	3107      	adds	r1, #7
 1002d14:	08c9      	lsrs	r1, r1, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");
 1002d16:	1c4d      	adds	r5, r1, #1
 1002d18:	429d      	cmp	r5, r3
	h->end_chunk = heap_sz;
 1002d1a:	6083      	str	r3, [r0, #8]
	h->avail_buckets = 0;
 1002d1c:	60c4      	str	r4, [r0, #12]
	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");
 1002d1e:	d90c      	bls.n	1002d3a <sys_heap_init+0xb2>
 1002d20:	491d      	ldr	r1, [pc, #116]	; (1002d98 <sys_heap_init+0x110>)
 1002d22:	f44f 7303 	mov.w	r3, #524	; 0x20c
 1002d26:	4a16      	ldr	r2, [pc, #88]	; (1002d80 <sys_heap_init+0xf8>)
 1002d28:	4816      	ldr	r0, [pc, #88]	; (1002d84 <sys_heap_init+0xfc>)
 1002d2a:	f021 ff54 	bl	1024bd6 <assert_print>
 1002d2e:	4818      	ldr	r0, [pc, #96]	; (1002d90 <sys_heap_init+0x108>)
 1002d30:	f021 ff51 	bl	1024bd6 <assert_print>
 1002d34:	f44f 7103 	mov.w	r1, #524	; 0x20c
 1002d38:	e7b7      	b.n	1002caa <sys_heap_init+0x22>
 1002d3a:	f100 050c 	add.w	r5, r0, #12
 1002d3e:	eb05 0686 	add.w	r6, r5, r6, lsl #2

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
 1002d42:	f845 4f04 	str.w	r4, [r5, #4]!
	for (int i = 0; i < nb_buckets; i++) {
 1002d46:	42b5      	cmp	r5, r6
 1002d48:	d1fb      	bne.n	1002d42 <sys_heap_init+0xba>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
 1002d4a:	004d      	lsls	r5, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 1002d4c:	f045 0501 	orr.w	r5, r5, #1
 1002d50:	8045      	strh	r5, [r0, #2]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
 1002d52:	1a5d      	subs	r5, r3, r1
		((uint16_t *)cmem)[f] = val;
 1002d54:	eb00 06c1 	add.w	r6, r0, r1, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
 1002d58:	006f      	lsls	r7, r5, #1
		((uint16_t *)cmem)[f] = val;
 1002d5a:	8004      	strh	r4, [r0, #0]
 1002d5c:	8077      	strh	r7, [r6, #2]
 1002d5e:	1886      	adds	r6, r0, r2
 1002d60:	f820 1031 	strh.w	r1, [r0, r1, lsl #3]
	void *cmem = &buf[c];
 1002d64:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
		((uint16_t *)cmem)[f] = val;
 1002d68:	8074      	strh	r4, [r6, #2]
 1002d6a:	5285      	strh	r5, [r0, r2]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 1002d6c:	885a      	ldrh	r2, [r3, #2]
 1002d6e:	f042 0201 	orr.w	r2, r2, #1
 1002d72:	805a      	strh	r2, [r3, #2]
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
}
 1002d74:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free_list_add(h, chunk0_size);
 1002d78:	f021 bd4e 	b.w	1024818 <free_list_add>
 1002d7c:	0102bc2c 	.word	0x0102bc2c
 1002d80:	0102bb28 	.word	0x0102bb28
 1002d84:	0102b695 	.word	0x0102b695
 1002d88:	0102bc42 	.word	0x0102bc42
 1002d8c:	0102bc59 	.word	0x0102bc59
 1002d90:	0102bc7a 	.word	0x0102bc7a
 1002d94:	0102bc93 	.word	0x0102bc93
 1002d98:	0102bcbc 	.word	0x0102bcbc

01002d9c <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
 1002d9c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1002da0:	4604      	mov	r4, r0
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1002da2:	8ba3      	ldrh	r3, [r4, #28]
{
 1002da4:	4608      	mov	r0, r1
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
 1002da6:	0719      	lsls	r1, r3, #28
{
 1002da8:	4615      	mov	r5, r2
	if (processing) {
 1002daa:	d412      	bmi.n	1002dd2 <process_event+0x36>

	sys_slist_init(&clients);
	do {
		onoff_transition_fn transit = NULL;

		if (evt == EVT_RECHECK) {
 1002dac:	2802      	cmp	r0, #2
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1002dae:	f003 0107 	and.w	r1, r3, #7
		if (evt == EVT_RECHECK) {
 1002db2:	d164      	bne.n	1002e7e <process_event+0xe2>
			evt = process_recheck(mgr);
 1002db4:	4620      	mov	r0, r4
 1002db6:	f021 fe41 	bl	1024a3c <process_recheck>
		}

		if (evt == EVT_NOP) {
 1002dba:	b188      	cbz	r0, 1002de0 <process_event+0x44>
			break;
		}

		res = 0;
		if (evt == EVT_COMPLETE) {
 1002dbc:	3801      	subs	r0, #1
 1002dbe:	2804      	cmp	r0, #4
 1002dc0:	f200 8134 	bhi.w	100302c <process_event+0x290>
 1002dc4:	e8df f010 	tbh	[pc, r0, lsl #1]
 1002dc8:	0132005b 	.word	0x0132005b
 1002dcc:	00d10081 	.word	0x00d10081
 1002dd0:	0101      	.short	0x0101
		if (evt == EVT_COMPLETE) {
 1002dd2:	2801      	cmp	r0, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
 1002dd4:	bf0c      	ite	eq
 1002dd6:	f043 0110 	orreq.w	r1, r3, #16
			mgr->flags |= ONOFF_FLAG_RECHECK;
 1002dda:	f043 0120 	orrne.w	r1, r3, #32
 1002dde:	83a1      	strh	r1, [r4, #28]

		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
 1002de0:	3414      	adds	r4, #20
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1002de2:	4620      	mov	r0, r4
 1002de4:	f01e f982 	bl	10210ec <z_spin_unlock_valid>
 1002de8:	2800      	cmp	r0, #0
 1002dea:	f040 819b 	bne.w	1003124 <process_event+0x388>
 1002dee:	4998      	ldr	r1, [pc, #608]	; (1003050 <process_event+0x2b4>)
 1002df0:	23c2      	movs	r3, #194	; 0xc2
 1002df2:	4a98      	ldr	r2, [pc, #608]	; (1003054 <process_event+0x2b8>)
 1002df4:	4898      	ldr	r0, [pc, #608]	; (1003058 <process_event+0x2bc>)
 1002df6:	f021 feee 	bl	1024bd6 <assert_print>
 1002dfa:	4621      	mov	r1, r4
 1002dfc:	e0b0      	b.n	1002f60 <process_event+0x1c4>
 1002dfe:	f003 0207 	and.w	r2, r3, #7
		   || (state == ONOFF_STATE_RESETTING)) {
 1002e02:	1f50      	subs	r0, r2, #5
	} else if ((state == ONOFF_STATE_TO_ON)
 1002e04:	2801      	cmp	r0, #1
 1002e06:	d81e      	bhi.n	1002e46 <process_event+0xaa>
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
 1002e08:	2000      	movs	r0, #0
		if (state == ONOFF_STATE_TO_ON) {
 1002e0a:	2a06      	cmp	r2, #6
		*clients = mgr->clients;
 1002e0c:	6827      	ldr	r7, [r4, #0]
	list->tail = NULL;
 1002e0e:	e9c4 0000 	strd	r0, r0, [r4]
		if (state == ONOFF_STATE_TO_ON) {
 1002e12:	d114      	bne.n	1002e3e <process_event+0xa2>
		*clients = mgr->clients;
 1002e14:	463a      	mov	r2, r7
 1002e16:	e003      	b.n	1002e20 <process_event+0x84>
				mgr->refs += 1U;
 1002e18:	8be0      	ldrh	r0, [r4, #30]
 1002e1a:	3001      	adds	r0, #1
 1002e1c:	83e0      	strh	r0, [r4, #30]

#define SYS_SLIST_STATIC_INIT(ptr_to_list) {NULL, NULL}

static inline sys_snode_t *z_snode_next_peek(sys_snode_t *node)
{
	return node->next;
 1002e1e:	6812      	ldr	r2, [r2, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
 1002e20:	2a00      	cmp	r2, #0
 1002e22:	d1f9      	bne.n	1002e18 <process_event+0x7c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1002e24:	f023 0307 	bic.w	r3, r3, #7
 1002e28:	f043 0202 	orr.w	r2, r3, #2
		if (process_recheck(mgr) != EVT_NOP) {
 1002e2c:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
 1002e2e:	83a2      	strh	r2, [r4, #28]
		if (process_recheck(mgr) != EVT_NOP) {
 1002e30:	f021 fe04 	bl	1024a3c <process_recheck>
 1002e34:	b390      	cbz	r0, 1002e9c <process_event+0x100>
			mgr->flags |= ONOFF_FLAG_RECHECK;
 1002e36:	f042 0220 	orr.w	r2, r2, #32
 1002e3a:	83a2      	strh	r2, [r4, #28]
 1002e3c:	e02e      	b.n	1002e9c <process_event+0x100>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1002e3e:	f023 0307 	bic.w	r3, r3, #7
 1002e42:	b29a      	uxth	r2, r3
}
 1002e44:	e7f2      	b.n	1002e2c <process_event+0x90>
	} else if (state == ONOFF_STATE_TO_OFF) {
 1002e46:	2a04      	cmp	r2, #4
 1002e48:	d133      	bne.n	1002eb2 <process_event+0x116>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1002e4a:	f023 0307 	bic.w	r3, r3, #7
 1002e4e:	b29a      	uxth	r2, r3
		if (process_recheck(mgr) != EVT_NOP) {
 1002e50:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
 1002e52:	83a2      	strh	r2, [r4, #28]
		if (process_recheck(mgr) != EVT_NOP) {
 1002e54:	f021 fdf2 	bl	1024a3c <process_recheck>
 1002e58:	b110      	cbz	r0, 1002e60 <process_event+0xc4>
			mgr->flags |= ONOFF_FLAG_RECHECK;
 1002e5a:	f042 0220 	orr.w	r2, r2, #32
 1002e5e:	83a2      	strh	r2, [r4, #28]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1002e60:	8ba3      	ldrh	r3, [r4, #28]
 1002e62:	f003 0907 	and.w	r9, r3, #7
				   && !sys_slist_is_empty(&mgr->monitors);
 1002e66:	4589      	cmp	r9, r1
 1002e68:	f040 80ea 	bne.w	1003040 <process_event+0x2a4>
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
 1002e6c:	8ba1      	ldrh	r1, [r4, #28]
 1002e6e:	06ca      	lsls	r2, r1, #27
 1002e70:	f140 814f 	bpl.w	1003112 <process_event+0x376>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
 1002e74:	f021 0310 	bic.w	r3, r1, #16
 1002e78:	83a3      	strh	r3, [r4, #28]
		state = mgr->flags & ONOFF_STATE_MASK;
 1002e7a:	f001 0107 	and.w	r1, r1, #7
			res = mgr->last_res;
 1002e7e:	f8d4 8018 	ldr.w	r8, [r4, #24]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1002e82:	8ba3      	ldrh	r3, [r4, #28]
	if (res < 0) {
 1002e84:	f1b8 0f00 	cmp.w	r8, #0
 1002e88:	dab9      	bge.n	1002dfe <process_event+0x62>
	list->head = NULL;
 1002e8a:	2200      	movs	r2, #0
		*clients = mgr->clients;
 1002e8c:	6827      	ldr	r7, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1002e8e:	f023 0307 	bic.w	r3, r3, #7
	list->tail = NULL;
 1002e92:	e9c4 2200 	strd	r2, r2, [r4]
 1002e96:	f043 0301 	orr.w	r3, r3, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
 1002e9a:	83a3      	strh	r3, [r4, #28]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1002e9c:	8ba3      	ldrh	r3, [r4, #28]
 1002e9e:	f003 0907 	and.w	r9, r3, #7
				   && !sys_slist_is_empty(&mgr->monitors);
 1002ea2:	4589      	cmp	r9, r1
 1002ea4:	f040 80cd 	bne.w	1003042 <process_event+0x2a6>
		    || !sys_slist_is_empty(&clients)
 1002ea8:	2f00      	cmp	r7, #0
 1002eaa:	d0df      	beq.n	1002e6c <process_event+0xd0>
 1002eac:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1002eae:	46b2      	mov	sl, r6
 1002eb0:	e044      	b.n	1002f3c <process_event+0x1a0>
		__ASSERT_NO_MSG(false);
 1002eb2:	496a      	ldr	r1, [pc, #424]	; (100305c <process_event+0x2c0>)
 1002eb4:	f240 131b 	movw	r3, #283	; 0x11b
 1002eb8:	4a69      	ldr	r2, [pc, #420]	; (1003060 <process_event+0x2c4>)
 1002eba:	4867      	ldr	r0, [pc, #412]	; (1003058 <process_event+0x2bc>)
 1002ebc:	f021 fe8b 	bl	1024bd6 <assert_print>
 1002ec0:	f240 111b 	movw	r1, #283	; 0x11b
			__ASSERT_NO_MSG(state == ONOFF_STATE_OFF);
 1002ec4:	4866      	ldr	r0, [pc, #408]	; (1003060 <process_event+0x2c4>)
 1002ec6:	f021 fe7f 	bl	1024bc8 <assert_post_action>
 1002eca:	b149      	cbz	r1, 1002ee0 <process_event+0x144>
 1002ecc:	4965      	ldr	r1, [pc, #404]	; (1003064 <process_event+0x2c8>)
 1002ece:	f44f 73ab 	mov.w	r3, #342	; 0x156
 1002ed2:	4a63      	ldr	r2, [pc, #396]	; (1003060 <process_event+0x2c4>)
 1002ed4:	4860      	ldr	r0, [pc, #384]	; (1003058 <process_event+0x2bc>)
 1002ed6:	f021 fe7e 	bl	1024bd6 <assert_print>
 1002eda:	f44f 71ab 	mov.w	r1, #342	; 0x156
 1002ede:	e7f1      	b.n	1002ec4 <process_event+0x128>
			__ASSERT_NO_MSG(!sys_slist_is_empty(&mgr->clients));
 1002ee0:	6823      	ldr	r3, [r4, #0]
 1002ee2:	b94b      	cbnz	r3, 1002ef8 <process_event+0x15c>
 1002ee4:	4960      	ldr	r1, [pc, #384]	; (1003068 <process_event+0x2cc>)
 1002ee6:	f240 1357 	movw	r3, #343	; 0x157
 1002eea:	4a5d      	ldr	r2, [pc, #372]	; (1003060 <process_event+0x2c4>)
 1002eec:	485a      	ldr	r0, [pc, #360]	; (1003058 <process_event+0x2bc>)
 1002eee:	f021 fe72 	bl	1024bd6 <assert_print>
 1002ef2:	f240 1157 	movw	r1, #343	; 0x157
 1002ef6:	e7e5      	b.n	1002ec4 <process_event+0x128>
			transit = mgr->transitions->start;
 1002ef8:	6923      	ldr	r3, [r4, #16]
 1002efa:	681e      	ldr	r6, [r3, #0]
			__ASSERT_NO_MSG(transit != NULL);
 1002efc:	b94e      	cbnz	r6, 1002f12 <process_event+0x176>
 1002efe:	495b      	ldr	r1, [pc, #364]	; (100306c <process_event+0x2d0>)
 1002f00:	f44f 73ad 	mov.w	r3, #346	; 0x15a
 1002f04:	4a56      	ldr	r2, [pc, #344]	; (1003060 <process_event+0x2c4>)
 1002f06:	4854      	ldr	r0, [pc, #336]	; (1003058 <process_event+0x2bc>)
 1002f08:	f021 fe65 	bl	1024bd6 <assert_print>
 1002f0c:	f44f 71ad 	mov.w	r1, #346	; 0x15a
 1002f10:	e7d8      	b.n	1002ec4 <process_event+0x128>
	mgr->flags = (state & ONOFF_STATE_MASK)
 1002f12:	460f      	mov	r7, r1
		res = 0;
 1002f14:	4688      	mov	r8, r1
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1002f16:	f04f 0906 	mov.w	r9, #6
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1002f1a:	8ba3      	ldrh	r3, [r4, #28]
 1002f1c:	f023 0307 	bic.w	r3, r3, #7
 1002f20:	f043 0306 	orr.w	r3, r3, #6
 1002f24:	b29b      	uxth	r3, r3
	mgr->flags = (state & ONOFF_STATE_MASK)
 1002f26:	83a3      	strh	r3, [r4, #28]
				   && !sys_slist_is_empty(&mgr->monitors);
 1002f28:	68a2      	ldr	r2, [r4, #8]
 1002f2a:	2a00      	cmp	r2, #0
 1002f2c:	f040 808b 	bne.w	1003046 <process_event+0x2aa>
		    || !sys_slist_is_empty(&clients)
 1002f30:	2f00      	cmp	r7, #0
 1002f32:	f040 808b 	bne.w	100304c <process_event+0x2b0>
		    || (transit != NULL)) {
 1002f36:	2e00      	cmp	r6, #0
 1002f38:	d098      	beq.n	1002e6c <process_event+0xd0>
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1002f3a:	46ba      	mov	sl, r7
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
 1002f3c:	f043 0308 	orr.w	r3, r3, #8
			k_spin_unlock(&mgr->lock, key);
 1002f40:	f104 0b14 	add.w	fp, r4, #20
 1002f44:	4658      	mov	r0, fp
			mgr->flags = flags;
 1002f46:	83a3      	strh	r3, [r4, #28]
 1002f48:	f01e f8d0 	bl	10210ec <z_spin_unlock_valid>
 1002f4c:	2800      	cmp	r0, #0
 1002f4e:	f040 8097 	bne.w	1003080 <process_event+0x2e4>
 1002f52:	493f      	ldr	r1, [pc, #252]	; (1003050 <process_event+0x2b4>)
 1002f54:	23c2      	movs	r3, #194	; 0xc2
 1002f56:	4a3f      	ldr	r2, [pc, #252]	; (1003054 <process_event+0x2b8>)
 1002f58:	483f      	ldr	r0, [pc, #252]	; (1003058 <process_event+0x2bc>)
 1002f5a:	f021 fe3c 	bl	1024bd6 <assert_print>
 1002f5e:	4659      	mov	r1, fp
 1002f60:	4843      	ldr	r0, [pc, #268]	; (1003070 <process_event+0x2d4>)
 1002f62:	f021 fe38 	bl	1024bd6 <assert_print>
 1002f66:	21c2      	movs	r1, #194	; 0xc2
 1002f68:	e0ae      	b.n	10030c8 <process_event+0x32c>
			__ASSERT_NO_MSG(state == ONOFF_STATE_ON);
 1002f6a:	2902      	cmp	r1, #2
 1002f6c:	d009      	beq.n	1002f82 <process_event+0x1e6>
 1002f6e:	4941      	ldr	r1, [pc, #260]	; (1003074 <process_event+0x2d8>)
 1002f70:	f240 135d 	movw	r3, #349	; 0x15d
 1002f74:	4a3a      	ldr	r2, [pc, #232]	; (1003060 <process_event+0x2c4>)
 1002f76:	4838      	ldr	r0, [pc, #224]	; (1003058 <process_event+0x2bc>)
 1002f78:	f021 fe2d 	bl	1024bd6 <assert_print>
 1002f7c:	f240 115d 	movw	r1, #349	; 0x15d
 1002f80:	e7a0      	b.n	1002ec4 <process_event+0x128>
			__ASSERT_NO_MSG(mgr->refs == 0);
 1002f82:	8be7      	ldrh	r7, [r4, #30]
 1002f84:	b14f      	cbz	r7, 1002f9a <process_event+0x1fe>
 1002f86:	493c      	ldr	r1, [pc, #240]	; (1003078 <process_event+0x2dc>)
 1002f88:	f44f 73af 	mov.w	r3, #350	; 0x15e
 1002f8c:	4a34      	ldr	r2, [pc, #208]	; (1003060 <process_event+0x2c4>)
 1002f8e:	4832      	ldr	r0, [pc, #200]	; (1003058 <process_event+0x2bc>)
 1002f90:	f021 fe21 	bl	1024bd6 <assert_print>
 1002f94:	f44f 71af 	mov.w	r1, #350	; 0x15e
 1002f98:	e794      	b.n	1002ec4 <process_event+0x128>
			transit = mgr->transitions->stop;
 1002f9a:	6923      	ldr	r3, [r4, #16]
 1002f9c:	685e      	ldr	r6, [r3, #4]
			__ASSERT_NO_MSG(transit != NULL);
 1002f9e:	b94e      	cbnz	r6, 1002fb4 <process_event+0x218>
 1002fa0:	4932      	ldr	r1, [pc, #200]	; (100306c <process_event+0x2d0>)
 1002fa2:	f240 1361 	movw	r3, #353	; 0x161
 1002fa6:	4a2e      	ldr	r2, [pc, #184]	; (1003060 <process_event+0x2c4>)
 1002fa8:	482b      	ldr	r0, [pc, #172]	; (1003058 <process_event+0x2bc>)
 1002faa:	f021 fe14 	bl	1024bd6 <assert_print>
 1002fae:	f240 1161 	movw	r1, #353	; 0x161
 1002fb2:	e787      	b.n	1002ec4 <process_event+0x128>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1002fb4:	8ba3      	ldrh	r3, [r4, #28]
		res = 0;
 1002fb6:	46b8      	mov	r8, r7
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1002fb8:	f023 0307 	bic.w	r3, r3, #7
 1002fbc:	f043 0304 	orr.w	r3, r3, #4
 1002fc0:	b29b      	uxth	r3, r3
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1002fc2:	f04f 0904 	mov.w	r9, #4
	mgr->flags = (state & ONOFF_STATE_MASK)
 1002fc6:	83a3      	strh	r3, [r4, #28]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1002fc8:	e7ae      	b.n	1002f28 <process_event+0x18c>
			__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
 1002fca:	2901      	cmp	r1, #1
 1002fcc:	d009      	beq.n	1002fe2 <process_event+0x246>
 1002fce:	492b      	ldr	r1, [pc, #172]	; (100307c <process_event+0x2e0>)
 1002fd0:	f44f 73b2 	mov.w	r3, #356	; 0x164
 1002fd4:	4a22      	ldr	r2, [pc, #136]	; (1003060 <process_event+0x2c4>)
 1002fd6:	4820      	ldr	r0, [pc, #128]	; (1003058 <process_event+0x2bc>)
 1002fd8:	f021 fdfd 	bl	1024bd6 <assert_print>
 1002fdc:	f44f 71b2 	mov.w	r1, #356	; 0x164
 1002fe0:	e770      	b.n	1002ec4 <process_event+0x128>
			__ASSERT_NO_MSG(!sys_slist_is_empty(&mgr->clients));
 1002fe2:	6823      	ldr	r3, [r4, #0]
 1002fe4:	b94b      	cbnz	r3, 1002ffa <process_event+0x25e>
 1002fe6:	4920      	ldr	r1, [pc, #128]	; (1003068 <process_event+0x2cc>)
 1002fe8:	f240 1365 	movw	r3, #357	; 0x165
 1002fec:	4a1c      	ldr	r2, [pc, #112]	; (1003060 <process_event+0x2c4>)
 1002fee:	481a      	ldr	r0, [pc, #104]	; (1003058 <process_event+0x2bc>)
 1002ff0:	f021 fdf1 	bl	1024bd6 <assert_print>
 1002ff4:	f240 1165 	movw	r1, #357	; 0x165
 1002ff8:	e764      	b.n	1002ec4 <process_event+0x128>
			transit = mgr->transitions->reset;
 1002ffa:	6923      	ldr	r3, [r4, #16]
 1002ffc:	689e      	ldr	r6, [r3, #8]
			__ASSERT_NO_MSG(transit != NULL);
 1002ffe:	b94e      	cbnz	r6, 1003014 <process_event+0x278>
 1003000:	491a      	ldr	r1, [pc, #104]	; (100306c <process_event+0x2d0>)
 1003002:	f44f 73b4 	mov.w	r3, #360	; 0x168
 1003006:	4a16      	ldr	r2, [pc, #88]	; (1003060 <process_event+0x2c4>)
 1003008:	4813      	ldr	r0, [pc, #76]	; (1003058 <process_event+0x2bc>)
 100300a:	f021 fde4 	bl	1024bd6 <assert_print>
 100300e:	f44f 71b4 	mov.w	r1, #360	; 0x168
 1003012:	e757      	b.n	1002ec4 <process_event+0x128>
	mgr->flags = (state & ONOFF_STATE_MASK)
 1003014:	2700      	movs	r7, #0
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1003016:	8ba3      	ldrh	r3, [r4, #28]
		res = 0;
 1003018:	46b8      	mov	r8, r7
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 100301a:	f023 0307 	bic.w	r3, r3, #7
 100301e:	f043 0305 	orr.w	r3, r3, #5
 1003022:	b29b      	uxth	r3, r3
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1003024:	f04f 0905 	mov.w	r9, #5
	mgr->flags = (state & ONOFF_STATE_MASK)
 1003028:	83a3      	strh	r3, [r4, #28]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 100302a:	e77d      	b.n	1002f28 <process_event+0x18c>
			__ASSERT_NO_MSG(false);
 100302c:	490b      	ldr	r1, [pc, #44]	; (100305c <process_event+0x2c0>)
 100302e:	f240 136b 	movw	r3, #363	; 0x16b
 1003032:	4a0b      	ldr	r2, [pc, #44]	; (1003060 <process_event+0x2c4>)
 1003034:	4808      	ldr	r0, [pc, #32]	; (1003058 <process_event+0x2bc>)
 1003036:	f021 fdce 	bl	1024bd6 <assert_print>
 100303a:	f240 116b 	movw	r1, #363	; 0x16b
 100303e:	e741      	b.n	1002ec4 <process_event+0x128>
				   && !sys_slist_is_empty(&mgr->monitors);
 1003040:	2700      	movs	r7, #0
 1003042:	2600      	movs	r6, #0
 1003044:	e770      	b.n	1002f28 <process_event+0x18c>
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1003046:	f04f 0a01 	mov.w	sl, #1
 100304a:	e777      	b.n	1002f3c <process_event+0x1a0>
 100304c:	4692      	mov	sl, r2
 100304e:	e775      	b.n	1002f3c <process_event+0x1a0>
 1003050:	0102bdb7 	.word	0x0102bdb7
 1003054:	0102bd8a 	.word	0x0102bd8a
 1003058:	0102b695 	.word	0x0102b695
 100305c:	0102ff6e 	.word	0x0102ff6e
 1003060:	0102bce7 	.word	0x0102bce7
 1003064:	0102bd09 	.word	0x0102bd09
 1003068:	0102bd15 	.word	0x0102bd15
 100306c:	0102bd38 	.word	0x0102bd38
 1003070:	0102bdce 	.word	0x0102bdce
 1003074:	0102bd4f 	.word	0x0102bd4f
 1003078:	0102bd65 	.word	0x0102bd65
 100307c:	0102bd74 	.word	0x0102bd74
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
 1003080:	f385 8811 	msr	BASEPRI, r5
 1003084:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
 1003088:	f1ba 0f00 	cmp.w	sl, #0
 100308c:	d11e      	bne.n	10030cc <process_event+0x330>
	while (!sys_slist_is_empty(list)) {
 100308e:	2f00      	cmp	r7, #0
 1003090:	d12f      	bne.n	10030f2 <process_event+0x356>
			if (transit != NULL) {
 1003092:	b116      	cbz	r6, 100309a <process_event+0x2fe>
				transit(mgr, transition_complete);
 1003094:	4620      	mov	r0, r4
 1003096:	4926      	ldr	r1, [pc, #152]	; (1003130 <process_event+0x394>)
 1003098:	47b0      	blx	r6
	__asm__ volatile(
 100309a:	f04f 0320 	mov.w	r3, #32
 100309e:	f3ef 8511 	mrs	r5, BASEPRI
 10030a2:	f383 8812 	msr	BASEPRI_MAX, r3
 10030a6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10030aa:	4658      	mov	r0, fp
 10030ac:	f01e f810 	bl	10210d0 <z_spin_lock_valid>
 10030b0:	bb38      	cbnz	r0, 1003102 <process_event+0x366>
 10030b2:	2394      	movs	r3, #148	; 0x94
 10030b4:	4a1f      	ldr	r2, [pc, #124]	; (1003134 <process_event+0x398>)
 10030b6:	4920      	ldr	r1, [pc, #128]	; (1003138 <process_event+0x39c>)
 10030b8:	4820      	ldr	r0, [pc, #128]	; (100313c <process_event+0x3a0>)
 10030ba:	f021 fd8c 	bl	1024bd6 <assert_print>
 10030be:	4659      	mov	r1, fp
 10030c0:	481f      	ldr	r0, [pc, #124]	; (1003140 <process_event+0x3a4>)
 10030c2:	f021 fd88 	bl	1024bd6 <assert_print>
 10030c6:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10030c8:	481a      	ldr	r0, [pc, #104]	; (1003134 <process_event+0x398>)
 10030ca:	e6fc      	b.n	1002ec6 <process_event+0x12a>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
 10030cc:	68a1      	ldr	r1, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
 10030ce:	2900      	cmp	r1, #0
 10030d0:	d0dd      	beq.n	100308e <process_event+0x2f2>
	return node->next;
 10030d2:	680d      	ldr	r5, [r1, #0]
 10030d4:	2900      	cmp	r1, #0
 10030d6:	d0da      	beq.n	100308e <process_event+0x2f2>
		mon->callback(mgr, mon, state, res);
 10030d8:	4643      	mov	r3, r8
 10030da:	464a      	mov	r2, r9
 10030dc:	4620      	mov	r0, r4
 10030de:	f8d1 a004 	ldr.w	sl, [r1, #4]
 10030e2:	47d0      	blx	sl
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
 10030e4:	b11d      	cbz	r5, 10030ee <process_event+0x352>
 10030e6:	682b      	ldr	r3, [r5, #0]
 10030e8:	4629      	mov	r1, r5
 10030ea:	461d      	mov	r5, r3
 10030ec:	e7f2      	b.n	10030d4 <process_event+0x338>
 10030ee:	462b      	mov	r3, r5
 10030f0:	e7fa      	b.n	10030e8 <process_event+0x34c>
 10030f2:	4639      	mov	r1, r7
		notify_one(mgr, cli, state, res);
 10030f4:	4643      	mov	r3, r8
 10030f6:	464a      	mov	r2, r9
 10030f8:	4620      	mov	r0, r4
 10030fa:	683f      	ldr	r7, [r7, #0]
 10030fc:	f021 fcca 	bl	1024a94 <notify_one>
 1003100:	e7c5      	b.n	100308e <process_event+0x2f2>
	z_spin_lock_set_owner(l);
 1003102:	4658      	mov	r0, fp
 1003104:	f01e f800 	bl	1021108 <z_spin_lock_set_owner>
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
 1003108:	8ba3      	ldrh	r3, [r4, #28]
 100310a:	f023 0308 	bic.w	r3, r3, #8
 100310e:	83a3      	strh	r3, [r4, #28]
 1003110:	e6ac      	b.n	1002e6c <process_event+0xd0>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
 1003112:	068b      	lsls	r3, r1, #26
 1003114:	f57f ae64 	bpl.w	1002de0 <process_event+0x44>
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
 1003118:	f021 0320 	bic.w	r3, r1, #32
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
 100311c:	83a3      	strh	r3, [r4, #28]
		state = mgr->flags & ONOFF_STATE_MASK;
 100311e:	f001 0107 	and.w	r1, r1, #7
		if (evt == EVT_RECHECK) {
 1003122:	e647      	b.n	1002db4 <process_event+0x18>
	__asm__ volatile(
 1003124:	f385 8811 	msr	BASEPRI, r5
 1003128:	f3bf 8f6f 	isb	sy
}
 100312c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1003130:	01003145 	.word	0x01003145
 1003134:	0102bd8a 	.word	0x0102bd8a
 1003138:	0102bde3 	.word	0x0102bde3
 100313c:	0102b695 	.word	0x0102b695
 1003140:	0102bdf8 	.word	0x0102bdf8

01003144 <transition_complete>:
{
 1003144:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1003146:	4604      	mov	r4, r0
 1003148:	460d      	mov	r5, r1
	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
 100314a:	f100 0614 	add.w	r6, r0, #20
	__asm__ volatile(
 100314e:	f04f 0320 	mov.w	r3, #32
 1003152:	f3ef 8711 	mrs	r7, BASEPRI
 1003156:	f383 8812 	msr	BASEPRI_MAX, r3
 100315a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 100315e:	4630      	mov	r0, r6
 1003160:	f01d ffb6 	bl	10210d0 <z_spin_lock_valid>
 1003164:	b968      	cbnz	r0, 1003182 <transition_complete+0x3e>
 1003166:	2394      	movs	r3, #148	; 0x94
 1003168:	4a0b      	ldr	r2, [pc, #44]	; (1003198 <transition_complete+0x54>)
 100316a:	490c      	ldr	r1, [pc, #48]	; (100319c <transition_complete+0x58>)
 100316c:	480c      	ldr	r0, [pc, #48]	; (10031a0 <transition_complete+0x5c>)
 100316e:	f021 fd32 	bl	1024bd6 <assert_print>
 1003172:	4631      	mov	r1, r6
 1003174:	480b      	ldr	r0, [pc, #44]	; (10031a4 <transition_complete+0x60>)
 1003176:	f021 fd2e 	bl	1024bd6 <assert_print>
 100317a:	2194      	movs	r1, #148	; 0x94
 100317c:	4806      	ldr	r0, [pc, #24]	; (1003198 <transition_complete+0x54>)
 100317e:	f021 fd23 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1003182:	4630      	mov	r0, r6
 1003184:	f01d ffc0 	bl	1021108 <z_spin_lock_set_owner>
	mgr->last_res = res;
 1003188:	61a5      	str	r5, [r4, #24]
	process_event(mgr, EVT_COMPLETE, key);
 100318a:	463a      	mov	r2, r7
 100318c:	4620      	mov	r0, r4
}
 100318e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	process_event(mgr, EVT_COMPLETE, key);
 1003192:	2101      	movs	r1, #1
 1003194:	f7ff be02 	b.w	1002d9c <process_event>
 1003198:	0102bd8a 	.word	0x0102bd8a
 100319c:	0102bde3 	.word	0x0102bde3
 10031a0:	0102b695 	.word	0x0102b695
 10031a4:	0102bdf8 	.word	0x0102bdf8

010031a8 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
 10031a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 10031ac:	4604      	mov	r4, r0
 10031ae:	460f      	mov	r7, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
 10031b0:	f021 fc60 	bl	1024a74 <validate_args>

	if (rv < 0) {
 10031b4:	1e05      	subs	r5, r0, #0
 10031b6:	db67      	blt.n	1003288 <onoff_request+0xe0>
		return rv;
	}

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
 10031b8:	f104 0914 	add.w	r9, r4, #20
 10031bc:	f04f 0320 	mov.w	r3, #32
 10031c0:	f3ef 8a11 	mrs	sl, BASEPRI
 10031c4:	f383 8812 	msr	BASEPRI_MAX, r3
 10031c8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10031cc:	4648      	mov	r0, r9
 10031ce:	f01d ff7f 	bl	10210d0 <z_spin_lock_valid>
 10031d2:	4680      	mov	r8, r0
 10031d4:	b960      	cbnz	r0, 10031f0 <onoff_request+0x48>
 10031d6:	2394      	movs	r3, #148	; 0x94
 10031d8:	4a37      	ldr	r2, [pc, #220]	; (10032b8 <onoff_request+0x110>)
 10031da:	4938      	ldr	r1, [pc, #224]	; (10032bc <onoff_request+0x114>)
 10031dc:	4838      	ldr	r0, [pc, #224]	; (10032c0 <onoff_request+0x118>)
 10031de:	f021 fcfa 	bl	1024bd6 <assert_print>
 10031e2:	4649      	mov	r1, r9
 10031e4:	4837      	ldr	r0, [pc, #220]	; (10032c4 <onoff_request+0x11c>)
 10031e6:	f021 fcf6 	bl	1024bd6 <assert_print>
 10031ea:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10031ec:	4832      	ldr	r0, [pc, #200]	; (10032b8 <onoff_request+0x110>)
 10031ee:	e040      	b.n	1003272 <onoff_request+0xca>
	z_spin_lock_set_owner(l);
 10031f0:	4648      	mov	r0, r9
 10031f2:	f01d ff89 	bl	1021108 <z_spin_lock_set_owner>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
 10031f6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 10031fa:	8be3      	ldrh	r3, [r4, #30]
 10031fc:	8ba6      	ldrh	r6, [r4, #28]
 10031fe:	4293      	cmp	r3, r2
 1003200:	f006 0607 	and.w	r6, r6, #7
 1003204:	d043      	beq.n	100328e <onoff_request+0xe6>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
 1003206:	2e02      	cmp	r6, #2
 1003208:	d113      	bne.n	1003232 <onoff_request+0x8a>
	rv = state;
 100320a:	4635      	mov	r5, r6
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
 100320c:	3301      	adds	r3, #1
 100320e:	83e3      	strh	r3, [r4, #30]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1003210:	4648      	mov	r0, r9
 1003212:	f01d ff6b 	bl	10210ec <z_spin_unlock_valid>
 1003216:	2800      	cmp	r0, #0
 1003218:	d13f      	bne.n	100329a <onoff_request+0xf2>
 100321a:	23c2      	movs	r3, #194	; 0xc2
 100321c:	4a26      	ldr	r2, [pc, #152]	; (10032b8 <onoff_request+0x110>)
 100321e:	492a      	ldr	r1, [pc, #168]	; (10032c8 <onoff_request+0x120>)
 1003220:	4827      	ldr	r0, [pc, #156]	; (10032c0 <onoff_request+0x118>)
 1003222:	f021 fcd8 	bl	1024bd6 <assert_print>
 1003226:	4649      	mov	r1, r9
 1003228:	4828      	ldr	r0, [pc, #160]	; (10032cc <onoff_request+0x124>)
 100322a:	f021 fcd4 	bl	1024bd6 <assert_print>
 100322e:	21c2      	movs	r1, #194	; 0xc2
 1003230:	e7dc      	b.n	10031ec <onoff_request+0x44>
	} else if ((state == ONOFF_STATE_OFF)
 1003232:	2e06      	cmp	r6, #6
 1003234:	d813      	bhi.n	100325e <onoff_request+0xb6>
 1003236:	e8df f006 	tbb	[pc, r6]
 100323a:	2d09      	.short	0x2d09
 100323c:	04091212 	.word	0x04091212
 1003240:	09          	.byte	0x09
 1003241:	00          	.byte	0x00
	if (state == ONOFF_STATE_ON) {
 1003242:	f06f 0585 	mvn.w	r5, #133	; 0x85
 1003246:	f04f 0800 	mov.w	r8, #0
 100324a:	e7e1      	b.n	1003210 <onoff_request+0x68>
	parent->next = child;
 100324c:	2300      	movs	r3, #0
 100324e:	603b      	str	r3, [r7, #0]
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
 1003250:	6863      	ldr	r3, [r4, #4]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
 1003252:	b983      	cbnz	r3, 1003276 <onoff_request+0xce>
	list->head = node;
 1003254:	e9c4 7700 	strd	r7, r7, [r4]
out:
	if (add_client) {
		sys_slist_append(&mgr->clients, &cli->node);
	}

	if (start) {
 1003258:	b186      	cbz	r6, 100327c <onoff_request+0xd4>
	rv = state;
 100325a:	4635      	mov	r5, r6
 100325c:	e7f3      	b.n	1003246 <onoff_request+0x9e>
		__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
 100325e:	491c      	ldr	r1, [pc, #112]	; (10032d0 <onoff_request+0x128>)
 1003260:	4817      	ldr	r0, [pc, #92]	; (10032c0 <onoff_request+0x118>)
 1003262:	f44f 73e4 	mov.w	r3, #456	; 0x1c8
 1003266:	4a1b      	ldr	r2, [pc, #108]	; (10032d4 <onoff_request+0x12c>)
 1003268:	f021 fcb5 	bl	1024bd6 <assert_print>
 100326c:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 1003270:	4818      	ldr	r0, [pc, #96]	; (10032d4 <onoff_request+0x12c>)
 1003272:	f021 fca9 	bl	1024bc8 <assert_post_action>
	parent->next = child;
 1003276:	601f      	str	r7, [r3, #0]
	list->tail = node;
 1003278:	6067      	str	r7, [r4, #4]
}
 100327a:	e7ed      	b.n	1003258 <onoff_request+0xb0>
		process_event(mgr, EVT_RECHECK, key);
 100327c:	4652      	mov	r2, sl
 100327e:	2102      	movs	r1, #2
 1003280:	4620      	mov	r0, r4
 1003282:	f7ff fd8b 	bl	1002d9c <process_event>
 1003286:	4635      	mov	r5, r6
			notify_one(mgr, cli, state, 0);
		}
	}

	return rv;
}
 1003288:	4628      	mov	r0, r5
 100328a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		rv = -EAGAIN;
 100328e:	f06f 050a 	mvn.w	r5, #10
 1003292:	e7d8      	b.n	1003246 <onoff_request+0x9e>
	if (state == ONOFF_STATE_ON) {
 1003294:	f06f 0504 	mvn.w	r5, #4
 1003298:	e7d5      	b.n	1003246 <onoff_request+0x9e>
	__asm__ volatile(
 100329a:	f38a 8811 	msr	BASEPRI, sl
 100329e:	f3bf 8f6f 	isb	sy
		if (notify) {
 10032a2:	f1b8 0f00 	cmp.w	r8, #0
 10032a6:	d0ef      	beq.n	1003288 <onoff_request+0xe0>
			notify_one(mgr, cli, state, 0);
 10032a8:	2300      	movs	r3, #0
 10032aa:	4632      	mov	r2, r6
 10032ac:	4639      	mov	r1, r7
 10032ae:	4620      	mov	r0, r4
 10032b0:	f021 fbf0 	bl	1024a94 <notify_one>
 10032b4:	e7e8      	b.n	1003288 <onoff_request+0xe0>
 10032b6:	bf00      	nop
 10032b8:	0102bd8a 	.word	0x0102bd8a
 10032bc:	0102bde3 	.word	0x0102bde3
 10032c0:	0102b695 	.word	0x0102b695
 10032c4:	0102bdf8 	.word	0x0102bdf8
 10032c8:	0102bdb7 	.word	0x0102bdb7
 10032cc:	0102bdce 	.word	0x0102bdce
 10032d0:	0102bd74 	.word	0x0102bd74
 10032d4:	0102bce7 	.word	0x0102bce7

010032d8 <onoff_release>:

int onoff_release(struct onoff_manager *mgr)
{
 10032d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10032da:	4605      	mov	r5, r0
	bool stop = false;      /* trigger a stop transition */

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
 10032dc:	f100 0614 	add.w	r6, r0, #20
	__asm__ volatile(
 10032e0:	f04f 0320 	mov.w	r3, #32
 10032e4:	f3ef 8711 	mrs	r7, BASEPRI
 10032e8:	f383 8812 	msr	BASEPRI_MAX, r3
 10032ec:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10032f0:	4630      	mov	r0, r6
 10032f2:	f01d feed 	bl	10210d0 <z_spin_lock_valid>
 10032f6:	b960      	cbnz	r0, 1003312 <onoff_release+0x3a>
 10032f8:	2394      	movs	r3, #148	; 0x94
 10032fa:	4a24      	ldr	r2, [pc, #144]	; (100338c <onoff_release+0xb4>)
 10032fc:	4924      	ldr	r1, [pc, #144]	; (1003390 <onoff_release+0xb8>)
 10032fe:	4825      	ldr	r0, [pc, #148]	; (1003394 <onoff_release+0xbc>)
 1003300:	f021 fc69 	bl	1024bd6 <assert_print>
 1003304:	4631      	mov	r1, r6
 1003306:	4824      	ldr	r0, [pc, #144]	; (1003398 <onoff_release+0xc0>)
 1003308:	f021 fc65 	bl	1024bd6 <assert_print>
 100330c:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 100330e:	481f      	ldr	r0, [pc, #124]	; (100338c <onoff_release+0xb4>)
 1003310:	e029      	b.n	1003366 <onoff_release+0x8e>
	z_spin_lock_set_owner(l);
 1003312:	4630      	mov	r0, r6
 1003314:	f01d fef8 	bl	1021108 <z_spin_lock_set_owner>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1003318:	8bac      	ldrh	r4, [r5, #28]
 100331a:	f004 0407 	and.w	r4, r4, #7
	int rv = state;

	if (state != ONOFF_STATE_ON) {
 100331e:	2c02      	cmp	r4, #2
 1003320:	d015      	beq.n	100334e <onoff_release+0x76>
		if (state == ONOFF_STATE_ERROR) {
			rv = -EIO;
		} else {
			rv = -ENOTSUP;
 1003322:	2c01      	cmp	r4, #1
 1003324:	bf0c      	ite	eq
 1003326:	f06f 0404 	mvneq.w	r4, #4
 100332a:	f06f 0485 	mvnne.w	r4, #133	; 0x85
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 100332e:	4630      	mov	r0, r6
 1003330:	f01d fedc 	bl	10210ec <z_spin_unlock_valid>
 1003334:	bb28      	cbnz	r0, 1003382 <onoff_release+0xaa>
 1003336:	23c2      	movs	r3, #194	; 0xc2
 1003338:	4a14      	ldr	r2, [pc, #80]	; (100338c <onoff_release+0xb4>)
 100333a:	4918      	ldr	r1, [pc, #96]	; (100339c <onoff_release+0xc4>)
 100333c:	4815      	ldr	r0, [pc, #84]	; (1003394 <onoff_release+0xbc>)
 100333e:	f021 fc4a 	bl	1024bd6 <assert_print>
 1003342:	4631      	mov	r1, r6
 1003344:	4816      	ldr	r0, [pc, #88]	; (10033a0 <onoff_release+0xc8>)
 1003346:	f021 fc46 	bl	1024bd6 <assert_print>
 100334a:	21c2      	movs	r1, #194	; 0xc2
 100334c:	e7df      	b.n	100330e <onoff_release+0x36>
		}
		goto out;
	}

	__ASSERT_NO_MSG(mgr->refs > 0);
 100334e:	8beb      	ldrh	r3, [r5, #30]
 1003350:	b95b      	cbnz	r3, 100336a <onoff_release+0x92>
 1003352:	4914      	ldr	r1, [pc, #80]	; (10033a4 <onoff_release+0xcc>)
 1003354:	480f      	ldr	r0, [pc, #60]	; (1003394 <onoff_release+0xbc>)
 1003356:	f240 13ef 	movw	r3, #495	; 0x1ef
 100335a:	4a13      	ldr	r2, [pc, #76]	; (10033a8 <onoff_release+0xd0>)
 100335c:	f021 fc3b 	bl	1024bd6 <assert_print>
 1003360:	f240 11ef 	movw	r1, #495	; 0x1ef
 1003364:	4810      	ldr	r0, [pc, #64]	; (10033a8 <onoff_release+0xd0>)
 1003366:	f021 fc2f 	bl	1024bc8 <assert_post_action>
	mgr->refs -= 1U;
 100336a:	3b01      	subs	r3, #1
 100336c:	b29b      	uxth	r3, r3
 100336e:	83eb      	strh	r3, [r5, #30]
	stop = (mgr->refs == 0);

out:
	if (stop) {
 1003370:	2b00      	cmp	r3, #0
 1003372:	d1dc      	bne.n	100332e <onoff_release+0x56>
		process_event(mgr, EVT_RECHECK, key);
 1003374:	463a      	mov	r2, r7
 1003376:	4621      	mov	r1, r4
 1003378:	4628      	mov	r0, r5
 100337a:	f7ff fd0f 	bl	1002d9c <process_event>
	} else {
		k_spin_unlock(&mgr->lock, key);
	}

	return rv;
}
 100337e:	4620      	mov	r0, r4
 1003380:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	__asm__ volatile(
 1003382:	f387 8811 	msr	BASEPRI, r7
 1003386:	f3bf 8f6f 	isb	sy
	return rv;
 100338a:	e7f8      	b.n	100337e <onoff_release+0xa6>
 100338c:	0102bd8a 	.word	0x0102bd8a
 1003390:	0102bde3 	.word	0x0102bde3
 1003394:	0102b695 	.word	0x0102b695
 1003398:	0102bdf8 	.word	0x0102bdf8
 100339c:	0102bdb7 	.word	0x0102bdb7
 10033a0:	0102bdce 	.word	0x0102bdce
 10033a4:	0102be10 	.word	0x0102be10
 10033a8:	0102bce7 	.word	0x0102bce7

010033ac <sys_notify_finalize>:
	return rv;
}

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
 10033ac:	b508      	push	{r3, lr}
};

/** @internal */
static inline uint32_t sys_notify_get_method(const struct sys_notify *notify)
{
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
 10033ae:	6842      	ldr	r2, [r0, #4]
 10033b0:	4603      	mov	r3, r0

	return method & SYS_NOTIFY_METHOD_MASK;
 10033b2:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
 10033b6:	2a02      	cmp	r2, #2
	notify->result = res;
 10033b8:	6081      	str	r1, [r0, #8]
	switch (method) {
 10033ba:	d00a      	beq.n	10033d2 <sys_notify_finalize+0x26>
 10033bc:	2a03      	cmp	r2, #3
 10033be:	f04f 0100 	mov.w	r1, #0
 10033c2:	d003      	beq.n	10033cc <sys_notify_finalize+0x20>
 10033c4:	2a01      	cmp	r2, #1
 10033c6:	d10a      	bne.n	10033de <sys_notify_finalize+0x32>
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
 10033c8:	6059      	str	r1, [r3, #4]

	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
 10033ca:	e006      	b.n	10033da <sys_notify_finalize+0x2e>
		rv = notify->method.callback;
 10033cc:	6818      	ldr	r0, [r3, #0]
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
 10033ce:	6059      	str	r1, [r3, #4]
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
 10033d0:	bd08      	pop	{r3, pc}
		sig = notify->method.signal;
 10033d2:	6818      	ldr	r0, [r3, #0]
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
 10033d4:	2200      	movs	r2, #0
 10033d6:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
 10033d8:	b958      	cbnz	r0, 10033f2 <sys_notify_finalize+0x46>
	sys_notify_generic_callback rv = NULL;
 10033da:	2000      	movs	r0, #0
 10033dc:	e7f8      	b.n	10033d0 <sys_notify_finalize+0x24>
		__ASSERT_NO_MSG(false);
 10033de:	4906      	ldr	r1, [pc, #24]	; (10033f8 <sys_notify_finalize+0x4c>)
 10033e0:	4806      	ldr	r0, [pc, #24]	; (10033fc <sys_notify_finalize+0x50>)
 10033e2:	2345      	movs	r3, #69	; 0x45
 10033e4:	4a06      	ldr	r2, [pc, #24]	; (1003400 <sys_notify_finalize+0x54>)
 10033e6:	f021 fbf6 	bl	1024bd6 <assert_print>
 10033ea:	2145      	movs	r1, #69	; 0x45
 10033ec:	4804      	ldr	r0, [pc, #16]	; (1003400 <sys_notify_finalize+0x54>)
 10033ee:	f021 fbeb 	bl	1024bc8 <assert_post_action>
		union { uintptr_t x; int val; } parm1 = { .val = result };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
 10033f2:	f021 f80f 	bl	1024414 <z_impl_k_poll_signal_raise>
 10033f6:	e7f0      	b.n	10033da <sys_notify_finalize+0x2e>
 10033f8:	0102ff6e 	.word	0x0102ff6e
 10033fc:	0102b695 	.word	0x0102b695
 1003400:	0102be1e 	.word	0x0102be1e

01003404 <crc8_ccitt>:
	0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15,
	0x38, 0x3f, 0x36, 0x31, 0x24, 0x23, 0x2a, 0x2d
};

uint8_t crc8_ccitt(uint8_t val, const void *buf, size_t cnt)
{
 1003404:	b510      	push	{r4, lr}
	size_t i;
	const uint8_t *p = buf;

	for (i = 0; i < cnt; i++) {
		val ^= p[i];
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
 1003406:	4c09      	ldr	r4, [pc, #36]	; (100342c <crc8_ccitt+0x28>)
 1003408:	440a      	add	r2, r1
	for (i = 0; i < cnt; i++) {
 100340a:	4291      	cmp	r1, r2
 100340c:	d100      	bne.n	1003410 <crc8_ccitt+0xc>
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
	}
	return val;
}
 100340e:	bd10      	pop	{r4, pc}
		val ^= p[i];
 1003410:	f811 3b01 	ldrb.w	r3, [r1], #1
 1003414:	4058      	eors	r0, r3
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
 1003416:	0903      	lsrs	r3, r0, #4
 1003418:	5ce3      	ldrb	r3, [r4, r3]
 100341a:	0100      	lsls	r0, r0, #4
 100341c:	b2c0      	uxtb	r0, r0
 100341e:	4043      	eors	r3, r0
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
 1003420:	0918      	lsrs	r0, r3, #4
 1003422:	5c20      	ldrb	r0, [r4, r0]
 1003424:	011b      	lsls	r3, r3, #4
 1003426:	b2db      	uxtb	r3, r3
 1003428:	4058      	eors	r0, r3
	for (i = 0; i < cnt; i++) {
 100342a:	e7ee      	b.n	100340a <crc8_ccitt+0x6>
 100342c:	0102be41 	.word	0x0102be41

01003430 <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
 1003430:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1003434:	4681      	mov	r9, r0
 1003436:	468b      	mov	fp, r1
 1003438:	4617      	mov	r7, r2
 100343a:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
 100343c:	2500      	movs	r5, #0
{
 100343e:	b095      	sub	sp, #84	; 0x54
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
 1003440:	7838      	ldrb	r0, [r7, #0]
 1003442:	b908      	cbnz	r0, 1003448 <z_cbvprintf_impl+0x18>
			OUTC(' ');
			--width;
		}
	}

	return count;
 1003444:	4628      	mov	r0, r5
 1003446:	e357      	b.n	1003af8 <z_cbvprintf_impl+0x6c8>
			OUTC(*fp++);
 1003448:	1c7b      	adds	r3, r7, #1
		if (*fp != '%') {
 100344a:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
 100344c:	9303      	str	r3, [sp, #12]
		if (*fp != '%') {
 100344e:	d006      	beq.n	100345e <z_cbvprintf_impl+0x2e>
			OUTC('%');
 1003450:	4659      	mov	r1, fp
 1003452:	47c8      	blx	r9
 1003454:	2800      	cmp	r0, #0
 1003456:	f2c0 834f 	blt.w	1003af8 <z_cbvprintf_impl+0x6c8>
 100345a:	3501      	adds	r5, #1
		if (bps == NULL) {
 100345c:	e1fb      	b.n	1003856 <z_cbvprintf_impl+0x426>
		} state = {
 100345e:	2218      	movs	r2, #24
 1003460:	2100      	movs	r1, #0
 1003462:	a80e      	add	r0, sp, #56	; 0x38
 1003464:	f023 fa91 	bl	102698a <memset>
	if (*sp == '%') {
 1003468:	787b      	ldrb	r3, [r7, #1]
 100346a:	2b25      	cmp	r3, #37	; 0x25
 100346c:	d07d      	beq.n	100356a <z_cbvprintf_impl+0x13a>
 100346e:	2300      	movs	r3, #0
 1003470:	4698      	mov	r8, r3
 1003472:	469e      	mov	lr, r3
 1003474:	469c      	mov	ip, r3
 1003476:	461e      	mov	r6, r3
 1003478:	1c78      	adds	r0, r7, #1
 100347a:	4601      	mov	r1, r0
		switch (*sp) {
 100347c:	f810 2b01 	ldrb.w	r2, [r0], #1
 1003480:	2a2b      	cmp	r2, #43	; 0x2b
 1003482:	f000 80a1 	beq.w	10035c8 <z_cbvprintf_impl+0x198>
 1003486:	f200 8098 	bhi.w	10035ba <z_cbvprintf_impl+0x18a>
 100348a:	2a20      	cmp	r2, #32
 100348c:	f000 809f 	beq.w	10035ce <z_cbvprintf_impl+0x19e>
 1003490:	2a23      	cmp	r2, #35	; 0x23
 1003492:	f000 809f 	beq.w	10035d4 <z_cbvprintf_impl+0x1a4>
 1003496:	b12b      	cbz	r3, 10034a4 <z_cbvprintf_impl+0x74>
 1003498:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 100349c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 10034a0:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
 10034a4:	f1b8 0f00 	cmp.w	r8, #0
 10034a8:	d005      	beq.n	10034b6 <z_cbvprintf_impl+0x86>
 10034aa:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 10034ae:	f043 0320 	orr.w	r3, r3, #32
 10034b2:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
 10034b6:	f1be 0f00 	cmp.w	lr, #0
 10034ba:	d005      	beq.n	10034c8 <z_cbvprintf_impl+0x98>
 10034bc:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 10034c0:	f043 0310 	orr.w	r3, r3, #16
 10034c4:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
 10034c8:	f1bc 0f00 	cmp.w	ip, #0
 10034cc:	d005      	beq.n	10034da <z_cbvprintf_impl+0xaa>
 10034ce:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 10034d2:	f043 0308 	orr.w	r3, r3, #8
 10034d6:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
 10034da:	b12e      	cbz	r6, 10034e8 <z_cbvprintf_impl+0xb8>
 10034dc:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 10034e0:	f043 0304 	orr.w	r3, r3, #4
 10034e4:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (conv->flag_zero && conv->flag_dash) {
 10034e8:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 10034ec:	f003 0044 	and.w	r0, r3, #68	; 0x44
 10034f0:	2844      	cmp	r0, #68	; 0x44
 10034f2:	d103      	bne.n	10034fc <z_cbvprintf_impl+0xcc>
		conv->flag_zero = false;
 10034f4:	f36f 1386 	bfc	r3, #6, #1
 10034f8:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	conv->width_present = true;
 10034fc:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
 1003500:	2a2a      	cmp	r2, #42	; 0x2a
	conv->width_present = true;
 1003502:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 1003506:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
 100350a:	d17f      	bne.n	100360c <z_cbvprintf_impl+0x1dc>
		conv->width_star = true;
 100350c:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
		return ++sp;
 1003510:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
 1003512:	f042 0201 	orr.w	r2, r2, #1
 1003516:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	conv->prec_present = (*sp == '.');
 100351a:	781a      	ldrb	r2, [r3, #0]
 100351c:	2a2e      	cmp	r2, #46	; 0x2e
 100351e:	bf0c      	ite	eq
 1003520:	2101      	moveq	r1, #1
 1003522:	2100      	movne	r1, #0
 1003524:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
 1003528:	f361 0241 	bfi	r2, r1, #1, #1
 100352c:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	if (!conv->prec_present) {
 1003530:	d178      	bne.n	1003624 <z_cbvprintf_impl+0x1f4>
	if (*sp == '*') {
 1003532:	785a      	ldrb	r2, [r3, #1]
 1003534:	2a2a      	cmp	r2, #42	; 0x2a
 1003536:	d06e      	beq.n	1003616 <z_cbvprintf_impl+0x1e6>
	size_t val = 0;
 1003538:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
 100353a:	f04f 0c0a 	mov.w	ip, #10
	++sp;
 100353e:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
 1003540:	4619      	mov	r1, r3
 1003542:	f811 0b01 	ldrb.w	r0, [r1], #1
 1003546:	f1a0 0630 	sub.w	r6, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
 100354a:	2e09      	cmp	r6, #9
 100354c:	f240 8095 	bls.w	100367a <z_cbvprintf_impl+0x24a>
	conv->unsupported |= ((conv->prec_value < 0)
 1003550:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
	conv->prec_value = prec;
 1003554:	9212      	str	r2, [sp, #72]	; 0x48
	conv->unsupported |= ((conv->prec_value < 0)
 1003556:	f3c1 0040 	ubfx	r0, r1, #1, #1
 100355a:	ea40 70d2 	orr.w	r0, r0, r2, lsr #31
 100355e:	460a      	mov	r2, r1
 1003560:	f360 0241 	bfi	r2, r0, #1, #1
 1003564:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
 1003568:	e05c      	b.n	1003624 <z_cbvprintf_impl+0x1f4>
		conv->specifier = *sp++;
 100356a:	1cba      	adds	r2, r7, #2
 100356c:	9203      	str	r2, [sp, #12]
 100356e:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->width_star) {
 1003572:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
 1003576:	07da      	lsls	r2, r3, #31
 1003578:	f140 812e 	bpl.w	10037d8 <z_cbvprintf_impl+0x3a8>
			width = va_arg(ap, int);
 100357c:	f854 8b04 	ldr.w	r8, [r4], #4
			if (width < 0) {
 1003580:	f1b8 0f00 	cmp.w	r8, #0
 1003584:	da07      	bge.n	1003596 <z_cbvprintf_impl+0x166>
				conv->flag_dash = true;
 1003586:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				width = -width;
 100358a:	f1c8 0800 	rsb	r8, r8, #0
				conv->flag_dash = true;
 100358e:	f042 0204 	orr.w	r2, r2, #4
 1003592:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
		if (conv->prec_star) {
 1003596:	075e      	lsls	r6, r3, #29
 1003598:	f140 8127 	bpl.w	10037ea <z_cbvprintf_impl+0x3ba>
			int arg = va_arg(ap, int);
 100359c:	f854 ab04 	ldr.w	sl, [r4], #4
			if (arg < 0) {
 10035a0:	f1ba 0f00 	cmp.w	sl, #0
 10035a4:	f280 8126 	bge.w	10037f4 <z_cbvprintf_impl+0x3c4>
				conv->prec_present = false;
 10035a8:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
 10035ac:	f36f 0341 	bfc	r3, #1, #1
 10035b0:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
		int precision = -1;
 10035b4:	f04f 3aff 	mov.w	sl, #4294967295
 10035b8:	e11c      	b.n	10037f4 <z_cbvprintf_impl+0x3c4>
		switch (*sp) {
 10035ba:	2a2d      	cmp	r2, #45	; 0x2d
 10035bc:	d00d      	beq.n	10035da <z_cbvprintf_impl+0x1aa>
 10035be:	2a30      	cmp	r2, #48	; 0x30
 10035c0:	f47f af69 	bne.w	1003496 <z_cbvprintf_impl+0x66>
 10035c4:	2301      	movs	r3, #1
	} while (loop);
 10035c6:	e758      	b.n	100347a <z_cbvprintf_impl+0x4a>
		switch (*sp) {
 10035c8:	f04f 0c01 	mov.w	ip, #1
 10035cc:	e755      	b.n	100347a <z_cbvprintf_impl+0x4a>
 10035ce:	f04f 0e01 	mov.w	lr, #1
 10035d2:	e752      	b.n	100347a <z_cbvprintf_impl+0x4a>
 10035d4:	f04f 0801 	mov.w	r8, #1
 10035d8:	e74f      	b.n	100347a <z_cbvprintf_impl+0x4a>
 10035da:	2601      	movs	r6, #1
 10035dc:	e74d      	b.n	100347a <z_cbvprintf_impl+0x4a>
		val = 10U * val + *sp++ - '0';
 10035de:	4603      	mov	r3, r0
 10035e0:	fb0e 6202 	mla	r2, lr, r2, r6
 10035e4:	3a30      	subs	r2, #48	; 0x30
 10035e6:	4618      	mov	r0, r3
 10035e8:	f810 6b01 	ldrb.w	r6, [r0], #1
 10035ec:	f1a6 0c30 	sub.w	ip, r6, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
 10035f0:	f1bc 0f09 	cmp.w	ip, #9
 10035f4:	d9f3      	bls.n	10035de <z_cbvprintf_impl+0x1ae>
	if (sp != wp) {
 10035f6:	4299      	cmp	r1, r3
 10035f8:	d08f      	beq.n	100351a <z_cbvprintf_impl+0xea>
		conv->unsupported |= ((conv->width_value < 0)
 10035fa:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
		conv->width_value = width;
 10035fe:	9211      	str	r2, [sp, #68]	; 0x44
				      || (width != (size_t)conv->width_value));
 1003600:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
 1003602:	f362 0141 	bfi	r1, r2, #1, #1
 1003606:	f88d 1040 	strb.w	r1, [sp, #64]	; 0x40
 100360a:	e786      	b.n	100351a <z_cbvprintf_impl+0xea>
 100360c:	460b      	mov	r3, r1
	size_t val = 0;
 100360e:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
 1003610:	f04f 0e0a 	mov.w	lr, #10
 1003614:	e7e7      	b.n	10035e6 <z_cbvprintf_impl+0x1b6>
		conv->prec_star = true;
 1003616:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
		return ++sp;
 100361a:	3302      	adds	r3, #2
		conv->prec_star = true;
 100361c:	f042 0204 	orr.w	r2, r2, #4
 1003620:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	switch (*sp) {
 1003624:	781a      	ldrb	r2, [r3, #0]
 1003626:	2a6c      	cmp	r2, #108	; 0x6c
 1003628:	d047      	beq.n	10036ba <z_cbvprintf_impl+0x28a>
 100362a:	d82b      	bhi.n	1003684 <z_cbvprintf_impl+0x254>
 100362c:	2a68      	cmp	r2, #104	; 0x68
 100362e:	d031      	beq.n	1003694 <z_cbvprintf_impl+0x264>
 1003630:	2a6a      	cmp	r2, #106	; 0x6a
 1003632:	d04b      	beq.n	10036cc <z_cbvprintf_impl+0x29c>
 1003634:	2a4c      	cmp	r2, #76	; 0x4c
 1003636:	d051      	beq.n	10036dc <z_cbvprintf_impl+0x2ac>
	conv->specifier = *sp++;
 1003638:	461a      	mov	r2, r3
 100363a:	f812 3b01 	ldrb.w	r3, [r2], #1
	switch (conv->specifier) {
 100363e:	2b78      	cmp	r3, #120	; 0x78
	conv->specifier = *sp++;
 1003640:	9203      	str	r2, [sp, #12]
 1003642:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->length_mod == LENGTH_UPPER_L) {
 1003646:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
	switch (conv->specifier) {
 100364a:	f200 80be 	bhi.w	10037ca <z_cbvprintf_impl+0x39a>
 100364e:	2b6d      	cmp	r3, #109	; 0x6d
 1003650:	d851      	bhi.n	10036f6 <z_cbvprintf_impl+0x2c6>
 1003652:	2b69      	cmp	r3, #105	; 0x69
 1003654:	f200 80b9 	bhi.w	10037ca <z_cbvprintf_impl+0x39a>
 1003658:	2b57      	cmp	r3, #87	; 0x57
 100365a:	d867      	bhi.n	100372c <z_cbvprintf_impl+0x2fc>
 100365c:	2b41      	cmp	r3, #65	; 0x41
 100365e:	d003      	beq.n	1003668 <z_cbvprintf_impl+0x238>
 1003660:	3b45      	subs	r3, #69	; 0x45
 1003662:	2b02      	cmp	r3, #2
 1003664:	f200 80b1 	bhi.w	10037ca <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_FP;
 1003668:	2204      	movs	r2, #4
 100366a:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 100366e:	f362 0302 	bfi	r3, r2, #0, #3
 1003672:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
			unsupported = true;
 1003676:	2301      	movs	r3, #1
			break;
 1003678:	e073      	b.n	1003762 <z_cbvprintf_impl+0x332>
		val = 10U * val + *sp++ - '0';
 100367a:	fb0c 0202 	mla	r2, ip, r2, r0
 100367e:	460b      	mov	r3, r1
 1003680:	3a30      	subs	r2, #48	; 0x30
 1003682:	e75d      	b.n	1003540 <z_cbvprintf_impl+0x110>
	switch (*sp) {
 1003684:	2a74      	cmp	r2, #116	; 0x74
 1003686:	d025      	beq.n	10036d4 <z_cbvprintf_impl+0x2a4>
 1003688:	2a7a      	cmp	r2, #122	; 0x7a
 100368a:	d1d5      	bne.n	1003638 <z_cbvprintf_impl+0x208>
		conv->length_mod = LENGTH_Z;
 100368c:	2106      	movs	r1, #6
 100368e:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
 1003692:	e00c      	b.n	10036ae <z_cbvprintf_impl+0x27e>
		if (*++sp == 'h') {
 1003694:	785a      	ldrb	r2, [r3, #1]
 1003696:	2a68      	cmp	r2, #104	; 0x68
 1003698:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
 100369c:	d106      	bne.n	10036ac <z_cbvprintf_impl+0x27c>
			conv->length_mod = LENGTH_HH;
 100369e:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
 10036a0:	f361 02c6 	bfi	r2, r1, #3, #4
 10036a4:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
			++sp;
 10036a8:	3302      	adds	r3, #2
 10036aa:	e7c5      	b.n	1003638 <z_cbvprintf_impl+0x208>
			conv->length_mod = LENGTH_H;
 10036ac:	2102      	movs	r1, #2
 10036ae:	f361 02c6 	bfi	r2, r1, #3, #4
 10036b2:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
		if (*++sp == 'h') {
 10036b6:	3301      	adds	r3, #1
 10036b8:	e7be      	b.n	1003638 <z_cbvprintf_impl+0x208>
		if (*++sp == 'l') {
 10036ba:	785a      	ldrb	r2, [r3, #1]
 10036bc:	2a6c      	cmp	r2, #108	; 0x6c
 10036be:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
 10036c2:	d101      	bne.n	10036c8 <z_cbvprintf_impl+0x298>
			conv->length_mod = LENGTH_LL;
 10036c4:	2104      	movs	r1, #4
 10036c6:	e7eb      	b.n	10036a0 <z_cbvprintf_impl+0x270>
			conv->length_mod = LENGTH_L;
 10036c8:	2103      	movs	r1, #3
 10036ca:	e7f0      	b.n	10036ae <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_J;
 10036cc:	2105      	movs	r1, #5
 10036ce:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
 10036d2:	e7ec      	b.n	10036ae <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_T;
 10036d4:	2107      	movs	r1, #7
 10036d6:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
 10036da:	e7e8      	b.n	10036ae <z_cbvprintf_impl+0x27e>
		conv->unsupported = true;
 10036dc:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 10036e0:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 10036e4:	f022 0202 	bic.w	r2, r2, #2
 10036e8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 10036ec:	f042 0202 	orr.w	r2, r2, #2
 10036f0:	f8ad 2040 	strh.w	r2, [sp, #64]	; 0x40
		break;
 10036f4:	e7df      	b.n	10036b6 <z_cbvprintf_impl+0x286>
	switch (conv->specifier) {
 10036f6:	3b6e      	subs	r3, #110	; 0x6e
 10036f8:	b2d9      	uxtb	r1, r3
 10036fa:	2301      	movs	r3, #1
 10036fc:	408b      	lsls	r3, r1
 10036fe:	f240 4182 	movw	r1, #1154	; 0x482
 1003702:	420b      	tst	r3, r1
 1003704:	d137      	bne.n	1003776 <z_cbvprintf_impl+0x346>
 1003706:	f013 0f24 	tst.w	r3, #36	; 0x24
 100370a:	d151      	bne.n	10037b0 <z_cbvprintf_impl+0x380>
 100370c:	07d8      	lsls	r0, r3, #31
 100370e:	d55c      	bpl.n	10037ca <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_PTR;
 1003710:	2103      	movs	r1, #3
 1003712:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 1003716:	f361 0302 	bfi	r3, r1, #0, #3
 100371a:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
 100371e:	f002 0378 	and.w	r3, r2, #120	; 0x78
 1003722:	f1a3 0140 	sub.w	r1, r3, #64	; 0x40
 1003726:	424b      	negs	r3, r1
 1003728:	414b      	adcs	r3, r1
 100372a:	e01a      	b.n	1003762 <z_cbvprintf_impl+0x332>
 100372c:	2001      	movs	r0, #1
	switch (conv->specifier) {
 100372e:	f1a3 0158 	sub.w	r1, r3, #88	; 0x58
 1003732:	b2c9      	uxtb	r1, r1
 1003734:	fa00 f101 	lsl.w	r1, r0, r1
 1003738:	f411 4f62 	tst.w	r1, #57856	; 0xe200
 100373c:	d194      	bne.n	1003668 <z_cbvprintf_impl+0x238>
 100373e:	f640 0601 	movw	r6, #2049	; 0x801
 1003742:	4231      	tst	r1, r6
 1003744:	d11d      	bne.n	1003782 <z_cbvprintf_impl+0x352>
 1003746:	f411 3f04 	tst.w	r1, #135168	; 0x21000
 100374a:	d03e      	beq.n	10037ca <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_SINT;
 100374c:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 1003750:	f360 0302 	bfi	r3, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
 1003754:	f002 0278 	and.w	r2, r2, #120	; 0x78
 1003758:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_SINT;
 100375a:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
 100375e:	d034      	beq.n	10037ca <z_cbvprintf_impl+0x39a>
	bool unsupported = false;
 1003760:	2300      	movs	r3, #0
	conv->unsupported |= unsupported;
 1003762:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
 1003766:	f3c2 0140 	ubfx	r1, r2, #1, #1
 100376a:	430b      	orrs	r3, r1
 100376c:	f363 0241 	bfi	r2, r3, #1, #1
 1003770:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
 1003774:	e6fd      	b.n	1003572 <z_cbvprintf_impl+0x142>
		conv->specifier_cat = SPECIFIER_UINT;
 1003776:	2102      	movs	r1, #2
 1003778:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 100377c:	f361 0302 	bfi	r3, r1, #0, #3
 1003780:	e7e8      	b.n	1003754 <z_cbvprintf_impl+0x324>
 1003782:	2002      	movs	r0, #2
 1003784:	f89d 1042 	ldrb.w	r1, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
 1003788:	f002 0278 	and.w	r2, r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
 100378c:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
 1003790:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
 1003792:	f88d 1042 	strb.w	r1, [sp, #66]	; 0x42
			conv->invalid = true;
 1003796:	bf02      	ittt	eq
 1003798:	f89d 1040 	ldrbeq.w	r1, [sp, #64]	; 0x40
 100379c:	f041 0101 	orreq.w	r1, r1, #1
 10037a0:	f88d 1040 	strbeq.w	r1, [sp, #64]	; 0x40
		if (conv->specifier == 'c') {
 10037a4:	2b63      	cmp	r3, #99	; 0x63
 10037a6:	d1db      	bne.n	1003760 <z_cbvprintf_impl+0x330>
			unsupported = (conv->length_mod != LENGTH_NONE);
 10037a8:	1e13      	subs	r3, r2, #0
 10037aa:	bf18      	it	ne
 10037ac:	2301      	movne	r3, #1
 10037ae:	e7d8      	b.n	1003762 <z_cbvprintf_impl+0x332>
		conv->specifier_cat = SPECIFIER_PTR;
 10037b0:	2103      	movs	r1, #3
 10037b2:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
 10037b6:	f012 0f78 	tst.w	r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
 10037ba:	f361 0302 	bfi	r3, r1, #0, #3
 10037be:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
 10037c2:	bf14      	ite	ne
 10037c4:	2301      	movne	r3, #1
 10037c6:	2300      	moveq	r3, #0
 10037c8:	e7cb      	b.n	1003762 <z_cbvprintf_impl+0x332>
		conv->invalid = true;
 10037ca:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 10037ce:	f043 0301 	orr.w	r3, r3, #1
 10037d2:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
		break;
 10037d6:	e7c3      	b.n	1003760 <z_cbvprintf_impl+0x330>
		} else if (conv->width_present) {
 10037d8:	f99d 2040 	ldrsb.w	r2, [sp, #64]	; 0x40
 10037dc:	2a00      	cmp	r2, #0
		int width = -1;
 10037de:	bfac      	ite	ge
 10037e0:	f04f 38ff 	movge.w	r8, #4294967295
			width = conv->width_value;
 10037e4:	f8dd 8044 	ldrlt.w	r8, [sp, #68]	; 0x44
 10037e8:	e6d5      	b.n	1003596 <z_cbvprintf_impl+0x166>
		} else if (conv->prec_present) {
 10037ea:	0798      	lsls	r0, r3, #30
 10037ec:	f57f aee2 	bpl.w	10035b4 <z_cbvprintf_impl+0x184>
			precision = conv->prec_value;
 10037f0:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
		conv->pad0_value = 0;
 10037f4:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
 10037f6:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
			= (enum specifier_cat_enum)conv->specifier_cat;
 10037fa:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
			= (enum length_mod_enum)conv->length_mod;
 10037fe:	f89d 1041 	ldrb.w	r1, [sp, #65]	; 0x41
		enum specifier_cat_enum specifier_cat
 1003802:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
 1003806:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
 1003808:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
 100380c:	d133      	bne.n	1003876 <z_cbvprintf_impl+0x446>
			switch (length_mod) {
 100380e:	1ecb      	subs	r3, r1, #3
 1003810:	2b04      	cmp	r3, #4
 1003812:	d804      	bhi.n	100381e <z_cbvprintf_impl+0x3ee>
 1003814:	e8df f003 	tbb	[pc, r3]
 1003818:	21464621 	.word	0x21464621
 100381c:	21          	.byte	0x21
 100381d:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
 100381e:	6823      	ldr	r3, [r4, #0]
			if (length_mod == LENGTH_HH) {
 1003820:	2901      	cmp	r1, #1
				value->sint = va_arg(ap, int);
 1003822:	ea4f 72e3 	mov.w	r2, r3, asr #31
 1003826:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
 100382a:	d11c      	bne.n	1003866 <z_cbvprintf_impl+0x436>
				value->sint = (signed char)value->sint;
 100382c:	f99d 3038 	ldrsb.w	r3, [sp, #56]	; 0x38
 1003830:	17da      	asrs	r2, r3, #31
 1003832:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
				value->sint = va_arg(ap, int);
 1003836:	3404      	adds	r4, #4
		if (conv->invalid || conv->unsupported) {
 1003838:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 100383c:	f013 0603 	ands.w	r6, r3, #3
 1003840:	d050      	beq.n	10038e4 <z_cbvprintf_impl+0x4b4>
			OUTS(sp, fp);
 1003842:	463a      	mov	r2, r7
 1003844:	4659      	mov	r1, fp
 1003846:	4648      	mov	r0, r9
 1003848:	9b03      	ldr	r3, [sp, #12]
 100384a:	f021 f9a6 	bl	1024b9a <outs>
 100384e:	2800      	cmp	r0, #0
 1003850:	f2c0 8152 	blt.w	1003af8 <z_cbvprintf_impl+0x6c8>
 1003854:	4405      	add	r5, r0
			continue;
 1003856:	9f03      	ldr	r7, [sp, #12]
 1003858:	e5f2      	b.n	1003440 <z_cbvprintf_impl+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
 100385a:	f854 3b04 	ldr.w	r3, [r4], #4
 100385e:	17da      	asrs	r2, r3, #31
				value->uint = (unsigned char)value->uint;
 1003860:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
 1003864:	e7e8      	b.n	1003838 <z_cbvprintf_impl+0x408>
			} else if (length_mod == LENGTH_H) {
 1003866:	2902      	cmp	r1, #2
 1003868:	d1e5      	bne.n	1003836 <z_cbvprintf_impl+0x406>
				value->sint = (short)value->sint;
 100386a:	b21a      	sxth	r2, r3
 100386c:	f343 33c0 	sbfx	r3, r3, #15, #1
 1003870:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
 1003874:	e7df      	b.n	1003836 <z_cbvprintf_impl+0x406>
		} else if (specifier_cat == SPECIFIER_UINT) {
 1003876:	2b02      	cmp	r3, #2
 1003878:	d124      	bne.n	10038c4 <z_cbvprintf_impl+0x494>
			switch (length_mod) {
 100387a:	1ecb      	subs	r3, r1, #3
 100387c:	2b04      	cmp	r3, #4
 100387e:	d804      	bhi.n	100388a <z_cbvprintf_impl+0x45a>
 1003880:	e8df f003 	tbb	[pc, r3]
 1003884:	18101018 	.word	0x18101018
 1003888:	18          	.byte	0x18
 1003889:	00          	.byte	0x00
			if (length_mod == LENGTH_HH) {
 100388a:	2901      	cmp	r1, #1
 100388c:	f04f 0200 	mov.w	r2, #0
				value->uint = va_arg(ap, unsigned int);
 1003890:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
 1003894:	d014      	beq.n	10038c0 <z_cbvprintf_impl+0x490>
			} else if (length_mod == LENGTH_H) {
 1003896:	2902      	cmp	r1, #2
				value->uint = va_arg(ap, unsigned int);
 1003898:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			} else if (length_mod == LENGTH_H) {
 100389c:	d1cc      	bne.n	1003838 <z_cbvprintf_impl+0x408>
				value->uint = (unsigned short)value->uint;
 100389e:	b29b      	uxth	r3, r3
			value->ptr = va_arg(ap, void *);
 10038a0:	930e      	str	r3, [sp, #56]	; 0x38
 10038a2:	e7c9      	b.n	1003838 <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap,
 10038a4:	3407      	adds	r4, #7
 10038a6:	f024 0407 	bic.w	r4, r4, #7
				value->uint =
 10038aa:	e8f4 2302 	ldrd	r2, r3, [r4], #8
 10038ae:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
 10038b2:	e7c1      	b.n	1003838 <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap, size_t);
 10038b4:	f854 3b04 	ldr.w	r3, [r4], #4
 10038b8:	930e      	str	r3, [sp, #56]	; 0x38
 10038ba:	2300      	movs	r3, #0
 10038bc:	930f      	str	r3, [sp, #60]	; 0x3c
			} else if (length_mod == LENGTH_H) {
 10038be:	e7bb      	b.n	1003838 <z_cbvprintf_impl+0x408>
				value->uint = (unsigned char)value->uint;
 10038c0:	b2db      	uxtb	r3, r3
 10038c2:	e7cd      	b.n	1003860 <z_cbvprintf_impl+0x430>
		} else if (specifier_cat == SPECIFIER_FP) {
 10038c4:	2b04      	cmp	r3, #4
 10038c6:	d108      	bne.n	10038da <z_cbvprintf_impl+0x4aa>
					(sint_value_type)va_arg(ap, long long);
 10038c8:	3407      	adds	r4, #7
				value->ldbl = va_arg(ap, long double);
 10038ca:	f024 0407 	bic.w	r4, r4, #7
 10038ce:	e9d4 2300 	ldrd	r2, r3, [r4]
 10038d2:	3408      	adds	r4, #8
 10038d4:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
 10038d8:	e7ae      	b.n	1003838 <z_cbvprintf_impl+0x408>
		} else if (specifier_cat == SPECIFIER_PTR) {
 10038da:	2b03      	cmp	r3, #3
 10038dc:	d1ac      	bne.n	1003838 <z_cbvprintf_impl+0x408>
			value->ptr = va_arg(ap, void *);
 10038de:	f854 3b04 	ldr.w	r3, [r4], #4
 10038e2:	e7dd      	b.n	10038a0 <z_cbvprintf_impl+0x470>
		switch (conv->specifier) {
 10038e4:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
 10038e8:	2878      	cmp	r0, #120	; 0x78
 10038ea:	d8b4      	bhi.n	1003856 <z_cbvprintf_impl+0x426>
 10038ec:	2862      	cmp	r0, #98	; 0x62
 10038ee:	d81c      	bhi.n	100392a <z_cbvprintf_impl+0x4fa>
 10038f0:	2825      	cmp	r0, #37	; 0x25
 10038f2:	f43f adad 	beq.w	1003450 <z_cbvprintf_impl+0x20>
 10038f6:	2858      	cmp	r0, #88	; 0x58
 10038f8:	d1ad      	bne.n	1003856 <z_cbvprintf_impl+0x426>
			bps = encode_uint(value->uint, conv, buf, bpe);
 10038fa:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 10038fe:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 1003902:	9300      	str	r3, [sp, #0]
 1003904:	aa10      	add	r2, sp, #64	; 0x40
 1003906:	ab08      	add	r3, sp, #32
 1003908:	f021 f901 	bl	1024b0e <encode_uint>
			if (precision >= 0) {
 100390c:	f1ba 0f00 	cmp.w	sl, #0
			bps = encode_uint(value->uint, conv, buf, bpe);
 1003910:	4607      	mov	r7, r0
			if (precision >= 0) {
 1003912:	f280 8099 	bge.w	1003a48 <z_cbvprintf_impl+0x618>
		if (bps == NULL) {
 1003916:	2f00      	cmp	r7, #0
 1003918:	d09d      	beq.n	1003856 <z_cbvprintf_impl+0x426>
		size_t nj_len = (bpe - bps);
 100391a:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 100391e:	1bd8      	subs	r0, r3, r7
		if (sign != 0) {
 1003920:	2e00      	cmp	r6, #0
 1003922:	f000 80c0 	beq.w	1003aa6 <z_cbvprintf_impl+0x676>
			nj_len += 1U;
 1003926:	3001      	adds	r0, #1
 1003928:	e0bd      	b.n	1003aa6 <z_cbvprintf_impl+0x676>
		switch (conv->specifier) {
 100392a:	3863      	subs	r0, #99	; 0x63
 100392c:	2815      	cmp	r0, #21
 100392e:	d892      	bhi.n	1003856 <z_cbvprintf_impl+0x426>
 1003930:	a201      	add	r2, pc, #4	; (adr r2, 1003938 <z_cbvprintf_impl+0x508>)
 1003932:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
 1003936:	bf00      	nop
 1003938:	01003a0d 	.word	0x01003a0d
 100393c:	01003a1f 	.word	0x01003a1f
 1003940:	01003857 	.word	0x01003857
 1003944:	01003857 	.word	0x01003857
 1003948:	01003857 	.word	0x01003857
 100394c:	01003857 	.word	0x01003857
 1003950:	01003a1f 	.word	0x01003a1f
 1003954:	01003857 	.word	0x01003857
 1003958:	01003857 	.word	0x01003857
 100395c:	01003857 	.word	0x01003857
 1003960:	01003857 	.word	0x01003857
 1003964:	01003aab 	.word	0x01003aab
 1003968:	01003a43 	.word	0x01003a43
 100396c:	01003a69 	.word	0x01003a69
 1003970:	01003857 	.word	0x01003857
 1003974:	01003857 	.word	0x01003857
 1003978:	01003991 	.word	0x01003991
 100397c:	01003857 	.word	0x01003857
 1003980:	01003a43 	.word	0x01003a43
 1003984:	01003857 	.word	0x01003857
 1003988:	01003857 	.word	0x01003857
 100398c:	01003a43 	.word	0x01003a43
			if (precision >= 0) {
 1003990:	f1ba 0f00 	cmp.w	sl, #0
			bps = (const char *)value->ptr;
 1003994:	9f0e      	ldr	r7, [sp, #56]	; 0x38
			if (precision >= 0) {
 1003996:	db35      	blt.n	1003a04 <z_cbvprintf_impl+0x5d4>
				len = strnlen(bps, precision);
 1003998:	4651      	mov	r1, sl
 100399a:	4638      	mov	r0, r7
 100399c:	f022 ffb2 	bl	1026904 <strnlen>
			bpe = bps + len;
 10039a0:	eb07 0a00 	add.w	sl, r7, r0
		if (bps == NULL) {
 10039a4:	2f00      	cmp	r7, #0
 10039a6:	f43f af56 	beq.w	1003856 <z_cbvprintf_impl+0x426>
		char sign = 0;
 10039aa:	2600      	movs	r6, #0
		if (conv->altform_0c) {
 10039ac:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 10039b0:	f013 0210 	ands.w	r2, r3, #16
 10039b4:	9205      	str	r2, [sp, #20]
 10039b6:	f000 8092 	beq.w	1003ade <z_cbvprintf_impl+0x6ae>
			nj_len += 2U;
 10039ba:	3002      	adds	r0, #2
		if (conv->pad_fp) {
 10039bc:	065b      	lsls	r3, r3, #25
		nj_len += conv->pad0_value;
 10039be:	9a11      	ldr	r2, [sp, #68]	; 0x44
			nj_len += conv->pad0_pre_exp;
 10039c0:	bf48      	it	mi
 10039c2:	9b12      	ldrmi	r3, [sp, #72]	; 0x48
		nj_len += conv->pad0_value;
 10039c4:	4410      	add	r0, r2
			nj_len += conv->pad0_pre_exp;
 10039c6:	bf48      	it	mi
 10039c8:	18c0      	addmi	r0, r0, r3
		if (width > 0) {
 10039ca:	f1b8 0f00 	cmp.w	r8, #0
		nj_len += conv->pad0_value;
 10039ce:	9204      	str	r2, [sp, #16]
		if (width > 0) {
 10039d0:	f340 809f 	ble.w	1003b12 <z_cbvprintf_impl+0x6e2>
			if (!conv->flag_dash) {
 10039d4:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
			width -= (int)nj_len;
 10039d8:	eba8 0800 	sub.w	r8, r8, r0
			if (!conv->flag_dash) {
 10039dc:	f3c2 0380 	ubfx	r3, r2, #2, #1
 10039e0:	0750      	lsls	r0, r2, #29
 10039e2:	9306      	str	r3, [sp, #24]
 10039e4:	f100 8095 	bmi.w	1003b12 <z_cbvprintf_impl+0x6e2>
				if (conv->flag_zero) {
 10039e8:	0651      	lsls	r1, r2, #25
 10039ea:	f140 8088 	bpl.w	1003afe <z_cbvprintf_impl+0x6ce>
					if (sign != 0) {
 10039ee:	b13e      	cbz	r6, 1003a00 <z_cbvprintf_impl+0x5d0>
						OUTC(sign);
 10039f0:	4659      	mov	r1, fp
 10039f2:	4630      	mov	r0, r6
 10039f4:	47c8      	blx	r9
 10039f6:	2800      	cmp	r0, #0
 10039f8:	db7e      	blt.n	1003af8 <z_cbvprintf_impl+0x6c8>
 10039fa:	9b06      	ldr	r3, [sp, #24]
 10039fc:	3501      	adds	r5, #1
 10039fe:	461e      	mov	r6, r3
					pad = '0';
 1003a00:	2230      	movs	r2, #48	; 0x30
 1003a02:	e07d      	b.n	1003b00 <z_cbvprintf_impl+0x6d0>
				len = strlen(bps);
 1003a04:	4638      	mov	r0, r7
 1003a06:	f022 ff76 	bl	10268f6 <strlen>
 1003a0a:	e7c9      	b.n	10039a0 <z_cbvprintf_impl+0x570>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 1003a0c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
		char sign = 0;
 1003a0e:	2600      	movs	r6, #0
		size_t nj_len = (bpe - bps);
 1003a10:	2001      	movs	r0, #1
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 1003a12:	f88d 3020 	strb.w	r3, [sp, #32]
			bps = buf;
 1003a16:	af08      	add	r7, sp, #32
			bpe = buf + 1;
 1003a18:	f10d 0a21 	add.w	sl, sp, #33	; 0x21
 1003a1c:	e7c6      	b.n	10039ac <z_cbvprintf_impl+0x57c>
			if (conv->flag_plus) {
 1003a1e:	0719      	lsls	r1, r3, #28
			} else if (conv->flag_space) {
 1003a20:	bf5a      	itte	pl
 1003a22:	f3c3 1300 	ubfxpl	r3, r3, #4, #1
 1003a26:	015e      	lslpl	r6, r3, #5
				sign = '+';
 1003a28:	262b      	movmi	r6, #43	; 0x2b
			sint = value->sint;
 1003a2a:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
			if (sint < 0) {
 1003a2e:	2b00      	cmp	r3, #0
 1003a30:	f6bf af63 	bge.w	10038fa <z_cbvprintf_impl+0x4ca>
				value->uint = (uint_value_type)-sint;
 1003a34:	4252      	negs	r2, r2
 1003a36:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
 1003a3a:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
 1003a3c:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
 1003a40:	e75b      	b.n	10038fa <z_cbvprintf_impl+0x4ca>
		switch (conv->specifier) {
 1003a42:	2600      	movs	r6, #0
 1003a44:	e759      	b.n	10038fa <z_cbvprintf_impl+0x4ca>
		char sign = 0;
 1003a46:	2600      	movs	r6, #0
				conv->flag_zero = false;
 1003a48:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				size_t len = bpe - bps;
 1003a4c:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 1003a50:	1bdb      	subs	r3, r3, r7
				conv->flag_zero = false;
 1003a52:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
 1003a56:	459a      	cmp	sl, r3
				conv->flag_zero = false;
 1003a58:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
				if (len < (size_t)precision) {
 1003a5c:	f67f af5b 	bls.w	1003916 <z_cbvprintf_impl+0x4e6>
					conv->pad0_value = precision - (int)len;
 1003a60:	ebaa 0303 	sub.w	r3, sl, r3
 1003a64:	9311      	str	r3, [sp, #68]	; 0x44
 1003a66:	e756      	b.n	1003916 <z_cbvprintf_impl+0x4e6>
			if (value->ptr != NULL) {
 1003a68:	980e      	ldr	r0, [sp, #56]	; 0x38
 1003a6a:	b390      	cbz	r0, 1003ad2 <z_cbvprintf_impl+0x6a2>
				bps = encode_uint((uintptr_t)value->ptr, conv,
 1003a6c:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 1003a70:	9300      	str	r3, [sp, #0]
 1003a72:	2100      	movs	r1, #0
 1003a74:	ab08      	add	r3, sp, #32
 1003a76:	aa10      	add	r2, sp, #64	; 0x40
 1003a78:	f021 f849 	bl	1024b0e <encode_uint>
				conv->altform_0c = true;
 1003a7c:	f8bd 3042 	ldrh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
 1003a80:	f1ba 0f00 	cmp.w	sl, #0
				conv->altform_0c = true;
 1003a84:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 1003a88:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
 1003a8c:	f043 0310 	orr.w	r3, r3, #16
				bps = encode_uint((uintptr_t)value->ptr, conv,
 1003a90:	4607      	mov	r7, r0
				conv->altform_0c = true;
 1003a92:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
 1003a96:	dad6      	bge.n	1003a46 <z_cbvprintf_impl+0x616>
		if (bps == NULL) {
 1003a98:	2800      	cmp	r0, #0
 1003a9a:	f43f aedc 	beq.w	1003856 <z_cbvprintf_impl+0x426>
		char sign = 0;
 1003a9e:	2600      	movs	r6, #0
		size_t nj_len = (bpe - bps);
 1003aa0:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 1003aa4:	1a18      	subs	r0, r3, r0
		if (sign != 0) {
 1003aa6:	469a      	mov	sl, r3
 1003aa8:	e780      	b.n	10039ac <z_cbvprintf_impl+0x57c>
				store_count(conv, value->ptr, count);
 1003aaa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	switch ((enum length_mod_enum)conv->length_mod) {
 1003aac:	2907      	cmp	r1, #7
 1003aae:	f63f aed2 	bhi.w	1003856 <z_cbvprintf_impl+0x426>
 1003ab2:	e8df f001 	tbb	[pc, r1]
 1003ab6:	040c      	.short	0x040c
 1003ab8:	08080c06 	.word	0x08080c06
 1003abc:	0c0c      	.short	0x0c0c
		*(signed char *)dp = (signed char)count;
 1003abe:	701d      	strb	r5, [r3, #0]
		if (bps == NULL) {
 1003ac0:	e6c9      	b.n	1003856 <z_cbvprintf_impl+0x426>
		*(short *)dp = (short)count;
 1003ac2:	801d      	strh	r5, [r3, #0]
		if (bps == NULL) {
 1003ac4:	e6c7      	b.n	1003856 <z_cbvprintf_impl+0x426>
		*(intmax_t *)dp = (intmax_t)count;
 1003ac6:	17ea      	asrs	r2, r5, #31
 1003ac8:	e9c3 5200 	strd	r5, r2, [r3]
		if (bps == NULL) {
 1003acc:	e6c3      	b.n	1003856 <z_cbvprintf_impl+0x426>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
 1003ace:	601d      	str	r5, [r3, #0]
		if (bps == NULL) {
 1003ad0:	e6c1      	b.n	1003856 <z_cbvprintf_impl+0x426>
 1003ad2:	4f2f      	ldr	r7, [pc, #188]	; (1003b90 <z_cbvprintf_impl+0x760>)
		char sign = 0;
 1003ad4:	4606      	mov	r6, r0
			bpe = bps + 5;
 1003ad6:	f107 0a05 	add.w	sl, r7, #5
		size_t nj_len = (bpe - bps);
 1003ada:	2005      	movs	r0, #5
 1003adc:	e766      	b.n	10039ac <z_cbvprintf_impl+0x57c>
		} else if (conv->altform_0) {
 1003ade:	071a      	lsls	r2, r3, #28
			nj_len += 1U;
 1003ae0:	bf48      	it	mi
 1003ae2:	3001      	addmi	r0, #1
 1003ae4:	e76a      	b.n	10039bc <z_cbvprintf_impl+0x58c>
					OUTC(pad);
 1003ae6:	4610      	mov	r0, r2
 1003ae8:	9307      	str	r3, [sp, #28]
 1003aea:	9206      	str	r2, [sp, #24]
 1003aec:	4659      	mov	r1, fp
 1003aee:	47c8      	blx	r9
 1003af0:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 1003af4:	2800      	cmp	r0, #0
 1003af6:	da04      	bge.n	1003b02 <z_cbvprintf_impl+0x6d2>
#undef OUTS
#undef OUTC
}
 1003af8:	b015      	add	sp, #84	; 0x54
 1003afa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
 1003afe:	2220      	movs	r2, #32
					pad = '0';
 1003b00:	4643      	mov	r3, r8
				while (width-- > 0) {
 1003b02:	4619      	mov	r1, r3
 1003b04:	2900      	cmp	r1, #0
 1003b06:	f103 33ff 	add.w	r3, r3, #4294967295
 1003b0a:	dcec      	bgt.n	1003ae6 <z_cbvprintf_impl+0x6b6>
 1003b0c:	4445      	add	r5, r8
 1003b0e:	4698      	mov	r8, r3
 1003b10:	1a6d      	subs	r5, r5, r1
		if (sign != 0) {
 1003b12:	b12e      	cbz	r6, 1003b20 <z_cbvprintf_impl+0x6f0>
			OUTC(sign);
 1003b14:	4659      	mov	r1, fp
 1003b16:	4630      	mov	r0, r6
 1003b18:	47c8      	blx	r9
 1003b1a:	2800      	cmp	r0, #0
 1003b1c:	dbec      	blt.n	1003af8 <z_cbvprintf_impl+0x6c8>
 1003b1e:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
 1003b20:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 1003b24:	06da      	lsls	r2, r3, #27
 1003b26:	d401      	bmi.n	1003b2c <z_cbvprintf_impl+0x6fc>
 1003b28:	071b      	lsls	r3, r3, #28
 1003b2a:	d505      	bpl.n	1003b38 <z_cbvprintf_impl+0x708>
				OUTC('0');
 1003b2c:	4659      	mov	r1, fp
 1003b2e:	2030      	movs	r0, #48	; 0x30
 1003b30:	47c8      	blx	r9
 1003b32:	2800      	cmp	r0, #0
 1003b34:	dbe0      	blt.n	1003af8 <z_cbvprintf_impl+0x6c8>
 1003b36:	3501      	adds	r5, #1
			if (conv->altform_0c) {
 1003b38:	9b05      	ldr	r3, [sp, #20]
 1003b3a:	b133      	cbz	r3, 1003b4a <z_cbvprintf_impl+0x71a>
				OUTC(conv->specifier);
 1003b3c:	4659      	mov	r1, fp
 1003b3e:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
 1003b42:	47c8      	blx	r9
 1003b44:	2800      	cmp	r0, #0
 1003b46:	dbd7      	blt.n	1003af8 <z_cbvprintf_impl+0x6c8>
 1003b48:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
 1003b4a:	9e04      	ldr	r6, [sp, #16]
 1003b4c:	442e      	add	r6, r5
 1003b4e:	e005      	b.n	1003b5c <z_cbvprintf_impl+0x72c>
				OUTC('0');
 1003b50:	4659      	mov	r1, fp
 1003b52:	2030      	movs	r0, #48	; 0x30
 1003b54:	47c8      	blx	r9
 1003b56:	2800      	cmp	r0, #0
 1003b58:	dbce      	blt.n	1003af8 <z_cbvprintf_impl+0x6c8>
 1003b5a:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
 1003b5c:	1b73      	subs	r3, r6, r5
 1003b5e:	2b00      	cmp	r3, #0
 1003b60:	dcf6      	bgt.n	1003b50 <z_cbvprintf_impl+0x720>
			OUTS(bps, bpe);
 1003b62:	4653      	mov	r3, sl
 1003b64:	463a      	mov	r2, r7
 1003b66:	4659      	mov	r1, fp
 1003b68:	4648      	mov	r0, r9
 1003b6a:	f021 f816 	bl	1024b9a <outs>
 1003b6e:	2800      	cmp	r0, #0
 1003b70:	dbc2      	blt.n	1003af8 <z_cbvprintf_impl+0x6c8>
 1003b72:	4405      	add	r5, r0
		while (width > 0) {
 1003b74:	44a8      	add	r8, r5
 1003b76:	eba8 0305 	sub.w	r3, r8, r5
 1003b7a:	2b00      	cmp	r3, #0
 1003b7c:	f77f ae6b 	ble.w	1003856 <z_cbvprintf_impl+0x426>
			OUTC(' ');
 1003b80:	4659      	mov	r1, fp
 1003b82:	2020      	movs	r0, #32
 1003b84:	47c8      	blx	r9
 1003b86:	2800      	cmp	r0, #0
 1003b88:	dbb6      	blt.n	1003af8 <z_cbvprintf_impl+0x6c8>
 1003b8a:	3501      	adds	r5, #1
			--width;
 1003b8c:	e7f3      	b.n	1003b76 <z_cbvprintf_impl+0x746>
 1003b8e:	bf00      	nop
 1003b90:	0102be51 	.word	0x0102be51

01003b94 <mpsc_pbuf_init>:
	}
}

void mpsc_pbuf_init(struct mpsc_pbuf_buffer *buffer,
		    const struct mpsc_pbuf_buffer_config *cfg)
{
 1003b94:	b538      	push	{r3, r4, r5, lr}
 1003b96:	460d      	mov	r5, r1
 1003b98:	4604      	mov	r4, r0
	int err;

	memset(buffer, 0, offsetof(struct mpsc_pbuf_buffer, buf));
 1003b9a:	2220      	movs	r2, #32
 1003b9c:	2100      	movs	r1, #0
 1003b9e:	f022 fef4 	bl	102698a <memset>
	buffer->get_wlen = cfg->get_wlen;
	buffer->notify_drop = cfg->notify_drop;
	buffer->buf = cfg->buf;
	buffer->size = cfg->size;
	buffer->max_usage = 0;
 1003ba2:	2200      	movs	r2, #0
	buffer->get_wlen = cfg->get_wlen;
 1003ba4:	68eb      	ldr	r3, [r5, #12]
 1003ba6:	61e3      	str	r3, [r4, #28]
	buffer->notify_drop = cfg->notify_drop;
 1003ba8:	68ab      	ldr	r3, [r5, #8]
 1003baa:	61a3      	str	r3, [r4, #24]
	buffer->buf = cfg->buf;
 1003bac:	682b      	ldr	r3, [r5, #0]
 1003bae:	6223      	str	r3, [r4, #32]
	buffer->size = cfg->size;
 1003bb0:	686b      	ldr	r3, [r5, #4]
	buffer->max_usage = 0;
 1003bb2:	62a2      	str	r2, [r4, #40]	; 0x28
	buffer->size = cfg->size;
 1003bb4:	6263      	str	r3, [r4, #36]	; 0x24
	buffer->flags = cfg->flags;
 1003bb6:	692a      	ldr	r2, [r5, #16]
 * @param x value to check
 * @return true if @p x is a power of two, false otherwise
 */
static inline bool is_power_of_two(unsigned int x)
{
	return (x != 0U) && ((x & (x - 1U)) == 0U);
 1003bb8:	b123      	cbz	r3, 1003bc4 <mpsc_pbuf_init+0x30>
 1003bba:	1e59      	subs	r1, r3, #1
 1003bbc:	4219      	tst	r1, r3

	if (is_power_of_two(buffer->size)) {
		buffer->flags |= MPSC_PBUF_SIZE_POW2;
 1003bbe:	bf08      	it	eq
 1003bc0:	f042 0201 	orreq.w	r2, r2, #1
	buffer->flags = cfg->flags;
 1003bc4:	6122      	str	r2, [r4, #16]
	return z_impl_k_sem_init(sem, initial_count, limit);
 1003bc6:	2201      	movs	r2, #1
 1003bc8:	2100      	movs	r1, #0
 1003bca:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 1003bce:	f025 fba2 	bl	1029316 <z_impl_k_sem_init>
	}

	err = k_sem_init(&buffer->sem, 0, 1);
	__ASSERT_NO_MSG(err == 0);
 1003bd2:	b148      	cbz	r0, 1003be8 <mpsc_pbuf_init+0x54>
 1003bd4:	4905      	ldr	r1, [pc, #20]	; (1003bec <mpsc_pbuf_init+0x58>)
 1003bd6:	4806      	ldr	r0, [pc, #24]	; (1003bf0 <mpsc_pbuf_init+0x5c>)
 1003bd8:	232e      	movs	r3, #46	; 0x2e
 1003bda:	4a06      	ldr	r2, [pc, #24]	; (1003bf4 <mpsc_pbuf_init+0x60>)
 1003bdc:	f020 fffb 	bl	1024bd6 <assert_print>
 1003be0:	212e      	movs	r1, #46	; 0x2e
 1003be2:	4804      	ldr	r0, [pc, #16]	; (1003bf4 <mpsc_pbuf_init+0x60>)
 1003be4:	f020 fff0 	bl	1024bc8 <assert_post_action>
	ARG_UNUSED(err);
}
 1003be8:	bd38      	pop	{r3, r4, r5, pc}
 1003bea:	bf00      	nop
 1003bec:	0102be7d 	.word	0x0102be7d
 1003bf0:	0102b695 	.word	0x0102b695
 1003bf4:	0102be57 	.word	0x0102be57

01003bf8 <mpsc_pbuf_alloc>:

}

union mpsc_pbuf_generic *mpsc_pbuf_alloc(struct mpsc_pbuf_buffer *buffer,
					 size_t wlen, k_timeout_t timeout)
{
 1003bf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1003bfc:	b087      	sub	sp, #28
 1003bfe:	e9cd 2301 	strd	r2, r3, [sp, #4]
	uint32_t free_wlen;
	bool valid_drop;

	MPSC_PBUF_DBG(buffer, "alloc %d words, ", (int)wlen);

	if (wlen > (buffer->size - 1)) {
 1003c02:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 1003c04:	4604      	mov	r4, r0
	if (wlen > (buffer->size - 1)) {
 1003c06:	3b01      	subs	r3, #1
 1003c08:	428b      	cmp	r3, r1
{
 1003c0a:	460f      	mov	r7, r1
	if (wlen > (buffer->size - 1)) {
 1003c0c:	f0c0 80a0 	bcc.w	1003d50 <mpsc_pbuf_alloc+0x158>
	union mpsc_pbuf_generic *dropped_item = NULL;
 1003c10:	2600      	movs	r6, #0
	union mpsc_pbuf_generic *item = NULL;
 1003c12:	46b2      	mov	sl, r6
	do {
		k_spinlock_key_t key;
		bool wrap;

		cont = false;
		key = k_spin_lock(&buffer->lock);
 1003c14:	f100 0514 	add.w	r5, r0, #20
	__asm__ volatile(
 1003c18:	f04f 0320 	mov.w	r3, #32
 1003c1c:	f3ef 8b11 	mrs	fp, BASEPRI
 1003c20:	f383 8812 	msr	BASEPRI_MAX, r3
 1003c24:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1003c28:	4628      	mov	r0, r5
	k.key = arch_irq_lock();
 1003c2a:	46d9      	mov	r9, fp
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1003c2c:	f01d fa50 	bl	10210d0 <z_spin_lock_valid>
 1003c30:	b958      	cbnz	r0, 1003c4a <mpsc_pbuf_alloc+0x52>
 1003c32:	2394      	movs	r3, #148	; 0x94
 1003c34:	4a49      	ldr	r2, [pc, #292]	; (1003d5c <mpsc_pbuf_alloc+0x164>)
 1003c36:	494a      	ldr	r1, [pc, #296]	; (1003d60 <mpsc_pbuf_alloc+0x168>)
 1003c38:	484a      	ldr	r0, [pc, #296]	; (1003d64 <mpsc_pbuf_alloc+0x16c>)
 1003c3a:	f020 ffcc 	bl	1024bd6 <assert_print>
 1003c3e:	4629      	mov	r1, r5
 1003c40:	4849      	ldr	r0, [pc, #292]	; (1003d68 <mpsc_pbuf_alloc+0x170>)
 1003c42:	f020 ffc8 	bl	1024bd6 <assert_print>
 1003c46:	2194      	movs	r1, #148	; 0x94
 1003c48:	e050      	b.n	1003cec <mpsc_pbuf_alloc+0xf4>
	z_spin_lock_set_owner(l);
 1003c4a:	4628      	mov	r0, r5
 1003c4c:	f01d fa5c 	bl	1021108 <z_spin_lock_set_owner>
		wrap = free_space(buffer, &free_wlen);
 1003c50:	a905      	add	r1, sp, #20
 1003c52:	4620      	mov	r0, r4
 1003c54:	f020 ffcc 	bl	1024bf0 <free_space>

		if (free_wlen >= wlen) {
 1003c58:	9905      	ldr	r1, [sp, #20]
		wrap = free_space(buffer, &free_wlen);
 1003c5a:	4680      	mov	r8, r0
		if (free_wlen >= wlen) {
 1003c5c:	42b9      	cmp	r1, r7
 1003c5e:	d328      	bcc.n	1003cb2 <mpsc_pbuf_alloc+0xba>
			item =
			    (union mpsc_pbuf_generic *)&buffer->buf[buffer->tmp_wr_idx];
 1003c60:	6822      	ldr	r2, [r4, #0]
			item =
 1003c62:	6a23      	ldr	r3, [r4, #32]
			item->hdr.valid = 0;
			item->hdr.busy = 0;
			buffer->tmp_wr_idx = idx_inc(buffer,
 1003c64:	4620      	mov	r0, r4
			item->hdr.valid = 0;
 1003c66:	f813 1022 	ldrb.w	r1, [r3, r2, lsl #2]
			item =
 1003c6a:	eb03 0a82 	add.w	sl, r3, r2, lsl #2
			item->hdr.valid = 0;
 1003c6e:	f021 0103 	bic.w	r1, r1, #3
 1003c72:	f803 1022 	strb.w	r1, [r3, r2, lsl #2]
			buffer->tmp_wr_idx = idx_inc(buffer,
 1003c76:	6821      	ldr	r1, [r4, #0]
 1003c78:	463a      	mov	r2, r7
 1003c7a:	f020 ffdb 	bl	1024c34 <idx_inc>
		cont = false;
 1003c7e:	f04f 0800 	mov.w	r8, #0
			buffer->tmp_wr_idx = idx_inc(buffer,
 1003c82:	6020      	str	r0, [r4, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1003c84:	4628      	mov	r0, r5
 1003c86:	f01d fa31 	bl	10210ec <z_spin_unlock_valid>
 1003c8a:	b320      	cbz	r0, 1003cd6 <mpsc_pbuf_alloc+0xde>
	__asm__ volatile(
 1003c8c:	f389 8811 	msr	BASEPRI, r9
 1003c90:	f3bf 8f6f 	isb	sy
			cont = dropped_item != NULL;
		}

		k_spin_unlock(&buffer->lock, key);

		if (cont && dropped_item && valid_drop) {
 1003c94:	f1b8 0f00 	cmp.w	r8, #0
 1003c98:	d05c      	beq.n	1003d54 <mpsc_pbuf_alloc+0x15c>
 1003c9a:	b146      	cbz	r6, 1003cae <mpsc_pbuf_alloc+0xb6>
 1003c9c:	f89d 3013 	ldrb.w	r3, [sp, #19]
 1003ca0:	2b00      	cmp	r3, #0
 1003ca2:	d0b9      	beq.n	1003c18 <mpsc_pbuf_alloc+0x20>
			/* Notify about item being dropped. */
			if (buffer->notify_drop) {
 1003ca4:	69a3      	ldr	r3, [r4, #24]
 1003ca6:	b113      	cbz	r3, 1003cae <mpsc_pbuf_alloc+0xb6>
				buffer->notify_drop(buffer, dropped_item);
 1003ca8:	4631      	mov	r1, r6
 1003caa:	4620      	mov	r0, r4
 1003cac:	4798      	blx	r3
{
 1003cae:	2600      	movs	r6, #0
 1003cb0:	e7b2      	b.n	1003c18 <mpsc_pbuf_alloc+0x20>
		} else if (wrap) {
 1003cb2:	b118      	cbz	r0, 1003cbc <mpsc_pbuf_alloc+0xc4>
			add_skip_item(buffer, free_wlen);
 1003cb4:	4620      	mov	r0, r4
 1003cb6:	f020 ffcb 	bl	1024c50 <add_skip_item>
			cont = true;
 1003cba:	e7e3      	b.n	1003c84 <mpsc_pbuf_alloc+0x8c>
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
 1003cbc:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 1003cc0:	4313      	orrs	r3, r2
 1003cc2:	d036      	beq.n	1003d32 <mpsc_pbuf_alloc+0x13a>
 1003cc4:	9103      	str	r1, [sp, #12]
			   !k_is_in_isr()) {
 1003cc6:	f025 fadc 	bl	1029282 <k_is_in_isr>
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
 1003cca:	9903      	ldr	r1, [sp, #12]
 1003ccc:	bb88      	cbnz	r0, 1003d32 <mpsc_pbuf_alloc+0x13a>
 1003cce:	4628      	mov	r0, r5
 1003cd0:	f01d fa0c 	bl	10210ec <z_spin_unlock_valid>
 1003cd4:	b968      	cbnz	r0, 1003cf2 <mpsc_pbuf_alloc+0xfa>
 1003cd6:	23c2      	movs	r3, #194	; 0xc2
 1003cd8:	4a20      	ldr	r2, [pc, #128]	; (1003d5c <mpsc_pbuf_alloc+0x164>)
 1003cda:	4924      	ldr	r1, [pc, #144]	; (1003d6c <mpsc_pbuf_alloc+0x174>)
 1003cdc:	4821      	ldr	r0, [pc, #132]	; (1003d64 <mpsc_pbuf_alloc+0x16c>)
 1003cde:	f020 ff7a 	bl	1024bd6 <assert_print>
 1003ce2:	4629      	mov	r1, r5
 1003ce4:	4822      	ldr	r0, [pc, #136]	; (1003d70 <mpsc_pbuf_alloc+0x178>)
 1003ce6:	f020 ff76 	bl	1024bd6 <assert_print>
 1003cea:	21c2      	movs	r1, #194	; 0xc2
 1003cec:	481b      	ldr	r0, [pc, #108]	; (1003d5c <mpsc_pbuf_alloc+0x164>)
 1003cee:	f020 ff6b 	bl	1024bc8 <assert_post_action>
 1003cf2:	f38b 8811 	msr	BASEPRI, fp
 1003cf6:	f3bf 8f6f 	isb	sy
	return z_impl_k_sem_take(sem, timeout);
 1003cfa:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 1003cfe:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
 1003d02:	f01d fd11 	bl	1021728 <z_impl_k_sem_take>
 1003d06:	4680      	mov	r8, r0
	__asm__ volatile(
 1003d08:	f04f 0320 	mov.w	r3, #32
 1003d0c:	f3ef 8911 	mrs	r9, BASEPRI
 1003d10:	f383 8812 	msr	BASEPRI_MAX, r3
 1003d14:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1003d18:	4628      	mov	r0, r5
 1003d1a:	f01d f9d9 	bl	10210d0 <z_spin_lock_valid>
 1003d1e:	2800      	cmp	r0, #0
 1003d20:	d087      	beq.n	1003c32 <mpsc_pbuf_alloc+0x3a>
			if (err == 0) {
 1003d22:	fab8 f888 	clz	r8, r8
	z_spin_lock_set_owner(l);
 1003d26:	4628      	mov	r0, r5
 1003d28:	f01d f9ee 	bl	1021108 <z_spin_lock_set_owner>
 1003d2c:	ea4f 1858 	mov.w	r8, r8, lsr #5
 1003d30:	e7a8      	b.n	1003c84 <mpsc_pbuf_alloc+0x8c>
			bool user_drop = buffer->flags & MPSC_PBUF_MODE_OVERWRITE;
 1003d32:	6922      	ldr	r2, [r4, #16]
			dropped_item = drop_item_locked(buffer, free_wlen,
 1003d34:	4620      	mov	r0, r4
 1003d36:	f10d 0313 	add.w	r3, sp, #19
 1003d3a:	f3c2 0240 	ubfx	r2, r2, #1, #1
 1003d3e:	f020 ffaa 	bl	1024c96 <drop_item_locked>
			cont = dropped_item != NULL;
 1003d42:	f1b0 0800 	subs.w	r8, r0, #0
 1003d46:	4606      	mov	r6, r0
 1003d48:	bf18      	it	ne
 1003d4a:	f04f 0801 	movne.w	r8, #1
 1003d4e:	e799      	b.n	1003c84 <mpsc_pbuf_alloc+0x8c>
		return NULL;
 1003d50:	f04f 0a00 	mov.w	sl, #0
		/* During test fill with 0's to simplify message comparison */
		memset(item, 0, sizeof(int) * wlen);
	}

	return item;
}
 1003d54:	4650      	mov	r0, sl
 1003d56:	b007      	add	sp, #28
 1003d58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1003d5c:	0102bd8a 	.word	0x0102bd8a
 1003d60:	0102bde3 	.word	0x0102bde3
 1003d64:	0102b695 	.word	0x0102b695
 1003d68:	0102bdf8 	.word	0x0102bdf8
 1003d6c:	0102bdb7 	.word	0x0102bdb7
 1003d70:	0102bdce 	.word	0x0102bdce

01003d74 <mpsc_pbuf_commit>:

void mpsc_pbuf_commit(struct mpsc_pbuf_buffer *buffer,
		       union mpsc_pbuf_generic *item)
{
 1003d74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1003d78:	4604      	mov	r4, r0
	uint32_t wlen = buffer->get_wlen(item);
 1003d7a:	69c3      	ldr	r3, [r0, #28]
 1003d7c:	4608      	mov	r0, r1
{
 1003d7e:	460e      	mov	r6, r1
	uint32_t wlen = buffer->get_wlen(item);
 1003d80:	4798      	blx	r3

	k_spinlock_key_t key = k_spin_lock(&buffer->lock);
 1003d82:	f104 0514 	add.w	r5, r4, #20
	uint32_t wlen = buffer->get_wlen(item);
 1003d86:	4607      	mov	r7, r0
 1003d88:	f04f 0320 	mov.w	r3, #32
 1003d8c:	f3ef 8811 	mrs	r8, BASEPRI
 1003d90:	f383 8812 	msr	BASEPRI_MAX, r3
 1003d94:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1003d98:	4628      	mov	r0, r5
 1003d9a:	f01d f999 	bl	10210d0 <z_spin_lock_valid>
 1003d9e:	b968      	cbnz	r0, 1003dbc <mpsc_pbuf_commit+0x48>
 1003da0:	2394      	movs	r3, #148	; 0x94
 1003da2:	4a19      	ldr	r2, [pc, #100]	; (1003e08 <mpsc_pbuf_commit+0x94>)
 1003da4:	4919      	ldr	r1, [pc, #100]	; (1003e0c <mpsc_pbuf_commit+0x98>)
 1003da6:	481a      	ldr	r0, [pc, #104]	; (1003e10 <mpsc_pbuf_commit+0x9c>)
 1003da8:	f020 ff15 	bl	1024bd6 <assert_print>
 1003dac:	4629      	mov	r1, r5
 1003dae:	4819      	ldr	r0, [pc, #100]	; (1003e14 <mpsc_pbuf_commit+0xa0>)
 1003db0:	f020 ff11 	bl	1024bd6 <assert_print>
 1003db4:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1003db6:	4814      	ldr	r0, [pc, #80]	; (1003e08 <mpsc_pbuf_commit+0x94>)
 1003db8:	f020 ff06 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1003dbc:	4628      	mov	r0, r5
 1003dbe:	f01d f9a3 	bl	1021108 <z_spin_lock_set_owner>

	item->hdr.valid = 1;
 1003dc2:	7833      	ldrb	r3, [r6, #0]
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
 1003dc4:	463a      	mov	r2, r7
	item->hdr.valid = 1;
 1003dc6:	f043 0301 	orr.w	r3, r3, #1
 1003dca:	7033      	strb	r3, [r6, #0]
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
 1003dcc:	6861      	ldr	r1, [r4, #4]
 1003dce:	4620      	mov	r0, r4
 1003dd0:	f020 ff30 	bl	1024c34 <idx_inc>
 1003dd4:	6060      	str	r0, [r4, #4]
	max_utilization_update(buffer);
 1003dd6:	4620      	mov	r0, r4
 1003dd8:	f020 ff50 	bl	1024c7c <max_utilization_update>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1003ddc:	4628      	mov	r0, r5
 1003dde:	f01d f985 	bl	10210ec <z_spin_unlock_valid>
 1003de2:	b958      	cbnz	r0, 1003dfc <mpsc_pbuf_commit+0x88>
 1003de4:	23c2      	movs	r3, #194	; 0xc2
 1003de6:	4a08      	ldr	r2, [pc, #32]	; (1003e08 <mpsc_pbuf_commit+0x94>)
 1003de8:	490b      	ldr	r1, [pc, #44]	; (1003e18 <mpsc_pbuf_commit+0xa4>)
 1003dea:	4809      	ldr	r0, [pc, #36]	; (1003e10 <mpsc_pbuf_commit+0x9c>)
 1003dec:	f020 fef3 	bl	1024bd6 <assert_print>
 1003df0:	4629      	mov	r1, r5
 1003df2:	480a      	ldr	r0, [pc, #40]	; (1003e1c <mpsc_pbuf_commit+0xa8>)
 1003df4:	f020 feef 	bl	1024bd6 <assert_print>
 1003df8:	21c2      	movs	r1, #194	; 0xc2
 1003dfa:	e7dc      	b.n	1003db6 <mpsc_pbuf_commit+0x42>
	__asm__ volatile(
 1003dfc:	f388 8811 	msr	BASEPRI, r8
 1003e00:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&buffer->lock, key);
	MPSC_PBUF_DBG(buffer, "committed %p ", item);
}
 1003e04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 1003e08:	0102bd8a 	.word	0x0102bd8a
 1003e0c:	0102bde3 	.word	0x0102bde3
 1003e10:	0102b695 	.word	0x0102b695
 1003e14:	0102bdf8 	.word	0x0102bdf8
 1003e18:	0102bdb7 	.word	0x0102bdb7
 1003e1c:	0102bdce 	.word	0x0102bdce

01003e20 <mpsc_pbuf_claim>:
		}
	} while (cont);
}

const union mpsc_pbuf_generic *mpsc_pbuf_claim(struct mpsc_pbuf_buffer *buffer)
{
 1003e20:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1003e24:	4604      	mov	r4, r0
	do {
		uint32_t a;
		k_spinlock_key_t key;

		cont = false;
		key = k_spin_lock(&buffer->lock);
 1003e26:	f100 0714 	add.w	r7, r0, #20
	__asm__ volatile(
 1003e2a:	f04f 0320 	mov.w	r3, #32
 1003e2e:	f3ef 8811 	mrs	r8, BASEPRI
 1003e32:	f383 8812 	msr	BASEPRI_MAX, r3
 1003e36:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1003e3a:	4638      	mov	r0, r7
 1003e3c:	f01d f948 	bl	10210d0 <z_spin_lock_valid>
 1003e40:	4605      	mov	r5, r0
 1003e42:	b968      	cbnz	r0, 1003e60 <mpsc_pbuf_claim+0x40>
 1003e44:	2394      	movs	r3, #148	; 0x94
 1003e46:	4a33      	ldr	r2, [pc, #204]	; (1003f14 <mpsc_pbuf_claim+0xf4>)
 1003e48:	4933      	ldr	r1, [pc, #204]	; (1003f18 <mpsc_pbuf_claim+0xf8>)
 1003e4a:	4834      	ldr	r0, [pc, #208]	; (1003f1c <mpsc_pbuf_claim+0xfc>)
 1003e4c:	f020 fec3 	bl	1024bd6 <assert_print>
 1003e50:	4639      	mov	r1, r7
 1003e52:	4833      	ldr	r0, [pc, #204]	; (1003f20 <mpsc_pbuf_claim+0x100>)
 1003e54:	f020 febf 	bl	1024bd6 <assert_print>
 1003e58:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1003e5a:	482e      	ldr	r0, [pc, #184]	; (1003f14 <mpsc_pbuf_claim+0xf4>)
 1003e5c:	f020 feb4 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1003e60:	4638      	mov	r0, r7
 1003e62:	f01d f951 	bl	1021108 <z_spin_lock_set_owner>
	if (buffer->tmp_rd_idx <= buffer->wr_idx) {
 1003e66:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
 1003e6a:	429a      	cmp	r2, r3
	*res = buffer->size - buffer->tmp_rd_idx;
 1003e6c:	bf88      	it	hi
 1003e6e:	6a63      	ldrhi	r3, [r4, #36]	; 0x24
 1003e70:	1a9b      	subs	r3, r3, r2
		(void)available(buffer, &a);
		item = (union mpsc_pbuf_generic *)
			&buffer->buf[buffer->tmp_rd_idx];

		if (!a || is_invalid(item)) {
 1003e72:	2b00      	cmp	r3, #0
 1003e74:	d03f      	beq.n	1003ef6 <mpsc_pbuf_claim+0xd6>
		item = (union mpsc_pbuf_generic *)
 1003e76:	6a21      	ldr	r1, [r4, #32]
	return !item->hdr.valid && !item->hdr.busy;
 1003e78:	f811 3022 	ldrb.w	r3, [r1, r2, lsl #2]
		item = (union mpsc_pbuf_generic *)
 1003e7c:	eb01 0982 	add.w	r9, r1, r2, lsl #2
		if (!a || is_invalid(item)) {
 1003e80:	f013 0003 	ands.w	r0, r3, #3
 1003e84:	d03a      	beq.n	1003efc <mpsc_pbuf_claim+0xdc>
	if (item->hdr.busy && !item->hdr.valid) {
 1003e86:	2802      	cmp	r0, #2
 1003e88:	d103      	bne.n	1003e92 <mpsc_pbuf_claim+0x72>
		return item->skip.len;
 1003e8a:	f851 6022 	ldr.w	r6, [r1, r2, lsl #2]
			item = NULL;
		} else {
			uint32_t skip = get_skip(item);

			if (skip || !is_valid(item)) {
 1003e8e:	08b6      	lsrs	r6, r6, #2
 1003e90:	d105      	bne.n	1003e9e <mpsc_pbuf_claim+0x7e>
 1003e92:	07d8      	lsls	r0, r3, #31
 1003e94:	d41f      	bmi.n	1003ed6 <mpsc_pbuf_claim+0xb6>
				uint32_t inc =
					skip ? skip : buffer->get_wlen(item);
 1003e96:	4648      	mov	r0, r9
 1003e98:	69e3      	ldr	r3, [r4, #28]
 1003e9a:	4798      	blx	r3
 1003e9c:	4606      	mov	r6, r0

				buffer->tmp_rd_idx =
				      idx_inc(buffer, buffer->tmp_rd_idx, inc);
 1003e9e:	68a1      	ldr	r1, [r4, #8]
 1003ea0:	4632      	mov	r2, r6
 1003ea2:	4620      	mov	r0, r4
 1003ea4:	f020 fec6 	bl	1024c34 <idx_inc>
				buffer->rd_idx =
					idx_inc(buffer, buffer->rd_idx, inc);
 1003ea8:	68e1      	ldr	r1, [r4, #12]
				buffer->tmp_rd_idx =
 1003eaa:	60a0      	str	r0, [r4, #8]
					idx_inc(buffer, buffer->rd_idx, inc);
 1003eac:	4632      	mov	r2, r6
 1003eae:	4620      	mov	r0, r4
 1003eb0:	f020 fec0 	bl	1024c34 <idx_inc>
				buffer->rd_idx =
 1003eb4:	60e0      	str	r0, [r4, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1003eb6:	4638      	mov	r0, r7
 1003eb8:	f01d f918 	bl	10210ec <z_spin_unlock_valid>
 1003ebc:	bb00      	cbnz	r0, 1003f00 <mpsc_pbuf_claim+0xe0>
 1003ebe:	23c2      	movs	r3, #194	; 0xc2
 1003ec0:	4a14      	ldr	r2, [pc, #80]	; (1003f14 <mpsc_pbuf_claim+0xf4>)
 1003ec2:	4918      	ldr	r1, [pc, #96]	; (1003f24 <mpsc_pbuf_claim+0x104>)
 1003ec4:	4815      	ldr	r0, [pc, #84]	; (1003f1c <mpsc_pbuf_claim+0xfc>)
 1003ec6:	f020 fe86 	bl	1024bd6 <assert_print>
 1003eca:	4639      	mov	r1, r7
 1003ecc:	4816      	ldr	r0, [pc, #88]	; (1003f28 <mpsc_pbuf_claim+0x108>)
 1003ece:	f020 fe82 	bl	1024bd6 <assert_print>
 1003ed2:	21c2      	movs	r1, #194	; 0xc2
 1003ed4:	e7c1      	b.n	1003e5a <mpsc_pbuf_claim+0x3a>
				cont = true;
			} else {
				item->hdr.busy = 1;
 1003ed6:	f043 0302 	orr.w	r3, r3, #2
 1003eda:	f801 3022 	strb.w	r3, [r1, r2, lsl #2]
				buffer->tmp_rd_idx =
					idx_inc(buffer, buffer->tmp_rd_idx,
 1003ede:	69e3      	ldr	r3, [r4, #28]
 1003ee0:	4648      	mov	r0, r9
 1003ee2:	68a5      	ldr	r5, [r4, #8]
 1003ee4:	4798      	blx	r3
 1003ee6:	4629      	mov	r1, r5
 1003ee8:	4602      	mov	r2, r0
 1003eea:	4620      	mov	r0, r4
 1003eec:	f020 fea2 	bl	1024c34 <idx_inc>
		cont = false;
 1003ef0:	2500      	movs	r5, #0
				buffer->tmp_rd_idx =
 1003ef2:	60a0      	str	r0, [r4, #8]
 1003ef4:	e7df      	b.n	1003eb6 <mpsc_pbuf_claim+0x96>
		cont = false;
 1003ef6:	461d      	mov	r5, r3
			item = NULL;
 1003ef8:	46a9      	mov	r9, r5
 1003efa:	e7dc      	b.n	1003eb6 <mpsc_pbuf_claim+0x96>
		cont = false;
 1003efc:	4605      	mov	r5, r0
 1003efe:	e7fb      	b.n	1003ef8 <mpsc_pbuf_claim+0xd8>
	__asm__ volatile(
 1003f00:	f388 8811 	msr	BASEPRI, r8
 1003f04:	f3bf 8f6f 	isb	sy

		if (!cont) {
			MPSC_PBUF_DBG(buffer, "claimed: %p ", item);
		}
		k_spin_unlock(&buffer->lock, key);
	} while (cont);
 1003f08:	2d00      	cmp	r5, #0
 1003f0a:	d18e      	bne.n	1003e2a <mpsc_pbuf_claim+0xa>

	return item;
}
 1003f0c:	4648      	mov	r0, r9
 1003f0e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 1003f12:	bf00      	nop
 1003f14:	0102bd8a 	.word	0x0102bd8a
 1003f18:	0102bde3 	.word	0x0102bde3
 1003f1c:	0102b695 	.word	0x0102b695
 1003f20:	0102bdf8 	.word	0x0102bdf8
 1003f24:	0102bdb7 	.word	0x0102bdb7
 1003f28:	0102bdce 	.word	0x0102bdce

01003f2c <mpsc_pbuf_free>:

void mpsc_pbuf_free(struct mpsc_pbuf_buffer *buffer,
		     const union mpsc_pbuf_generic *item)
{
 1003f2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1003f30:	4604      	mov	r4, r0
	uint32_t wlen = buffer->get_wlen(item);
 1003f32:	69c3      	ldr	r3, [r0, #28]
 1003f34:	4608      	mov	r0, r1
{
 1003f36:	460d      	mov	r5, r1
	uint32_t wlen = buffer->get_wlen(item);
 1003f38:	4798      	blx	r3
	k_spinlock_key_t key = k_spin_lock(&buffer->lock);
 1003f3a:	f104 0614 	add.w	r6, r4, #20
	uint32_t wlen = buffer->get_wlen(item);
 1003f3e:	4607      	mov	r7, r0
	__asm__ volatile(
 1003f40:	f04f 0320 	mov.w	r3, #32
 1003f44:	f3ef 8811 	mrs	r8, BASEPRI
 1003f48:	f383 8812 	msr	BASEPRI_MAX, r3
 1003f4c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1003f50:	4630      	mov	r0, r6
 1003f52:	f01d f8bd 	bl	10210d0 <z_spin_lock_valid>
 1003f56:	b968      	cbnz	r0, 1003f74 <mpsc_pbuf_free+0x48>
 1003f58:	2394      	movs	r3, #148	; 0x94
 1003f5a:	4a23      	ldr	r2, [pc, #140]	; (1003fe8 <mpsc_pbuf_free+0xbc>)
 1003f5c:	4923      	ldr	r1, [pc, #140]	; (1003fec <mpsc_pbuf_free+0xc0>)
 1003f5e:	4824      	ldr	r0, [pc, #144]	; (1003ff0 <mpsc_pbuf_free+0xc4>)
 1003f60:	f020 fe39 	bl	1024bd6 <assert_print>
 1003f64:	4631      	mov	r1, r6
 1003f66:	4823      	ldr	r0, [pc, #140]	; (1003ff4 <mpsc_pbuf_free+0xc8>)
 1003f68:	f020 fe35 	bl	1024bd6 <assert_print>
 1003f6c:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1003f6e:	481e      	ldr	r0, [pc, #120]	; (1003fe8 <mpsc_pbuf_free+0xbc>)
 1003f70:	f020 fe2a 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1003f74:	4630      	mov	r0, r6
 1003f76:	f01d f8c7 	bl	1021108 <z_spin_lock_set_owner>
	union mpsc_pbuf_generic *witem = (union mpsc_pbuf_generic *)item;

	witem->hdr.valid = 0;
 1003f7a:	782b      	ldrb	r3, [r5, #0]
 1003f7c:	f36f 0300 	bfc	r3, #0, #1
 1003f80:	702b      	strb	r3, [r5, #0]
	if (!(buffer->flags & MPSC_PBUF_MODE_OVERWRITE) ||
 1003f82:	6923      	ldr	r3, [r4, #16]
 1003f84:	079b      	lsls	r3, r3, #30
 1003f86:	d505      	bpl.n	1003f94 <mpsc_pbuf_free+0x68>
		 ((uint32_t *)item == &buffer->buf[buffer->rd_idx])) {
 1003f88:	68e2      	ldr	r2, [r4, #12]
 1003f8a:	6a23      	ldr	r3, [r4, #32]
 1003f8c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
	if (!(buffer->flags & MPSC_PBUF_MODE_OVERWRITE) ||
 1003f90:	429d      	cmp	r5, r3
 1003f92:	d119      	bne.n	1003fc8 <mpsc_pbuf_free+0x9c>
		witem->hdr.busy = 0;
 1003f94:	782b      	ldrb	r3, [r5, #0]
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, wlen);
 1003f96:	463a      	mov	r2, r7
		witem->hdr.busy = 0;
 1003f98:	f36f 0341 	bfc	r3, #1, #1
 1003f9c:	702b      	strb	r3, [r5, #0]
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, wlen);
 1003f9e:	68e1      	ldr	r1, [r4, #12]
 1003fa0:	4620      	mov	r0, r4
 1003fa2:	f020 fe47 	bl	1024c34 <idx_inc>
 1003fa6:	60e0      	str	r0, [r4, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1003fa8:	4630      	mov	r0, r6
 1003faa:	f01d f89f 	bl	10210ec <z_spin_unlock_valid>
 1003fae:	b980      	cbnz	r0, 1003fd2 <mpsc_pbuf_free+0xa6>
 1003fb0:	23c2      	movs	r3, #194	; 0xc2
 1003fb2:	4a0d      	ldr	r2, [pc, #52]	; (1003fe8 <mpsc_pbuf_free+0xbc>)
 1003fb4:	4910      	ldr	r1, [pc, #64]	; (1003ff8 <mpsc_pbuf_free+0xcc>)
 1003fb6:	480e      	ldr	r0, [pc, #56]	; (1003ff0 <mpsc_pbuf_free+0xc4>)
 1003fb8:	f020 fe0d 	bl	1024bd6 <assert_print>
 1003fbc:	4631      	mov	r1, r6
 1003fbe:	480f      	ldr	r0, [pc, #60]	; (1003ffc <mpsc_pbuf_free+0xd0>)
 1003fc0:	f020 fe09 	bl	1024bd6 <assert_print>
 1003fc4:	21c2      	movs	r1, #194	; 0xc2
 1003fc6:	e7d2      	b.n	1003f6e <mpsc_pbuf_free+0x42>
	} else {
		witem->skip.len = wlen;
 1003fc8:	682b      	ldr	r3, [r5, #0]
 1003fca:	f367 039f 	bfi	r3, r7, #2, #30
 1003fce:	602b      	str	r3, [r5, #0]
 1003fd0:	e7ea      	b.n	1003fa8 <mpsc_pbuf_free+0x7c>
	__asm__ volatile(
 1003fd2:	f388 8811 	msr	BASEPRI, r8
 1003fd6:	f3bf 8f6f 	isb	sy
	z_impl_k_sem_give(sem);
 1003fda:	f104 002c 	add.w	r0, r4, #44	; 0x2c
	}
	MPSC_PBUF_DBG(buffer, "freed: %p ", item);

	k_spin_unlock(&buffer->lock, key);
	k_sem_give(&buffer->sem);
}
 1003fde:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 1003fe2:	f01d bb5d 	b.w	10216a0 <z_impl_k_sem_give>
 1003fe6:	bf00      	nop
 1003fe8:	0102bd8a 	.word	0x0102bd8a
 1003fec:	0102bde3 	.word	0x0102bde3
 1003ff0:	0102b695 	.word	0x0102b695
 1003ff4:	0102bdf8 	.word	0x0102bdf8
 1003ff8:	0102bdb7 	.word	0x0102bdb7
 1003ffc:	0102bdce 	.word	0x0102bdce

01004000 <nordicsemi_nrf53_init>:
	__asm__ volatile(
 1004000:	f04f 0220 	mov.w	r2, #32
 1004004:	f3ef 8311 	mrs	r3, BASEPRI
 1004008:	f382 8812 	msr	BASEPRI_MAX, r2
 100400c:	f3bf 8f6f 	isb	sy
        NRFX_CRITICAL_SECTION_EXIT();
    }
    else
#endif
    {
        p_reg->ICACHECNF = (uint32_t)config;
 1004010:	2101      	movs	r1, #1
 1004012:	4a04      	ldr	r2, [pc, #16]	; (1004024 <nordicsemi_nrf53_init+0x24>)
 1004014:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
 1004018:	f383 8811 	msr	BASEPRI, r3
 100401c:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
 1004020:	2000      	movs	r0, #0
 1004022:	4770      	bx	lr
 1004024:	41080000 	.word	0x41080000

01004028 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
 1004028:	b120      	cbz	r0, 1004034 <arch_busy_wait+0xc>
    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
 100402a:	4b03      	ldr	r3, [pc, #12]	; (1004038 <arch_busy_wait+0x10>)
 100402c:	0180      	lsls	r0, r0, #6
 100402e:	f043 0301 	orr.w	r3, r3, #1
 1004032:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
 1004034:	4770      	bx	lr
 1004036:	bf00      	nop
 1004038:	01029b90 	.word	0x01029b90

0100403c <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
 100403c:	f01b bc02 	b.w	101f844 <SystemInit>

01004040 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
 1004040:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
 1004042:	2200      	movs	r2, #0
{
 1004044:	b089      	sub	sp, #36	; 0x24
		k_timer_init(&log_process_thread_timer,
 1004046:	490f      	ldr	r1, [pc, #60]	; (1004084 <enable_logger+0x44>)
 1004048:	480f      	ldr	r0, [pc, #60]	; (1004088 <enable_logger+0x48>)
 100404a:	f025 fa35 	bl	10294b8 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 100404e:	2200      	movs	r2, #0
 1004050:	2300      	movs	r3, #0
 1004052:	2400      	movs	r4, #0
 1004054:	e9cd 2306 	strd	r2, r3, [sp, #24]
 1004058:	230e      	movs	r3, #14
 100405a:	4d0c      	ldr	r5, [pc, #48]	; (100408c <enable_logger+0x4c>)
 100405c:	e9cd 3403 	strd	r3, r4, [sp, #12]
 1004060:	f44f 6200 	mov.w	r2, #2048	; 0x800
 1004064:	4628      	mov	r0, r5
 1004066:	e9cd 4401 	strd	r4, r4, [sp, #4]
 100406a:	4b09      	ldr	r3, [pc, #36]	; (1004090 <enable_logger+0x50>)
 100406c:	4909      	ldr	r1, [pc, #36]	; (1004094 <enable_logger+0x54>)
 100406e:	9400      	str	r4, [sp, #0]
 1004070:	f01c ff64 	bl	1020f3c <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
 1004074:	4908      	ldr	r1, [pc, #32]	; (1004098 <enable_logger+0x58>)
 1004076:	4628      	mov	r0, r5
 1004078:	f025 f909 	bl	102928e <z_impl_k_thread_name_set>
	} else {
		(void)z_log_init(false, false);
	}

	return 0;
}
 100407c:	4620      	mov	r0, r4
 100407e:	b009      	add	sp, #36	; 0x24
 1004080:	bd30      	pop	{r4, r5, pc}
 1004082:	bf00      	nop
 1004084:	010041e1 	.word	0x010041e1
 1004088:	21001470 	.word	0x21001470
 100408c:	21000fe8 	.word	0x21000fe8
 1004090:	010044b1 	.word	0x010044b1
 1004094:	21008f70 	.word	0x21008f70
 1004098:	0102be8a 	.word	0x0102be8a

0100409c <activate_foreach_backend>:
{
 100409c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 10040a0:	4604      	mov	r4, r0
	while (mask_cpy) {
 10040a2:	4607      	mov	r7, r0
		mask_cpy &= ~BIT(i);
 10040a4:	f04f 0901 	mov.w	r9, #1
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
 10040a8:	f8df 8050 	ldr.w	r8, [pc, #80]	; 10040fc <activate_foreach_backend+0x60>
	while (mask_cpy) {
 10040ac:	b914      	cbnz	r4, 10040b4 <activate_foreach_backend+0x18>
}
 10040ae:	4638      	mov	r0, r7
 10040b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uint32_t i = __builtin_ctz(mask_cpy);
 10040b4:	fa94 f5a4 	rbit	r5, r4
 10040b8:	fab5 f585 	clz	r5, r5
		mask_cpy &= ~BIT(i);
 10040bc:	fa09 f305 	lsl.w	r3, r9, r5
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
 10040c0:	012e      	lsls	r6, r5, #4
 10040c2:	eb08 1505 	add.w	r5, r8, r5, lsl #4
		mask_cpy &= ~BIT(i);
 10040c6:	ea6f 0a03 	mvn.w	sl, r3
 10040ca:	ea24 0403 	bic.w	r4, r4, r3
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
 10040ce:	7b2b      	ldrb	r3, [r5, #12]
 10040d0:	2b00      	cmp	r3, #0
 10040d2:	d0eb      	beq.n	10040ac <activate_foreach_backend+0x10>
 * @retval -EBUSY if backend is not yet ready.
 */
static inline int log_backend_is_ready(const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	if (backend->api->is_ready != NULL) {
 10040d4:	f858 3006 	ldr.w	r3, [r8, r6]
 10040d8:	691b      	ldr	r3, [r3, #16]
 10040da:	b94b      	cbnz	r3, 10040f0 <activate_foreach_backend+0x54>
					   backend->cb->ctx,
 10040dc:	4446      	add	r6, r8
			log_backend_enable(backend,
 10040de:	6873      	ldr	r3, [r6, #4]
 10040e0:	2204      	movs	r2, #4
 10040e2:	4628      	mov	r0, r5
 10040e4:	6819      	ldr	r1, [r3, #0]
			mask &= ~BIT(i);
 10040e6:	ea07 070a 	and.w	r7, r7, sl
			log_backend_enable(backend,
 10040ea:	f000 fae7 	bl	10046bc <log_backend_enable>
 10040ee:	e7dd      	b.n	10040ac <activate_foreach_backend+0x10>
		return backend->api->is_ready(backend);
 10040f0:	4628      	mov	r0, r5
 10040f2:	4798      	blx	r3
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
 10040f4:	2800      	cmp	r0, #0
 10040f6:	d1d9      	bne.n	10040ac <activate_foreach_backend+0x10>
 10040f8:	e7f0      	b.n	10040dc <activate_foreach_backend+0x40>
 10040fa:	bf00      	nop
 10040fc:	01029a6c 	.word	0x01029a6c

01004100 <z_log_init>:
{
 1004100:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 */
static inline int log_backend_count_get(void)
{
	int cnt;

	STRUCT_SECTION_COUNT(log_backend, &cnt);
 1004104:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 10041c0 <z_log_init+0xc0>
 1004108:	4c2e      	ldr	r4, [pc, #184]	; (10041c4 <z_log_init+0xc4>)
 100410a:	4680      	mov	r8, r0
 100410c:	eba9 0304 	sub.w	r3, r9, r4
	__ASSERT_NO_MSG(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
 1004110:	2b9f      	cmp	r3, #159	; 0x9f
{
 1004112:	460f      	mov	r7, r1
	__ASSERT_NO_MSG(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
 1004114:	d90b      	bls.n	100412e <z_log_init+0x2e>
 1004116:	492c      	ldr	r1, [pc, #176]	; (10041c8 <z_log_init+0xc8>)
 1004118:	f240 1315 	movw	r3, #277	; 0x115
 100411c:	4a2b      	ldr	r2, [pc, #172]	; (10041cc <z_log_init+0xcc>)
 100411e:	482c      	ldr	r0, [pc, #176]	; (10041d0 <z_log_init+0xd0>)
 1004120:	f020 fd59 	bl	1024bd6 <assert_print>
 1004124:	f240 1115 	movw	r1, #277	; 0x115
	STRUCT_SECTION_FOREACH(log_backend, backend) {
 1004128:	4828      	ldr	r0, [pc, #160]	; (10041cc <z_log_init+0xcc>)
 100412a:	f020 fd4d 	bl	1024bc8 <assert_post_action>
	if (atomic_inc(&initialized) != 0) {
 100412e:	4829      	ldr	r0, [pc, #164]	; (10041d4 <z_log_init+0xd4>)
 1004130:	f020 fe2b 	bl	1024d8a <atomic_inc>
 1004134:	4606      	mov	r6, r0
 1004136:	b360      	cbz	r0, 1004192 <z_log_init+0x92>
	uint32_t mask = 0;
 1004138:	2500      	movs	r5, #0
}
 100413a:	4628      	mov	r0, r5
 100413c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (backend->autostart) {
 1004140:	7b23      	ldrb	r3, [r4, #12]
 1004142:	b173      	cbz	r3, 1004162 <z_log_init+0x62>
	if (backend->api->init) {
 1004144:	6823      	ldr	r3, [r4, #0]
 1004146:	68db      	ldr	r3, [r3, #12]
 1004148:	b10b      	cbz	r3, 100414e <z_log_init+0x4e>
		backend->api->init(backend);
 100414a:	4620      	mov	r0, r4
 100414c:	4798      	blx	r3
	if (backend->api->is_ready != NULL) {
 100414e:	6823      	ldr	r3, [r4, #0]
 1004150:	691b      	ldr	r3, [r3, #16]
 1004152:	b9b3      	cbnz	r3, 1004182 <z_log_init+0x82>
				log_backend_enable(backend,
 1004154:	6863      	ldr	r3, [r4, #4]
 1004156:	2204      	movs	r2, #4
 1004158:	4620      	mov	r0, r4
 100415a:	6819      	ldr	r1, [r3, #0]
 100415c:	f000 faae 	bl	10046bc <log_backend_enable>
			i++;
 1004160:	3601      	adds	r6, #1
	STRUCT_SECTION_FOREACH(log_backend, backend) {
 1004162:	3410      	adds	r4, #16
 1004164:	454c      	cmp	r4, r9
 1004166:	d918      	bls.n	100419a <z_log_init+0x9a>
 1004168:	491b      	ldr	r1, [pc, #108]	; (10041d8 <z_log_init+0xd8>)
 100416a:	f44f 7391 	mov.w	r3, #290	; 0x122
 100416e:	4a17      	ldr	r2, [pc, #92]	; (10041cc <z_log_init+0xcc>)
 1004170:	4817      	ldr	r0, [pc, #92]	; (10041d0 <z_log_init+0xd0>)
 1004172:	f020 fd30 	bl	1024bd6 <assert_print>
 1004176:	4819      	ldr	r0, [pc, #100]	; (10041dc <z_log_init+0xdc>)
 1004178:	f020 fd2d 	bl	1024bd6 <assert_print>
 100417c:	f44f 7191 	mov.w	r1, #290	; 0x122
 1004180:	e7d2      	b.n	1004128 <z_log_init+0x28>
		return backend->api->is_ready(backend);
 1004182:	4620      	mov	r0, r4
 1004184:	4798      	blx	r3
			if (log_backend_is_ready(backend) == 0) {
 1004186:	2800      	cmp	r0, #0
 1004188:	d0e4      	beq.n	1004154 <z_log_init+0x54>
				mask |= BIT(i);
 100418a:	fa0a f306 	lsl.w	r3, sl, r6
 100418e:	431d      	orrs	r5, r3
 1004190:	e7e6      	b.n	1004160 <z_log_init+0x60>
	uint32_t mask = 0;
 1004192:	4605      	mov	r5, r0
				mask |= BIT(i);
 1004194:	f04f 0a01 	mov.w	sl, #1
 1004198:	e7e4      	b.n	1004164 <z_log_init+0x64>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
 100419a:	d3d1      	bcc.n	1004140 <z_log_init+0x40>
	if (blocking) {
 100419c:	f1b8 0f00 	cmp.w	r8, #0
 10041a0:	d0cb      	beq.n	100413a <z_log_init+0x3a>
		while (mask) {
 10041a2:	2d00      	cmp	r5, #0
 10041a4:	d0c8      	beq.n	1004138 <z_log_init+0x38>
			mask = activate_foreach_backend(mask);
 10041a6:	4628      	mov	r0, r5
 10041a8:	f7ff ff78 	bl	100409c <activate_foreach_backend>
 10041ac:	4605      	mov	r5, r0
			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
 10041ae:	2f00      	cmp	r7, #0
 10041b0:	d0f7      	beq.n	10041a2 <z_log_init+0xa2>
	return z_impl_k_sleep(timeout);
 10041b2:	2100      	movs	r1, #0
 10041b4:	f44f 70a4 	mov.w	r0, #328	; 0x148
 10041b8:	f01f f918 	bl	10233ec <z_impl_k_sleep>
 * @return Zero if the requested time has elapsed or the number of milliseconds
 * left to sleep, if thread was woken up by \ref k_wakeup call.
 */
static inline int32_t k_msleep(int32_t ms)
{
	return k_sleep(Z_TIMEOUT_MS(ms));
 10041bc:	e7f1      	b.n	10041a2 <z_log_init+0xa2>
 10041be:	bf00      	nop
 10041c0:	01029a7c 	.word	0x01029a7c
 10041c4:	01029a6c 	.word	0x01029a6c
 10041c8:	0102bebf 	.word	0x0102bebf
 10041cc:	0102be92 	.word	0x0102be92
 10041d0:	0102b695 	.word	0x0102b695
 10041d4:	210045ec 	.word	0x210045ec
 10041d8:	0102bee3 	.word	0x0102bee3
 10041dc:	0102bf04 	.word	0x0102bf04

010041e0 <log_process_thread_timer_expiry_fn>:
	z_impl_k_sem_give(sem);
 10041e0:	4801      	ldr	r0, [pc, #4]	; (10041e8 <log_process_thread_timer_expiry_fn+0x8>)
 10041e2:	f01d ba5d 	b.w	10216a0 <z_impl_k_sem_give>
 10041e6:	bf00      	nop
 10041e8:	21000cb0 	.word	0x21000cb0

010041ec <log_format_func_t_get>:
}
 10041ec:	4b01      	ldr	r3, [pc, #4]	; (10041f4 <log_format_func_t_get+0x8>)
 10041ee:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 10041f2:	4770      	bx	lr
 10041f4:	01029bbc 	.word	0x01029bbc

010041f8 <log_set_timestamp_func>:
{
 10041f8:	b508      	push	{r3, lr}
 10041fa:	4603      	mov	r3, r0
 10041fc:	4608      	mov	r0, r1
	if (timestamp_getter == NULL) {
 10041fe:	b12b      	cbz	r3, 100420c <log_set_timestamp_func+0x14>
	timestamp_func = timestamp_getter;
 1004200:	4a04      	ldr	r2, [pc, #16]	; (1004214 <log_set_timestamp_func+0x1c>)
 1004202:	6013      	str	r3, [r2, #0]
		log_output_timestamp_freq_set(freq);
 1004204:	f000 fd60 	bl	1004cc8 <log_output_timestamp_freq_set>
	return 0;
 1004208:	2000      	movs	r0, #0
}
 100420a:	bd08      	pop	{r3, pc}
		return -EINVAL;
 100420c:	f06f 0015 	mvn.w	r0, #21
 1004210:	e7fb      	b.n	100420a <log_set_timestamp_func+0x12>
 1004212:	bf00      	nop
 1004214:	21000274 	.word	0x21000274

01004218 <z_log_notify_backend_enabled>:
{
 1004218:	b510      	push	{r4, lr}
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
 100421a:	4c04      	ldr	r4, [pc, #16]	; (100422c <z_log_notify_backend_enabled+0x14>)
 100421c:	7823      	ldrb	r3, [r4, #0]
 100421e:	b913      	cbnz	r3, 1004226 <z_log_notify_backend_enabled+0xe>
 1004220:	4803      	ldr	r0, [pc, #12]	; (1004230 <z_log_notify_backend_enabled+0x18>)
 1004222:	f01d fa3d 	bl	10216a0 <z_impl_k_sem_give>
	backend_attached = true;
 1004226:	2301      	movs	r3, #1
 1004228:	7023      	strb	r3, [r4, #0]
}
 100422a:	bd10      	pop	{r4, pc}
 100422c:	210081f0 	.word	0x210081f0
 1004230:	21000cb0 	.word	0x21000cb0

01004234 <z_log_dropped>:
{
 1004234:	b510      	push	{r4, lr}
 1004236:	4604      	mov	r4, r0
	atomic_inc(&dropped_cnt);
 1004238:	4806      	ldr	r0, [pc, #24]	; (1004254 <z_log_dropped+0x20>)
 100423a:	f020 fda6 	bl	1024d8a <atomic_inc>
	if (buffered) {
 100423e:	b13c      	cbz	r4, 1004250 <z_log_dropped+0x1c>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 1004240:	4b05      	ldr	r3, [pc, #20]	; (1004258 <z_log_dropped+0x24>)
 1004242:	e8d3 1fef 	ldaex	r1, [r3]
 1004246:	3901      	subs	r1, #1
 1004248:	e8c3 1fe2 	stlex	r2, r1, [r3]
 100424c:	2a00      	cmp	r2, #0
 100424e:	d1f8      	bne.n	1004242 <z_log_dropped+0xe>
}
 1004250:	bd10      	pop	{r4, pc}
 1004252:	bf00      	nop
 1004254:	210045e4 	.word	0x210045e4
 1004258:	210045e8 	.word	0x210045e8

0100425c <z_log_dropped_read_and_clear>:
}
 100425c:	2000      	movs	r0, #0
 100425e:	4601      	mov	r1, r0
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 1004260:	4b03      	ldr	r3, [pc, #12]	; (1004270 <z_log_dropped_read_and_clear+0x14>)
 1004262:	e8d3 0fef 	ldaex	r0, [r3]
 1004266:	e8c3 1fe2 	stlex	r2, r1, [r3]
 100426a:	2a00      	cmp	r2, #0
 100426c:	d1f9      	bne.n	1004262 <z_log_dropped_read_and_clear+0x6>
 100426e:	4770      	bx	lr
 1004270:	210045e4 	.word	0x210045e4

01004274 <dropped_notify>:
{
 1004274:	b570      	push	{r4, r5, r6, lr}
	uint32_t dropped = z_log_dropped_read_and_clear();
 1004276:	f7ff fff1 	bl	100425c <z_log_dropped_read_and_clear>
 100427a:	4605      	mov	r5, r0
	STRUCT_SECTION_FOREACH(log_backend, backend) {
 100427c:	4c0f      	ldr	r4, [pc, #60]	; (10042bc <dropped_notify+0x48>)
 100427e:	4e10      	ldr	r6, [pc, #64]	; (10042c0 <dropped_notify+0x4c>)
 1004280:	42b4      	cmp	r4, r6
 1004282:	d919      	bls.n	10042b8 <dropped_notify+0x44>
 1004284:	490f      	ldr	r1, [pc, #60]	; (10042c4 <dropped_notify+0x50>)
 1004286:	f240 13cd 	movw	r3, #461	; 0x1cd
 100428a:	4a0f      	ldr	r2, [pc, #60]	; (10042c8 <dropped_notify+0x54>)
 100428c:	480f      	ldr	r0, [pc, #60]	; (10042cc <dropped_notify+0x58>)
 100428e:	f020 fca2 	bl	1024bd6 <assert_print>
 1004292:	480f      	ldr	r0, [pc, #60]	; (10042d0 <dropped_notify+0x5c>)
 1004294:	f020 fc9f 	bl	1024bd6 <assert_print>
 1004298:	f240 11cd 	movw	r1, #461	; 0x1cd
 100429c:	480a      	ldr	r0, [pc, #40]	; (10042c8 <dropped_notify+0x54>)
 100429e:	f020 fc93 	bl	1024bc8 <assert_post_action>
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
 10042a2:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
 10042a4:	795b      	ldrb	r3, [r3, #5]
 10042a6:	b12b      	cbz	r3, 10042b4 <dropped_notify+0x40>
	if (backend->api->dropped != NULL) {
 10042a8:	6823      	ldr	r3, [r4, #0]
 10042aa:	685b      	ldr	r3, [r3, #4]
 10042ac:	b113      	cbz	r3, 10042b4 <dropped_notify+0x40>
		backend->api->dropped(backend, cnt);
 10042ae:	4629      	mov	r1, r5
 10042b0:	4620      	mov	r0, r4
 10042b2:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(log_backend, backend) {
 10042b4:	3410      	adds	r4, #16
 10042b6:	e7e3      	b.n	1004280 <dropped_notify+0xc>
 10042b8:	d3f3      	bcc.n	10042a2 <dropped_notify+0x2e>
}
 10042ba:	bd70      	pop	{r4, r5, r6, pc}
 10042bc:	01029a6c 	.word	0x01029a6c
 10042c0:	01029a7c 	.word	0x01029a7c
 10042c4:	0102bee3 	.word	0x0102bee3
 10042c8:	0102be92 	.word	0x0102be92
 10042cc:	0102b695 	.word	0x0102b695
 10042d0:	0102bf04 	.word	0x0102bf04

010042d4 <z_log_msg_init>:
{
 10042d4:	b510      	push	{r4, lr}
	mpsc_pbuf_init(&log_buffer, &mpsc_config);
 10042d6:	4c04      	ldr	r4, [pc, #16]	; (10042e8 <z_log_msg_init+0x14>)
 10042d8:	4904      	ldr	r1, [pc, #16]	; (10042ec <z_log_msg_init+0x18>)
 10042da:	4620      	mov	r0, r4
 10042dc:	f7ff fc5a 	bl	1003b94 <mpsc_pbuf_init>
	curr_log_buffer = &log_buffer;
 10042e0:	4b03      	ldr	r3, [pc, #12]	; (10042f0 <z_log_msg_init+0x1c>)
 10042e2:	601c      	str	r4, [r3, #0]
}
 10042e4:	bd10      	pop	{r4, pc}
 10042e6:	bf00      	nop
 10042e8:	21000bc8 	.word	0x21000bc8
 10042ec:	01029ba8 	.word	0x01029ba8
 10042f0:	210045dc 	.word	0x210045dc

010042f4 <log_core_init>:
{
 10042f4:	b508      	push	{r3, lr}
	panic_mode = false;
 10042f6:	2300      	movs	r3, #0
 10042f8:	4a06      	ldr	r2, [pc, #24]	; (1004314 <log_core_init+0x20>)
		log_set_timestamp_func(default_get_timestamp,
 10042fa:	f44f 4100 	mov.w	r1, #32768	; 0x8000
	panic_mode = false;
 10042fe:	7013      	strb	r3, [r2, #0]
	dropped_cnt = 0;
 1004300:	4a05      	ldr	r2, [pc, #20]	; (1004318 <log_core_init+0x24>)
		log_set_timestamp_func(default_get_timestamp,
 1004302:	4806      	ldr	r0, [pc, #24]	; (100431c <log_core_init+0x28>)
	dropped_cnt = 0;
 1004304:	6013      	str	r3, [r2, #0]
		log_set_timestamp_func(default_get_timestamp,
 1004306:	f7ff ff77 	bl	10041f8 <log_set_timestamp_func>
}
 100430a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		z_log_msg_init();
 100430e:	f7ff bfe1 	b.w	10042d4 <z_log_msg_init>
 1004312:	bf00      	nop
 1004314:	210081f1 	.word	0x210081f1
 1004318:	210045e4 	.word	0x210045e4
 100431c:	01024d87 	.word	0x01024d87

01004320 <z_log_msg_alloc>:
{
 1004320:	4601      	mov	r1, r0
	return (struct log_msg *)mpsc_pbuf_alloc(buffer, wlen,
 1004322:	2200      	movs	r2, #0
 1004324:	2300      	movs	r3, #0
 1004326:	4801      	ldr	r0, [pc, #4]	; (100432c <z_log_msg_alloc+0xc>)
 1004328:	f7ff bc66 	b.w	1003bf8 <mpsc_pbuf_alloc>
 100432c:	21000bc8 	.word	0x21000bc8

01004330 <z_log_msg_local_claim>:
	return (union log_msg_generic *)mpsc_pbuf_claim(&log_buffer);
 1004330:	4801      	ldr	r0, [pc, #4]	; (1004338 <z_log_msg_local_claim+0x8>)
 1004332:	f7ff bd75 	b.w	1003e20 <mpsc_pbuf_claim>
 1004336:	bf00      	nop
 1004338:	21000bc8 	.word	0x21000bc8

0100433c <z_log_msg_free>:
	mpsc_pbuf_free(buffer, &msg->buf);
 100433c:	4b02      	ldr	r3, [pc, #8]	; (1004348 <z_log_msg_free+0xc>)
{
 100433e:	4601      	mov	r1, r0
	mpsc_pbuf_free(buffer, &msg->buf);
 1004340:	6818      	ldr	r0, [r3, #0]
 1004342:	f7ff bdf3 	b.w	1003f2c <mpsc_pbuf_free>
 1004346:	bf00      	nop
 1004348:	210045dc 	.word	0x210045dc

0100434c <z_log_msg_pending>:
	return mpsc_pbuf_is_pending(buffer);
 100434c:	4801      	ldr	r0, [pc, #4]	; (1004354 <z_log_msg_pending+0x8>)
 100434e:	f020 bcfc 	b.w	1024d4a <mpsc_pbuf_is_pending>
 1004352:	bf00      	nop
 1004354:	21000bc8 	.word	0x21000bc8

01004358 <z_impl_log_process>:
{
 1004358:	b570      	push	{r4, r5, r6, lr}
	if (!backend_attached) {
 100435a:	4b2e      	ldr	r3, [pc, #184]	; (1004414 <z_impl_log_process+0xbc>)
 100435c:	7818      	ldrb	r0, [r3, #0]
 100435e:	2800      	cmp	r0, #0
 1004360:	d057      	beq.n	1004412 <z_impl_log_process+0xba>
	return z_log_msg_local_claim();
 1004362:	f7ff ffe5 	bl	1004330 <z_log_msg_local_claim>
	if (msg) {
 1004366:	4605      	mov	r5, r0
 1004368:	b340      	cbz	r0, 10043bc <z_impl_log_process+0x64>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 100436a:	4b2b      	ldr	r3, [pc, #172]	; (1004418 <z_impl_log_process+0xc0>)
 100436c:	e8d3 1fef 	ldaex	r1, [r3]
 1004370:	3901      	subs	r1, #1
 1004372:	e8c3 1fe2 	stlex	r2, r1, [r3]
 1004376:	2a00      	cmp	r2, #0
 1004378:	d1f8      	bne.n	100436c <z_impl_log_process+0x14>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
 100437a:	4c28      	ldr	r4, [pc, #160]	; (100441c <z_impl_log_process+0xc4>)
 100437c:	4e28      	ldr	r6, [pc, #160]	; (1004420 <z_impl_log_process+0xc8>)
 100437e:	42b4      	cmp	r4, r6
 1004380:	d918      	bls.n	10043b4 <z_impl_log_process+0x5c>
 1004382:	4928      	ldr	r1, [pc, #160]	; (1004424 <z_impl_log_process+0xcc>)
 1004384:	f240 13c1 	movw	r3, #449	; 0x1c1
 1004388:	4a27      	ldr	r2, [pc, #156]	; (1004428 <z_impl_log_process+0xd0>)
 100438a:	4828      	ldr	r0, [pc, #160]	; (100442c <z_impl_log_process+0xd4>)
 100438c:	f020 fc23 	bl	1024bd6 <assert_print>
 1004390:	4827      	ldr	r0, [pc, #156]	; (1004430 <z_impl_log_process+0xd8>)
 1004392:	f020 fc20 	bl	1024bd6 <assert_print>
 1004396:	f240 11c1 	movw	r1, #449	; 0x1c1
 100439a:	4823      	ldr	r0, [pc, #140]	; (1004428 <z_impl_log_process+0xd0>)
 100439c:	f020 fc14 	bl	1024bc8 <assert_post_action>
	return backend->cb->active;
 10043a0:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend) &&
 10043a2:	795b      	ldrb	r3, [r3, #5]
 10043a4:	b123      	cbz	r3, 10043b0 <z_impl_log_process+0x58>
	backend->api->process(backend, msg);
 10043a6:	6823      	ldr	r3, [r4, #0]
 10043a8:	4629      	mov	r1, r5
 10043aa:	4620      	mov	r0, r4
 10043ac:	681b      	ldr	r3, [r3, #0]
 10043ae:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(log_backend, backend) {
 10043b0:	3410      	adds	r4, #16
 10043b2:	e7e4      	b.n	100437e <z_impl_log_process+0x26>
 10043b4:	d3f4      	bcc.n	10043a0 <z_impl_log_process+0x48>
		z_log_msg_free(msg);
 10043b6:	4628      	mov	r0, r5
 10043b8:	f7ff ffc0 	bl	100433c <z_log_msg_free>
	return dropped_cnt > 0;
 10043bc:	4b1d      	ldr	r3, [pc, #116]	; (1004434 <z_impl_log_process+0xdc>)
 10043be:	4c1e      	ldr	r4, [pc, #120]	; (1004438 <z_impl_log_process+0xe0>)
		if ((dropped_pend || unordered_pend) &&
 10043c0:	681b      	ldr	r3, [r3, #0]
 10043c2:	2b00      	cmp	r3, #0
 10043c4:	dd19      	ble.n	10043fa <z_impl_log_process+0xa2>
	return z_impl_k_uptime_ticks();
 10043c6:	f025 f84f 	bl	1029468 <z_impl_k_uptime_ticks>
			/* Faster algorithm but source is first multiplied by target frequency
			 * and it can overflow even though final result would not overflow.
			 * Kconfig option shall prevent use of this algorithm when there is a
			 * risk of overflow.
			 */
			return ((t * to_hz + off) / from_hz);
 10043ca:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 10043ce:	fba0 0302 	umull	r0, r3, r0, r2
 10043d2:	fb02 3101 	mla	r1, r2, r1, r3
 10043d6:	0bc3      	lsrs	r3, r0, #15
 10043d8:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
		   (k_uptime_get() - last_failure_report) > CONFIG_LOG_FAILURE_REPORT_PERIOD) {
 10043dc:	e9d4 2000 	ldrd	r2, r0, [r4]
 10043e0:	1a9b      	subs	r3, r3, r2
		if ((dropped_pend || unordered_pend) &&
 10043e2:	f240 32e9 	movw	r2, #1001	; 0x3e9
 10043e6:	ea4f 31d1 	mov.w	r1, r1, lsr #15
		   (k_uptime_get() - last_failure_report) > CONFIG_LOG_FAILURE_REPORT_PERIOD) {
 10043ea:	eb61 0100 	sbc.w	r1, r1, r0
		if ((dropped_pend || unordered_pend) &&
 10043ee:	4293      	cmp	r3, r2
 10043f0:	f171 0100 	sbcs.w	r1, r1, #0
 10043f4:	d301      	bcc.n	10043fa <z_impl_log_process+0xa2>
				dropped_notify();
 10043f6:	f7ff ff3d 	bl	1004274 <dropped_notify>
		last_failure_report += CONFIG_LOG_FAILURE_REPORT_PERIOD;
 10043fa:	e9d4 3200 	ldrd	r3, r2, [r4]
 10043fe:	f513 737a 	adds.w	r3, r3, #1000	; 0x3e8
 1004402:	f142 0200 	adc.w	r2, r2, #0
 1004406:	e9c4 3200 	strd	r3, r2, [r4]
}
 100440a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return z_log_msg_pending();
 100440e:	f7ff bf9d 	b.w	100434c <z_log_msg_pending>
}
 1004412:	bd70      	pop	{r4, r5, r6, pc}
 1004414:	210081f0 	.word	0x210081f0
 1004418:	210045e8 	.word	0x210045e8
 100441c:	01029a6c 	.word	0x01029a6c
 1004420:	01029a7c 	.word	0x01029a7c
 1004424:	0102bee3 	.word	0x0102bee3
 1004428:	0102be92 	.word	0x0102be92
 100442c:	0102b695 	.word	0x0102b695
 1004430:	0102bf04 	.word	0x0102bf04
 1004434:	210045e4 	.word	0x210045e4
 1004438:	21001468 	.word	0x21001468

0100443c <z_impl_log_panic>:
{
 100443c:	b570      	push	{r4, r5, r6, lr}
	if (panic_mode) {
 100443e:	4d15      	ldr	r5, [pc, #84]	; (1004494 <z_impl_log_panic+0x58>)
 1004440:	7829      	ldrb	r1, [r5, #0]
 1004442:	bb29      	cbnz	r1, 1004490 <z_impl_log_panic+0x54>
	(void)z_log_init(true, false);
 1004444:	2001      	movs	r0, #1
 1004446:	f7ff fe5b 	bl	1004100 <z_log_init>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
 100444a:	4c13      	ldr	r4, [pc, #76]	; (1004498 <z_impl_log_panic+0x5c>)
 100444c:	4e13      	ldr	r6, [pc, #76]	; (100449c <z_impl_log_panic+0x60>)
 100444e:	42b4      	cmp	r4, r6
 1004450:	d917      	bls.n	1004482 <z_impl_log_panic+0x46>
 1004452:	4913      	ldr	r1, [pc, #76]	; (10044a0 <z_impl_log_panic+0x64>)
 1004454:	f44f 73c2 	mov.w	r3, #388	; 0x184
 1004458:	4a12      	ldr	r2, [pc, #72]	; (10044a4 <z_impl_log_panic+0x68>)
 100445a:	4813      	ldr	r0, [pc, #76]	; (10044a8 <z_impl_log_panic+0x6c>)
 100445c:	f020 fbbb 	bl	1024bd6 <assert_print>
 1004460:	4812      	ldr	r0, [pc, #72]	; (10044ac <z_impl_log_panic+0x70>)
 1004462:	f020 fbb8 	bl	1024bd6 <assert_print>
 1004466:	f44f 71c2 	mov.w	r1, #388	; 0x184
 100446a:	480e      	ldr	r0, [pc, #56]	; (10044a4 <z_impl_log_panic+0x68>)
 100446c:	f020 fbac 	bl	1024bc8 <assert_post_action>
	return backend->cb->active;
 1004470:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
 1004472:	795b      	ldrb	r3, [r3, #5]
 1004474:	b11b      	cbz	r3, 100447e <z_impl_log_panic+0x42>
	backend->api->panic(backend);
 1004476:	6823      	ldr	r3, [r4, #0]
 1004478:	4620      	mov	r0, r4
 100447a:	689b      	ldr	r3, [r3, #8]
 100447c:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(log_backend, backend) {
 100447e:	3410      	adds	r4, #16
 1004480:	e7e5      	b.n	100444e <z_impl_log_panic+0x12>
 1004482:	d3f5      	bcc.n	1004470 <z_impl_log_panic+0x34>
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke0(K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process();
 1004484:	f7ff ff68 	bl	1004358 <z_impl_log_process>
		while (log_process() == true) {
 1004488:	2800      	cmp	r0, #0
 100448a:	d1fb      	bne.n	1004484 <z_impl_log_panic+0x48>
	panic_mode = true;
 100448c:	2301      	movs	r3, #1
 100448e:	702b      	strb	r3, [r5, #0]
}
 1004490:	bd70      	pop	{r4, r5, r6, pc}
 1004492:	bf00      	nop
 1004494:	210081f1 	.word	0x210081f1
 1004498:	01029a6c 	.word	0x01029a6c
 100449c:	01029a7c 	.word	0x01029a7c
 10044a0:	0102bee3 	.word	0x0102bee3
 10044a4:	0102be92 	.word	0x0102be92
 10044a8:	0102b695 	.word	0x0102b695
 10044ac:	0102bf04 	.word	0x0102bf04

010044b0 <log_process_thread_func>:
{
 10044b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	STRUCT_SECTION_COUNT(log_backend, &cnt);
 10044b4:	4b2f      	ldr	r3, [pc, #188]	; (1004574 <log_process_thread_func+0xc4>)
 10044b6:	4f30      	ldr	r7, [pc, #192]	; (1004578 <log_process_thread_func+0xc8>)
 10044b8:	1afb      	subs	r3, r7, r3
	__ASSERT_NO_MSG(log_backend_count_get() > 0);
 10044ba:	091b      	lsrs	r3, r3, #4
 10044bc:	d10b      	bne.n	10044d6 <log_process_thread_func+0x26>
 10044be:	492f      	ldr	r1, [pc, #188]	; (100457c <log_process_thread_func+0xcc>)
 10044c0:	f240 3347 	movw	r3, #839	; 0x347
 10044c4:	4a2e      	ldr	r2, [pc, #184]	; (1004580 <log_process_thread_func+0xd0>)
 10044c6:	482f      	ldr	r0, [pc, #188]	; (1004584 <log_process_thread_func+0xd4>)
 10044c8:	f020 fb85 	bl	1024bd6 <assert_print>
 10044cc:	f240 3147 	movw	r1, #839	; 0x347
	STRUCT_SECTION_FOREACH(log_backend, backend) {
 10044d0:	482b      	ldr	r0, [pc, #172]	; (1004580 <log_process_thread_func+0xd0>)
 10044d2:	f020 fb79 	bl	1024bc8 <assert_post_action>
	uint32_t activate_mask = z_log_init(false, false);
 10044d6:	2100      	movs	r1, #0
 10044d8:	4608      	mov	r0, r1
 10044da:	f7ff fe11 	bl	1004100 <z_log_init>
	k_timeout_t timeout = (activate_mask != 0) ? K_MSEC(50) : K_FOREVER;
 10044de:	4604      	mov	r4, r0
 10044e0:	b340      	cbz	r0, 1004534 <log_process_thread_func+0x84>
 10044e2:	f240 6867 	movw	r8, #1639	; 0x667
 10044e6:	f04f 0900 	mov.w	r9, #0
	return z_impl_z_current_get();
 10044ea:	f01e ffb3 	bl	1023454 <z_impl_z_current_get>
	proc_tid = process_tid;
 10044ee:	4b26      	ldr	r3, [pc, #152]	; (1004588 <log_process_thread_func+0xd8>)
 10044f0:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
 10044f2:	b130      	cbz	r0, 1004502 <log_process_thread_func+0x52>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
 10044f4:	4b25      	ldr	r3, [pc, #148]	; (100458c <log_process_thread_func+0xdc>)
	    process_tid &&
 10044f6:	681b      	ldr	r3, [r3, #0]
 10044f8:	2b09      	cmp	r3, #9
 10044fa:	dd02      	ble.n	1004502 <log_process_thread_func+0x52>
	z_impl_k_sem_give(sem);
 10044fc:	4824      	ldr	r0, [pc, #144]	; (1004590 <log_process_thread_func+0xe0>)
 10044fe:	f01d f8cf 	bl	10216a0 <z_impl_k_sem_give>
	k_timeout_t timeout = (activate_mask != 0) ? K_MSEC(50) : K_FOREVER;
 1004502:	2500      	movs	r5, #0
	return z_impl_k_sem_take(sem, timeout);
 1004504:	f8df a088 	ldr.w	sl, [pc, #136]	; 1004590 <log_process_thread_func+0xe0>
		if (activate_mask) {
 1004508:	b144      	cbz	r4, 100451c <log_process_thread_func+0x6c>
			activate_mask = activate_foreach_backend(activate_mask);
 100450a:	4620      	mov	r0, r4
 100450c:	f7ff fdc6 	bl	100409c <activate_foreach_backend>
			if (!activate_mask) {
 1004510:	4604      	mov	r4, r0
 1004512:	b918      	cbnz	r0, 100451c <log_process_thread_func+0x6c>
				timeout = K_FOREVER;
 1004514:	f04f 38ff 	mov.w	r8, #4294967295
 1004518:	f04f 39ff 	mov.w	r9, #4294967295
 100451c:	f7ff ff1c 	bl	1004358 <z_impl_log_process>
		if (log_process() == false) {
 1004520:	4606      	mov	r6, r0
 1004522:	b928      	cbnz	r0, 1004530 <log_process_thread_func+0x80>
			if (processed_any) {
 1004524:	b95d      	cbnz	r5, 100453e <log_process_thread_func+0x8e>
 1004526:	4642      	mov	r2, r8
 1004528:	464b      	mov	r3, r9
 100452a:	4650      	mov	r0, sl
 100452c:	f01d f8fc 	bl	1021728 <z_impl_k_sem_take>
	k_timeout_t timeout = (activate_mask != 0) ? K_MSEC(50) : K_FOREVER;
 1004530:	4635      	mov	r5, r6
 1004532:	e7e9      	b.n	1004508 <log_process_thread_func+0x58>
 1004534:	f04f 38ff 	mov.w	r8, #4294967295
 1004538:	f04f 39ff 	mov.w	r9, #4294967295
 100453c:	e7d5      	b.n	10044ea <log_process_thread_func+0x3a>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
 100453e:	4d0d      	ldr	r5, [pc, #52]	; (1004574 <log_process_thread_func+0xc4>)
 1004540:	e008      	b.n	1004554 <log_process_thread_func+0xa4>
 1004542:	d2f0      	bcs.n	1004526 <log_process_thread_func+0x76>
				      enum log_backend_evt event,
				      union log_backend_evt_arg *arg)
{
	__ASSERT_NO_MSG(backend != NULL);

	if (backend->api->notify) {
 1004544:	682b      	ldr	r3, [r5, #0]
 1004546:	699b      	ldr	r3, [r3, #24]
 1004548:	b11b      	cbz	r3, 1004552 <log_process_thread_func+0xa2>
		backend->api->notify(backend, event, arg);
 100454a:	2200      	movs	r2, #0
 100454c:	4628      	mov	r0, r5
 100454e:	4611      	mov	r1, r2
 1004550:	4798      	blx	r3
 1004552:	3510      	adds	r5, #16
 1004554:	42bd      	cmp	r5, r7
 1004556:	d9f4      	bls.n	1004542 <log_process_thread_func+0x92>
 1004558:	490e      	ldr	r1, [pc, #56]	; (1004594 <log_process_thread_func+0xe4>)
 100455a:	f240 333b 	movw	r3, #827	; 0x33b
 100455e:	4a08      	ldr	r2, [pc, #32]	; (1004580 <log_process_thread_func+0xd0>)
 1004560:	4808      	ldr	r0, [pc, #32]	; (1004584 <log_process_thread_func+0xd4>)
 1004562:	f020 fb38 	bl	1024bd6 <assert_print>
 1004566:	480c      	ldr	r0, [pc, #48]	; (1004598 <log_process_thread_func+0xe8>)
 1004568:	f020 fb35 	bl	1024bd6 <assert_print>
 100456c:	f240 313b 	movw	r1, #827	; 0x33b
 1004570:	e7ae      	b.n	10044d0 <log_process_thread_func+0x20>
 1004572:	bf00      	nop
 1004574:	01029a6c 	.word	0x01029a6c
 1004578:	01029a7c 	.word	0x01029a7c
 100457c:	0102bf23 	.word	0x0102bf23
 1004580:	0102be92 	.word	0x0102be92
 1004584:	0102b695 	.word	0x0102b695
 1004588:	210045e0 	.word	0x210045e0
 100458c:	210045e8 	.word	0x210045e8
 1004590:	21000cb0 	.word	0x21000cb0
 1004594:	0102bee3 	.word	0x0102bee3
 1004598:	0102bf04 	.word	0x0102bf04

0100459c <z_log_msg_post_finalize>:
{
 100459c:	b513      	push	{r0, r1, r4, lr}
	atomic_val_t cnt = atomic_inc(&buffered_cnt);
 100459e:	482b      	ldr	r0, [pc, #172]	; (100464c <z_log_msg_post_finalize+0xb0>)
 10045a0:	f020 fbf3 	bl	1024d8a <atomic_inc>
	if (panic_mode) {
 10045a4:	4b2a      	ldr	r3, [pc, #168]	; (1004650 <z_log_msg_post_finalize+0xb4>)
 10045a6:	781b      	ldrb	r3, [r3, #0]
 10045a8:	2b00      	cmp	r3, #0
 10045aa:	d034      	beq.n	1004616 <z_log_msg_post_finalize+0x7a>
	__asm__ volatile(
 10045ac:	f04f 0320 	mov.w	r3, #32
 10045b0:	f3ef 8411 	mrs	r4, BASEPRI
 10045b4:	f383 8812 	msr	BASEPRI_MAX, r3
 10045b8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10045bc:	4825      	ldr	r0, [pc, #148]	; (1004654 <z_log_msg_post_finalize+0xb8>)
 10045be:	f01c fd87 	bl	10210d0 <z_spin_lock_valid>
 10045c2:	b968      	cbnz	r0, 10045e0 <z_log_msg_post_finalize+0x44>
 10045c4:	2394      	movs	r3, #148	; 0x94
 10045c6:	4a24      	ldr	r2, [pc, #144]	; (1004658 <z_log_msg_post_finalize+0xbc>)
 10045c8:	4924      	ldr	r1, [pc, #144]	; (100465c <z_log_msg_post_finalize+0xc0>)
 10045ca:	4825      	ldr	r0, [pc, #148]	; (1004660 <z_log_msg_post_finalize+0xc4>)
 10045cc:	f020 fb03 	bl	1024bd6 <assert_print>
 10045d0:	4920      	ldr	r1, [pc, #128]	; (1004654 <z_log_msg_post_finalize+0xb8>)
 10045d2:	4824      	ldr	r0, [pc, #144]	; (1004664 <z_log_msg_post_finalize+0xc8>)
 10045d4:	f020 faff 	bl	1024bd6 <assert_print>
 10045d8:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10045da:	481f      	ldr	r0, [pc, #124]	; (1004658 <z_log_msg_post_finalize+0xbc>)
 10045dc:	f020 faf4 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 10045e0:	481c      	ldr	r0, [pc, #112]	; (1004654 <z_log_msg_post_finalize+0xb8>)
 10045e2:	f01c fd91 	bl	1021108 <z_spin_lock_set_owner>
 10045e6:	f7ff feb7 	bl	1004358 <z_impl_log_process>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10045ea:	481a      	ldr	r0, [pc, #104]	; (1004654 <z_log_msg_post_finalize+0xb8>)
 10045ec:	f01c fd7e 	bl	10210ec <z_spin_unlock_valid>
 10045f0:	b958      	cbnz	r0, 100460a <z_log_msg_post_finalize+0x6e>
 10045f2:	23c2      	movs	r3, #194	; 0xc2
 10045f4:	4a18      	ldr	r2, [pc, #96]	; (1004658 <z_log_msg_post_finalize+0xbc>)
 10045f6:	491c      	ldr	r1, [pc, #112]	; (1004668 <z_log_msg_post_finalize+0xcc>)
 10045f8:	4819      	ldr	r0, [pc, #100]	; (1004660 <z_log_msg_post_finalize+0xc4>)
 10045fa:	f020 faec 	bl	1024bd6 <assert_print>
 10045fe:	4915      	ldr	r1, [pc, #84]	; (1004654 <z_log_msg_post_finalize+0xb8>)
 1004600:	481a      	ldr	r0, [pc, #104]	; (100466c <z_log_msg_post_finalize+0xd0>)
 1004602:	f020 fae8 	bl	1024bd6 <assert_print>
 1004606:	21c2      	movs	r1, #194	; 0xc2
 1004608:	e7e7      	b.n	10045da <z_log_msg_post_finalize+0x3e>
	__asm__ volatile(
 100460a:	f384 8811 	msr	BASEPRI, r4
 100460e:	f3bf 8f6f 	isb	sy
}
 1004612:	b002      	add	sp, #8
 1004614:	bd10      	pop	{r4, pc}
	} else if (proc_tid != NULL) {
 1004616:	4b16      	ldr	r3, [pc, #88]	; (1004670 <z_log_msg_post_finalize+0xd4>)
 1004618:	681b      	ldr	r3, [r3, #0]
 100461a:	2b00      	cmp	r3, #0
 100461c:	d0f9      	beq.n	1004612 <z_log_msg_post_finalize+0x76>
		if (cnt == 0) {
 100461e:	b950      	cbnz	r0, 1004636 <z_log_msg_post_finalize+0x9a>
	z_impl_k_timer_start(timer, duration, period);
 1004620:	2200      	movs	r2, #0
 1004622:	2300      	movs	r3, #0
 1004624:	4813      	ldr	r0, [pc, #76]	; (1004674 <z_log_msg_post_finalize+0xd8>)
 1004626:	e9cd 2300 	strd	r2, r3, [sp]
 100462a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 100462e:	2300      	movs	r3, #0
 1004630:	f01f fbb4 	bl	1023d9c <z_impl_k_timer_start>
 1004634:	e7ed      	b.n	1004612 <z_log_msg_post_finalize+0x76>
		} else if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
 1004636:	280a      	cmp	r0, #10
 1004638:	d1eb      	bne.n	1004612 <z_log_msg_post_finalize+0x76>
	z_impl_k_timer_stop(timer);
 100463a:	480e      	ldr	r0, [pc, #56]	; (1004674 <z_log_msg_post_finalize+0xd8>)
 100463c:	f024 ff48 	bl	10294d0 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
 1004640:	480d      	ldr	r0, [pc, #52]	; (1004678 <z_log_msg_post_finalize+0xdc>)
}
 1004642:	b002      	add	sp, #8
 1004644:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 1004648:	f01d b82a 	b.w	10216a0 <z_impl_k_sem_give>
 100464c:	210045e8 	.word	0x210045e8
 1004650:	210081f1 	.word	0x210081f1
 1004654:	210045d8 	.word	0x210045d8
 1004658:	0102bd8a 	.word	0x0102bd8a
 100465c:	0102bde3 	.word	0x0102bde3
 1004660:	0102b695 	.word	0x0102b695
 1004664:	0102bdf8 	.word	0x0102bdf8
 1004668:	0102bdb7 	.word	0x0102bdb7
 100466c:	0102bdce 	.word	0x0102bdce
 1004670:	210045e0 	.word	0x210045e0
 1004674:	21001470 	.word	0x21001470
 1004678:	21000cb0 	.word	0x21000cb0

0100467c <z_log_msg_commit>:
{
 100467c:	b510      	push	{r4, lr}
	msg->hdr.timestamp = timestamp_func();
 100467e:	4b06      	ldr	r3, [pc, #24]	; (1004698 <z_log_msg_commit+0x1c>)
{
 1004680:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
 1004682:	681b      	ldr	r3, [r3, #0]
 1004684:	4798      	blx	r3
	mpsc_pbuf_commit(buffer, &m->buf);
 1004686:	4621      	mov	r1, r4
	msg->hdr.timestamp = timestamp_func();
 1004688:	60a0      	str	r0, [r4, #8]
	mpsc_pbuf_commit(buffer, &m->buf);
 100468a:	4804      	ldr	r0, [pc, #16]	; (100469c <z_log_msg_commit+0x20>)
 100468c:	f7ff fb72 	bl	1003d74 <mpsc_pbuf_commit>
}
 1004690:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_log_msg_post_finalize();
 1004694:	f7ff bf82 	b.w	100459c <z_log_msg_post_finalize>
 1004698:	21000274 	.word	0x21000274
 100469c:	21000bc8 	.word	0x21000bc8

010046a0 <log_source_name_get>:
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)__log_const_start)/
 10046a0:	4a04      	ldr	r2, [pc, #16]	; (10046b4 <log_source_name_get+0x14>)
 10046a2:	4b05      	ldr	r3, [pc, #20]	; (10046b8 <log_source_name_get+0x18>)
 10046a4:	1a9b      	subs	r3, r3, r2
}

const char *log_source_name_get(uint32_t domain_id, uint32_t source_id)
{
	if (z_log_is_local_domain(domain_id)) {
		if (source_id < log_src_cnt_get(domain_id)) {
 10046a6:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
			return __log_const_start[source_id].name;
 10046aa:	bf34      	ite	cc
 10046ac:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
		} else {
			return NULL;
 10046b0:	2000      	movcs	r0, #0
		}
	}

	return link_source_name_get(domain_id, source_id);
}
 10046b2:	4770      	bx	lr
 10046b4:	01029944 	.word	0x01029944
 10046b8:	01029a6c 	.word	0x01029a6c

010046bc <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
 10046bc:	4b0e      	ldr	r3, [pc, #56]	; (10046f8 <log_backend_enable+0x3c>)
{
 10046be:	b510      	push	{r4, lr}
	id += backend - log_backend_get(0);
 10046c0:	1ac3      	subs	r3, r0, r3
 10046c2:	111b      	asrs	r3, r3, #4
 10046c4:	3301      	adds	r3, #1

	log_backend_id_set(backend, id);
 10046c6:	b2db      	uxtb	r3, r3
	__ASSERT_NO_MSG(backend != NULL);
 10046c8:	b948      	cbnz	r0, 10046de <log_backend_enable+0x22>
 10046ca:	490c      	ldr	r1, [pc, #48]	; (10046fc <log_backend_enable+0x40>)
 10046cc:	480c      	ldr	r0, [pc, #48]	; (1004700 <log_backend_enable+0x44>)
 10046ce:	23de      	movs	r3, #222	; 0xde
 10046d0:	4a0c      	ldr	r2, [pc, #48]	; (1004704 <log_backend_enable+0x48>)
 10046d2:	f020 fa80 	bl	1024bd6 <assert_print>
 10046d6:	21de      	movs	r1, #222	; 0xde
 10046d8:	480a      	ldr	r0, [pc, #40]	; (1004704 <log_backend_enable+0x48>)
 10046da:	f020 fa75 	bl	1024bc8 <assert_post_action>
	backend->cb->id = id;
 10046de:	6844      	ldr	r4, [r0, #4]
 10046e0:	7123      	strb	r3, [r4, #4]
	backend->cb->level = level;
 10046e2:	6843      	ldr	r3, [r0, #4]
 10046e4:	719a      	strb	r2, [r3, #6]
	backend->cb->active = true;
 10046e6:	2201      	movs	r2, #1
	backend->cb->ctx = ctx;
 10046e8:	6843      	ldr	r3, [r0, #4]
 10046ea:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
 10046ec:	6843      	ldr	r3, [r0, #4]
 10046ee:	715a      	strb	r2, [r3, #5]
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);

	z_log_notify_backend_enabled();
}
 10046f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_log_notify_backend_enabled();
 10046f4:	f7ff bd90 	b.w	1004218 <z_log_notify_backend_enabled>
 10046f8:	01029a6c 	.word	0x01029a6c
 10046fc:	0102bfc3 	.word	0x0102bfc3
 1004700:	0102b695 	.word	0x0102b695
 1004704:	0102bf8b 	.word	0x0102bf8b

01004708 <z_impl_z_log_msg_static_create>:
}

void z_impl_z_log_msg_static_create(const void *source,
			      const struct log_msg_desc desc,
			      uint8_t *package, const void *data)
{
 1004708:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 *
 * @return Length.
 */
static inline uint32_t log_msg_get_total_wlen(const struct log_msg_desc desc)
{
	return Z_LOG_MSG2_ALIGNED_WLEN(desc.package_len, desc.data_len);
 100470c:	f3c1 44cb 	ubfx	r4, r1, #19, #12
 1004710:	b08f      	sub	sp, #60	; 0x3c
 1004712:	f3c1 2649 	ubfx	r6, r1, #9, #10
 1004716:	460d      	mov	r5, r1
 1004718:	4690      	mov	r8, r2
 100471a:	4699      	mov	r9, r3
 100471c:	9005      	str	r0, [sp, #20]
 100471e:	3417      	adds	r4, #23

	struct log_msg_desc out_desc = desc;
	int inlen = desc.package_len;
	struct log_msg *msg;

	if (inlen > 0) {
 1004720:	2e00      	cmp	r6, #0
 1004722:	d03d      	beq.n	10047a0 <z_impl_z_log_msg_static_create+0x98>
	return cbprintf_package_convert(in_packaged, in_len,
 1004724:	f04f 0b04 	mov.w	fp, #4
 1004728:	f04f 0a0a 	mov.w	sl, #10
	struct z_cbprintf_buf_desc buf_desc = {
 100472c:	2200      	movs	r2, #0
	return cbprintf_package_convert(in_packaged, in_len,
 100472e:	af09      	add	r7, sp, #36	; 0x24
		uint32_t flags = CBPRINTF_PACKAGE_CONVERT_RW_STR |
				 CBPRINTF_PACKAGE_CONVERT_PTR_CHECK;
		uint16_t strl[4];
		int len;

		len = cbprintf_package_copy(package, inlen,
 1004730:	4631      	mov	r1, r6
 1004732:	ab0b      	add	r3, sp, #44	; 0x2c
 1004734:	4640      	mov	r0, r8
 1004736:	f8cd b008 	str.w	fp, [sp, #8]
 100473a:	9701      	str	r7, [sp, #4]
 100473c:	f8cd a000 	str.w	sl, [sp]
	struct z_cbprintf_buf_desc buf_desc = {
 1004740:	e9cd 220b 	strd	r2, r2, [sp, #44]	; 0x2c
 1004744:	920d      	str	r2, [sp, #52]	; 0x34
	return cbprintf_package_convert(in_packaged, in_len,
 1004746:	9607      	str	r6, [sp, #28]
 1004748:	f7fd ff82 	bl	1002650 <cbprintf_package_convert>
					    strl, ARRAY_SIZE(strl));

		/* Update package length with calculated value (which may be extended
		 * when strings are copied into the package.
		 */
		out_desc.package_len = len;
 100474c:	f3c0 0309 	ubfx	r3, r0, #0, #10
 1004750:	1918      	adds	r0, r3, r4
 1004752:	f020 0007 	bic.w	r0, r0, #7
		msg = z_log_msg_alloc(log_msg_get_total_wlen(out_desc));
 1004756:	0880      	lsrs	r0, r0, #2
		out_desc.package_len = len;
 1004758:	461e      	mov	r6, r3
		msg = z_log_msg_alloc(log_msg_get_total_wlen(out_desc));
 100475a:	f363 2552 	bfi	r5, r3, #9, #10
 100475e:	9306      	str	r3, [sp, #24]
 1004760:	f7ff fdde 	bl	1004320 <z_log_msg_alloc>
		if (msg) {
 1004764:	4604      	mov	r4, r0
 1004766:	b308      	cbz	r0, 10047ac <z_impl_z_log_msg_static_create+0xa4>
	struct z_cbprintf_buf_desc buf_desc = {
 1004768:	2200      	movs	r2, #0
 100476a:	9b06      	ldr	r3, [sp, #24]
			len = cbprintf_package_copy(package, inlen,
						    msg->data, out_desc.package_len,
 100476c:	3010      	adds	r0, #16
 100476e:	900b      	str	r0, [sp, #44]	; 0x2c
 1004770:	930c      	str	r3, [sp, #48]	; 0x30
 1004772:	920d      	str	r2, [sp, #52]	; 0x34
	return cbprintf_package_convert(in_packaged, in_len,
 1004774:	4640      	mov	r0, r8
 1004776:	e9cd 7b01 	strd	r7, fp, [sp, #4]
 100477a:	4a12      	ldr	r2, [pc, #72]	; (10047c4 <z_impl_z_log_msg_static_create+0xbc>)
 100477c:	9907      	ldr	r1, [sp, #28]
 100477e:	f8cd a000 	str.w	sl, [sp]
 1004782:	ab0b      	add	r3, sp, #44	; 0x2c
 1004784:	f7fd ff64 	bl	1002650 <cbprintf_package_convert>
						    flags, strl, ARRAY_SIZE(strl));
			__ASSERT_NO_MSG(len >= 0);
 1004788:	2800      	cmp	r0, #0
 100478a:	da0f      	bge.n	10047ac <z_impl_z_log_msg_static_create+0xa4>
 100478c:	490e      	ldr	r1, [pc, #56]	; (10047c8 <z_impl_z_log_msg_static_create+0xc0>)
 100478e:	480f      	ldr	r0, [pc, #60]	; (10047cc <z_impl_z_log_msg_static_create+0xc4>)
 1004790:	2349      	movs	r3, #73	; 0x49
 1004792:	4a0f      	ldr	r2, [pc, #60]	; (10047d0 <z_impl_z_log_msg_static_create+0xc8>)
 1004794:	f020 fa1f 	bl	1024bd6 <assert_print>
 1004798:	2149      	movs	r1, #73	; 0x49
 100479a:	480d      	ldr	r0, [pc, #52]	; (10047d0 <z_impl_z_log_msg_static_create+0xc8>)
 100479c:	f020 fa14 	bl	1024bc8 <assert_post_action>
 10047a0:	f024 0007 	bic.w	r0, r4, #7
		}
	} else {
		msg = z_log_msg_alloc(log_msg_get_total_wlen(out_desc));
 10047a4:	0880      	lsrs	r0, r0, #2
 10047a6:	f7ff fdbb 	bl	1004320 <z_log_msg_alloc>
 10047aa:	4604      	mov	r4, r0
	}

	z_log_msg_finalize(msg, source, out_desc, data);
 10047ac:	f366 2552 	bfi	r5, r6, #9, #10
 10047b0:	464b      	mov	r3, r9
 10047b2:	462a      	mov	r2, r5
 10047b4:	4620      	mov	r0, r4
 10047b6:	9905      	ldr	r1, [sp, #20]
}
 10047b8:	b00f      	add	sp, #60	; 0x3c
 10047ba:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	z_log_msg_finalize(msg, source, out_desc, data);
 10047be:	f020 bb16 	b.w	1024dee <z_log_msg_finalize>
 10047c2:	bf00      	nop
 10047c4:	01024dc3 	.word	0x01024dc3
 10047c8:	0102c010 	.word	0x0102c010
 10047cc:	0102b695 	.word	0x0102b695
 10047d0:	0102bfe3 	.word	0x0102bfe3

010047d4 <z_impl_z_log_msg_runtime_vcreate>:
#endif

void z_impl_z_log_msg_runtime_vcreate(uint8_t domain_id, const void *source,
				uint8_t level, const void *data, size_t dlen,
				uint32_t package_flags, const char *fmt, va_list ap)
{
 10047d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10047d8:	b087      	sub	sp, #28
 10047da:	4604      	mov	r4, r0
 10047dc:	e9dd 5a10 	ldrd	r5, sl, [sp, #64]	; 0x40
 10047e0:	e9dd 6912 	ldrd	r6, r9, [sp, #72]	; 0x48
 10047e4:	460f      	mov	r7, r1
 10047e6:	4693      	mov	fp, r2
 10047e8:	4698      	mov	r8, r3
	int plen;

	if (fmt) {
 10047ea:	b1ae      	cbz	r6, 1004818 <z_impl_z_log_msg_runtime_vcreate+0x44>
		va_list ap2;

		va_copy(ap2, ap);
		plen = cbvprintf_package(NULL, Z_LOG_MSG2_ALIGN_OFFSET,
 10047ec:	2110      	movs	r1, #16
 10047ee:	4633      	mov	r3, r6
 10047f0:	4652      	mov	r2, sl
 10047f2:	2000      	movs	r0, #0
 10047f4:	f8cd 9000 	str.w	r9, [sp]
		va_copy(ap2, ap);
 10047f8:	f8cd 9014 	str.w	r9, [sp, #20]
		plen = cbvprintf_package(NULL, Z_LOG_MSG2_ALIGN_OFFSET,
 10047fc:	f7fd fd0a 	bl	1002214 <cbvprintf_package>
					 package_flags, fmt, ap2);
		__ASSERT_NO_MSG(plen >= 0);
 1004800:	1e01      	subs	r1, r0, #0
 1004802:	da0a      	bge.n	100481a <z_impl_z_log_msg_runtime_vcreate+0x46>
 1004804:	4920      	ldr	r1, [pc, #128]	; (1004888 <z_impl_z_log_msg_runtime_vcreate+0xb4>)
 1004806:	2368      	movs	r3, #104	; 0x68
 1004808:	4a20      	ldr	r2, [pc, #128]	; (100488c <z_impl_z_log_msg_runtime_vcreate+0xb8>)
 100480a:	4821      	ldr	r0, [pc, #132]	; (1004890 <z_impl_z_log_msg_runtime_vcreate+0xbc>)
 100480c:	f020 f9e3 	bl	1024bd6 <assert_print>
 1004810:	2168      	movs	r1, #104	; 0x68
		pkg = msg->data;
	}

	if (pkg && fmt) {
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
		__ASSERT_NO_MSG(plen >= 0);
 1004812:	481e      	ldr	r0, [pc, #120]	; (100488c <z_impl_z_log_msg_runtime_vcreate+0xb8>)
 1004814:	f020 f9d8 	bl	1024bc8 <assert_post_action>
		plen = 0;
 1004818:	4631      	mov	r1, r6
	struct log_msg_desc desc =
 100481a:	4b1e      	ldr	r3, [pc, #120]	; (1004894 <z_impl_z_log_msg_runtime_vcreate+0xc0>)
 100481c:	f004 0407 	and.w	r4, r4, #7
 1004820:	f00b 0b07 	and.w	fp, fp, #7
 1004824:	00e4      	lsls	r4, r4, #3
 1004826:	ea03 2341 	and.w	r3, r3, r1, lsl #9
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
 100482a:	f105 0017 	add.w	r0, r5, #23
	struct log_msg_desc desc =
 100482e:	ea44 148b 	orr.w	r4, r4, fp, lsl #6
 1004832:	431c      	orrs	r4, r3
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
 1004834:	4408      	add	r0, r1
	struct log_msg_desc desc =
 1004836:	4b18      	ldr	r3, [pc, #96]	; (1004898 <z_impl_z_log_msg_runtime_vcreate+0xc4>)
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
 1004838:	f020 0007 	bic.w	r0, r0, #7
	struct log_msg_desc desc =
 100483c:	ea03 43c5 	and.w	r3, r3, r5, lsl #19
		msg = z_log_msg_alloc(msg_wlen);
 1004840:	0880      	lsrs	r0, r0, #2
	struct log_msg_desc desc =
 1004842:	431c      	orrs	r4, r3
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
 1004844:	9103      	str	r1, [sp, #12]
		msg = z_log_msg_alloc(msg_wlen);
 1004846:	f7ff fd6b 	bl	1004320 <z_log_msg_alloc>
			pkg = msg ? msg->data : NULL;
 100484a:	4605      	mov	r5, r0
 100484c:	b190      	cbz	r0, 1004874 <z_impl_z_log_msg_runtime_vcreate+0xa0>
	if (pkg && fmt) {
 100484e:	b18e      	cbz	r6, 1004874 <z_impl_z_log_msg_runtime_vcreate+0xa0>
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
 1004850:	4633      	mov	r3, r6
 1004852:	4652      	mov	r2, sl
 1004854:	9903      	ldr	r1, [sp, #12]
 1004856:	f8cd 9000 	str.w	r9, [sp]
 100485a:	3010      	adds	r0, #16
 100485c:	f7fd fcda 	bl	1002214 <cbvprintf_package>
		__ASSERT_NO_MSG(plen >= 0);
 1004860:	2800      	cmp	r0, #0
 1004862:	da07      	bge.n	1004874 <z_impl_z_log_msg_runtime_vcreate+0xa0>
 1004864:	4908      	ldr	r1, [pc, #32]	; (1004888 <z_impl_z_log_msg_runtime_vcreate+0xb4>)
 1004866:	2382      	movs	r3, #130	; 0x82
 1004868:	4a08      	ldr	r2, [pc, #32]	; (100488c <z_impl_z_log_msg_runtime_vcreate+0xb8>)
 100486a:	4809      	ldr	r0, [pc, #36]	; (1004890 <z_impl_z_log_msg_runtime_vcreate+0xbc>)
 100486c:	f020 f9b3 	bl	1024bd6 <assert_print>
 1004870:	2182      	movs	r1, #130	; 0x82
 1004872:	e7ce      	b.n	1004812 <z_impl_z_log_msg_runtime_vcreate+0x3e>
	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_msg(source, desc, pkg, data);
	}

	if (BACKENDS_IN_USE()) {
		z_log_msg_finalize(msg, source, desc, data);
 1004874:	4643      	mov	r3, r8
 1004876:	4622      	mov	r2, r4
 1004878:	4639      	mov	r1, r7
 100487a:	4628      	mov	r0, r5
	}
}
 100487c:	b007      	add	sp, #28
 100487e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		z_log_msg_finalize(msg, source, desc, data);
 1004882:	f020 bab4 	b.w	1024dee <z_log_msg_finalize>
 1004886:	bf00      	nop
 1004888:	0102c00f 	.word	0x0102c00f
 100488c:	0102bfe3 	.word	0x0102bfe3
 1004890:	0102b695 	.word	0x0102b695
 1004894:	0007fe00 	.word	0x0007fe00
 1004898:	7ff80000 	.word	0x7ff80000

0100489c <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
 100489c:	b40e      	push	{r1, r2, r3}
 100489e:	b503      	push	{r0, r1, lr}
 10048a0:	ab03      	add	r3, sp, #12
 10048a2:	f853 2b04 	ldr.w	r2, [r3], #4
 10048a6:	4601      	mov	r1, r0
	va_list args;
	int length = 0;

	va_start(args, fmt);
	length = cbvprintf(out_func, (void *)output, fmt, args);
 10048a8:	4804      	ldr	r0, [pc, #16]	; (10048bc <print_formatted+0x20>)
	va_start(args, fmt);
 10048aa:	9301      	str	r3, [sp, #4]
	length = cbvprintf(out_func, (void *)output, fmt, args);
 10048ac:	f020 fac6 	bl	1024e3c <cbvprintf>
	va_end(args);

	return length;
}
 10048b0:	b002      	add	sp, #8
 10048b2:	f85d eb04 	ldr.w	lr, [sp], #4
 10048b6:	b003      	add	sp, #12
 10048b8:	4770      	bx	lr
 10048ba:	bf00      	nop
 10048bc:	010048dd 	.word	0x010048dd

010048c0 <newline_print>:
	if (IS_ENABLED(CONFIG_LOG_BACKEND_NET) &&
	    flags & LOG_OUTPUT_FLAG_FORMAT_SYSLOG) {
		return;
	}

	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 10048c0:	06ca      	lsls	r2, r1, #27
 10048c2:	d405      	bmi.n	10048d0 <newline_print+0x10>
		return;
	}

	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 10048c4:	068b      	lsls	r3, r1, #26
		print_formatted(ctx, "\n");
 10048c6:	bf4c      	ite	mi
 10048c8:	4902      	ldrmi	r1, [pc, #8]	; (10048d4 <newline_print+0x14>)
	} else {
		print_formatted(ctx, "\r\n");
 10048ca:	4903      	ldrpl	r1, [pc, #12]	; (10048d8 <newline_print+0x18>)
 10048cc:	f7ff bfe6 	b.w	100489c <print_formatted>
	}
}
 10048d0:	4770      	bx	lr
 10048d2:	bf00      	nop
 10048d4:	0102ee85 	.word	0x0102ee85
 10048d8:	0102c019 	.word	0x0102c019

010048dc <out_func>:
{
 10048dc:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
 10048de:	684b      	ldr	r3, [r1, #4]
{
 10048e0:	4605      	mov	r5, r0
	if (out_ctx->control_block->offset == out_ctx->size) {
 10048e2:	681a      	ldr	r2, [r3, #0]
 10048e4:	68cb      	ldr	r3, [r1, #12]
{
 10048e6:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
 10048e8:	429a      	cmp	r2, r3
 10048ea:	d102      	bne.n	10048f2 <out_func+0x16>
		log_output_flush(out_ctx);
 10048ec:	4608      	mov	r0, r1
 10048ee:	f020 faac 	bl	1024e4a <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 10048f2:	6863      	ldr	r3, [r4, #4]
 10048f4:	e8d3 2fef 	ldaex	r2, [r3]
 10048f8:	1c51      	adds	r1, r2, #1
 10048fa:	e8c3 1fe0 	stlex	r0, r1, [r3]
 10048fe:	2800      	cmp	r0, #0
 1004900:	d1f8      	bne.n	10048f4 <out_func+0x18>
	out_ctx->buf[idx] = (uint8_t)c;
 1004902:	68a3      	ldr	r3, [r4, #8]
 1004904:	549d      	strb	r5, [r3, r2]
	__ASSERT_NO_MSG(out_ctx->control_block->offset <= out_ctx->size);
 1004906:	6863      	ldr	r3, [r4, #4]
 1004908:	681a      	ldr	r2, [r3, #0]
 100490a:	68e3      	ldr	r3, [r4, #12]
 100490c:	429a      	cmp	r2, r3
 100490e:	d909      	bls.n	1004924 <out_func+0x48>
 1004910:	4905      	ldr	r1, [pc, #20]	; (1004928 <out_func+0x4c>)
 1004912:	4806      	ldr	r0, [pc, #24]	; (100492c <out_func+0x50>)
 1004914:	2379      	movs	r3, #121	; 0x79
 1004916:	4a06      	ldr	r2, [pc, #24]	; (1004930 <out_func+0x54>)
 1004918:	f020 f95d 	bl	1024bd6 <assert_print>
 100491c:	2179      	movs	r1, #121	; 0x79
 100491e:	4804      	ldr	r0, [pc, #16]	; (1004930 <out_func+0x54>)
 1004920:	f020 f952 	bl	1024bc8 <assert_post_action>
}
 1004924:	2000      	movs	r0, #0
 1004926:	bd38      	pop	{r3, r4, r5, pc}
 1004928:	0102c04b 	.word	0x0102c04b
 100492c:	0102b695 	.word	0x0102b695
 1004930:	0102c01c 	.word	0x0102c01c

01004934 <log_output_process>:
			uint8_t level,
			const uint8_t *package,
			const uint8_t *data,
			size_t data_len,
			uint32_t flags)
{
 1004934:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1004938:	b089      	sub	sp, #36	; 0x24
 100493a:	469b      	mov	fp, r3
 100493c:	e9dd 7615 	ldrd	r7, r6, [sp, #84]	; 0x54
 1004940:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
 1004944:	4604      	mov	r4, r0
 1004946:	9304      	str	r3, [sp, #16]
 1004948:	e9dd 9313 	ldrd	r9, r3, [sp, #76]	; 0x4c
 100494c:	9305      	str	r3, [sp, #20]
	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
	uint32_t prefix_offset;
	cbprintf_cb cb;

	if (!raw_string) {
 100494e:	9b04      	ldr	r3, [sp, #16]
{
 1004950:	460d      	mov	r5, r1
 1004952:	9206      	str	r2, [sp, #24]
	if (!raw_string) {
 1004954:	2b00      	cmp	r3, #0
 1004956:	f000 8087 	beq.w	1004a68 <log_output_process+0x134>
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
 100495a:	f006 0308 	and.w	r3, r6, #8
 100495e:	9307      	str	r3, [sp, #28]
	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
 1004960:	f020 fa2d 	bl	1024dbe <z_log_get_tag>
	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
 1004964:	f006 0a02 	and.w	sl, r6, #2
	if (tag) {
 1004968:	4602      	mov	r2, r0
 100496a:	2800      	cmp	r0, #0
 100496c:	d04b      	beq.n	1004a06 <log_output_process+0xd2>
		length += print_formatted(output, "%s ", tag);
 100496e:	4620      	mov	r0, r4
 1004970:	498d      	ldr	r1, [pc, #564]	; (1004ba8 <log_output_process+0x274>)
 1004972:	f7ff ff93 	bl	100489c <print_formatted>
 1004976:	4680      	mov	r8, r0
	if (stamp) {
 1004978:	f1ba 0f00 	cmp.w	sl, #0
 100497c:	d008      	beq.n	1004990 <log_output_process+0x5c>
	if (!format) {
 100497e:	f016 0f44 	tst.w	r6, #68	; 0x44
 1004982:	d142      	bne.n	1004a0a <log_output_process+0xd6>
		length = print_formatted(output, "[%08lu] ", timestamp);
 1004984:	462a      	mov	r2, r5
 1004986:	4620      	mov	r0, r4
 1004988:	4988      	ldr	r1, [pc, #544]	; (1004bac <log_output_process+0x278>)
 100498a:	f7ff ff87 	bl	100489c <print_formatted>
		length += timestamp_print(output, flags, timestamp);
 100498e:	4480      	add	r8, r0
	if (color) {
 1004990:	f006 0301 	and.w	r3, r6, #1
 1004994:	b15b      	cbz	r3, 10049ae <log_output_process+0x7a>
		const char *log_color = start && (colors[level] != NULL) ?
 1004996:	4b86      	ldr	r3, [pc, #536]	; (1004bb0 <log_output_process+0x27c>)
 1004998:	9a04      	ldr	r2, [sp, #16]
		print_formatted(output, "%s", log_color);
 100499a:	4620      	mov	r0, r4
		const char *log_color = start && (colors[level] != NULL) ?
 100499c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
		print_formatted(output, "%s", log_color);
 10049a0:	4b84      	ldr	r3, [pc, #528]	; (1004bb4 <log_output_process+0x280>)
 10049a2:	4985      	ldr	r1, [pc, #532]	; (1004bb8 <log_output_process+0x284>)
 10049a4:	2a00      	cmp	r2, #0
 10049a6:	bf08      	it	eq
 10049a8:	461a      	moveq	r2, r3
 10049aa:	f7ff ff77 	bl	100489c <print_formatted>
	if (level_on) {
 10049ae:	f006 0308 	and.w	r3, r6, #8
 10049b2:	2b00      	cmp	r3, #0
 10049b4:	d055      	beq.n	1004a62 <log_output_process+0x12e>
		total += print_formatted(output, "<%s> ", severity[level]);
 10049b6:	4b81      	ldr	r3, [pc, #516]	; (1004bbc <log_output_process+0x288>)
 10049b8:	9a04      	ldr	r2, [sp, #16]
 10049ba:	4620      	mov	r0, r4
 10049bc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 10049c0:	497f      	ldr	r1, [pc, #508]	; (1004bc0 <log_output_process+0x28c>)
 10049c2:	f7ff ff6b 	bl	100489c <print_formatted>
 10049c6:	4605      	mov	r5, r0
	if (domain) {
 10049c8:	9b06      	ldr	r3, [sp, #24]
 10049ca:	b12b      	cbz	r3, 10049d8 <log_output_process+0xa4>
		total += print_formatted(output, "%s/", domain);
 10049cc:	461a      	mov	r2, r3
 10049ce:	4620      	mov	r0, r4
 10049d0:	497c      	ldr	r1, [pc, #496]	; (1004bc4 <log_output_process+0x290>)
 10049d2:	f7ff ff63 	bl	100489c <print_formatted>
 10049d6:	4405      	add	r5, r0
	if (source) {
 10049d8:	f1bb 0f00 	cmp.w	fp, #0
 10049dc:	d005      	beq.n	10049ea <log_output_process+0xb6>
		total += print_formatted(output,
 10049de:	465a      	mov	r2, fp
 10049e0:	4620      	mov	r0, r4
 10049e2:	4979      	ldr	r1, [pc, #484]	; (1004bc8 <log_output_process+0x294>)
 10049e4:	f7ff ff5a 	bl	100489c <print_formatted>
 10049e8:	4405      	add	r5, r0
	length += ids_print(output, level_on, func_on, domain, source, level);
 10049ea:	4445      	add	r5, r8
		 * appending <CR> to the new line character).
		 */
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
	}

	if (package) {
 10049ec:	f1b9 0f00 	cmp.w	r9, #0
 10049f0:	d14a      	bne.n	1004a88 <log_output_process+0x154>

		(void)err;
		__ASSERT_NO_MSG(err >= 0);
	}

	if (data_len) {
 10049f2:	2f00      	cmp	r7, #0
 10049f4:	d161      	bne.n	1004aba <log_output_process+0x186>
	if (color) {
 10049f6:	07f3      	lsls	r3, r6, #31
 10049f8:	f100 80cf 	bmi.w	1004b9a <log_output_process+0x266>
	newline_print(output, flags);
 10049fc:	4631      	mov	r1, r6
 10049fe:	4620      	mov	r0, r4
 1004a00:	f7ff ff5e 	bl	10048c0 <newline_print>
}
 1004a04:	e0c3      	b.n	1004b8e <log_output_process+0x25a>
	uint32_t length = 0U;
 1004a06:	4680      	mov	r8, r0
 1004a08:	e7b6      	b.n	1004978 <log_output_process+0x44>
	} else if (freq != 0U) {
 1004a0a:	4b70      	ldr	r3, [pc, #448]	; (1004bcc <log_output_process+0x298>)
 1004a0c:	6818      	ldr	r0, [r3, #0]
 1004a0e:	2800      	cmp	r0, #0
 1004a10:	d0bd      	beq.n	100498e <log_output_process+0x5a>
		timestamp /= timestamp_div;
 1004a12:	4b6f      	ldr	r3, [pc, #444]	; (1004bd0 <log_output_process+0x29c>)
		ms = (remainder * 1000U) / freq;
 1004a14:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
		timestamp /= timestamp_div;
 1004a18:	681b      	ldr	r3, [r3, #0]
 1004a1a:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 1004a1e:	fbb5 f5f3 	udiv	r5, r5, r3
		total_seconds = timestamp / freq;
 1004a22:	fbb5 f3f0 	udiv	r3, r5, r0
		remainder = timestamp % freq;
 1004a26:	fb00 5513 	mls	r5, r0, r3, r5
		ms = (remainder * 1000U) / freq;
 1004a2a:	fb0e f505 	mul.w	r5, lr, r5
 1004a2e:	fbb3 faf2 	udiv	sl, r3, r2
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 1004a32:	fbb5 fcf0 	udiv	ip, r5, r0
		mins = seconds / 60U;
 1004a36:	213c      	movs	r1, #60	; 0x3c
 1004a38:	fb02 321a 	mls	r2, r2, sl, r3
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 1004a3c:	fb00 551c 	mls	r5, r0, ip, r5
		mins = seconds / 60U;
 1004a40:	fbb2 f3f1 	udiv	r3, r2, r1
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 1004a44:	fb0e f505 	mul.w	r5, lr, r5
 1004a48:	fbb5 f5f0 	udiv	r5, r5, r0
				length = print_formatted(output,
 1004a4c:	fb01 2213 	mls	r2, r1, r3, r2
 1004a50:	4620      	mov	r0, r4
 1004a52:	9200      	str	r2, [sp, #0]
 1004a54:	e9cd c501 	strd	ip, r5, [sp, #4]
 1004a58:	4652      	mov	r2, sl
 1004a5a:	495e      	ldr	r1, [pc, #376]	; (1004bd4 <log_output_process+0x2a0>)
 1004a5c:	f7ff ff1e 	bl	100489c <print_formatted>
 1004a60:	e795      	b.n	100498e <log_output_process+0x5a>
	int total = 0;
 1004a62:	f006 0508 	and.w	r5, r6, #8
 1004a66:	e7af      	b.n	10049c8 <log_output_process+0x94>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
 1004a68:	f1bb 0f01 	cmp.w	fp, #1
 1004a6c:	d107      	bne.n	1004a7e <log_output_process+0x14a>
	if (package) {
 1004a6e:	f1b9 0f00 	cmp.w	r9, #0
 1004a72:	d11d      	bne.n	1004ab0 <log_output_process+0x17c>
	if (data_len) {
 1004a74:	2f00      	cmp	r7, #0
 1004a76:	f000 808a 	beq.w	1004b8e <log_output_process+0x25a>
		prefix_offset = 0;
 1004a7a:	2500      	movs	r5, #0
 1004a7c:	e01d      	b.n	1004aba <log_output_process+0x186>
	if (package) {
 1004a7e:	f1b9 0f00 	cmp.w	r9, #0
 1004a82:	d0f7      	beq.n	1004a74 <log_output_process+0x140>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
 1004a84:	4854      	ldr	r0, [pc, #336]	; (1004bd8 <log_output_process+0x2a4>)
 1004a86:	e014      	b.n	1004ab2 <log_output_process+0x17e>
		cb = out_func;
 1004a88:	4854      	ldr	r0, [pc, #336]	; (1004bdc <log_output_process+0x2a8>)
		return cbpprintf_external(out, cbvprintf_tagged_args,
					  ctx, packaged);
	}
#endif

	return cbpprintf_external(out, cbvprintf, ctx, packaged);
 1004a8a:	464b      	mov	r3, r9
 1004a8c:	4622      	mov	r2, r4
 1004a8e:	4954      	ldr	r1, [pc, #336]	; (1004be0 <log_output_process+0x2ac>)
 1004a90:	f01f fdb3 	bl	10245fa <cbpprintf_external>
		__ASSERT_NO_MSG(err >= 0);
 1004a94:	2800      	cmp	r0, #0
 1004a96:	da0e      	bge.n	1004ab6 <log_output_process+0x182>
 1004a98:	4952      	ldr	r1, [pc, #328]	; (1004be4 <log_output_process+0x2b0>)
 1004a9a:	4853      	ldr	r0, [pc, #332]	; (1004be8 <log_output_process+0x2b4>)
 1004a9c:	f44f 7300 	mov.w	r3, #512	; 0x200
 1004aa0:	4a52      	ldr	r2, [pc, #328]	; (1004bec <log_output_process+0x2b8>)
 1004aa2:	f020 f898 	bl	1024bd6 <assert_print>
 1004aa6:	f44f 7100 	mov.w	r1, #512	; 0x200
 1004aaa:	4850      	ldr	r0, [pc, #320]	; (1004bec <log_output_process+0x2b8>)
 1004aac:	f020 f88c 	bl	1024bc8 <assert_post_action>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
 1004ab0:	484a      	ldr	r0, [pc, #296]	; (1004bdc <log_output_process+0x2a8>)
		prefix_offset = 0;
 1004ab2:	9d04      	ldr	r5, [sp, #16]
 1004ab4:	e7e9      	b.n	1004a8a <log_output_process+0x156>
	if (data_len) {
 1004ab6:	2f00      	cmp	r7, #0
 1004ab8:	d065      	beq.n	1004b86 <log_output_process+0x252>
		print_formatted(output, " ");
 1004aba:	f8df 9134 	ldr.w	r9, [pc, #308]	; 1004bf0 <log_output_process+0x2bc>
			print_formatted(output, "%02x ", data[i]);
 1004abe:	f8df a134 	ldr.w	sl, [pc, #308]	; 1004bf4 <log_output_process+0x2c0>
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
 1004ac2:	2f10      	cmp	r7, #16
	newline_print(output, flags);
 1004ac4:	4631      	mov	r1, r6
 1004ac6:	4620      	mov	r0, r4
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
 1004ac8:	46b8      	mov	r8, r7
	for (int i = 0; i < prefix_offset; i++) {
 1004aca:	f04f 0b00 	mov.w	fp, #0
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
 1004ace:	bf28      	it	cs
 1004ad0:	f04f 0810 	movcs.w	r8, #16
	newline_print(output, flags);
 1004ad4:	f7ff fef4 	bl	10048c0 <newline_print>
	for (int i = 0; i < prefix_offset; i++) {
 1004ad8:	455d      	cmp	r5, fp
 1004ada:	dc42      	bgt.n	1004b62 <log_output_process+0x22e>
			print_formatted(output, "%02x ", data[i]);
 1004adc:	9b05      	ldr	r3, [sp, #20]
 1004ade:	4651      	mov	r1, sl
 1004ae0:	4620      	mov	r0, r4
 1004ae2:	781a      	ldrb	r2, [r3, #0]
 1004ae4:	f7ff feda 	bl	100489c <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 1004ae8:	f04f 0b01 	mov.w	fp, #1
		if (i > 0 && !(i % 8)) {
 1004aec:	f01b 0f07 	tst.w	fp, #7
 1004af0:	d103      	bne.n	1004afa <log_output_process+0x1c6>
			print_formatted(output, " ");
 1004af2:	4649      	mov	r1, r9
 1004af4:	4620      	mov	r0, r4
 1004af6:	f7ff fed1 	bl	100489c <print_formatted>
		if (i < length) {
 1004afa:	45d8      	cmp	r8, fp
 1004afc:	d938      	bls.n	1004b70 <log_output_process+0x23c>
			print_formatted(output, "%02x ", data[i]);
 1004afe:	9b05      	ldr	r3, [sp, #20]
 1004b00:	4651      	mov	r1, sl
 1004b02:	4620      	mov	r0, r4
 1004b04:	f813 200b 	ldrb.w	r2, [r3, fp]
 1004b08:	f7ff fec8 	bl	100489c <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 1004b0c:	f10b 0b01 	add.w	fp, fp, #1
 1004b10:	f1bb 0f10 	cmp.w	fp, #16
 1004b14:	d1ea      	bne.n	1004aec <log_output_process+0x1b8>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 1004b16:	f04f 0b00 	mov.w	fp, #0
	print_formatted(output, "|");
 1004b1a:	4620      	mov	r0, r4
 1004b1c:	4936      	ldr	r1, [pc, #216]	; (1004bf8 <log_output_process+0x2c4>)
 1004b1e:	f7ff febd 	bl	100489c <print_formatted>
		if (i < length) {
 1004b22:	465a      	mov	r2, fp
			unsigned char c = (unsigned char)data[i];
 1004b24:	9b05      	ldr	r3, [sp, #20]
			print_formatted(output, "%c",
 1004b26:	4620      	mov	r0, r4
			unsigned char c = (unsigned char)data[i];
 1004b28:	5c9a      	ldrb	r2, [r3, r2]
	return (int)((((unsigned)c) >= ' ') &&
 1004b2a:	f1a2 0120 	sub.w	r1, r2, #32
			print_formatted(output, "%c",
 1004b2e:	295f      	cmp	r1, #95	; 0x5f
 1004b30:	bf28      	it	cs
 1004b32:	222e      	movcs	r2, #46	; 0x2e
 1004b34:	4931      	ldr	r1, [pc, #196]	; (1004bfc <log_output_process+0x2c8>)
 1004b36:	f7ff feb1 	bl	100489c <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 1004b3a:	f10b 0b01 	add.w	fp, fp, #1
 1004b3e:	f1bb 0f10 	cmp.w	fp, #16
 1004b42:	d01a      	beq.n	1004b7a <log_output_process+0x246>
		if (i > 0 && !(i % 8)) {
 1004b44:	f01b 0f07 	tst.w	fp, #7
 1004b48:	d103      	bne.n	1004b52 <log_output_process+0x21e>
			print_formatted(output, " ");
 1004b4a:	4649      	mov	r1, r9
 1004b4c:	4620      	mov	r0, r4
 1004b4e:	f7ff fea5 	bl	100489c <print_formatted>
		if (i < length) {
 1004b52:	45d8      	cmp	r8, fp
 1004b54:	465a      	mov	r2, fp
 1004b56:	d8e5      	bhi.n	1004b24 <log_output_process+0x1f0>
			print_formatted(output, " ");
 1004b58:	4649      	mov	r1, r9
 1004b5a:	4620      	mov	r0, r4
 1004b5c:	f7ff fe9e 	bl	100489c <print_formatted>
 1004b60:	e7eb      	b.n	1004b3a <log_output_process+0x206>
		print_formatted(output, " ");
 1004b62:	4649      	mov	r1, r9
 1004b64:	4620      	mov	r0, r4
 1004b66:	f7ff fe99 	bl	100489c <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
 1004b6a:	f10b 0b01 	add.w	fp, fp, #1
 1004b6e:	e7b3      	b.n	1004ad8 <log_output_process+0x1a4>
			print_formatted(output, "   ");
 1004b70:	4620      	mov	r0, r4
 1004b72:	4923      	ldr	r1, [pc, #140]	; (1004c00 <log_output_process+0x2cc>)
 1004b74:	f7ff fe92 	bl	100489c <print_formatted>
 1004b78:	e7c8      	b.n	1004b0c <log_output_process+0x1d8>
		data += length;
 1004b7a:	9b05      	ldr	r3, [sp, #20]
	} while (len);
 1004b7c:	ebb7 0708 	subs.w	r7, r7, r8
		data += length;
 1004b80:	4443      	add	r3, r8
 1004b82:	9305      	str	r3, [sp, #20]
	} while (len);
 1004b84:	d19d      	bne.n	1004ac2 <log_output_process+0x18e>
		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
	}

	if (!raw_string) {
 1004b86:	9b04      	ldr	r3, [sp, #16]
 1004b88:	2b00      	cmp	r3, #0
 1004b8a:	f47f af34 	bne.w	10049f6 <log_output_process+0xc2>
		postfix_print(output, flags, level);
	}

	log_output_flush(output);
 1004b8e:	4620      	mov	r0, r4
}
 1004b90:	b009      	add	sp, #36	; 0x24
 1004b92:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	log_output_flush(output);
 1004b96:	f020 b958 	b.w	1024e4a <log_output_flush>
		print_formatted(output, "%s", log_color);
 1004b9a:	4620      	mov	r0, r4
 1004b9c:	4a05      	ldr	r2, [pc, #20]	; (1004bb4 <log_output_process+0x280>)
 1004b9e:	4906      	ldr	r1, [pc, #24]	; (1004bb8 <log_output_process+0x284>)
 1004ba0:	f7ff fe7c 	bl	100489c <print_formatted>
}
 1004ba4:	e72a      	b.n	10049fc <log_output_process+0xc8>
 1004ba6:	bf00      	nop
 1004ba8:	0102c080 	.word	0x0102c080
 1004bac:	0102c084 	.word	0x0102c084
 1004bb0:	01029bcc 	.word	0x01029bcc
 1004bb4:	0102c07b 	.word	0x0102c07b
 1004bb8:	0102b4e3 	.word	0x0102b4e3
 1004bbc:	01029be0 	.word	0x01029be0
 1004bc0:	0102c0a9 	.word	0x0102c0a9
 1004bc4:	0102c0af 	.word	0x0102c0af
 1004bc8:	0102c0b3 	.word	0x0102c0b3
 1004bcc:	210045f4 	.word	0x210045f4
 1004bd0:	210045f0 	.word	0x210045f0
 1004bd4:	0102c08d 	.word	0x0102c08d
 1004bd8:	01024e65 	.word	0x01024e65
 1004bdc:	010048dd 	.word	0x010048dd
 1004be0:	01024e3d 	.word	0x01024e3d
 1004be4:	0102c0b8 	.word	0x0102c0b8
 1004be8:	0102b695 	.word	0x0102b695
 1004bec:	0102c01c 	.word	0x0102c01c
 1004bf0:	0102c0c9 	.word	0x0102c0c9
 1004bf4:	0102c0c1 	.word	0x0102c0c1
 1004bf8:	0102c0cb 	.word	0x0102c0cb
 1004bfc:	0102b86a 	.word	0x0102b86a
 1004c00:	0102c0c7 	.word	0x0102c0c7

01004c04 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg, uint32_t flags)
{
 1004c04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 *
 * @return Log level.
 */
static inline uint8_t log_msg_get_level(struct log_msg *msg)
{
	return msg->hdr.desc.level;
 1004c08:	880f      	ldrh	r7, [r1, #0]
 *
 * @return Pointer to the source data.
 */
static inline const void *log_msg_get_source(struct log_msg *msg)
{
	return msg->hdr.source;
 1004c0a:	684b      	ldr	r3, [r1, #4]
 1004c0c:	4605      	mov	r5, r0
 1004c0e:	460c      	mov	r4, r1
 1004c10:	4690      	mov	r8, r2
 *
 * @return Timestamp.
 */
static inline log_timestamp_t log_msg_get_timestamp(struct log_msg *msg)
{
	return msg->hdr.timestamp;
 1004c12:	688e      	ldr	r6, [r1, #8]
 1004c14:	b086      	sub	sp, #24
	return msg->hdr.desc.level;
 1004c16:	f3c7 1782 	ubfx	r7, r7, #6, #3
		/* Remote domain is converting source pointer to ID */
		source_id = (int16_t)(uintptr_t)log_msg_get_source(msg);
	} else {
		void *source = (void *)log_msg_get_source(msg);

		if (source != NULL) {
 1004c1a:	b15b      	cbz	r3, 1004c34 <log_output_msg_process+0x30>
 1004c1c:	4a13      	ldr	r2, [pc, #76]	; (1004c6c <log_output_msg_process+0x68>)
 1004c1e:	1a9b      	subs	r3, r3, r2
			source_id = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ?
 1004c20:	f343 01cf 	sbfx	r1, r3, #3, #16
		} else {
			source_id = -1;
		}
	}

	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
 1004c24:	2900      	cmp	r1, #0
 1004c26:	db1f      	blt.n	1004c68 <log_output_msg_process+0x64>
	return msg->hdr.desc.domain;
 1004c28:	7820      	ldrb	r0, [r4, #0]
 1004c2a:	f3c0 00c2 	ubfx	r0, r0, #3, #3
 1004c2e:	f7ff fd37 	bl	10046a0 <log_source_name_get>
 1004c32:	4603      	mov	r3, r0
 *
 * @return pointer to the package.
 */
static inline uint8_t *log_msg_get_package(struct log_msg *msg, size_t *len)
{
	*len = msg->hdr.desc.package_len;
 1004c34:	4621      	mov	r1, r4
 1004c36:	f851 2b10 	ldr.w	r2, [r1], #16
	*len = msg->hdr.desc.data_len;
 1004c3a:	8860      	ldrh	r0, [r4, #2]
	*len = msg->hdr.desc.package_len;
 1004c3c:	f3c2 2249 	ubfx	r2, r2, #9, #10
	size_t plen, dlen;
	uint8_t *package = log_msg_get_package(msg, &plen);
	uint8_t *data = log_msg_get_data(msg, &dlen);

	log_output_process(output, timestamp, NULL, sname, level,
 1004c40:	2a00      	cmp	r2, #0
	return msg->data + msg->hdr.desc.package_len;
 1004c42:	eb01 0402 	add.w	r4, r1, r2
 1004c46:	bf08      	it	eq
 1004c48:	2100      	moveq	r1, #0
	*len = msg->hdr.desc.data_len;
 1004c4a:	f3c0 00cb 	ubfx	r0, r0, #3, #12
 1004c4e:	e9cd 0803 	strd	r0, r8, [sp, #12]
 1004c52:	e9cd 1401 	strd	r1, r4, [sp, #4]
 1004c56:	2200      	movs	r2, #0
 1004c58:	4631      	mov	r1, r6
 1004c5a:	4628      	mov	r0, r5
 1004c5c:	9700      	str	r7, [sp, #0]
 1004c5e:	f7ff fe69 	bl	1004934 <log_output_process>
			   plen > 0 ? package : NULL, data, dlen, flags);
}
 1004c62:	b006      	add	sp, #24
 1004c64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
 1004c68:	2300      	movs	r3, #0
 1004c6a:	e7e3      	b.n	1004c34 <log_output_msg_process+0x30>
 1004c6c:	01029944 	.word	0x01029944

01004c70 <log_output_dropped_process>:
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
 1004c70:	f242 730f 	movw	r3, #9999	; 0x270f
{
 1004c74:	b573      	push	{r0, r1, r4, r5, r6, lr}
	len = snprintk(buf, sizeof(buf), "%d", cnt);
 1004c76:	428b      	cmp	r3, r1
 1004c78:	bf28      	it	cs
 1004c7a:	460b      	movcs	r3, r1
	log_output_func_t outf = output->func;
 1004c7c:	6805      	ldr	r5, [r0, #0]
{
 1004c7e:	4604      	mov	r4, r0
	len = snprintk(buf, sizeof(buf), "%d", cnt);
 1004c80:	2105      	movs	r1, #5
 1004c82:	4668      	mov	r0, sp
 1004c84:	4a0d      	ldr	r2, [pc, #52]	; (1004cbc <log_output_dropped_process+0x4c>)
 1004c86:	f01f fdab 	bl	10247e0 <snprintk>
 1004c8a:	4606      	mov	r6, r0

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
 1004c8c:	6863      	ldr	r3, [r4, #4]
 1004c8e:	4628      	mov	r0, r5
 1004c90:	220b      	movs	r2, #11
 1004c92:	685b      	ldr	r3, [r3, #4]
 1004c94:	490a      	ldr	r1, [pc, #40]	; (1004cc0 <log_output_dropped_process+0x50>)
 1004c96:	f020 f8c4 	bl	1024e22 <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
 1004c9a:	6863      	ldr	r3, [r4, #4]
 1004c9c:	4632      	mov	r2, r6
 1004c9e:	4669      	mov	r1, sp
 1004ca0:	4628      	mov	r0, r5
 1004ca2:	685b      	ldr	r3, [r3, #4]
 1004ca4:	f020 f8bd 	bl	1024e22 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
 1004ca8:	6863      	ldr	r3, [r4, #4]
 1004caa:	221b      	movs	r2, #27
 1004cac:	4628      	mov	r0, r5
 1004cae:	685b      	ldr	r3, [r3, #4]
 1004cb0:	4904      	ldr	r1, [pc, #16]	; (1004cc4 <log_output_dropped_process+0x54>)
 1004cb2:	f020 f8b6 	bl	1024e22 <buffer_write>
		     output->control_block->ctx);
}
 1004cb6:	b002      	add	sp, #8
 1004cb8:	bd70      	pop	{r4, r5, r6, pc}
 1004cba:	bf00      	nop
 1004cbc:	0102b4cd 	.word	0x0102b4cd
 1004cc0:	0102c0e9 	.word	0x0102c0e9
 1004cc4:	0102c0cd 	.word	0x0102c0cd

01004cc8 <log_output_timestamp_freq_set>:
{
	timestamp_div = 1U;
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
 1004cc8:	2100      	movs	r1, #0
 1004cca:	2301      	movs	r3, #1
 1004ccc:	4a06      	ldr	r2, [pc, #24]	; (1004ce8 <log_output_timestamp_freq_set+0x20>)
 1004cce:	4290      	cmp	r0, r2
 1004cd0:	d806      	bhi.n	1004ce0 <log_output_timestamp_freq_set+0x18>
 1004cd2:	4a06      	ldr	r2, [pc, #24]	; (1004cec <log_output_timestamp_freq_set+0x24>)
 1004cd4:	b901      	cbnz	r1, 1004cd8 <log_output_timestamp_freq_set+0x10>
	timestamp_div = 1U;
 1004cd6:	2301      	movs	r3, #1
 1004cd8:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
 1004cda:	4b05      	ldr	r3, [pc, #20]	; (1004cf0 <log_output_timestamp_freq_set+0x28>)
 1004cdc:	6018      	str	r0, [r3, #0]
}
 1004cde:	4770      	bx	lr
		timestamp_div *= 2U;
 1004ce0:	2101      	movs	r1, #1
		frequency /= 2U;
 1004ce2:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
 1004ce4:	005b      	lsls	r3, r3, #1
 1004ce6:	e7f2      	b.n	1004cce <log_output_timestamp_freq_set+0x6>
 1004ce8:	000f4240 	.word	0x000f4240
 1004cec:	210045f0 	.word	0x210045f0
 1004cf0:	210045f4 	.word	0x210045f4

01004cf4 <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
 1004cf4:	2201      	movs	r2, #1
 1004cf6:	4b01      	ldr	r3, [pc, #4]	; (1004cfc <log_backend_rtt_init+0x8>)
 1004cf8:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
 1004cfa:	4770      	bx	lr
 1004cfc:	210081f2 	.word	0x210081f2

01004d00 <format_set>:
	log_output_func(&log_output_rtt, &msg->log, flags);
}

static int format_set(const struct log_backend *const backend, uint32_t log_type)
{
	log_format_current = log_type;
 1004d00:	4b01      	ldr	r3, [pc, #4]	; (1004d08 <format_set+0x8>)
	return 0;
}
 1004d02:	2000      	movs	r0, #0
	log_format_current = log_type;
 1004d04:	6019      	str	r1, [r3, #0]
}
 1004d06:	4770      	bx	lr
 1004d08:	2100460c 	.word	0x2100460c

01004d0c <panic>:
	panic_mode = true;
 1004d0c:	2201      	movs	r2, #1
 1004d0e:	4b02      	ldr	r3, [pc, #8]	; (1004d18 <panic+0xc>)
 * @param output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const output)
{
	log_output_flush(output);
 1004d10:	4802      	ldr	r0, [pc, #8]	; (1004d1c <panic+0x10>)
 1004d12:	701a      	strb	r2, [r3, #0]
 1004d14:	f020 b899 	b.w	1024e4a <log_output_flush>
 1004d18:	210081f3 	.word	0x210081f3
 1004d1c:	01029c10 	.word	0x01029c10

01004d20 <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const output, uint32_t cnt)
{
	log_output_dropped_process(output, cnt);
 1004d20:	4801      	ldr	r0, [pc, #4]	; (1004d28 <dropped+0x8>)
 1004d22:	f7ff bfa5 	b.w	1004c70 <log_output_dropped_process>
 1004d26:	bf00      	nop
 1004d28:	01029c10 	.word	0x01029c10

01004d2c <process>:
{
 1004d2c:	b510      	push	{r4, lr}
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
 1004d2e:	4b06      	ldr	r3, [pc, #24]	; (1004d48 <process+0x1c>)
{
 1004d30:	460c      	mov	r4, r1
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
 1004d32:	6818      	ldr	r0, [r3, #0]
 1004d34:	f7ff fa5a 	bl	10041ec <log_format_func_t_get>
	log_output_func(&log_output_rtt, &msg->log, flags);
 1004d38:	4621      	mov	r1, r4
}
 1004d3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
 1004d3e:	4603      	mov	r3, r0
	log_output_func(&log_output_rtt, &msg->log, flags);
 1004d40:	220f      	movs	r2, #15
 1004d42:	4802      	ldr	r0, [pc, #8]	; (1004d4c <process+0x20>)
 1004d44:	4718      	bx	r3
 1004d46:	bf00      	nop
 1004d48:	2100460c 	.word	0x2100460c
 1004d4c:	01029c10 	.word	0x01029c10

01004d50 <on_failed_write>:
	if (retry_cnt == 0) {
 1004d50:	b910      	cbnz	r0, 1004d58 <on_failed_write+0x8>
		host_present = false;
 1004d52:	4b07      	ldr	r3, [pc, #28]	; (1004d70 <on_failed_write+0x20>)
 1004d54:	7018      	strb	r0, [r3, #0]
}
 1004d56:	4770      	bx	lr
	return IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE) || panic_mode;
 1004d58:	4b06      	ldr	r3, [pc, #24]	; (1004d74 <on_failed_write+0x24>)
	} else if (is_sync_mode()) {
 1004d5a:	781b      	ldrb	r3, [r3, #0]
 1004d5c:	b11b      	cbz	r3, 1004d66 <on_failed_write+0x16>
	z_impl_k_busy_wait(usec_to_wait);
 1004d5e:	f241 3088 	movw	r0, #5000	; 0x1388
 1004d62:	f024 bb83 	b.w	102946c <z_impl_k_busy_wait>
	return z_impl_k_sleep(timeout);
 1004d66:	20a4      	movs	r0, #164	; 0xa4
 1004d68:	2100      	movs	r1, #0
 1004d6a:	f01e bb3f 	b.w	10233ec <z_impl_k_sleep>
 1004d6e:	bf00      	nop
 1004d70:	210081f2 	.word	0x210081f2
 1004d74:	210081f3 	.word	0x210081f3

01004d78 <data_out_block_mode>:
{
 1004d78:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1004d7c:	4680      	mov	r8, r0
 1004d7e:	460e      	mov	r6, r1
	int retry_cnt = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_MODE_BLOCK) ?
 1004d80:	2404      	movs	r4, #4
	return IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE) || panic_mode;
 1004d82:	f8df 9070 	ldr.w	r9, [pc, #112]	; 1004df4 <data_out_block_mode+0x7c>
 1004d86:	4f1c      	ldr	r7, [pc, #112]	; (1004df8 <data_out_block_mode+0x80>)
		if (!is_sync_mode()) {
 1004d88:	f899 5000 	ldrb.w	r5, [r9]
 1004d8c:	b995      	cbnz	r5, 1004db4 <data_out_block_mode+0x3c>
			RTT_LOCK();
 1004d8e:	f01b fcb1 	bl	10206f4 <zephyr_rtt_mutex_lock>
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
 1004d92:	4628      	mov	r0, r5
 1004d94:	4632      	mov	r2, r6
 1004d96:	4641      	mov	r1, r8
 1004d98:	f01b fc2e 	bl	10205f8 <SEGGER_RTT_WriteSkipNoLock>
 1004d9c:	4605      	mov	r5, r0
			RTT_UNLOCK();
 1004d9e:	f01b fcb3 	bl	1020708 <zephyr_rtt_mutex_unlock>
		if (ret) {
 1004da2:	b1e5      	cbz	r5, 1004dde <data_out_block_mode+0x66>
	host_present = true;
 1004da4:	2301      	movs	r3, #1
 1004da6:	703b      	strb	r3, [r7, #0]
	if (is_panic_mode()) {
 1004da8:	f899 3000 	ldrb.w	r3, [r9]
 1004dac:	b973      	cbnz	r3, 1004dcc <data_out_block_mode+0x54>
}
 1004dae:	4630      	mov	r0, r6
 1004db0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
 1004db4:	4632      	mov	r2, r6
 1004db6:	4641      	mov	r1, r8
 1004db8:	2000      	movs	r0, #0
 1004dba:	f01b fc1d 	bl	10205f8 <SEGGER_RTT_WriteSkipNoLock>
 1004dbe:	4605      	mov	r5, r0
 1004dc0:	e7ef      	b.n	1004da2 <data_out_block_mode+0x2a>
			on_failed_write(retry_cnt--);
 1004dc2:	4620      	mov	r0, r4
 1004dc4:	1e65      	subs	r5, r4, #1
 1004dc6:	f7ff ffc3 	bl	1004d50 <on_failed_write>
 1004dca:	462c      	mov	r4, r5
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
 1004dcc:	2000      	movs	r0, #0
 1004dce:	f01b fc87 	bl	10206e0 <SEGGER_RTT_HasDataUp>
 1004dd2:	2800      	cmp	r0, #0
 1004dd4:	d0eb      	beq.n	1004dae <data_out_block_mode+0x36>
 1004dd6:	783b      	ldrb	r3, [r7, #0]
 1004dd8:	2b00      	cmp	r3, #0
 1004dda:	d1f2      	bne.n	1004dc2 <data_out_block_mode+0x4a>
 1004ddc:	e7e7      	b.n	1004dae <data_out_block_mode+0x36>
		} else if (host_present) {
 1004dde:	783b      	ldrb	r3, [r7, #0]
 1004de0:	2b00      	cmp	r3, #0
 1004de2:	d0e4      	beq.n	1004dae <data_out_block_mode+0x36>
			retry_cnt--;
 1004de4:	3c01      	subs	r4, #1
			on_failed_write(retry_cnt);
 1004de6:	4620      	mov	r0, r4
 1004de8:	f7ff ffb2 	bl	1004d50 <on_failed_write>
	} while ((ret == 0) && host_present);
 1004dec:	783b      	ldrb	r3, [r7, #0]
 1004dee:	2b00      	cmp	r3, #0
 1004df0:	d1ca      	bne.n	1004d88 <data_out_block_mode+0x10>
 1004df2:	e7dc      	b.n	1004dae <data_out_block_mode+0x36>
 1004df4:	210081f3 	.word	0x210081f3
 1004df8:	210081f2 	.word	0x210081f2

01004dfc <nvs_recover_last_ate>:
 *
 * addr should point to the faulty closing ate and will be updated to the last
 * valid ate. If no valid ate is found it will be left untouched.
 */
static int nvs_recover_last_ate(struct nvs_fs *fs, uint32_t *addr)
{
 1004dfc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 1004e00:	460f      	mov	r7, r1
 1004e02:	4606      	mov	r6, r0
	int rc;

	LOG_DBG("Recovering last ate from sector %d",
		(*addr >> ADDR_SECT_SHIFT));

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
 1004e04:	2108      	movs	r1, #8
 1004e06:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 1004e08:	f020 f8ca 	bl	1024fa0 <nvs_al_size.isra.0>
 1004e0c:	4680      	mov	r8, r0

	*addr -= ate_size;
 1004e0e:	683c      	ldr	r4, [r7, #0]
	ate_end_addr = *addr;
	data_end_addr = *addr & ADDR_SECT_MASK;
 1004e10:	f8df 9048 	ldr.w	r9, [pc, #72]	; 1004e5c <nvs_recover_last_ate+0x60>
	*addr -= ate_size;
 1004e14:	1a24      	subs	r4, r4, r0
 1004e16:	603c      	str	r4, [r7, #0]
	data_end_addr = *addr & ADDR_SECT_MASK;
 1004e18:	ea04 0509 	and.w	r5, r4, r9
	while (ate_end_addr > data_end_addr) {
 1004e1c:	42ac      	cmp	r4, r5
 1004e1e:	d803      	bhi.n	1004e28 <nvs_recover_last_ate+0x2c>
			*addr = ate_end_addr;
		}
		ate_end_addr -= ate_size;
	}

	return 0;
 1004e20:	2000      	movs	r0, #0
}
 1004e22:	b003      	add	sp, #12
 1004e24:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
 1004e28:	2308      	movs	r3, #8
 1004e2a:	466a      	mov	r2, sp
 1004e2c:	4621      	mov	r1, r4
 1004e2e:	4630      	mov	r0, r6
 1004e30:	f020 f826 	bl	1024e80 <nvs_flash_rd>
		if (rc) {
 1004e34:	2800      	cmp	r0, #0
 1004e36:	d1f4      	bne.n	1004e22 <nvs_recover_last_ate+0x26>
		if (nvs_ate_valid(fs, &end_ate)) {
 1004e38:	4669      	mov	r1, sp
 1004e3a:	4630      	mov	r0, r6
 1004e3c:	f020 f8ba 	bl	1024fb4 <nvs_ate_valid>
 1004e40:	b140      	cbz	r0, 1004e54 <nvs_recover_last_ate+0x58>
			data_end_addr += end_ate.offset + end_ate.len;
 1004e42:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 1004e46:	f8bd 2004 	ldrh.w	r2, [sp, #4]
			data_end_addr &= ADDR_SECT_MASK;
 1004e4a:	ea05 0509 	and.w	r5, r5, r9
			data_end_addr += end_ate.offset + end_ate.len;
 1004e4e:	4413      	add	r3, r2
 1004e50:	441d      	add	r5, r3
			*addr = ate_end_addr;
 1004e52:	603c      	str	r4, [r7, #0]
		ate_end_addr -= ate_size;
 1004e54:	eba4 0408 	sub.w	r4, r4, r8
 1004e58:	e7e0      	b.n	1004e1c <nvs_recover_last_ate+0x20>
 1004e5a:	bf00      	nop
 1004e5c:	ffff0000 	.word	0xffff0000

01004e60 <nvs_mount>:

	return 0;
}

int nvs_mount(struct nvs_fs *fs)
{
 1004e60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1004e64:	b08f      	sub	sp, #60	; 0x3c
 1004e66:	4604      	mov	r4, r0
 1004e68:	af00      	add	r7, sp, #0

	int rc;
	struct flash_pages_info info;
	size_t write_block_size;

	k_mutex_init(&fs->nvs_lock);
 1004e6a:	f100 0814 	add.w	r8, r0, #20
	return z_impl_k_mutex_init(mutex);
 1004e6e:	4640      	mov	r0, r8
 1004e70:	f024 fa1c 	bl	10292ac <z_impl_k_mutex_init>

	fs->flash_parameters = flash_get_parameters(fs->flash_device);
 1004e74:	6aa0      	ldr	r0, [r4, #40]	; 0x28
static inline const struct flash_parameters *z_impl_flash_get_parameters(const struct device *dev)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->api;

	return api->get_parameters(dev);
 1004e76:	6883      	ldr	r3, [r0, #8]
 1004e78:	68db      	ldr	r3, [r3, #12]
 1004e7a:	4798      	blx	r3
 1004e7c:	62e0      	str	r0, [r4, #44]	; 0x2c
	if (fs->flash_parameters == NULL) {
 1004e7e:	b988      	cbnz	r0, 1004ea4 <nvs_mount+0x44>
		LOG_ERR("Could not obtain flash parameters");
 1004e80:	4b8d      	ldr	r3, [pc, #564]	; (10050b8 <nvs_mount+0x258>)

	write_block_size = flash_get_write_block_size(fs->flash_device);

	/* check that the write block size is supported */
	if (write_block_size > NVS_BLOCK_SIZE || write_block_size == 0) {
		LOG_ERR("Unsupported write block size");
 1004e82:	637b      	str	r3, [r7, #52]	; 0x34
 1004e84:	2302      	movs	r3, #2
		return -EINVAL;
 1004e86:	f06f 0515 	mvn.w	r5, #21
		LOG_ERR("Unsupported write block size");
 1004e8a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1004e8e:	488b      	ldr	r0, [pc, #556]	; (10050bc <nvs_mount+0x25c>)
 1004e90:	633b      	str	r3, [r7, #48]	; 0x30
 1004e92:	f107 0230 	add.w	r2, r7, #48	; 0x30
 1004e96:	f020 f880 	bl	1024f9a <z_log_msg_static_create.constprop.0>
	LOG_INF("data wra: %d, %x",
		(fs->data_wra >> ADDR_SECT_SHIFT),
		(fs->data_wra & ADDR_OFFS_MASK));

	return 0;
}
 1004e9a:	4628      	mov	r0, r5
 1004e9c:	373c      	adds	r7, #60	; 0x3c
 1004e9e:	46bd      	mov	sp, r7
 1004ea0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	write_block_size = flash_get_write_block_size(fs->flash_device);
 1004ea4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	return api->get_parameters(dev)->write_block_size;
 1004ea6:	6883      	ldr	r3, [r0, #8]
 1004ea8:	68db      	ldr	r3, [r3, #12]
 1004eaa:	4798      	blx	r3
	if (write_block_size > NVS_BLOCK_SIZE || write_block_size == 0) {
 1004eac:	6803      	ldr	r3, [r0, #0]
 1004eae:	3b01      	subs	r3, #1
 1004eb0:	2b1f      	cmp	r3, #31
 1004eb2:	d901      	bls.n	1004eb8 <nvs_mount+0x58>
		LOG_ERR("Unsupported write block size");
 1004eb4:	4b82      	ldr	r3, [pc, #520]	; (10050c0 <nvs_mount+0x260>)
 1004eb6:	e7e4      	b.n	1004e82 <nvs_mount+0x22>
	rc = flash_get_page_info_by_offs(fs->flash_device, fs->offset, &info);
 1004eb8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 1004eba:	6821      	ldr	r1, [r4, #0]
		union { uintptr_t x; struct flash_pages_info * val; } parm2 = { .val = info };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_FLASH_GET_PAGE_INFO_BY_OFFS);
	}
#endif
	compiler_barrier();
	return z_impl_flash_get_page_info_by_offs(dev, offset, info);
 1004ebc:	f107 0214 	add.w	r2, r7, #20
 1004ec0:	f024 f881 	bl	1028fc6 <z_impl_flash_get_page_info_by_offs>
	if (rc) {
 1004ec4:	b108      	cbz	r0, 1004eca <nvs_mount+0x6a>
		LOG_ERR("Unable to get page info");
 1004ec6:	4b7f      	ldr	r3, [pc, #508]	; (10050c4 <nvs_mount+0x264>)
 1004ec8:	e7db      	b.n	1004e82 <nvs_mount+0x22>
	if (!fs->sector_size || fs->sector_size % info.size) {
 1004eca:	89a5      	ldrh	r5, [r4, #12]
 1004ecc:	b12d      	cbz	r5, 1004eda <nvs_mount+0x7a>
 1004ece:	69bb      	ldr	r3, [r7, #24]
 1004ed0:	fbb5 f2f3 	udiv	r2, r5, r3
 1004ed4:	fb03 5512 	mls	r5, r3, r2, r5
 1004ed8:	b10d      	cbz	r5, 1004ede <nvs_mount+0x7e>
		LOG_ERR("Invalid sector size");
 1004eda:	4b7b      	ldr	r3, [pc, #492]	; (10050c8 <nvs_mount+0x268>)
 1004edc:	e7d1      	b.n	1004e82 <nvs_mount+0x22>
	if (fs->sector_count < 2) {
 1004ede:	89e3      	ldrh	r3, [r4, #14]
 1004ee0:	2b01      	cmp	r3, #1
 1004ee2:	d801      	bhi.n	1004ee8 <nvs_mount+0x88>
		LOG_ERR("Configuration error - sector count");
 1004ee4:	4b79      	ldr	r3, [pc, #484]	; (10050cc <nvs_mount+0x26c>)
 1004ee6:	e7cc      	b.n	1004e82 <nvs_mount+0x22>
	uint8_t erase_value = fs->flash_parameters->erase_value;
 1004ee8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	uint32_t addr = 0U;
 1004eea:	603d      	str	r5, [r7, #0]
	uint8_t erase_value = fs->flash_parameters->erase_value;
 1004eec:	f893 a004 	ldrb.w	sl, [r3, #4]
	return z_impl_k_mutex_lock(mutex, timeout);
 1004ef0:	f04f 33ff 	mov.w	r3, #4294967295
 1004ef4:	f04f 32ff 	mov.w	r2, #4294967295
 1004ef8:	4640      	mov	r0, r8
 1004efa:	f01c f931 	bl	1021160 <z_impl_k_mutex_lock>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
 1004efe:	2108      	movs	r1, #8
 1004f00:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 1004f02:	f020 f84d 	bl	1024fa0 <nvs_al_size.isra.0>
	uint16_t i, closed_sectors = 0;
 1004f06:	46a9      	mov	r9, r5
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
 1004f08:	4606      	mov	r6, r0
	for (i = 0; i < fs->sector_count; i++) {
 1004f0a:	89e3      	ldrh	r3, [r4, #14]
 1004f0c:	fa1f fb85 	uxth.w	fp, r5
 1004f10:	455b      	cmp	r3, fp
 1004f12:	d808      	bhi.n	1004f26 <nvs_mount+0xc6>
	if (closed_sectors == fs->sector_count) {
 1004f14:	89e3      	ldrh	r3, [r4, #14]
 1004f16:	454b      	cmp	r3, r9
 1004f18:	d123      	bne.n	1004f62 <nvs_mount+0x102>
	return z_impl_k_mutex_unlock(mutex);
 1004f1a:	4640      	mov	r0, r8
 1004f1c:	f01c f9f0 	bl	1021300 <z_impl_k_mutex_unlock>
		rc = -EDEADLK;
 1004f20:	f06f 052c 	mvn.w	r5, #44	; 0x2c
 1004f24:	e7b9      	b.n	1004e9a <nvs_mount+0x3a>
		       (uint16_t)(fs->sector_size - ate_size);
 1004f26:	89a1      	ldrh	r1, [r4, #12]
		rc = nvs_flash_cmp_const(fs, addr, erase_value,
 1004f28:	2308      	movs	r3, #8
		       (uint16_t)(fs->sector_size - ate_size);
 1004f2a:	1b89      	subs	r1, r1, r6
 1004f2c:	b289      	uxth	r1, r1
		addr = (i << ADDR_SECT_SHIFT) +
 1004f2e:	eb01 4105 	add.w	r1, r1, r5, lsl #16
		rc = nvs_flash_cmp_const(fs, addr, erase_value,
 1004f32:	4652      	mov	r2, sl
 1004f34:	4620      	mov	r0, r4
		addr = (i << ADDR_SECT_SHIFT) +
 1004f36:	6039      	str	r1, [r7, #0]
		rc = nvs_flash_cmp_const(fs, addr, erase_value,
 1004f38:	f01f ffe7 	bl	1024f0a <nvs_flash_cmp_const>
		if (rc) {
 1004f3c:	b178      	cbz	r0, 1004f5e <nvs_mount+0xfe>
			nvs_sector_advance(fs, &addr);
 1004f3e:	4639      	mov	r1, r7
 1004f40:	4620      	mov	r0, r4
 1004f42:	f01f ffab 	bl	1024e9c <nvs_sector_advance>
			closed_sectors++;
 1004f46:	f109 0901 	add.w	r9, r9, #1
			rc = nvs_flash_cmp_const(fs, addr, erase_value,
 1004f4a:	2308      	movs	r3, #8
 1004f4c:	4652      	mov	r2, sl
 1004f4e:	4620      	mov	r0, r4
 1004f50:	6839      	ldr	r1, [r7, #0]
			closed_sectors++;
 1004f52:	fa1f f989 	uxth.w	r9, r9
			rc = nvs_flash_cmp_const(fs, addr, erase_value,
 1004f56:	f01f ffd8 	bl	1024f0a <nvs_flash_cmp_const>
			if (!rc) {
 1004f5a:	2800      	cmp	r0, #0
 1004f5c:	d0da      	beq.n	1004f14 <nvs_mount+0xb4>
	for (i = 0; i < fs->sector_count; i++) {
 1004f5e:	3501      	adds	r5, #1
 1004f60:	e7d3      	b.n	1004f0a <nvs_mount+0xaa>
	if (i == fs->sector_count) {
 1004f62:	455b      	cmp	r3, fp
 1004f64:	d10b      	bne.n	1004f7e <nvs_mount+0x11e>
		rc = nvs_flash_cmp_const(fs, addr - ate_size, erase_value,
 1004f66:	6839      	ldr	r1, [r7, #0]
 1004f68:	2308      	movs	r3, #8
 1004f6a:	4652      	mov	r2, sl
 1004f6c:	4620      	mov	r0, r4
 1004f6e:	1b89      	subs	r1, r1, r6
 1004f70:	f01f ffcb 	bl	1024f0a <nvs_flash_cmp_const>
		if (!rc) {
 1004f74:	b918      	cbnz	r0, 1004f7e <nvs_mount+0x11e>
			nvs_sector_advance(fs, &addr);
 1004f76:	4639      	mov	r1, r7
 1004f78:	4620      	mov	r0, r4
 1004f7a:	f01f ff8f 	bl	1024e9c <nvs_sector_advance>
	rc = nvs_recover_last_ate(fs, &addr);
 1004f7e:	4639      	mov	r1, r7
 1004f80:	4620      	mov	r0, r4
 1004f82:	f7ff ff3b 	bl	1004dfc <nvs_recover_last_ate>
	if (rc) {
 1004f86:	4605      	mov	r5, r0
 1004f88:	b118      	cbz	r0, 1004f92 <nvs_mount+0x132>
 1004f8a:	4640      	mov	r0, r8
 1004f8c:	f01c f9b8 	bl	1021300 <z_impl_k_mutex_unlock>
	if (rc) {
 1004f90:	e783      	b.n	1004e9a <nvs_mount+0x3a>
	fs->ate_wra = addr;
 1004f92:	683b      	ldr	r3, [r7, #0]
	fs->data_wra = addr & ADDR_SECT_MASK;
 1004f94:	ea4f 4913 	mov.w	r9, r3, lsr #16
 1004f98:	ea4f 4909 	mov.w	r9, r9, lsl #16
	fs->ate_wra = addr;
 1004f9c:	6063      	str	r3, [r4, #4]
	fs->data_wra = addr & ADDR_SECT_MASK;
 1004f9e:	f8c4 9008 	str.w	r9, [r4, #8]
	while (fs->ate_wra >= fs->data_wra) {
 1004fa2:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
 1004fa6:	4299      	cmp	r1, r3
 1004fa8:	d30f      	bcc.n	1004fca <nvs_mount+0x16a>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
 1004faa:	2308      	movs	r3, #8
 1004fac:	4620      	mov	r0, r4
 1004fae:	1d3a      	adds	r2, r7, #4
 1004fb0:	f01f ff66 	bl	1024e80 <nvs_flash_rd>
		if (rc) {
 1004fb4:	4605      	mov	r5, r0
 1004fb6:	2800      	cmp	r0, #0
 1004fb8:	d1e7      	bne.n	1004f8a <nvs_mount+0x12a>
 1004fba:	1d3b      	adds	r3, r7, #4
		if (data8[i] != value) {
 1004fbc:	f813 2b01 	ldrb.w	r2, [r3], #1
 1004fc0:	4592      	cmp	sl, r2
 1004fc2:	d144      	bne.n	100504e <nvs_mount+0x1ee>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
 1004fc4:	3501      	adds	r5, #1
 1004fc6:	2d08      	cmp	r5, #8
 1004fc8:	d1f8      	bne.n	1004fbc <nvs_mount+0x15c>
	addr = fs->ate_wra & ADDR_SECT_MASK;
 1004fca:	6863      	ldr	r3, [r4, #4]
	nvs_sector_advance(fs, &addr);
 1004fcc:	4639      	mov	r1, r7
	addr = fs->ate_wra & ADDR_SECT_MASK;
 1004fce:	0c1b      	lsrs	r3, r3, #16
 1004fd0:	041b      	lsls	r3, r3, #16
	nvs_sector_advance(fs, &addr);
 1004fd2:	4620      	mov	r0, r4
	addr = fs->ate_wra & ADDR_SECT_MASK;
 1004fd4:	603b      	str	r3, [r7, #0]
	nvs_sector_advance(fs, &addr);
 1004fd6:	f01f ff61 	bl	1024e9c <nvs_sector_advance>
	rc = nvs_flash_cmp_const(fs, addr, erase_value, fs->sector_size);
 1004fda:	4652      	mov	r2, sl
 1004fdc:	4620      	mov	r0, r4
 1004fde:	89a3      	ldrh	r3, [r4, #12]
 1004fe0:	6839      	ldr	r1, [r7, #0]
 1004fe2:	f01f ff92 	bl	1024f0a <nvs_flash_cmp_const>
	if (rc < 0) {
 1004fe6:	1e05      	subs	r5, r0, #0
 1004fe8:	dbcf      	blt.n	1004f8a <nvs_mount+0x12a>
		addr = fs->ate_wra + ate_size;
 1004fea:	6863      	ldr	r3, [r4, #4]
	if (rc) {
 1004fec:	f000 8082 	beq.w	10050f4 <nvs_mount+0x294>
		while ((addr & ADDR_OFFS_MASK) < (fs->sector_size - ate_size)) {
 1004ff0:	f64f 7aff 	movw	sl, #65535	; 0xffff
		addr = fs->ate_wra + ate_size;
 1004ff4:	eb06 0903 	add.w	r9, r6, r3
		while ((addr & ADDR_OFFS_MASK) < (fs->sector_size - ate_size)) {
 1004ff8:	89a3      	ldrh	r3, [r4, #12]
 1004ffa:	fa1f f289 	uxth.w	r2, r9
 1004ffe:	1b9b      	subs	r3, r3, r6
 1005000:	429a      	cmp	r2, r3
		addr = fs->ate_wra + ate_size;
 1005002:	f8c7 9000 	str.w	r9, [r7]
		while ((addr & ADDR_OFFS_MASK) < (fs->sector_size - ate_size)) {
 1005006:	d33c      	bcc.n	1005082 <nvs_mount+0x222>
		LOG_INF("No GC Done marker found: restarting gc");
 1005008:	4b31      	ldr	r3, [pc, #196]	; (10050d0 <nvs_mount+0x270>)
 100500a:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
 100500e:	637b      	str	r3, [r7, #52]	; 0x34
 1005010:	2302      	movs	r3, #2
 1005012:	482a      	ldr	r0, [pc, #168]	; (10050bc <nvs_mount+0x25c>)
 1005014:	633b      	str	r3, [r7, #48]	; 0x30
 1005016:	f107 0230 	add.w	r2, r7, #48	; 0x30
 100501a:	f01f ffbe 	bl	1024f9a <z_log_msg_static_create.constprop.0>
		rc = nvs_flash_erase_sector(fs, fs->ate_wra);
 100501e:	4620      	mov	r0, r4
 1005020:	6861      	ldr	r1, [r4, #4]
 1005022:	f01f ff97 	bl	1024f54 <nvs_flash_erase_sector>
		if (rc) {
 1005026:	4605      	mov	r5, r0
 1005028:	2800      	cmp	r0, #0
 100502a:	d1ae      	bne.n	1004f8a <nvs_mount+0x12a>
		fs->ate_wra &= ADDR_SECT_MASK;
 100502c:	6863      	ldr	r3, [r4, #4]
 100502e:	4a29      	ldr	r2, [pc, #164]	; (10050d4 <nvs_mount+0x274>)
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
 1005030:	89a1      	ldrh	r1, [r4, #12]
		fs->ate_wra &= ADDR_SECT_MASK;
 1005032:	4013      	ands	r3, r2
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
 1005034:	440b      	add	r3, r1
 1005036:	eba3 0346 	sub.w	r3, r3, r6, lsl #1
 100503a:	6063      	str	r3, [r4, #4]
		fs->data_wra = (fs->ate_wra & ADDR_SECT_MASK);
 100503c:	4013      	ands	r3, r2
		rc = nvs_gc(fs);
 100503e:	4620      	mov	r0, r4
		fs->data_wra = (fs->ate_wra & ADDR_SECT_MASK);
 1005040:	60a3      	str	r3, [r4, #8]
		rc = nvs_gc(fs);
 1005042:	f020 f899 	bl	1025178 <nvs_gc>
			rc = nvs_flash_erase_sector(fs, addr);
 1005046:	4605      	mov	r5, r0
	if ((!rc) && ((fs->ate_wra & ADDR_OFFS_MASK) ==
 1005048:	2d00      	cmp	r5, #0
 100504a:	d06f      	beq.n	100512c <nvs_mount+0x2cc>
 100504c:	e79d      	b.n	1004f8a <nvs_mount+0x12a>
		if (nvs_ate_valid(fs, &last_ate)) {
 100504e:	4620      	mov	r0, r4
 1005050:	1d39      	adds	r1, r7, #4
 1005052:	f01f ffaf 	bl	1024fb4 <nvs_ate_valid>
 1005056:	6862      	ldr	r2, [r4, #4]
 1005058:	b910      	cbnz	r0, 1005060 <nvs_mount+0x200>
		fs->ate_wra -= ate_size;
 100505a:	1b92      	subs	r2, r2, r6
 100505c:	6062      	str	r2, [r4, #4]
 100505e:	e7a0      	b.n	1004fa2 <nvs_mount+0x142>
			fs->data_wra += nvs_al_size(fs, last_ate.offset + last_ate.len);
 1005060:	893d      	ldrh	r5, [r7, #8]
 1005062:	88f9      	ldrh	r1, [r7, #6]
 1005064:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
			fs->data_wra = addr & ADDR_SECT_MASK;
 1005066:	f8c4 9008 	str.w	r9, [r4, #8]
			fs->data_wra += nvs_al_size(fs, last_ate.offset + last_ate.len);
 100506a:	4429      	add	r1, r5
 100506c:	f01f ff98 	bl	1024fa0 <nvs_al_size.isra.0>
 1005070:	4448      	add	r0, r9
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
 1005072:	4290      	cmp	r0, r2
			fs->data_wra += nvs_al_size(fs, last_ate.offset + last_ate.len);
 1005074:	60a0      	str	r0, [r4, #8]
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
 1005076:	d1f0      	bne.n	100505a <nvs_mount+0x1fa>
 1005078:	2d00      	cmp	r5, #0
 100507a:	d0ee      	beq.n	100505a <nvs_mount+0x1fa>
				rc = -ESPIPE;
 100507c:	f06f 051c 	mvn.w	r5, #28
 1005080:	e09c      	b.n	10051bc <nvs_mount+0x35c>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
 1005082:	2308      	movs	r3, #8
 1005084:	4649      	mov	r1, r9
 1005086:	4620      	mov	r0, r4
 1005088:	f107 020c 	add.w	r2, r7, #12
 100508c:	f01f fef8 	bl	1024e80 <nvs_flash_rd>
			if (rc) {
 1005090:	4605      	mov	r5, r0
 1005092:	2800      	cmp	r0, #0
 1005094:	f47f af79 	bne.w	1004f8a <nvs_mount+0x12a>
			if (nvs_ate_valid(fs, &gc_done_ate) &&
 1005098:	4620      	mov	r0, r4
 100509a:	f107 010c 	add.w	r1, r7, #12
 100509e:	f01f ff89 	bl	1024fb4 <nvs_ate_valid>
 10050a2:	b130      	cbz	r0, 10050b2 <nvs_mount+0x252>
 10050a4:	89bb      	ldrh	r3, [r7, #12]
 10050a6:	4553      	cmp	r3, sl
 10050a8:	d103      	bne.n	10050b2 <nvs_mount+0x252>
			    (gc_done_ate.id == 0xffff) &&
 10050aa:	8a3b      	ldrh	r3, [r7, #16]
 10050ac:	2b00      	cmp	r3, #0
 10050ae:	f000 808b 	beq.w	10051c8 <nvs_mount+0x368>
			addr += ate_size;
 10050b2:	44b1      	add	r9, r6
 10050b4:	e7a0      	b.n	1004ff8 <nvs_mount+0x198>
 10050b6:	bf00      	nop
 10050b8:	0102c139 	.word	0x0102c139
 10050bc:	01029a0c 	.word	0x01029a0c
 10050c0:	0102c15b 	.word	0x0102c15b
 10050c4:	0102c178 	.word	0x0102c178
 10050c8:	0102c190 	.word	0x0102c190
 10050cc:	0102c1a4 	.word	0x0102c1a4
 10050d0:	0102c201 	.word	0x0102c201
 10050d4:	ffff0000 	.word	0xffff0000
		rc = nvs_flash_cmp_const(fs, fs->data_wra, erase_value,
 10050d8:	4652      	mov	r2, sl
 10050da:	4620      	mov	r0, r4
 10050dc:	1a5b      	subs	r3, r3, r1
 10050de:	f01f ff14 	bl	1024f0a <nvs_flash_cmp_const>
		if (rc < 0) {
 10050e2:	1e05      	subs	r5, r0, #0
 10050e4:	f6ff af51 	blt.w	1004f8a <nvs_mount+0x12a>
		if (!rc) {
 10050e8:	d008      	beq.n	10050fc <nvs_mount+0x29c>
		fs->data_wra += fs->flash_parameters->write_block_size;
 10050ea:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 10050ec:	68a3      	ldr	r3, [r4, #8]
 10050ee:	6812      	ldr	r2, [r2, #0]
 10050f0:	4413      	add	r3, r2
 10050f2:	60a3      	str	r3, [r4, #8]
	while (fs->ate_wra > fs->data_wra) {
 10050f4:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
 10050f8:	428b      	cmp	r3, r1
 10050fa:	d8ed      	bhi.n	10050d8 <nvs_mount+0x278>
	if (((fs->ate_wra + 2 * ate_size) == fs->sector_size) &&
 10050fc:	6861      	ldr	r1, [r4, #4]
 10050fe:	89a3      	ldrh	r3, [r4, #12]
 1005100:	eb01 0246 	add.w	r2, r1, r6, lsl #1
 1005104:	429a      	cmp	r2, r3
 1005106:	d19f      	bne.n	1005048 <nvs_mount+0x1e8>
	    (fs->data_wra != (fs->ate_wra & ADDR_SECT_MASK))) {
 1005108:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 10051f8 <nvs_mount+0x398>
	if (((fs->ate_wra + 2 * ate_size) == fs->sector_size) &&
 100510c:	68a3      	ldr	r3, [r4, #8]
	    (fs->data_wra != (fs->ate_wra & ADDR_SECT_MASK))) {
 100510e:	ea01 0209 	and.w	r2, r1, r9
	if (((fs->ate_wra + 2 * ate_size) == fs->sector_size) &&
 1005112:	4293      	cmp	r3, r2
 1005114:	d098      	beq.n	1005048 <nvs_mount+0x1e8>
		rc = nvs_flash_erase_sector(fs, fs->ate_wra);
 1005116:	4620      	mov	r0, r4
 1005118:	f01f ff1c 	bl	1024f54 <nvs_flash_erase_sector>
		if (rc) {
 100511c:	4605      	mov	r5, r0
 100511e:	2800      	cmp	r0, #0
 1005120:	f47f af33 	bne.w	1004f8a <nvs_mount+0x12a>
		fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
 1005124:	6863      	ldr	r3, [r4, #4]
 1005126:	ea03 0309 	and.w	r3, r3, r9
 100512a:	60a3      	str	r3, [r4, #8]
		      (fs->sector_size - 2 * ate_size))) {
 100512c:	89a3      	ldrh	r3, [r4, #12]
	if ((!rc) && ((fs->ate_wra & ADDR_OFFS_MASK) ==
 100512e:	88a2      	ldrh	r2, [r4, #4]
		      (fs->sector_size - 2 * ate_size))) {
 1005130:	eba3 0346 	sub.w	r3, r3, r6, lsl #1
	if ((!rc) && ((fs->ate_wra & ADDR_OFFS_MASK) ==
 1005134:	429a      	cmp	r2, r3
 1005136:	d03d      	beq.n	10051b4 <nvs_mount+0x354>
 1005138:	4640      	mov	r0, r8
 100513a:	f01c f8e1 	bl	1021300 <z_impl_k_mutex_unlock>
	fs->ready = true;
 100513e:	2301      	movs	r3, #1
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
 1005140:	46e8      	mov	r8, sp
 1005142:	b088      	sub	sp, #32
	fs->ready = true;
 1005144:	7423      	strb	r3, [r4, #16]
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
 1005146:	466d      	mov	r5, sp
 1005148:	89e2      	ldrh	r2, [r4, #14]
 100514a:	89a3      	ldrh	r3, [r4, #12]
 100514c:	f04f 0904 	mov.w	r9, #4
 1005150:	462e      	mov	r6, r5
 1005152:	492a      	ldr	r1, [pc, #168]	; (10051fc <nvs_mount+0x39c>)
 1005154:	61eb      	str	r3, [r5, #28]
 1005156:	e9c5 1205 	strd	r1, r2, [r5, #20]
 100515a:	f846 9f10 	str.w	r9, [r6, #16]!
 100515e:	4632      	mov	r2, r6
 1005160:	f44f 5103 	mov.w	r1, #8384	; 0x20c0
 1005164:	4826      	ldr	r0, [pc, #152]	; (1005200 <nvs_mount+0x3a0>)
 1005166:	f01f ff18 	bl	1024f9a <z_log_msg_static_create.constprop.0>
 100516a:	46c5      	mov	sp, r8
	LOG_INF("alloc wra: %d, %x",
 100516c:	6863      	ldr	r3, [r4, #4]
 100516e:	46ad      	mov	sp, r5
 1005170:	4a24      	ldr	r2, [pc, #144]	; (1005204 <nvs_mount+0x3a4>)
 1005172:	f44f 5103 	mov.w	r1, #8384	; 0x20c0
 1005176:	616a      	str	r2, [r5, #20]
 1005178:	0c1a      	lsrs	r2, r3, #16
 100517a:	b29b      	uxth	r3, r3
 100517c:	61aa      	str	r2, [r5, #24]
 100517e:	61eb      	str	r3, [r5, #28]
 1005180:	4632      	mov	r2, r6
 1005182:	481f      	ldr	r0, [pc, #124]	; (1005200 <nvs_mount+0x3a0>)
 1005184:	f8c5 9010 	str.w	r9, [r5, #16]
 1005188:	f01f ff07 	bl	1024f9a <z_log_msg_static_create.constprop.0>
 100518c:	46c5      	mov	sp, r8
	LOG_INF("data wra: %d, %x",
 100518e:	68a3      	ldr	r3, [r4, #8]
 1005190:	46ad      	mov	sp, r5
 1005192:	4a1d      	ldr	r2, [pc, #116]	; (1005208 <nvs_mount+0x3a8>)
 1005194:	f8c5 9010 	str.w	r9, [r5, #16]
 1005198:	616a      	str	r2, [r5, #20]
 100519a:	0c1a      	lsrs	r2, r3, #16
 100519c:	b29b      	uxth	r3, r3
 100519e:	61aa      	str	r2, [r5, #24]
 10051a0:	61eb      	str	r3, [r5, #28]
 10051a2:	4632      	mov	r2, r6
 10051a4:	f44f 5103 	mov.w	r1, #8384	; 0x20c0
 10051a8:	4815      	ldr	r0, [pc, #84]	; (1005200 <nvs_mount+0x3a0>)
 10051aa:	f01f fef6 	bl	1024f9a <z_log_msg_static_create.constprop.0>
	return 0;
 10051ae:	2500      	movs	r5, #0
 10051b0:	46c5      	mov	sp, r8
 10051b2:	e672      	b.n	1004e9a <nvs_mount+0x3a>
		rc = nvs_add_gc_done_ate(fs);
 10051b4:	4620      	mov	r0, r4
 10051b6:	f01f ffca 	bl	102514e <nvs_add_gc_done_ate>
 10051ba:	4605      	mov	r5, r0
 10051bc:	4640      	mov	r0, r8
 10051be:	f01c f89f 	bl	1021300 <z_impl_k_mutex_unlock>
	if (rc) {
 10051c2:	2d00      	cmp	r5, #0
 10051c4:	d0bb      	beq.n	100513e <nvs_mount+0x2de>
 10051c6:	e668      	b.n	1004e9a <nvs_mount+0x3a>
			LOG_INF("GC Done marker found");
 10051c8:	4b10      	ldr	r3, [pc, #64]	; (100520c <nvs_mount+0x3ac>)
 10051ca:	f107 0230 	add.w	r2, r7, #48	; 0x30
 10051ce:	637b      	str	r3, [r7, #52]	; 0x34
 10051d0:	2302      	movs	r3, #2
 10051d2:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
 10051d6:	633b      	str	r3, [r7, #48]	; 0x30
 10051d8:	4809      	ldr	r0, [pc, #36]	; (1005200 <nvs_mount+0x3a0>)
 10051da:	f01f fede 	bl	1024f9a <z_log_msg_static_create.constprop.0>
			addr = fs->ate_wra & ADDR_SECT_MASK;
 10051de:	6863      	ldr	r3, [r4, #4]
			nvs_sector_advance(fs, &addr);
 10051e0:	4639      	mov	r1, r7
			addr = fs->ate_wra & ADDR_SECT_MASK;
 10051e2:	0c1b      	lsrs	r3, r3, #16
			nvs_sector_advance(fs, &addr);
 10051e4:	4620      	mov	r0, r4
			addr = fs->ate_wra & ADDR_SECT_MASK;
 10051e6:	041b      	lsls	r3, r3, #16
 10051e8:	603b      	str	r3, [r7, #0]
			nvs_sector_advance(fs, &addr);
 10051ea:	f01f fe57 	bl	1024e9c <nvs_sector_advance>
			rc = nvs_flash_erase_sector(fs, addr);
 10051ee:	4620      	mov	r0, r4
 10051f0:	6839      	ldr	r1, [r7, #0]
 10051f2:	f01f feaf 	bl	1024f54 <nvs_flash_erase_sector>
 10051f6:	e726      	b.n	1005046 <nvs_mount+0x1e6>
 10051f8:	ffff0000 	.word	0xffff0000
 10051fc:	0102c1c7 	.word	0x0102c1c7
 1005200:	01029a0c 	.word	0x01029a0c
 1005204:	0102c1de 	.word	0x0102c1de
 1005208:	0102c1f0 	.word	0x0102c1f0
 100520c:	0102c228 	.word	0x0102c228

01005210 <nvs_write>:

ssize_t nvs_write(struct nvs_fs *fs, uint16_t id, const void *data, size_t len)
{
 1005210:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1005214:	461d      	mov	r5, r3
	struct nvs_ate wlk_ate;
	uint32_t wlk_addr, rd_addr;
	uint16_t required_space = 0U; /* no space, appropriate for delete ate */
	bool prev_found = false;

	if (!fs->ready) {
 1005216:	7c03      	ldrb	r3, [r0, #16]
{
 1005218:	4604      	mov	r4, r0
 100521a:	4689      	mov	r9, r1
 100521c:	4690      	mov	r8, r2
 100521e:	b08d      	sub	sp, #52	; 0x34
	if (!fs->ready) {
 1005220:	b97b      	cbnz	r3, 1005242 <nvs_write+0x32>
		LOG_ERR("NVS not initialized");
 1005222:	4b66      	ldr	r3, [pc, #408]	; (10053bc <nvs_write+0x1ac>)
		return -EACCES;
 1005224:	f06f 060c 	mvn.w	r6, #12
		LOG_ERR("NVS not initialized");
 1005228:	930b      	str	r3, [sp, #44]	; 0x2c
 100522a:	2302      	movs	r3, #2
 100522c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1005230:	4863      	ldr	r0, [pc, #396]	; (10053c0 <nvs_write+0x1b0>)
 1005232:	aa0a      	add	r2, sp, #40	; 0x28
 1005234:	930a      	str	r3, [sp, #40]	; 0x28
 1005236:	f01f feb0 	bl	1024f9a <z_log_msg_static_create.constprop.0>
	}
	rc = len;
end:
	k_mutex_unlock(&fs->nvs_lock);
	return rc;
}
 100523a:	4630      	mov	r0, r6
 100523c:	b00d      	add	sp, #52	; 0x34
 100523e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
 1005242:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 1005244:	2108      	movs	r1, #8
 1005246:	4610      	mov	r0, r2
 1005248:	f01f feaa 	bl	1024fa0 <nvs_al_size.isra.0>
 100524c:	4682      	mov	sl, r0
	data_size = nvs_al_size(fs, len);
 100524e:	4629      	mov	r1, r5
 1005250:	4610      	mov	r0, r2
 1005252:	f01f fea5 	bl	1024fa0 <nvs_al_size.isra.0>
	if ((len > (fs->sector_size - 4 * ate_size)) ||
 1005256:	89a3      	ldrh	r3, [r4, #12]
	data_size = nvs_al_size(fs, len);
 1005258:	4607      	mov	r7, r0
	if ((len > (fs->sector_size - 4 * ate_size)) ||
 100525a:	eba3 038a 	sub.w	r3, r3, sl, lsl #2
 100525e:	42ab      	cmp	r3, r5
 1005260:	f0c0 80a9 	bcc.w	10053b6 <nvs_write+0x1a6>
 1005264:	b11d      	cbz	r5, 100526e <nvs_write+0x5e>
	    ((len > 0) && (data == NULL))) {
 1005266:	f1b8 0f00 	cmp.w	r8, #0
 100526a:	f000 80a4 	beq.w	10053b6 <nvs_write+0x1a6>
	wlk_addr = fs->ate_wra;
 100526e:	6863      	ldr	r3, [r4, #4]
 1005270:	9303      	str	r3, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
 1005272:	4620      	mov	r0, r4
 1005274:	aa04      	add	r2, sp, #16
 1005276:	a903      	add	r1, sp, #12
		rd_addr = wlk_addr;
 1005278:	f8dd b00c 	ldr.w	fp, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
 100527c:	f01f fed2 	bl	1025024 <nvs_prev_ate>
		if (rc) {
 1005280:	4606      	mov	r6, r0
 1005282:	2800      	cmp	r0, #0
 1005284:	d1d9      	bne.n	100523a <nvs_write+0x2a>
		if ((wlk_ate.id == id) && (nvs_ate_valid(fs, &wlk_ate))) {
 1005286:	f8bd 3010 	ldrh.w	r3, [sp, #16]
 100528a:	454b      	cmp	r3, r9
 100528c:	d005      	beq.n	100529a <nvs_write+0x8a>
		if (wlk_addr == fs->ate_wra) {
 100528e:	6862      	ldr	r2, [r4, #4]
 1005290:	9b03      	ldr	r3, [sp, #12]
 1005292:	429a      	cmp	r2, r3
 1005294:	d1ed      	bne.n	1005272 <nvs_write+0x62>
		if (len == 0) {
 1005296:	b9e5      	cbnz	r5, 10052d2 <nvs_write+0xc2>
 1005298:	e7cf      	b.n	100523a <nvs_write+0x2a>
		if ((wlk_ate.id == id) && (nvs_ate_valid(fs, &wlk_ate))) {
 100529a:	4620      	mov	r0, r4
 100529c:	a904      	add	r1, sp, #16
 100529e:	f01f fe89 	bl	1024fb4 <nvs_ate_valid>
 10052a2:	2800      	cmp	r0, #0
 10052a4:	d0f3      	beq.n	100528e <nvs_write+0x7e>
		rd_addr += wlk_ate.offset;
 10052a6:	f8bd 0012 	ldrh.w	r0, [sp, #18]
			if (wlk_ate.len == 0U) {
 10052aa:	f8bd 3014 	ldrh.w	r3, [sp, #20]
		if (len == 0) {
 10052ae:	b175      	cbz	r5, 10052ce <nvs_write+0xbe>
		} else if (len == wlk_ate.len) {
 10052b0:	42ab      	cmp	r3, r5
 10052b2:	d10e      	bne.n	10052d2 <nvs_write+0xc2>
		rd_addr &= ADDR_SECT_MASK;
 10052b4:	ea4f 411b 	mov.w	r1, fp, lsr #16
 10052b8:	0409      	lsls	r1, r1, #16
			rc = nvs_flash_block_cmp(fs, rd_addr, data, len);
 10052ba:	4401      	add	r1, r0
 10052bc:	462b      	mov	r3, r5
 10052be:	4642      	mov	r2, r8
 10052c0:	4620      	mov	r0, r4
 10052c2:	f01f fdf8 	bl	1024eb6 <nvs_flash_block_cmp>
			if (rc <= 0) {
 10052c6:	2800      	cmp	r0, #0
 10052c8:	dc03      	bgt.n	10052d2 <nvs_write+0xc2>
 10052ca:	4606      	mov	r6, r0
 10052cc:	e7b5      	b.n	100523a <nvs_write+0x2a>
			if (wlk_ate.len == 0U) {
 10052ce:	2b00      	cmp	r3, #0
 10052d0:	d0b3      	beq.n	100523a <nvs_write+0x2a>
	if (data_size) {
 10052d2:	2f00      	cmp	r7, #0
 10052d4:	d13e      	bne.n	1005354 <nvs_write+0x144>
	k_mutex_lock(&fs->nvs_lock, K_FOREVER);
 10052d6:	f104 0314 	add.w	r3, r4, #20
 10052da:	9301      	str	r3, [sp, #4]
	return z_impl_k_mutex_lock(mutex, timeout);
 10052dc:	f04f 32ff 	mov.w	r2, #4294967295
 10052e0:	f04f 33ff 	mov.w	r3, #4294967295
 10052e4:	f104 0014 	add.w	r0, r4, #20
 10052e8:	f01b ff3a 	bl	1021160 <z_impl_k_mutex_lock>
	fs->ate_wra &= ADDR_SECT_MASK;
 10052ec:	f8df b0d4 	ldr.w	fp, [pc, #212]	; 10053c4 <nvs_write+0x1b4>
		if (gc_count == fs->sector_count) {
 10052f0:	89e3      	ldrh	r3, [r4, #14]
 10052f2:	429e      	cmp	r6, r3
 10052f4:	d05c      	beq.n	10053b0 <nvs_write+0x1a0>
		if (fs->ate_wra >= (fs->data_wra + required_space)) {
 10052f6:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
 10052fa:	18f9      	adds	r1, r7, r3
 10052fc:	428a      	cmp	r2, r1
 10052fe:	d32c      	bcc.n	100535a <nvs_write+0x14a>
	entry.offset = (uint16_t)(fs->data_wra & ADDR_OFFS_MASK);
 1005300:	f8ad 301a 	strh.w	r3, [sp, #26]
	entry.part = 0xff;
 1005304:	23ff      	movs	r3, #255	; 0xff
	nvs_ate_crc8_update(&entry);
 1005306:	a806      	add	r0, sp, #24
	entry.part = 0xff;
 1005308:	f88d 301e 	strb.w	r3, [sp, #30]
	entry.id = id;
 100530c:	f8ad 9018 	strh.w	r9, [sp, #24]
	entry.len = (uint16_t)len;
 1005310:	f8ad 501c 	strh.w	r5, [sp, #28]
	nvs_ate_crc8_update(&entry);
 1005314:	f01f fe38 	bl	1024f88 <nvs_ate_crc8_update>
	rc = nvs_flash_al_wrt(fs, fs->data_wra, data, len);
 1005318:	462b      	mov	r3, r5
 100531a:	4642      	mov	r2, r8
 100531c:	68a1      	ldr	r1, [r4, #8]
 100531e:	4620      	mov	r0, r4
 1005320:	f01f feca 	bl	10250b8 <nvs_flash_al_wrt>
	fs->data_wra += nvs_al_size(fs, len);
 1005324:	4629      	mov	r1, r5
	rc = nvs_flash_al_wrt(fs, fs->data_wra, data, len);
 1005326:	4682      	mov	sl, r0
	fs->data_wra += nvs_al_size(fs, len);
 1005328:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 100532a:	f01f fe39 	bl	1024fa0 <nvs_al_size.isra.0>
 100532e:	68a2      	ldr	r2, [r4, #8]
 1005330:	4402      	add	r2, r0
 1005332:	60a2      	str	r2, [r4, #8]
	if (rc) {
 1005334:	f1ba 0f00 	cmp.w	sl, #0
 1005338:	d107      	bne.n	100534a <nvs_write+0x13a>
	rc = nvs_flash_ate_wrt(fs, &entry);
 100533a:	4620      	mov	r0, r4
 100533c:	a906      	add	r1, sp, #24
 100533e:	f01f fef5 	bl	102512c <nvs_flash_ate_wrt>
	rc = len;
 1005342:	2800      	cmp	r0, #0
 1005344:	bf14      	ite	ne
 1005346:	4682      	movne	sl, r0
 1005348:	46aa      	moveq	sl, r5
	return z_impl_k_mutex_unlock(mutex);
 100534a:	9801      	ldr	r0, [sp, #4]
 100534c:	f01b ffd8 	bl	1021300 <z_impl_k_mutex_unlock>
	return rc;
 1005350:	4656      	mov	r6, sl
 1005352:	e772      	b.n	100523a <nvs_write+0x2a>
		required_space = data_size + ate_size;
 1005354:	4457      	add	r7, sl
 1005356:	b2bf      	uxth	r7, r7
 1005358:	e7bd      	b.n	10052d6 <nvs_write+0xc6>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
 100535a:	2108      	movs	r1, #8
 100535c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 100535e:	f01f fe1f 	bl	1024fa0 <nvs_al_size.isra.0>
	close_ate.id = 0xFFFF;
 1005362:	f64f 73ff 	movw	r3, #65535	; 0xffff
 1005366:	f8ad 3018 	strh.w	r3, [sp, #24]
	close_ate.len = 0U;
 100536a:	2300      	movs	r3, #0
 100536c:	f8ad 301c 	strh.w	r3, [sp, #28]
	close_ate.offset = (uint16_t)((fs->ate_wra + ate_size) & ADDR_OFFS_MASK);
 1005370:	1813      	adds	r3, r2, r0
 1005372:	f8ad 301a 	strh.w	r3, [sp, #26]
	fs->ate_wra += (fs->sector_size - ate_size);
 1005376:	89a3      	ldrh	r3, [r4, #12]
	fs->ate_wra &= ADDR_SECT_MASK;
 1005378:	ea02 020b 	and.w	r2, r2, fp
	fs->ate_wra += (fs->sector_size - ate_size);
 100537c:	441a      	add	r2, r3
 100537e:	1a10      	subs	r0, r2, r0
 1005380:	6060      	str	r0, [r4, #4]
	nvs_ate_crc8_update(&close_ate);
 1005382:	a806      	add	r0, sp, #24
 1005384:	f01f fe00 	bl	1024f88 <nvs_ate_crc8_update>
	rc = nvs_flash_ate_wrt(fs, &close_ate);
 1005388:	a906      	add	r1, sp, #24
 100538a:	4620      	mov	r0, r4
 100538c:	f01f fece 	bl	102512c <nvs_flash_ate_wrt>
	nvs_sector_advance(fs, &fs->ate_wra);
 1005390:	4620      	mov	r0, r4
 1005392:	1d21      	adds	r1, r4, #4
 1005394:	f01f fd82 	bl	1024e9c <nvs_sector_advance>
	fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
 1005398:	6863      	ldr	r3, [r4, #4]
		rc = nvs_gc(fs);
 100539a:	4620      	mov	r0, r4
	fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
 100539c:	ea03 030b 	and.w	r3, r3, fp
 10053a0:	60a3      	str	r3, [r4, #8]
		rc = nvs_gc(fs);
 10053a2:	f01f fee9 	bl	1025178 <nvs_gc>
		if (rc) {
 10053a6:	4682      	mov	sl, r0
 10053a8:	2800      	cmp	r0, #0
 10053aa:	d1ce      	bne.n	100534a <nvs_write+0x13a>
		gc_count++;
 10053ac:	3601      	adds	r6, #1
		if (gc_count == fs->sector_count) {
 10053ae:	e79f      	b.n	10052f0 <nvs_write+0xe0>
			rc = -ENOSPC;
 10053b0:	f06f 0a1b 	mvn.w	sl, #27
 10053b4:	e7c9      	b.n	100534a <nvs_write+0x13a>
		return -EINVAL;
 10053b6:	f06f 0615 	mvn.w	r6, #21
 10053ba:	e73e      	b.n	100523a <nvs_write+0x2a>
 10053bc:	0102c125 	.word	0x0102c125
 10053c0:	01029a0c 	.word	0x01029a0c
 10053c4:	ffff0000 	.word	0xffff0000

010053c8 <nvs_read_hist>:
	return nvs_write(fs, id, NULL, 0);
}

ssize_t nvs_read_hist(struct nvs_fs *fs, uint16_t id, void *data, size_t len,
		      uint16_t cnt)
{
 10053c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 10053cc:	461e      	mov	r6, r3
	uint32_t wlk_addr, rd_addr;
	uint16_t cnt_his;
	struct nvs_ate wlk_ate;
	size_t ate_size;

	if (!fs->ready) {
 10053ce:	7c03      	ldrb	r3, [r0, #16]
{
 10053d0:	b088      	sub	sp, #32
 10053d2:	4604      	mov	r4, r0
 10053d4:	460f      	mov	r7, r1
 10053d6:	4690      	mov	r8, r2
 10053d8:	f8bd 9040 	ldrh.w	r9, [sp, #64]	; 0x40
	if (!fs->ready) {
 10053dc:	b973      	cbnz	r3, 10053fc <nvs_read_hist+0x34>
		LOG_ERR("NVS not initialized");
 10053de:	4b2f      	ldr	r3, [pc, #188]	; (100549c <nvs_read_hist+0xd4>)
 10053e0:	482f      	ldr	r0, [pc, #188]	; (10054a0 <nvs_read_hist+0xd8>)
 10053e2:	9307      	str	r3, [sp, #28]
 10053e4:	2302      	movs	r3, #2
 10053e6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10053ea:	aa06      	add	r2, sp, #24
 10053ec:	9306      	str	r3, [sp, #24]
 10053ee:	f01f fdd4 	bl	1024f9a <z_log_msg_static_create.constprop.0>
		return -EACCES;
 10053f2:	f06f 000c 	mvn.w	r0, #12

	return wlk_ate.len;

err:
	return rc;
}
 10053f6:	b008      	add	sp, #32
 10053f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
 10053fc:	2108      	movs	r1, #8
 10053fe:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 1005400:	f01f fdce 	bl	1024fa0 <nvs_al_size.isra.0>
	if (len > (fs->sector_size - 2 * ate_size)) {
 1005404:	89a3      	ldrh	r3, [r4, #12]
 1005406:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
 100540a:	42b3      	cmp	r3, r6
 100540c:	d343      	bcc.n	1005496 <nvs_read_hist+0xce>
	cnt_his = 0U;
 100540e:	2500      	movs	r5, #0
	wlk_addr = fs->ate_wra;
 1005410:	f8d4 a004 	ldr.w	sl, [r4, #4]
 1005414:	f8cd a004 	str.w	sl, [sp, #4]
	while (cnt_his <= cnt) {
 1005418:	454d      	cmp	r5, r9
 100541a:	4651      	mov	r1, sl
		rd_addr = wlk_addr;
 100541c:	f8dd a004 	ldr.w	sl, [sp, #4]
	while (cnt_his <= cnt) {
 1005420:	d909      	bls.n	1005436 <nvs_read_hist+0x6e>
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
 1005422:	6863      	ldr	r3, [r4, #4]
 1005424:	4553      	cmp	r3, sl
 1005426:	d11e      	bne.n	1005466 <nvs_read_hist+0x9e>
 1005428:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 100542c:	42bb      	cmp	r3, r7
 100542e:	d01a      	beq.n	1005466 <nvs_read_hist+0x9e>
		return -ENOENT;
 1005430:	f06f 0001 	mvn.w	r0, #1
 1005434:	e7df      	b.n	10053f6 <nvs_read_hist+0x2e>
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
 1005436:	4620      	mov	r0, r4
 1005438:	aa02      	add	r2, sp, #8
 100543a:	a901      	add	r1, sp, #4
 100543c:	f01f fdf2 	bl	1025024 <nvs_prev_ate>
		if (rc) {
 1005440:	2800      	cmp	r0, #0
 1005442:	d1d8      	bne.n	10053f6 <nvs_read_hist+0x2e>
		if ((wlk_ate.id == id) &&  (nvs_ate_valid(fs, &wlk_ate))) {
 1005444:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 1005448:	42bb      	cmp	r3, r7
 100544a:	d106      	bne.n	100545a <nvs_read_hist+0x92>
 100544c:	4620      	mov	r0, r4
 100544e:	a902      	add	r1, sp, #8
 1005450:	f01f fdb0 	bl	1024fb4 <nvs_ate_valid>
 1005454:	b108      	cbz	r0, 100545a <nvs_read_hist+0x92>
			cnt_his++;
 1005456:	3501      	adds	r5, #1
 1005458:	b2ad      	uxth	r5, r5
		if (wlk_addr == fs->ate_wra) {
 100545a:	6862      	ldr	r2, [r4, #4]
 100545c:	9b01      	ldr	r3, [sp, #4]
 100545e:	429a      	cmp	r2, r3
 1005460:	d1da      	bne.n	1005418 <nvs_read_hist+0x50>
		rd_addr = wlk_addr;
 1005462:	4651      	mov	r1, sl
 1005464:	e7e0      	b.n	1005428 <nvs_read_hist+0x60>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
 1005466:	f8bd 300c 	ldrh.w	r3, [sp, #12]
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
 100546a:	2b00      	cmp	r3, #0
 100546c:	d0e0      	beq.n	1005430 <nvs_read_hist+0x68>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
 100546e:	45a9      	cmp	r9, r5
 1005470:	d8de      	bhi.n	1005430 <nvs_read_hist+0x68>
	rd_addr += wlk_ate.offset;
 1005472:	f8bd 000a 	ldrh.w	r0, [sp, #10]
	rd_addr &= ADDR_SECT_MASK;
 1005476:	0c09      	lsrs	r1, r1, #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
 1005478:	42b3      	cmp	r3, r6
	rd_addr &= ADDR_SECT_MASK;
 100547a:	ea4f 4101 	mov.w	r1, r1, lsl #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
 100547e:	bf28      	it	cs
 1005480:	4633      	movcs	r3, r6
 1005482:	4401      	add	r1, r0
 1005484:	4642      	mov	r2, r8
 1005486:	4620      	mov	r0, r4
 1005488:	f01f fcfa 	bl	1024e80 <nvs_flash_rd>
	if (rc) {
 100548c:	2800      	cmp	r0, #0
 100548e:	d1b2      	bne.n	10053f6 <nvs_read_hist+0x2e>
	return wlk_ate.len;
 1005490:	f8bd 000c 	ldrh.w	r0, [sp, #12]
 1005494:	e7af      	b.n	10053f6 <nvs_read_hist+0x2e>
		return -EINVAL;
 1005496:	f06f 0015 	mvn.w	r0, #21
 100549a:	e7ac      	b.n	10053f6 <nvs_read_hist+0x2e>
 100549c:	0102c125 	.word	0x0102c125
 10054a0:	01029a0c 	.word	0x01029a0c

010054a4 <flash_area_open>:
		user_cb(&flash_map[i], user_data);
	}
}

int flash_area_open(uint8_t id, const struct flash_area **fap)
{
 10054a4:	b570      	push	{r4, r5, r6, lr}
	const struct flash_area *area;

	if (flash_map == NULL) {
 10054a6:	4b11      	ldr	r3, [pc, #68]	; (10054ec <flash_area_open+0x48>)
{
 10054a8:	460d      	mov	r5, r1
	if (flash_map == NULL) {
 10054aa:	681c      	ldr	r4, [r3, #0]
 10054ac:	b1dc      	cbz	r4, 10054e6 <flash_area_open+0x42>
extern const struct flash_area *flash_map;
extern const int flash_map_entries;

static inline struct flash_area const *get_flash_area_from_id(int idx)
{
	for (int i = 0; i < flash_map_entries; i++) {
 10054ae:	4b10      	ldr	r3, [pc, #64]	; (10054f0 <flash_area_open+0x4c>)
 10054b0:	6819      	ldr	r1, [r3, #0]
 10054b2:	2300      	movs	r3, #0
 10054b4:	428b      	cmp	r3, r1
 10054b6:	db02      	blt.n	10054be <flash_area_open+0x1a>
		return -EACCES;
	}

	area = get_flash_area_from_id(id);
	if (area == NULL) {
		return -ENOENT;
 10054b8:	f06f 0001 	mvn.w	r0, #1
	}

	*fap = area;

	return 0;
}
 10054bc:	bd70      	pop	{r4, r5, r6, pc}
		if (flash_map[i].fa_id == idx) {
 10054be:	4622      	mov	r2, r4
 10054c0:	f812 6b10 	ldrb.w	r6, [r2], #16
 10054c4:	4286      	cmp	r6, r0
 10054c6:	d002      	beq.n	10054ce <flash_area_open+0x2a>
	for (int i = 0; i < flash_map_entries; i++) {
 10054c8:	4614      	mov	r4, r2
 10054ca:	3301      	adds	r3, #1
 10054cc:	e7f2      	b.n	10054b4 <flash_area_open+0x10>
	if (!area->fa_dev || !device_is_ready(area->fa_dev)) {
 10054ce:	68e0      	ldr	r0, [r4, #12]
 10054d0:	b910      	cbnz	r0, 10054d8 <flash_area_open+0x34>
		return -ENODEV;
 10054d2:	f06f 0012 	mvn.w	r0, #18
 10054d6:	e7f1      	b.n	10054bc <flash_area_open+0x18>
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
 10054d8:	f023 fea6 	bl	1029228 <z_device_is_ready>
	if (!area->fa_dev || !device_is_ready(area->fa_dev)) {
 10054dc:	2800      	cmp	r0, #0
 10054de:	d0f8      	beq.n	10054d2 <flash_area_open+0x2e>
	return 0;
 10054e0:	2000      	movs	r0, #0
	*fap = area;
 10054e2:	602c      	str	r4, [r5, #0]
	return 0;
 10054e4:	e7ea      	b.n	10054bc <flash_area_open+0x18>
		return -EACCES;
 10054e6:	f06f 000c 	mvn.w	r0, #12
 10054ea:	e7e7      	b.n	10054bc <flash_area_open+0x18>
 10054ec:	21000278 	.word	0x21000278
 10054f0:	01029c20 	.word	0x01029c20

010054f4 <flash_area_get_sectors>:

	return true;
}

int flash_area_get_sectors(int idx, uint32_t *cnt, struct flash_sector *ret)
{
 10054f4:	b570      	push	{r4, r5, r6, lr}
 10054f6:	b088      	sub	sp, #32
 10054f8:	4605      	mov	r5, r0
 10054fa:	460c      	mov	r4, r1
	int rc = flash_area_open(idx, &fa);
 10054fc:	b2c0      	uxtb	r0, r0
 10054fe:	4669      	mov	r1, sp
{
 1005500:	4616      	mov	r6, r2
	int rc = flash_area_open(idx, &fa);
 1005502:	f7ff ffcf 	bl	10054a4 <flash_area_open>
	if (rc < 0 || fa == NULL) {
 1005506:	2800      	cmp	r0, #0
 1005508:	db1b      	blt.n	1005542 <flash_area_get_sectors+0x4e>
 100550a:	9800      	ldr	r0, [sp, #0]
 100550c:	b1c8      	cbz	r0, 1005542 <flash_area_get_sectors+0x4e>
	cb_data->area_off = fa->fa_off;
 100550e:	6843      	ldr	r3, [r0, #4]
	cb_data->ret_len = *cnt;
 1005510:	6822      	ldr	r2, [r4, #0]
	cb_data->area_off = fa->fa_off;
 1005512:	9302      	str	r3, [sp, #8]
	cb_data->area_len = fa->fa_size;
 1005514:	6883      	ldr	r3, [r0, #8]
	cb_data->area_idx = idx;
 1005516:	9501      	str	r5, [sp, #4]
	cb_data->ret = ret;
 1005518:	e9cd 3603 	strd	r3, r6, [sp, #12]
	cb_data->ret_idx = 0U;
 100551c:	2300      	movs	r3, #0
	cb_data->status = 0;
 100551e:	e9cd 2306 	strd	r2, r3, [sp, #24]
	cb_data->ret_idx = 0U;
 1005522:	9305      	str	r3, [sp, #20]
	flash_dev = fa->fa_dev;
 1005524:	68c5      	ldr	r5, [r0, #12]
	flash_area_close(fa);
 1005526:	f01f feff 	bl	1025328 <flash_area_close>
	if (flash_dev == NULL) {
 100552a:	b16d      	cbz	r5, 1005548 <flash_area_get_sectors+0x54>
	flash_page_foreach(flash_dev, cb, cb_data);
 100552c:	4628      	mov	r0, r5
 100552e:	4908      	ldr	r1, [pc, #32]	; (1005550 <flash_area_get_sectors+0x5c>)
 1005530:	aa01      	add	r2, sp, #4
 1005532:	f023 fd4c 	bl	1028fce <flash_page_foreach>
	if (cb_data->status == 0) {
 1005536:	9807      	ldr	r0, [sp, #28]
 1005538:	b908      	cbnz	r0, 100553e <flash_area_get_sectors+0x4a>
		*cnt = cb_data->ret_idx;
 100553a:	9b05      	ldr	r3, [sp, #20]
 100553c:	6023      	str	r3, [r4, #0]
	struct layout_data data;

	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
}
 100553e:	b008      	add	sp, #32
 1005540:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
 1005542:	f06f 0015 	mvn.w	r0, #21
 1005546:	e7fa      	b.n	100553e <flash_area_get_sectors+0x4a>
		return -ENODEV;
 1005548:	f06f 0012 	mvn.w	r0, #18
	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
 100554c:	e7f7      	b.n	100553e <flash_area_get_sectors+0x4a>
 100554e:	bf00      	nop
 1005550:	0102532b 	.word	0x0102532b

01005554 <settings_save_one>:

/*
 * Append a single value to persisted config. Don't store duplicate value.
 */
int settings_save_one(const char *name, const void *value, size_t val_len)
{
 1005554:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int rc;
	struct settings_store *cs;

	cs = settings_save_dst;
 1005558:	4b0f      	ldr	r3, [pc, #60]	; (1005598 <settings_save_one+0x44>)
{
 100555a:	4605      	mov	r5, r0
	cs = settings_save_dst;
 100555c:	681c      	ldr	r4, [r3, #0]
{
 100555e:	460e      	mov	r6, r1
 1005560:	4617      	mov	r7, r2
	if (!cs) {
 1005562:	b1ac      	cbz	r4, 1005590 <settings_save_one+0x3c>
	return z_impl_k_mutex_lock(mutex, timeout);
 1005564:	f04f 32ff 	mov.w	r2, #4294967295
 1005568:	f04f 33ff 	mov.w	r3, #4294967295
 100556c:	480b      	ldr	r0, [pc, #44]	; (100559c <settings_save_one+0x48>)
 100556e:	f01b fdf7 	bl	1021160 <z_impl_k_mutex_lock>
		return -ENOENT;
	}

	k_mutex_lock(&settings_lock, K_FOREVER);

	rc = cs->cs_itf->csi_save(cs, name, (char *)value, val_len);
 1005572:	6863      	ldr	r3, [r4, #4]
 1005574:	4632      	mov	r2, r6
 1005576:	f8d3 8008 	ldr.w	r8, [r3, #8]
 100557a:	4629      	mov	r1, r5
 100557c:	463b      	mov	r3, r7
 100557e:	4620      	mov	r0, r4
 1005580:	47c0      	blx	r8
 1005582:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
 1005584:	4805      	ldr	r0, [pc, #20]	; (100559c <settings_save_one+0x48>)
 1005586:	f01b febb 	bl	1021300 <z_impl_k_mutex_unlock>

	k_mutex_unlock(&settings_lock);

	return rc;
}
 100558a:	4620      	mov	r0, r4
 100558c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOENT;
 1005590:	f06f 0401 	mvn.w	r4, #1
 1005594:	e7f9      	b.n	100558a <settings_save_one+0x36>
 1005596:	bf00      	nop
 1005598:	21004610 	.word	0x21004610
 100559c:	21000c84 	.word	0x21000c84

010055a0 <settings_src_register>:
	parent->next = child;
 10055a0:	2300      	movs	r3, #0
 10055a2:	6003      	str	r3, [r0, #0]
	return list->tail;
 10055a4:	4b04      	ldr	r3, [pc, #16]	; (10055b8 <settings_src_register+0x18>)
 10055a6:	685a      	ldr	r2, [r3, #4]
Z_GENLIST_APPEND(slist, snode)
 10055a8:	b912      	cbnz	r2, 10055b0 <settings_src_register+0x10>
	list->head = node;
 10055aa:	e9c3 0000 	strd	r0, r0, [r3]
}
 10055ae:	4770      	bx	lr
	parent->next = child;
 10055b0:	6010      	str	r0, [r2, #0]
	list->tail = node;
 10055b2:	6058      	str	r0, [r3, #4]
}
 10055b4:	4770      	bx	lr
 10055b6:	bf00      	nop
 10055b8:	21004614 	.word	0x21004614

010055bc <settings_dst_register>:
	settings_save_dst = cs;
 10055bc:	4b01      	ldr	r3, [pc, #4]	; (10055c4 <settings_dst_register+0x8>)
 10055be:	6018      	str	r0, [r3, #0]
}
 10055c0:	4770      	bx	lr
 10055c2:	bf00      	nop
 10055c4:	21004610 	.word	0x21004610

010055c8 <settings_load_subtree>:
	const struct settings_load_arg arg = {
 10055c8:	2300      	movs	r3, #0
{
 10055ca:	b530      	push	{r4, r5, lr}
 10055cc:	b085      	sub	sp, #20
 10055ce:	4605      	mov	r5, r0
	const struct settings_load_arg arg = {
 10055d0:	e9cd 3302 	strd	r3, r3, [sp, #8]
 10055d4:	9001      	str	r0, [sp, #4]
	return z_impl_k_mutex_lock(mutex, timeout);
 10055d6:	f04f 33ff 	mov.w	r3, #4294967295
 10055da:	f04f 32ff 	mov.w	r2, #4294967295
 10055de:	480b      	ldr	r0, [pc, #44]	; (100560c <settings_load_subtree+0x44>)
 10055e0:	f01b fdbe 	bl	1021160 <z_impl_k_mutex_lock>
	return list->head;
 10055e4:	4b0a      	ldr	r3, [pc, #40]	; (1005610 <settings_load_subtree+0x48>)
 10055e6:	681c      	ldr	r4, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
 10055e8:	b94c      	cbnz	r4, 10055fe <settings_load_subtree+0x36>
	rc = settings_commit_subtree(subtree);
 10055ea:	4628      	mov	r0, r5
 10055ec:	f000 f8f6 	bl	10057dc <settings_commit_subtree>
 10055f0:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
 10055f2:	4806      	ldr	r0, [pc, #24]	; (100560c <settings_load_subtree+0x44>)
 10055f4:	f01b fe84 	bl	1021300 <z_impl_k_mutex_unlock>
}
 10055f8:	4620      	mov	r0, r4
 10055fa:	b005      	add	sp, #20
 10055fc:	bd30      	pop	{r4, r5, pc}
		cs->cs_itf->csi_load(cs, &arg);
 10055fe:	6863      	ldr	r3, [r4, #4]
 1005600:	4620      	mov	r0, r4
 1005602:	681b      	ldr	r3, [r3, #0]
 1005604:	a901      	add	r1, sp, #4
 1005606:	4798      	blx	r3
	return node->next;
 1005608:	6824      	ldr	r4, [r4, #0]
 100560a:	e7ed      	b.n	10055e8 <settings_load_subtree+0x20>
 100560c:	21000c84 	.word	0x21000c84
 1005610:	21004614 	.word	0x21004614

01005614 <settings_load_subtree_direct>:
{
 1005614:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	const struct settings_load_arg arg = {
 1005616:	e9cd 0101 	strd	r0, r1, [sp, #4]
 100561a:	9203      	str	r2, [sp, #12]
	return z_impl_k_mutex_lock(mutex, timeout);
 100561c:	f04f 33ff 	mov.w	r3, #4294967295
 1005620:	f04f 32ff 	mov.w	r2, #4294967295
 1005624:	4809      	ldr	r0, [pc, #36]	; (100564c <settings_load_subtree_direct+0x38>)
 1005626:	f01b fd9b 	bl	1021160 <z_impl_k_mutex_lock>
	return list->head;
 100562a:	4b09      	ldr	r3, [pc, #36]	; (1005650 <settings_load_subtree_direct+0x3c>)
 100562c:	681c      	ldr	r4, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
 100562e:	b92c      	cbnz	r4, 100563c <settings_load_subtree_direct+0x28>
	return z_impl_k_mutex_unlock(mutex);
 1005630:	4806      	ldr	r0, [pc, #24]	; (100564c <settings_load_subtree_direct+0x38>)
 1005632:	f01b fe65 	bl	1021300 <z_impl_k_mutex_unlock>
}
 1005636:	4620      	mov	r0, r4
 1005638:	b004      	add	sp, #16
 100563a:	bd10      	pop	{r4, pc}
		cs->cs_itf->csi_load(cs, &arg);
 100563c:	6863      	ldr	r3, [r4, #4]
 100563e:	4620      	mov	r0, r4
 1005640:	681b      	ldr	r3, [r3, #0]
 1005642:	a901      	add	r1, sp, #4
 1005644:	4798      	blx	r3
	return node->next;
 1005646:	6824      	ldr	r4, [r4, #0]
 1005648:	e7f1      	b.n	100562e <settings_load_subtree_direct+0x1a>
 100564a:	bf00      	nop
 100564c:	21000c84 	.word	0x21000c84
 1005650:	21004614 	.word	0x21004614

01005654 <settings_store_init>:
	list->head = NULL;
 1005654:	2200      	movs	r2, #0
 1005656:	4b02      	ldr	r3, [pc, #8]	; (1005660 <settings_store_init+0xc>)
	list->tail = NULL;
 1005658:	e9c3 2200 	strd	r2, r2, [r3]
}

void settings_store_init(void)
{
	sys_slist_init(&settings_load_srcs);
}
 100565c:	4770      	bx	lr
 100565e:	bf00      	nop
 1005660:	21004614 	.word	0x21004614

01005664 <settings_init>:
	list->head = NULL;
 1005664:	2200      	movs	r2, #0
 1005666:	4b02      	ldr	r3, [pc, #8]	; (1005670 <settings_init+0xc>)
	list->tail = NULL;
 1005668:	e9c3 2200 	strd	r2, r2, [r3]
void settings_init(void)
{
#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	sys_slist_init(&settings_handlers);
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	settings_store_init();
 100566c:	f7ff bff2 	b.w	1005654 <settings_store_init>
 1005670:	2100461c 	.word	0x2100461c

01005674 <settings_parse_and_lookup>:
	return rc;
}

struct settings_handler_static *settings_parse_and_lookup(const char *name,
							const char **next)
{
 1005674:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 1005678:	4607      	mov	r7, r0
	struct settings_handler_static *bestmatch;
	const char *tmpnext;

	bestmatch = NULL;
	if (next) {
 100567a:	460c      	mov	r4, r1
 100567c:	b109      	cbz	r1, 1005682 <settings_parse_and_lookup+0xe>
		*next = NULL;
 100567e:	2300      	movs	r3, #0
 1005680:	600b      	str	r3, [r1, #0]
{
 1005682:	2600      	movs	r6, #0
 1005684:	4d25      	ldr	r5, [pc, #148]	; (100571c <settings_parse_and_lookup+0xa8>)
	}

	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
 1005686:	f8df 9098 	ldr.w	r9, [pc, #152]	; 1005720 <settings_parse_and_lookup+0xac>
 100568a:	454d      	cmp	r5, r9
 100568c:	d924      	bls.n	10056d8 <settings_parse_and_lookup+0x64>
 100568e:	4925      	ldr	r1, [pc, #148]	; (1005724 <settings_parse_and_lookup+0xb0>)
 1005690:	2394      	movs	r3, #148	; 0x94
 1005692:	4a25      	ldr	r2, [pc, #148]	; (1005728 <settings_parse_and_lookup+0xb4>)
 1005694:	4825      	ldr	r0, [pc, #148]	; (100572c <settings_parse_and_lookup+0xb8>)
 1005696:	f01f fa9e 	bl	1024bd6 <assert_print>
 100569a:	4825      	ldr	r0, [pc, #148]	; (1005730 <settings_parse_and_lookup+0xbc>)
 100569c:	f01f fa9b 	bl	1024bd6 <assert_print>
 10056a0:	2194      	movs	r1, #148	; 0x94
 10056a2:	4821      	ldr	r0, [pc, #132]	; (1005728 <settings_parse_and_lookup+0xb4>)
 10056a4:	f01f fa90 	bl	1024bc8 <assert_post_action>
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
 10056a8:	f8d5 8000 	ldr.w	r8, [r5]
 10056ac:	4638      	mov	r0, r7
 10056ae:	4641      	mov	r1, r8
 10056b0:	aa01      	add	r2, sp, #4
 10056b2:	f01f fe63 	bl	102537c <settings_name_steq>
 10056b6:	b150      	cbz	r0, 10056ce <settings_parse_and_lookup+0x5a>
			continue;
		}
		if (!bestmatch) {
 10056b8:	b916      	cbnz	r6, 10056c0 <settings_parse_and_lookup+0x4c>
			}
			continue;
		}
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
			bestmatch = ch;
			if (next) {
 10056ba:	b954      	cbnz	r4, 10056d2 <settings_parse_and_lookup+0x5e>
{
 10056bc:	462e      	mov	r6, r5
 10056be:	e006      	b.n	10056ce <settings_parse_and_lookup+0x5a>
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
 10056c0:	2200      	movs	r2, #0
 10056c2:	4640      	mov	r0, r8
 10056c4:	6831      	ldr	r1, [r6, #0]
 10056c6:	f01f fe59 	bl	102537c <settings_name_steq>
 10056ca:	2800      	cmp	r0, #0
 10056cc:	d1f5      	bne.n	10056ba <settings_parse_and_lookup+0x46>
	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
 10056ce:	3514      	adds	r5, #20
 10056d0:	e7db      	b.n	100568a <settings_parse_and_lookup+0x16>
				*next = tmpnext;
 10056d2:	9b01      	ldr	r3, [sp, #4]
 10056d4:	6023      	str	r3, [r4, #0]
 10056d6:	e7f1      	b.n	10056bc <settings_parse_and_lookup+0x48>
	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
 10056d8:	d3e6      	bcc.n	10056a8 <settings_parse_and_lookup+0x34>
	return list->head;
 10056da:	4b16      	ldr	r3, [pc, #88]	; (1005734 <settings_parse_and_lookup+0xc0>)
 10056dc:	681d      	ldr	r5, [r3, #0]
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;

	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
 10056de:	b1c5      	cbz	r5, 1005712 <settings_parse_and_lookup+0x9e>
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
 10056e0:	f855 8c14 	ldr.w	r8, [r5, #-20]
 10056e4:	4638      	mov	r0, r7
 10056e6:	4641      	mov	r1, r8
 10056e8:	aa01      	add	r2, sp, #4
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
 10056ea:	3d14      	subs	r5, #20
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
 10056ec:	f01f fe46 	bl	102537c <settings_name_steq>
 10056f0:	b150      	cbz	r0, 1005708 <settings_parse_and_lookup+0x94>
			continue;
		}
		if (!bestmatch) {
 10056f2:	b916      	cbnz	r6, 10056fa <settings_parse_and_lookup+0x86>
			}
			continue;
		}
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
			bestmatch = (struct settings_handler_static *)ch;
			if (next) {
 10056f4:	b954      	cbnz	r4, 100570c <settings_parse_and_lookup+0x98>
{
 10056f6:	462e      	mov	r6, r5
 10056f8:	e006      	b.n	1005708 <settings_parse_and_lookup+0x94>
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
 10056fa:	2200      	movs	r2, #0
 10056fc:	4640      	mov	r0, r8
 10056fe:	6831      	ldr	r1, [r6, #0]
 1005700:	f01f fe3c 	bl	102537c <settings_name_steq>
 1005704:	2800      	cmp	r0, #0
 1005706:	d1f5      	bne.n	10056f4 <settings_parse_and_lookup+0x80>
	return node->next;
 1005708:	696d      	ldr	r5, [r5, #20]
 100570a:	e7e8      	b.n	10056de <settings_parse_and_lookup+0x6a>
				*next = tmpnext;
 100570c:	9b01      	ldr	r3, [sp, #4]
 100570e:	6023      	str	r3, [r4, #0]
 1005710:	e7f1      	b.n	10056f6 <settings_parse_and_lookup+0x82>
			}
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	return bestmatch;
}
 1005712:	4630      	mov	r0, r6
 1005714:	b003      	add	sp, #12
 1005716:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 100571a:	bf00      	nop
 100571c:	01029a7c 	.word	0x01029a7c
 1005720:	01029af4 	.word	0x01029af4
 1005724:	0102c276 	.word	0x0102c276
 1005728:	0102c244 	.word	0x0102c244
 100572c:	0102b695 	.word	0x0102b695
 1005730:	0102bf04 	.word	0x0102bf04
 1005734:	2100461c 	.word	0x2100461c

01005738 <settings_call_set_handler>:
int settings_call_set_handler(const char *name,
			      size_t len,
			      settings_read_cb read_cb,
			      void *read_cb_arg,
			      const struct settings_load_arg *load_arg)
{
 1005738:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100573c:	b084      	sub	sp, #16
 100573e:	af02      	add	r7, sp, #8
 1005740:	f8d7 9028 	ldr.w	r9, [r7, #40]	; 0x28
 1005744:	4604      	mov	r4, r0
 1005746:	460d      	mov	r5, r1
 1005748:	4616      	mov	r6, r2
 100574a:	4698      	mov	r8, r3
	int rc;
	const char *name_key = name;
 100574c:	6078      	str	r0, [r7, #4]

	if (load_arg && load_arg->subtree &&
 100574e:	f1b9 0f00 	cmp.w	r9, #0
 1005752:	d007      	beq.n	1005764 <settings_call_set_handler+0x2c>
 1005754:	f8d9 1000 	ldr.w	r1, [r9]
 1005758:	bb31      	cbnz	r1, 10057a8 <settings_call_set_handler+0x70>
	    !settings_name_steq(name, load_arg->subtree, &name_key)) {
		return 0;
	}

	if (load_arg && load_arg->cb) {
 100575a:	f8d9 a004 	ldr.w	sl, [r9, #4]
 100575e:	f1ba 0f00 	cmp.w	sl, #0
 1005762:	d128      	bne.n	10057b6 <settings_call_set_handler+0x7e>
		rc = load_arg->cb(name_key, len, read_cb, read_cb_arg,
				  load_arg->param);
	} else {
		struct settings_handler_static *ch;

		ch = settings_parse_and_lookup(name, &name_key);
 1005764:	4620      	mov	r0, r4
 1005766:	1d39      	adds	r1, r7, #4
 1005768:	f7ff ff84 	bl	1005674 <settings_parse_and_lookup>
		if (!ch) {
 100576c:	b308      	cbz	r0, 10057b2 <settings_call_set_handler+0x7a>
			return 0;
		}

		rc = ch->h_set(name_key, len, read_cb, read_cb_arg);
 100576e:	f8d0 9008 	ldr.w	r9, [r0, #8]
 1005772:	4643      	mov	r3, r8
 1005774:	4632      	mov	r2, r6
 1005776:	4629      	mov	r1, r5
 1005778:	6878      	ldr	r0, [r7, #4]
 100577a:	47c8      	blx	r9

		if (rc != 0) {
 100577c:	b1c8      	cbz	r0, 10057b2 <settings_call_set_handler+0x7a>
			LOG_ERR("set-value failure. key: %s error(%d)",
 100577e:	466d      	mov	r5, sp
 1005780:	b08a      	sub	sp, #40	; 0x28
 1005782:	aa02      	add	r2, sp, #8
 1005784:	4b12      	ldr	r3, [pc, #72]	; (10057d0 <settings_call_set_handler+0x98>)
 1005786:	61d0      	str	r0, [r2, #28]
 1005788:	e9c2 3405 	strd	r3, r4, [r2, #20]
 100578c:	f44f 7300 	mov.w	r3, #512	; 0x200
 1005790:	8413      	strh	r3, [r2, #32]
 1005792:	4b10      	ldr	r3, [pc, #64]	; (10057d4 <settings_call_set_handler+0x9c>)
 1005794:	f842 3f10 	str.w	r3, [r2, #16]!
 1005798:	2300      	movs	r3, #0
 100579a:	f44f 5111 	mov.w	r1, #9280	; 0x2440
 100579e:	480e      	ldr	r0, [pc, #56]	; (10057d8 <settings_call_set_handler+0xa0>)
 10057a0:	f7fe ffb2 	bl	1004708 <z_impl_z_log_msg_static_create>
 10057a4:	46ad      	mov	sp, r5
				name, rc);
			/* Ignoring the error */
			rc = 0;
 10057a6:	e004      	b.n	10057b2 <settings_call_set_handler+0x7a>
	    !settings_name_steq(name, load_arg->subtree, &name_key)) {
 10057a8:	1d3a      	adds	r2, r7, #4
 10057aa:	f01f fde7 	bl	102537c <settings_name_steq>
	if (load_arg && load_arg->subtree &&
 10057ae:	2800      	cmp	r0, #0
 10057b0:	d1d3      	bne.n	100575a <settings_call_set_handler+0x22>
		return 0;
 10057b2:	2000      	movs	r0, #0
 10057b4:	e007      	b.n	10057c6 <settings_call_set_handler+0x8e>
		rc = load_arg->cb(name_key, len, read_cb, read_cb_arg,
 10057b6:	f8d9 3008 	ldr.w	r3, [r9, #8]
 10057ba:	4632      	mov	r2, r6
 10057bc:	9300      	str	r3, [sp, #0]
 10057be:	4629      	mov	r1, r5
 10057c0:	4643      	mov	r3, r8
 10057c2:	6878      	ldr	r0, [r7, #4]
 10057c4:	47d0      	blx	sl
			LOG_DBG("set-value OK. key: %s",
				name);
		}
	}
	return rc;
}
 10057c6:	3708      	adds	r7, #8
 10057c8:	46bd      	mov	sp, r7
 10057ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 10057ce:	bf00      	nop
 10057d0:	0102c29e 	.word	0x0102c29e
 10057d4:	01000004 	.word	0x01000004
 10057d8:	01029a5c 	.word	0x01029a5c

010057dc <settings_commit_subtree>:
{
	return settings_commit_subtree(NULL);
}

int settings_commit_subtree(const char *subtree)
{
 10057dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10057de:	4606      	mov	r6, r0
	int rc;
	int rc2;

	rc = 0;
 10057e0:	2500      	movs	r5, #0

	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
 10057e2:	4c1e      	ldr	r4, [pc, #120]	; (100585c <settings_commit_subtree+0x80>)
 10057e4:	4f1e      	ldr	r7, [pc, #120]	; (1005860 <settings_commit_subtree+0x84>)
 10057e6:	42bc      	cmp	r4, r7
 10057e8:	d91f      	bls.n	100582a <settings_commit_subtree+0x4e>
 10057ea:	491e      	ldr	r1, [pc, #120]	; (1005864 <settings_commit_subtree+0x88>)
 10057ec:	23f4      	movs	r3, #244	; 0xf4
 10057ee:	4a1e      	ldr	r2, [pc, #120]	; (1005868 <settings_commit_subtree+0x8c>)
 10057f0:	481e      	ldr	r0, [pc, #120]	; (100586c <settings_commit_subtree+0x90>)
 10057f2:	f01f f9f0 	bl	1024bd6 <assert_print>
 10057f6:	481e      	ldr	r0, [pc, #120]	; (1005870 <settings_commit_subtree+0x94>)
 10057f8:	f01f f9ed 	bl	1024bd6 <assert_print>
 10057fc:	21f4      	movs	r1, #244	; 0xf4
 10057fe:	481a      	ldr	r0, [pc, #104]	; (1005868 <settings_commit_subtree+0x8c>)
 1005800:	f01f f9e2 	bl	1024bc8 <assert_post_action>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
 1005804:	b92e      	cbnz	r6, 1005812 <settings_commit_subtree+0x36>
			continue;
		}
		if (ch->h_commit) {
 1005806:	68e3      	ldr	r3, [r4, #12]
 1005808:	b95b      	cbnz	r3, 1005822 <settings_commit_subtree+0x46>
{
 100580a:	4628      	mov	r0, r5
	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
 100580c:	4605      	mov	r5, r0
 100580e:	3414      	adds	r4, #20
 1005810:	e7e9      	b.n	10057e6 <settings_commit_subtree+0xa>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
 1005812:	2200      	movs	r2, #0
 1005814:	4631      	mov	r1, r6
 1005816:	6820      	ldr	r0, [r4, #0]
 1005818:	f01f fdb0 	bl	102537c <settings_name_steq>
 100581c:	2800      	cmp	r0, #0
 100581e:	d1f2      	bne.n	1005806 <settings_commit_subtree+0x2a>
 1005820:	e7f3      	b.n	100580a <settings_commit_subtree+0x2e>
			rc2 = ch->h_commit();
 1005822:	4798      	blx	r3
			if (!rc) {
 1005824:	2d00      	cmp	r5, #0
 1005826:	d1f0      	bne.n	100580a <settings_commit_subtree+0x2e>
 1005828:	e7f0      	b.n	100580c <settings_commit_subtree+0x30>
	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
 100582a:	d3eb      	bcc.n	1005804 <settings_commit_subtree+0x28>
	return list->head;
 100582c:	4b11      	ldr	r3, [pc, #68]	; (1005874 <settings_commit_subtree+0x98>)
 100582e:	681c      	ldr	r4, [r3, #0]
		}
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
 1005830:	b194      	cbz	r4, 1005858 <settings_commit_subtree+0x7c>
 1005832:	3c14      	subs	r4, #20
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
 1005834:	b91e      	cbnz	r6, 100583e <settings_commit_subtree+0x62>
			continue;
		}
		if (ch->h_commit) {
 1005836:	68e3      	ldr	r3, [r4, #12]
 1005838:	b94b      	cbnz	r3, 100584e <settings_commit_subtree+0x72>
	return node->next;
 100583a:	6964      	ldr	r4, [r4, #20]
 100583c:	e7f8      	b.n	1005830 <settings_commit_subtree+0x54>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
 100583e:	2200      	movs	r2, #0
 1005840:	4631      	mov	r1, r6
 1005842:	6820      	ldr	r0, [r4, #0]
 1005844:	f01f fd9a 	bl	102537c <settings_name_steq>
 1005848:	2800      	cmp	r0, #0
 100584a:	d1f4      	bne.n	1005836 <settings_commit_subtree+0x5a>
 100584c:	e7f5      	b.n	100583a <settings_commit_subtree+0x5e>
			rc2 = ch->h_commit();
 100584e:	4798      	blx	r3
			if (!rc) {
				rc = rc2;
 1005850:	2d00      	cmp	r5, #0
 1005852:	bf08      	it	eq
 1005854:	4605      	moveq	r5, r0
 1005856:	e7f0      	b.n	100583a <settings_commit_subtree+0x5e>
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */

	return rc;
}
 1005858:	4628      	mov	r0, r5
 100585a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 100585c:	01029a7c 	.word	0x01029a7c
 1005860:	01029af4 	.word	0x01029af4
 1005864:	0102c276 	.word	0x0102c276
 1005868:	0102c244 	.word	0x0102c244
 100586c:	0102b695 	.word	0x0102b695
 1005870:	0102bf04 	.word	0x0102bf04
 1005874:	2100461c 	.word	0x2100461c

01005878 <settings_subsys_init>:
void settings_init(void);

int settings_backend_init(void);

int settings_subsys_init(void)
{
 1005878:	b510      	push	{r4, lr}

	int err = 0;

	if (settings_subsys_initialized) {
 100587a:	4c07      	ldr	r4, [pc, #28]	; (1005898 <settings_subsys_init+0x20>)
 100587c:	7823      	ldrb	r3, [r4, #0]
 100587e:	b10b      	cbz	r3, 1005884 <settings_subsys_init+0xc>
		return 0;
 1005880:	2000      	movs	r0, #0
	if (!err) {
		settings_subsys_initialized = true;
	}

	return err;
}
 1005882:	bd10      	pop	{r4, pc}
	settings_init();
 1005884:	f7ff feee 	bl	1005664 <settings_init>
	err = settings_backend_init(); /* func rises kernel panic once error */
 1005888:	f000 f866 	bl	1005958 <settings_backend_init>
	if (!err) {
 100588c:	2800      	cmp	r0, #0
 100588e:	d1f8      	bne.n	1005882 <settings_subsys_init+0xa>
		settings_subsys_initialized = true;
 1005890:	2301      	movs	r3, #1
 1005892:	7023      	strb	r3, [r4, #0]
 1005894:	e7f4      	b.n	1005880 <settings_subsys_init+0x8>
 1005896:	bf00      	nop
 1005898:	21008204 	.word	0x21008204

0100589c <settings_nvs_load>:
}
#endif /* CONFIG_SETTINGS_NVS_NAME_CACHE */

static int settings_nvs_load(struct settings_store *cs,
			     const struct settings_load_arg *arg)
{
 100589c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 10058a0:	4680      	mov	r8, r0
 10058a2:	4689      	mov	r9, r1
	char name[SETTINGS_MAX_NAME_LEN + SETTINGS_EXTRA_LEN + 1];
	char buf;
	ssize_t rc1, rc2;
	uint16_t name_id = NVS_NAMECNT_ID;

	name_id = cf->last_name_id + 1;
 10058a4:	8f04      	ldrh	r4, [r0, #56]	; 0x38

#if CONFIG_SETTINGS_NVS_NAME_CACHE
		settings_nvs_cache_add(cf, name, name_id);
#endif

		ret = settings_call_set_handler(
 10058a6:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 1005954 <settings_nvs_load+0xb8>
	name_id = cf->last_name_id + 1;
 10058aa:	3401      	adds	r4, #1
{
 10058ac:	b098      	sub	sp, #96	; 0x60
	name_id = cf->last_name_id + 1;
 10058ae:	b2a4      	uxth	r4, r4
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
 10058b0:	f100 0608 	add.w	r6, r0, #8
		name_id--;
 10058b4:	1e65      	subs	r5, r4, #1
 10058b6:	b2ad      	uxth	r5, r5
		if (name_id == NVS_NAMECNT_ID) {
 10058b8:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
 10058bc:	d047      	beq.n	100594e <settings_nvs_load+0xb2>
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
 10058be:	234a      	movs	r3, #74	; 0x4a
 10058c0:	4629      	mov	r1, r5
 10058c2:	aa05      	add	r2, sp, #20
 10058c4:	4630      	mov	r0, r6
 10058c6:	f01f fd28 	bl	102531a <nvs_read>
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
 10058ca:	f504 547f 	add.w	r4, r4, #16320	; 0x3fc0
 10058ce:	343f      	adds	r4, #63	; 0x3f
 10058d0:	b2a4      	uxth	r4, r4
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
 10058d2:	4607      	mov	r7, r0
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
 10058d4:	4621      	mov	r1, r4
 10058d6:	2301      	movs	r3, #1
 10058d8:	4630      	mov	r0, r6
 10058da:	f10d 020b 	add.w	r2, sp, #11
 10058de:	f01f fd1c 	bl	102531a <nvs_read>
		if ((rc1 <= 0) && (rc2 <= 0)) {
 10058e2:	2f00      	cmp	r7, #0
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
 10058e4:	4601      	mov	r1, r0
		if ((rc1 <= 0) && (rc2 <= 0)) {
 10058e6:	dc03      	bgt.n	10058f0 <settings_nvs_load+0x54>
 10058e8:	2800      	cmp	r0, #0
 10058ea:	dc03      	bgt.n	10058f4 <settings_nvs_load+0x58>
{
 10058ec:	462c      	mov	r4, r5
 10058ee:	e7e1      	b.n	10058b4 <settings_nvs_load+0x18>
		if ((rc1 <= 0) || (rc2 <= 0)) {
 10058f0:	2800      	cmp	r0, #0
 10058f2:	dc16      	bgt.n	1005922 <settings_nvs_load+0x86>
			if (name_id == cf->last_name_id) {
 10058f4:	f8b8 3038 	ldrh.w	r3, [r8, #56]	; 0x38
 10058f8:	42ab      	cmp	r3, r5
 10058fa:	d109      	bne.n	1005910 <settings_nvs_load+0x74>
				cf->last_name_id--;
 10058fc:	4642      	mov	r2, r8
 10058fe:	1e6b      	subs	r3, r5, #1
 1005900:	f822 3f38 	strh.w	r3, [r2, #56]!
				nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID,
 1005904:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 1005908:	2302      	movs	r3, #2
 100590a:	4630      	mov	r0, r6
 100590c:	f7ff fc80 	bl	1005210 <nvs_write>
			nvs_delete(&cf->cf_nvs, name_id);
 1005910:	4629      	mov	r1, r5
 1005912:	4630      	mov	r0, r6
 1005914:	f01f fcfd 	bl	1025312 <nvs_delete>
			nvs_delete(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET);
 1005918:	4621      	mov	r1, r4
 100591a:	4630      	mov	r0, r6
 100591c:	f01f fcf9 	bl	1025312 <nvs_delete>
			continue;
 1005920:	e7e4      	b.n	10058ec <settings_nvs_load+0x50>
		name[rc1] = '\0';
 1005922:	f107 0360 	add.w	r3, r7, #96	; 0x60
 1005926:	eb0d 0703 	add.w	r7, sp, r3
 100592a:	2300      	movs	r3, #0
		ret = settings_call_set_handler(
 100592c:	4652      	mov	r2, sl
		name[rc1] = '\0';
 100592e:	f807 3c4c 	strb.w	r3, [r7, #-76]
		ret = settings_call_set_handler(
 1005932:	a805      	add	r0, sp, #20
 1005934:	f8cd 9000 	str.w	r9, [sp]
 1005938:	ab03      	add	r3, sp, #12
		read_fn_arg.fs = &cf->cf_nvs;
 100593a:	9603      	str	r6, [sp, #12]
		read_fn_arg.id = name_id + NVS_NAME_ID_OFFSET;
 100593c:	f8ad 4010 	strh.w	r4, [sp, #16]
		ret = settings_call_set_handler(
 1005940:	f7ff fefa 	bl	1005738 <settings_call_set_handler>
			name, rc2,
			settings_nvs_read_fn, &read_fn_arg,
			(void *)arg);
		if (ret) {
 1005944:	2800      	cmp	r0, #0
 1005946:	d0d1      	beq.n	10058ec <settings_nvs_load+0x50>
			break;
		}
	}
	return ret;
}
 1005948:	b018      	add	sp, #96	; 0x60
 100594a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 100594e:	2000      	movs	r0, #0
	return ret;
 1005950:	e7fa      	b.n	1005948 <settings_nvs_load+0xac>
 1005952:	bf00      	nop
 1005954:	010253ed 	.word	0x010253ed

01005958 <settings_backend_init>:
	LOG_DBG("Initialized");
	return 0;
}

int settings_backend_init(void)
{
 1005958:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	int rc;
	uint16_t cnt = 0;
	size_t nvs_sector_size, nvs_size = 0;
	const struct flash_area *fa;
	struct flash_sector hw_flash_sector;
	uint32_t sector_cnt = 1;
 100595a:	2301      	movs	r3, #1

	rc = flash_area_open(SETTINGS_PARTITION, &fa);
 100595c:	4669      	mov	r1, sp
 100595e:	2004      	movs	r0, #4
	uint32_t sector_cnt = 1;
 1005960:	9301      	str	r3, [sp, #4]
	rc = flash_area_open(SETTINGS_PARTITION, &fa);
 1005962:	f7ff fd9f 	bl	10054a4 <flash_area_open>
	if (rc) {
 1005966:	4604      	mov	r4, r0
 1005968:	2800      	cmp	r0, #0
 100596a:	d134      	bne.n	10059d6 <settings_backend_init+0x7e>
		return rc;
	}

	rc = flash_area_get_sectors(SETTINGS_PARTITION, &sector_cnt,
 100596c:	2004      	movs	r0, #4
 100596e:	aa02      	add	r2, sp, #8
 1005970:	a901      	add	r1, sp, #4
 1005972:	f7ff fdbf 	bl	10054f4 <flash_area_get_sectors>
				    &hw_flash_sector);
	if (rc == -ENODEV) {
 1005976:	f110 0f13 	cmn.w	r0, #19
	rc = flash_area_get_sectors(SETTINGS_PARTITION, &sector_cnt,
 100597a:	4604      	mov	r4, r0
	if (rc == -ENODEV) {
 100597c:	d02b      	beq.n	10059d6 <settings_backend_init+0x7e>
		return rc;
	} else if (rc != 0 && rc != -ENOMEM) {
 100597e:	b138      	cbz	r0, 1005990 <settings_backend_init+0x38>
 1005980:	340c      	adds	r4, #12
 1005982:	d005      	beq.n	1005990 <settings_backend_init+0x38>
		k_panic();
 1005984:	4040      	eors	r0, r0
 1005986:	f380 8811 	msr	BASEPRI, r0
 100598a:	f04f 0004 	mov.w	r0, #4
 100598e:	df02      	svc	2
	}

	nvs_sector_size = CONFIG_SETTINGS_NVS_SECTOR_SIZE_MULT *
 1005990:	9903      	ldr	r1, [sp, #12]
			  hw_flash_sector.fs_size;

	if (nvs_sector_size > UINT16_MAX) {
 1005992:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
 1005996:	d223      	bcs.n	10059e0 <settings_backend_init+0x88>
		return -EDOM;
	}

	while (cnt < CONFIG_SETTINGS_NVS_SECTOR_COUNT) {
		nvs_size += nvs_sector_size;
		if (nvs_size > fa->fa_size) {
 1005998:	2300      	movs	r3, #0
	size_t nvs_sector_size, nvs_size = 0;
 100599a:	4618      	mov	r0, r3
		if (nvs_size > fa->fa_size) {
 100599c:	9a00      	ldr	r2, [sp, #0]
 100599e:	6894      	ldr	r4, [r2, #8]
		nvs_size += nvs_sector_size;
 10059a0:	4408      	add	r0, r1
		if (nvs_size > fa->fa_size) {
 10059a2:	4284      	cmp	r4, r0
 10059a4:	d31a      	bcc.n	10059dc <settings_backend_init+0x84>
	while (cnt < CONFIG_SETTINGS_NVS_SECTOR_COUNT) {
 10059a6:	3301      	adds	r3, #1
 10059a8:	2b08      	cmp	r3, #8
 10059aa:	d1f9      	bne.n	10059a0 <settings_backend_init+0x48>
		}
		cnt++;
	}

	/* define the nvs file system using the page_info */
	default_settings_nvs.cf_nvs.sector_size = nvs_sector_size;
 10059ac:	4d0e      	ldr	r5, [pc, #56]	; (10059e8 <settings_backend_init+0x90>)
 10059ae:	82a9      	strh	r1, [r5, #20]
	default_settings_nvs.cf_nvs.sector_count = cnt;
 10059b0:	82eb      	strh	r3, [r5, #22]
	default_settings_nvs.cf_nvs.offset = fa->fa_off;
 10059b2:	6853      	ldr	r3, [r2, #4]
	default_settings_nvs.flash_dev = fa->fa_dev;

	rc = settings_nvs_backend_init(&default_settings_nvs);
 10059b4:	4628      	mov	r0, r5
	default_settings_nvs.cf_nvs.offset = fa->fa_off;
 10059b6:	60ab      	str	r3, [r5, #8]
	default_settings_nvs.flash_dev = fa->fa_dev;
 10059b8:	68d3      	ldr	r3, [r2, #12]
 10059ba:	63eb      	str	r3, [r5, #60]	; 0x3c
	rc = settings_nvs_backend_init(&default_settings_nvs);
 10059bc:	f01f fdb0 	bl	1025520 <settings_nvs_backend_init>
	if (rc) {
 10059c0:	4604      	mov	r4, r0
 10059c2:	b940      	cbnz	r0, 10059d6 <settings_backend_init+0x7e>
	cf->cf_store.cs_itf = &settings_nvs_itf;
 10059c4:	4e09      	ldr	r6, [pc, #36]	; (10059ec <settings_backend_init+0x94>)
	settings_src_register(&cf->cf_store);
 10059c6:	4628      	mov	r0, r5
	cf->cf_store.cs_itf = &settings_nvs_itf;
 10059c8:	606e      	str	r6, [r5, #4]
	settings_src_register(&cf->cf_store);
 10059ca:	f7ff fde9 	bl	10055a0 <settings_src_register>
	settings_dst_register(&cf->cf_store);
 10059ce:	4628      	mov	r0, r5
	cf->cf_store.cs_itf = &settings_nvs_itf;
 10059d0:	606e      	str	r6, [r5, #4]
	settings_dst_register(&cf->cf_store);
 10059d2:	f7ff fdf3 	bl	10055bc <settings_dst_register>
	}

	rc = settings_nvs_dst(&default_settings_nvs);

	return rc;
}
 10059d6:	4620      	mov	r0, r4
 10059d8:	b004      	add	sp, #16
 10059da:	bd70      	pop	{r4, r5, r6, pc}
 10059dc:	b29b      	uxth	r3, r3
 10059de:	e7e5      	b.n	10059ac <settings_backend_init+0x54>
		return -EDOM;
 10059e0:	f06f 0420 	mvn.w	r4, #32
 10059e4:	e7f7      	b.n	10059d6 <settings_backend_init+0x7e>
 10059e6:	bf00      	nop
 10059e8:	21004624 	.word	0x21004624
 10059ec:	2100027c 	.word	0x2100027c

010059f0 <nus_ccc_cfg_changed>:
static struct bt_nus_cb nus_cb;

static void nus_ccc_cfg_changed(const struct bt_gatt_attr *attr,
				  uint16_t value)
{
	if (nus_cb.send_enabled) {
 10059f0:	4b03      	ldr	r3, [pc, #12]	; (1005a00 <nus_ccc_cfg_changed+0x10>)
 10059f2:	689b      	ldr	r3, [r3, #8]
 10059f4:	b11b      	cbz	r3, 10059fe <nus_ccc_cfg_changed+0xe>
		LOG_DBG("Notification has been turned %s",
			value == BT_GATT_CCC_NOTIFY ? "on" : "off");
		nus_cb.send_enabled(value == BT_GATT_CCC_NOTIFY ?
 10059f6:	1e48      	subs	r0, r1, #1
 10059f8:	bf18      	it	ne
 10059fa:	2001      	movne	r0, #1
 10059fc:	4718      	bx	r3
			BT_NUS_SEND_STATUS_ENABLED : BT_NUS_SEND_STATUS_DISABLED);
	}
}
 10059fe:	4770      	bx	lr
 1005a00:	21004664 	.word	0x21004664

01005a04 <on_receive>:
			  const struct bt_gatt_attr *attr,
			  const void *buf,
			  uint16_t len,
			  uint16_t offset,
			  uint8_t flags)
{
 1005a04:	b510      	push	{r4, lr}
 1005a06:	461c      	mov	r4, r3
	LOG_DBG("Received data, handle %d, conn %p",
		attr->handle, (void *)conn);

	if (nus_cb.received) {
 1005a08:	4b03      	ldr	r3, [pc, #12]	; (1005a18 <on_receive+0x14>)
{
 1005a0a:	4611      	mov	r1, r2
	if (nus_cb.received) {
 1005a0c:	681b      	ldr	r3, [r3, #0]
 1005a0e:	b10b      	cbz	r3, 1005a14 <on_receive+0x10>
		nus_cb.received(conn, buf, len);
 1005a10:	4622      	mov	r2, r4
 1005a12:	4798      	blx	r3
}
	return len;
}
 1005a14:	4620      	mov	r0, r4
 1005a16:	bd10      	pop	{r4, pc}
 1005a18:	21004664 	.word	0x21004664

01005a1c <on_sent>:
{
	ARG_UNUSED(user_data);

	LOG_DBG("Data send, conn %p", (void *)conn);

	if (nus_cb.sent) {
 1005a1c:	4b02      	ldr	r3, [pc, #8]	; (1005a28 <on_sent+0xc>)
 1005a1e:	685b      	ldr	r3, [r3, #4]
 1005a20:	b103      	cbz	r3, 1005a24 <on_sent+0x8>
		nus_cb.sent(conn);
 1005a22:	4718      	bx	r3
	}
}
 1005a24:	4770      	bx	lr
 1005a26:	bf00      	nop
 1005a28:	21004664 	.word	0x21004664

01005a2c <bt_nus_init>:
			       NULL, on_receive, NULL),
);

int bt_nus_init(struct bt_nus_cb *callbacks)
{
	if (callbacks) {
 1005a2c:	b130      	cbz	r0, 1005a3c <bt_nus_init+0x10>
		nus_cb.received = callbacks->received;
 1005a2e:	4b04      	ldr	r3, [pc, #16]	; (1005a40 <bt_nus_init+0x14>)
 1005a30:	6802      	ldr	r2, [r0, #0]
 1005a32:	601a      	str	r2, [r3, #0]
		nus_cb.sent = callbacks->sent;
 1005a34:	6842      	ldr	r2, [r0, #4]
 1005a36:	605a      	str	r2, [r3, #4]
		nus_cb.send_enabled = callbacks->send_enabled;
 1005a38:	6882      	ldr	r2, [r0, #8]
 1005a3a:	609a      	str	r2, [r3, #8]
	}

	return 0;
}
 1005a3c:	2000      	movs	r0, #0
 1005a3e:	4770      	bx	lr
 1005a40:	21004664 	.word	0x21004664

01005a44 <bt_nus_send>:

int bt_nus_send(struct bt_conn *conn, const uint8_t *data, uint16_t len)
{
 1005a44:	b570      	push	{r4, r5, r6, lr}
 1005a46:	460e      	mov	r6, r1
 1005a48:	4615      	mov	r5, r2
 1005a4a:	4604      	mov	r4, r0
 1005a4c:	b086      	sub	sp, #24
	struct bt_gatt_notify_params params = {0};
 1005a4e:	2100      	movs	r1, #0
 1005a50:	2218      	movs	r2, #24
 1005a52:	4668      	mov	r0, sp
 1005a54:	f020 ff99 	bl	102698a <memset>
	const struct bt_gatt_attr *attr = &nus_svc.attrs[2];

	params.attr = attr;
 1005a58:	490b      	ldr	r1, [pc, #44]	; (1005a88 <bt_nus_send+0x44>)
	params.data = data;
	params.len = len;
	params.func = on_sent;
 1005a5a:	4b0c      	ldr	r3, [pc, #48]	; (1005a8c <bt_nus_send+0x48>)
	params.data = data;
 1005a5c:	e9cd 1601 	strd	r1, r6, [sp, #4]
	params.len = len;
 1005a60:	f8ad 500c 	strh.w	r5, [sp, #12]
	params.func = on_sent;
 1005a64:	9304      	str	r3, [sp, #16]

	if (!conn) {
 1005a66:	b92c      	cbnz	r4, 1005a74 <bt_nus_send+0x30>
		LOG_DBG("Notification send to all connected peers");
		return bt_gatt_notify_cb(NULL, &params);
	} else if (bt_gatt_is_subscribed(conn, attr, BT_GATT_CCC_NOTIFY)) {
		return bt_gatt_notify_cb(conn, &params);
 1005a68:	4669      	mov	r1, sp
 1005a6a:	4620      	mov	r0, r4
 1005a6c:	f008 fe42 	bl	100e6f4 <bt_gatt_notify_cb>
	} else {
		return -EINVAL;
	}
}
 1005a70:	b006      	add	sp, #24
 1005a72:	bd70      	pop	{r4, r5, r6, pc}
	} else if (bt_gatt_is_subscribed(conn, attr, BT_GATT_CCC_NOTIFY)) {
 1005a74:	2201      	movs	r2, #1
 1005a76:	4620      	mov	r0, r4
 1005a78:	f008 fb02 	bl	100e080 <bt_gatt_is_subscribed>
 1005a7c:	2800      	cmp	r0, #0
 1005a7e:	d1f3      	bne.n	1005a68 <bt_nus_send+0x24>
		return -EINVAL;
 1005a80:	f06f 0015 	mvn.w	r0, #21
 1005a84:	e7f4      	b.n	1005a70 <bt_nus_send+0x2c>
 1005a86:	bf00      	nop
 1005a88:	01029c9c 	.word	0x01029c9c
 1005a8c:	01005a1d 	.word	0x01005a1d

01005a90 <uECC_get_rng>:
}

uECC_RNG_Function uECC_get_rng(void)
{
	return g_rng_function;
}
 1005a90:	4b01      	ldr	r3, [pc, #4]	; (1005a98 <uECC_get_rng+0x8>)
 1005a92:	6818      	ldr	r0, [r3, #0]
 1005a94:	4770      	bx	lr
 1005a96:	bf00      	nop
 1005a98:	21000300 	.word	0x21000300

01005a9c <vli_mmod_fast_secp256r1>:
{
	unsigned int tmp[NUM_ECC_WORDS];
	int carry;

	/* t */
	uECC_vli_set(result, product, NUM_ECC_WORDS);
 1005a9c:	2208      	movs	r2, #8
{
 1005a9e:	b5f0      	push	{r4, r5, r6, r7, lr}
 1005aa0:	b089      	sub	sp, #36	; 0x24
	uECC_vli_set(result, product, NUM_ECC_WORDS);
 1005aa2:	f01f ff12 	bl	10258ca <uECC_vli_set>

	/* s1 */
	tmp[0] = tmp[1] = tmp[2] = 0;
	tmp[3] = product[11];
 1005aa6:	6acb      	ldr	r3, [r1, #44]	; 0x2c
	tmp[0] = tmp[1] = tmp[2] = 0;
 1005aa8:	2700      	movs	r7, #0
	tmp[3] = product[11];
 1005aaa:	9303      	str	r3, [sp, #12]
	tmp[4] = product[12];
 1005aac:	6b0b      	ldr	r3, [r1, #48]	; 0x30
{
 1005aae:	460c      	mov	r4, r1
	tmp[4] = product[12];
 1005ab0:	9304      	str	r3, [sp, #16]
	tmp[5] = product[13];
 1005ab2:	6b4b      	ldr	r3, [r1, #52]	; 0x34
{
 1005ab4:	4606      	mov	r6, r0
	tmp[5] = product[13];
 1005ab6:	9305      	str	r3, [sp, #20]
	tmp[6] = product[14];
 1005ab8:	6b8b      	ldr	r3, [r1, #56]	; 0x38
	tmp[0] = tmp[1] = tmp[2] = 0;
 1005aba:	e9cd 7701 	strd	r7, r7, [sp, #4]
	tmp[6] = product[14];
 1005abe:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
 1005ac0:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
	tmp[0] = tmp[1] = tmp[2] = 0;
 1005ac2:	9700      	str	r7, [sp, #0]
	tmp[7] = product[15];
 1005ac4:	9307      	str	r3, [sp, #28]
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1005ac6:	4613      	mov	r3, r2
 1005ac8:	466a      	mov	r2, sp
 1005aca:	4611      	mov	r1, r2
 1005acc:	4610      	mov	r0, r2
 1005ace:	f01f fe0c 	bl	10256ea <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1005ad2:	4631      	mov	r1, r6
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1005ad4:	4605      	mov	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1005ad6:	4630      	mov	r0, r6
 1005ad8:	f01f fe07 	bl	10256ea <uECC_vli_add>

	/* s2 */
	tmp[3] = product[12];
 1005adc:	6b21      	ldr	r1, [r4, #48]	; 0x30
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1005ade:	4405      	add	r5, r0
	tmp[3] = product[12];
 1005ae0:	9103      	str	r1, [sp, #12]
	tmp[4] = product[13];
 1005ae2:	6b61      	ldr	r1, [r4, #52]	; 0x34
	tmp[5] = product[14];
	tmp[6] = product[15];
	tmp[7] = 0;
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1005ae4:	4610      	mov	r0, r2
	tmp[4] = product[13];
 1005ae6:	9104      	str	r1, [sp, #16]
	tmp[5] = product[14];
 1005ae8:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 1005aea:	9105      	str	r1, [sp, #20]
	tmp[6] = product[15];
 1005aec:	6be1      	ldr	r1, [r4, #60]	; 0x3c
	tmp[7] = 0;
 1005aee:	e9cd 1706 	strd	r1, r7, [sp, #24]
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1005af2:	4611      	mov	r1, r2
 1005af4:	f01f fdf9 	bl	10256ea <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1005af8:	4631      	mov	r1, r6
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1005afa:	4405      	add	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1005afc:	4630      	mov	r0, r6
 1005afe:	f01f fdf4 	bl	10256ea <uECC_vli_add>
 1005b02:	4405      	add	r5, r0

	/* s3 */
	tmp[0] = product[8];
 1005b04:	6a20      	ldr	r0, [r4, #32]
	tmp[1] = product[9];
	tmp[2] = product[10];
	tmp[3] = tmp[4] = tmp[5] = 0;
 1005b06:	e9cd 7704 	strd	r7, r7, [sp, #16]
	tmp[0] = product[8];
 1005b0a:	9000      	str	r0, [sp, #0]
	tmp[1] = product[9];
 1005b0c:	6a60      	ldr	r0, [r4, #36]	; 0x24
	tmp[3] = tmp[4] = tmp[5] = 0;
 1005b0e:	9703      	str	r7, [sp, #12]
	tmp[1] = product[9];
 1005b10:	9001      	str	r0, [sp, #4]
	tmp[2] = product[10];
 1005b12:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 1005b14:	9002      	str	r0, [sp, #8]
	tmp[6] = product[14];
 1005b16:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 1005b18:	9006      	str	r0, [sp, #24]
	tmp[7] = product[15];
 1005b1a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 1005b1c:	9007      	str	r0, [sp, #28]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1005b1e:	4630      	mov	r0, r6
 1005b20:	f01f fde3 	bl	10256ea <uECC_vli_add>
 1005b24:	4405      	add	r5, r0

	/* s4 */
	tmp[0] = product[9];
 1005b26:	6a60      	ldr	r0, [r4, #36]	; 0x24
	tmp[1] = product[10];
	tmp[2] = product[11];
	tmp[3] = product[13];
	tmp[4] = product[14];
 1005b28:	f8d4 c038 	ldr.w	ip, [r4, #56]	; 0x38
	tmp[0] = product[9];
 1005b2c:	9000      	str	r0, [sp, #0]
	tmp[1] = product[10];
 1005b2e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	tmp[4] = product[14];
 1005b30:	f8cd c010 	str.w	ip, [sp, #16]
	tmp[1] = product[10];
 1005b34:	9001      	str	r0, [sp, #4]
	tmp[2] = product[11];
 1005b36:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
	tmp[5] = product[15];
 1005b38:	f8d4 c03c 	ldr.w	ip, [r4, #60]	; 0x3c
	tmp[2] = product[11];
 1005b3c:	9002      	str	r0, [sp, #8]
	tmp[3] = product[13];
 1005b3e:	6b60      	ldr	r0, [r4, #52]	; 0x34
	tmp[6] = product[13];
 1005b40:	e9cd c005 	strd	ip, r0, [sp, #20]
	tmp[3] = product[13];
 1005b44:	9003      	str	r0, [sp, #12]
	tmp[7] = product[8];
 1005b46:	6a20      	ldr	r0, [r4, #32]
 1005b48:	9007      	str	r0, [sp, #28]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1005b4a:	4630      	mov	r0, r6
 1005b4c:	f01f fdcd 	bl	10256ea <uECC_vli_add>
 1005b50:	4405      	add	r5, r0

	/* d1 */
	tmp[0] = product[11];
 1005b52:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
	tmp[1] = product[12];
	tmp[2] = product[13];
	tmp[3] = tmp[4] = tmp[5] = 0;
 1005b54:	e9cd 7704 	strd	r7, r7, [sp, #16]
	tmp[0] = product[11];
 1005b58:	9000      	str	r0, [sp, #0]
	tmp[1] = product[12];
 1005b5a:	6b20      	ldr	r0, [r4, #48]	; 0x30
	tmp[3] = tmp[4] = tmp[5] = 0;
 1005b5c:	9703      	str	r7, [sp, #12]
	tmp[1] = product[12];
 1005b5e:	9001      	str	r0, [sp, #4]
	tmp[2] = product[13];
 1005b60:	6b60      	ldr	r0, [r4, #52]	; 0x34
 1005b62:	9002      	str	r0, [sp, #8]
	tmp[6] = product[8];
 1005b64:	6a20      	ldr	r0, [r4, #32]
 1005b66:	9006      	str	r0, [sp, #24]
	tmp[7] = product[10];
 1005b68:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 1005b6a:	9007      	str	r0, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1005b6c:	4630      	mov	r0, r6
 1005b6e:	f01f fedf 	bl	1025930 <uECC_vli_sub>

	/* d2 */
	tmp[0] = product[12];
 1005b72:	6b23      	ldr	r3, [r4, #48]	; 0x30
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1005b74:	1a2d      	subs	r5, r5, r0
	tmp[0] = product[12];
 1005b76:	9300      	str	r3, [sp, #0]
	tmp[1] = product[13];
 1005b78:	6b63      	ldr	r3, [r4, #52]	; 0x34
	tmp[2] = product[14];
	tmp[3] = product[15];
	tmp[4] = tmp[5] = 0;
	tmp[6] = product[9];
	tmp[7] = product[11];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1005b7a:	4630      	mov	r0, r6
	tmp[1] = product[13];
 1005b7c:	9301      	str	r3, [sp, #4]
	tmp[2] = product[14];
 1005b7e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 1005b80:	9302      	str	r3, [sp, #8]
	tmp[3] = product[15];
 1005b82:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 1005b84:	9303      	str	r3, [sp, #12]
	tmp[6] = product[9];
 1005b86:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1005b88:	9306      	str	r3, [sp, #24]
	tmp[7] = product[11];
 1005b8a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 1005b8c:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1005b8e:	2308      	movs	r3, #8
 1005b90:	f01f fece 	bl	1025930 <uECC_vli_sub>

	/* d3 */
	tmp[0] = product[13];
 1005b94:	6b63      	ldr	r3, [r4, #52]	; 0x34
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1005b96:	1a2d      	subs	r5, r5, r0
	tmp[0] = product[13];
 1005b98:	9300      	str	r3, [sp, #0]
	tmp[1] = product[14];
 1005b9a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	tmp[3] = product[8];
	tmp[4] = product[9];
	tmp[5] = product[10];
	tmp[6] = 0;
	tmp[7] = product[12];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1005b9c:	4630      	mov	r0, r6
	tmp[1] = product[14];
 1005b9e:	9301      	str	r3, [sp, #4]
	tmp[2] = product[15];
 1005ba0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 1005ba2:	9302      	str	r3, [sp, #8]
	tmp[3] = product[8];
 1005ba4:	6a23      	ldr	r3, [r4, #32]
 1005ba6:	9303      	str	r3, [sp, #12]
	tmp[4] = product[9];
 1005ba8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1005baa:	9304      	str	r3, [sp, #16]
	tmp[5] = product[10];
 1005bac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[6] = 0;
 1005bae:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[12];
 1005bb2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 1005bb4:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1005bb6:	2308      	movs	r3, #8
 1005bb8:	f01f feba 	bl	1025930 <uECC_vli_sub>

	/* d4 */
	tmp[0] = product[14];
 1005bbc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1005bbe:	1a2d      	subs	r5, r5, r0
	tmp[0] = product[14];
 1005bc0:	9300      	str	r3, [sp, #0]
	tmp[1] = product[15];
 1005bc2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[3] = product[9];
	tmp[4] = product[10];
	tmp[5] = product[11];
	tmp[6] = 0;
	tmp[7] = product[13];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1005bc4:	4630      	mov	r0, r6
	tmp[2] = 0;
 1005bc6:	e9cd 3701 	strd	r3, r7, [sp, #4]
	tmp[3] = product[9];
 1005bca:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1005bcc:	9303      	str	r3, [sp, #12]
	tmp[4] = product[10];
 1005bce:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1005bd0:	9304      	str	r3, [sp, #16]
	tmp[5] = product[11];
 1005bd2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 1005bd4:	9305      	str	r3, [sp, #20]
	tmp[7] = product[13];
 1005bd6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 1005bd8:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1005bda:	2308      	movs	r3, #8
 1005bdc:	f01f fea8 	bl	1025930 <uECC_vli_sub>

	if (carry < 0) {
 1005be0:	1a2d      	subs	r5, r5, r0
 1005be2:	d410      	bmi.n	1005c06 <vli_mmod_fast_secp256r1+0x16a>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
		}
		while (carry < 0);
	} else  {
		while (carry || 
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
 1005be4:	4c0d      	ldr	r4, [pc, #52]	; (1005c1c <vli_mmod_fast_secp256r1+0x180>)
		while (carry || 
 1005be6:	b935      	cbnz	r5, 1005bf6 <vli_mmod_fast_secp256r1+0x15a>
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
 1005be8:	2208      	movs	r2, #8
 1005bea:	4631      	mov	r1, r6
 1005bec:	4620      	mov	r0, r4
 1005bee:	f01f fe78 	bl	10258e2 <uECC_vli_cmp_unsafe>
		while (carry || 
 1005bf2:	2801      	cmp	r0, #1
 1005bf4:	d00f      	beq.n	1005c16 <vli_mmod_fast_secp256r1+0x17a>
			carry -= uECC_vli_sub(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
 1005bf6:	2308      	movs	r3, #8
 1005bf8:	4622      	mov	r2, r4
 1005bfa:	4631      	mov	r1, r6
 1005bfc:	4630      	mov	r0, r6
 1005bfe:	f01f fe97 	bl	1025930 <uECC_vli_sub>
 1005c02:	1a2d      	subs	r5, r5, r0
 1005c04:	e7ef      	b.n	1005be6 <vli_mmod_fast_secp256r1+0x14a>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
 1005c06:	4a05      	ldr	r2, [pc, #20]	; (1005c1c <vli_mmod_fast_secp256r1+0x180>)
 1005c08:	2308      	movs	r3, #8
 1005c0a:	4631      	mov	r1, r6
 1005c0c:	4630      	mov	r0, r6
 1005c0e:	f01f fd6c 	bl	10256ea <uECC_vli_add>
		while (carry < 0);
 1005c12:	182d      	adds	r5, r5, r0
 1005c14:	d4f8      	bmi.n	1005c08 <vli_mmod_fast_secp256r1+0x16c>
		}
	}
}
 1005c16:	b009      	add	sp, #36	; 0x24
 1005c18:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1005c1a:	bf00      	nop
 1005c1c:	01029cf0 	.word	0x01029cf0

01005c20 <sub_bytes>:
static inline void sub_bytes(uint8_t *s)
{
	unsigned int i;

	for (i = 0; i < (Nb * Nk); ++i) {
		s[i] = sbox[s[i]];
 1005c20:	4904      	ldr	r1, [pc, #16]	; (1005c34 <sub_bytes+0x14>)
 1005c22:	1e43      	subs	r3, r0, #1
 1005c24:	300f      	adds	r0, #15
 1005c26:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 1005c2a:	5c8a      	ldrb	r2, [r1, r2]
	for (i = 0; i < (Nb * Nk); ++i) {
 1005c2c:	4283      	cmp	r3, r0
		s[i] = sbox[s[i]];
 1005c2e:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < (Nb * Nk); ++i) {
 1005c30:	d1f9      	bne.n	1005c26 <sub_bytes+0x6>
	}
}
 1005c32:	4770      	bx	lr
 1005c34:	0102c2ca 	.word	0x0102c2ca

01005c38 <tc_aes128_set_encrypt_key>:
{
 1005c38:	b5f0      	push	{r4, r5, r6, r7, lr}
 1005c3a:	4607      	mov	r7, r0
	const unsigned int rconst[11] = {
 1005c3c:	4e26      	ldr	r6, [pc, #152]	; (1005cd8 <tc_aes128_set_encrypt_key+0xa0>)
{
 1005c3e:	b08d      	sub	sp, #52	; 0x34
	const unsigned int rconst[11] = {
 1005c40:	ad01      	add	r5, sp, #4
{
 1005c42:	460c      	mov	r4, r1
	const unsigned int rconst[11] = {
 1005c44:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 1005c46:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 1005c48:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 1005c4a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 1005c4c:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 1005c50:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	if (s == (TCAesKeySched_t) 0) {
 1005c54:	4638      	mov	r0, r7
 1005c56:	2f00      	cmp	r7, #0
 1005c58:	d039      	beq.n	1005cce <tc_aes128_set_encrypt_key+0x96>
	} else if (k == (const uint8_t *) 0) {
 1005c5a:	2c00      	cmp	r4, #0
 1005c5c:	d039      	beq.n	1005cd2 <tc_aes128_set_encrypt_key+0x9a>
 1005c5e:	1f38      	subs	r0, r7, #4
 1005c60:	4602      	mov	r2, r0
 1005c62:	4621      	mov	r1, r4
 1005c64:	3410      	adds	r4, #16
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
 1005c66:	784b      	ldrb	r3, [r1, #1]
 1005c68:	780d      	ldrb	r5, [r1, #0]
 1005c6a:	041b      	lsls	r3, r3, #16
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
 1005c6c:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
 1005c70:	78cd      	ldrb	r5, [r1, #3]
	for (i = 0; i < Nk; ++i) {
 1005c72:	3104      	adds	r1, #4
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
 1005c74:	432b      	orrs	r3, r5
 1005c76:	f811 5c02 	ldrb.w	r5, [r1, #-2]
	for (i = 0; i < Nk; ++i) {
 1005c7a:	428c      	cmp	r4, r1
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
 1005c7c:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
 1005c80:	f842 3f04 	str.w	r3, [r2, #4]!
	for (i = 0; i < Nk; ++i) {
 1005c84:	d1ef      	bne.n	1005c66 <tc_aes128_set_encrypt_key+0x2e>
 1005c86:	2104      	movs	r1, #4
			t = subword(rotword(t)) ^ rconst[i/Nk];
 1005c88:	4c14      	ldr	r4, [pc, #80]	; (1005cdc <tc_aes128_set_encrypt_key+0xa4>)
		if ((i % Nk) == 0) {
 1005c8a:	078a      	lsls	r2, r1, #30
		t = s->words[i-1];
 1005c8c:	6903      	ldr	r3, [r0, #16]
		if ((i % Nk) == 0) {
 1005c8e:	d116      	bne.n	1005cbe <tc_aes128_set_encrypt_key+0x86>
			t = subword(rotword(t)) ^ rconst[i/Nk];
 1005c90:	f3c3 4207 	ubfx	r2, r3, #16, #8
 1005c94:	5ca5      	ldrb	r5, [r4, r2]
 1005c96:	0e1a      	lsrs	r2, r3, #24
 1005c98:	5ca2      	ldrb	r2, [r4, r2]
 1005c9a:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
 1005c9e:	f3c3 2507 	ubfx	r5, r3, #8, #8
 1005ca2:	5d65      	ldrb	r5, [r4, r5]
 1005ca4:	b2db      	uxtb	r3, r3
 1005ca6:	5ce3      	ldrb	r3, [r4, r3]
 1005ca8:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
 1005cac:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 1005cb0:	f021 0303 	bic.w	r3, r1, #3
 1005cb4:	3330      	adds	r3, #48	; 0x30
 1005cb6:	446b      	add	r3, sp
 1005cb8:	f853 3c2c 	ldr.w	r3, [r3, #-44]
 1005cbc:	4053      	eors	r3, r2
		s->words[i] = s->words[i-Nk] ^ t;
 1005cbe:	f850 2f04 	ldr.w	r2, [r0, #4]!
	for (; i < (Nb * (Nr + 1)); ++i) {
 1005cc2:	3101      	adds	r1, #1
		s->words[i] = s->words[i-Nk] ^ t;
 1005cc4:	4053      	eors	r3, r2
	for (; i < (Nb * (Nr + 1)); ++i) {
 1005cc6:	292c      	cmp	r1, #44	; 0x2c
		s->words[i] = s->words[i-Nk] ^ t;
 1005cc8:	6103      	str	r3, [r0, #16]
	for (; i < (Nb * (Nr + 1)); ++i) {
 1005cca:	d1de      	bne.n	1005c8a <tc_aes128_set_encrypt_key+0x52>
	return TC_CRYPTO_SUCCESS;
 1005ccc:	2001      	movs	r0, #1
}
 1005cce:	b00d      	add	sp, #52	; 0x34
 1005cd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
 1005cd2:	4620      	mov	r0, r4
 1005cd4:	e7fb      	b.n	1005cce <tc_aes128_set_encrypt_key+0x96>
 1005cd6:	bf00      	nop
 1005cd8:	01029b14 	.word	0x01029b14
 1005cdc:	0102c2ca 	.word	0x0102c2ca

01005ce0 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
 1005ce0:	4901      	ldr	r1, [pc, #4]	; (1005ce8 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
 1005ce2:	2210      	movs	r2, #16
	str	r2, [r1]
 1005ce4:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
 1005ce6:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
 1005ce8:	e000ed10 	.word	0xe000ed10

01005cec <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
 1005cec:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
 1005cee:	4040      	eors	r0, r0
	msr	BASEPRI, r0
 1005cf0:	f380 8811 	msr	BASEPRI, r0
	isb
 1005cf4:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
 1005cf8:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
 1005cfc:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
 1005cfe:	b662      	cpsie	i
	isb
 1005d00:	f3bf 8f6f 	isb	sy

	bx	lr
 1005d04:	4770      	bx	lr
 1005d06:	bf00      	nop

01005d08 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
 1005d08:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
 1005d0a:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
 1005d0c:	f381 8811 	msr	BASEPRI, r1

	wfe
 1005d10:	bf20      	wfe

	msr	BASEPRI, r0
 1005d12:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
 1005d16:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
 1005d18:	4770      	bx	lr
 1005d1a:	bf00      	nop

01005d1c <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
 1005d1c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1005d20:	4681      	mov	r9, r0

	if (esf != NULL) {
 1005d22:	460c      	mov	r4, r1
{
 1005d24:	af00      	add	r7, sp, #0
	if (esf != NULL) {
 1005d26:	2900      	cmp	r1, #0
 1005d28:	d04c      	beq.n	1005dc4 <z_arm_fatal_error+0xa8>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
 1005d2a:	e9d1 1200 	ldrd	r1, r2, [r1]
 1005d2e:	466e      	mov	r6, sp
 1005d30:	b08a      	sub	sp, #40	; 0x28
 1005d32:	68a3      	ldr	r3, [r4, #8]
 1005d34:	466d      	mov	r5, sp
 1005d36:	f04f 0a05 	mov.w	sl, #5
 1005d3a:	46a8      	mov	r8, r5
 1005d3c:	4825      	ldr	r0, [pc, #148]	; (1005dd4 <z_arm_fatal_error+0xb8>)
 1005d3e:	e9c5 2307 	strd	r2, r3, [r5, #28]
 1005d42:	e9c5 0105 	strd	r0, r1, [r5, #20]
 1005d46:	f848 af10 	str.w	sl, [r8, #16]!
 1005d4a:	2300      	movs	r3, #0
 1005d4c:	4642      	mov	r2, r8
 1005d4e:	f44f 5121 	mov.w	r1, #10304	; 0x2840
 1005d52:	4821      	ldr	r0, [pc, #132]	; (1005dd8 <z_arm_fatal_error+0xbc>)
 1005d54:	f7fe fcd8 	bl	1004708 <z_impl_z_log_msg_static_create>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
 1005d58:	e9d4 1203 	ldrd	r1, r2, [r4, #12]
 1005d5c:	46b5      	mov	sp, r6
 1005d5e:	6963      	ldr	r3, [r4, #20]
 1005d60:	46ad      	mov	sp, r5
 1005d62:	481e      	ldr	r0, [pc, #120]	; (1005ddc <z_arm_fatal_error+0xc0>)
 1005d64:	e9c5 2307 	strd	r2, r3, [r5, #28]
 1005d68:	e9c5 0105 	strd	r0, r1, [r5, #20]
 1005d6c:	f8c5 a010 	str.w	sl, [r5, #16]
 1005d70:	2300      	movs	r3, #0
 1005d72:	4642      	mov	r2, r8
 1005d74:	f44f 5121 	mov.w	r1, #10304	; 0x2840
 1005d78:	4817      	ldr	r0, [pc, #92]	; (1005dd8 <z_arm_fatal_error+0xbc>)
 1005d7a:	f7fe fcc5 	bl	1004708 <z_impl_z_log_msg_static_create>
 1005d7e:	46b5      	mov	sp, r6
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
 1005d80:	b088      	sub	sp, #32
 1005d82:	69e3      	ldr	r3, [r4, #28]
 1005d84:	466d      	mov	r5, sp
 1005d86:	f04f 0a03 	mov.w	sl, #3
 1005d8a:	46a8      	mov	r8, r5
 1005d8c:	4a14      	ldr	r2, [pc, #80]	; (1005de0 <z_arm_fatal_error+0xc4>)
 1005d8e:	e9c5 2305 	strd	r2, r3, [r5, #20]
 1005d92:	f848 af10 	str.w	sl, [r8, #16]!
 1005d96:	2300      	movs	r3, #0
 1005d98:	4642      	mov	r2, r8
 1005d9a:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1005d9e:	480e      	ldr	r0, [pc, #56]	; (1005dd8 <z_arm_fatal_error+0xbc>)
 1005da0:	f7fe fcb2 	bl	1004708 <z_impl_z_log_msg_static_create>
 1005da4:	46b5      	mov	sp, r6
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
 1005da6:	69a3      	ldr	r3, [r4, #24]
 1005da8:	46ad      	mov	sp, r5
 1005daa:	4a0e      	ldr	r2, [pc, #56]	; (1005de4 <z_arm_fatal_error+0xc8>)
 1005dac:	f8c5 a010 	str.w	sl, [r5, #16]
 1005db0:	e9c5 2305 	strd	r2, r3, [r5, #20]
 1005db4:	2300      	movs	r3, #0
 1005db6:	4642      	mov	r2, r8
 1005db8:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1005dbc:	4806      	ldr	r0, [pc, #24]	; (1005dd8 <z_arm_fatal_error+0xbc>)
 1005dbe:	f7fe fca3 	bl	1004708 <z_impl_z_log_msg_static_create>
 1005dc2:	46b5      	mov	sp, r6
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
 1005dc4:	4621      	mov	r1, r4
 1005dc6:	4648      	mov	r0, r9
 1005dc8:	f01a fcd4 	bl	1020774 <z_fatal_error>
}
 1005dcc:	46bd      	mov	sp, r7
 1005dce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1005dd2:	bf00      	nop
 1005dd4:	0102c3ca 	.word	0x0102c3ca
 1005dd8:	01029a54 	.word	0x01029a54
 1005ddc:	0102c3f9 	.word	0x0102c3f9
 1005de0:	0102c428 	.word	0x0102c428
 1005de4:	0102c437 	.word	0x0102c437

01005de8 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
 1005de8:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 1005dea:	2800      	cmp	r0, #0
 1005dec:	db07      	blt.n	1005dfe <arch_irq_enable+0x16>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1005dee:	2301      	movs	r3, #1
 1005df0:	0941      	lsrs	r1, r0, #5
 1005df2:	4a03      	ldr	r2, [pc, #12]	; (1005e00 <arch_irq_enable+0x18>)
 1005df4:	f000 001f 	and.w	r0, r0, #31
 1005df8:	4083      	lsls	r3, r0
 1005dfa:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 1005dfe:	4770      	bx	lr
 1005e00:	e000e100 	.word	0xe000e100

01005e04 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
 1005e04:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 1005e06:	2800      	cmp	r0, #0
 1005e08:	db0c      	blt.n	1005e24 <arch_irq_disable+0x20>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1005e0a:	2201      	movs	r2, #1
 1005e0c:	4906      	ldr	r1, [pc, #24]	; (1005e28 <arch_irq_disable+0x24>)
 1005e0e:	0943      	lsrs	r3, r0, #5
 1005e10:	f000 001f 	and.w	r0, r0, #31
 1005e14:	4082      	lsls	r2, r0
 1005e16:	3320      	adds	r3, #32
 1005e18:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 1005e1c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1005e20:	f3bf 8f6f 	isb	sy
}
 1005e24:	4770      	bx	lr
 1005e26:	bf00      	nop
 1005e28:	e000e100 	.word	0xe000e100

01005e2c <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
 1005e2c:	4b05      	ldr	r3, [pc, #20]	; (1005e44 <arch_irq_is_enabled+0x18>)
 1005e2e:	0942      	lsrs	r2, r0, #5
 1005e30:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 1005e34:	2301      	movs	r3, #1
 1005e36:	f000 001f 	and.w	r0, r0, #31
 1005e3a:	fa03 f000 	lsl.w	r0, r3, r0
}
 1005e3e:	4010      	ands	r0, r2
 1005e40:	4770      	bx	lr
 1005e42:	bf00      	nop
 1005e44:	e000e100 	.word	0xe000e100

01005e48 <z_arm_irq_priority_set>:
 * The priority is verified if ASSERT_ON is enabled. The maximum number
 * of priority levels is a little complex, as there are some hardware
 * priority levels which are reserved.
 */
void z_arm_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
 1005e48:	b538      	push	{r3, r4, r5, lr}
			prio = _EXC_ZERO_LATENCY_IRQS_PRIO;
		} else {
			/* Use caller supplied prio level as-is */
		}
	} else {
		prio += _IRQ_PRIO_OFFSET;
 1005e4a:	1c4b      	adds	r3, r1, #1
	/* The last priority level is also used by PendSV exception, but
	 * allow other interrupts to use the same level, even if it ends up
	 * affecting performance (can still be useful on systems with a
	 * reduced set of priorities, like Cortex-M0/M0+).
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
 1005e4c:	2b07      	cmp	r3, #7
{
 1005e4e:	4604      	mov	r4, r0
 1005e50:	460d      	mov	r5, r1
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
 1005e52:	d90f      	bls.n	1005e74 <z_arm_irq_priority_set+0x2c>
 1005e54:	235b      	movs	r3, #91	; 0x5b
 1005e56:	4a10      	ldr	r2, [pc, #64]	; (1005e98 <z_arm_irq_priority_set+0x50>)
 1005e58:	4910      	ldr	r1, [pc, #64]	; (1005e9c <z_arm_irq_priority_set+0x54>)
 1005e5a:	4811      	ldr	r0, [pc, #68]	; (1005ea0 <z_arm_irq_priority_set+0x58>)
 1005e5c:	f01e febb 	bl	1024bd6 <assert_print>
 1005e60:	4629      	mov	r1, r5
 1005e62:	4810      	ldr	r0, [pc, #64]	; (1005ea4 <z_arm_irq_priority_set+0x5c>)
 1005e64:	2307      	movs	r3, #7
 1005e66:	4622      	mov	r2, r4
 1005e68:	f01e feb5 	bl	1024bd6 <assert_print>
 1005e6c:	215b      	movs	r1, #91	; 0x5b
 1005e6e:	480a      	ldr	r0, [pc, #40]	; (1005e98 <z_arm_irq_priority_set+0x50>)
 1005e70:	f01e feaa 	bl	1024bc8 <assert_post_action>
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
 1005e74:	b240      	sxtb	r0, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 1005e76:	2800      	cmp	r0, #0
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1005e78:	bfac      	ite	ge
 1005e7a:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1005e7e:	4a0a      	ldrlt	r2, [pc, #40]	; (1005ea8 <z_arm_irq_priority_set+0x60>)
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1005e80:	ea4f 1343 	mov.w	r3, r3, lsl #5
 1005e84:	b2db      	uxtb	r3, r3
 1005e86:	bfab      	itete	ge
 1005e88:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1005e8c:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1005e90:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1005e94:	5413      	strblt	r3, [r2, r0]
}
 1005e96:	bd38      	pop	{r3, r4, r5, pc}
 1005e98:	0102c465 	.word	0x0102c465
 1005e9c:	0102c49b 	.word	0x0102c49b
 1005ea0:	0102b695 	.word	0x0102b695
 1005ea4:	0102c4b6 	.word	0x0102c4b6
 1005ea8:	e000ed14 	.word	0xe000ed14

01005eac <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
 1005eac:	bf30      	wfi
    b z_SysNmiOnReset
 1005eae:	f7ff bffd 	b.w	1005eac <z_SysNmiOnReset>
 1005eb2:	bf00      	nop

01005eb4 <z_arm_prep_c>:
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
 1005eb4:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
 1005eb6:	4b08      	ldr	r3, [pc, #32]	; (1005ed8 <z_arm_prep_c+0x24>)
 1005eb8:	4a08      	ldr	r2, [pc, #32]	; (1005edc <z_arm_prep_c+0x28>)
 1005eba:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 1005ebe:	6093      	str	r3, [r2, #8]
  __ASM volatile ("dsb 0xF":::"memory");
 1005ec0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1005ec4:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
 1005ec8:	f01a fd26 	bl	1020918 <z_bss_zero>
	z_data_copy();
 1005ecc:	f01d fc00 	bl	10236d0 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
 1005ed0:	f000 fbc0 	bl	1006654 <z_arm_interrupt_init>
	z_cstart();
 1005ed4:	f01a fd60 	bl	1020998 <z_cstart>
 1005ed8:	01000000 	.word	0x01000000
 1005edc:	e000ed00 	.word	0xe000ed00

01005ee0 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
 1005ee0:	4a09      	ldr	r2, [pc, #36]	; (1005f08 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
 1005ee2:	490a      	ldr	r1, [pc, #40]	; (1005f0c <arch_swap+0x2c>)
	_current->arch.basepri = key;
 1005ee4:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
 1005ee6:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
 1005ee8:	6798      	str	r0, [r3, #120]	; 0x78
	_current->arch.swap_return_value = _k_neg_eagain;
 1005eea:	67d9      	str	r1, [r3, #124]	; 0x7c

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 1005eec:	4908      	ldr	r1, [pc, #32]	; (1005f10 <arch_swap+0x30>)
 1005eee:	684b      	ldr	r3, [r1, #4]
 1005ef0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 1005ef4:	604b      	str	r3, [r1, #4]
 1005ef6:	2300      	movs	r3, #0
 1005ef8:	f383 8811 	msr	BASEPRI, r3
 1005efc:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
 1005f00:	6893      	ldr	r3, [r2, #8]
}
 1005f02:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
 1005f04:	4770      	bx	lr
 1005f06:	bf00      	nop
 1005f08:	210080cc 	.word	0x210080cc
 1005f0c:	0102b3d4 	.word	0x0102b3d4
 1005f10:	e000ed00 	.word	0xe000ed00

01005f14 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
 1005f14:	4913      	ldr	r1, [pc, #76]	; (1005f64 <z_arm_pendsv+0x50>)
    ldr r2, [r1, #_kernel_offset_to_current]
 1005f16:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
 1005f18:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
 1005f1c:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
 1005f1e:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
 1005f22:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 1005f26:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
 1005f28:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
 1005f2c:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
 1005f30:	4f0d      	ldr	r7, [pc, #52]	; (1005f68 <z_arm_pendsv+0x54>)
    ldr v3, =_SCS_ICSR_UNPENDSV
 1005f32:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
 1005f36:	698a      	ldr	r2, [r1, #24]

    str r2, [r1, #_kernel_offset_to_current]
 1005f38:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
 1005f3a:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
 1005f3c:	6f90      	ldr	r0, [r2, #120]	; 0x78
    movs r3, #0
 1005f3e:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
 1005f40:	6793      	str	r3, [r2, #120]	; 0x78
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
 1005f42:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
 1005f46:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
 1005f4a:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
 1005f4e:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
 1005f52:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
 1005f56:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
 1005f58:	f020 fc1c 	bl	1026794 <configure_builtin_stack_guard>
    pop {r2, lr}
 1005f5c:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
 1005f60:	4770      	bx	lr
 1005f62:	0000      	.short	0x0000
    ldr r1, =_kernel
 1005f64:	210080cc 	.word	0x210080cc
    ldr v4, =_SCS_ICSR
 1005f68:	e000ed04 	.word	0xe000ed04

01005f6c <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
 1005f6c:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
 1005f70:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
 1005f72:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
 1005f76:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
 1005f7a:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
 1005f7c:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
 1005f80:	2902      	cmp	r1, #2
    beq _oops
 1005f82:	d0ff      	beq.n	1005f84 <_oops>

01005f84 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
 1005f84:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
 1005f86:	f020 fbf6 	bl	1026776 <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
 1005f8a:	bd01      	pop	{r0, pc}

01005f8c <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
 1005f8c:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
 1005f90:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
 1005f92:	490b      	ldr	r1, [pc, #44]	; (1005fc0 <arch_new_thread+0x34>)
	iframe->a2 = (uint32_t)p1;
 1005f94:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
 1005f98:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
 1005f9a:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
 1005f9e:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
 1005fa2:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
 1005fa4:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
 1005fa8:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
 1005fac:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 1005fb0:	f842 3c04 	str.w	r3, [r2, #-4]
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
 1005fb4:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
 1005fb6:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
 1005fb8:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
 1005fba:	6783      	str	r3, [r0, #120]	; 0x78
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
 1005fbc:	4770      	bx	lr
 1005fbe:	bf00      	nop
 1005fc0:	010247fb 	.word	0x010247fb

01005fc4 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
 1005fc4:	4b08      	ldr	r3, [pc, #32]	; (1005fe8 <arch_switch_to_main_thread+0x24>)
 1005fc6:	6098      	str	r0, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 1005fc8:	6e83      	ldr	r3, [r0, #104]	; 0x68
 1005fca:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
 1005fce:	4610      	mov	r0, r2
 1005fd0:	f381 8809 	msr	PSP, r1
 1005fd4:	2100      	movs	r1, #0
 1005fd6:	b663      	cpsie	if
 1005fd8:	f381 8811 	msr	BASEPRI, r1
 1005fdc:	f3bf 8f6f 	isb	sy
 1005fe0:	2200      	movs	r2, #0
 1005fe2:	2300      	movs	r3, #0
 1005fe4:	f01e fc09 	bl	10247fa <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
 1005fe8:	210080cc 	.word	0x210080cc

01005fec <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
 1005fec:	b501      	push	{r0, lr}
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
 1005fee:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
 1005ff2:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
 1005ff6:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
 1005ffa:	4904      	ldr	r1, [pc, #16]	; (100600c <_isr_wrapper+0x20>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
 1005ffc:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
 1005ffe:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
 1006000:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
 1006002:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
 1006006:	4902      	ldr	r1, [pc, #8]	; (1006010 <_isr_wrapper+0x24>)
	bx r1
 1006008:	4708      	bx	r1
 100600a:	0000      	.short	0x0000
	ldr r1, =_sw_isr_table
 100600c:	01029778 	.word	0x01029778
	ldr r1, =z_arm_int_exit
 1006010:	01006015 	.word	0x01006015

01006014 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
 1006014:	4b04      	ldr	r3, [pc, #16]	; (1006028 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
 1006016:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
 1006018:	6998      	ldr	r0, [r3, #24]
	cmp r0, r1
 100601a:	4288      	cmp	r0, r1
	beq _EXIT_EXC
 100601c:	d003      	beq.n	1006026 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
 100601e:	4903      	ldr	r1, [pc, #12]	; (100602c <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
 1006020:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
 1006024:	600a      	str	r2, [r1, #0]

01006026 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
 1006026:	4770      	bx	lr
	ldr r3, =_kernel
 1006028:	210080cc 	.word	0x210080cc
	ldr r1, =_SCS_ICSR
 100602c:	e000ed04 	.word	0xe000ed04

01006030 <mem_manage_fault.constprop.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
 1006030:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1006034:	b086      	sub	sp, #24
 1006036:	4606      	mov	r6, r0
 1006038:	460d      	mov	r5, r1
 100603a:	af00      	add	r7, sp, #0
			      bool *recoverable)
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	uint32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");
 100603c:	2402      	movs	r4, #2
 100603e:	4b40      	ldr	r3, [pc, #256]	; (1006140 <mem_manage_fault.constprop.0+0x110>)
 1006040:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1006044:	617b      	str	r3, [r7, #20]
 1006046:	483f      	ldr	r0, [pc, #252]	; (1006144 <mem_manage_fault.constprop.0+0x114>)
 1006048:	613c      	str	r4, [r7, #16]
 100604a:	f107 0210 	add.w	r2, r7, #16
 100604e:	f020 fba5 	bl	102679c <z_log_msg_static_create.constprop.0>

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 1006052:	4b3d      	ldr	r3, [pc, #244]	; (1006148 <mem_manage_fault.constprop.0+0x118>)
 1006054:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 1006056:	06db      	lsls	r3, r3, #27
 1006058:	d509      	bpl.n	100606e <mem_manage_fault.constprop.0+0x3e>
		PR_FAULT_INFO("  Stacking error (context area might be"
 100605a:	4b3c      	ldr	r3, [pc, #240]	; (100614c <mem_manage_fault.constprop.0+0x11c>)
 100605c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1006060:	e9c7 4304 	strd	r4, r3, [r7, #16]
 1006064:	4837      	ldr	r0, [pc, #220]	; (1006144 <mem_manage_fault.constprop.0+0x114>)
 1006066:	f107 0210 	add.w	r2, r7, #16
 100606a:	f020 fb97 	bl	102679c <z_log_msg_static_create.constprop.0>
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
 100606e:	4b36      	ldr	r3, [pc, #216]	; (1006148 <mem_manage_fault.constprop.0+0x118>)
 1006070:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 1006072:	0718      	lsls	r0, r3, #28
 1006074:	d50a      	bpl.n	100608c <mem_manage_fault.constprop.0+0x5c>
		PR_FAULT_INFO("  Unstacking error");
 1006076:	4b36      	ldr	r3, [pc, #216]	; (1006150 <mem_manage_fault.constprop.0+0x120>)
 1006078:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100607c:	617b      	str	r3, [r7, #20]
 100607e:	2302      	movs	r3, #2
 1006080:	4830      	ldr	r0, [pc, #192]	; (1006144 <mem_manage_fault.constprop.0+0x114>)
 1006082:	613b      	str	r3, [r7, #16]
 1006084:	f107 0210 	add.w	r2, r7, #16
 1006088:	f020 fb88 	bl	102679c <z_log_msg_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 100608c:	4c2e      	ldr	r4, [pc, #184]	; (1006148 <mem_manage_fault.constprop.0+0x118>)
 100608e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1006090:	0799      	lsls	r1, r3, #30
 1006092:	d522      	bpl.n	10060da <mem_manage_fault.constprop.0+0xaa>
		PR_FAULT_INFO("  Data Access Violation");
 1006094:	46e8      	mov	r8, sp
 1006096:	4b2f      	ldr	r3, [pc, #188]	; (1006154 <mem_manage_fault.constprop.0+0x124>)
 1006098:	f107 0210 	add.w	r2, r7, #16
 100609c:	617b      	str	r3, [r7, #20]
 100609e:	2302      	movs	r3, #2
 10060a0:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10060a4:	613b      	str	r3, [r7, #16]
 10060a6:	4827      	ldr	r0, [pc, #156]	; (1006144 <mem_manage_fault.constprop.0+0x114>)
 10060a8:	f020 fb78 	bl	102679c <z_log_msg_static_create.constprop.0>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		uint32_t temp = SCB->MMFAR;
 10060ac:	6b63      	ldr	r3, [r4, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
 10060ae:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 10060b0:	0612      	lsls	r2, r2, #24
 10060b2:	d512      	bpl.n	10060da <mem_manage_fault.constprop.0+0xaa>
			mmfar = temp;
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
 10060b4:	b088      	sub	sp, #32
 10060b6:	466a      	mov	r2, sp
 10060b8:	4927      	ldr	r1, [pc, #156]	; (1006158 <mem_manage_fault.constprop.0+0x128>)
 10060ba:	4822      	ldr	r0, [pc, #136]	; (1006144 <mem_manage_fault.constprop.0+0x114>)
 10060bc:	e9c2 1305 	strd	r1, r3, [r2, #20]
 10060c0:	2303      	movs	r3, #3
 10060c2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 10060c6:	f842 3f10 	str.w	r3, [r2, #16]!
 10060ca:	f020 fb67 	bl	102679c <z_log_msg_static_create.constprop.0>
 10060ce:	46c5      	mov	sp, r8
			if (from_hard_fault != 0) {
 10060d0:	b11e      	cbz	r6, 10060da <mem_manage_fault.constprop.0+0xaa>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
 10060d2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 10060d4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 10060d8:	62a3      	str	r3, [r4, #40]	; 0x28
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
 10060da:	4b1b      	ldr	r3, [pc, #108]	; (1006148 <mem_manage_fault.constprop.0+0x118>)
 10060dc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 10060de:	07d8      	lsls	r0, r3, #31
 10060e0:	d50a      	bpl.n	10060f8 <mem_manage_fault.constprop.0+0xc8>
		PR_FAULT_INFO("  Instruction Access Violation");
 10060e2:	4b1e      	ldr	r3, [pc, #120]	; (100615c <mem_manage_fault.constprop.0+0x12c>)
 10060e4:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10060e8:	617b      	str	r3, [r7, #20]
 10060ea:	2302      	movs	r3, #2
 10060ec:	4815      	ldr	r0, [pc, #84]	; (1006144 <mem_manage_fault.constprop.0+0x114>)
 10060ee:	613b      	str	r3, [r7, #16]
 10060f0:	f107 0210 	add.w	r2, r7, #16
 10060f4:	f020 fb52 	bl	102679c <z_log_msg_static_create.constprop.0>
	 * crossed into an area beyond the thread stack.]
	 *
	 * Data Access Violation errors may or may not be caused by
	 * thread stack overflows.
	 */
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
 10060f8:	4b13      	ldr	r3, [pc, #76]	; (1006148 <mem_manage_fault.constprop.0+0x118>)
 10060fa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 10060fc:	06d1      	lsls	r1, r2, #27
 10060fe:	d402      	bmi.n	1006106 <mem_manage_fault.constprop.0+0xd6>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
 1006100:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
 1006102:	0792      	lsls	r2, r2, #30
 1006104:	d511      	bpl.n	100612a <mem_manage_fault.constprop.0+0xfa>
					"Stacking error not a stack fail\n");
			}
		}
#else
	(void)mmfar;
	__ASSERT(!(SCB->CFSR & SCB_CFSR_MSTKERR_Msk),
 1006106:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 1006108:	06db      	lsls	r3, r3, #27
 100610a:	d50e      	bpl.n	100612a <mem_manage_fault.constprop.0+0xfa>
 100610c:	4914      	ldr	r1, [pc, #80]	; (1006160 <mem_manage_fault.constprop.0+0x130>)
 100610e:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 1006112:	4a14      	ldr	r2, [pc, #80]	; (1006164 <mem_manage_fault.constprop.0+0x134>)
 1006114:	4814      	ldr	r0, [pc, #80]	; (1006168 <mem_manage_fault.constprop.0+0x138>)
 1006116:	f01e fd5e 	bl	1024bd6 <assert_print>
 100611a:	4814      	ldr	r0, [pc, #80]	; (100616c <mem_manage_fault.constprop.0+0x13c>)
 100611c:	f01e fd5b 	bl	1024bd6 <assert_print>
 1006120:	f44f 71ae 	mov.w	r1, #348	; 0x15c
 1006124:	480f      	ldr	r0, [pc, #60]	; (1006164 <mem_manage_fault.constprop.0+0x134>)
 1006126:	f01e fd4f 	bl	1024bc8 <assert_post_action>

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf, true);
 100612a:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 100612c:	4a06      	ldr	r2, [pc, #24]	; (1006148 <mem_manage_fault.constprop.0+0x118>)

	return reason;
}
 100612e:	3718      	adds	r7, #24
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 1006130:	6a93      	ldr	r3, [r2, #40]	; 0x28
 1006132:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
 1006136:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
 1006138:	7028      	strb	r0, [r5, #0]
}
 100613a:	46bd      	mov	sp, r7
 100613c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 1006140:	0102c4f6 	.word	0x0102c4f6
 1006144:	01029a54 	.word	0x01029a54
 1006148:	e000ed00 	.word	0xe000ed00
 100614c:	0102c50c 	.word	0x0102c50c
 1006150:	0102c53f 	.word	0x0102c53f
 1006154:	0102c552 	.word	0x0102c552
 1006158:	0102c56a 	.word	0x0102c56a
 100615c:	0102c580 	.word	0x0102c580
 1006160:	0102c5d9 	.word	0x0102c5d9
 1006164:	0102c59f 	.word	0x0102c59f
 1006168:	0102b695 	.word	0x0102b695
 100616c:	0102c623 	.word	0x0102c623

01006170 <bus_fault.constprop.0>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason.
 *
 */
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
 1006170:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1006174:	b086      	sub	sp, #24
 1006176:	4606      	mov	r6, r0
 1006178:	460d      	mov	r5, r1
 100617a:	af00      	add	r7, sp, #0
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");
 100617c:	2402      	movs	r4, #2
 100617e:	4b3b      	ldr	r3, [pc, #236]	; (100626c <bus_fault.constprop.0+0xfc>)
 1006180:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1006184:	617b      	str	r3, [r7, #20]
 1006186:	483a      	ldr	r0, [pc, #232]	; (1006270 <bus_fault.constprop.0+0x100>)
 1006188:	613c      	str	r4, [r7, #16]
 100618a:	f107 0210 	add.w	r2, r7, #16
 100618e:	f020 fb05 	bl	102679c <z_log_msg_static_create.constprop.0>

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 1006192:	4b38      	ldr	r3, [pc, #224]	; (1006274 <bus_fault.constprop.0+0x104>)
 1006194:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 1006196:	04db      	lsls	r3, r3, #19
 1006198:	d509      	bpl.n	10061ae <bus_fault.constprop.0+0x3e>
		PR_FAULT_INFO("  Stacking error");
 100619a:	4b37      	ldr	r3, [pc, #220]	; (1006278 <bus_fault.constprop.0+0x108>)
 100619c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10061a0:	e9c7 4304 	strd	r4, r3, [r7, #16]
 10061a4:	4832      	ldr	r0, [pc, #200]	; (1006270 <bus_fault.constprop.0+0x100>)
 10061a6:	f107 0210 	add.w	r2, r7, #16
 10061aa:	f020 faf7 	bl	102679c <z_log_msg_static_create.constprop.0>
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
 10061ae:	4b31      	ldr	r3, [pc, #196]	; (1006274 <bus_fault.constprop.0+0x104>)
 10061b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 10061b2:	051c      	lsls	r4, r3, #20
 10061b4:	d50a      	bpl.n	10061cc <bus_fault.constprop.0+0x5c>
		PR_FAULT_INFO("  Unstacking error");
 10061b6:	4b31      	ldr	r3, [pc, #196]	; (100627c <bus_fault.constprop.0+0x10c>)
 10061b8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10061bc:	617b      	str	r3, [r7, #20]
 10061be:	2302      	movs	r3, #2
 10061c0:	482b      	ldr	r0, [pc, #172]	; (1006270 <bus_fault.constprop.0+0x100>)
 10061c2:	613b      	str	r3, [r7, #16]
 10061c4:	f107 0210 	add.w	r2, r7, #16
 10061c8:	f020 fae8 	bl	102679c <z_log_msg_static_create.constprop.0>
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 10061cc:	4c29      	ldr	r4, [pc, #164]	; (1006274 <bus_fault.constprop.0+0x104>)
 10061ce:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 10061d0:	0598      	lsls	r0, r3, #22
 10061d2:	d522      	bpl.n	100621a <bus_fault.constprop.0+0xaa>
		PR_FAULT_INFO("  Precise data bus error");
 10061d4:	46e8      	mov	r8, sp
 10061d6:	4b2a      	ldr	r3, [pc, #168]	; (1006280 <bus_fault.constprop.0+0x110>)
 10061d8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10061dc:	617b      	str	r3, [r7, #20]
 10061de:	2302      	movs	r3, #2
 10061e0:	f107 0210 	add.w	r2, r7, #16
 10061e4:	613b      	str	r3, [r7, #16]
 10061e6:	4822      	ldr	r0, [pc, #136]	; (1006270 <bus_fault.constprop.0+0x100>)
 10061e8:	f020 fad8 	bl	102679c <z_log_msg_static_create.constprop.0>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
 10061ec:	6ba3      	ldr	r3, [r4, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
 10061ee:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 10061f0:	0411      	lsls	r1, r2, #16
 10061f2:	d512      	bpl.n	100621a <bus_fault.constprop.0+0xaa>
			PR_EXC("  BFAR Address: 0x%x", bfar);
 10061f4:	b088      	sub	sp, #32
 10061f6:	466a      	mov	r2, sp
 10061f8:	4922      	ldr	r1, [pc, #136]	; (1006284 <bus_fault.constprop.0+0x114>)
 10061fa:	481d      	ldr	r0, [pc, #116]	; (1006270 <bus_fault.constprop.0+0x100>)
 10061fc:	e9c2 1305 	strd	r1, r3, [r2, #20]
 1006200:	2303      	movs	r3, #3
 1006202:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1006206:	f842 3f10 	str.w	r3, [r2, #16]!
 100620a:	f020 fac7 	bl	102679c <z_log_msg_static_create.constprop.0>
 100620e:	46c5      	mov	sp, r8
			if (from_hard_fault != 0) {
 1006210:	b11e      	cbz	r6, 100621a <bus_fault.constprop.0+0xaa>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
 1006212:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1006214:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 1006218:	62a3      	str	r3, [r4, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
 100621a:	4b16      	ldr	r3, [pc, #88]	; (1006274 <bus_fault.constprop.0+0x104>)
 100621c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 100621e:	055a      	lsls	r2, r3, #21
 1006220:	d50a      	bpl.n	1006238 <bus_fault.constprop.0+0xc8>
		PR_FAULT_INFO("  Imprecise data bus error");
 1006222:	4b19      	ldr	r3, [pc, #100]	; (1006288 <bus_fault.constprop.0+0x118>)
 1006224:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1006228:	617b      	str	r3, [r7, #20]
 100622a:	2302      	movs	r3, #2
 100622c:	4810      	ldr	r0, [pc, #64]	; (1006270 <bus_fault.constprop.0+0x100>)
 100622e:	613b      	str	r3, [r7, #16]
 1006230:	f107 0210 	add.w	r2, r7, #16
 1006234:	f020 fab2 	bl	102679c <z_log_msg_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
 1006238:	4b0e      	ldr	r3, [pc, #56]	; (1006274 <bus_fault.constprop.0+0x104>)
 100623a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 100623c:	05db      	lsls	r3, r3, #23
 100623e:	d50a      	bpl.n	1006256 <bus_fault.constprop.0+0xe6>
		PR_FAULT_INFO("  Instruction bus error");
 1006240:	4b12      	ldr	r3, [pc, #72]	; (100628c <bus_fault.constprop.0+0x11c>)
 1006242:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1006246:	617b      	str	r3, [r7, #20]
 1006248:	2302      	movs	r3, #2
 100624a:	4809      	ldr	r0, [pc, #36]	; (1006270 <bus_fault.constprop.0+0x100>)
 100624c:	613b      	str	r3, [r7, #16]
 100624e:	f107 0210 	add.w	r2, r7, #16
 1006252:	f020 faa3 	bl	102679c <z_log_msg_static_create.constprop.0>
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;

	*recoverable = memory_fault_recoverable(esf, true);
 1006256:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 1006258:	4a06      	ldr	r2, [pc, #24]	; (1006274 <bus_fault.constprop.0+0x104>)

	return reason;
}
 100625a:	3718      	adds	r7, #24
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 100625c:	6a93      	ldr	r3, [r2, #40]	; 0x28
 100625e:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
 1006262:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
 1006264:	7028      	strb	r0, [r5, #0]
}
 1006266:	46bd      	mov	sp, r7
 1006268:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100626c:	0102c687 	.word	0x0102c687
 1006270:	01029a54 	.word	0x01029a54
 1006274:	e000ed00 	.word	0xe000ed00
 1006278:	0102c69d 	.word	0x0102c69d
 100627c:	0102c53f 	.word	0x0102c53f
 1006280:	0102c6ae 	.word	0x0102c6ae
 1006284:	0102c6c7 	.word	0x0102c6c7
 1006288:	0102c6dc 	.word	0x0102c6dc
 100628c:	0102c6f7 	.word	0x0102c6f7

01006290 <usage_fault.constprop.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
 1006290:	b510      	push	{r4, lr}
 1006292:	b086      	sub	sp, #24
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
 1006294:	2402      	movs	r4, #2
 1006296:	4b3a      	ldr	r3, [pc, #232]	; (1006380 <usage_fault.constprop.0+0xf0>)
 1006298:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100629c:	4839      	ldr	r0, [pc, #228]	; (1006384 <usage_fault.constprop.0+0xf4>)
 100629e:	aa04      	add	r2, sp, #16
 10062a0:	9305      	str	r3, [sp, #20]
 10062a2:	9404      	str	r4, [sp, #16]
 10062a4:	f020 fa7a 	bl	102679c <z_log_msg_static_create.constprop.0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 10062a8:	4b37      	ldr	r3, [pc, #220]	; (1006388 <usage_fault.constprop.0+0xf8>)
 10062aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 10062ac:	019b      	lsls	r3, r3, #6
 10062ae:	d508      	bpl.n	10062c2 <usage_fault.constprop.0+0x32>
		PR_FAULT_INFO("  Division by zero");
 10062b0:	4b36      	ldr	r3, [pc, #216]	; (100638c <usage_fault.constprop.0+0xfc>)
 10062b2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10062b6:	4833      	ldr	r0, [pc, #204]	; (1006384 <usage_fault.constprop.0+0xf4>)
 10062b8:	aa04      	add	r2, sp, #16
 10062ba:	e9cd 4304 	strd	r4, r3, [sp, #16]
 10062be:	f020 fa6d 	bl	102679c <z_log_msg_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
 10062c2:	4b31      	ldr	r3, [pc, #196]	; (1006388 <usage_fault.constprop.0+0xf8>)
 10062c4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 10062c6:	01dc      	lsls	r4, r3, #7
 10062c8:	d509      	bpl.n	10062de <usage_fault.constprop.0+0x4e>
		PR_FAULT_INFO("  Unaligned memory access");
 10062ca:	4b31      	ldr	r3, [pc, #196]	; (1006390 <usage_fault.constprop.0+0x100>)
 10062cc:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10062d0:	9305      	str	r3, [sp, #20]
 10062d2:	2302      	movs	r3, #2
 10062d4:	482b      	ldr	r0, [pc, #172]	; (1006384 <usage_fault.constprop.0+0xf4>)
 10062d6:	aa04      	add	r2, sp, #16
 10062d8:	9304      	str	r3, [sp, #16]
 10062da:	f020 fa5f 	bl	102679c <z_log_msg_static_create.constprop.0>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
 10062de:	4b2a      	ldr	r3, [pc, #168]	; (1006388 <usage_fault.constprop.0+0xf8>)
 10062e0:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 10062e2:	f414 1480 	ands.w	r4, r4, #1048576	; 0x100000
 10062e6:	d009      	beq.n	10062fc <usage_fault.constprop.0+0x6c>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
 10062e8:	2402      	movs	r4, #2
 10062ea:	4b2a      	ldr	r3, [pc, #168]	; (1006394 <usage_fault.constprop.0+0x104>)
 10062ec:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10062f0:	4824      	ldr	r0, [pc, #144]	; (1006384 <usage_fault.constprop.0+0xf4>)
 10062f2:	aa04      	add	r2, sp, #16
 10062f4:	9305      	str	r3, [sp, #20]
 10062f6:	9404      	str	r4, [sp, #16]
 10062f8:	f020 fa50 	bl	102679c <z_log_msg_static_create.constprop.0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
 10062fc:	4b22      	ldr	r3, [pc, #136]	; (1006388 <usage_fault.constprop.0+0xf8>)
 10062fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 1006300:	0318      	lsls	r0, r3, #12
 1006302:	d509      	bpl.n	1006318 <usage_fault.constprop.0+0x88>
		PR_FAULT_INFO("  No coprocessor instructions");
 1006304:	4b24      	ldr	r3, [pc, #144]	; (1006398 <usage_fault.constprop.0+0x108>)
 1006306:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100630a:	9305      	str	r3, [sp, #20]
 100630c:	2302      	movs	r3, #2
 100630e:	481d      	ldr	r0, [pc, #116]	; (1006384 <usage_fault.constprop.0+0xf4>)
 1006310:	aa04      	add	r2, sp, #16
 1006312:	9304      	str	r3, [sp, #16]
 1006314:	f020 fa42 	bl	102679c <z_log_msg_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
 1006318:	4b1b      	ldr	r3, [pc, #108]	; (1006388 <usage_fault.constprop.0+0xf8>)
 100631a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 100631c:	0359      	lsls	r1, r3, #13
 100631e:	d509      	bpl.n	1006334 <usage_fault.constprop.0+0xa4>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
 1006320:	4b1e      	ldr	r3, [pc, #120]	; (100639c <usage_fault.constprop.0+0x10c>)
 1006322:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1006326:	9305      	str	r3, [sp, #20]
 1006328:	2302      	movs	r3, #2
 100632a:	4816      	ldr	r0, [pc, #88]	; (1006384 <usage_fault.constprop.0+0xf4>)
 100632c:	aa04      	add	r2, sp, #16
 100632e:	9304      	str	r3, [sp, #16]
 1006330:	f020 fa34 	bl	102679c <z_log_msg_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
 1006334:	4b14      	ldr	r3, [pc, #80]	; (1006388 <usage_fault.constprop.0+0xf8>)
 1006336:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 1006338:	039a      	lsls	r2, r3, #14
 100633a:	d509      	bpl.n	1006350 <usage_fault.constprop.0+0xc0>
		PR_FAULT_INFO("  Illegal use of the EPSR");
 100633c:	4b18      	ldr	r3, [pc, #96]	; (10063a0 <usage_fault.constprop.0+0x110>)
 100633e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1006342:	9305      	str	r3, [sp, #20]
 1006344:	2302      	movs	r3, #2
 1006346:	480f      	ldr	r0, [pc, #60]	; (1006384 <usage_fault.constprop.0+0xf4>)
 1006348:	aa04      	add	r2, sp, #16
 100634a:	9304      	str	r3, [sp, #16]
 100634c:	f020 fa26 	bl	102679c <z_log_msg_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
 1006350:	4b0d      	ldr	r3, [pc, #52]	; (1006388 <usage_fault.constprop.0+0xf8>)
 1006352:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 1006354:	03db      	lsls	r3, r3, #15
 1006356:	d509      	bpl.n	100636c <usage_fault.constprop.0+0xdc>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
 1006358:	4b12      	ldr	r3, [pc, #72]	; (10063a4 <usage_fault.constprop.0+0x114>)
 100635a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100635e:	9305      	str	r3, [sp, #20]
 1006360:	2302      	movs	r3, #2
 1006362:	4808      	ldr	r0, [pc, #32]	; (1006384 <usage_fault.constprop.0+0xf4>)
 1006364:	aa04      	add	r2, sp, #16
 1006366:	9304      	str	r3, [sp, #16]
 1006368:	f020 fa18 	bl	102679c <z_log_msg_static_create.constprop.0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 100636c:	4a06      	ldr	r2, [pc, #24]	; (1006388 <usage_fault.constprop.0+0xf8>)

	return reason;
}
 100636e:	4620      	mov	r0, r4
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 1006370:	6a93      	ldr	r3, [r2, #40]	; 0x28
 1006372:	ea6f 4303 	mvn.w	r3, r3, lsl #16
 1006376:	ea6f 4313 	mvn.w	r3, r3, lsr #16
 100637a:	6293      	str	r3, [r2, #40]	; 0x28
}
 100637c:	b006      	add	sp, #24
 100637e:	bd10      	pop	{r4, pc}
 1006380:	0102c70f 	.word	0x0102c70f
 1006384:	01029a54 	.word	0x01029a54
 1006388:	e000ed00 	.word	0xe000ed00
 100638c:	0102c727 	.word	0x0102c727
 1006390:	0102c73a 	.word	0x0102c73a
 1006394:	0102c754 	.word	0x0102c754
 1006398:	0102c77e 	.word	0x0102c77e
 100639c:	0102c79c 	.word	0x0102c79c
 10063a0:	0102c7c1 	.word	0x0102c7c1
 10063a4:	0102c7db 	.word	0x0102c7db

010063a8 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
 10063a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 10063ac:	b08b      	sub	sp, #44	; 0x2c
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 10063ae:	4b8a      	ldr	r3, [pc, #552]	; (10065d8 <z_arm_fault+0x230>)
{
 10063b0:	4605      	mov	r5, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 10063b2:	6858      	ldr	r0, [r3, #4]
 10063b4:	2600      	movs	r6, #0
{
 10063b6:	af00      	add	r7, sp, #0
 10063b8:	f3c0 0308 	ubfx	r3, r0, #0, #9
 10063bc:	f386 8811 	msr	BASEPRI, r6
 10063c0:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
 10063c4:	f002 447f 	and.w	r4, r2, #4278190080	; 0xff000000
 10063c8:	f1b4 4f7f 	cmp.w	r4, #4278190080	; 0xff000000
 10063cc:	d10e      	bne.n	10063ec <z_arm_fault+0x44>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 10063ce:	f002 040c 	and.w	r4, r2, #12
 10063d2:	2c08      	cmp	r4, #8
 10063d4:	d119      	bne.n	100640a <z_arm_fault+0x62>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
 10063d6:	4b81      	ldr	r3, [pc, #516]	; (10065dc <z_arm_fault+0x234>)
 10063d8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10063dc:	61fb      	str	r3, [r7, #28]
 10063de:	2302      	movs	r3, #2
 10063e0:	487f      	ldr	r0, [pc, #508]	; (10065e0 <z_arm_fault+0x238>)
 10063e2:	61bb      	str	r3, [r7, #24]
 10063e4:	f107 0218 	add.w	r2, r7, #24
 10063e8:	f020 f9d8 	bl	102679c <z_log_msg_static_create.constprop.0>

	/* Retrieve the Exception Stack Frame (ESF) to be supplied
	 * as argument to the remainder of the fault handling process.
	 */
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
 10063ec:	497d      	ldr	r1, [pc, #500]	; (10065e4 <z_arm_fault+0x23c>)
 10063ee:	f44f 6384 	mov.w	r3, #1056	; 0x420
 10063f2:	4a7d      	ldr	r2, [pc, #500]	; (10065e8 <z_arm_fault+0x240>)
 10063f4:	487d      	ldr	r0, [pc, #500]	; (10065ec <z_arm_fault+0x244>)
 10063f6:	f01e fbee 	bl	1024bd6 <assert_print>
 10063fa:	487d      	ldr	r0, [pc, #500]	; (10065f0 <z_arm_fault+0x248>)
 10063fc:	f01e fbeb 	bl	1024bd6 <assert_print>
 1006400:	f44f 6184 	mov.w	r1, #1056	; 0x420
			__ASSERT(0,
 1006404:	4878      	ldr	r0, [pc, #480]	; (10065e8 <z_arm_fault+0x240>)
 1006406:	f01e fbdf 	bl	1024bc8 <assert_post_action>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
 100640a:	0714      	lsls	r4, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
 100640c:	bf4c      	ite	mi
 100640e:	460d      	movmi	r5, r1
			*nested_exc = true;
 1006410:	2601      	movpl	r6, #1
	__ASSERT(esf != NULL,
 1006412:	2d00      	cmp	r5, #0
 1006414:	d0ea      	beq.n	10063ec <z_arm_fault+0x44>
	*recoverable = false;
 1006416:	2200      	movs	r2, #0
 1006418:	71fa      	strb	r2, [r7, #7]
	switch (fault) {
 100641a:	1eda      	subs	r2, r3, #3
 100641c:	2a09      	cmp	r2, #9
 100641e:	f200 80ba 	bhi.w	1006596 <z_arm_fault+0x1ee>
 1006422:	e8df f002 	tbb	[pc, r2]
 1006426:	ad05      	.short	0xad05
 1006428:	b8b890b0 	.word	0xb8b890b0
 100642c:	b3b8b8b8 	.word	0xb3b8b8b8
	PR_FAULT_INFO("***** HARD FAULT *****");
 1006430:	46e9      	mov	r9, sp
 1006432:	f04f 0802 	mov.w	r8, #2
 1006436:	4b6f      	ldr	r3, [pc, #444]	; (10065f4 <z_arm_fault+0x24c>)
 1006438:	f107 0218 	add.w	r2, r7, #24
 100643c:	61fb      	str	r3, [r7, #28]
 100643e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1006442:	4867      	ldr	r0, [pc, #412]	; (10065e0 <z_arm_fault+0x238>)
 1006444:	f8c7 8018 	str.w	r8, [r7, #24]
 1006448:	f020 f9a8 	bl	102679c <z_log_msg_static_create.constprop.0>
	*recoverable = false;
 100644c:	2300      	movs	r3, #0
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 100644e:	4c62      	ldr	r4, [pc, #392]	; (10065d8 <z_arm_fault+0x230>)
	*recoverable = false;
 1006450:	71fb      	strb	r3, [r7, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 1006452:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 1006454:	079a      	lsls	r2, r3, #30
 1006456:	d50b      	bpl.n	1006470 <z_arm_fault+0xc8>
		PR_EXC("  Bus fault on vector table read");
 1006458:	4b67      	ldr	r3, [pc, #412]	; (10065f8 <z_arm_fault+0x250>)
		PR_EXC("  Debug event");
 100645a:	e9c7 8306 	strd	r8, r3, [r7, #24]
	PR_FAULT_INFO(
 100645e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1006462:	485f      	ldr	r0, [pc, #380]	; (10065e0 <z_arm_fault+0x238>)
 1006464:	f107 0218 	add.w	r2, r7, #24
 1006468:	f020 f998 	bl	102679c <z_log_msg_static_create.constprop.0>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
 100646c:	2400      	movs	r4, #0
 100646e:	e038      	b.n	10064e2 <z_arm_fault+0x13a>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
 1006470:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 1006472:	2b00      	cmp	r3, #0
 1006474:	da01      	bge.n	100647a <z_arm_fault+0xd2>
		PR_EXC("  Debug event");
 1006476:	4b61      	ldr	r3, [pc, #388]	; (10065fc <z_arm_fault+0x254>)
 1006478:	e7ef      	b.n	100645a <z_arm_fault+0xb2>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
 100647a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 100647c:	005b      	lsls	r3, r3, #1
 100647e:	d572      	bpl.n	1006566 <z_arm_fault+0x1be>
		PR_EXC("  Fault escalation (see below)");
 1006480:	4b5f      	ldr	r3, [pc, #380]	; (1006600 <z_arm_fault+0x258>)
 1006482:	f107 0218 	add.w	r2, r7, #24
 1006486:	e9c7 8306 	strd	r8, r3, [r7, #24]
 100648a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100648e:	4854      	ldr	r0, [pc, #336]	; (10065e0 <z_arm_fault+0x238>)
 1006490:	f020 f984 	bl	102679c <z_log_msg_static_create.constprop.0>
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
 1006494:	6963      	ldr	r3, [r4, #20]
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
 1006496:	69aa      	ldr	r2, [r5, #24]
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
 1006498:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 100649c:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 100649e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 10064a2:	f3bf 8f6f 	isb	sy
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
 10064a6:	6963      	ldr	r3, [r4, #20]
	uint16_t fault_insn = *(ret_addr - 1);
 10064a8:	f832 2c02 	ldrh.w	r2, [r2, #-2]
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
 10064ac:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 10064b0:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 10064b2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 10064b6:	f3bf 8f6f 	isb	sy
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 10064ba:	f64d 7302 	movw	r3, #57090	; 0xdf02
 10064be:	429a      	cmp	r2, r3
 10064c0:	d12b      	bne.n	100651a <z_arm_fault+0x172>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
 10064c2:	b088      	sub	sp, #32
 10064c4:	682b      	ldr	r3, [r5, #0]
 10064c6:	466a      	mov	r2, sp
 10064c8:	494e      	ldr	r1, [pc, #312]	; (1006604 <z_arm_fault+0x25c>)
 10064ca:	4845      	ldr	r0, [pc, #276]	; (10065e0 <z_arm_fault+0x238>)
 10064cc:	e9c2 1305 	strd	r1, r3, [r2, #20]
 10064d0:	2303      	movs	r3, #3
 10064d2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 10064d6:	f842 3f10 	str.w	r3, [r2, #16]!
 10064da:	f020 f95f 	bl	102679c <z_log_msg_static_create.constprop.0>
 10064de:	46cd      	mov	sp, r9
			reason = esf->basic.r0;
 10064e0:	682c      	ldr	r4, [r5, #0]
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
 10064e2:	79fb      	ldrb	r3, [r7, #7]
 10064e4:	b9ab      	cbnz	r3, 1006512 <z_arm_fault+0x16a>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
 10064e6:	2220      	movs	r2, #32
 10064e8:	4629      	mov	r1, r5
 10064ea:	f107 0008 	add.w	r0, r7, #8
 10064ee:	f020 fa41 	bl	1026974 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
 10064f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 10064f4:	2e00      	cmp	r6, #0
 10064f6:	d069      	beq.n	10065cc <z_arm_fault+0x224>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
 10064f8:	f3c3 0208 	ubfx	r2, r3, #0, #9
 10064fc:	b922      	cbnz	r2, 1006508 <z_arm_fault+0x160>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
 10064fe:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 1006502:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 1006506:	627b      	str	r3, [r7, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
 1006508:	4620      	mov	r0, r4
 100650a:	f107 0108 	add.w	r1, r7, #8
 100650e:	f7ff fc05 	bl	1005d1c <z_arm_fatal_error>
}
 1006512:	372c      	adds	r7, #44	; 0x2c
 1006514:	46bd      	mov	sp, r7
 1006516:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
 100651a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 100651c:	b2db      	uxtb	r3, r3
 100651e:	b12b      	cbz	r3, 100652c <z_arm_fault+0x184>
			reason = mem_manage_fault(esf, 1, recoverable);
 1006520:	2001      	movs	r0, #1
 1006522:	1df9      	adds	r1, r7, #7
		reason = mem_manage_fault(esf, 0, recoverable);
 1006524:	f7ff fd84 	bl	1006030 <mem_manage_fault.constprop.0>
 1006528:	4604      	mov	r4, r0
		break;
 100652a:	e7da      	b.n	10064e2 <z_arm_fault+0x13a>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
 100652c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 100652e:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
 1006532:	d004      	beq.n	100653e <z_arm_fault+0x196>
			reason = bus_fault(esf, 1, recoverable);
 1006534:	2001      	movs	r0, #1
 1006536:	1df9      	adds	r1, r7, #7
		reason = bus_fault(esf, 0, recoverable);
 1006538:	f7ff fe1a 	bl	1006170 <bus_fault.constprop.0>
 100653c:	e7f4      	b.n	1006528 <z_arm_fault+0x180>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
 100653e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1006540:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 1006544:	d302      	bcc.n	100654c <z_arm_fault+0x1a4>
		reason = usage_fault(esf);
 1006546:	f7ff fea3 	bl	1006290 <usage_fault.constprop.0>
 100654a:	e7ed      	b.n	1006528 <z_arm_fault+0x180>
			__ASSERT(0,
 100654c:	492e      	ldr	r1, [pc, #184]	; (1006608 <z_arm_fault+0x260>)
 100654e:	f240 23f2 	movw	r3, #754	; 0x2f2
 1006552:	4a25      	ldr	r2, [pc, #148]	; (10065e8 <z_arm_fault+0x240>)
 1006554:	4825      	ldr	r0, [pc, #148]	; (10065ec <z_arm_fault+0x244>)
 1006556:	f01e fb3e 	bl	1024bd6 <assert_print>
 100655a:	482c      	ldr	r0, [pc, #176]	; (100660c <z_arm_fault+0x264>)
 100655c:	f01e fb3b 	bl	1024bd6 <assert_print>
 1006560:	f240 21f2 	movw	r1, #754	; 0x2f2
 1006564:	e74e      	b.n	1006404 <z_arm_fault+0x5c>
		__ASSERT(0,
 1006566:	4928      	ldr	r1, [pc, #160]	; (1006608 <z_arm_fault+0x260>)
 1006568:	f240 23f6 	movw	r3, #758	; 0x2f6
 100656c:	4a1e      	ldr	r2, [pc, #120]	; (10065e8 <z_arm_fault+0x240>)
 100656e:	481f      	ldr	r0, [pc, #124]	; (10065ec <z_arm_fault+0x244>)
 1006570:	f01e fb31 	bl	1024bd6 <assert_print>
 1006574:	4826      	ldr	r0, [pc, #152]	; (1006610 <z_arm_fault+0x268>)
 1006576:	f01e fb2e 	bl	1024bd6 <assert_print>
 100657a:	f240 21f6 	movw	r1, #758	; 0x2f6
 100657e:	e741      	b.n	1006404 <z_arm_fault+0x5c>
		reason = mem_manage_fault(esf, 0, recoverable);
 1006580:	2000      	movs	r0, #0
 1006582:	1df9      	adds	r1, r7, #7
 1006584:	e7ce      	b.n	1006524 <z_arm_fault+0x17c>
		reason = bus_fault(esf, 0, recoverable);
 1006586:	2000      	movs	r0, #0
 1006588:	1df9      	adds	r1, r7, #7
 100658a:	e7d5      	b.n	1006538 <z_arm_fault+0x190>
	PR_FAULT_INFO(
 100658c:	4b21      	ldr	r3, [pc, #132]	; (1006614 <z_arm_fault+0x26c>)
 100658e:	61fb      	str	r3, [r7, #28]
 1006590:	2302      	movs	r3, #2
 1006592:	61bb      	str	r3, [r7, #24]
 1006594:	e763      	b.n	100645e <z_arm_fault+0xb6>
	PR_FAULT_INFO("***** %s %d) *****",
 1006596:	4a20      	ldr	r2, [pc, #128]	; (1006618 <z_arm_fault+0x270>)
 1006598:	466c      	mov	r4, sp
 100659a:	f410 7ff8 	tst.w	r0, #496	; 0x1f0
 100659e:	b08a      	sub	sp, #40	; 0x28
 10065a0:	491e      	ldr	r1, [pc, #120]	; (100661c <z_arm_fault+0x274>)
 10065a2:	bf18      	it	ne
 10065a4:	4611      	movne	r1, r2
 10065a6:	466a      	mov	r2, sp
 10065a8:	3b10      	subs	r3, #16
 10065aa:	61d3      	str	r3, [r2, #28]
 10065ac:	f44f 7300 	mov.w	r3, #512	; 0x200
 10065b0:	481b      	ldr	r0, [pc, #108]	; (1006620 <z_arm_fault+0x278>)
 10065b2:	8413      	strh	r3, [r2, #32]
 10065b4:	4b1b      	ldr	r3, [pc, #108]	; (1006624 <z_arm_fault+0x27c>)
 10065b6:	e9c2 0105 	strd	r0, r1, [r2, #20]
 10065ba:	f44f 5111 	mov.w	r1, #9280	; 0x2440
 10065be:	4808      	ldr	r0, [pc, #32]	; (10065e0 <z_arm_fault+0x238>)
 10065c0:	f842 3f10 	str.w	r3, [r2, #16]!
 10065c4:	f020 f8ea 	bl	102679c <z_log_msg_static_create.constprop.0>
 10065c8:	46a5      	mov	sp, r4
}
 10065ca:	e74f      	b.n	100646c <z_arm_fault+0xc4>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 10065cc:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 10065d0:	f023 0301 	bic.w	r3, r3, #1
 10065d4:	e797      	b.n	1006506 <z_arm_fault+0x15e>
 10065d6:	bf00      	nop
 10065d8:	e000ed00 	.word	0xe000ed00
 10065dc:	0102c834 	.word	0x0102c834
 10065e0:	01029a54 	.word	0x01029a54
 10065e4:	0102c85f 	.word	0x0102c85f
 10065e8:	0102c59f 	.word	0x0102c59f
 10065ec:	0102b695 	.word	0x0102b695
 10065f0:	0102c872 	.word	0x0102c872
 10065f4:	0102c8b0 	.word	0x0102c8b0
 10065f8:	0102c8c7 	.word	0x0102c8c7
 10065fc:	0102c8e8 	.word	0x0102c8e8
 1006600:	0102c8f6 	.word	0x0102c8f6
 1006604:	0102c915 	.word	0x0102c915
 1006608:	0102ff6e 	.word	0x0102ff6e
 100660c:	0102c931 	.word	0x0102c931
 1006610:	0102c955 	.word	0x0102c955
 1006614:	0102c985 	.word	0x0102c985
 1006618:	0102c81b 	.word	0x0102c81b
 100661c:	0102c806 	.word	0x0102c806
 1006620:	0102c9a9 	.word	0x0102c9a9
 1006624:	01000004 	.word	0x01000004

01006628 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
 1006628:	4b04      	ldr	r3, [pc, #16]	; (100663c <z_arm_fault_init+0x14>)
 100662a:	695a      	ldr	r2, [r3, #20]
 100662c:	f042 0210 	orr.w	r2, r2, #16
 1006630:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
 1006632:	695a      	ldr	r2, [r3, #20]
 1006634:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 1006638:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
 100663a:	4770      	bx	lr
 100663c:	e000ed00 	.word	0xe000ed00

01006640 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
 1006640:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
 1006644:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
 1006648:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
 100664a:	4672      	mov	r2, lr
	bl z_arm_fault
 100664c:	f7ff feac 	bl	10063a8 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
 1006650:	bd01      	pop	{r0, pc}
 1006652:	bf00      	nop

01006654 <z_arm_interrupt_init>:
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
 1006654:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1006656:	2120      	movs	r1, #32
 1006658:	4803      	ldr	r0, [pc, #12]	; (1006668 <z_arm_interrupt_init+0x14>)
 100665a:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
 100665c:	3301      	adds	r3, #1
 100665e:	2b1e      	cmp	r3, #30
 1006660:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
 1006664:	d1f9      	bne.n	100665a <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
 1006666:	4770      	bx	lr
 1006668:	e000e100 	.word	0xe000e100

0100666c <__start>:
    strb r0, [r1]
#endif /* CONFIG_DEBUG_THREAD_INFO */

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
 100666c:	2000      	movs	r0, #0
    msr CONTROL, r0
 100666e:	f380 8814 	msr	CONTROL, r0
    isb
 1006672:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
 1006676:	2000      	movs	r0, #0
    msr MSPLIM, r0
 1006678:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
 100667c:	f380 880b 	msr	PSPLIM, r0
#if defined(CONFIG_PM_S2RAM)
    bl arch_pm_s2ram_resume
#endif /* CONFIG_PM_S2RAM */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
 1006680:	f7fd fcdc 	bl	100403c <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
 1006684:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
 1006686:	490e      	ldr	r1, [pc, #56]	; (10066c0 <__start+0x54>)
    str r0, [r1]
 1006688:	6008      	str	r0, [r1, #0]
    dsb
 100668a:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
 100668e:	480d      	ldr	r0, [pc, #52]	; (10066c4 <__start+0x58>)
    msr msp, r0
 1006690:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
 1006694:	f000 f83e 	bl	1006714 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 1006698:	2020      	movs	r0, #32
    msr BASEPRI, r0
 100669a:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
 100669e:	480a      	ldr	r0, [pc, #40]	; (10066c8 <__start+0x5c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 10066a0:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
 10066a4:	1840      	adds	r0, r0, r1
    msr PSP, r0
 10066a6:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
 10066aa:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
 10066ae:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
 10066b0:	4308      	orrs	r0, r1
    msr CONTROL, r0
 10066b2:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
 10066b6:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
 10066ba:	f7ff fbfb 	bl	1005eb4 <z_arm_prep_c>
 10066be:	0000      	.short	0x0000
    ldr r1, =_SCS_MPU_CTRL
 10066c0:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
 10066c4:	2100c948 	.word	0x2100c948
    ldr r0, =z_interrupt_stacks
 10066c8:	2100bc48 	.word	0x2100bc48

010066cc <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
 10066cc:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 10066d0:	4905      	ldr	r1, [pc, #20]	; (10066e8 <sys_arch_reboot+0x1c>)
 10066d2:	4b06      	ldr	r3, [pc, #24]	; (10066ec <sys_arch_reboot+0x20>)
 10066d4:	68ca      	ldr	r2, [r1, #12]
 10066d6:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 10066da:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 10066dc:	60cb      	str	r3, [r1, #12]
 10066de:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 10066e2:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 10066e4:	e7fd      	b.n	10066e2 <sys_arch_reboot+0x16>
 10066e6:	bf00      	nop
 10066e8:	e000ed00 	.word	0xe000ed00
 10066ec:	05fa0004 	.word	0x05fa0004

010066f0 <z_arm_clear_arm_mpu_config>:
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);

	for (i = 0; i < num_regions; i++) {
 10066f0:	2300      	movs	r3, #0
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
  mpu->RLAR = 0U;
 10066f2:	4618      	mov	r0, r3
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
 10066f4:	4906      	ldr	r1, [pc, #24]	; (1006710 <z_arm_clear_arm_mpu_config+0x20>)
 10066f6:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
	int num_regions =
 10066fa:	f3c2 2207 	ubfx	r2, r2, #8, #8
	for (i = 0; i < num_regions; i++) {
 10066fe:	4293      	cmp	r3, r2
 1006700:	db00      	blt.n	1006704 <z_arm_clear_arm_mpu_config+0x14>
		ARM_MPU_ClrRegion(i);
	}
}
 1006702:	4770      	bx	lr
  mpu->RNR = rnr;
 1006704:	f8c1 3098 	str.w	r3, [r1, #152]	; 0x98
  mpu->RLAR = 0U;
 1006708:	f8c1 00a0 	str.w	r0, [r1, #160]	; 0xa0
	for (i = 0; i < num_regions; i++) {
 100670c:	3301      	adds	r3, #1
 100670e:	e7f6      	b.n	10066fe <z_arm_clear_arm_mpu_config+0xe>
 1006710:	e000ed00 	.word	0xe000ed00

01006714 <z_arm_init_arch_hw_at_boot>:
 * This routine resets Cortex-M system control block
 * components and core registers.
 *
 */
void z_arm_init_arch_hw_at_boot(void)
{
 1006714:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
 1006716:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 1006718:	2400      	movs	r4, #0
 100671a:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
 100671e:	f7ff ffe7 	bl	10066f0 <z_arm_clear_arm_mpu_config>
 1006722:	4623      	mov	r3, r4
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
		NVIC->ICER[i] = 0xFFFFFFFF;
 1006724:	f04f 30ff 	mov.w	r0, #4294967295
 1006728:	4a0c      	ldr	r2, [pc, #48]	; (100675c <z_arm_init_arch_hw_at_boot+0x48>)
 100672a:	f103 0120 	add.w	r1, r3, #32
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
 100672e:	3301      	adds	r3, #1
 1006730:	2b10      	cmp	r3, #16
		NVIC->ICER[i] = 0xFFFFFFFF;
 1006732:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
 1006736:	d1f8      	bne.n	100672a <z_arm_init_arch_hw_at_boot+0x16>
 1006738:	2300      	movs	r3, #0
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
		NVIC->ICPR[i] = 0xFFFFFFFF;
 100673a:	f04f 30ff 	mov.w	r0, #4294967295
 100673e:	4a07      	ldr	r2, [pc, #28]	; (100675c <z_arm_init_arch_hw_at_boot+0x48>)
 1006740:	f103 0160 	add.w	r1, r3, #96	; 0x60
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
 1006744:	3301      	adds	r3, #1
 1006746:	2b10      	cmp	r3, #16
		NVIC->ICPR[i] = 0xFFFFFFFF;
 1006748:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
 100674c:	d1f8      	bne.n	1006740 <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
 100674e:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
 1006750:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1006754:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
 1006758:	bd10      	pop	{r4, pc}
 100675a:	bf00      	nop
 100675c:	e000e100 	.word	0xe000e100

01006760 <z_impl_k_thread_abort>:
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
 1006760:	4b08      	ldr	r3, [pc, #32]	; (1006784 <z_impl_k_thread_abort+0x24>)
 1006762:	689b      	ldr	r3, [r3, #8]
 1006764:	4283      	cmp	r3, r0
 1006766:	d10b      	bne.n	1006780 <z_impl_k_thread_abort+0x20>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 1006768:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
 100676c:	b143      	cbz	r3, 1006780 <z_impl_k_thread_abort+0x20>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 100676e:	4b06      	ldr	r3, [pc, #24]	; (1006788 <z_impl_k_thread_abort+0x28>)
 1006770:	685a      	ldr	r2, [r3, #4]
 1006772:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 1006776:	605a      	str	r2, [r3, #4]
			/* Clear any system calls that may be pending
			 * as they have a higher priority than the PendSV
			 * handler and will check the stack of the thread
			 * being aborted.
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
 1006778:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 100677a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 100677e:	625a      	str	r2, [r3, #36]	; 0x24
		}
	}

	z_thread_abort(thread);
 1006780:	f01c be6e 	b.w	1023460 <z_thread_abort>
 1006784:	210080cc 	.word	0x210080cc
 1006788:	e000ed00 	.word	0xe000ed00

0100678c <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
 100678c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	 * into account the unused SRAM area, as well.
	 */
#ifdef CONFIG_AARCH32_ARMV8_R
	arm_core_mpu_disable();
#endif
	arm_core_mpu_configure_static_mpu_regions(static_regions,
 100678e:	4c09      	ldr	r4, [pc, #36]	; (10067b4 <z_arm_configure_static_mpu_regions+0x28>)
 1006790:	4a09      	ldr	r2, [pc, #36]	; (10067b8 <z_arm_configure_static_mpu_regions+0x2c>)
 1006792:	4623      	mov	r3, r4
 1006794:	2101      	movs	r1, #1
 1006796:	4809      	ldr	r0, [pc, #36]	; (10067bc <z_arm_configure_static_mpu_regions+0x30>)
 1006798:	f000 f92a 	bl	10069f0 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
 100679c:	2300      	movs	r3, #0
 100679e:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
 10067a0:	4b07      	ldr	r3, [pc, #28]	; (10067c0 <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
 10067a2:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
 10067a4:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
 10067a6:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
 10067a8:	9301      	str	r3, [sp, #4]
 10067aa:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
 10067ac:	f000 f944 	bl	1006a38 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
 10067b0:	b004      	add	sp, #16
 10067b2:	bd10      	pop	{r4, pc}
 10067b4:	21010000 	.word	0x21010000
 10067b8:	21000000 	.word	0x21000000
 10067bc:	01029d9c 	.word	0x01029d9c
 10067c0:	21000ee8 	.word	0x21000ee8

010067c4 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
 10067c4:	b510      	push	{r4, lr}
	mpu_set_region(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
		| (region_conf->attr.rbar &
 10067c6:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
 10067c8:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
 10067ca:	f004 021f 	and.w	r2, r4, #31
		(region_conf->base & MPU_RBAR_BASE_Msk)
 10067ce:	f023 031f 	bic.w	r3, r3, #31
		| (region_conf->attr.rbar &
 10067d2:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
 10067d4:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
 10067d6:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
 10067d8:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = rnr;
 10067dc:	4905      	ldr	r1, [pc, #20]	; (10067f4 <region_init+0x30>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
 10067de:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
 10067e2:	f043 0301 	orr.w	r3, r3, #1
	MPU->RNR = rnr;
 10067e6:	f8c1 0098 	str.w	r0, [r1, #152]	; 0x98
	MPU->RBAR = rbar;
 10067ea:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
	MPU->RLAR = rlar;
 10067ee:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
 10067f2:	bd10      	pop	{r4, pc}
 10067f4:	e000ed00 	.word	0xe000ed00

010067f8 <region_allocate_and_init.part.0>:
#include "arm_mpu_v8_internal.h"
#else
#error "Unsupported ARM CPU"
#endif

static int region_allocate_and_init(const uint8_t index,
 10067f8:	b580      	push	{r7, lr}
 10067fa:	af00      	add	r7, sp, #0
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
 10067fc:	b088      	sub	sp, #32
 10067fe:	466a      	mov	r2, sp
 1006800:	4b07      	ldr	r3, [pc, #28]	; (1006820 <region_allocate_and_init.part.0+0x28>)
 1006802:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1006806:	2303      	movs	r3, #3
 1006808:	f842 3f10 	str.w	r3, [r2, #16]!
 100680c:	2300      	movs	r3, #0
 100680e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1006812:	4804      	ldr	r0, [pc, #16]	; (1006824 <region_allocate_and_init.part.0+0x2c>)
 1006814:	f7fd ff78 	bl	1004708 <z_impl_z_log_msg_static_create>

	/* Program region */
	region_init(index, region_conf);

	return index;
}
 1006818:	f06f 0015 	mvn.w	r0, #21
 100681c:	46bd      	mov	sp, r7
 100681e:	bd80      	pop	{r7, pc}
 1006820:	0102c9c0 	.word	0x0102c9c0
 1006824:	01029a44 	.word	0x01029a44

01006828 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
 1006828:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100682c:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
 100682e:	4606      	mov	r6, r0
 1006830:	f04f 0900 	mov.w	r9, #0
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
 1006834:	b087      	sub	sp, #28
	MPU->RNR = rnr;
 1006836:	4d5f      	ldr	r5, [pc, #380]	; (10069b4 <mpu_configure_regions_and_partition.constprop.0+0x18c>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
 1006838:	af00      	add	r7, sp, #0
 100683a:	6079      	str	r1, [r7, #4]
	for (i = 0; i < regions_num; i++) {
 100683c:	687b      	ldr	r3, [r7, #4]
 100683e:	4599      	cmp	r9, r3
 1006840:	da35      	bge.n	10068ae <mpu_configure_regions_and_partition.constprop.0+0x86>
		if (regions[i].size == 0U) {
 1006842:	f8d6 8004 	ldr.w	r8, [r6, #4]
 1006846:	f1b8 0f00 	cmp.w	r8, #0
 100684a:	d054      	beq.n	10068f6 <mpu_configure_regions_and_partition.constprop.0+0xce>
		&&
 100684c:	f1b8 0f1f 	cmp.w	r8, #31
 1006850:	d91b      	bls.n	100688a <mpu_configure_regions_and_partition.constprop.0+0x62>
		&&
 1006852:	f018 0f1f 	tst.w	r8, #31
 1006856:	d118      	bne.n	100688a <mpu_configure_regions_and_partition.constprop.0+0x62>
		((part->start &
 1006858:	f8d6 b000 	ldr.w	fp, [r6]
		&&
 100685c:	f01b 0f1f 	tst.w	fp, #31
 1006860:	d113      	bne.n	100688a <mpu_configure_regions_and_partition.constprop.0+0x62>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
 1006862:	4658      	mov	r0, fp
 1006864:	f01f ff9d 	bl	10267a2 <arm_cmse_mpu_region_get>
 1006868:	4682      	mov	sl, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
 100686a:	eb08 000b 	add.w	r0, r8, fp
 100686e:	3801      	subs	r0, #1
 1006870:	f01f ff97 	bl	10267a2 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
 1006874:	4582      	cmp	sl, r0
 1006876:	d01f      	beq.n	10068b8 <mpu_configure_regions_and_partition.constprop.0+0x90>

		/* Derive the index of the underlying MPU region,
		 * inside which the new region will be configured.
		 */
		int u_reg_index =
			get_region_index(regions[i].start, regions[i].size);
 1006878:	f06f 0a15 	mvn.w	sl, #21

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
 100687c:	466c      	mov	r4, sp
 100687e:	b088      	sub	sp, #32
 1006880:	466a      	mov	r2, sp
 1006882:	494d      	ldr	r1, [pc, #308]	; (10069b8 <mpu_configure_regions_and_partition.constprop.0+0x190>)
 1006884:	e9c2 1a05 	strd	r1, sl, [r2, #20]
 1006888:	e005      	b.n	1006896 <mpu_configure_regions_and_partition.constprop.0+0x6e>
			LOG_ERR("Partition %u: sanity check failed.", i);
 100688a:	466c      	mov	r4, sp
 100688c:	b088      	sub	sp, #32
 100688e:	466a      	mov	r2, sp
 1006890:	4b4a      	ldr	r3, [pc, #296]	; (10069bc <mpu_configure_regions_and_partition.constprop.0+0x194>)
 1006892:	e9c2 3905 	strd	r3, r9, [r2, #20]
			LOG_ERR("Invalid underlying region index %u",
 1006896:	2303      	movs	r3, #3
 1006898:	f842 3f10 	str.w	r3, [r2, #16]!
 100689c:	2300      	movs	r3, #0
 100689e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 10068a2:	4847      	ldr	r0, [pc, #284]	; (10069c0 <mpu_configure_regions_and_partition.constprop.0+0x198>)
 10068a4:	f7fd ff30 	bl	1004708 <z_impl_z_log_msg_static_create>
 10068a8:	46a5      	mov	sp, r4
			return -EINVAL;
 10068aa:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
 10068ae:	4620      	mov	r0, r4
 10068b0:	371c      	adds	r7, #28
 10068b2:	46bd      	mov	sp, r7
 10068b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((u_reg_index == -EINVAL) ||
 10068b8:	f11a 0f16 	cmn.w	sl, #22
 10068bc:	d0de      	beq.n	100687c <mpu_configure_regions_and_partition.constprop.0+0x54>
 10068be:	4554      	cmp	r4, sl
 10068c0:	dddc      	ble.n	100687c <mpu_configure_regions_and_partition.constprop.0+0x54>
	MPU->RNR = rnr;
 10068c2:	f8c5 a098 	str.w	sl, [r5, #152]	; 0x98
	return MPU->RBAR;
 10068c6:	f8d5 009c 	ldr.w	r0, [r5, #156]	; 0x9c
	MPU->RNR = rnr;
 10068ca:	f8c5 a098 	str.w	sl, [r5, #152]	; 0x98
	return MPU->RLAR;
 10068ce:	f8d5 20a0 	ldr.w	r2, [r5, #160]	; 0xa0
	return mpu_get_rbar() & MPU_RBAR_BASE_Msk;
 10068d2:	f020 001f 	bic.w	r0, r0, #31
	return (mpu_get_rlar() & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
 10068d6:	f042 081f 	orr.w	r8, r2, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
 10068da:	e9d6 2100 	ldrd	r2, r1, [r6]
 10068de:	4411      	add	r1, r2
		if ((regions[i].start == u_reg_base) &&
 10068e0:	4290      	cmp	r0, r2
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
 10068e2:	f101 3bff 	add.w	fp, r1, #4294967295
		if ((regions[i].start == u_reg_base) &&
 10068e6:	d11e      	bne.n	1006926 <mpu_configure_regions_and_partition.constprop.0+0xfe>
 10068e8:	45d8      	cmp	r8, fp
 10068ea:	d108      	bne.n	10068fe <mpu_configure_regions_and_partition.constprop.0+0xd6>
			mpu_configure_region(u_reg_index, &regions[i]);
 10068ec:	4631      	mov	r1, r6
 10068ee:	fa5f f08a 	uxtb.w	r0, sl
 10068f2:	f01f ff5f 	bl	10267b4 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
 10068f6:	f109 0901 	add.w	r9, r9, #1
 10068fa:	360c      	adds	r6, #12
 10068fc:	e79e      	b.n	100683c <mpu_configure_regions_and_partition.constprop.0+0x14>
	MPU->RNR = rnr;
 10068fe:	f8c5 a098 	str.w	sl, [r5, #152]	; 0x98
	return MPU->RBAR;
 1006902:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
		     | (base & MPU_RBAR_BASE_Msk));
 1006906:	f021 011f 	bic.w	r1, r1, #31
	mpu_set_rbar((mpu_get_rbar() & (~MPU_RBAR_BASE_Msk))
 100690a:	f003 031f 	and.w	r3, r3, #31
		     | (base & MPU_RBAR_BASE_Msk));
 100690e:	430b      	orrs	r3, r1
				mpu_configure_region(reg_index, &regions[i]);
 1006910:	4631      	mov	r1, r6
	MPU->RBAR = rbar;
 1006912:	f8c5 309c 	str.w	r3, [r5, #156]	; 0x9c
				mpu_configure_region(reg_index, &regions[i]);
 1006916:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, &regions[i]);
 1006918:	f01f ff4c 	bl	10267b4 <mpu_configure_region>
			if (reg_index == -EINVAL) {
 100691c:	f110 0f16 	cmn.w	r0, #22
 1006920:	d0c3      	beq.n	10068aa <mpu_configure_regions_and_partition.constprop.0+0x82>
			reg_index++;
 1006922:	1c44      	adds	r4, r0, #1
 1006924:	e7e7      	b.n	10068f6 <mpu_configure_regions_and_partition.constprop.0+0xce>
				regions[i].start - 1);
 1006926:	3a01      	subs	r2, #1
		} else if (reg_last == u_reg_last) {
 1006928:	45d8      	cmp	r8, fp
				mpu_configure_region(reg_index, &regions[i]);
 100692a:	b2e0      	uxtb	r0, r4
		     | (limit & MPU_RLAR_LIMIT_Msk));
 100692c:	f022 021f 	bic.w	r2, r2, #31
	MPU->RNR = rnr;
 1006930:	f8c5 a098 	str.w	sl, [r5, #152]	; 0x98
		} else if (reg_last == u_reg_last) {
 1006934:	d108      	bne.n	1006948 <mpu_configure_regions_and_partition.constprop.0+0x120>
	return MPU->RLAR;
 1006936:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
				mpu_configure_region(reg_index, &regions[i]);
 100693a:	4631      	mov	r1, r6
	mpu_set_rlar((mpu_get_rlar() & (~MPU_RLAR_LIMIT_Msk))
 100693c:	f003 031f 	and.w	r3, r3, #31
		     | (limit & MPU_RLAR_LIMIT_Msk));
 1006940:	4313      	orrs	r3, r2
	MPU->RLAR = rlar;
 1006942:	f8c5 30a0 	str.w	r3, [r5, #160]	; 0xa0
			reg_index =
 1006946:	e7e7      	b.n	1006918 <mpu_configure_regions_and_partition.constprop.0+0xf0>
	return MPU->RLAR;
 1006948:	f8d5 10a0 	ldr.w	r1, [r5, #160]	; 0xa0
	mpu_set_rlar((mpu_get_rlar() & (~MPU_RLAR_LIMIT_Msk))
 100694c:	f001 011f 	and.w	r1, r1, #31
		     | (limit & MPU_RLAR_LIMIT_Msk));
 1006950:	430a      	orrs	r2, r1
	MPU->RLAR = rlar;
 1006952:	f8c5 20a0 	str.w	r2, [r5, #160]	; 0xa0
				mpu_configure_region(reg_index, &regions[i]);
 1006956:	4631      	mov	r1, r6
 1006958:	f01f ff2c 	bl	10267b4 <mpu_configure_region>
			if (reg_index == -EINVAL) {
 100695c:	f110 0f16 	cmn.w	r0, #22
 1006960:	d0a3      	beq.n	10068aa <mpu_configure_regions_and_partition.constprop.0+0x82>
	MPU->RNR = rnr;
 1006962:	f8c5 a098 	str.w	sl, [r5, #152]	; 0x98
	return MPU->RBAR;
 1006966:	f8d5 209c 	ldr.w	r2, [r5, #156]	; 0x9c
	attr->rbar = mpu_get_rbar() &
 100696a:	7c3b      	ldrb	r3, [r7, #16]
			REGION_LIMIT_ADDR((regions[i].start +
 100696c:	f108 38ff 	add.w	r8, r8, #4294967295
	attr->rbar = mpu_get_rbar() &
 1006970:	f362 0304 	bfi	r3, r2, #0, #5
 1006974:	743b      	strb	r3, [r7, #16]
	return MPU->RLAR;
 1006976:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
 100697a:	7c3a      	ldrb	r2, [r7, #16]
 100697c:	085b      	lsrs	r3, r3, #1
 100697e:	f363 1247 	bfi	r2, r3, #5, #3
 1006982:	743a      	strb	r2, [r7, #16]
			fill_region.base = regions[i].start +
 1006984:	e9d6 3200 	ldrd	r3, r2, [r6]
 1006988:	4413      	add	r3, r2
 100698a:	60bb      	str	r3, [r7, #8]
			REGION_LIMIT_ADDR((regions[i].start +
 100698c:	f023 031f 	bic.w	r3, r3, #31
			reg_index++;
 1006990:	1c44      	adds	r4, r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
 1006992:	4443      	add	r3, r8
 1006994:	eba3 030b 	sub.w	r3, r3, fp
				region_allocate_and_init(reg_index,
 1006998:	b2e0      	uxtb	r0, r4
			REGION_LIMIT_ADDR((regions[i].start +
 100699a:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1U)) {
 100699e:	2807      	cmp	r0, #7
			fill_region.attr.r_limit =
 10069a0:	617b      	str	r3, [r7, #20]
 10069a2:	d902      	bls.n	10069aa <mpu_configure_regions_and_partition.constprop.0+0x182>
 10069a4:	f7ff ff28 	bl	10067f8 <region_allocate_and_init.part.0>
			if (reg_index == -EINVAL) {
 10069a8:	e7b8      	b.n	100691c <mpu_configure_regions_and_partition.constprop.0+0xf4>
	region_init(index, region_conf);
 10069aa:	f107 0108 	add.w	r1, r7, #8
 10069ae:	f7ff ff09 	bl	10067c4 <region_init>
 10069b2:	e7b6      	b.n	1006922 <mpu_configure_regions_and_partition.constprop.0+0xfa>
 10069b4:	e000ed00 	.word	0xe000ed00
 10069b8:	0102ca09 	.word	0x0102ca09
 10069bc:	0102c9e6 	.word	0x0102c9e6
 10069c0:	01029a44 	.word	0x01029a44

010069c4 <arm_core_mpu_enable>:
	 * background region for privileged software access if desired.
	 */
#if defined(CONFIG_MPU_DISABLE_BACKGROUND_MAP)
	MPU->CTRL = MPU_CTRL_ENABLE_Msk;
#else
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
 10069c4:	2205      	movs	r2, #5
 10069c6:	4b04      	ldr	r3, [pc, #16]	; (10069d8 <arm_core_mpu_enable+0x14>)
 10069c8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
 10069cc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 10069d0:	f3bf 8f6f 	isb	sy
#endif

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
 10069d4:	4770      	bx	lr
 10069d6:	bf00      	nop
 10069d8:	e000ed00 	.word	0xe000ed00

010069dc <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
 10069dc:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
 10069e0:	2200      	movs	r2, #0
 10069e2:	4b02      	ldr	r3, [pc, #8]	; (10069ec <arm_core_mpu_disable+0x10>)
 10069e4:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
 10069e8:	4770      	bx	lr
 10069ea:	bf00      	nop
 10069ec:	e000ed00 	.word	0xe000ed00

010069f0 <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	*static_regions, const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
 10069f0:	b538      	push	{r3, r4, r5, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
 10069f2:	4d0c      	ldr	r5, [pc, #48]	; (1006a24 <arm_core_mpu_configure_static_mpu_regions+0x34>)
 10069f4:	460c      	mov	r4, r1
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
 10069f6:	782a      	ldrb	r2, [r5, #0]
 10069f8:	f7ff ff16 	bl	1006828 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
 10069fc:	7028      	strb	r0, [r5, #0]
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
 10069fe:	3016      	adds	r0, #22
 1006a00:	d10f      	bne.n	1006a22 <arm_core_mpu_configure_static_mpu_regions+0x32>
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
 1006a02:	f44f 738d 	mov.w	r3, #282	; 0x11a
 1006a06:	4a08      	ldr	r2, [pc, #32]	; (1006a28 <arm_core_mpu_configure_static_mpu_regions+0x38>)
 1006a08:	4908      	ldr	r1, [pc, #32]	; (1006a2c <arm_core_mpu_configure_static_mpu_regions+0x3c>)
 1006a0a:	4809      	ldr	r0, [pc, #36]	; (1006a30 <arm_core_mpu_configure_static_mpu_regions+0x40>)
 1006a0c:	f01e f8e3 	bl	1024bd6 <assert_print>
 1006a10:	4621      	mov	r1, r4
 1006a12:	4808      	ldr	r0, [pc, #32]	; (1006a34 <arm_core_mpu_configure_static_mpu_regions+0x44>)
 1006a14:	f01e f8df 	bl	1024bd6 <assert_print>
 1006a18:	f44f 718d 	mov.w	r1, #282	; 0x11a
 1006a1c:	4802      	ldr	r0, [pc, #8]	; (1006a28 <arm_core_mpu_configure_static_mpu_regions+0x38>)
 1006a1e:	f01e f8d3 	bl	1024bc8 <assert_post_action>
			regions_num);
	}
}
 1006a22:	bd38      	pop	{r3, r4, r5, pc}
 1006a24:	21008205 	.word	0x21008205
 1006a28:	0102ca2c 	.word	0x0102ca2c
 1006a2c:	0102ff6e 	.word	0x0102ff6e
 1006a30:	0102b695 	.word	0x0102b695
 1006a34:	0102ca63 	.word	0x0102ca63

01006a38 <arm_core_mpu_mark_areas_for_dynamic_regions>:
 * @brief mark memory areas for dynamic region configuration
 */
void arm_core_mpu_mark_areas_for_dynamic_regions(
	const struct z_arm_mpu_partition dyn_region_areas[],
	const uint8_t dyn_region_areas_num)
{
 1006a38:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1006a3c:	4e31      	ldr	r6, [pc, #196]	; (1006b04 <arm_core_mpu_mark_areas_for_dynamic_regions+0xcc>)
 1006a3e:	4689      	mov	r9, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
 1006a40:	4605      	mov	r5, r0
 1006a42:	f04f 0800 	mov.w	r8, #0
 1006a46:	46b3      	mov	fp, r6
	MPU->RNR = rnr;
 1006a48:	4f2f      	ldr	r7, [pc, #188]	; (1006b08 <arm_core_mpu_mark_areas_for_dynamic_regions+0xd0>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
 1006a4a:	45c8      	cmp	r8, r9
 1006a4c:	db02      	blt.n	1006a54 <arm_core_mpu_mark_areas_for_dynamic_regions+0x1c>
						 dyn_region_areas_num) == -EINVAL) {

		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
			dyn_region_areas_num);
	}
}
 1006a4e:	b003      	add	sp, #12
 1006a50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (dyn_region_areas[i].size == 0U) {
 1006a54:	f8d5 a004 	ldr.w	sl, [r5, #4]
 1006a58:	f1ba 0f00 	cmp.w	sl, #0
 1006a5c:	d04c      	beq.n	1006af8 <arm_core_mpu_mark_areas_for_dynamic_regions+0xc0>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
 1006a5e:	6829      	ldr	r1, [r5, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
 1006a60:	4608      	mov	r0, r1
 1006a62:	9101      	str	r1, [sp, #4]
 1006a64:	f01f fe9d 	bl	10267a2 <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
 1006a68:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
 1006a6a:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
 1006a6c:	eb0a 0001 	add.w	r0, sl, r1
 1006a70:	3801      	subs	r0, #1
 1006a72:	f01f fe96 	bl	10267a2 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
 1006a76:	4284      	cmp	r4, r0
 1006a78:	f04f 0214 	mov.w	r2, #20
 1006a7c:	4b23      	ldr	r3, [pc, #140]	; (1006b0c <arm_core_mpu_mark_areas_for_dynamic_regions+0xd4>)
 1006a7e:	d015      	beq.n	1006aac <arm_core_mpu_mark_areas_for_dynamic_regions+0x74>
		dyn_reg_info[i].index =
 1006a80:	fb02 f308 	mul.w	r3, r2, r8
 1006a84:	f06f 0215 	mvn.w	r2, #21
 1006a88:	f84b 2003 	str.w	r2, [fp, r3]
		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
 1006a8c:	f44f 7395 	mov.w	r3, #298	; 0x12a
 1006a90:	4a1f      	ldr	r2, [pc, #124]	; (1006b10 <arm_core_mpu_mark_areas_for_dynamic_regions+0xd8>)
 1006a92:	4920      	ldr	r1, [pc, #128]	; (1006b14 <arm_core_mpu_mark_areas_for_dynamic_regions+0xdc>)
 1006a94:	4820      	ldr	r0, [pc, #128]	; (1006b18 <arm_core_mpu_mark_areas_for_dynamic_regions+0xe0>)
 1006a96:	f01e f89e 	bl	1024bd6 <assert_print>
 1006a9a:	4649      	mov	r1, r9
 1006a9c:	481f      	ldr	r0, [pc, #124]	; (1006b1c <arm_core_mpu_mark_areas_for_dynamic_regions+0xe4>)
 1006a9e:	f01e f89a 	bl	1024bd6 <assert_print>
 1006aa2:	f44f 7195 	mov.w	r1, #298	; 0x12a
 1006aa6:	481a      	ldr	r0, [pc, #104]	; (1006b10 <arm_core_mpu_mark_areas_for_dynamic_regions+0xd8>)
 1006aa8:	f01e f88e 	bl	1024bc8 <assert_post_action>
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
 1006aac:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
 1006ab0:	6034      	str	r4, [r6, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
 1006ab2:	d0eb      	beq.n	1006a8c <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
 1006ab4:	7819      	ldrb	r1, [r3, #0]
 1006ab6:	42a1      	cmp	r1, r4
 1006ab8:	dde8      	ble.n	1006a8c <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
	attr->rbar = mpu_get_rbar() &
 1006aba:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = rnr;
 1006abe:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
 1006ac2:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
	return MPU->RBAR;
 1006ac6:	f8d7 409c 	ldr.w	r4, [r7, #156]	; 0x9c
	attr->rbar = mpu_get_rbar() &
 1006aca:	f100 0108 	add.w	r1, r0, #8
 1006ace:	7b00      	ldrb	r0, [r0, #12]
 1006ad0:	f364 0004 	bfi	r0, r4, #0, #5
 1006ad4:	7108      	strb	r0, [r1, #4]
	return MPU->RLAR;
 1006ad6:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
 1006ada:	790c      	ldrb	r4, [r1, #4]
 1006adc:	0840      	lsrs	r0, r0, #1
 1006ade:	f360 1447 	bfi	r4, r0, #5, #3
 1006ae2:	710c      	strb	r4, [r1, #4]
	return MPU->RBAR;
 1006ae4:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
	region_conf->base = mpu_get_rbar() & MPU_RBAR_BASE_Msk;
 1006ae8:	f021 011f 	bic.w	r1, r1, #31
 1006aec:	6071      	str	r1, [r6, #4]
	return MPU->RLAR;
 1006aee:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
	region_conf->attr.r_limit = mpu_get_rlar() & MPU_RLAR_LIMIT_Msk;
 1006af2:	f021 011f 	bic.w	r1, r1, #31
 1006af6:	6131      	str	r1, [r6, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
 1006af8:	f108 0801 	add.w	r8, r8, #1
 1006afc:	3614      	adds	r6, #20
 1006afe:	350c      	adds	r5, #12
 1006b00:	e7a3      	b.n	1006a4a <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
 1006b02:	bf00      	nop
 1006b04:	21004670 	.word	0x21004670
 1006b08:	e000ed00 	.word	0xe000ed00
 1006b0c:	21008205 	.word	0x21008205
 1006b10:	0102ca2c 	.word	0x0102ca2c
 1006b14:	0102ff6e 	.word	0x0102ff6e
 1006b18:	0102b695 	.word	0x0102b695
 1006b1c:	0102ca8f 	.word	0x0102ca8f

01006b20 <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
 1006b20:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
 1006b22:	4d1f      	ldr	r5, [pc, #124]	; (1006ba0 <z_arm_mpu_init+0x80>)
 1006b24:	682c      	ldr	r4, [r5, #0]
 1006b26:	2c08      	cmp	r4, #8
 1006b28:	d910      	bls.n	1006b4c <z_arm_mpu_init+0x2c>
		 * what is supported by hardware. As this operation
		 * is executed during system (pre-kernel) initialization,
		 * we want to ensure we can detect an attempt to
		 * perform invalid configuration.
		 */
		__ASSERT(0,
 1006b2a:	f240 1351 	movw	r3, #337	; 0x151
 1006b2e:	4a1d      	ldr	r2, [pc, #116]	; (1006ba4 <z_arm_mpu_init+0x84>)
 1006b30:	491d      	ldr	r1, [pc, #116]	; (1006ba8 <z_arm_mpu_init+0x88>)
 1006b32:	481e      	ldr	r0, [pc, #120]	; (1006bac <z_arm_mpu_init+0x8c>)
 1006b34:	f01e f84f 	bl	1024bd6 <assert_print>
 1006b38:	4621      	mov	r1, r4
 1006b3a:	2208      	movs	r2, #8
 1006b3c:	481c      	ldr	r0, [pc, #112]	; (1006bb0 <z_arm_mpu_init+0x90>)
 1006b3e:	f01e f84a 	bl	1024bd6 <assert_print>
 1006b42:	f240 1151 	movw	r1, #337	; 0x151
	defined(CONFIG_CPU_CORTEX_M4)
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos == 8,
		"Invalid number of MPU regions\n");
#elif defined(NUM_MPU_REGIONS)
	__ASSERT(
 1006b46:	4817      	ldr	r0, [pc, #92]	; (1006ba4 <z_arm_mpu_init+0x84>)
 1006b48:	f01e f83e 	bl	1024bc8 <assert_post_action>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
 1006b4c:	2000      	movs	r0, #0
	arm_core_mpu_disable();
 1006b4e:	f7ff ff45 	bl	10069dc <arm_core_mpu_disable>
	MPU->MAIR0 = mair0;
 1006b52:	4b18      	ldr	r3, [pc, #96]	; (1006bb4 <z_arm_mpu_init+0x94>)
 1006b54:	4a18      	ldr	r2, [pc, #96]	; (1006bb8 <z_arm_mpu_init+0x98>)
 1006b56:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
 1006b5a:	4284      	cmp	r4, r0
 1006b5c:	d117      	bne.n	1006b8e <z_arm_mpu_init+0x6e>
	static_regions_num = mpu_config.num_regions;
 1006b5e:	4b17      	ldr	r3, [pc, #92]	; (1006bbc <z_arm_mpu_init+0x9c>)
 1006b60:	701c      	strb	r4, [r3, #0]
	arm_core_mpu_enable();
 1006b62:	f7ff ff2f 	bl	10069c4 <arm_core_mpu_enable>
	__ASSERT(
 1006b66:	4b13      	ldr	r3, [pc, #76]	; (1006bb4 <z_arm_mpu_init+0x94>)
 1006b68:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 1006b6c:	f3c3 2307 	ubfx	r3, r3, #8, #8
 1006b70:	2b08      	cmp	r3, #8
 1006b72:	d013      	beq.n	1006b9c <z_arm_mpu_init+0x7c>
 1006b74:	4912      	ldr	r1, [pc, #72]	; (1006bc0 <z_arm_mpu_init+0xa0>)
 1006b76:	f240 13bb 	movw	r3, #443	; 0x1bb
 1006b7a:	4a0a      	ldr	r2, [pc, #40]	; (1006ba4 <z_arm_mpu_init+0x84>)
 1006b7c:	480b      	ldr	r0, [pc, #44]	; (1006bac <z_arm_mpu_init+0x8c>)
 1006b7e:	f01e f82a 	bl	1024bd6 <assert_print>
 1006b82:	4810      	ldr	r0, [pc, #64]	; (1006bc4 <z_arm_mpu_init+0xa4>)
 1006b84:	f01e f827 	bl	1024bd6 <assert_print>
 1006b88:	f240 11bb 	movw	r1, #443	; 0x1bb
 1006b8c:	e7db      	b.n	1006b46 <z_arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
 1006b8e:	6869      	ldr	r1, [r5, #4]
 1006b90:	eb01 1100 	add.w	r1, r1, r0, lsl #4
 1006b94:	f7ff fe16 	bl	10067c4 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
 1006b98:	3001      	adds	r0, #1
 1006b9a:	e7de      	b.n	1006b5a <z_arm_mpu_init+0x3a>
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
}
 1006b9c:	2000      	movs	r0, #0
 1006b9e:	bd38      	pop	{r3, r4, r5, pc}
 1006ba0:	01029da8 	.word	0x01029da8
 1006ba4:	0102ca2c 	.word	0x0102ca2c
 1006ba8:	0102ff6e 	.word	0x0102ff6e
 1006bac:	0102b695 	.word	0x0102b695
 1006bb0:	0102cabe 	.word	0x0102cabe
 1006bb4:	e000ed00 	.word	0xe000ed00
 1006bb8:	0044ffaa 	.word	0x0044ffaa
 1006bbc:	21008205 	.word	0x21008205
 1006bc0:	0102caf2 	.word	0x0102caf2
 1006bc4:	0102cb42 	.word	0x0102cb42

01006bc8 <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
 1006bc8:	4b01      	ldr	r3, [pc, #4]	; (1006bd0 <__stdout_hook_install+0x8>)
 1006bca:	6018      	str	r0, [r3, #0]
}
 1006bcc:	4770      	bx	lr
 1006bce:	bf00      	nop
 1006bd0:	21000304 	.word	0x21000304

01006bd4 <snprintf>:
	return 0; /* indicate keep going so we get the total count */
}

int snprintf(char *ZRESTRICT str, size_t len,
	     const char *ZRESTRICT format, ...)
{
 1006bd4:	b40c      	push	{r2, r3}
 1006bd6:	b510      	push	{r4, lr}
 1006bd8:	b086      	sub	sp, #24

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
 1006bda:	b909      	cbnz	r1, 1006be0 <snprintf+0xc>
		str = &dummy; /* write final NUL to dummy, can't change *s */
 1006bdc:	f10d 000b 	add.w	r0, sp, #11
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
 1006be0:	2400      	movs	r4, #0
	}

	p.ptr = str;
	p.len = (int) len;
 1006be2:	e9cd 0104 	strd	r0, r1, [sp, #16]

	va_start(vargs, format);
 1006be6:	ab09      	add	r3, sp, #36	; 0x24
 1006be8:	9a08      	ldr	r2, [sp, #32]
 1006bea:	9400      	str	r4, [sp, #0]
 1006bec:	a904      	add	r1, sp, #16
 1006bee:	4805      	ldr	r0, [pc, #20]	; (1006c04 <snprintf+0x30>)
 1006bf0:	9303      	str	r3, [sp, #12]
 1006bf2:	f7fc fc1d 	bl	1003430 <z_cbvprintf_impl>
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
	va_end(vargs);

	*(p.ptr) = 0;
 1006bf6:	9b04      	ldr	r3, [sp, #16]
 1006bf8:	701c      	strb	r4, [r3, #0]
	return r;
}
 1006bfa:	b006      	add	sp, #24
 1006bfc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 1006c00:	b002      	add	sp, #8
 1006c02:	4770      	bx	lr
 1006c04:	010269a3 	.word	0x010269a3

01006c08 <bt_hex>:
	static const char hex[] = "0123456789abcdef";
	static char str[129];
	const uint8_t *b = buf;
	size_t i;

	len = MIN(len, (sizeof(str) - 1) / 2);
 1006c08:	4b0e      	ldr	r3, [pc, #56]	; (1006c44 <bt_hex+0x3c>)
 1006c0a:	2940      	cmp	r1, #64	; 0x40
 1006c0c:	bf28      	it	cs
 1006c0e:	2140      	movcs	r1, #64	; 0x40
{
 1006c10:	b570      	push	{r4, r5, r6, lr}
 1006c12:	461d      	mov	r5, r3

	for (i = 0; i < len; i++) {
		str[i * 2] = hex[b[i] >> 4];
 1006c14:	4c0c      	ldr	r4, [pc, #48]	; (1006c48 <bt_hex+0x40>)
 1006c16:	1846      	adds	r6, r0, r1
	for (i = 0; i < len; i++) {
 1006c18:	42b0      	cmp	r0, r6
 1006c1a:	f103 0302 	add.w	r3, r3, #2
 1006c1e:	d104      	bne.n	1006c2a <bt_hex+0x22>
		str[i * 2 + 1] = hex[b[i] & 0xf];
	}

	str[i * 2] = '\0';
 1006c20:	2300      	movs	r3, #0
 1006c22:	f805 3011 	strb.w	r3, [r5, r1, lsl #1]

	return str;
}
 1006c26:	4807      	ldr	r0, [pc, #28]	; (1006c44 <bt_hex+0x3c>)
 1006c28:	bd70      	pop	{r4, r5, r6, pc}
		str[i * 2] = hex[b[i] >> 4];
 1006c2a:	7802      	ldrb	r2, [r0, #0]
 1006c2c:	0912      	lsrs	r2, r2, #4
 1006c2e:	5ca2      	ldrb	r2, [r4, r2]
 1006c30:	f803 2c02 	strb.w	r2, [r3, #-2]
		str[i * 2 + 1] = hex[b[i] & 0xf];
 1006c34:	f810 2b01 	ldrb.w	r2, [r0], #1
 1006c38:	f002 020f 	and.w	r2, r2, #15
 1006c3c:	5ca2      	ldrb	r2, [r4, r2]
 1006c3e:	f803 2c01 	strb.w	r2, [r3, #-1]
	for (i = 0; i < len; i++) {
 1006c42:	e7e9      	b.n	1006c18 <bt_hex+0x10>
 1006c44:	21008224 	.word	0x21008224
 1006c48:	0102cb8c 	.word	0x0102cb8c

01006c4c <bt_addr_le_str>:

	return str;
}

const char *bt_addr_le_str(const bt_addr_le_t *addr)
{
 1006c4c:	b530      	push	{r4, r5, lr}
	switch (addr->type) {
 1006c4e:	7803      	ldrb	r3, [r0, #0]
 1006c50:	b08b      	sub	sp, #44	; 0x2c
 1006c52:	4604      	mov	r4, r0
 1006c54:	ad07      	add	r5, sp, #28
 1006c56:	2b03      	cmp	r3, #3
 1006c58:	d821      	bhi.n	1006c9e <bt_addr_le_str+0x52>
 1006c5a:	e8df f003 	tbb	[pc, r3]
 1006c5e:	1a02      	.short	0x1a02
 1006c60:	1e1c      	.short	0x1e1c
		strcpy(type, "public");
 1006c62:	4912      	ldr	r1, [pc, #72]	; (1006cac <bt_addr_le_str+0x60>)
		strcpy(type, "random");
 1006c64:	4628      	mov	r0, r5
 1006c66:	f01f fe3c 	bl	10268e2 <strcpy>
	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
 1006c6a:	9505      	str	r5, [sp, #20]
 1006c6c:	7863      	ldrb	r3, [r4, #1]
 1006c6e:	211e      	movs	r1, #30
 1006c70:	9304      	str	r3, [sp, #16]
 1006c72:	78a3      	ldrb	r3, [r4, #2]
 1006c74:	4a0e      	ldr	r2, [pc, #56]	; (1006cb0 <bt_addr_le_str+0x64>)
 1006c76:	9303      	str	r3, [sp, #12]
 1006c78:	78e3      	ldrb	r3, [r4, #3]
 1006c7a:	480e      	ldr	r0, [pc, #56]	; (1006cb4 <bt_addr_le_str+0x68>)
 1006c7c:	9302      	str	r3, [sp, #8]
 1006c7e:	7923      	ldrb	r3, [r4, #4]
 1006c80:	9301      	str	r3, [sp, #4]
 1006c82:	7963      	ldrb	r3, [r4, #5]
 1006c84:	9300      	str	r3, [sp, #0]
 1006c86:	79a3      	ldrb	r3, [r4, #6]
 1006c88:	f01d fdaa 	bl	10247e0 <snprintk>
	static char str[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(addr, str, sizeof(str));

	return str;
}
 1006c8c:	4809      	ldr	r0, [pc, #36]	; (1006cb4 <bt_addr_le_str+0x68>)
 1006c8e:	b00b      	add	sp, #44	; 0x2c
 1006c90:	bd30      	pop	{r4, r5, pc}
		strcpy(type, "random");
 1006c92:	4909      	ldr	r1, [pc, #36]	; (1006cb8 <bt_addr_le_str+0x6c>)
 1006c94:	e7e6      	b.n	1006c64 <bt_addr_le_str+0x18>
		strcpy(type, "public-id");
 1006c96:	4909      	ldr	r1, [pc, #36]	; (1006cbc <bt_addr_le_str+0x70>)
 1006c98:	e7e4      	b.n	1006c64 <bt_addr_le_str+0x18>
		strcpy(type, "random-id");
 1006c9a:	4909      	ldr	r1, [pc, #36]	; (1006cc0 <bt_addr_le_str+0x74>)
 1006c9c:	e7e2      	b.n	1006c64 <bt_addr_le_str+0x18>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
 1006c9e:	210a      	movs	r1, #10
 1006ca0:	4628      	mov	r0, r5
 1006ca2:	4a08      	ldr	r2, [pc, #32]	; (1006cc4 <bt_addr_le_str+0x78>)
 1006ca4:	f01d fd9c 	bl	10247e0 <snprintk>
		break;
 1006ca8:	e7df      	b.n	1006c6a <bt_addr_le_str+0x1e>
 1006caa:	bf00      	nop
 1006cac:	0102b404 	.word	0x0102b404
 1006cb0:	0102b426 	.word	0x0102b426
 1006cb4:	21008206 	.word	0x21008206
 1006cb8:	0102b40b 	.word	0x0102b40b
 1006cbc:	0102b412 	.word	0x0102b412
 1006cc0:	0102b41c 	.word	0x0102b41c
 1006cc4:	0102eaf6 	.word	0x0102eaf6

01006cc8 <sys_memcpy_swap.constprop.0>:
static inline void sys_memcpy_swap(void *dst, const void *src, size_t length)
{
	uint8_t *pdst = (uint8_t *)dst;
	const uint8_t *psrc = (const uint8_t *)src;

	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
 1006cc8:	4288      	cmp	r0, r1
static inline void sys_memcpy_swap(void *dst, const void *src, size_t length)
 1006cca:	b508      	push	{r3, lr}
 1006ccc:	f101 0320 	add.w	r3, r1, #32
	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
 1006cd0:	d910      	bls.n	1006cf4 <sys_memcpy_swap.constprop.0+0x2c>
 1006cd2:	4298      	cmp	r0, r3
 1006cd4:	d213      	bcs.n	1006cfe <sys_memcpy_swap.constprop.0+0x36>
 1006cd6:	490e      	ldr	r1, [pc, #56]	; (1006d10 <sys_memcpy_swap.constprop.0+0x48>)
 1006cd8:	f240 2315 	movw	r3, #533	; 0x215
 1006cdc:	4a0d      	ldr	r2, [pc, #52]	; (1006d14 <sys_memcpy_swap.constprop.0+0x4c>)
 1006cde:	480e      	ldr	r0, [pc, #56]	; (1006d18 <sys_memcpy_swap.constprop.0+0x50>)
 1006ce0:	f01d ff79 	bl	1024bd6 <assert_print>
 1006ce4:	480d      	ldr	r0, [pc, #52]	; (1006d1c <sys_memcpy_swap.constprop.0+0x54>)
 1006ce6:	f01d ff76 	bl	1024bd6 <assert_print>
 1006cea:	f240 2115 	movw	r1, #533	; 0x215
 1006cee:	4809      	ldr	r0, [pc, #36]	; (1006d14 <sys_memcpy_swap.constprop.0+0x4c>)
 1006cf0:	f01d ff6a 	bl	1024bc8 <assert_post_action>
 1006cf4:	d0ef      	beq.n	1006cd6 <sys_memcpy_swap.constprop.0+0xe>
 1006cf6:	f100 0220 	add.w	r2, r0, #32
 1006cfa:	4291      	cmp	r1, r2
 1006cfc:	e7ea      	b.n	1006cd4 <sys_memcpy_swap.constprop.0+0xc>
		  (psrc > pdst && (pdst + length) <= psrc)),
		 "Source and destination buffers must not overlap");

	psrc += length - 1;

	for (; length > 0; length--) {
 1006cfe:	3801      	subs	r0, #1
		*pdst++ = *psrc--;
 1006d00:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
	for (; length > 0; length--) {
 1006d04:	428b      	cmp	r3, r1
		*pdst++ = *psrc--;
 1006d06:	f800 2f01 	strb.w	r2, [r0, #1]!
	for (; length > 0; length--) {
 1006d0a:	d1f9      	bne.n	1006d00 <sys_memcpy_swap.constprop.0+0x38>
	}
}
 1006d0c:	bd08      	pop	{r3, pc}
 1006d0e:	bf00      	nop
 1006d10:	0102cbd6 	.word	0x0102cbd6
 1006d14:	0102cba4 	.word	0x0102cba4
 1006d18:	0102b695 	.word	0x0102b695
 1006d1c:	0102cc2d 	.word	0x0102cc2d

01006d20 <ecc_process>:

	bt_recv(buf);
}

static void ecc_process(struct k_work *work)
{
 1006d20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1006d24:	b086      	sub	sp, #24
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1006d26:	4d6a      	ldr	r5, [pc, #424]	; (1006ed0 <ecc_process+0x1b0>)
 1006d28:	af00      	add	r7, sp, #0
 1006d2a:	e8d5 4faf 	lda	r4, [r5]
	if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
 1006d2e:	f014 0401 	ands.w	r4, r4, #1
 1006d32:	d060      	beq.n	1006df6 <ecc_process+0xd6>
		rc = uECC_make_key(ecc.public_key_be, ecc.private_key_be,
 1006d34:	f8df 819c 	ldr.w	r8, [pc, #412]	; 1006ed4 <ecc_process+0x1b4>
 1006d38:	4c67      	ldr	r4, [pc, #412]	; (1006ed8 <ecc_process+0x1b8>)
	} while (memcmp(ecc.private_key_be, debug_private_key_be, BT_PRIV_KEY_LEN) == 0);
 1006d3a:	4e68      	ldr	r6, [pc, #416]	; (1006edc <ecc_process+0x1bc>)
		rc = uECC_make_key(ecc.public_key_be, ecc.private_key_be,
 1006d3c:	4642      	mov	r2, r8
 1006d3e:	4621      	mov	r1, r4
 1006d40:	4867      	ldr	r0, [pc, #412]	; (1006ee0 <ecc_process+0x1c0>)
 1006d42:	f01e fc26 	bl	1025592 <uECC_make_key>
		if (rc == TC_CRYPTO_FAIL) {
 1006d46:	4603      	mov	r3, r0
 1006d48:	2800      	cmp	r0, #0
 1006d4a:	d141      	bne.n	1006dd0 <ecc_process+0xb0>
			LOG_ERR("Failed to create ECC public/private pair");
 1006d4c:	4a65      	ldr	r2, [pc, #404]	; (1006ee4 <ecc_process+0x1c4>)
 1006d4e:	617a      	str	r2, [r7, #20]
 1006d50:	2202      	movs	r2, #2
 1006d52:	613a      	str	r2, [r7, #16]
			return BT_HCI_ERR_UNSPECIFIED;
 1006d54:	f04f 081f 	mov.w	r8, #31
 1006d58:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1006d5c:	4862      	ldr	r0, [pc, #392]	; (1006ee8 <ecc_process+0x1c8>)
 1006d5e:	f107 0210 	add.w	r2, r7, #16
 1006d62:	f7fd fcd1 	bl	1004708 <z_impl_z_log_msg_static_create>
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 1006d66:	f04f 32ff 	mov.w	r2, #4294967295
 1006d6a:	f04f 33ff 	mov.w	r3, #4294967295
 1006d6e:	2001      	movs	r0, #1
 1006d70:	f000 fb02 	bl	1007378 <bt_buf_get_rx>
 1006d74:	f100 060c 	add.w	r6, r0, #12
 1006d78:	2102      	movs	r1, #2
 1006d7a:	4604      	mov	r4, r0
 1006d7c:	4630      	mov	r0, r6
 1006d7e:	f017 fa8b 	bl	101e298 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
 1006d82:	233e      	movs	r3, #62	; 0x3e
 1006d84:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
 1006d86:	2342      	movs	r3, #66	; 0x42
 1006d88:	2101      	movs	r1, #1
 1006d8a:	7043      	strb	r3, [r0, #1]
 1006d8c:	4630      	mov	r0, r6
 1006d8e:	f017 fa83 	bl	101e298 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE;
 1006d92:	2308      	movs	r3, #8
 1006d94:	2141      	movs	r1, #65	; 0x41
 1006d96:	7003      	strb	r3, [r0, #0]
 1006d98:	4630      	mov	r0, r6
 1006d9a:	f017 fa7d 	bl	101e298 <net_buf_simple_add>
 1006d9e:	4606      	mov	r6, r0
	evt->status = status;
 1006da0:	f800 8b01 	strb.w	r8, [r0], #1
	if (status) {
 1006da4:	f1b8 0f00 	cmp.w	r8, #0
 1006da8:	d01c      	beq.n	1006de4 <ecc_process+0xc4>
		(void)memset(evt->key, 0, sizeof(evt->key));
 1006daa:	2240      	movs	r2, #64	; 0x40
 1006dac:	2100      	movs	r1, #0
 1006dae:	f01f fdec 	bl	102698a <memset>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1006db2:	e8d5 3fef 	ldaex	r3, [r5]
 1006db6:	f023 0301 	bic.w	r3, r3, #1
 1006dba:	e8c5 3fe2 	stlex	r2, r3, [r5]
 1006dbe:	2a00      	cmp	r2, #0
 1006dc0:	d1f7      	bne.n	1006db2 <ecc_process+0x92>
	bt_recv(buf);
 1006dc2:	4620      	mov	r0, r4
	bt_recv(buf);
 1006dc4:	f001 fc4a 	bl	100865c <bt_recv>
	} else if (atomic_test_bit(flags, PENDING_DHKEY)) {
		emulate_le_generate_dhkey();
	} else {
		__ASSERT(0, "Unhandled ECC command");
	}
}
 1006dc8:	3718      	adds	r7, #24
 1006dca:	46bd      	mov	sp, r7
 1006dcc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} while (memcmp(ecc.private_key_be, debug_private_key_be, BT_PRIV_KEY_LEN) == 0);
 1006dd0:	2220      	movs	r2, #32
 1006dd2:	4631      	mov	r1, r6
 1006dd4:	4620      	mov	r0, r4
 1006dd6:	f01f fdbd 	bl	1026954 <memcmp>
 1006dda:	2800      	cmp	r0, #0
 1006ddc:	d0ae      	beq.n	1006d3c <ecc_process+0x1c>
	return 0;
 1006dde:	f04f 0800 	mov.w	r8, #0
 1006de2:	e7c0      	b.n	1006d66 <ecc_process+0x46>
		sys_memcpy_swap(evt->key, ecc.public_key_be, BT_PUB_KEY_COORD_LEN);
 1006de4:	493e      	ldr	r1, [pc, #248]	; (1006ee0 <ecc_process+0x1c0>)
 1006de6:	f7ff ff6f 	bl	1006cc8 <sys_memcpy_swap.constprop.0>
		sys_memcpy_swap(&evt->key[BT_PUB_KEY_COORD_LEN],
 1006dea:	4940      	ldr	r1, [pc, #256]	; (1006eec <ecc_process+0x1cc>)
 1006dec:	f106 0021 	add.w	r0, r6, #33	; 0x21
 1006df0:	f7ff ff6a 	bl	1006cc8 <sys_memcpy_swap.constprop.0>
 1006df4:	e7dd      	b.n	1006db2 <ecc_process+0x92>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1006df6:	e8d5 3faf 	lda	r3, [r5]
	} else if (atomic_test_bit(flags, PENDING_DHKEY)) {
 1006dfa:	079b      	lsls	r3, r3, #30
 1006dfc:	d55a      	bpl.n	1006eb4 <ecc_process+0x194>
	ret = uECC_valid_public_key(ecc.public_key_be, &curve_secp256r1);
 1006dfe:	4935      	ldr	r1, [pc, #212]	; (1006ed4 <ecc_process+0x1b4>)
 1006e00:	4837      	ldr	r0, [pc, #220]	; (1006ee0 <ecc_process+0x1c0>)
 1006e02:	f01f fa82 	bl	102630a <uECC_valid_public_key>
	if (ret < 0) {
 1006e06:	2800      	cmp	r0, #0
 1006e08:	da3e      	bge.n	1006e88 <ecc_process+0x168>
		LOG_ERR("public key is not valid (ret %d)", ret);
 1006e0a:	466e      	mov	r6, sp
 1006e0c:	b088      	sub	sp, #32
 1006e0e:	466a      	mov	r2, sp
 1006e10:	4b37      	ldr	r3, [pc, #220]	; (1006ef0 <ecc_process+0x1d0>)
 1006e12:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1006e16:	2303      	movs	r3, #3
 1006e18:	f842 3f10 	str.w	r3, [r2, #16]!
 1006e1c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1006e20:	4623      	mov	r3, r4
 1006e22:	4831      	ldr	r0, [pc, #196]	; (1006ee8 <ecc_process+0x1c8>)
 1006e24:	f7fd fc70 	bl	1004708 <z_impl_z_log_msg_static_create>
 1006e28:	46b5      	mov	sp, r6
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 1006e2a:	f04f 32ff 	mov.w	r2, #4294967295
 1006e2e:	f04f 33ff 	mov.w	r3, #4294967295
 1006e32:	2001      	movs	r0, #1
 1006e34:	f000 faa0 	bl	1007378 <bt_buf_get_rx>
 1006e38:	f100 080c 	add.w	r8, r0, #12
 1006e3c:	2102      	movs	r1, #2
 1006e3e:	4606      	mov	r6, r0
 1006e40:	4640      	mov	r0, r8
 1006e42:	f017 fa29 	bl	101e298 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
 1006e46:	233e      	movs	r3, #62	; 0x3e
 1006e48:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
 1006e4a:	2322      	movs	r3, #34	; 0x22
 1006e4c:	2101      	movs	r1, #1
 1006e4e:	7043      	strb	r3, [r0, #1]
 1006e50:	4640      	mov	r0, r8
 1006e52:	f017 fa21 	bl	101e298 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE;
 1006e56:	2309      	movs	r3, #9
 1006e58:	2121      	movs	r1, #33	; 0x21
 1006e5a:	7003      	strb	r3, [r0, #0]
 1006e5c:	4640      	mov	r0, r8
 1006e5e:	f017 fa1b 	bl	101e298 <net_buf_simple_add>
 1006e62:	4603      	mov	r3, r0
	if (ret == TC_CRYPTO_FAIL) {
 1006e64:	3001      	adds	r0, #1
 1006e66:	b9fc      	cbnz	r4, 1006ea8 <ecc_process+0x188>
		evt->status = BT_HCI_ERR_UNSPECIFIED;
 1006e68:	221f      	movs	r2, #31
		(void)memset(evt->dhkey, 0xff, sizeof(evt->dhkey));
 1006e6a:	21ff      	movs	r1, #255	; 0xff
		evt->status = BT_HCI_ERR_UNSPECIFIED;
 1006e6c:	701a      	strb	r2, [r3, #0]
		(void)memset(evt->dhkey, 0xff, sizeof(evt->dhkey));
 1006e6e:	2220      	movs	r2, #32
 1006e70:	f01f fd8b 	bl	102698a <memset>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1006e74:	e8d5 3fef 	ldaex	r3, [r5]
 1006e78:	f023 0302 	bic.w	r3, r3, #2
 1006e7c:	e8c5 3fe2 	stlex	r2, r3, [r5]
 1006e80:	2a00      	cmp	r2, #0
 1006e82:	d1f7      	bne.n	1006e74 <ecc_process+0x154>
	bt_recv(buf);
 1006e84:	4630      	mov	r0, r6
 1006e86:	e79d      	b.n	1006dc4 <ecc_process+0xa4>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1006e88:	e8d5 3faf 	lda	r3, [r5]
		ret = uECC_shared_secret(ecc.public_key_be,
 1006e8c:	4912      	ldr	r1, [pc, #72]	; (1006ed8 <ecc_process+0x1b8>)
 1006e8e:	4813      	ldr	r0, [pc, #76]	; (1006edc <ecc_process+0x1bc>)
 1006e90:	f013 0f04 	tst.w	r3, #4
 1006e94:	f101 0220 	add.w	r2, r1, #32
 1006e98:	4b0e      	ldr	r3, [pc, #56]	; (1006ed4 <ecc_process+0x1b4>)
 1006e9a:	bf18      	it	ne
 1006e9c:	4601      	movne	r1, r0
 1006e9e:	4610      	mov	r0, r2
 1006ea0:	f01e fbc6 	bl	1025630 <uECC_shared_secret>
 1006ea4:	4604      	mov	r4, r0
 1006ea6:	e7c0      	b.n	1006e2a <ecc_process+0x10a>
		evt->status = 0U;
 1006ea8:	2200      	movs	r2, #0
		sys_memcpy_swap(evt->dhkey, ecc.dhkey_be, sizeof(ecc.dhkey_be));
 1006eaa:	490d      	ldr	r1, [pc, #52]	; (1006ee0 <ecc_process+0x1c0>)
		evt->status = 0U;
 1006eac:	701a      	strb	r2, [r3, #0]
		sys_memcpy_swap(evt->dhkey, ecc.dhkey_be, sizeof(ecc.dhkey_be));
 1006eae:	f7ff ff0b 	bl	1006cc8 <sys_memcpy_swap.constprop.0>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1006eb2:	e7df      	b.n	1006e74 <ecc_process+0x154>
		__ASSERT(0, "Unhandled ECC command");
 1006eb4:	490f      	ldr	r1, [pc, #60]	; (1006ef4 <ecc_process+0x1d4>)
 1006eb6:	23db      	movs	r3, #219	; 0xdb
 1006eb8:	4a0f      	ldr	r2, [pc, #60]	; (1006ef8 <ecc_process+0x1d8>)
 1006eba:	4810      	ldr	r0, [pc, #64]	; (1006efc <ecc_process+0x1dc>)
 1006ebc:	f01d fe8b 	bl	1024bd6 <assert_print>
 1006ec0:	480f      	ldr	r0, [pc, #60]	; (1006f00 <ecc_process+0x1e0>)
 1006ec2:	f01d fe88 	bl	1024bd6 <assert_print>
 1006ec6:	21db      	movs	r1, #219	; 0xdb
 1006ec8:	480b      	ldr	r0, [pc, #44]	; (1006ef8 <ecc_process+0x1d8>)
 1006eca:	f01d fe7d 	bl	1024bc8 <assert_post_action>
 1006ece:	bf00      	nop
 1006ed0:	21004684 	.word	0x21004684
 1006ed4:	01029dd0 	.word	0x01029dd0
 1006ed8:	210082a5 	.word	0x210082a5
 1006edc:	0102ccf4 	.word	0x0102ccf4
 1006ee0:	210082c5 	.word	0x210082c5
 1006ee4:	0102cc5f 	.word	0x0102cc5f
 1006ee8:	010299ac 	.word	0x010299ac
 1006eec:	210082e5 	.word	0x210082e5
 1006ef0:	0102cc88 	.word	0x0102cc88
 1006ef4:	0102ff6e 	.word	0x0102ff6e
 1006ef8:	0102cca9 	.word	0x0102cca9
 1006efc:	0102b695 	.word	0x0102b695
 1006f00:	0102ccdc 	.word	0x0102ccdc

01006f04 <le_gen_dhkey>:
	cmd->events[0] &= ~0x80; /* LE Read Local P-256 PKey Compl */
	cmd->events[1] &= ~0x01; /* LE Generate DHKey Compl Event */
}

static uint8_t le_gen_dhkey(uint8_t *key, uint8_t key_type)
{
 1006f04:	b570      	push	{r4, r5, r6, lr}
 1006f06:	4606      	mov	r6, r0
 1006f08:	460d      	mov	r5, r1
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1006f0a:	4c1a      	ldr	r4, [pc, #104]	; (1006f74 <le_gen_dhkey+0x70>)
 1006f0c:	e8d4 3faf 	lda	r3, [r4]
	if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
 1006f10:	07da      	lsls	r2, r3, #31
 1006f12:	d501      	bpl.n	1006f18 <le_gen_dhkey+0x14>
		return BT_HCI_ERR_CMD_DISALLOWED;
 1006f14:	200c      	movs	r0, #12
			  key_type == BT_HCI_LE_KEY_TYPE_DEBUG);

	bt_long_wq_submit(&ecc_work);

	return BT_HCI_ERR_SUCCESS;
}
 1006f16:	bd70      	pop	{r4, r5, r6, pc}
	if (key_type > BT_HCI_LE_KEY_TYPE_DEBUG) {
 1006f18:	2901      	cmp	r1, #1
 1006f1a:	d829      	bhi.n	1006f70 <le_gen_dhkey+0x6c>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1006f1c:	e8d4 3fef 	ldaex	r3, [r4]
 1006f20:	f043 0202 	orr.w	r2, r3, #2
 1006f24:	e8c4 2fe1 	stlex	r1, r2, [r4]
 1006f28:	2900      	cmp	r1, #0
 1006f2a:	d1f7      	bne.n	1006f1c <le_gen_dhkey+0x18>
	if (atomic_test_and_set_bit(flags, PENDING_DHKEY)) {
 1006f2c:	079b      	lsls	r3, r3, #30
 1006f2e:	d4f1      	bmi.n	1006f14 <le_gen_dhkey+0x10>
	sys_memcpy_swap(ecc.public_key_be, key, BT_PUB_KEY_COORD_LEN);
 1006f30:	4631      	mov	r1, r6
 1006f32:	4811      	ldr	r0, [pc, #68]	; (1006f78 <le_gen_dhkey+0x74>)
 1006f34:	f7ff fec8 	bl	1006cc8 <sys_memcpy_swap.constprop.0>
	sys_memcpy_swap(&ecc.public_key_be[BT_PUB_KEY_COORD_LEN], &key[BT_PUB_KEY_COORD_LEN],
 1006f38:	4810      	ldr	r0, [pc, #64]	; (1006f7c <le_gen_dhkey+0x78>)
 1006f3a:	f106 0120 	add.w	r1, r6, #32
 1006f3e:	f7ff fec3 	bl	1006cc8 <sys_memcpy_swap.constprop.0>
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	if (val) {
 1006f42:	b165      	cbz	r5, 1006f5e <le_gen_dhkey+0x5a>
 1006f44:	e8d4 3fef 	ldaex	r3, [r4]
 1006f48:	f043 0304 	orr.w	r3, r3, #4
 1006f4c:	e8c4 3fe2 	stlex	r2, r3, [r4]
 1006f50:	2a00      	cmp	r2, #0
 1006f52:	d1f7      	bne.n	1006f44 <le_gen_dhkey+0x40>
	bt_long_wq_submit(&ecc_work);
 1006f54:	480a      	ldr	r0, [pc, #40]	; (1006f80 <le_gen_dhkey+0x7c>)
 1006f56:	f000 f9d3 	bl	1007300 <bt_long_wq_submit>
 1006f5a:	2000      	movs	r0, #0
 1006f5c:	e7db      	b.n	1006f16 <le_gen_dhkey+0x12>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1006f5e:	e8d4 3fef 	ldaex	r3, [r4]
 1006f62:	f023 0304 	bic.w	r3, r3, #4
 1006f66:	e8c4 3fe2 	stlex	r2, r3, [r4]
 1006f6a:	2a00      	cmp	r2, #0
 1006f6c:	d0f2      	beq.n	1006f54 <le_gen_dhkey+0x50>
 1006f6e:	e7f6      	b.n	1006f5e <le_gen_dhkey+0x5a>
		return BT_HCI_ERR_INVALID_PARAM;
 1006f70:	2012      	movs	r0, #18
 1006f72:	e7d0      	b.n	1006f16 <le_gen_dhkey+0x12>
 1006f74:	21004684 	.word	0x21004684
 1006f78:	210082c5 	.word	0x210082c5
 1006f7c:	210082e5 	.word	0x210082e5
 1006f80:	21000308 	.word	0x21000308

01006f84 <bt_hci_ecc_send>:

	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
}

int bt_hci_ecc_send(struct net_buf *buf)
{
 1006f84:	b570      	push	{r4, r5, r6, lr}
 *
 *  @return The BT_* type to of the buffer
 */
static inline enum bt_buf_type bt_buf_get_type(struct net_buf *buf)
{
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
 1006f86:	7e06      	ldrb	r6, [r0, #24]
 1006f88:	4604      	mov	r4, r0
	if (bt_buf_get_type(buf) == BT_BUF_CMD) {
 1006f8a:	b976      	cbnz	r6, 1006faa <bt_hci_ecc_send+0x26>
		struct bt_hci_cmd_hdr *chdr = (void *)buf->data;

		switch (sys_le16_to_cpu(chdr->opcode)) {
 1006f8c:	f242 0226 	movw	r2, #8230	; 0x2026
		struct bt_hci_cmd_hdr *chdr = (void *)buf->data;
 1006f90:	68c3      	ldr	r3, [r0, #12]
		switch (sys_le16_to_cpu(chdr->opcode)) {
 1006f92:	881d      	ldrh	r5, [r3, #0]
 1006f94:	4295      	cmp	r5, r2
 1006f96:	d03e      	beq.n	1007016 <bt_hci_ecc_send+0x92>
 1006f98:	d80f      	bhi.n	1006fba <bt_hci_ecc_send+0x36>
 1006f9a:	f242 0201 	movw	r2, #8193	; 0x2001
 1006f9e:	4295      	cmp	r5, r2
 1006fa0:	d048      	beq.n	1007034 <bt_hci_ecc_send+0xb0>
 1006fa2:	f242 0325 	movw	r3, #8229	; 0x2025
 1006fa6:	429d      	cmp	r5, r3
 1006fa8:	d013      	beq.n	1006fd2 <bt_hci_ecc_send+0x4e>
		default:
			break;
		}
	}

	return bt_dev.drv->send(buf);
 1006faa:	4b27      	ldr	r3, [pc, #156]	; (1007048 <bt_hci_ecc_send+0xc4>)
 1006fac:	4620      	mov	r0, r4
}
 1006fae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_dev.drv->send(buf);
 1006fb2:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
 1006fb6:	695b      	ldr	r3, [r3, #20]
 1006fb8:	4718      	bx	r3
		switch (sys_le16_to_cpu(chdr->opcode)) {
 1006fba:	f242 035e 	movw	r3, #8286	; 0x205e
 1006fbe:	429d      	cmp	r5, r3
 1006fc0:	d1f3      	bne.n	1006faa <bt_hci_ecc_send+0x26>
 *
 * @return New beginning of the buffer data.
 */
static inline void *net_buf_pull(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull(&buf->b, len);
 1006fc2:	2103      	movs	r1, #3
 1006fc4:	300c      	adds	r0, #12
 1006fc6:	f017 f92b 	bl	101e220 <net_buf_simple_pull>
	cmd = (void *)buf->data;
 1006fca:	68e0      	ldr	r0, [r4, #12]
	status = le_gen_dhkey(cmd->key, cmd->key_type);
 1006fcc:	f890 1040 	ldrb.w	r1, [r0, #64]	; 0x40
 1006fd0:	e027      	b.n	1007022 <bt_hci_ecc_send+0x9e>
 1006fd2:	2103      	movs	r1, #3
 1006fd4:	300c      	adds	r0, #12
 1006fd6:	f017 f923 	bl	101e220 <net_buf_simple_pull>
	net_buf_unref(buf);
 1006fda:	4620      	mov	r0, r4
 1006fdc:	f017 f800 	bl	101dfe0 <net_buf_unref>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1006fe0:	4b1a      	ldr	r3, [pc, #104]	; (100704c <bt_hci_ecc_send+0xc8>)
 1006fe2:	e8d3 2faf 	lda	r2, [r3]
	if (atomic_test_bit(flags, PENDING_DHKEY)) {
 1006fe6:	0792      	lsls	r2, r2, #30
 1006fe8:	d507      	bpl.n	1006ffa <bt_hci_ecc_send+0x76>
		status = BT_HCI_ERR_CMD_DISALLOWED;
 1006fea:	260c      	movs	r6, #12
	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
 1006fec:	4631      	mov	r1, r6
 1006fee:	f242 0025 	movw	r0, #8229	; 0x2025
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
 1006ff2:	f01f fd09 	bl	1026a08 <send_cmd_status>
}
 1006ff6:	2000      	movs	r0, #0
 1006ff8:	bd70      	pop	{r4, r5, r6, pc}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1006ffa:	e8d3 2fef 	ldaex	r2, [r3]
 1006ffe:	f042 0101 	orr.w	r1, r2, #1
 1007002:	e8c3 1fe0 	stlex	r0, r1, [r3]
 1007006:	2800      	cmp	r0, #0
 1007008:	d1f7      	bne.n	1006ffa <bt_hci_ecc_send+0x76>
	} else if (atomic_test_and_set_bit(flags, PENDING_PUB_KEY)) {
 100700a:	07d3      	lsls	r3, r2, #31
 100700c:	d4ed      	bmi.n	1006fea <bt_hci_ecc_send+0x66>
		bt_long_wq_submit(&ecc_work);
 100700e:	4810      	ldr	r0, [pc, #64]	; (1007050 <bt_hci_ecc_send+0xcc>)
 1007010:	f000 f976 	bl	1007300 <bt_long_wq_submit>
		status = BT_HCI_ERR_SUCCESS;
 1007014:	e7ea      	b.n	1006fec <bt_hci_ecc_send+0x68>
 1007016:	2103      	movs	r1, #3
 1007018:	300c      	adds	r0, #12
 100701a:	f017 f901 	bl	101e220 <net_buf_simple_pull>
	status = le_gen_dhkey(cmd->key, BT_HCI_LE_KEY_TYPE_GENERATED);
 100701e:	4631      	mov	r1, r6
 1007020:	68e0      	ldr	r0, [r4, #12]
 1007022:	f7ff ff6f 	bl	1006f04 <le_gen_dhkey>
 1007026:	4606      	mov	r6, r0
	net_buf_unref(buf);
 1007028:	4620      	mov	r0, r4
 100702a:	f016 ffd9 	bl	101dfe0 <net_buf_unref>
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
 100702e:	4631      	mov	r1, r6
 1007030:	4628      	mov	r0, r5
 1007032:	e7de      	b.n	1006ff2 <bt_hci_ecc_send+0x6e>
	cmd->events[0] &= ~0x80; /* LE Read Local P-256 PKey Compl */
 1007034:	78da      	ldrb	r2, [r3, #3]
 1007036:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 100703a:	70da      	strb	r2, [r3, #3]
	cmd->events[1] &= ~0x01; /* LE Generate DHKey Compl Event */
 100703c:	791a      	ldrb	r2, [r3, #4]
 100703e:	f022 0201 	bic.w	r2, r2, #1
 1007042:	711a      	strb	r2, [r3, #4]
}
 1007044:	e7b1      	b.n	1006faa <bt_hci_ecc_send+0x26>
 1007046:	bf00      	nop
 1007048:	21000000 	.word	0x21000000
 100704c:	21004684 	.word	0x21004684
 1007050:	21000308 	.word	0x21000308

01007054 <save_id>:
}

#define ID_DATA_LEN(array) (bt_dev.id_count * sizeof(array[0]))

static void save_id(struct k_work *work)
{
 1007054:	b590      	push	{r4, r7, lr}
 1007056:	b087      	sub	sp, #28
	int err;
	LOG_INF("Saving ID");
 1007058:	466c      	mov	r4, sp
{
 100705a:	af00      	add	r7, sp, #0
	LOG_INF("Saving ID");
 100705c:	4b12      	ldr	r3, [pc, #72]	; (10070a8 <save_id+0x54>)
 100705e:	617b      	str	r3, [r7, #20]
 1007060:	2302      	movs	r3, #2
 1007062:	613b      	str	r3, [r7, #16]
 1007064:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
 1007068:	4810      	ldr	r0, [pc, #64]	; (10070ac <save_id+0x58>)
 100706a:	f107 0210 	add.w	r2, r7, #16
 100706e:	2300      	movs	r3, #0
 1007070:	f7fd fb4a 	bl	1004708 <z_impl_z_log_msg_static_create>
	err = settings_save_one("bt/id", &bt_dev.id_addr,
				ID_DATA_LEN(bt_dev.id_addr));
 1007074:	490e      	ldr	r1, [pc, #56]	; (10070b0 <save_id+0x5c>)
	err = settings_save_one("bt/id", &bt_dev.id_addr,
 1007076:	480f      	ldr	r0, [pc, #60]	; (10070b4 <save_id+0x60>)
				ID_DATA_LEN(bt_dev.id_addr));
 1007078:	79ca      	ldrb	r2, [r1, #7]
	err = settings_save_one("bt/id", &bt_dev.id_addr,
 100707a:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 100707e:	f7fe fa69 	bl	1005554 <settings_save_one>
	if (err) {
 1007082:	b170      	cbz	r0, 10070a2 <save_id+0x4e>
		LOG_ERR("Failed to save ID (err %d)", err);
 1007084:	b088      	sub	sp, #32
 1007086:	466a      	mov	r2, sp
 1007088:	4b0b      	ldr	r3, [pc, #44]	; (10070b8 <save_id+0x64>)
 100708a:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100708e:	2303      	movs	r3, #3
 1007090:	f842 3f10 	str.w	r3, [r2, #16]!
 1007094:	2300      	movs	r3, #0
 1007096:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100709a:	4804      	ldr	r0, [pc, #16]	; (10070ac <save_id+0x58>)
 100709c:	f7fd fb34 	bl	1004708 <z_impl_z_log_msg_static_create>
 10070a0:	46a5      	mov	sp, r4
	err = settings_save_one("bt/irk", bt_dev.irk, ID_DATA_LEN(bt_dev.irk));
	if (err) {
		LOG_ERR("Failed to save IRK (err %d)", err);
	}
#endif
}
 10070a2:	371c      	adds	r7, #28
 10070a4:	46bd      	mov	sp, r7
 10070a6:	bd90      	pop	{r4, r7, pc}
 10070a8:	0102cd1f 	.word	0x0102cd1f
 10070ac:	010299dc 	.word	0x010299dc
 10070b0:	21000000 	.word	0x21000000
 10070b4:	0102cd29 	.word	0x0102cd29
 10070b8:	0102cd2f 	.word	0x0102cd2f

010070bc <set_setting>:
{
 10070bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 10070be:	4605      	mov	r5, r0
 10070c0:	4616      	mov	r6, r2
 10070c2:	461f      	mov	r7, r3
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 10070c4:	4c28      	ldr	r4, [pc, #160]	; (1007168 <set_setting+0xac>)
 10070c6:	b089      	sub	sp, #36	; 0x24
 10070c8:	e8d4 3faf 	lda	r3, [r4]
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
 10070cc:	07d9      	lsls	r1, r3, #31
 10070ce:	d529      	bpl.n	1007124 <set_setting+0x68>
	if (!name) {
 10070d0:	b968      	cbnz	r0, 10070ee <set_setting+0x32>
		LOG_ERR("Insufficient number of arguments");
 10070d2:	4b26      	ldr	r3, [pc, #152]	; (100716c <set_setting+0xb0>)
 10070d4:	9307      	str	r3, [sp, #28]
 10070d6:	2302      	movs	r3, #2
 10070d8:	9306      	str	r3, [sp, #24]
 10070da:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10070de:	4603      	mov	r3, r0
 10070e0:	aa06      	add	r2, sp, #24
 10070e2:	4823      	ldr	r0, [pc, #140]	; (1007170 <set_setting+0xb4>)
 10070e4:	f7fd fb10 	bl	1004708 <z_impl_z_log_msg_static_create>
		return -ENOENT;
 10070e8:	f06f 0001 	mvn.w	r0, #1
 10070ec:	e01b      	b.n	1007126 <set_setting+0x6a>
	len = settings_name_next(name, &next);
 10070ee:	a901      	add	r1, sp, #4
 10070f0:	f01e f968 	bl	10253c4 <settings_name_next>
	if (!strncmp(name, "id", len)) {
 10070f4:	491f      	ldr	r1, [pc, #124]	; (1007174 <set_setting+0xb8>)
	len = settings_name_next(name, &next);
 10070f6:	4602      	mov	r2, r0
	if (!strncmp(name, "id", len)) {
 10070f8:	4628      	mov	r0, r5
 10070fa:	f01f fc18 	bl	102692e <strncmp>
 10070fe:	4603      	mov	r3, r0
 1007100:	2800      	cmp	r0, #0
 1007102:	d1f1      	bne.n	10070e8 <set_setting+0x2c>
 1007104:	e8d4 2faf 	lda	r2, [r4]
		if (atomic_test_bit(bt_dev.flags, BT_DEV_PRESET_ID)) {
 1007108:	f3c2 05c0 	ubfx	r5, r2, #3, #1
 100710c:	0712      	lsls	r2, r2, #28
 100710e:	d50c      	bpl.n	100712a <set_setting+0x6e>
			LOG_WRN("Ignoring identities stored in flash");
 1007110:	4a19      	ldr	r2, [pc, #100]	; (1007178 <set_setting+0xbc>)
 1007112:	9207      	str	r2, [sp, #28]
 1007114:	2202      	movs	r2, #2
 1007116:	9206      	str	r2, [sp, #24]
 1007118:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100711c:	4814      	ldr	r0, [pc, #80]	; (1007170 <set_setting+0xb4>)
 100711e:	aa06      	add	r2, sp, #24
 1007120:	f7fd faf2 	bl	1004708 <z_impl_z_log_msg_static_create>
		return 0;
 1007124:	2000      	movs	r0, #0
}
 1007126:	b009      	add	sp, #36	; 0x24
 1007128:	bdf0      	pop	{r4, r5, r6, r7, pc}
		len = read_cb(cb_arg, &bt_dev.id_addr, sizeof(bt_dev.id_addr));
 100712a:	3ccc      	subs	r4, #204	; 0xcc
 100712c:	2207      	movs	r2, #7
 100712e:	4621      	mov	r1, r4
 1007130:	4638      	mov	r0, r7
 1007132:	47b0      	blx	r6
		if (len < sizeof(bt_dev.id_addr[0])) {
 1007134:	2806      	cmp	r0, #6
 1007136:	d811      	bhi.n	100715c <set_setting+0xa0>
				LOG_ERR("Invalid length ID address in storage");
 1007138:	4b10      	ldr	r3, [pc, #64]	; (100717c <set_setting+0xc0>)
 100713a:	9307      	str	r3, [sp, #28]
 100713c:	2302      	movs	r3, #2
 100713e:	9306      	str	r3, [sp, #24]
 1007140:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1007144:	462b      	mov	r3, r5
 1007146:	480a      	ldr	r0, [pc, #40]	; (1007170 <set_setting+0xb4>)
 1007148:	aa06      	add	r2, sp, #24
 100714a:	f7fd fadd 	bl	1004708 <z_impl_z_log_msg_static_create>
			(void)memset(bt_dev.id_addr, 0,
 100714e:	2207      	movs	r2, #7
 1007150:	4629      	mov	r1, r5
 1007152:	4620      	mov	r0, r4
 1007154:	f01f fc19 	bl	102698a <memset>
			bt_dev.id_count = 0U;
 1007158:	71e5      	strb	r5, [r4, #7]
 100715a:	e7e3      	b.n	1007124 <set_setting+0x68>
			bt_dev.id_count = len / sizeof(bt_dev.id_addr[0]);
 100715c:	2307      	movs	r3, #7
 100715e:	fbb0 f0f3 	udiv	r0, r0, r3
 1007162:	71e0      	strb	r0, [r4, #7]
			for (i = 0; i < bt_dev.id_count; i++) {
 1007164:	e7de      	b.n	1007124 <set_setting+0x68>
 1007166:	bf00      	nop
 1007168:	210000cc 	.word	0x210000cc
 100716c:	0102cd4a 	.word	0x0102cd4a
 1007170:	010299dc 	.word	0x010299dc
 1007174:	0102b419 	.word	0x0102b419
 1007178:	0102cd6b 	.word	0x0102cd6b
 100717c:	0102cd8f 	.word	0x0102cd8f

01007180 <bt_settings_encode_key>:
{
 1007180:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1007184:	b088      	sub	sp, #32
 1007186:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		snprintk(path, path_size,
 100718a:	799c      	ldrb	r4, [r3, #6]
 100718c:	795d      	ldrb	r5, [r3, #5]
 100718e:	791e      	ldrb	r6, [r3, #4]
 1007190:	78df      	ldrb	r7, [r3, #3]
 1007192:	f893 c002 	ldrb.w	ip, [r3, #2]
 1007196:	f893 e001 	ldrb.w	lr, [r3, #1]
 100719a:	781b      	ldrb	r3, [r3, #0]
	if (key) {
 100719c:	f1b8 0f00 	cmp.w	r8, #0
 10071a0:	d00e      	beq.n	10071c0 <bt_settings_encode_key+0x40>
		snprintk(path, path_size,
 10071a2:	e9cd 3806 	strd	r3, r8, [sp, #24]
 10071a6:	e9cd ce04 	strd	ip, lr, [sp, #16]
 10071aa:	4613      	mov	r3, r2
 10071ac:	e9cd 6702 	strd	r6, r7, [sp, #8]
 10071b0:	e9cd 4500 	strd	r4, r5, [sp]
 10071b4:	4a08      	ldr	r2, [pc, #32]	; (10071d8 <bt_settings_encode_key+0x58>)
 10071b6:	f01d fb13 	bl	10247e0 <snprintk>
}
 10071ba:	b008      	add	sp, #32
 10071bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		snprintk(path, path_size,
 10071c0:	e9cd e305 	strd	lr, r3, [sp, #20]
 10071c4:	e9cd 7c03 	strd	r7, ip, [sp, #12]
 10071c8:	4613      	mov	r3, r2
 10071ca:	e9cd 5601 	strd	r5, r6, [sp, #4]
 10071ce:	4a03      	ldr	r2, [pc, #12]	; (10071dc <bt_settings_encode_key+0x5c>)
 10071d0:	9400      	str	r4, [sp, #0]
 10071d2:	f01d fb05 	bl	10247e0 <snprintk>
}
 10071d6:	e7f0      	b.n	10071ba <bt_settings_encode_key+0x3a>
 10071d8:	0102cdb4 	.word	0x0102cdb4
 10071dc:	0102cdd8 	.word	0x0102cdd8

010071e0 <bt_settings_save_id>:

K_WORK_DEFINE(save_id_work, save_id);

void bt_settings_save_id(void)
{
	k_work_submit(&save_id_work);
 10071e0:	4801      	ldr	r0, [pc, #4]	; (10071e8 <bt_settings_save_id+0x8>)
 10071e2:	f01a be0b 	b.w	1021dfc <k_work_submit>
 10071e6:	bf00      	nop
 10071e8:	21000318 	.word	0x21000318

010071ec <commit_settings>:
}

static int commit_settings(void)
{
 10071ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10071f0:	4d1d      	ldr	r5, [pc, #116]	; (1007268 <commit_settings+0x7c>)
 10071f2:	b086      	sub	sp, #24
 10071f4:	e8d5 3faf 	lda	r3, [r5]
	int err;

	LOG_DBG("");

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
 10071f8:	f013 0f01 	tst.w	r3, #1
 10071fc:	462f      	mov	r7, r5
 10071fe:	d031      	beq.n	1007264 <commit_settings+0x78>
#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	if (bt_dev.name[0] == '\0') {
		bt_set_name(CONFIG_BT_DEVICE_NAME);
	}
#endif
	if (!bt_dev.id_count) {
 1007200:	f815 6cc5 	ldrb.w	r6, [r5, #-197]
 1007204:	f1a5 08cc 	sub.w	r8, r5, #204	; 0xcc
 1007208:	b9d6      	cbnz	r6, 1007240 <commit_settings+0x54>
		err = bt_setup_public_id_addr();
 100720a:	f001 ff05 	bl	1009018 <bt_setup_public_id_addr>
		if (err) {
 100720e:	4604      	mov	r4, r0
 1007210:	b170      	cbz	r0, 1007230 <commit_settings+0x44>
	}

	if (!bt_dev.id_count) {
		err = bt_setup_random_id_addr();
		if (err) {
			LOG_ERR("Unable to setup an identity address");
 1007212:	4b16      	ldr	r3, [pc, #88]	; (100726c <commit_settings+0x80>)
 1007214:	9305      	str	r3, [sp, #20]
 1007216:	2302      	movs	r3, #2
 1007218:	9304      	str	r3, [sp, #16]
 100721a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100721e:	4633      	mov	r3, r6
 1007220:	4813      	ldr	r0, [pc, #76]	; (1007270 <commit_settings+0x84>)
 1007222:	aa04      	add	r2, sp, #16
 1007224:	f7fd fa70 	bl	1004708 <z_impl_z_log_msg_static_create>
		LOG_DBG("Storing Identity Information");
		bt_settings_save_id();
	}

	return 0;
}
 1007228:	4620      	mov	r0, r4
 100722a:	b006      	add	sp, #24
 100722c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!bt_dev.id_count) {
 1007230:	f898 6007 	ldrb.w	r6, [r8, #7]
 1007234:	b926      	cbnz	r6, 1007240 <commit_settings+0x54>
		err = bt_setup_random_id_addr();
 1007236:	f001 ff51 	bl	10090dc <bt_setup_random_id_addr>
		if (err) {
 100723a:	4604      	mov	r4, r0
 100723c:	2800      	cmp	r0, #0
 100723e:	d1e8      	bne.n	1007212 <commit_settings+0x26>
 1007240:	e8d5 3faf 	lda	r3, [r5]
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
 1007244:	075a      	lsls	r2, r3, #29
 1007246:	d401      	bmi.n	100724c <commit_settings+0x60>
		bt_finalize_init();
 1007248:	f001 faec 	bl	1008824 <bt_finalize_init>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 100724c:	e8d7 3fef 	ldaex	r3, [r7]
 1007250:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 1007254:	e8c7 2fe1 	stlex	r1, r2, [r7]
 1007258:	2900      	cmp	r1, #0
 100725a:	d1f7      	bne.n	100724c <commit_settings+0x60>
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_STORE_ID)) {
 100725c:	03db      	lsls	r3, r3, #15
 100725e:	d501      	bpl.n	1007264 <commit_settings+0x78>
		bt_settings_save_id();
 1007260:	f7ff ffbe 	bl	10071e0 <bt_settings_save_id>
		return 0;
 1007264:	2400      	movs	r4, #0
 1007266:	e7df      	b.n	1007228 <commit_settings+0x3c>
 1007268:	210000cc 	.word	0x210000cc
 100726c:	0102cdf9 	.word	0x0102cdf9
 1007270:	010299dc 	.word	0x010299dc

01007274 <bt_settings_init>:

SETTINGS_STATIC_HANDLER_DEFINE(bt, "bt", NULL, set_setting, commit_settings, NULL);

int bt_settings_init(void)
{
 1007274:	b5b0      	push	{r4, r5, r7, lr}
 1007276:	af00      	add	r7, sp, #0
	int err;

	LOG_DBG("");

	err = settings_subsys_init();
 1007278:	f7fe fafe 	bl	1005878 <settings_subsys_init>
	if (err) {
 100727c:	4604      	mov	r4, r0
 100727e:	b178      	cbz	r0, 10072a0 <bt_settings_init+0x2c>
		LOG_ERR("settings_subsys_init failed (err %d)", err);
 1007280:	466d      	mov	r5, sp
 1007282:	b088      	sub	sp, #32
 1007284:	466a      	mov	r2, sp
 1007286:	4b08      	ldr	r3, [pc, #32]	; (10072a8 <bt_settings_init+0x34>)
 1007288:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100728c:	2303      	movs	r3, #3
 100728e:	f842 3f10 	str.w	r3, [r2, #16]!
 1007292:	2300      	movs	r3, #0
 1007294:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1007298:	4804      	ldr	r0, [pc, #16]	; (10072ac <bt_settings_init+0x38>)
 100729a:	f7fd fa35 	bl	1004708 <z_impl_z_log_msg_static_create>
 100729e:	46ad      	mov	sp, r5
		return err;
	}

	return 0;
}
 10072a0:	4620      	mov	r0, r4
 10072a2:	46bd      	mov	sp, r7
 10072a4:	bdb0      	pop	{r4, r5, r7, pc}
 10072a6:	bf00      	nop
 10072a8:	0102ce1d 	.word	0x0102ce1d
 10072ac:	010299dc 	.word	0x010299dc

010072b0 <long_wq_init>:
{
	return k_work_submit_to_queue(&bt_long_wq, work);
}

static int long_wq_init(const struct device *d)
{
 10072b0:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(d);

	const struct k_work_queue_config cfg = {.name = "BT_LW_WQ"};
 10072b2:	2400      	movs	r4, #0

	k_work_queue_init(&bt_long_wq);
 10072b4:	4d09      	ldr	r5, [pc, #36]	; (10072dc <long_wq_init+0x2c>)
	const struct k_work_queue_config cfg = {.name = "BT_LW_WQ"};
 10072b6:	4b0a      	ldr	r3, [pc, #40]	; (10072e0 <long_wq_init+0x30>)
{
 10072b8:	b085      	sub	sp, #20
	k_work_queue_init(&bt_long_wq);
 10072ba:	4628      	mov	r0, r5
	const struct k_work_queue_config cfg = {.name = "BT_LW_WQ"};
 10072bc:	9302      	str	r3, [sp, #8]
 10072be:	9403      	str	r4, [sp, #12]
	k_work_queue_init(&bt_long_wq);
 10072c0:	f01a fda2 	bl	1021e08 <k_work_queue_init>

	k_work_queue_start(&bt_long_wq, bt_lw_stack_area,
 10072c4:	ab02      	add	r3, sp, #8
 10072c6:	4628      	mov	r0, r5
 10072c8:	9300      	str	r3, [sp, #0]
 10072ca:	f44f 62a3 	mov.w	r2, #1304	; 0x518
 10072ce:	230a      	movs	r3, #10
 10072d0:	4904      	ldr	r1, [pc, #16]	; (10072e4 <long_wq_init+0x34>)
 10072d2:	f01a fdb3 	bl	1021e3c <k_work_queue_start>
			   K_THREAD_STACK_SIZEOF(bt_lw_stack_area),
			   CONFIG_BT_LONG_WQ_PRIO, &cfg);

	return 0;
}
 10072d6:	4620      	mov	r0, r4
 10072d8:	b005      	add	sp, #20
 10072da:	bd30      	pop	{r4, r5, pc}
 10072dc:	210014a8 	.word	0x210014a8
 10072e0:	0102ce4e 	.word	0x0102ce4e
 10072e4:	21009770 	.word	0x21009770

010072e8 <bt_long_wq_schedule>:
{
 10072e8:	4601      	mov	r1, r0
	return k_work_schedule_for_queue(&bt_long_wq, dwork, timeout);
 10072ea:	4801      	ldr	r0, [pc, #4]	; (10072f0 <bt_long_wq_schedule+0x8>)
 10072ec:	f01a be3a 	b.w	1021f64 <k_work_schedule_for_queue>
 10072f0:	210014a8 	.word	0x210014a8

010072f4 <bt_long_wq_reschedule>:
{
 10072f4:	4601      	mov	r1, r0
	return k_work_reschedule_for_queue(&bt_long_wq, dwork, timeout);
 10072f6:	4801      	ldr	r0, [pc, #4]	; (10072fc <bt_long_wq_reschedule+0x8>)
 10072f8:	f01a beb0 	b.w	102205c <k_work_reschedule_for_queue>
 10072fc:	210014a8 	.word	0x210014a8

01007300 <bt_long_wq_submit>:
{
 1007300:	4601      	mov	r1, r0
	return k_work_submit_to_queue(&bt_long_wq, work);
 1007302:	4801      	ldr	r0, [pc, #4]	; (1007308 <bt_long_wq_submit+0x8>)
 1007304:	f022 b86a 	b.w	10293dc <k_work_submit_to_queue>
 1007308:	210014a8 	.word	0x210014a8

0100730c <uuid_to_uuid128>:
	.val = { BT_UUID_128_ENCODE(
		0x00000000, 0x0000, 0x1000, 0x8000, 0x00805F9B34FB) }
};

static void uuid_to_uuid128(const struct bt_uuid *src, struct bt_uuid_128 *dst)
{
 100730c:	4603      	mov	r3, r0
 100730e:	b430      	push	{r4, r5}
	switch (src->type) {
 1007310:	781a      	ldrb	r2, [r3, #0]
{
 1007312:	4608      	mov	r0, r1
	switch (src->type) {
 1007314:	2a01      	cmp	r2, #1
 1007316:	d013      	beq.n	1007340 <uuid_to_uuid128+0x34>
 1007318:	2a02      	cmp	r2, #2
 100731a:	d026      	beq.n	100736a <uuid_to_uuid128+0x5e>
 100731c:	b972      	cbnz	r2, 100733c <uuid_to_uuid128+0x30>
	case BT_UUID_TYPE_16:
		*dst = uuid128_base;
 100731e:	4a15      	ldr	r2, [pc, #84]	; (1007374 <uuid_to_uuid128+0x68>)
 1007320:	f102 0410 	add.w	r4, r2, #16
 1007324:	f852 5b04 	ldr.w	r5, [r2], #4
 1007328:	42a2      	cmp	r2, r4
 100732a:	f841 5b04 	str.w	r5, [r1], #4
 100732e:	d1f9      	bne.n	1007324 <uuid_to_uuid128+0x18>
 1007330:	7812      	ldrb	r2, [r2, #0]
 1007332:	700a      	strb	r2, [r1, #0]
		sys_put_le16(BT_UUID_16(src)->val,
 1007334:	885b      	ldrh	r3, [r3, #2]
	dst[0] = val;
 1007336:	7343      	strb	r3, [r0, #13]
	dst[1] = val >> 8;
 1007338:	0a1b      	lsrs	r3, r3, #8
 100733a:	7383      	strb	r3, [r0, #14]
		return;
	case BT_UUID_TYPE_128:
		memcpy(dst, src, sizeof(*dst));
		return;
	}
}
 100733c:	bc30      	pop	{r4, r5}
 100733e:	4770      	bx	lr
		*dst = uuid128_base;
 1007340:	4a0c      	ldr	r2, [pc, #48]	; (1007374 <uuid_to_uuid128+0x68>)
 1007342:	f102 0410 	add.w	r4, r2, #16
 1007346:	f852 5b04 	ldr.w	r5, [r2], #4
 100734a:	42a2      	cmp	r2, r4
 100734c:	f841 5b04 	str.w	r5, [r1], #4
 1007350:	d1f9      	bne.n	1007346 <uuid_to_uuid128+0x3a>
 1007352:	7812      	ldrb	r2, [r2, #0]
 1007354:	700a      	strb	r2, [r1, #0]
		sys_put_le32(BT_UUID_32(src)->val,
 1007356:	685b      	ldr	r3, [r3, #4]
 1007358:	f3c3 2207 	ubfx	r2, r3, #8, #8
	dst[0] = val;
 100735c:	7343      	strb	r3, [r0, #13]
	sys_put_le16(val >> 16, &dst[2]);
 100735e:	0c1b      	lsrs	r3, r3, #16
	dst[0] = val;
 1007360:	73c3      	strb	r3, [r0, #15]
	dst[1] = val >> 8;
 1007362:	0a1b      	lsrs	r3, r3, #8
 1007364:	7382      	strb	r2, [r0, #14]
 1007366:	7403      	strb	r3, [r0, #16]
}
 1007368:	e7e8      	b.n	100733c <uuid_to_uuid128+0x30>
		memcpy(dst, src, sizeof(*dst));
 100736a:	2211      	movs	r2, #17
}
 100736c:	bc30      	pop	{r4, r5}
		memcpy(dst, src, sizeof(*dst));
 100736e:	4619      	mov	r1, r3
 1007370:	f01f bb00 	b.w	1026974 <memcpy>
 1007374:	0102ce57 	.word	0x0102ce57

01007378 <bt_buf_get_rx>:

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, k_timeout_t timeout)
{
	struct net_buf *buf;

	__ASSERT(type == BT_BUF_EVT || type == BT_BUF_ACL_IN ||
 1007378:	2805      	cmp	r0, #5
{
 100737a:	b538      	push	{r3, r4, r5, lr}
 100737c:	4605      	mov	r5, r0
 100737e:	d803      	bhi.n	1007388 <bt_buf_get_rx+0x10>
 1007380:	212a      	movs	r1, #42	; 0x2a
 1007382:	40c1      	lsrs	r1, r0
 1007384:	07c9      	lsls	r1, r1, #31
 1007386:	d40c      	bmi.n	10073a2 <bt_buf_get_rx+0x2a>
	__ASSERT(type == BT_BUF_EVT || type == BT_BUF_ACL_IN ||
 1007388:	490c      	ldr	r1, [pc, #48]	; (10073bc <bt_buf_get_rx+0x44>)
 100738a:	233d      	movs	r3, #61	; 0x3d
 100738c:	4a0c      	ldr	r2, [pc, #48]	; (10073c0 <bt_buf_get_rx+0x48>)
 100738e:	480d      	ldr	r0, [pc, #52]	; (10073c4 <bt_buf_get_rx+0x4c>)
 1007390:	f01d fc21 	bl	1024bd6 <assert_print>
 1007394:	480c      	ldr	r0, [pc, #48]	; (10073c8 <bt_buf_get_rx+0x50>)
 1007396:	f01d fc1e 	bl	1024bd6 <assert_print>
 100739a:	213d      	movs	r1, #61	; 0x3d
 100739c:	4808      	ldr	r0, [pc, #32]	; (10073c0 <bt_buf_get_rx+0x48>)
 100739e:	f01d fc13 	bl	1024bc8 <assert_post_action>
	return net_buf_alloc_fixed(pool, timeout);
 10073a2:	480a      	ldr	r0, [pc, #40]	; (10073cc <bt_buf_get_rx+0x54>)
 10073a4:	f021 fcd0 	bl	1028d48 <net_buf_alloc_fixed>
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
#endif

	if (buf) {
 10073a8:	4604      	mov	r4, r0
 10073aa:	b120      	cbz	r0, 10073b6 <bt_buf_get_rx+0x3e>
	net_buf_simple_reserve(&buf->b, reserve);
 10073ac:	2100      	movs	r1, #0
 10073ae:	300c      	adds	r0, #12
 10073b0:	f016 fdca 	bl	101df48 <net_buf_simple_reserve>
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
 10073b4:	7625      	strb	r5, [r4, #24]
		net_buf_reserve(buf, BT_BUF_RESERVE);
		bt_buf_set_type(buf, type);
	}

	return buf;
}
 10073b6:	4620      	mov	r0, r4
 10073b8:	bd38      	pop	{r3, r4, r5, pc}
 10073ba:	bf00      	nop
 10073bc:	0102ce97 	.word	0x0102ce97
 10073c0:	0102ce68 	.word	0x0102ce68
 10073c4:	0102b695 	.word	0x0102b695
 10073c8:	0102cedc 	.word	0x0102cedc
 10073cc:	21000e80 	.word	0x21000e80

010073d0 <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(k_timeout_t timeout)
{
 10073d0:	b510      	push	{r4, lr}
 10073d2:	460b      	mov	r3, r1
	struct net_buf *buf;

	if (bt_dev.sent_cmd) {
 10073d4:	490a      	ldr	r1, [pc, #40]	; (1007400 <bt_buf_get_cmd_complete+0x30>)
{
 10073d6:	4602      	mov	r2, r0
	if (bt_dev.sent_cmd) {
 10073d8:	f8d1 0138 	ldr.w	r0, [r1, #312]	; 0x138
 10073dc:	b920      	cbnz	r0, 10073e8 <bt_buf_get_cmd_complete+0x18>

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
}
 10073de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
 10073e2:	2001      	movs	r0, #1
 10073e4:	f7ff bfc8 	b.w	1007378 <bt_buf_get_rx>
		buf = net_buf_ref(bt_dev.sent_cmd);
 10073e8:	f016 fe3c 	bl	101e064 <net_buf_ref>
 10073ec:	2301      	movs	r3, #1
		buf->len = 0U;
 10073ee:	2100      	movs	r1, #0
		buf = net_buf_ref(bt_dev.sent_cmd);
 10073f0:	4604      	mov	r4, r0
 10073f2:	7603      	strb	r3, [r0, #24]
		buf->len = 0U;
 10073f4:	8201      	strh	r1, [r0, #16]
 10073f6:	300c      	adds	r0, #12
 10073f8:	f016 fda6 	bl	101df48 <net_buf_simple_reserve>
}
 10073fc:	4620      	mov	r0, r4
 10073fe:	bd10      	pop	{r4, pc}
 1007400:	21000000 	.word	0x21000000

01007404 <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(uint8_t evt, bool discardable,
			       k_timeout_t timeout)
{
 1007404:	b570      	push	{r4, r5, r6, lr}
 1007406:	4604      	mov	r4, r0
	switch (evt) {
 1007408:	2c0f      	cmp	r4, #15
{
 100740a:	460d      	mov	r5, r1
 100740c:	4610      	mov	r0, r2
 100740e:	4619      	mov	r1, r3
	switch (evt) {
 1007410:	d805      	bhi.n	100741e <bt_buf_get_evt+0x1a>
 1007412:	2c0d      	cmp	r4, #13
 1007414:	d90d      	bls.n	1007432 <bt_buf_get_evt+0x2e>
			return buf;
		}

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
	}
}
 1007416:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_buf_get_cmd_complete(timeout);
 100741a:	f7ff bfd9 	b.w	10073d0 <bt_buf_get_cmd_complete>
	switch (evt) {
 100741e:	2c13      	cmp	r4, #19
 1007420:	d107      	bne.n	1007432 <bt_buf_get_evt+0x2e>
	return net_buf_alloc_fixed(pool, timeout);
 1007422:	480c      	ldr	r0, [pc, #48]	; (1007454 <bt_buf_get_evt+0x50>)
 1007424:	f021 fc90 	bl	1028d48 <net_buf_alloc_fixed>
			if (buf) {
 1007428:	4604      	mov	r4, r0
 100742a:	b938      	cbnz	r0, 100743c <bt_buf_get_evt+0x38>
{
 100742c:	2400      	movs	r4, #0
}
 100742e:	4620      	mov	r0, r4
 1007430:	bd70      	pop	{r4, r5, r6, pc}
 1007432:	4602      	mov	r2, r0
 1007434:	460b      	mov	r3, r1
		if (discardable) {
 1007436:	b145      	cbz	r5, 100744a <bt_buf_get_evt+0x46>
 1007438:	4807      	ldr	r0, [pc, #28]	; (1007458 <bt_buf_get_evt+0x54>)
 100743a:	e7f3      	b.n	1007424 <bt_buf_get_evt+0x20>
	net_buf_simple_reserve(&buf->b, reserve);
 100743c:	2100      	movs	r1, #0
 100743e:	300c      	adds	r0, #12
 1007440:	f016 fd82 	bl	101df48 <net_buf_simple_reserve>
 1007444:	2301      	movs	r3, #1
 1007446:	7623      	strb	r3, [r4, #24]
}
 1007448:	e7f1      	b.n	100742e <bt_buf_get_evt+0x2a>
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
 100744a:	2001      	movs	r0, #1
}
 100744c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
 1007450:	f7ff bf92 	b.w	1007378 <bt_buf_get_rx>
 1007454:	21000eb4 	.word	0x21000eb4
 1007458:	21000de4 	.word	0x21000de4

0100745c <hci_disconn_complete_prio>:
{
 100745c:	b538      	push	{r3, r4, r5, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
 100745e:	68c3      	ldr	r3, [r0, #12]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
 1007460:	f8b3 4001 	ldrh.w	r4, [r3, #1]
	if (evt->status) {
 1007464:	781b      	ldrb	r3, [r3, #0]
 1007466:	b98b      	cbnz	r3, 100748c <hci_disconn_complete_prio+0x30>
	conn = bt_conn_lookup_handle(handle);
 1007468:	4620      	mov	r0, r4
 100746a:	f002 fe47 	bl	100a0fc <bt_conn_lookup_handle>
	if (!conn) {
 100746e:	4605      	mov	r5, r0
 1007470:	b968      	cbnz	r0, 100748e <hci_disconn_complete_prio+0x32>
			disconnected_handles[i] = ~BT_ACL_HANDLE_MASK | handle;
 1007472:	ea6f 5004 	mvn.w	r0, r4, lsl #20
	if (!conn) {
 1007476:	2308      	movs	r3, #8
			disconnected_handles[i] = ~BT_ACL_HANDLE_MASK | handle;
 1007478:	ea6f 5010 	mvn.w	r0, r0, lsr #20
 100747c:	4a08      	ldr	r2, [pc, #32]	; (10074a0 <hci_disconn_complete_prio+0x44>)
		if (!disconnected_handles[i]) {
 100747e:	f832 1b02 	ldrh.w	r1, [r2], #2
 1007482:	b909      	cbnz	r1, 1007488 <hci_disconn_complete_prio+0x2c>
			disconnected_handles[i] = ~BT_ACL_HANDLE_MASK | handle;
 1007484:	f822 0c02 	strh.w	r0, [r2, #-2]
	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
 1007488:	3b01      	subs	r3, #1
 100748a:	d1f8      	bne.n	100747e <hci_disconn_complete_prio+0x22>
}
 100748c:	bd38      	pop	{r3, r4, r5, pc}
	bt_conn_set_state(conn, BT_CONN_DISCONNECT_COMPLETE);
 100748e:	2101      	movs	r1, #1
 1007490:	f002 fe3c 	bl	100a10c <bt_conn_set_state>
	bt_conn_unref(conn);
 1007494:	4628      	mov	r0, r5
}
 1007496:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_conn_unref(conn);
 100749a:	f002 bdff 	b.w	100a09c <bt_conn_unref>
 100749e:	bf00      	nop
 10074a0:	21008124 	.word	0x21008124

010074a4 <find_pending_connect.part.0>:
static struct bt_conn *find_pending_connect(uint8_t role, bt_addr_le_t *peer_addr)
 10074a4:	b510      	push	{r4, lr}
		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
 10074a6:	4c08      	ldr	r4, [pc, #32]	; (10074c8 <find_pending_connect.part.0+0x24>)
static struct bt_conn *find_pending_connect(uint8_t role, bt_addr_le_t *peer_addr)
 10074a8:	4601      	mov	r1, r0
		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
 10074aa:	2205      	movs	r2, #5
 10074ac:	f894 0067 	ldrb.w	r0, [r4, #103]	; 0x67
 10074b0:	f003 f944 	bl	100a73c <bt_conn_lookup_state_le>
		if (!conn) {
 10074b4:	b938      	cbnz	r0, 10074c6 <find_pending_connect.part.0+0x22>
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
 10074b6:	f894 0067 	ldrb.w	r0, [r4, #103]	; 0x67
 10074ba:	2204      	movs	r2, #4
}
 10074bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
 10074c0:	4902      	ldr	r1, [pc, #8]	; (10074cc <find_pending_connect.part.0+0x28>)
 10074c2:	f003 b93b 	b.w	100a73c <bt_conn_lookup_state_le>
}
 10074c6:	bd10      	pop	{r4, pc}
 10074c8:	21000000 	.word	0x21000000
 10074cc:	0102cb72 	.word	0x0102cb72

010074d0 <hci_data_buf_overflow>:
{
 10074d0:	b580      	push	{r7, lr}
	LOG_WRN("Data buffer overflow (link type 0x%02x)", evt->link_type);
 10074d2:	68c3      	ldr	r3, [r0, #12]
{
 10074d4:	af00      	add	r7, sp, #0
	LOG_WRN("Data buffer overflow (link type 0x%02x)", evt->link_type);
 10074d6:	b088      	sub	sp, #32
 10074d8:	466a      	mov	r2, sp
 10074da:	781b      	ldrb	r3, [r3, #0]
 10074dc:	4906      	ldr	r1, [pc, #24]	; (10074f8 <hci_data_buf_overflow+0x28>)
 10074de:	4807      	ldr	r0, [pc, #28]	; (10074fc <hci_data_buf_overflow+0x2c>)
 10074e0:	e9c2 1305 	strd	r1, r3, [r2, #20]
 10074e4:	2303      	movs	r3, #3
 10074e6:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 10074ea:	f842 3f10 	str.w	r3, [r2, #16]!
 10074ee:	f01f fb77 	bl	1026be0 <z_log_msg_static_create.constprop.0>
}
 10074f2:	46bd      	mov	sp, r7
 10074f4:	bd80      	pop	{r7, pc}
 10074f6:	bf00      	nop
 10074f8:	0102cefc 	.word	0x0102cefc
 10074fc:	010299a4 	.word	0x010299a4

01007500 <le_conn_param_neg_reply.part.0>:
static void le_conn_param_neg_reply(uint16_t handle, uint8_t reason)
 1007500:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
		LOG_ERR("Unable to allocate buffer");
 1007502:	4b06      	ldr	r3, [pc, #24]	; (100751c <le_conn_param_neg_reply.part.0+0x1c>)
 1007504:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1007508:	9305      	str	r3, [sp, #20]
 100750a:	2302      	movs	r3, #2
 100750c:	4804      	ldr	r0, [pc, #16]	; (1007520 <le_conn_param_neg_reply.part.0+0x20>)
 100750e:	aa04      	add	r2, sp, #16
 1007510:	9304      	str	r3, [sp, #16]
 1007512:	f01f fb65 	bl	1026be0 <z_log_msg_static_create.constprop.0>
}
 1007516:	b007      	add	sp, #28
 1007518:	f85d fb04 	ldr.w	pc, [sp], #4
 100751c:	0102cf24 	.word	0x0102cf24
 1007520:	010299a4 	.word	0x010299a4

01007524 <handle_event.part.0>:
static void handle_event(uint8_t event, struct net_buf *buf, const struct event_handler *handlers,
 1007524:	460b      	mov	r3, r1
 1007526:	b5b0      	push	{r4, r5, r7, lr}
		LOG_WRN("Unhandled event 0x%02x len %u: %s", event, buf->len,
 1007528:	8a0d      	ldrh	r5, [r1, #16]
static void handle_event(uint8_t event, struct net_buf *buf, const struct event_handler *handlers,
 100752a:	af00      	add	r7, sp, #0
 100752c:	4604      	mov	r4, r0
		LOG_WRN("Unhandled event 0x%02x len %u: %s", event, buf->len,
 100752e:	4629      	mov	r1, r5
 1007530:	68d8      	ldr	r0, [r3, #12]
 1007532:	f7ff fb69 	bl	1006c08 <bt_hex>
 1007536:	b08a      	sub	sp, #40	; 0x28
 1007538:	466a      	mov	r2, sp
 100753a:	4b09      	ldr	r3, [pc, #36]	; (1007560 <handle_event.part.0+0x3c>)
 100753c:	e9c2 5007 	strd	r5, r0, [r2, #28]
 1007540:	e9c2 3405 	strd	r3, r4, [r2, #20]
 1007544:	f240 4302 	movw	r3, #1026	; 0x402
 1007548:	8493      	strh	r3, [r2, #36]	; 0x24
 100754a:	4b06      	ldr	r3, [pc, #24]	; (1007564 <handle_event.part.0+0x40>)
 100754c:	f44f 5132 	mov.w	r1, #11392	; 0x2c80
 1007550:	4805      	ldr	r0, [pc, #20]	; (1007568 <handle_event.part.0+0x44>)
 1007552:	f842 3f10 	str.w	r3, [r2, #16]!
 1007556:	f01f fb43 	bl	1026be0 <z_log_msg_static_create.constprop.0>
}
 100755a:	46bd      	mov	sp, r7
 100755c:	bdb0      	pop	{r4, r5, r7, pc}
 100755e:	bf00      	nop
 1007560:	0102cf3e 	.word	0x0102cf3e
 1007564:	01000005 	.word	0x01000005
 1007568:	010299a4 	.word	0x010299a4

0100756c <hci_hardware_error>:
{
 100756c:	b580      	push	{r7, lr}
 *
 * @return Pointer to the old beginning of the buffer data.
 */
static inline void *net_buf_pull_mem(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull_mem(&buf->b, len);
 100756e:	2101      	movs	r1, #1
 1007570:	af00      	add	r7, sp, #0
 1007572:	300c      	adds	r0, #12
 1007574:	f016 fe72 	bl	101e25c <net_buf_simple_pull_mem>
	LOG_ERR("Hardware error, hardware code: %d", evt->hardware_code);
 1007578:	b088      	sub	sp, #32
 100757a:	466a      	mov	r2, sp
 100757c:	7803      	ldrb	r3, [r0, #0]
 100757e:	4906      	ldr	r1, [pc, #24]	; (1007598 <hci_hardware_error+0x2c>)
 1007580:	4806      	ldr	r0, [pc, #24]	; (100759c <hci_hardware_error+0x30>)
 1007582:	e9c2 1305 	strd	r1, r3, [r2, #20]
 1007586:	2303      	movs	r3, #3
 1007588:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100758c:	f842 3f10 	str.w	r3, [r2, #16]!
 1007590:	f01f fb26 	bl	1026be0 <z_log_msg_static_create.constprop.0>
}
 1007594:	46bd      	mov	sp, r7
 1007596:	bd80      	pop	{r7, pc}
 1007598:	0102cf60 	.word	0x0102cf60
 100759c:	010299a4 	.word	0x010299a4

010075a0 <le_data_len_change>:
{
 10075a0:	b5b0      	push	{r4, r5, r7, lr}
	uint16_t handle = sys_le16_to_cpu(evt->handle);
 10075a2:	68c3      	ldr	r3, [r0, #12]
{
 10075a4:	af00      	add	r7, sp, #0
	uint16_t handle = sys_le16_to_cpu(evt->handle);
 10075a6:	881c      	ldrh	r4, [r3, #0]
	conn = bt_conn_lookup_handle(handle);
 10075a8:	4620      	mov	r0, r4
 10075aa:	f002 fda7 	bl	100a0fc <bt_conn_lookup_handle>
	if (!conn) {
 10075ae:	b980      	cbnz	r0, 10075d2 <le_data_len_change+0x32>
		LOG_ERR("Unable to lookup conn for handle %u", handle);
 10075b0:	466d      	mov	r5, sp
 10075b2:	b088      	sub	sp, #32
 10075b4:	466a      	mov	r2, sp
 10075b6:	4b08      	ldr	r3, [pc, #32]	; (10075d8 <le_data_len_change+0x38>)
 10075b8:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 10075bc:	e9c2 3405 	strd	r3, r4, [r2, #20]
 10075c0:	2303      	movs	r3, #3
 10075c2:	4806      	ldr	r0, [pc, #24]	; (10075dc <le_data_len_change+0x3c>)
 10075c4:	f842 3f10 	str.w	r3, [r2, #16]!
 10075c8:	f01f fb0a 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 10075cc:	46ad      	mov	sp, r5
}
 10075ce:	46bd      	mov	sp, r7
 10075d0:	bdb0      	pop	{r4, r5, r7, pc}
	bt_conn_unref(conn);
 10075d2:	f002 fd63 	bl	100a09c <bt_conn_unref>
 10075d6:	e7fa      	b.n	10075ce <le_data_len_change+0x2e>
 10075d8:	0102cf82 	.word	0x0102cf82
 10075dc:	010299a4 	.word	0x010299a4

010075e0 <le_phy_update_complete>:
{
 10075e0:	b5b0      	push	{r4, r5, r7, lr}
	uint16_t handle = sys_le16_to_cpu(evt->handle);
 10075e2:	68c3      	ldr	r3, [r0, #12]
{
 10075e4:	af00      	add	r7, sp, #0
	uint16_t handle = sys_le16_to_cpu(evt->handle);
 10075e6:	f8b3 4001 	ldrh.w	r4, [r3, #1]
	conn = bt_conn_lookup_handle(handle);
 10075ea:	4620      	mov	r0, r4
 10075ec:	f002 fd86 	bl	100a0fc <bt_conn_lookup_handle>
	if (!conn) {
 10075f0:	b980      	cbnz	r0, 1007614 <le_phy_update_complete+0x34>
		LOG_ERR("Unable to lookup conn for handle %u", handle);
 10075f2:	466d      	mov	r5, sp
 10075f4:	b088      	sub	sp, #32
 10075f6:	466a      	mov	r2, sp
 10075f8:	4b08      	ldr	r3, [pc, #32]	; (100761c <le_phy_update_complete+0x3c>)
 10075fa:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 10075fe:	e9c2 3405 	strd	r3, r4, [r2, #20]
 1007602:	2303      	movs	r3, #3
 1007604:	4806      	ldr	r0, [pc, #24]	; (1007620 <le_phy_update_complete+0x40>)
 1007606:	f842 3f10 	str.w	r3, [r2, #16]!
 100760a:	f01f fae9 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 100760e:	46ad      	mov	sp, r5
}
 1007610:	46bd      	mov	sp, r7
 1007612:	bdb0      	pop	{r4, r5, r7, pc}
	bt_conn_unref(conn);
 1007614:	f002 fd42 	bl	100a09c <bt_conn_unref>
 1007618:	e7fa      	b.n	1007610 <le_phy_update_complete+0x30>
 100761a:	bf00      	nop
 100761c:	0102cf82 	.word	0x0102cf82
 1007620:	010299a4 	.word	0x010299a4

01007624 <hci_disconn_complete>:
{
 1007624:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
 1007628:	68c5      	ldr	r5, [r0, #12]
{
 100762a:	af00      	add	r7, sp, #0
	if (evt->status) {
 100762c:	782e      	ldrb	r6, [r5, #0]
 100762e:	b9ae      	cbnz	r6, 100765c <hci_disconn_complete+0x38>
	uint16_t handle = sys_le16_to_cpu(evt->handle);
 1007630:	f8b5 8001 	ldrh.w	r8, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
 1007634:	4640      	mov	r0, r8
 1007636:	f002 fd61 	bl	100a0fc <bt_conn_lookup_handle>
	if (!conn) {
 100763a:	4604      	mov	r4, r0
 100763c:	b988      	cbnz	r0, 1007662 <hci_disconn_complete+0x3e>
		LOG_ERR("Unable to look up conn with handle %u", handle);
 100763e:	466c      	mov	r4, sp
 1007640:	b088      	sub	sp, #32
 1007642:	466a      	mov	r2, sp
 1007644:	4b0b      	ldr	r3, [pc, #44]	; (1007674 <hci_disconn_complete+0x50>)
 1007646:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100764a:	e9c2 3805 	strd	r3, r8, [r2, #20]
 100764e:	2303      	movs	r3, #3
 1007650:	4809      	ldr	r0, [pc, #36]	; (1007678 <hci_disconn_complete+0x54>)
 1007652:	f842 3f10 	str.w	r3, [r2, #16]!
 1007656:	f01f fac3 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 100765a:	46a5      	mov	sp, r4
}
 100765c:	46bd      	mov	sp, r7
 100765e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	conn->err = evt->reason;
 1007662:	78eb      	ldrb	r3, [r5, #3]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
 1007664:	4631      	mov	r1, r6
	conn->err = evt->reason;
 1007666:	7303      	strb	r3, [r0, #12]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
 1007668:	f002 fd50 	bl	100a10c <bt_conn_set_state>
		bt_conn_unref(conn);
 100766c:	4620      	mov	r0, r4
	bt_conn_unref(conn);
 100766e:	f002 fd15 	bl	100a09c <bt_conn_unref>
 1007672:	e7f3      	b.n	100765c <hci_disconn_complete+0x38>
 1007674:	0102cfa6 	.word	0x0102cfa6
 1007678:	010299a4 	.word	0x010299a4

0100767c <handle_event>:
{
 100767c:	b5b0      	push	{r4, r5, r7, lr}
 100767e:	4604      	mov	r4, r0
 1007680:	af00      	add	r7, sp, #0
 1007682:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
	for (i = 0; i < num_handlers; i++) {
 1007686:	4293      	cmp	r3, r2
 1007688:	d103      	bne.n	1007692 <handle_event+0x16>
	if (err == -EOPNOTSUPP) {
 100768a:	4620      	mov	r0, r4
 100768c:	f7ff ff4a 	bl	1007524 <handle_event.part.0>
}
 1007690:	e018      	b.n	10076c4 <handle_event+0x48>
		if (handler->event != event) {
 1007692:	4610      	mov	r0, r2
 1007694:	f810 5b08 	ldrb.w	r5, [r0], #8
 1007698:	42a5      	cmp	r5, r4
 100769a:	d119      	bne.n	10076d0 <handle_event+0x54>
		if (buf->len < handler->min_len) {
 100769c:	8a0b      	ldrh	r3, [r1, #16]
 100769e:	7850      	ldrb	r0, [r2, #1]
 10076a0:	4298      	cmp	r0, r3
 10076a2:	d911      	bls.n	10076c8 <handle_event+0x4c>
			LOG_ERR("Too small (%u bytes) event 0x%02x", buf->len, event);
 10076a4:	466d      	mov	r5, sp
 10076a6:	b088      	sub	sp, #32
 10076a8:	466a      	mov	r2, sp
 10076aa:	490a      	ldr	r1, [pc, #40]	; (10076d4 <handle_event+0x58>)
 10076ac:	61d4      	str	r4, [r2, #28]
 10076ae:	e9c2 1305 	strd	r1, r3, [r2, #20]
 10076b2:	2304      	movs	r3, #4
 10076b4:	f44f 5101 	mov.w	r1, #8256	; 0x2040
 10076b8:	4807      	ldr	r0, [pc, #28]	; (10076d8 <handle_event+0x5c>)
 10076ba:	f842 3f10 	str.w	r3, [r2, #16]!
 10076be:	f01f fa8f 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 10076c2:	46ad      	mov	sp, r5
}
 10076c4:	46bd      	mov	sp, r7
 10076c6:	bdb0      	pop	{r4, r5, r7, pc}
		handler->handler(buf);
 10076c8:	4608      	mov	r0, r1
 10076ca:	6853      	ldr	r3, [r2, #4]
 10076cc:	4798      	blx	r3
	if (err == -EOPNOTSUPP) {
 10076ce:	e7f9      	b.n	10076c4 <handle_event+0x48>
 10076d0:	4602      	mov	r2, r0
 10076d2:	e7d8      	b.n	1007686 <handle_event+0xa>
 10076d4:	0102cfcc 	.word	0x0102cfcc
 10076d8:	010299a4 	.word	0x010299a4

010076dc <hci_le_meta_event>:
{
 10076dc:	b510      	push	{r4, lr}
 10076de:	2101      	movs	r1, #1
 10076e0:	4604      	mov	r4, r0
 10076e2:	300c      	adds	r0, #12
 10076e4:	f016 fdba 	bl	101e25c <net_buf_simple_pull_mem>
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
 10076e8:	4621      	mov	r1, r4
}
 10076ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
 10076ee:	230a      	movs	r3, #10
 10076f0:	4a01      	ldr	r2, [pc, #4]	; (10076f8 <hci_le_meta_event+0x1c>)
 10076f2:	7800      	ldrb	r0, [r0, #0]
 10076f4:	f7ff bfc2 	b.w	100767c <handle_event>
 10076f8:	01029f08 	.word	0x01029f08

010076fc <le_remote_feat_complete>:
{
 10076fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_remote_feat_complete *evt = (void *)buf->data;
 10076fe:	68c5      	ldr	r5, [r0, #12]
{
 1007700:	af00      	add	r7, sp, #0
	uint16_t handle = sys_le16_to_cpu(evt->handle);
 1007702:	f8b5 6001 	ldrh.w	r6, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
 1007706:	4630      	mov	r0, r6
 1007708:	f002 fcf8 	bl	100a0fc <bt_conn_lookup_handle>
	if (!conn) {
 100770c:	4604      	mov	r4, r0
 100770e:	b980      	cbnz	r0, 1007732 <le_remote_feat_complete+0x36>
		LOG_ERR("Unable to lookup conn for handle %u", handle);
 1007710:	466c      	mov	r4, sp
 1007712:	b088      	sub	sp, #32
 1007714:	466a      	mov	r2, sp
 1007716:	4b0f      	ldr	r3, [pc, #60]	; (1007754 <le_remote_feat_complete+0x58>)
 1007718:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100771c:	e9c2 3605 	strd	r3, r6, [r2, #20]
 1007720:	2303      	movs	r3, #3
 1007722:	480d      	ldr	r0, [pc, #52]	; (1007758 <le_remote_feat_complete+0x5c>)
 1007724:	f842 3f10 	str.w	r3, [r2, #16]!
 1007728:	f01f fa5a 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 100772c:	46a5      	mov	sp, r4
}
 100772e:	46bd      	mov	sp, r7
 1007730:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!evt->status) {
 1007732:	782b      	ldrb	r3, [r5, #0]
 1007734:	b923      	cbnz	r3, 1007740 <le_remote_feat_complete+0x44>
		memcpy(conn->le.features, evt->features,
 1007736:	2208      	movs	r2, #8
 1007738:	1ce9      	adds	r1, r5, #3
 100773a:	30b5      	adds	r0, #181	; 0xb5
 100773c:	f01f f91a 	bl	1026974 <memcpy>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
 1007740:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 1007744:	1d20      	adds	r0, r4, #4
 1007746:	f01f fa40 	bl	1026bca <atomic_or>
	bt_conn_unref(conn);
 100774a:	4620      	mov	r0, r4
 100774c:	f002 fca6 	bl	100a09c <bt_conn_unref>
 1007750:	e7ed      	b.n	100772e <le_remote_feat_complete+0x32>
 1007752:	bf00      	nop
 1007754:	0102cf82 	.word	0x0102cf82
 1007758:	010299a4 	.word	0x010299a4

0100775c <hci_cmd_done>:
{
 100775c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1007760:	4606      	mov	r6, r0
 1007762:	af00      	add	r7, sp, #0
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
 1007764:	7a90      	ldrb	r0, [r2, #10]
{
 1007766:	4688      	mov	r8, r1
 1007768:	4614      	mov	r4, r2
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
 100776a:	f016 fac5 	bl	101dcf8 <net_buf_pool_get>
 100776e:	4d41      	ldr	r5, [pc, #260]	; (1007874 <hci_cmd_done+0x118>)
 1007770:	4285      	cmp	r5, r0
 1007772:	d018      	beq.n	10077a6 <hci_cmd_done+0x4a>
		LOG_WRN("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p", opcode,
 1007774:	7aa4      	ldrb	r4, [r4, #10]
 1007776:	46e8      	mov	r8, sp
 1007778:	4620      	mov	r0, r4
 100777a:	f016 fabd 	bl	101dcf8 <net_buf_pool_get>
 100777e:	b08a      	sub	sp, #40	; 0x28
 1007780:	466a      	mov	r2, sp
 1007782:	4b3d      	ldr	r3, [pc, #244]	; (1007878 <hci_cmd_done+0x11c>)
 1007784:	e9c2 4007 	strd	r4, r0, [r2, #28]
 1007788:	e9c2 3605 	strd	r3, r6, [r2, #20]
 100778c:	2306      	movs	r3, #6
 100778e:	6255      	str	r5, [r2, #36]	; 0x24
 1007790:	f44f 5142 	mov.w	r1, #12416	; 0x3080
 1007794:	4839      	ldr	r0, [pc, #228]	; (100787c <hci_cmd_done+0x120>)
 1007796:	f842 3f10 	str.w	r3, [r2, #16]!
 100779a:	f01f fa21 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 100779e:	46c5      	mov	sp, r8
}
 10077a0:	46bd      	mov	sp, r7
 10077a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (cmd(buf)->opcode != opcode) {
 10077a6:	4620      	mov	r0, r4
 10077a8:	f016 faae 	bl	101dd08 <net_buf_id>
 10077ac:	f04f 090c 	mov.w	r9, #12
 10077b0:	4d33      	ldr	r5, [pc, #204]	; (1007880 <hci_cmd_done+0x124>)
 10077b2:	fb09 5000 	mla	r0, r9, r0, r5
 10077b6:	8843      	ldrh	r3, [r0, #2]
 10077b8:	42b3      	cmp	r3, r6
 10077ba:	d016      	beq.n	10077ea <hci_cmd_done+0x8e>
		LOG_WRN("OpCode 0x%04x completed instead of expected 0x%04x", opcode,
 10077bc:	4620      	mov	r0, r4
 10077be:	f016 faa3 	bl	101dd08 <net_buf_id>
 10077c2:	fb09 5000 	mla	r0, r9, r0, r5
 10077c6:	466c      	mov	r4, sp
 10077c8:	b088      	sub	sp, #32
 10077ca:	466a      	mov	r2, sp
 10077cc:	8843      	ldrh	r3, [r0, #2]
 10077ce:	61d3      	str	r3, [r2, #28]
 10077d0:	2304      	movs	r3, #4
 10077d2:	492c      	ldr	r1, [pc, #176]	; (1007884 <hci_cmd_done+0x128>)
 10077d4:	4829      	ldr	r0, [pc, #164]	; (100787c <hci_cmd_done+0x120>)
 10077d6:	e9c2 1605 	strd	r1, r6, [r2, #20]
 10077da:	f44f 5102 	mov.w	r1, #8320	; 0x2080
 10077de:	f842 3f10 	str.w	r3, [r2, #16]!
 10077e2:	f01f f9fd 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 10077e6:	46a5      	mov	sp, r4
		return;
 10077e8:	e7da      	b.n	10077a0 <hci_cmd_done+0x44>
	if (bt_dev.sent_cmd) {
 10077ea:	4e27      	ldr	r6, [pc, #156]	; (1007888 <hci_cmd_done+0x12c>)
 10077ec:	f8d6 0138 	ldr.w	r0, [r6, #312]	; 0x138
 10077f0:	b120      	cbz	r0, 10077fc <hci_cmd_done+0xa0>
		net_buf_unref(bt_dev.sent_cmd);
 10077f2:	f016 fbf5 	bl	101dfe0 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
 10077f6:	2300      	movs	r3, #0
 10077f8:	f8c6 3138 	str.w	r3, [r6, #312]	; 0x138
	if (cmd(buf)->state && !status) {
 10077fc:	4620      	mov	r0, r4
 10077fe:	f016 fa83 	bl	101dd08 <net_buf_id>
 1007802:	260c      	movs	r6, #12
 1007804:	fb06 5000 	mla	r0, r6, r0, r5
 1007808:	6843      	ldr	r3, [r0, #4]
 100780a:	b1ab      	cbz	r3, 1007838 <hci_cmd_done+0xdc>
 100780c:	f1b8 0f00 	cmp.w	r8, #0
 1007810:	d112      	bne.n	1007838 <hci_cmd_done+0xdc>
		struct bt_hci_cmd_state_set *update = cmd(buf)->state;
 1007812:	4620      	mov	r0, r4
 1007814:	f016 fa78 	bl	101dd08 <net_buf_id>
	atomic_val_t mask = ATOMIC_MASK(bit);
 1007818:	2101      	movs	r1, #1
 100781a:	fb06 5000 	mla	r0, r6, r0, r5
 100781e:	6842      	ldr	r2, [r0, #4]
		atomic_set_bit_to(update->target, update->bit, update->val);
 1007820:	e9d2 0300 	ldrd	r0, r3, [r2]
	if (val) {
 1007824:	7a12      	ldrb	r2, [r2, #8]
	atomic_val_t mask = ATOMIC_MASK(bit);
 1007826:	f003 061f 	and.w	r6, r3, #31
 100782a:	40b1      	lsls	r1, r6
	if (val) {
 100782c:	095b      	lsrs	r3, r3, #5
 100782e:	b1da      	cbz	r2, 1007868 <hci_cmd_done+0x10c>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
 1007830:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 1007834:	f01f f9c9 	bl	1026bca <atomic_or>
	if (cmd(buf)->sync) {
 1007838:	4620      	mov	r0, r4
 100783a:	f016 fa65 	bl	101dd08 <net_buf_id>
 100783e:	260c      	movs	r6, #12
 1007840:	fb06 5000 	mla	r0, r6, r0, r5
 1007844:	6883      	ldr	r3, [r0, #8]
 1007846:	2b00      	cmp	r3, #0
 1007848:	d0aa      	beq.n	10077a0 <hci_cmd_done+0x44>
		cmd(buf)->status = status;
 100784a:	4620      	mov	r0, r4
 100784c:	f016 fa5c 	bl	101dd08 <net_buf_id>
 1007850:	4370      	muls	r0, r6
 1007852:	f805 8000 	strb.w	r8, [r5, r0]
		k_sem_give(cmd(buf)->sync);
 1007856:	4620      	mov	r0, r4
 1007858:	f016 fa56 	bl	101dd08 <net_buf_id>
 100785c:	fb06 5500 	mla	r5, r6, r0, r5
 1007860:	68a8      	ldr	r0, [r5, #8]
	z_impl_k_sem_give(sem);
 1007862:	f019 ff1d 	bl	10216a0 <z_impl_k_sem_give>
}
 1007866:	e79b      	b.n	10077a0 <hci_cmd_done+0x44>
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 1007868:	43c9      	mvns	r1, r1
 100786a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 100786e:	f01f f9ba 	bl	1026be6 <atomic_and.isra.0>
 1007872:	e7e1      	b.n	1007838 <hci_cmd_done+0xdc>
 1007874:	21000e4c 	.word	0x21000e4c
 1007878:	0102cfee 	.word	0x0102cfee
 100787c:	010299a4 	.word	0x010299a4
 1007880:	21004688 	.word	0x21004688
 1007884:	0102d023 	.word	0x0102d023
 1007888:	21000000 	.word	0x21000000

0100788c <hci_cmd_status>:
{
 100788c:	b538      	push	{r3, r4, r5, lr}
 100788e:	2104      	movs	r1, #4
 1007890:	4604      	mov	r4, r0
 1007892:	300c      	adds	r0, #12
 1007894:	f016 fce2 	bl	101e25c <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
 1007898:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
 100789a:	7801      	ldrb	r1, [r0, #0]
 100789c:	4622      	mov	r2, r4
 100789e:	8840      	ldrh	r0, [r0, #2]
 10078a0:	f7ff ff5c 	bl	100775c <hci_cmd_done>
	if (ncmd) {
 10078a4:	b125      	cbz	r5, 10078b0 <hci_cmd_status+0x24>
}
 10078a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_sem_give(sem);
 10078aa:	4802      	ldr	r0, [pc, #8]	; (10078b4 <hci_cmd_status+0x28>)
 10078ac:	f019 bef8 	b.w	10216a0 <z_impl_k_sem_give>
 10078b0:	bd38      	pop	{r3, r4, r5, pc}
 10078b2:	bf00      	nop
 10078b4:	21000120 	.word	0x21000120

010078b8 <hci_cmd_complete>:
{
 10078b8:	b538      	push	{r3, r4, r5, lr}
 10078ba:	2103      	movs	r1, #3
 10078bc:	4604      	mov	r4, r0
 10078be:	300c      	adds	r0, #12
 10078c0:	f016 fccc 	bl	101e25c <net_buf_simple_pull_mem>
	status = buf->data[0];
 10078c4:	68e3      	ldr	r3, [r4, #12]
	ncmd = evt->ncmd;
 10078c6:	7805      	ldrb	r5, [r0, #0]
	hci_cmd_done(opcode, status, buf);
 10078c8:	4622      	mov	r2, r4
 10078ca:	7819      	ldrb	r1, [r3, #0]
 10078cc:	f8b0 0001 	ldrh.w	r0, [r0, #1]
 10078d0:	f7ff ff44 	bl	100775c <hci_cmd_done>
	if (ncmd) {
 10078d4:	b125      	cbz	r5, 10078e0 <hci_cmd_complete+0x28>
}
 10078d6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 10078da:	4802      	ldr	r0, [pc, #8]	; (10078e4 <hci_cmd_complete+0x2c>)
 10078dc:	f019 bee0 	b.w	10216a0 <z_impl_k_sem_give>
 10078e0:	bd38      	pop	{r3, r4, r5, pc}
 10078e2:	bf00      	nop
 10078e4:	21000120 	.word	0x21000120

010078e8 <hci_tx_thread>:
{
 10078e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		events[0].state = K_POLL_STATE_NOT_READY;
 10078ec:	f8df 8154 	ldr.w	r8, [pc, #340]	; 1007a44 <hci_tx_thread+0x15c>
{
 10078f0:	b087      	sub	sp, #28
		BT_ASSERT(err == 0);
 10078f2:	f8df 9154 	ldr.w	r9, [pc, #340]	; 1007a48 <hci_tx_thread+0x160>
{
 10078f6:	af00      	add	r7, sp, #0
		events[0].state = K_POLL_STATE_NOT_READY;
 10078f8:	f8d8 300c 	ldr.w	r3, [r8, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
 10078fc:	4853      	ldr	r0, [pc, #332]	; (1007a4c <hci_tx_thread+0x164>)
		events[0].state = K_POLL_STATE_NOT_READY;
 10078fe:	f36f 3394 	bfc	r3, #14, #7
 1007902:	f8c8 300c 	str.w	r3, [r8, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
 1007906:	f002 fb61 	bl	1009fcc <bt_conn_prepare_events>
 100790a:	1c45      	adds	r5, r0, #1
	return z_impl_k_poll(events, num_events, timeout);
 100790c:	f04f 32ff 	mov.w	r2, #4294967295
 1007910:	f04f 33ff 	mov.w	r3, #4294967295
 1007914:	4629      	mov	r1, r5
 1007916:	484b      	ldr	r0, [pc, #300]	; (1007a44 <hci_tx_thread+0x15c>)
 1007918:	f01c fca0 	bl	102425c <z_impl_k_poll>
		BT_ASSERT(err == 0);
 100791c:	b160      	cbz	r0, 1007938 <hci_tx_thread+0x50>
 100791e:	f640 13e6 	movw	r3, #2534	; 0x9e6
 1007922:	464a      	mov	r2, r9
 1007924:	494a      	ldr	r1, [pc, #296]	; (1007a50 <hci_tx_thread+0x168>)
 1007926:	484b      	ldr	r0, [pc, #300]	; (1007a54 <hci_tx_thread+0x16c>)
 1007928:	f01d f955 	bl	1024bd6 <assert_print>
 100792c:	4040      	eors	r0, r0
 100792e:	f380 8811 	msr	BASEPRI, r0
 1007932:	f04f 0003 	mov.w	r0, #3
 1007936:	df02      	svc	2
			LOG_WRN("Unexpected k_poll event state %u", ev->state);
 1007938:	f04f 0a03 	mov.w	sl, #3
{
 100793c:	4e41      	ldr	r6, [pc, #260]	; (1007a44 <hci_tx_thread+0x15c>)
	for (; count; ev++, count--) {
 100793e:	b915      	cbnz	r5, 1007946 <hci_tx_thread+0x5e>
	z_impl_k_yield();
 1007940:	f01b fc1a 	bl	1023178 <z_impl_k_yield>
	while (1) {
 1007944:	e7d8      	b.n	10078f8 <hci_tx_thread+0x10>
		switch (ev->state) {
 1007946:	68f3      	ldr	r3, [r6, #12]
 1007948:	f3c3 3386 	ubfx	r3, r3, #14, #7
 100794c:	2b01      	cmp	r3, #1
 100794e:	d960      	bls.n	1007a12 <hci_tx_thread+0x12a>
 1007950:	2b04      	cmp	r3, #4
 1007952:	d168      	bne.n	1007a26 <hci_tx_thread+0x13e>
			if (ev->tag == BT_EVENT_CMD_TX) {
 1007954:	7b33      	ldrb	r3, [r6, #12]
 1007956:	2b00      	cmp	r3, #0
 1007958:	d15e      	bne.n	1007a18 <hci_tx_thread+0x130>
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
 100795a:	2200      	movs	r2, #0
 100795c:	2300      	movs	r3, #0
 100795e:	483e      	ldr	r0, [pc, #248]	; (1007a58 <hci_tx_thread+0x170>)
 1007960:	f021 f9f7 	bl	1028d52 <net_buf_get>
	BT_ASSERT(buf);
 1007964:	4604      	mov	r4, r0
 1007966:	b960      	cbnz	r0, 1007982 <hci_tx_thread+0x9a>
 1007968:	f44f 6318 	mov.w	r3, #2432	; 0x980
 100796c:	464a      	mov	r2, r9
 100796e:	493b      	ldr	r1, [pc, #236]	; (1007a5c <hci_tx_thread+0x174>)
 1007970:	4838      	ldr	r0, [pc, #224]	; (1007a54 <hci_tx_thread+0x16c>)
 1007972:	f01d f930 	bl	1024bd6 <assert_print>
 1007976:	4040      	eors	r0, r0
 1007978:	f380 8811 	msr	BASEPRI, r0
 100797c:	f04f 0003 	mov.w	r0, #3
 1007980:	df02      	svc	2
	if (bt_dev.sent_cmd) {
 1007982:	f8df b0dc 	ldr.w	fp, [pc, #220]	; 1007a60 <hci_tx_thread+0x178>
	return z_impl_k_sem_take(sem, timeout);
 1007986:	f04f 33ff 	mov.w	r3, #4294967295
 100798a:	f04f 32ff 	mov.w	r2, #4294967295
 100798e:	4835      	ldr	r0, [pc, #212]	; (1007a64 <hci_tx_thread+0x17c>)
 1007990:	f019 feca 	bl	1021728 <z_impl_k_sem_take>
 1007994:	f8db 3138 	ldr.w	r3, [fp, #312]	; 0x138
 1007998:	b18b      	cbz	r3, 10079be <hci_tx_thread+0xd6>
		LOG_ERR("Uncleared pending sent_cmd");
 100799a:	4b33      	ldr	r3, [pc, #204]	; (1007a68 <hci_tx_thread+0x180>)
 100799c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10079a0:	617b      	str	r3, [r7, #20]
 10079a2:	2302      	movs	r3, #2
 10079a4:	4831      	ldr	r0, [pc, #196]	; (1007a6c <hci_tx_thread+0x184>)
 10079a6:	613b      	str	r3, [r7, #16]
 10079a8:	f107 0210 	add.w	r2, r7, #16
 10079ac:	f01f f918 	bl	1026be0 <z_log_msg_static_create.constprop.0>
		net_buf_unref(bt_dev.sent_cmd);
 10079b0:	f8db 0138 	ldr.w	r0, [fp, #312]	; 0x138
 10079b4:	f016 fb14 	bl	101dfe0 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
 10079b8:	2300      	movs	r3, #0
 10079ba:	f8cb 3138 	str.w	r3, [fp, #312]	; 0x138
	bt_dev.sent_cmd = net_buf_ref(buf);
 10079be:	4620      	mov	r0, r4
 10079c0:	f016 fb50 	bl	101e064 <net_buf_ref>
 10079c4:	f8cb 0138 	str.w	r0, [fp, #312]	; 0x138
		return bt_hci_ecc_send(buf);
 10079c8:	4620      	mov	r0, r4
 10079ca:	f7ff fadb 	bl	1006f84 <bt_hci_ecc_send>
	if (err) {
 10079ce:	b300      	cbz	r0, 1007a12 <hci_tx_thread+0x12a>
		LOG_ERR("Unable to send to driver (err %d)", err);
 10079d0:	46eb      	mov	fp, sp
 10079d2:	b088      	sub	sp, #32
 10079d4:	466a      	mov	r2, sp
 10079d6:	4b26      	ldr	r3, [pc, #152]	; (1007a70 <hci_tx_thread+0x188>)
 10079d8:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 10079dc:	e9c2 3005 	strd	r3, r0, [r2, #20]
 10079e0:	2303      	movs	r3, #3
 10079e2:	4822      	ldr	r0, [pc, #136]	; (1007a6c <hci_tx_thread+0x184>)
 10079e4:	f842 3f10 	str.w	r3, [r2, #16]!
 10079e8:	f01f f8fa 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 10079ec:	46dd      	mov	sp, fp
	z_impl_k_sem_give(sem);
 10079ee:	481d      	ldr	r0, [pc, #116]	; (1007a64 <hci_tx_thread+0x17c>)
 10079f0:	f019 fe56 	bl	10216a0 <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED, buf);
 10079f4:	4620      	mov	r0, r4
 10079f6:	f016 f987 	bl	101dd08 <net_buf_id>
 10079fa:	220c      	movs	r2, #12
 10079fc:	4b1d      	ldr	r3, [pc, #116]	; (1007a74 <hci_tx_thread+0x18c>)
 10079fe:	211f      	movs	r1, #31
 1007a00:	fb02 3000 	mla	r0, r2, r0, r3
 1007a04:	4622      	mov	r2, r4
 1007a06:	8840      	ldrh	r0, [r0, #2]
 1007a08:	f7ff fea8 	bl	100775c <hci_cmd_done>
		net_buf_unref(buf);
 1007a0c:	4620      	mov	r0, r4
 1007a0e:	f016 fae7 	bl	101dfe0 <net_buf_unref>
	for (; count; ev++, count--) {
 1007a12:	3614      	adds	r6, #20
 1007a14:	3d01      	subs	r5, #1
 1007a16:	e792      	b.n	100793e <hci_tx_thread+0x56>
				if (ev->tag == BT_EVENT_CONN_TX_QUEUE) {
 1007a18:	2b01      	cmp	r3, #1
 1007a1a:	d1fa      	bne.n	1007a12 <hci_tx_thread+0x12a>
					conn = CONTAINER_OF(ev->fifo,
 1007a1c:	6930      	ldr	r0, [r6, #16]
					bt_conn_process_tx(conn);
 1007a1e:	3838      	subs	r0, #56	; 0x38
 1007a20:	f002 ffc8 	bl	100a9b4 <bt_conn_process_tx>
 1007a24:	e7f5      	b.n	1007a12 <hci_tx_thread+0x12a>
			LOG_WRN("Unexpected k_poll event state %u", ev->state);
 1007a26:	466c      	mov	r4, sp
 1007a28:	b088      	sub	sp, #32
 1007a2a:	466a      	mov	r2, sp
 1007a2c:	4912      	ldr	r1, [pc, #72]	; (1007a78 <hci_tx_thread+0x190>)
 1007a2e:	480f      	ldr	r0, [pc, #60]	; (1007a6c <hci_tx_thread+0x184>)
		switch (ev->state) {
 1007a30:	e9c2 1305 	strd	r1, r3, [r2, #20]
			LOG_WRN("Unexpected k_poll event state %u", ev->state);
 1007a34:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 1007a38:	f842 af10 	str.w	sl, [r2, #16]!
 1007a3c:	f01f f8d0 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 1007a40:	46a5      	mov	sp, r4
 1007a42:	e7e6      	b.n	1007a12 <hci_tx_thread+0x12a>
 1007a44:	21000328 	.word	0x21000328
 1007a48:	0102d056 	.word	0x0102d056
 1007a4c:	2100033c 	.word	0x2100033c
 1007a50:	0102be7d 	.word	0x0102be7d
 1007a54:	0102b695 	.word	0x0102b695
 1007a58:	2100013c 	.word	0x2100013c
 1007a5c:	0102ef22 	.word	0x0102ef22
 1007a60:	21000000 	.word	0x21000000
 1007a64:	21000120 	.word	0x21000120
 1007a68:	0102d08a 	.word	0x0102d08a
 1007a6c:	010299a4 	.word	0x010299a4
 1007a70:	0102d0a5 	.word	0x0102d0a5
 1007a74:	21004688 	.word	0x21004688
 1007a78:	0102d0c7 	.word	0x0102d0c7

01007a7c <hci_num_completed_packets>:
{
 1007a7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (i = 0; i < evt->num_handles; i++) {
 1007a80:	2500      	movs	r5, #0
{
 1007a82:	b087      	sub	sp, #28
			tx->pending_no_cb = 0U;
 1007a84:	46a9      	mov	r9, r5
	struct bt_hci_evt_num_completed_packets *evt = (void *)buf->data;
 1007a86:	f8d0 800c 	ldr.w	r8, [r0, #12]
				LOG_ERR("packets count mismatch");
 1007a8a:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 1007b88 <hci_num_completed_packets+0x10c>
{
 1007a8e:	af00      	add	r7, sp, #0
	for (i = 0; i < evt->num_handles; i++) {
 1007a90:	f898 3000 	ldrb.w	r3, [r8]
 1007a94:	429d      	cmp	r5, r3
 1007a96:	db03      	blt.n	1007aa0 <hci_num_completed_packets+0x24>
}
 1007a98:	371c      	adds	r7, #28
 1007a9a:	46bd      	mov	sp, r7
 1007a9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		handle = sys_le16_to_cpu(evt->h[i].handle);
 1007aa0:	eb08 0385 	add.w	r3, r8, r5, lsl #2
 1007aa4:	f8b3 b001 	ldrh.w	fp, [r3, #1]
		count = sys_le16_to_cpu(evt->h[i].count);
 1007aa8:	f8b3 6003 	ldrh.w	r6, [r3, #3]
		conn = bt_conn_lookup_handle(handle);
 1007aac:	4658      	mov	r0, fp
 1007aae:	f002 fb25 	bl	100a0fc <bt_conn_lookup_handle>
		if (!conn) {
 1007ab2:	4604      	mov	r4, r0
 1007ab4:	b1d8      	cbz	r0, 1007aee <hci_num_completed_packets+0x72>
			k_work_submit(&conn->tx_complete_work);
 1007ab6:	f100 0b28 	add.w	fp, r0, #40	; 0x28
		while (count--) {
 1007aba:	2e00      	cmp	r6, #0
 1007abc:	d039      	beq.n	1007b32 <hci_num_completed_packets+0xb6>
	__asm__ volatile(
 1007abe:	f04f 0320 	mov.w	r3, #32
 1007ac2:	f3ef 8211 	mrs	r2, BASEPRI
 1007ac6:	f383 8812 	msr	BASEPRI_MAX, r3
 1007aca:	f3bf 8f6f 	isb	sy
			if (conn->pending_no_cb) {
 1007ace:	69e3      	ldr	r3, [r4, #28]
 1007ad0:	b1f3      	cbz	r3, 1007b10 <hci_num_completed_packets+0x94>
				conn->pending_no_cb--;
 1007ad2:	3b01      	subs	r3, #1
 1007ad4:	61e3      	str	r3, [r4, #28]
	__asm__ volatile(
 1007ad6:	f382 8811 	msr	BASEPRI, r2
 1007ada:	f3bf 8f6f 	isb	sy
			k_sem_give(bt_conn_get_pkts(conn));
 1007ade:	4620      	mov	r0, r4
 1007ae0:	f002 f8f4 	bl	1009ccc <bt_conn_get_pkts>
 1007ae4:	3e01      	subs	r6, #1
 1007ae6:	f019 fddb 	bl	10216a0 <z_impl_k_sem_give>
 1007aea:	b2b6      	uxth	r6, r6
 1007aec:	e7e5      	b.n	1007aba <hci_num_completed_packets+0x3e>
			LOG_ERR("No connection for handle %u", handle);
 1007aee:	466c      	mov	r4, sp
 1007af0:	b088      	sub	sp, #32
 1007af2:	466a      	mov	r2, sp
 1007af4:	4b25      	ldr	r3, [pc, #148]	; (1007b8c <hci_num_completed_packets+0x110>)
 1007af6:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1007afa:	e9c2 3b05 	strd	r3, fp, [r2, #20]
 1007afe:	2303      	movs	r3, #3
 1007b00:	4823      	ldr	r0, [pc, #140]	; (1007b90 <hci_num_completed_packets+0x114>)
 1007b02:	f842 3f10 	str.w	r3, [r2, #16]!
 1007b06:	f01f f86b 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 1007b0a:	46a5      	mov	sp, r4
	for (i = 0; i < evt->num_handles; i++) {
 1007b0c:	3501      	adds	r5, #1
 1007b0e:	e7bf      	b.n	1007a90 <hci_num_completed_packets+0x14>
	return list->head;
 1007b10:	6963      	ldr	r3, [r4, #20]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
 1007b12:	b993      	cbnz	r3, 1007b3a <hci_num_completed_packets+0xbe>
 1007b14:	f382 8811 	msr	BASEPRI, r2
 1007b18:	f3bf 8f6f 	isb	sy
				LOG_ERR("packets count mismatch");
 1007b1c:	2302      	movs	r3, #2
 1007b1e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1007b22:	481b      	ldr	r0, [pc, #108]	; (1007b90 <hci_num_completed_packets+0x114>)
 1007b24:	f8c7 a014 	str.w	sl, [r7, #20]
 1007b28:	613b      	str	r3, [r7, #16]
 1007b2a:	f107 0210 	add.w	r2, r7, #16
 1007b2e:	f01f f857 	bl	1026be0 <z_log_msg_static_create.constprop.0>
		bt_conn_unref(conn);
 1007b32:	4620      	mov	r0, r4
 1007b34:	f002 fab2 	bl	100a09c <bt_conn_unref>
 1007b38:	e7e8      	b.n	1007b0c <hci_num_completed_packets+0x90>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1007b3a:	69a1      	ldr	r1, [r4, #24]
	return node->next;
 1007b3c:	6818      	ldr	r0, [r3, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1007b3e:	428b      	cmp	r3, r1
	list->head = node;
 1007b40:	6160      	str	r0, [r4, #20]
	list->tail = node;
 1007b42:	bf08      	it	eq
 1007b44:	61a0      	streq	r0, [r4, #24]
 1007b46:	f382 8811 	msr	BASEPRI, r2
 1007b4a:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
 1007b4e:	f04f 0220 	mov.w	r2, #32
 1007b52:	f3ef 8111 	mrs	r1, BASEPRI
 1007b56:	f382 8812 	msr	BASEPRI_MAX, r2
 1007b5a:	f3bf 8f6f 	isb	sy
			conn->pending_no_cb = tx->pending_no_cb;
 1007b5e:	68da      	ldr	r2, [r3, #12]
 1007b60:	61e2      	str	r2, [r4, #28]
			tx->pending_no_cb = 0U;
 1007b62:	f8c3 900c 	str.w	r9, [r3, #12]
	parent->next = child;
 1007b66:	f8c3 9000 	str.w	r9, [r3]
	return list->tail;
 1007b6a:	6a62      	ldr	r2, [r4, #36]	; 0x24
Z_GENLIST_APPEND(slist, snode)
 1007b6c:	b94a      	cbnz	r2, 1007b82 <hci_num_completed_packets+0x106>
	list->head = node;
 1007b6e:	e9c4 3308 	strd	r3, r3, [r4, #32]
	__asm__ volatile(
 1007b72:	f381 8811 	msr	BASEPRI, r1
 1007b76:	f3bf 8f6f 	isb	sy
			k_work_submit(&conn->tx_complete_work);
 1007b7a:	4658      	mov	r0, fp
 1007b7c:	f01a f93e 	bl	1021dfc <k_work_submit>
 1007b80:	e7ad      	b.n	1007ade <hci_num_completed_packets+0x62>
	parent->next = child;
 1007b82:	6013      	str	r3, [r2, #0]
	list->tail = node;
 1007b84:	6263      	str	r3, [r4, #36]	; 0x24
}
 1007b86:	e7f4      	b.n	1007b72 <hci_num_completed_packets+0xf6>
 1007b88:	0102d104 	.word	0x0102d104
 1007b8c:	0102d0e8 	.word	0x0102d0e8
 1007b90:	010299a4 	.word	0x010299a4

01007b94 <le_conn_update_complete>:
{
 1007b94:	b5f0      	push	{r4, r5, r6, r7, lr}
 1007b96:	b083      	sub	sp, #12
	struct bt_hci_evt_le_conn_update_complete *evt = (void *)buf->data;
 1007b98:	68c5      	ldr	r5, [r0, #12]
{
 1007b9a:	af00      	add	r7, sp, #0
	handle = sys_le16_to_cpu(evt->handle);
 1007b9c:	f8b5 6001 	ldrh.w	r6, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
 1007ba0:	4630      	mov	r0, r6
 1007ba2:	f002 faab 	bl	100a0fc <bt_conn_lookup_handle>
	if (!conn) {
 1007ba6:	4604      	mov	r4, r0
 1007ba8:	b988      	cbnz	r0, 1007bce <le_conn_update_complete+0x3a>
		LOG_ERR("Unable to lookup conn for handle %u", handle);
 1007baa:	466c      	mov	r4, sp
 1007bac:	b088      	sub	sp, #32
 1007bae:	466a      	mov	r2, sp
 1007bb0:	4b2b      	ldr	r3, [pc, #172]	; (1007c60 <le_conn_update_complete+0xcc>)
 1007bb2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1007bb6:	e9c2 3605 	strd	r3, r6, [r2, #20]
 1007bba:	2303      	movs	r3, #3
 1007bbc:	4829      	ldr	r0, [pc, #164]	; (1007c64 <le_conn_update_complete+0xd0>)
 1007bbe:	f842 3f10 	str.w	r3, [r2, #16]!
 1007bc2:	f01f f80d 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 1007bc6:	46a5      	mov	sp, r4
}
 1007bc8:	370c      	adds	r7, #12
 1007bca:	46bd      	mov	sp, r7
 1007bcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
 1007bce:	782b      	ldrb	r3, [r5, #0]
	    !atomic_test_and_set_bit(conn->flags,
 1007bd0:	1d06      	adds	r6, r0, #4
	if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
 1007bd2:	2b1a      	cmp	r3, #26
 1007bd4:	d117      	bne.n	1007c06 <le_conn_update_complete+0x72>
 1007bd6:	78c3      	ldrb	r3, [r0, #3]
 1007bd8:	2b01      	cmp	r3, #1
 1007bda:	d128      	bne.n	1007c2e <le_conn_update_complete+0x9a>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
 1007bdc:	f44f 6180 	mov.w	r1, #1024	; 0x400
 1007be0:	4630      	mov	r0, r6
 1007be2:	f01e fff2 	bl	1026bca <atomic_or>
	    conn->role == BT_HCI_ROLE_PERIPHERAL &&
 1007be6:	0542      	lsls	r2, r0, #21
 1007be8:	d40d      	bmi.n	1007c06 <le_conn_update_complete+0x72>
		param.interval_min = conn->le.interval_min;
 1007bea:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
		bt_l2cap_update_conn_param(conn, &param);
 1007bee:	4639      	mov	r1, r7
		param.interval_min = conn->le.interval_min;
 1007bf0:	603b      	str	r3, [r7, #0]
		param.latency = conn->le.pending_latency;
 1007bf2:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
		bt_l2cap_update_conn_param(conn, &param);
 1007bf6:	4620      	mov	r0, r4
		param.latency = conn->le.pending_latency;
 1007bf8:	607b      	str	r3, [r7, #4]
		bt_l2cap_update_conn_param(conn, &param);
 1007bfa:	f01f fdd7 	bl	10277ac <bt_l2cap_update_conn_param>
	bt_conn_unref(conn);
 1007bfe:	4620      	mov	r0, r4
 1007c00:	f002 fa4c 	bl	100a09c <bt_conn_unref>
 1007c04:	e7e0      	b.n	1007bc8 <le_conn_update_complete+0x34>
		if (!evt->status) {
 1007c06:	782b      	ldrb	r3, [r5, #0]
 1007c08:	b98b      	cbnz	r3, 1007c2e <le_conn_update_complete+0x9a>
			conn->le.interval = sys_le16_to_cpu(evt->interval);
 1007c0a:	f8b5 3003 	ldrh.w	r3, [r5, #3]
 1007c0e:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
			conn->le.latency = sys_le16_to_cpu(evt->latency);
 1007c12:	f8b5 3005 	ldrh.w	r3, [r5, #5]
 1007c16:	f8a4 30ac 	strh.w	r3, [r4, #172]	; 0xac
			conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
 1007c1a:	f8b5 3007 	ldrh.w	r3, [r5, #7]
 1007c1e:	f8a4 30ae 	strh.w	r3, [r4, #174]	; 0xae
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 1007c22:	f46f 7180 	mvn.w	r1, #256	; 0x100
 1007c26:	4630      	mov	r0, r6
 1007c28:	f01e ffdd 	bl	1026be6 <atomic_and.isra.0>
}
 1007c2c:	e014      	b.n	1007c58 <le_conn_update_complete+0xc4>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1007c2e:	e8d6 3faf 	lda	r3, [r6]
		} else if (atomic_test_bit(conn->flags,
 1007c32:	05db      	lsls	r3, r3, #23
 1007c34:	d5f5      	bpl.n	1007c22 <le_conn_update_complete+0x8e>
					   BT_CONN_PERIPHERAL_PARAM_AUTO_UPDATE) &&
 1007c36:	782b      	ldrb	r3, [r5, #0]
 1007c38:	2b20      	cmp	r3, #32
 1007c3a:	d1f2      	bne.n	1007c22 <le_conn_update_complete+0x8e>
			   conn->le.conn_param_retry_countdown) {
 1007c3c:	f894 30b4 	ldrb.w	r3, [r4, #180]	; 0xb4
			   evt->status == BT_HCI_ERR_UNSUPP_LL_PARAM_VAL &&
 1007c40:	2b00      	cmp	r3, #0
 1007c42:	d0ee      	beq.n	1007c22 <le_conn_update_complete+0x8e>
			conn->le.conn_param_retry_countdown--;
 1007c44:	3b01      	subs	r3, #1
 1007c46:	f884 30b4 	strb.w	r3, [r4, #180]	; 0xb4
			k_work_schedule(&conn->deferred_work,
 1007c4a:	f44f 3220 	mov.w	r2, #163840	; 0x28000
 1007c4e:	2300      	movs	r3, #0
 1007c50:	f104 0060 	add.w	r0, r4, #96	; 0x60
 1007c54:	f01a f9fc 	bl	1022050 <k_work_schedule>
		notify_le_param_updated(conn);
 1007c58:	4620      	mov	r0, r4
 1007c5a:	f002 fbd1 	bl	100a400 <notify_le_param_updated>
 1007c5e:	e7ce      	b.n	1007bfe <le_conn_update_complete+0x6a>
 1007c60:	0102cf82 	.word	0x0102cf82
 1007c64:	010299a4 	.word	0x010299a4

01007c68 <bt_hci_cmd_state_set_init>:
{
 1007c68:	b510      	push	{r4, lr}
	state->bit = bit;
 1007c6a:	e9c1 2300 	strd	r2, r3, [r1]
	state->val = val;
 1007c6e:	f89d 3008 	ldrb.w	r3, [sp, #8]
{
 1007c72:	460c      	mov	r4, r1
	state->val = val;
 1007c74:	720b      	strb	r3, [r1, #8]
	cmd(buf)->state = state;
 1007c76:	f016 f847 	bl	101dd08 <net_buf_id>
 1007c7a:	220c      	movs	r2, #12
 1007c7c:	4b02      	ldr	r3, [pc, #8]	; (1007c88 <bt_hci_cmd_state_set_init+0x20>)
 1007c7e:	fb02 3300 	mla	r3, r2, r0, r3
 1007c82:	605c      	str	r4, [r3, #4]
}
 1007c84:	bd10      	pop	{r4, pc}
 1007c86:	bf00      	nop
 1007c88:	21004688 	.word	0x21004688

01007c8c <bt_hci_cmd_create>:
{
 1007c8c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return net_buf_alloc_fixed(pool, timeout);
 1007c90:	f04f 32ff 	mov.w	r2, #4294967295
 1007c94:	4606      	mov	r6, r0
 1007c96:	f04f 33ff 	mov.w	r3, #4294967295
 1007c9a:	481e      	ldr	r0, [pc, #120]	; (1007d14 <bt_hci_cmd_create+0x88>)
 1007c9c:	460f      	mov	r7, r1
 1007c9e:	f021 f853 	bl	1028d48 <net_buf_alloc_fixed>
	__ASSERT_NO_MSG(buf);
 1007ca2:	4604      	mov	r4, r0
 1007ca4:	b958      	cbnz	r0, 1007cbe <bt_hci_cmd_create+0x32>
 1007ca6:	491c      	ldr	r1, [pc, #112]	; (1007d18 <bt_hci_cmd_create+0x8c>)
 1007ca8:	481c      	ldr	r0, [pc, #112]	; (1007d1c <bt_hci_cmd_create+0x90>)
 1007caa:	f240 1301 	movw	r3, #257	; 0x101
 1007cae:	4a1c      	ldr	r2, [pc, #112]	; (1007d20 <bt_hci_cmd_create+0x94>)
 1007cb0:	f01c ff91 	bl	1024bd6 <assert_print>
 1007cb4:	f240 1101 	movw	r1, #257	; 0x101
 1007cb8:	4819      	ldr	r0, [pc, #100]	; (1007d20 <bt_hci_cmd_create+0x94>)
 1007cba:	f01c ff85 	bl	1024bc8 <assert_post_action>
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
 1007cbe:	f04f 0800 	mov.w	r8, #0
	net_buf_simple_reserve(&buf->b, reserve);
 1007cc2:	f100 0a0c 	add.w	sl, r0, #12
 1007cc6:	2100      	movs	r1, #0
 1007cc8:	4650      	mov	r0, sl
 1007cca:	f016 f93d 	bl	101df48 <net_buf_simple_reserve>
	cmd(buf)->opcode = opcode;
 1007cce:	4620      	mov	r0, r4
 1007cd0:	f884 8018 	strb.w	r8, [r4, #24]
 1007cd4:	f016 f818 	bl	101dd08 <net_buf_id>
 1007cd8:	f04f 090c 	mov.w	r9, #12
 1007cdc:	4d11      	ldr	r5, [pc, #68]	; (1007d24 <bt_hci_cmd_create+0x98>)
 1007cde:	fb09 5000 	mla	r0, r9, r0, r5
 1007ce2:	8046      	strh	r6, [r0, #2]
	cmd(buf)->sync = NULL;
 1007ce4:	4620      	mov	r0, r4
 1007ce6:	f016 f80f 	bl	101dd08 <net_buf_id>
 1007cea:	fb09 5000 	mla	r0, r9, r0, r5
 1007cee:	f8c0 8008 	str.w	r8, [r0, #8]
	cmd(buf)->state = NULL;
 1007cf2:	4620      	mov	r0, r4
 1007cf4:	f016 f808 	bl	101dd08 <net_buf_id>
 1007cf8:	fb09 5500 	mla	r5, r9, r0, r5
	return net_buf_simple_add(&buf->b, len);
 1007cfc:	2103      	movs	r1, #3
 1007cfe:	4650      	mov	r0, sl
 1007d00:	f8c5 8004 	str.w	r8, [r5, #4]
 1007d04:	f016 fac8 	bl	101e298 <net_buf_simple_add>
	hdr->opcode = sys_cpu_to_le16(opcode);
 1007d08:	8006      	strh	r6, [r0, #0]
	hdr->param_len = param_len;
 1007d0a:	7087      	strb	r7, [r0, #2]
}
 1007d0c:	4620      	mov	r0, r4
 1007d0e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1007d12:	bf00      	nop
 1007d14:	21000e4c 	.word	0x21000e4c
 1007d18:	0102ef22 	.word	0x0102ef22
 1007d1c:	0102b695 	.word	0x0102b695
 1007d20:	0102d056 	.word	0x0102d056
 1007d24:	21004688 	.word	0x21004688

01007d28 <bt_hci_cmd_send>:
{
 1007d28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1007d2a:	4605      	mov	r5, r0
	if (!buf) {
 1007d2c:	460c      	mov	r4, r1
{
 1007d2e:	af00      	add	r7, sp, #0
	if (!buf) {
 1007d30:	b919      	cbnz	r1, 1007d3a <bt_hci_cmd_send+0x12>
		buf = bt_hci_cmd_create(opcode, 0);
 1007d32:	f7ff ffab 	bl	1007c8c <bt_hci_cmd_create>
		if (!buf) {
 1007d36:	4604      	mov	r4, r0
 1007d38:	b318      	cbz	r0, 1007d82 <bt_hci_cmd_send+0x5a>
	if (opcode == BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS) {
 1007d3a:	f640 4335 	movw	r3, #3125	; 0xc35
 1007d3e:	429d      	cmp	r5, r3
 1007d40:	d119      	bne.n	1007d76 <bt_hci_cmd_send+0x4e>
		return bt_hci_ecc_send(buf);
 1007d42:	4620      	mov	r0, r4
 1007d44:	f7ff f91e 	bl	1006f84 <bt_hci_ecc_send>
		if (err) {
 1007d48:	4605      	mov	r5, r0
 1007d4a:	b188      	cbz	r0, 1007d70 <bt_hci_cmd_send+0x48>
			LOG_ERR("Unable to send to driver (err %d)", err);
 1007d4c:	466e      	mov	r6, sp
 1007d4e:	b088      	sub	sp, #32
 1007d50:	466a      	mov	r2, sp
 1007d52:	4b0d      	ldr	r3, [pc, #52]	; (1007d88 <bt_hci_cmd_send+0x60>)
 1007d54:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1007d58:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1007d5c:	2303      	movs	r3, #3
 1007d5e:	480b      	ldr	r0, [pc, #44]	; (1007d8c <bt_hci_cmd_send+0x64>)
 1007d60:	f842 3f10 	str.w	r3, [r2, #16]!
 1007d64:	f01e ff3c 	bl	1026be0 <z_log_msg_static_create.constprop.0>
			net_buf_unref(buf);
 1007d68:	4620      	mov	r0, r4
 1007d6a:	46b5      	mov	sp, r6
 1007d6c:	f016 f938 	bl	101dfe0 <net_buf_unref>
}
 1007d70:	4628      	mov	r0, r5
 1007d72:	46bd      	mov	sp, r7
 1007d74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
 1007d76:	4621      	mov	r1, r4
 1007d78:	4805      	ldr	r0, [pc, #20]	; (1007d90 <bt_hci_cmd_send+0x68>)
 1007d7a:	f016 f90b 	bl	101df94 <net_buf_put>
	return 0;
 1007d7e:	2500      	movs	r5, #0
 1007d80:	e7f6      	b.n	1007d70 <bt_hci_cmd_send+0x48>
			return -ENOBUFS;
 1007d82:	f06f 0568 	mvn.w	r5, #104	; 0x68
 1007d86:	e7f3      	b.n	1007d70 <bt_hci_cmd_send+0x48>
 1007d88:	0102d0a5 	.word	0x0102d0a5
 1007d8c:	010299a4 	.word	0x010299a4
 1007d90:	2100013c 	.word	0x2100013c

01007d94 <le_ltk_request>:
{
 1007d94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1007d98:	b08c      	sub	sp, #48	; 0x30
	struct bt_hci_evt_le_ltk_request *evt = (void *)buf->data;
 1007d9a:	68c4      	ldr	r4, [r0, #12]
{
 1007d9c:	af02      	add	r7, sp, #8
	handle = sys_le16_to_cpu(evt->handle);
 1007d9e:	8826      	ldrh	r6, [r4, #0]
 1007da0:	fa1f f886 	uxth.w	r8, r6
	conn = bt_conn_lookup_handle(handle);
 1007da4:	4640      	mov	r0, r8
 1007da6:	f002 f9a9 	bl	100a0fc <bt_conn_lookup_handle>
	if (!conn) {
 1007daa:	4605      	mov	r5, r0
 1007dac:	b990      	cbnz	r0, 1007dd4 <le_ltk_request+0x40>
		LOG_ERR("Unable to lookup conn for handle %u", handle);
 1007dae:	466c      	mov	r4, sp
 1007db0:	b088      	sub	sp, #32
 1007db2:	aa02      	add	r2, sp, #8
 1007db4:	4b28      	ldr	r3, [pc, #160]	; (1007e58 <le_ltk_request+0xc4>)
 1007db6:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1007dba:	e9c2 3805 	strd	r3, r8, [r2, #20]
 1007dbe:	2303      	movs	r3, #3
 1007dc0:	4826      	ldr	r0, [pc, #152]	; (1007e5c <le_ltk_request+0xc8>)
 1007dc2:	f842 3f10 	str.w	r3, [r2, #16]!
 1007dc6:	f01e ff0b 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 1007dca:	46a5      	mov	sp, r4
}
 1007dcc:	3728      	adds	r7, #40	; 0x28
 1007dce:	46bd      	mov	sp, r7
 1007dd0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (bt_smp_request_ltk(conn, evt->rand, evt->ediv, ltk)) {
 1007dd4:	f8d4 2002 	ldr.w	r2, [r4, #2]
 1007dd8:	f8d4 3006 	ldr.w	r3, [r4, #6]
 1007ddc:	9701      	str	r7, [sp, #4]
 1007dde:	8961      	ldrh	r1, [r4, #10]
 1007de0:	9100      	str	r1, [sp, #0]
 1007de2:	f020 fe13 	bl	1028a0c <bt_smp_request_ltk>
 1007de6:	b328      	cbz	r0, 1007e34 <le_ltk_request+0xa0>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_LTK_REQ_REPLY,
 1007de8:	2112      	movs	r1, #18
 1007dea:	f242 001a 	movw	r0, #8218	; 0x201a
 1007dee:	f7ff ff4d 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 1007df2:	4604      	mov	r4, r0
 1007df4:	b970      	cbnz	r0, 1007e14 <le_ltk_request+0x80>
		LOG_ERR("Out of command buffers");
 1007df6:	4b1a      	ldr	r3, [pc, #104]	; (1007e60 <le_ltk_request+0xcc>)
 1007df8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1007dfc:	627b      	str	r3, [r7, #36]	; 0x24
 1007dfe:	2302      	movs	r3, #2
 1007e00:	4816      	ldr	r0, [pc, #88]	; (1007e5c <le_ltk_request+0xc8>)
 1007e02:	623b      	str	r3, [r7, #32]
 1007e04:	f107 0220 	add.w	r2, r7, #32
 1007e08:	f01e feea 	bl	1026be0 <z_log_msg_static_create.constprop.0>
	bt_conn_unref(conn);
 1007e0c:	4628      	mov	r0, r5
 1007e0e:	f002 f945 	bl	100a09c <bt_conn_unref>
 1007e12:	e7db      	b.n	1007dcc <le_ltk_request+0x38>
 1007e14:	2112      	movs	r1, #18
 1007e16:	300c      	adds	r0, #12
 1007e18:	f016 fa3e 	bl	101e298 <net_buf_simple_add>
	memcpy(cp->ltk, ltk, sizeof(cp->ltk));
 1007e1c:	4639      	mov	r1, r7
 1007e1e:	2210      	movs	r2, #16
	cp->handle = sys_cpu_to_le16(handle);
 1007e20:	f820 6b02 	strh.w	r6, [r0], #2
	memcpy(cp->ltk, ltk, sizeof(cp->ltk));
 1007e24:	f01e fda6 	bl	1026974 <memcpy>
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_REPLY, buf);
 1007e28:	4621      	mov	r1, r4
 1007e2a:	f242 001a 	movw	r0, #8218	; 0x201a
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, buf);
 1007e2e:	f7ff ff7b 	bl	1007d28 <bt_hci_cmd_send>
 1007e32:	e7eb      	b.n	1007e0c <le_ltk_request+0x78>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, sizeof(*cp));
 1007e34:	2102      	movs	r1, #2
 1007e36:	f242 001b 	movw	r0, #8219	; 0x201b
 1007e3a:	f7ff ff27 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 1007e3e:	4604      	mov	r4, r0
 1007e40:	2800      	cmp	r0, #0
 1007e42:	d0d8      	beq.n	1007df6 <le_ltk_request+0x62>
 1007e44:	2102      	movs	r1, #2
 1007e46:	300c      	adds	r0, #12
 1007e48:	f016 fa26 	bl	101e298 <net_buf_simple_add>
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, buf);
 1007e4c:	4621      	mov	r1, r4
	cp->handle = sys_cpu_to_le16(handle);
 1007e4e:	8006      	strh	r6, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, buf);
 1007e50:	f242 001b 	movw	r0, #8219	; 0x201b
 1007e54:	e7eb      	b.n	1007e2e <le_ltk_request+0x9a>
 1007e56:	bf00      	nop
 1007e58:	0102cf82 	.word	0x0102cf82
 1007e5c:	010299a4 	.word	0x010299a4
 1007e60:	0102d11b 	.word	0x0102d11b

01007e64 <le_conn_param_req>:
{
 1007e64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1007e68:	b082      	sub	sp, #8
	struct bt_hci_evt_le_conn_param_req *evt = (void *)buf->data;
 1007e6a:	68c3      	ldr	r3, [r0, #12]
{
 1007e6c:	af00      	add	r7, sp, #0
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
 1007e6e:	78d9      	ldrb	r1, [r3, #3]
 1007e70:	789a      	ldrb	r2, [r3, #2]
	handle = sys_le16_to_cpu(evt->handle);
 1007e72:	f8b3 8000 	ldrh.w	r8, [r3]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
 1007e76:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 1007e7a:	803a      	strh	r2, [r7, #0]
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
 1007e7c:	7959      	ldrb	r1, [r3, #5]
 1007e7e:	791a      	ldrb	r2, [r3, #4]
	handle = sys_le16_to_cpu(evt->handle);
 1007e80:	fa1f f488 	uxth.w	r4, r8
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
 1007e84:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 1007e88:	807a      	strh	r2, [r7, #2]
	param.latency = sys_le16_to_cpu(evt->latency);
 1007e8a:	799a      	ldrb	r2, [r3, #6]
 1007e8c:	79d9      	ldrb	r1, [r3, #7]
	conn = bt_conn_lookup_handle(handle);
 1007e8e:	4620      	mov	r0, r4
	param.latency = sys_le16_to_cpu(evt->latency);
 1007e90:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 1007e94:	80ba      	strh	r2, [r7, #4]
	param.timeout = sys_le16_to_cpu(evt->timeout);
 1007e96:	7a1a      	ldrb	r2, [r3, #8]
 1007e98:	7a5b      	ldrb	r3, [r3, #9]
 1007e9a:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 1007e9e:	80fb      	strh	r3, [r7, #6]
	conn = bt_conn_lookup_handle(handle);
 1007ea0:	f002 f92c 	bl	100a0fc <bt_conn_lookup_handle>
	if (!conn) {
 1007ea4:	4606      	mov	r6, r0
 1007ea6:	b9b0      	cbnz	r0, 1007ed6 <le_conn_param_req+0x72>
		LOG_ERR("Unable to lookup conn for handle %u", handle);
 1007ea8:	466d      	mov	r5, sp
 1007eaa:	b088      	sub	sp, #32
 1007eac:	466a      	mov	r2, sp
 1007eae:	4b20      	ldr	r3, [pc, #128]	; (1007f30 <le_conn_param_req+0xcc>)
 1007eb0:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1007eb4:	e9c2 3405 	strd	r3, r4, [r2, #20]
 1007eb8:	2303      	movs	r3, #3
 1007eba:	481e      	ldr	r0, [pc, #120]	; (1007f34 <le_conn_param_req+0xd0>)
 1007ebc:	f842 3f10 	str.w	r3, [r2, #16]!
 1007ec0:	f01e fe8e 	bl	1026be0 <z_log_msg_static_create.constprop.0>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_UNKNOWN_CONN_ID);
 1007ec4:	2102      	movs	r1, #2
 1007ec6:	46ad      	mov	sp, r5
 1007ec8:	4620      	mov	r0, r4
 1007eca:	f01e fea4 	bl	1026c16 <le_conn_param_neg_reply>
}
 1007ece:	3708      	adds	r7, #8
 1007ed0:	46bd      	mov	sp, r7
 1007ed2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!le_param_req(conn, &param)) {
 1007ed6:	4639      	mov	r1, r7
 1007ed8:	f002 faea 	bl	100a4b0 <le_param_req>
 1007edc:	b938      	cbnz	r0, 1007eee <le_conn_param_req+0x8a>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_INVALID_LL_PARAM);
 1007ede:	211e      	movs	r1, #30
 1007ee0:	4620      	mov	r0, r4
 1007ee2:	f01e fe98 	bl	1026c16 <le_conn_param_neg_reply>
	bt_conn_unref(conn);
 1007ee6:	4630      	mov	r0, r6
 1007ee8:	f002 f8d8 	bl	100a09c <bt_conn_unref>
 1007eec:	e7ef      	b.n	1007ece <le_conn_param_req+0x6a>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(*cp));
 1007eee:	210e      	movs	r1, #14
 1007ef0:	f242 0020 	movw	r0, #8224	; 0x2020
 1007ef4:	f7ff feca 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 1007ef8:	4605      	mov	r5, r0
 1007efa:	2800      	cmp	r0, #0
 1007efc:	d0f3      	beq.n	1007ee6 <le_conn_param_req+0x82>
 1007efe:	210e      	movs	r1, #14
 1007f00:	300c      	adds	r0, #12
 1007f02:	f016 f9c9 	bl	101e298 <net_buf_simple_add>
 1007f06:	4604      	mov	r4, r0
	(void)memset(cp, 0, sizeof(*cp));
 1007f08:	220e      	movs	r2, #14
 1007f0a:	2100      	movs	r1, #0
 1007f0c:	f01e fd3d 	bl	102698a <memset>
	cp->handle = sys_cpu_to_le16(handle);
 1007f10:	f8a4 8000 	strh.w	r8, [r4]
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
 1007f14:	883b      	ldrh	r3, [r7, #0]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
 1007f16:	4629      	mov	r1, r5
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
 1007f18:	8063      	strh	r3, [r4, #2]
	cp->interval_max = sys_cpu_to_le16(param->interval_max);
 1007f1a:	887b      	ldrh	r3, [r7, #2]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
 1007f1c:	f242 0020 	movw	r0, #8224	; 0x2020
	cp->interval_max = sys_cpu_to_le16(param->interval_max);
 1007f20:	80a3      	strh	r3, [r4, #4]
	cp->latency = sys_cpu_to_le16(param->latency);
 1007f22:	88bb      	ldrh	r3, [r7, #4]
 1007f24:	80e3      	strh	r3, [r4, #6]
	cp->timeout = sys_cpu_to_le16(param->timeout);
 1007f26:	88fb      	ldrh	r3, [r7, #6]
 1007f28:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
 1007f2a:	f7ff fefd 	bl	1007d28 <bt_hci_cmd_send>
 1007f2e:	e7da      	b.n	1007ee6 <le_conn_param_req+0x82>
 1007f30:	0102cf82 	.word	0x0102cf82
 1007f34:	010299a4 	.word	0x010299a4

01007f38 <bt_hci_cmd_send_sync>:
{
 1007f38:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1007f3c:	b087      	sub	sp, #28
 1007f3e:	4680      	mov	r8, r0
 1007f40:	4615      	mov	r5, r2
	if (!buf) {
 1007f42:	460c      	mov	r4, r1
{
 1007f44:	af00      	add	r7, sp, #0
	if (!buf) {
 1007f46:	b921      	cbnz	r1, 1007f52 <bt_hci_cmd_send_sync+0x1a>
		buf = bt_hci_cmd_create(opcode, 0);
 1007f48:	f7ff fea0 	bl	1007c8c <bt_hci_cmd_create>
		if (!buf) {
 1007f4c:	4604      	mov	r4, r0
 1007f4e:	2800      	cmp	r0, #0
 1007f50:	d05a      	beq.n	1008008 <bt_hci_cmd_send_sync+0xd0>
	return z_impl_k_sem_init(sem, initial_count, limit);
 1007f52:	2201      	movs	r2, #1
 1007f54:	2100      	movs	r1, #0
 1007f56:	4638      	mov	r0, r7
 1007f58:	f021 f9dd 	bl	1029316 <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
 1007f5c:	4620      	mov	r0, r4
 1007f5e:	f015 fed3 	bl	101dd08 <net_buf_id>
 1007f62:	230c      	movs	r3, #12
 1007f64:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 1008010 <bt_hci_cmd_send_sync+0xd8>
 1007f68:	fb03 9000 	mla	r0, r3, r0, r9
 1007f6c:	6087      	str	r7, [r0, #8]
	net_buf_put(&bt_dev.cmd_tx_queue, net_buf_ref(buf));
 1007f6e:	4620      	mov	r0, r4
 1007f70:	f016 f878 	bl	101e064 <net_buf_ref>
 1007f74:	4601      	mov	r1, r0
 1007f76:	4827      	ldr	r0, [pc, #156]	; (1008014 <bt_hci_cmd_send_sync+0xdc>)
 1007f78:	f016 f80c 	bl	101df94 <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
 1007f7c:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
 1007f80:	2300      	movs	r3, #0
 1007f82:	4638      	mov	r0, r7
 1007f84:	f019 fbd0 	bl	1021728 <z_impl_k_sem_take>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
 1007f88:	4606      	mov	r6, r0
 1007f8a:	b180      	cbz	r0, 1007fae <bt_hci_cmd_send_sync+0x76>
 1007f8c:	f240 1349 	movw	r3, #329	; 0x149
 1007f90:	4a21      	ldr	r2, [pc, #132]	; (1008018 <bt_hci_cmd_send_sync+0xe0>)
 1007f92:	4922      	ldr	r1, [pc, #136]	; (100801c <bt_hci_cmd_send_sync+0xe4>)
 1007f94:	4822      	ldr	r0, [pc, #136]	; (1008020 <bt_hci_cmd_send_sync+0xe8>)
 1007f96:	f01c fe1e 	bl	1024bd6 <assert_print>
 1007f9a:	4631      	mov	r1, r6
 1007f9c:	4821      	ldr	r0, [pc, #132]	; (1008024 <bt_hci_cmd_send_sync+0xec>)
 1007f9e:	f01c fe1a 	bl	1024bd6 <assert_print>
 1007fa2:	4040      	eors	r0, r0
 1007fa4:	f380 8811 	msr	BASEPRI, r0
 1007fa8:	f04f 0003 	mov.w	r0, #3
 1007fac:	df02      	svc	2
	status = cmd(buf)->status;
 1007fae:	4620      	mov	r0, r4
 1007fb0:	f015 feaa 	bl	101dd08 <net_buf_id>
 1007fb4:	230c      	movs	r3, #12
 1007fb6:	4358      	muls	r0, r3
 1007fb8:	f819 6000 	ldrb.w	r6, [r9, r0]
	if (status) {
 1007fbc:	b1e6      	cbz	r6, 1007ff8 <bt_hci_cmd_send_sync+0xc0>
		LOG_WRN("opcode 0x%04x status 0x%02x", opcode, status);
 1007fbe:	466d      	mov	r5, sp
 1007fc0:	b088      	sub	sp, #32
 1007fc2:	466a      	mov	r2, sp
 1007fc4:	4b18      	ldr	r3, [pc, #96]	; (1008028 <bt_hci_cmd_send_sync+0xf0>)
 1007fc6:	61d6      	str	r6, [r2, #28]
 1007fc8:	e9c2 3805 	strd	r3, r8, [r2, #20]
 1007fcc:	2304      	movs	r3, #4
 1007fce:	f44f 5102 	mov.w	r1, #8320	; 0x2080
 1007fd2:	4816      	ldr	r0, [pc, #88]	; (100802c <bt_hci_cmd_send_sync+0xf4>)
 1007fd4:	f842 3f10 	str.w	r3, [r2, #16]!
 1007fd8:	f01e fe02 	bl	1026be0 <z_log_msg_static_create.constprop.0>
		net_buf_unref(buf);
 1007fdc:	4620      	mov	r0, r4
 1007fde:	46ad      	mov	sp, r5
 1007fe0:	f015 fffe 	bl	101dfe0 <net_buf_unref>
			return -ECONNREFUSED;
 1007fe4:	2e09      	cmp	r6, #9
 1007fe6:	bf14      	ite	ne
 1007fe8:	f06f 0004 	mvnne.w	r0, #4
 1007fec:	f06f 006e 	mvneq.w	r0, #110	; 0x6e
}
 1007ff0:	371c      	adds	r7, #28
 1007ff2:	46bd      	mov	sp, r7
 1007ff4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (rsp) {
 1007ff8:	b115      	cbz	r5, 1008000 <bt_hci_cmd_send_sync+0xc8>
		*rsp = buf;
 1007ffa:	602c      	str	r4, [r5, #0]
	return 0;
 1007ffc:	2000      	movs	r0, #0
 1007ffe:	e7f7      	b.n	1007ff0 <bt_hci_cmd_send_sync+0xb8>
		net_buf_unref(buf);
 1008000:	4620      	mov	r0, r4
 1008002:	f015 ffed 	bl	101dfe0 <net_buf_unref>
 1008006:	e7f9      	b.n	1007ffc <bt_hci_cmd_send_sync+0xc4>
			return -ENOBUFS;
 1008008:	f06f 0068 	mvn.w	r0, #104	; 0x68
 100800c:	e7f0      	b.n	1007ff0 <bt_hci_cmd_send_sync+0xb8>
 100800e:	bf00      	nop
 1008010:	21004688 	.word	0x21004688
 1008014:	2100013c 	.word	0x2100013c
 1008018:	0102d056 	.word	0x0102d056
 100801c:	0102be7d 	.word	0x0102be7d
 1008020:	0102b695 	.word	0x0102b695
 1008024:	0102d132 	.word	0x0102d132
 1008028:	0102d152 	.word	0x0102d152
 100802c:	010299a4 	.word	0x010299a4

01008030 <hci_le_read_max_data_len>:
{
 1008030:	b570      	push	{r4, r5, r6, lr}
 1008032:	b088      	sub	sp, #32
 1008034:	4606      	mov	r6, r0
 1008036:	460d      	mov	r5, r1
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL, &rsp);
 1008038:	f242 002f 	movw	r0, #8239	; 0x202f
 100803c:	2100      	movs	r1, #0
 100803e:	aa01      	add	r2, sp, #4
 1008040:	f7ff ff7a 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 1008044:	4604      	mov	r4, r0
 1008046:	b160      	cbz	r0, 1008062 <hci_le_read_max_data_len+0x32>
		LOG_ERR("Failed to read DLE max data len");
 1008048:	4b0b      	ldr	r3, [pc, #44]	; (1008078 <hci_le_read_max_data_len+0x48>)
 100804a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100804e:	9307      	str	r3, [sp, #28]
 1008050:	2302      	movs	r3, #2
 1008052:	480a      	ldr	r0, [pc, #40]	; (100807c <hci_le_read_max_data_len+0x4c>)
 1008054:	aa06      	add	r2, sp, #24
 1008056:	9306      	str	r3, [sp, #24]
 1008058:	f01e fdc2 	bl	1026be0 <z_log_msg_static_create.constprop.0>
}
 100805c:	4620      	mov	r0, r4
 100805e:	b008      	add	sp, #32
 1008060:	bd70      	pop	{r4, r5, r6, pc}
	rp = (void *)rsp->data;
 1008062:	9801      	ldr	r0, [sp, #4]
 1008064:	68c3      	ldr	r3, [r0, #12]
	*tx_octets = sys_le16_to_cpu(rp->max_tx_octets);
 1008066:	f8b3 2001 	ldrh.w	r2, [r3, #1]
 100806a:	8032      	strh	r2, [r6, #0]
	*tx_time = sys_le16_to_cpu(rp->max_tx_time);
 100806c:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 1008070:	802b      	strh	r3, [r5, #0]
	net_buf_unref(rsp);
 1008072:	f015 ffb5 	bl	101dfe0 <net_buf_unref>
	return 0;
 1008076:	e7f1      	b.n	100805c <hci_le_read_max_data_len+0x2c>
 1008078:	0102d16e 	.word	0x0102d16e
 100807c:	010299a4 	.word	0x010299a4

01008080 <bt_hci_le_rand>:
{
 1008080:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (!BT_CMD_TEST(bt_dev.supported_commands, 27, 7)) {
 1008082:	4b14      	ldr	r3, [pc, #80]	; (10080d4 <bt_hci_le_rand+0x54>)
{
 1008084:	4605      	mov	r5, r0
	if (!BT_CMD_TEST(bt_dev.supported_commands, 27, 7)) {
 1008086:	f993 3093 	ldrsb.w	r3, [r3, #147]	; 0x93
{
 100808a:	460c      	mov	r4, r1
	if (!BT_CMD_TEST(bt_dev.supported_commands, 27, 7)) {
 100808c:	2b00      	cmp	r3, #0
 100808e:	da1d      	bge.n	10080cc <bt_hci_le_rand+0x4c>
	while (len > 0) {
 1008090:	b914      	cbnz	r4, 1008098 <bt_hci_le_rand+0x18>
	return 0;
 1008092:	4620      	mov	r0, r4
}
 1008094:	b003      	add	sp, #12
 1008096:	bdf0      	pop	{r4, r5, r6, r7, pc}
		count = MIN(len, sizeof(rp->rand));
 1008098:	2c08      	cmp	r4, #8
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
 100809a:	f04f 0100 	mov.w	r1, #0
 100809e:	f242 0018 	movw	r0, #8216	; 0x2018
 10080a2:	aa01      	add	r2, sp, #4
		count = MIN(len, sizeof(rp->rand));
 10080a4:	4626      	mov	r6, r4
 10080a6:	bf28      	it	cs
 10080a8:	2608      	movcs	r6, #8
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
 10080aa:	f7ff ff45 	bl	1007f38 <bt_hci_cmd_send_sync>
		if (err) {
 10080ae:	2800      	cmp	r0, #0
 10080b0:	d1f0      	bne.n	1008094 <bt_hci_le_rand+0x14>
		rp = (void *)rsp->data;
 10080b2:	9f01      	ldr	r7, [sp, #4]
		memcpy(buffer, rp->rand, count);
 10080b4:	4632      	mov	r2, r6
 10080b6:	68f9      	ldr	r1, [r7, #12]
 10080b8:	4628      	mov	r0, r5
 10080ba:	3101      	adds	r1, #1
 10080bc:	f01e fc5a 	bl	1026974 <memcpy>
		net_buf_unref(rsp);
 10080c0:	4638      	mov	r0, r7
 10080c2:	f015 ff8d 	bl	101dfe0 <net_buf_unref>
		buffer = (uint8_t *)buffer + count;
 10080c6:	4435      	add	r5, r6
		len -= count;
 10080c8:	1ba4      	subs	r4, r4, r6
 10080ca:	e7e1      	b.n	1008090 <bt_hci_le_rand+0x10>
		return -ENOTSUP;
 10080cc:	f06f 0085 	mvn.w	r0, #133	; 0x85
 10080d0:	e7e0      	b.n	1008094 <bt_hci_le_rand+0x14>
 10080d2:	bf00      	nop
 10080d4:	21000000 	.word	0x21000000

010080d8 <bt_hci_le_enh_conn_complete>:
{
 10080d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10080dc:	b08d      	sub	sp, #52	; 0x34
	uint16_t handle = sys_le16_to_cpu(evt->handle);
 10080de:	f8b0 8001 	ldrh.w	r8, [r0, #1]
 10080e2:	49b4      	ldr	r1, [pc, #720]	; (10083b4 <bt_hci_le_enh_conn_complete+0x2dc>)
	handle |= ~BT_ACL_HANDLE_MASK;
 10080e4:	ea6f 5308 	mvn.w	r3, r8, lsl #20
 10080e8:	ea6f 5313 	mvn.w	r3, r3, lsr #20
{
 10080ec:	4605      	mov	r5, r0
	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
 10080ee:	2200      	movs	r2, #0
 10080f0:	4608      	mov	r0, r1
{
 10080f2:	af02      	add	r7, sp, #8
	uint16_t handle = sys_le16_to_cpu(evt->handle);
 10080f4:	fa1f f688 	uxth.w	r6, r8
	handle |= ~BT_ACL_HANDLE_MASK;
 10080f8:	b29b      	uxth	r3, r3
		if (disconnected_handles[i] == handle) {
 10080fa:	f831 4b02 	ldrh.w	r4, [r1], #2
 10080fe:	42a3      	cmp	r3, r4
 1008100:	d126      	bne.n	1008150 <bt_hci_le_enh_conn_complete+0x78>
			disconnected_handles[i] = 0;
 1008102:	2300      	movs	r3, #0
			return true;
 1008104:	f04f 0901 	mov.w	r9, #1
			disconnected_handles[i] = 0;
 1008108:	f820 3012 	strh.w	r3, [r0, r2, lsl #1]
	bt_id_pending_keys_update();
 100810c:	f000 fde2 	bl	1008cd4 <bt_id_pending_keys_update>
	if (evt->status) {
 1008110:	782c      	ldrb	r4, [r5, #0]
 1008112:	2c00      	cmp	r4, #0
 1008114:	d03a      	beq.n	100818c <bt_hci_le_enh_conn_complete+0xb4>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
 1008116:	2c3c      	cmp	r4, #60	; 0x3c
 1008118:	d128      	bne.n	100816c <bt_hci_le_enh_conn_complete+0x94>
		struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
 100811a:	f001 f951 	bl	10093c0 <bt_le_adv_lookup_legacy>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 100811e:	f06f 0180 	mvn.w	r1, #128	; 0x80
 1008122:	3010      	adds	r0, #16
 1008124:	f01e fd5f 	bl	1026be6 <atomic_and.isra.0>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_PERIPHERAL) {
 1008128:	2000      	movs	r0, #0
 100812a:	f7ff f9bb 	bl	10074a4 <find_pending_connect.part.0>
		if (!conn) {
 100812e:	4605      	mov	r5, r0
 1008130:	b9a0      	cbnz	r0, 100815c <bt_hci_le_enh_conn_complete+0x84>
			LOG_ERR("No pending peripheral connection");
 1008132:	4ba1      	ldr	r3, [pc, #644]	; (10083b8 <bt_hci_le_enh_conn_complete+0x2e0>)
 1008134:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1008138:	627b      	str	r3, [r7, #36]	; 0x24
 100813a:	2302      	movs	r3, #2
 100813c:	489f      	ldr	r0, [pc, #636]	; (10083bc <bt_hci_le_enh_conn_complete+0x2e4>)
 100813e:	623b      	str	r3, [r7, #32]
 1008140:	f107 0220 	add.w	r2, r7, #32
 1008144:	f01e fd4c 	bl	1026be0 <z_log_msg_static_create.constprop.0>
}
 1008148:	372c      	adds	r7, #44	; 0x2c
 100814a:	46bd      	mov	sp, r7
 100814c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
 1008150:	3201      	adds	r2, #1
 1008152:	2a08      	cmp	r2, #8
 1008154:	d1d1      	bne.n	10080fa <bt_hci_le_enh_conn_complete+0x22>
	return false;
 1008156:	f04f 0900 	mov.w	r9, #0
 100815a:	e7d7      	b.n	100810c <bt_hci_le_enh_conn_complete+0x34>
		conn->err = BT_HCI_ERR_ADV_TIMEOUT;
 100815c:	7304      	strb	r4, [r0, #12]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
 100815e:	2100      	movs	r1, #0
 1008160:	f001 ffd4 	bl	100a10c <bt_conn_set_state>
		bt_conn_unref(conn);
 1008164:	4628      	mov	r0, r5
	bt_conn_unref(conn);
 1008166:	f001 ff99 	bl	100a09c <bt_conn_unref>
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
 100816a:	e7ed      	b.n	1008148 <bt_hci_le_enh_conn_complete+0x70>
		LOG_WRN("Unexpected status 0x%02x", evt->status);
 100816c:	466d      	mov	r5, sp
 100816e:	b088      	sub	sp, #32
 1008170:	aa02      	add	r2, sp, #8
 1008172:	4b93      	ldr	r3, [pc, #588]	; (10083c0 <bt_hci_le_enh_conn_complete+0x2e8>)
 1008174:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 1008178:	e9c2 3405 	strd	r3, r4, [r2, #20]
 100817c:	2303      	movs	r3, #3
 100817e:	488f      	ldr	r0, [pc, #572]	; (10083bc <bt_hci_le_enh_conn_complete+0x2e4>)
 1008180:	f842 3f10 	str.w	r3, [r2, #16]!
 1008184:	f01e fd2c 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 1008188:	46ad      	mov	sp, r5
		return;
 100818a:	e7dd      	b.n	1008148 <bt_hci_le_enh_conn_complete+0x70>
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
 100818c:	792b      	ldrb	r3, [r5, #4]
		bt_addr_le_copy(&id_addr, &evt->peer_addr);
 100818e:	f105 0a04 	add.w	sl, r5, #4
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
 1008192:	3b02      	subs	r3, #2
 1008194:	2b01      	cmp	r3, #1
 1008196:	d82d      	bhi.n	10081f4 <bt_hci_le_enh_conn_complete+0x11c>
		bt_addr_le_copy(&id_addr, &evt->peer_addr);
 1008198:	4651      	mov	r1, sl
 100819a:	f107 0010 	add.w	r0, r7, #16
 100819e:	f01e fd11 	bl	1026bc4 <bt_addr_le_copy>
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
 10081a2:	7c3b      	ldrb	r3, [r7, #16]
	memcpy(dst, src, sizeof(*dst));
 10081a4:	2206      	movs	r2, #6
 10081a6:	3b02      	subs	r3, #2
 10081a8:	743b      	strb	r3, [r7, #16]
 10081aa:	f105 0111 	add.w	r1, r5, #17
 10081ae:	f107 0009 	add.w	r0, r7, #9
 10081b2:	f01e fbdf 	bl	1026974 <memcpy>
		peer_addr.type = BT_ADDR_LE_RANDOM;
 10081b6:	2301      	movs	r3, #1
 10081b8:	723b      	strb	r3, [r7, #8]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_PERIPHERAL) {
 10081ba:	78eb      	ldrb	r3, [r5, #3]
 10081bc:	2b01      	cmp	r3, #1
 10081be:	d02e      	beq.n	100821e <bt_hci_le_enh_conn_complete+0x146>
		LOG_ERR("No pending conn for peer %s", bt_addr_le_str(&evt->peer_addr));
 10081c0:	4650      	mov	r0, sl
 10081c2:	f7fe fd43 	bl	1006c4c <bt_addr_le_str>
 10081c6:	466c      	mov	r4, sp
 10081c8:	b088      	sub	sp, #32
 10081ca:	aa02      	add	r2, sp, #8
 10081cc:	4b7d      	ldr	r3, [pc, #500]	; (10083c4 <bt_hci_le_enh_conn_complete+0x2ec>)
 10081ce:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 10081d2:	e9c2 3005 	strd	r3, r0, [r2, #20]
 10081d6:	f44f 7300 	mov.w	r3, #512	; 0x200
 10081da:	8393      	strh	r3, [r2, #28]
 10081dc:	4b7a      	ldr	r3, [pc, #488]	; (10083c8 <bt_hci_le_enh_conn_complete+0x2f0>)
 10081de:	4877      	ldr	r0, [pc, #476]	; (10083bc <bt_hci_le_enh_conn_complete+0x2e4>)
 10081e0:	f842 3f10 	str.w	r3, [r2, #16]!
 10081e4:	f01e fcfc 	bl	1026be0 <z_log_msg_static_create.constprop.0>
		bt_hci_disconnect(handle, BT_HCI_ERR_UNSPECIFIED);
 10081e8:	211f      	movs	r1, #31
 10081ea:	46a5      	mov	sp, r4
 10081ec:	4630      	mov	r0, r6
 10081ee:	f01e fd2d 	bl	1026c4c <bt_hci_disconnect>
		return;
 10081f2:	e7a9      	b.n	1008148 <bt_hci_le_enh_conn_complete+0x70>
		uint8_t id = evt->role == BT_HCI_ROLE_PERIPHERAL ? bt_dev.adv_conn_id :
 10081f4:	78eb      	ldrb	r3, [r5, #3]
		bt_addr_le_copy(&id_addr,
 10081f6:	4651      	mov	r1, sl
		uint8_t id = evt->role == BT_HCI_ROLE_PERIPHERAL ? bt_dev.adv_conn_id :
 10081f8:	2b01      	cmp	r3, #1
 10081fa:	bf04      	itt	eq
 10081fc:	4b73      	ldreq	r3, [pc, #460]	; (10083cc <bt_hci_le_enh_conn_complete+0x2f4>)
 10081fe:	f893 4067 	ldrbeq.w	r4, [r3, #103]	; 0x67
		bt_addr_le_copy(&id_addr,
 1008202:	4620      	mov	r0, r4
 1008204:	f01e fe79 	bl	1026efa <bt_lookup_id_addr>
 1008208:	4601      	mov	r1, r0
 100820a:	f107 0010 	add.w	r0, r7, #16
 100820e:	f01e fcd9 	bl	1026bc4 <bt_addr_le_copy>
		bt_addr_le_copy(&peer_addr, &evt->peer_addr);
 1008212:	4651      	mov	r1, sl
 1008214:	f107 0008 	add.w	r0, r7, #8
 1008218:	f01e fcd4 	bl	1026bc4 <bt_addr_le_copy>
 100821c:	e7cd      	b.n	10081ba <bt_hci_le_enh_conn_complete+0xe2>
 100821e:	f107 0010 	add.w	r0, r7, #16
 1008222:	f7ff f93f 	bl	10074a4 <find_pending_connect.part.0>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
 1008226:	78eb      	ldrb	r3, [r5, #3]
 1008228:	4604      	mov	r4, r0
 100822a:	2b01      	cmp	r3, #1
 100822c:	d10a      	bne.n	1008244 <bt_hci_le_enh_conn_complete+0x16c>
		struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
 100822e:	f001 f8c7 	bl	10093c0 <bt_le_adv_lookup_legacy>
 1008232:	4683      	mov	fp, r0
 1008234:	f06f 0180 	mvn.w	r1, #128	; 0x80
 1008238:	3010      	adds	r0, #16
 100823a:	f01e fcd4 	bl	1026be6 <atomic_and.isra.0>
		(void)bt_le_lim_adv_cancel_timeout(adv);
 100823e:	4658      	mov	r0, fp
 1008240:	f01e ff75 	bl	102712e <bt_le_lim_adv_cancel_timeout>
	if (!conn) {
 1008244:	2c00      	cmp	r4, #0
 1008246:	d0bb      	beq.n	10081c0 <bt_hci_le_enh_conn_complete+0xe8>
	conn->handle = handle;
 1008248:	4620      	mov	r0, r4
	bt_addr_le_copy(&conn->le.dst, &id_addr);
 100824a:	f107 0110 	add.w	r1, r7, #16
	conn->handle = handle;
 100824e:	f820 8b90 	strh.w	r8, [r0], #144
	bt_addr_le_copy(&conn->le.dst, &id_addr);
 1008252:	f01e fcb7 	bl	1026bc4 <bt_addr_le_copy>
	conn->err = 0U;
 1008256:	2200      	movs	r2, #0
	conn->le.interval = sys_le16_to_cpu(evt->interval);
 1008258:	f8b5 3017 	ldrh.w	r3, [r5, #23]
 100825c:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
	conn->le.latency = sys_le16_to_cpu(evt->latency);
 1008260:	f8b5 3019 	ldrh.w	r3, [r5, #25]
 1008264:	f8a4 30ac 	strh.w	r3, [r4, #172]	; 0xac
	conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
 1008268:	f8b5 301b 	ldrh.w	r3, [r5, #27]
 100826c:	f8a4 30ae 	strh.w	r3, [r4, #174]	; 0xae
	conn->role = evt->role;
 1008270:	78eb      	ldrb	r3, [r5, #3]
	conn->err = 0U;
 1008272:	7322      	strb	r2, [r4, #12]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
 1008274:	2b01      	cmp	r3, #1
	conn->role = evt->role;
 1008276:	70e3      	strb	r3, [r4, #3]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
 1008278:	d116      	bne.n	10082a8 <bt_hci_le_enh_conn_complete+0x1d0>
		bt_addr_le_copy(&conn->le.init_addr, &peer_addr);
 100827a:	f107 0108 	add.w	r1, r7, #8
 100827e:	f104 0097 	add.w	r0, r4, #151	; 0x97
 1008282:	f01e fc9f 	bl	1026bc4 <bt_addr_le_copy>
			struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
 1008286:	f001 f89b 	bl	10093c0 <bt_le_adv_lookup_legacy>
						&bt_dev.id_addr[conn->id]);
 100828a:	7a21      	ldrb	r1, [r4, #8]
 100828c:	4d4f      	ldr	r5, [pc, #316]	; (10083cc <bt_hci_le_enh_conn_complete+0x2f4>)
 100828e:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
				bt_addr_le_copy(&conn->le.resp_addr,
 1008292:	4429      	add	r1, r5
 1008294:	f104 009e 	add.w	r0, r4, #158	; 0x9e
 1008298:	f01e fc94 	bl	1026bc4 <bt_addr_le_copy>
		if (BT_LE_STATES_PER_CONN_ADV(bt_dev.le.states)) {
 100829c:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
 10082a0:	065d      	lsls	r5, r3, #25
 10082a2:	d501      	bpl.n	10082a8 <bt_hci_le_enh_conn_complete+0x1d0>
			bt_le_adv_resume();
 10082a4:	f001 fa56 	bl	1009754 <bt_le_adv_resume>
	bt_conn_set_state(conn, BT_CONN_CONNECTED);
 10082a8:	2107      	movs	r1, #7
 10082aa:	4620      	mov	r0, r4
 10082ac:	f001 ff2e 	bl	100a10c <bt_conn_set_state>
	if (is_disconnected) {
 10082b0:	f1b9 0f00 	cmp.w	r9, #0
 10082b4:	d003      	beq.n	10082be <bt_hci_le_enh_conn_complete+0x1e6>
		bt_conn_set_state(conn, BT_CONN_DISCONNECT_COMPLETE);
 10082b6:	2101      	movs	r1, #1
 10082b8:	4620      	mov	r0, r4
 10082ba:	f001 ff27 	bl	100a10c <bt_conn_set_state>
	bt_conn_connected(conn);
 10082be:	4620      	mov	r0, r4
 10082c0:	f01e ff8f 	bl	10271e2 <bt_conn_connected>
	if (conn->state != BT_CONN_CONNECTED) {
 10082c4:	7b63      	ldrb	r3, [r4, #13]
 10082c6:	2b07      	cmp	r3, #7
 10082c8:	d16e      	bne.n	10083a8 <bt_hci_le_enh_conn_complete+0x2d0>
 10082ca:	1d23      	adds	r3, r4, #4
 10082cc:	e8d3 3faf 	lda	r3, [r3]
	if (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&
 10082d0:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 10082d4:	4d3d      	ldr	r5, [pc, #244]	; (10083cc <bt_hci_le_enh_conn_complete+0x2f4>)
 10082d6:	d129      	bne.n	100832c <bt_hci_le_enh_conn_complete+0x254>
 10082d8:	78e3      	ldrb	r3, [r4, #3]
 10082da:	b11b      	cbz	r3, 10082e4 <bt_hci_le_enh_conn_complete+0x20c>
	    ((conn->role == BT_HCI_ROLE_CENTRAL) ||
 10082dc:	f895 30d0 	ldrb.w	r3, [r5, #208]	; 0xd0
 10082e0:	0718      	lsls	r0, r3, #28
 10082e2:	d523      	bpl.n	100832c <bt_hci_le_enh_conn_complete+0x254>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES,
 10082e4:	2102      	movs	r1, #2
 10082e6:	f242 0016 	movw	r0, #8214	; 0x2016
 10082ea:	f7ff fccf 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 10082ee:	4606      	mov	r6, r0
 10082f0:	2800      	cmp	r0, #0
 10082f2:	d05b      	beq.n	10083ac <bt_hci_le_enh_conn_complete+0x2d4>
 10082f4:	2102      	movs	r1, #2
 10082f6:	300c      	adds	r0, #12
 10082f8:	f015 ffce 	bl	101e298 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
 10082fc:	8823      	ldrh	r3, [r4, #0]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf, NULL);
 10082fe:	2200      	movs	r2, #0
	cp->handle = sys_cpu_to_le16(conn->handle);
 1008300:	8003      	strh	r3, [r0, #0]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf, NULL);
 1008302:	4631      	mov	r1, r6
 1008304:	f242 0016 	movw	r0, #8214	; 0x2016
 1008308:	f7ff fe16 	bl	1007f38 <bt_hci_cmd_send_sync>
		if (err) {
 100830c:	b170      	cbz	r0, 100832c <bt_hci_le_enh_conn_complete+0x254>
			LOG_ERR("Failed read remote features (%d)", err);
 100830e:	466e      	mov	r6, sp
 1008310:	b088      	sub	sp, #32
 1008312:	aa02      	add	r2, sp, #8
 1008314:	4b2e      	ldr	r3, [pc, #184]	; (10083d0 <bt_hci_le_enh_conn_complete+0x2f8>)
 1008316:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100831a:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100831e:	2303      	movs	r3, #3
 1008320:	4826      	ldr	r0, [pc, #152]	; (10083bc <bt_hci_le_enh_conn_complete+0x2e4>)
 1008322:	f842 3f10 	str.w	r3, [r2, #16]!
 1008326:	f01e fc5b 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 100832a:	46b5      	mov	sp, r6
	if (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&
 100832c:	f895 30d1 	ldrb.w	r3, [r5, #209]	; 0xd1
 1008330:	07d9      	lsls	r1, r3, #31
 1008332:	d516      	bpl.n	1008362 <bt_hci_le_enh_conn_complete+0x28a>
		err = bt_le_set_phy(conn, 0U, BT_HCI_LE_PHY_PREFER_2M,
 1008334:	2100      	movs	r1, #0
 1008336:	2302      	movs	r3, #2
 1008338:	4620      	mov	r0, r4
 100833a:	461a      	mov	r2, r3
 100833c:	9100      	str	r1, [sp, #0]
 100833e:	f01e fcbe 	bl	1026cbe <bt_le_set_phy>
		if (err) {
 1008342:	b170      	cbz	r0, 1008362 <bt_hci_le_enh_conn_complete+0x28a>
			LOG_ERR("Failed LE Set PHY (%d)", err);
 1008344:	466e      	mov	r6, sp
 1008346:	b088      	sub	sp, #32
 1008348:	aa02      	add	r2, sp, #8
 100834a:	4b22      	ldr	r3, [pc, #136]	; (10083d4 <bt_hci_le_enh_conn_complete+0x2fc>)
 100834c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1008350:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1008354:	2303      	movs	r3, #3
 1008356:	4819      	ldr	r0, [pc, #100]	; (10083bc <bt_hci_le_enh_conn_complete+0x2e4>)
 1008358:	f842 3f10 	str.w	r3, [r2, #16]!
 100835c:	f01e fc40 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 1008360:	46b5      	mov	sp, r6
	if (IS_ENABLED(CONFIG_BT_AUTO_DATA_LEN_UPDATE) &&
 1008362:	f895 30d0 	ldrb.w	r3, [r5, #208]	; 0xd0
 1008366:	069a      	lsls	r2, r3, #26
 1008368:	d51e      	bpl.n	10083a8 <bt_hci_le_enh_conn_complete+0x2d0>
		if (IS_BT_QUIRK_NO_AUTO_DLE(&bt_dev)) {
 100836a:	f8d5 3158 	ldr.w	r3, [r5, #344]	; 0x158
 100836e:	689b      	ldr	r3, [r3, #8]
 1008370:	079b      	lsls	r3, r3, #30
 1008372:	d519      	bpl.n	10083a8 <bt_hci_le_enh_conn_complete+0x2d0>
			err = hci_le_read_max_data_len(&tx_octets, &tx_time);
 1008374:	1db9      	adds	r1, r7, #6
 1008376:	1d38      	adds	r0, r7, #4
 1008378:	f7ff fe5a 	bl	1008030 <hci_le_read_max_data_len>
			if (!err) {
 100837c:	b9a0      	cbnz	r0, 10083a8 <bt_hci_le_enh_conn_complete+0x2d0>
				err = bt_le_set_data_len(conn,
 100837e:	4620      	mov	r0, r4
 1008380:	88fa      	ldrh	r2, [r7, #6]
 1008382:	88b9      	ldrh	r1, [r7, #4]
 1008384:	f01e fc7d 	bl	1026c82 <bt_le_set_data_len>
				if (err) {
 1008388:	b170      	cbz	r0, 10083a8 <bt_hci_le_enh_conn_complete+0x2d0>
					LOG_ERR("Failed to set data len (%d)", err);
 100838a:	466d      	mov	r5, sp
 100838c:	b088      	sub	sp, #32
 100838e:	aa02      	add	r2, sp, #8
 1008390:	4b11      	ldr	r3, [pc, #68]	; (10083d8 <bt_hci_le_enh_conn_complete+0x300>)
 1008392:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1008396:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100839a:	2303      	movs	r3, #3
 100839c:	4807      	ldr	r0, [pc, #28]	; (10083bc <bt_hci_le_enh_conn_complete+0x2e4>)
 100839e:	f842 3f10 	str.w	r3, [r2, #16]!
 10083a2:	f01e fc1d 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 10083a6:	46ad      	mov	sp, r5
	bt_conn_unref(conn);
 10083a8:	4620      	mov	r0, r4
 10083aa:	e6dc      	b.n	1008166 <bt_hci_le_enh_conn_complete+0x8e>
		return -ENOBUFS;
 10083ac:	f06f 0068 	mvn.w	r0, #104	; 0x68
 10083b0:	e7ad      	b.n	100830e <bt_hci_le_enh_conn_complete+0x236>
 10083b2:	bf00      	nop
 10083b4:	21008124 	.word	0x21008124
 10083b8:	0102d18e 	.word	0x0102d18e
 10083bc:	010299a4 	.word	0x010299a4
 10083c0:	0102d1af 	.word	0x0102d1af
 10083c4:	0102d1c8 	.word	0x0102d1c8
 10083c8:	01000003 	.word	0x01000003
 10083cc:	21000000 	.word	0x21000000
 10083d0:	0102d1e4 	.word	0x0102d1e4
 10083d4:	0102d205 	.word	0x0102d205
 10083d8:	0102d21c 	.word	0x0102d21c

010083dc <le_legacy_conn_complete>:
{
 10083dc:	b510      	push	{r4, lr}
	struct bt_hci_evt_le_conn_complete *evt = (void *)buf->data;
 10083de:	68c1      	ldr	r1, [r0, #12]
{
 10083e0:	b088      	sub	sp, #32
	enh.status         = evt->status;
 10083e2:	780b      	ldrb	r3, [r1, #0]
 10083e4:	4c16      	ldr	r4, [pc, #88]	; (1008440 <le_legacy_conn_complete+0x64>)
 10083e6:	f88d 3000 	strb.w	r3, [sp]
	enh.handle         = evt->handle;
 10083ea:	f8b1 3001 	ldrh.w	r3, [r1, #1]
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
 10083ee:	a801      	add	r0, sp, #4
	enh.handle         = evt->handle;
 10083f0:	f8ad 3001 	strh.w	r3, [sp, #1]
	enh.role           = evt->role;
 10083f4:	78cb      	ldrb	r3, [r1, #3]
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
 10083f6:	3104      	adds	r1, #4
	enh.role           = evt->role;
 10083f8:	f88d 3003 	strb.w	r3, [sp, #3]
	enh.interval       = evt->interval;
 10083fc:	f8b1 3007 	ldrh.w	r3, [r1, #7]
 1008400:	f8ad 3017 	strh.w	r3, [sp, #23]
	enh.latency        = evt->latency;
 1008404:	f8b1 3009 	ldrh.w	r3, [r1, #9]
 1008408:	f8ad 3019 	strh.w	r3, [sp, #25]
	enh.supv_timeout   = evt->supv_timeout;
 100840c:	f8b1 300b 	ldrh.w	r3, [r1, #11]
 1008410:	f8ad 301b 	strh.w	r3, [sp, #27]
	enh.clock_accuracy = evt->clock_accuracy;
 1008414:	7b4b      	ldrb	r3, [r1, #13]
 1008416:	f88d 301d 	strb.w	r3, [sp, #29]
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
 100841a:	f01e fbd3 	bl	1026bc4 <bt_addr_le_copy>
 100841e:	4621      	mov	r1, r4
 1008420:	2206      	movs	r2, #6
 1008422:	f10d 000b 	add.w	r0, sp, #11
 1008426:	f01e faa5 	bl	1026974 <memcpy>
 100842a:	2206      	movs	r2, #6
 100842c:	4621      	mov	r1, r4
 100842e:	f10d 0011 	add.w	r0, sp, #17
 1008432:	f01e fa9f 	bl	1026974 <memcpy>
	bt_hci_le_enh_conn_complete(evt);
 1008436:	4668      	mov	r0, sp
 1008438:	f7ff fe4e 	bl	10080d8 <bt_hci_le_enh_conn_complete>
}
 100843c:	b008      	add	sp, #32
 100843e:	bd10      	pop	{r4, pc}
 1008440:	0102cb86 	.word	0x0102cb86

01008444 <bt_security_err_get>:
	switch (hci_err) {
 1008444:	2829      	cmp	r0, #41	; 0x29
 1008446:	bf9a      	itte	ls
 1008448:	4b01      	ldrls	r3, [pc, #4]	; (1008450 <bt_security_err_get+0xc>)
 100844a:	5c18      	ldrbls	r0, [r3, r0]
{
 100844c:	2009      	movhi	r0, #9
}
 100844e:	4770      	bx	lr
 1008450:	0102d460 	.word	0x0102d460

01008454 <hci_encrypt_key_refresh_complete>:
{
 1008454:	b5f0      	push	{r4, r5, r6, r7, lr}
 1008456:	b087      	sub	sp, #28
	struct bt_hci_evt_encrypt_key_refresh_complete *evt = (void *)buf->data;
 1008458:	68c3      	ldr	r3, [r0, #12]
{
 100845a:	af00      	add	r7, sp, #0
	handle = sys_le16_to_cpu(evt->handle);
 100845c:	f8b3 6001 	ldrh.w	r6, [r3, #1]
	uint8_t status = evt->status;
 1008460:	781d      	ldrb	r5, [r3, #0]
	conn = bt_conn_lookup_handle(handle);
 1008462:	4630      	mov	r0, r6
 1008464:	f001 fe4a 	bl	100a0fc <bt_conn_lookup_handle>
	if (!conn) {
 1008468:	4604      	mov	r4, r0
 100846a:	b988      	cbnz	r0, 1008490 <hci_encrypt_key_refresh_complete+0x3c>
		LOG_ERR("Unable to look up conn with handle %u", handle);
 100846c:	466c      	mov	r4, sp
 100846e:	b088      	sub	sp, #32
 1008470:	466a      	mov	r2, sp
 1008472:	4b1f      	ldr	r3, [pc, #124]	; (10084f0 <hci_encrypt_key_refresh_complete+0x9c>)
 1008474:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1008478:	e9c2 3605 	strd	r3, r6, [r2, #20]
 100847c:	2303      	movs	r3, #3
 100847e:	481d      	ldr	r0, [pc, #116]	; (10084f4 <hci_encrypt_key_refresh_complete+0xa0>)
 1008480:	f842 3f10 	str.w	r3, [r2, #16]!
 1008484:	f01e fbac 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 1008488:	46a5      	mov	sp, r4
}
 100848a:	371c      	adds	r7, #28
 100848c:	46bd      	mov	sp, r7
 100848e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (status) {
 1008490:	b15d      	cbz	r5, 10084aa <hci_encrypt_key_refresh_complete+0x56>
	bt_conn_security_changed(conn, status, bt_security_err_get(status));
 1008492:	4628      	mov	r0, r5
 1008494:	f7ff ffd6 	bl	1008444 <bt_security_err_get>
 1008498:	4629      	mov	r1, r5
 100849a:	4602      	mov	r2, r0
 100849c:	4620      	mov	r0, r4
 100849e:	f002 f89f 	bl	100a5e0 <bt_conn_security_changed>
	bt_conn_unref(conn);
 10084a2:	4620      	mov	r0, r4
 10084a4:	f001 fdfa 	bl	100a09c <bt_conn_unref>
 10084a8:	e7ef      	b.n	100848a <hci_encrypt_key_refresh_complete+0x36>
	if (conn->type == BT_CONN_TYPE_LE) {
 10084aa:	7883      	ldrb	r3, [r0, #2]
 10084ac:	2b01      	cmp	r3, #1
 10084ae:	d1f0      	bne.n	1008492 <hci_encrypt_key_refresh_complete+0x3e>
		bt_smp_update_keys(conn);
 10084b0:	f008 f80a 	bl	10104c8 <bt_smp_update_keys>
		if (!update_sec_level(conn)) {
 10084b4:	4620      	mov	r0, r4
 10084b6:	f01e fb6c 	bl	1026b92 <update_sec_level>
 10084ba:	2800      	cmp	r0, #0
 10084bc:	d1e9      	bne.n	1008492 <hci_encrypt_key_refresh_complete+0x3e>
	bt_conn_security_changed(conn, status, bt_security_err_get(status));
 10084be:	2005      	movs	r0, #5
 10084c0:	f7ff ffc0 	bl	1008444 <bt_security_err_get>
 10084c4:	2105      	movs	r1, #5
 10084c6:	4602      	mov	r2, r0
 10084c8:	4620      	mov	r0, r4
 10084ca:	f002 f889 	bl	100a5e0 <bt_conn_security_changed>
		LOG_ERR("Failed to set required security level");
 10084ce:	4b0a      	ldr	r3, [pc, #40]	; (10084f8 <hci_encrypt_key_refresh_complete+0xa4>)
 10084d0:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10084d4:	617b      	str	r3, [r7, #20]
 10084d6:	2302      	movs	r3, #2
 10084d8:	4806      	ldr	r0, [pc, #24]	; (10084f4 <hci_encrypt_key_refresh_complete+0xa0>)
 10084da:	613b      	str	r3, [r7, #16]
 10084dc:	f107 0210 	add.w	r2, r7, #16
 10084e0:	f01e fb7e 	bl	1026be0 <z_log_msg_static_create.constprop.0>
		bt_conn_disconnect(conn, status);
 10084e4:	2105      	movs	r1, #5
 10084e6:	4620      	mov	r0, r4
 10084e8:	f01e fe84 	bl	10271f4 <bt_conn_disconnect>
 10084ec:	e7d9      	b.n	10084a2 <hci_encrypt_key_refresh_complete+0x4e>
 10084ee:	bf00      	nop
 10084f0:	0102cfa6 	.word	0x0102cfa6
 10084f4:	010299a4 	.word	0x010299a4
 10084f8:	0102d238 	.word	0x0102d238

010084fc <hci_encrypt_change>:
{
 10084fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1008500:	b086      	sub	sp, #24
	struct bt_hci_evt_encrypt_change *evt = (void *)buf->data;
 1008502:	68c6      	ldr	r6, [r0, #12]
{
 1008504:	af00      	add	r7, sp, #0
	uint16_t handle = sys_le16_to_cpu(evt->handle);
 1008506:	f8b6 8001 	ldrh.w	r8, [r6, #1]
	uint8_t status = evt->status;
 100850a:	7835      	ldrb	r5, [r6, #0]
	conn = bt_conn_lookup_handle(handle);
 100850c:	4640      	mov	r0, r8
 100850e:	f001 fdf5 	bl	100a0fc <bt_conn_lookup_handle>
	if (!conn) {
 1008512:	4604      	mov	r4, r0
 1008514:	b990      	cbnz	r0, 100853c <hci_encrypt_change+0x40>
		LOG_ERR("Unable to look up conn with handle %u", handle);
 1008516:	466c      	mov	r4, sp
 1008518:	b088      	sub	sp, #32
 100851a:	466a      	mov	r2, sp
 100851c:	4b23      	ldr	r3, [pc, #140]	; (10085ac <hci_encrypt_change+0xb0>)
 100851e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1008522:	e9c2 3805 	strd	r3, r8, [r2, #20]
 1008526:	2303      	movs	r3, #3
 1008528:	4821      	ldr	r0, [pc, #132]	; (10085b0 <hci_encrypt_change+0xb4>)
 100852a:	f842 3f10 	str.w	r3, [r2, #16]!
 100852e:	f01e fb57 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 1008532:	46a5      	mov	sp, r4
}
 1008534:	3718      	adds	r7, #24
 1008536:	46bd      	mov	sp, r7
 1008538:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (status) {
 100853c:	b15d      	cbz	r5, 1008556 <hci_encrypt_change+0x5a>
		bt_conn_security_changed(conn, status,
 100853e:	4628      	mov	r0, r5
 1008540:	f7ff ff80 	bl	1008444 <bt_security_err_get>
 1008544:	4629      	mov	r1, r5
 1008546:	4602      	mov	r2, r0
	bt_conn_security_changed(conn, status, bt_security_err_get(status));
 1008548:	4620      	mov	r0, r4
 100854a:	f002 f849 	bl	100a5e0 <bt_conn_security_changed>
	bt_conn_unref(conn);
 100854e:	4620      	mov	r0, r4
 1008550:	f001 fda4 	bl	100a09c <bt_conn_unref>
 1008554:	e7ee      	b.n	1008534 <hci_encrypt_change+0x38>
	if (conn->type == BT_CONN_TYPE_LE) {
 1008556:	7882      	ldrb	r2, [r0, #2]
	conn->encrypt = evt->encrypt;
 1008558:	78f3      	ldrb	r3, [r6, #3]
	if (conn->type == BT_CONN_TYPE_LE) {
 100855a:	2a01      	cmp	r2, #1
	conn->encrypt = evt->encrypt;
 100855c:	72c3      	strb	r3, [r0, #11]
	if (conn->type == BT_CONN_TYPE_LE) {
 100855e:	d005      	beq.n	100856c <hci_encrypt_change+0x70>
	bt_conn_security_changed(conn, status, bt_security_err_get(status));
 1008560:	2000      	movs	r0, #0
 1008562:	f7ff ff6f 	bl	1008444 <bt_security_err_get>
 1008566:	2100      	movs	r1, #0
 1008568:	4602      	mov	r2, r0
 100856a:	e7ed      	b.n	1008548 <hci_encrypt_change+0x4c>
		if (conn->encrypt) {
 100856c:	b10b      	cbz	r3, 1008572 <hci_encrypt_change+0x76>
			bt_smp_update_keys(conn);
 100856e:	f007 ffab 	bl	10104c8 <bt_smp_update_keys>
		if (!update_sec_level(conn)) {
 1008572:	4620      	mov	r0, r4
 1008574:	f01e fb0d 	bl	1026b92 <update_sec_level>
 1008578:	2800      	cmp	r0, #0
 100857a:	d1f1      	bne.n	1008560 <hci_encrypt_change+0x64>
	bt_conn_security_changed(conn, status, bt_security_err_get(status));
 100857c:	2005      	movs	r0, #5
 100857e:	f7ff ff61 	bl	1008444 <bt_security_err_get>
 1008582:	2105      	movs	r1, #5
 1008584:	4602      	mov	r2, r0
 1008586:	4620      	mov	r0, r4
 1008588:	f002 f82a 	bl	100a5e0 <bt_conn_security_changed>
		LOG_ERR("Failed to set required security level");
 100858c:	4b09      	ldr	r3, [pc, #36]	; (10085b4 <hci_encrypt_change+0xb8>)
 100858e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1008592:	617b      	str	r3, [r7, #20]
 1008594:	2302      	movs	r3, #2
 1008596:	4806      	ldr	r0, [pc, #24]	; (10085b0 <hci_encrypt_change+0xb4>)
 1008598:	613b      	str	r3, [r7, #16]
 100859a:	f107 0210 	add.w	r2, r7, #16
 100859e:	f01e fb1f 	bl	1026be0 <z_log_msg_static_create.constprop.0>
		bt_conn_disconnect(conn, status);
 10085a2:	2105      	movs	r1, #5
 10085a4:	4620      	mov	r0, r4
 10085a6:	f01e fe25 	bl	10271f4 <bt_conn_disconnect>
 10085aa:	e7d0      	b.n	100854e <hci_encrypt_change+0x52>
 10085ac:	0102cfa6 	.word	0x0102cfa6
 10085b0:	010299a4 	.word	0x010299a4
 10085b4:	0102d238 	.word	0x0102d238

010085b8 <hci_event_prio>:
{
 10085b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10085bc:	4604      	mov	r4, r0
	net_buf_simple_save(&buf->b, &state);
 10085be:	f100 060c 	add.w	r6, r0, #12
	state->offset = net_buf_simple_headroom(buf);
 10085c2:	4630      	mov	r0, r6
 10085c4:	f020 fbd8 	bl	1028d78 <net_buf_simple_headroom>
	state->len = buf->len;
 10085c8:	f8b4 8010 	ldrh.w	r8, [r4, #16]
	state->offset = net_buf_simple_headroom(buf);
 10085cc:	4605      	mov	r5, r0
	BT_ASSERT(buf->len >= sizeof(*hdr));
 10085ce:	f1b8 0f01 	cmp.w	r8, #1
 10085d2:	d80c      	bhi.n	10085ee <hci_event_prio+0x36>
 10085d4:	f640 537b 	movw	r3, #3451	; 0xd7b
 10085d8:	4a1b      	ldr	r2, [pc, #108]	; (1008648 <hci_event_prio+0x90>)
 10085da:	491c      	ldr	r1, [pc, #112]	; (100864c <hci_event_prio+0x94>)
 10085dc:	481c      	ldr	r0, [pc, #112]	; (1008650 <hci_event_prio+0x98>)
 10085de:	f01c fafa 	bl	1024bd6 <assert_print>
 10085e2:	4040      	eors	r0, r0
 10085e4:	f380 8811 	msr	BASEPRI, r0
 10085e8:	f04f 0003 	mov.w	r0, #3
 10085ec:	df02      	svc	2
	return net_buf_simple_pull_mem(&buf->b, len);
 10085ee:	4630      	mov	r0, r6
 10085f0:	2102      	movs	r1, #2
 10085f2:	f015 fe33 	bl	101e25c <net_buf_simple_pull_mem>
 10085f6:	4607      	mov	r7, r0
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
 10085f8:	7800      	ldrb	r0, [r0, #0]
 10085fa:	f01e fab8 	bl	1026b6e <bt_hci_evt_get_flags>
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
 10085fe:	07c2      	lsls	r2, r0, #31
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
 1008600:	4606      	mov	r6, r0
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
 1008602:	d40c      	bmi.n	100861e <hci_event_prio+0x66>
 1008604:	f640 537f 	movw	r3, #3455	; 0xd7f
 1008608:	4a0f      	ldr	r2, [pc, #60]	; (1008648 <hci_event_prio+0x90>)
 100860a:	4912      	ldr	r1, [pc, #72]	; (1008654 <hci_event_prio+0x9c>)
 100860c:	4810      	ldr	r0, [pc, #64]	; (1008650 <hci_event_prio+0x98>)
 100860e:	f01c fae2 	bl	1024bd6 <assert_print>
 1008612:	4040      	eors	r0, r0
 1008614:	f380 8811 	msr	BASEPRI, r0
 1008618:	f04f 0003 	mov.w	r0, #3
 100861c:	df02      	svc	2
	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
 100861e:	2305      	movs	r3, #5
 1008620:	4621      	mov	r1, r4
 1008622:	4a0d      	ldr	r2, [pc, #52]	; (1008658 <hci_event_prio+0xa0>)
 1008624:	7838      	ldrb	r0, [r7, #0]
 1008626:	f7ff f829 	bl	100767c <handle_event>
	if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
 100862a:	07b3      	lsls	r3, r6, #30
 100862c:	d507      	bpl.n	100863e <hci_event_prio+0x86>
	buf->data = buf->__buf + state->offset;
 100862e:	6963      	ldr	r3, [r4, #20]
 1008630:	b2ad      	uxth	r5, r5
 1008632:	442b      	add	r3, r5
 1008634:	60e3      	str	r3, [r4, #12]
	buf->len = state->len;
 1008636:	f8a4 8010 	strh.w	r8, [r4, #16]
}
 100863a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		net_buf_unref(buf);
 100863e:	4620      	mov	r0, r4
}
 1008640:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		net_buf_unref(buf);
 1008644:	f015 bccc 	b.w	101dfe0 <net_buf_unref>
 1008648:	0102d056 	.word	0x0102d056
 100864c:	0102d25e 	.word	0x0102d25e
 1008650:	0102b695 	.word	0x0102b695
 1008654:	0102d277 	.word	0x0102d277
 1008658:	01029eb0 	.word	0x01029eb0

0100865c <bt_recv>:
{
 100865c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
 100865e:	7e03      	ldrb	r3, [r0, #24]
 1008660:	4604      	mov	r4, r0
	switch (bt_buf_get_type(buf)) {
 1008662:	2b01      	cmp	r3, #1
{
 1008664:	af00      	add	r7, sp, #0
	switch (bt_buf_get_type(buf)) {
 1008666:	d054      	beq.n	1008712 <bt_recv+0xb6>
 1008668:	2b03      	cmp	r3, #3
 100866a:	f040 8081 	bne.w	1008770 <bt_recv+0x114>
	BT_ASSERT(buf->len >= sizeof(*hdr));
 100866e:	8a03      	ldrh	r3, [r0, #16]
 1008670:	2b03      	cmp	r3, #3
 1008672:	d80c      	bhi.n	100868e <bt_recv+0x32>
 1008674:	f240 13ed 	movw	r3, #493	; 0x1ed
 1008678:	4a48      	ldr	r2, [pc, #288]	; (100879c <bt_recv+0x140>)
 100867a:	4949      	ldr	r1, [pc, #292]	; (10087a0 <bt_recv+0x144>)
 100867c:	4849      	ldr	r0, [pc, #292]	; (10087a4 <bt_recv+0x148>)
 100867e:	f01c faaa 	bl	1024bd6 <assert_print>
 1008682:	4040      	eors	r0, r0
 1008684:	f380 8811 	msr	BASEPRI, r0
 1008688:	f04f 0003 	mov.w	r0, #3
 100868c:	df02      	svc	2
	return net_buf_simple_pull_mem(&buf->b, len);
 100868e:	2104      	movs	r1, #4
 1008690:	f104 000c 	add.w	r0, r4, #12
 1008694:	f015 fde2 	bl	101e25c <net_buf_simple_pull_mem>
	acl(buf)->index = BT_CONN_INDEX_INVALID;
 1008698:	22ff      	movs	r2, #255	; 0xff
	len = sys_le16_to_cpu(hdr->len);
 100869a:	8843      	ldrh	r3, [r0, #2]
	handle = sys_le16_to_cpu(hdr->handle);
 100869c:	8806      	ldrh	r6, [r0, #0]
	if (buf->len != len) {
 100869e:	8a21      	ldrh	r1, [r4, #16]
	acl(buf)->handle = bt_acl_handle(handle);
 10086a0:	f3c6 000b 	ubfx	r0, r6, #0, #12
	if (buf->len != len) {
 10086a4:	428b      	cmp	r3, r1
	acl(buf)->handle = bt_acl_handle(handle);
 10086a6:	8360      	strh	r0, [r4, #26]
	acl(buf)->index = BT_CONN_INDEX_INVALID;
 10086a8:	7662      	strb	r2, [r4, #25]
	if (buf->len != len) {
 10086aa:	d013      	beq.n	10086d4 <bt_recv+0x78>
		LOG_ERR("ACL data length mismatch (%u != %u)", buf->len, len);
 10086ac:	466d      	mov	r5, sp
 10086ae:	b088      	sub	sp, #32
 10086b0:	466a      	mov	r2, sp
 10086b2:	483d      	ldr	r0, [pc, #244]	; (10087a8 <bt_recv+0x14c>)
 10086b4:	61d3      	str	r3, [r2, #28]
 10086b6:	2304      	movs	r3, #4
 10086b8:	e9c2 0105 	strd	r0, r1, [r2, #20]
 10086bc:	f44f 5101 	mov.w	r1, #8256	; 0x2040
 10086c0:	f842 3f10 	str.w	r3, [r2, #16]!
		LOG_ERR("Unable to find conn for handle %u", acl(buf)->handle);
 10086c4:	4839      	ldr	r0, [pc, #228]	; (10087ac <bt_recv+0x150>)
 10086c6:	f01e fa8b 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 10086ca:	46ad      	mov	sp, r5
	net_buf_unref(buf);
 10086cc:	4620      	mov	r0, r4
 10086ce:	f015 fc87 	bl	101dfe0 <net_buf_unref>
}
 10086d2:	e01b      	b.n	100870c <bt_recv+0xb0>
	conn = bt_conn_lookup_handle(acl(buf)->handle);
 10086d4:	f001 fd12 	bl	100a0fc <bt_conn_lookup_handle>
	if (!conn) {
 10086d8:	4605      	mov	r5, r0
 10086da:	b960      	cbnz	r0, 10086f6 <bt_recv+0x9a>
		LOG_ERR("Unable to find conn for handle %u", acl(buf)->handle);
 10086dc:	466d      	mov	r5, sp
 10086de:	b088      	sub	sp, #32
 10086e0:	466a      	mov	r2, sp
 10086e2:	8b63      	ldrh	r3, [r4, #26]
 10086e4:	4932      	ldr	r1, [pc, #200]	; (10087b0 <bt_recv+0x154>)
 10086e6:	e9c2 1305 	strd	r1, r3, [r2, #20]
 10086ea:	2303      	movs	r3, #3
 10086ec:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 10086f0:	f842 3f10 	str.w	r3, [r2, #16]!
 10086f4:	e7e6      	b.n	10086c4 <bt_recv+0x68>
	acl(buf)->index = bt_conn_index(conn);
 10086f6:	f001 fe1d 	bl	100a334 <bt_conn_index>
	bt_conn_recv(conn, buf, flags);
 10086fa:	4621      	mov	r1, r4
	acl(buf)->index = bt_conn_index(conn);
 10086fc:	7660      	strb	r0, [r4, #25]
	bt_conn_recv(conn, buf, flags);
 10086fe:	0b32      	lsrs	r2, r6, #12
 1008700:	4628      	mov	r0, r5
 1008702:	f001 fb5f 	bl	1009dc4 <bt_conn_recv>
	bt_conn_unref(conn);
 1008706:	4628      	mov	r0, r5
 1008708:	f001 fcc8 	bl	100a09c <bt_conn_unref>
		return 0;
 100870c:	2000      	movs	r0, #0
}
 100870e:	46bd      	mov	sp, r7
 1008710:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	BT_ASSERT(buf->len >= sizeof(*hdr));
 1008712:	8a03      	ldrh	r3, [r0, #16]
 1008714:	2b01      	cmp	r3, #1
 1008716:	d80c      	bhi.n	1008732 <bt_recv+0xd6>
 1008718:	f640 136d 	movw	r3, #2413	; 0x96d
 100871c:	4a1f      	ldr	r2, [pc, #124]	; (100879c <bt_recv+0x140>)
 100871e:	4920      	ldr	r1, [pc, #128]	; (10087a0 <bt_recv+0x144>)
 1008720:	4820      	ldr	r0, [pc, #128]	; (10087a4 <bt_recv+0x148>)
 1008722:	f01c fa58 	bl	1024bd6 <assert_print>
 1008726:	4040      	eors	r0, r0
 1008728:	f380 8811 	msr	BASEPRI, r0
 100872c:	f04f 0003 	mov.w	r0, #3
 1008730:	df02      	svc	2
 1008732:	2102      	movs	r1, #2
 1008734:	f104 000c 	add.w	r0, r4, #12
 1008738:	f015 fd90 	bl	101e25c <net_buf_simple_pull_mem>
 100873c:	4605      	mov	r5, r0
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
 100873e:	7800      	ldrb	r0, [r0, #0]
 1008740:	f01e fa15 	bl	1026b6e <bt_hci_evt_get_flags>
 1008744:	0783      	lsls	r3, r0, #30
 1008746:	d40c      	bmi.n	1008762 <bt_recv+0x106>
 1008748:	f640 1371 	movw	r3, #2417	; 0x971
 100874c:	4a13      	ldr	r2, [pc, #76]	; (100879c <bt_recv+0x140>)
 100874e:	4919      	ldr	r1, [pc, #100]	; (10087b4 <bt_recv+0x158>)
 1008750:	4814      	ldr	r0, [pc, #80]	; (10087a4 <bt_recv+0x148>)
 1008752:	f01c fa40 	bl	1024bd6 <assert_print>
 1008756:	4040      	eors	r0, r0
 1008758:	f380 8811 	msr	BASEPRI, r0
 100875c:	f04f 0003 	mov.w	r0, #3
 1008760:	df02      	svc	2
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
 1008762:	2306      	movs	r3, #6
 1008764:	4621      	mov	r1, r4
 1008766:	4a14      	ldr	r2, [pc, #80]	; (10087b8 <bt_recv+0x15c>)
 1008768:	7828      	ldrb	r0, [r5, #0]
 100876a:	f7fe ff87 	bl	100767c <handle_event>
 100876e:	e7ad      	b.n	10086cc <bt_recv+0x70>
		LOG_ERR("Invalid buf type %u", bt_buf_get_type(buf));
 1008770:	466d      	mov	r5, sp
 1008772:	b088      	sub	sp, #32
 1008774:	466a      	mov	r2, sp
 1008776:	4911      	ldr	r1, [pc, #68]	; (10087bc <bt_recv+0x160>)
 1008778:	480c      	ldr	r0, [pc, #48]	; (10087ac <bt_recv+0x150>)
	switch (bt_buf_get_type(buf)) {
 100877a:	e9c2 1305 	strd	r1, r3, [r2, #20]
		LOG_ERR("Invalid buf type %u", bt_buf_get_type(buf));
 100877e:	2303      	movs	r3, #3
 1008780:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1008784:	f842 3f10 	str.w	r3, [r2, #16]!
 1008788:	f01e fa2a 	bl	1026be0 <z_log_msg_static_create.constprop.0>
		net_buf_unref(buf);
 100878c:	4620      	mov	r0, r4
 100878e:	46ad      	mov	sp, r5
 1008790:	f015 fc26 	bl	101dfe0 <net_buf_unref>
		return -EINVAL;
 1008794:	f06f 0015 	mvn.w	r0, #21
 1008798:	e7b9      	b.n	100870e <bt_recv+0xb2>
 100879a:	bf00      	nop
 100879c:	0102d056 	.word	0x0102d056
 10087a0:	0102d25e 	.word	0x0102d25e
 10087a4:	0102b695 	.word	0x0102b695
 10087a8:	0102d290 	.word	0x0102d290
 10087ac:	010299a4 	.word	0x010299a4
 10087b0:	0102d2b4 	.word	0x0102d2b4
 10087b4:	0102d2d6 	.word	0x0102d2d6
 10087b8:	01029ed8 	.word	0x01029ed8
 10087bc:	0102d304 	.word	0x0102d304

010087c0 <bt_recv_prio>:
{
 10087c0:	b510      	push	{r4, lr}
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
 10087c2:	7e03      	ldrb	r3, [r0, #24]
{
 10087c4:	4604      	mov	r4, r0
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
 10087c6:	2b01      	cmp	r3, #1
 10087c8:	d00c      	beq.n	10087e4 <bt_recv_prio+0x24>
 10087ca:	f640 53d1 	movw	r3, #3537	; 0xdd1
 10087ce:	4a08      	ldr	r2, [pc, #32]	; (10087f0 <bt_recv_prio+0x30>)
 10087d0:	4908      	ldr	r1, [pc, #32]	; (10087f4 <bt_recv_prio+0x34>)
 10087d2:	4809      	ldr	r0, [pc, #36]	; (10087f8 <bt_recv_prio+0x38>)
 10087d4:	f01c f9ff 	bl	1024bd6 <assert_print>
 10087d8:	4040      	eors	r0, r0
 10087da:	f380 8811 	msr	BASEPRI, r0
 10087de:	f04f 0003 	mov.w	r0, #3
 10087e2:	df02      	svc	2
	hci_event_prio(buf);
 10087e4:	4620      	mov	r0, r4
 10087e6:	f7ff fee7 	bl	10085b8 <hci_event_prio>
}
 10087ea:	2000      	movs	r0, #0
 10087ec:	bd10      	pop	{r4, pc}
 10087ee:	bf00      	nop
 10087f0:	0102d056 	.word	0x0102d056
 10087f4:	0102d318 	.word	0x0102d318
 10087f8:	0102b695 	.word	0x0102b695

010087fc <bt_hci_driver_register>:
	if (bt_dev.drv) {
 10087fc:	4a08      	ldr	r2, [pc, #32]	; (1008820 <bt_hci_driver_register+0x24>)
{
 10087fe:	4603      	mov	r3, r0
	if (bt_dev.drv) {
 1008800:	f8d2 0158 	ldr.w	r0, [r2, #344]	; 0x158
 1008804:	b930      	cbnz	r0, 1008814 <bt_hci_driver_register+0x18>
	if (!drv->open || !drv->send) {
 1008806:	68d9      	ldr	r1, [r3, #12]
 1008808:	b139      	cbz	r1, 100881a <bt_hci_driver_register+0x1e>
 100880a:	6959      	ldr	r1, [r3, #20]
 100880c:	b129      	cbz	r1, 100881a <bt_hci_driver_register+0x1e>
	bt_dev.drv = drv;
 100880e:	f8c2 3158 	str.w	r3, [r2, #344]	; 0x158
	return 0;
 1008812:	4770      	bx	lr
		return -EALREADY;
 1008814:	f06f 0077 	mvn.w	r0, #119	; 0x77
 1008818:	4770      	bx	lr
		return -EINVAL;
 100881a:	f06f 0015 	mvn.w	r0, #21
}
 100881e:	4770      	bx	lr
 1008820:	21000000 	.word	0x21000000

01008824 <bt_finalize_init>:
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
 1008824:	2104      	movs	r1, #4
 1008826:	4801      	ldr	r0, [pc, #4]	; (100882c <bt_finalize_init+0x8>)
 1008828:	f01e b9cf 	b.w	1026bca <atomic_or>
 100882c:	210000cc 	.word	0x210000cc

01008830 <bt_init.part.0>:
static int bt_init(void)
 1008830:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
		if (!bt_dev.id_count) {
 1008832:	480c      	ldr	r0, [pc, #48]	; (1008864 <bt_init.part.0+0x34>)
 1008834:	79c3      	ldrb	r3, [r0, #7]
 1008836:	b96b      	cbnz	r3, 1008854 <bt_init.part.0+0x24>
			LOG_INF("No ID address. App must call settings_load()");
 1008838:	4b0b      	ldr	r3, [pc, #44]	; (1008868 <bt_init.part.0+0x38>)
 100883a:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
 100883e:	9305      	str	r3, [sp, #20]
 1008840:	2302      	movs	r3, #2
 1008842:	480a      	ldr	r0, [pc, #40]	; (100886c <bt_init.part.0+0x3c>)
 1008844:	aa04      	add	r2, sp, #16
 1008846:	9304      	str	r3, [sp, #16]
 1008848:	f01e f9ca 	bl	1026be0 <z_log_msg_static_create.constprop.0>
}
 100884c:	2000      	movs	r0, #0
 100884e:	b007      	add	sp, #28
 1008850:	f85d fb04 	ldr.w	pc, [sp], #4
 1008854:	2108      	movs	r1, #8
 1008856:	30cc      	adds	r0, #204	; 0xcc
 1008858:	f01e f9b7 	bl	1026bca <atomic_or>
	bt_finalize_init();
 100885c:	f7ff ffe2 	bl	1008824 <bt_finalize_init>
	return 0;
 1008860:	e7f4      	b.n	100884c <bt_init.part.0+0x1c>
 1008862:	bf00      	nop
 1008864:	21000000 	.word	0x21000000
 1008868:	0102d33b 	.word	0x0102d33b
 100886c:	010299a4 	.word	0x010299a4

01008870 <init_work>:

static void init_work(struct k_work *work)
{
 1008870:	b510      	push	{r4, lr}
	int err;

	err = bt_init();
 1008872:	f7f7 fd89 	bl	1000388 <bt_init>
	if (ready_cb) {
 1008876:	4b03      	ldr	r3, [pc, #12]	; (1008884 <init_work+0x14>)
 1008878:	681b      	ldr	r3, [r3, #0]
 100887a:	b113      	cbz	r3, 1008882 <init_work+0x12>
		ready_cb(err);
	}
}
 100887c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ready_cb(err);
 1008880:	4718      	bx	r3
}
 1008882:	bd10      	pop	{r4, pc}
 1008884:	21004700 	.word	0x21004700

01008888 <bt_enable>:
	}
}
#endif /* !CONFIG_BT_RECV_BLOCKING */

int bt_enable(bt_ready_cb_t cb)
{
 1008888:	b5f0      	push	{r4, r5, r6, r7, lr}
 100888a:	b08f      	sub	sp, #60	; 0x3c
	int err;

	if (!bt_dev.drv) {
 100888c:	4d35      	ldr	r5, [pc, #212]	; (1008964 <bt_enable+0xdc>)
{
 100888e:	4606      	mov	r6, r0
	if (!bt_dev.drv) {
 1008890:	f8d5 3158 	ldr.w	r3, [r5, #344]	; 0x158
{
 1008894:	af08      	add	r7, sp, #32
	if (!bt_dev.drv) {
 1008896:	b983      	cbnz	r3, 10088ba <bt_enable+0x32>
		LOG_ERR("No HCI driver registered");
 1008898:	4b33      	ldr	r3, [pc, #204]	; (1008968 <bt_enable+0xe0>)
		return -ENODEV;
 100889a:	f06f 0412 	mvn.w	r4, #18
		LOG_ERR("No HCI driver registered");
 100889e:	617b      	str	r3, [r7, #20]
 10088a0:	2302      	movs	r3, #2
 10088a2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10088a6:	4831      	ldr	r0, [pc, #196]	; (100896c <bt_enable+0xe4>)
 10088a8:	613b      	str	r3, [r7, #16]
 10088aa:	f107 0210 	add.w	r2, r7, #16
 10088ae:	f01e f997 	bl	1026be0 <z_log_msg_static_create.constprop.0>
		return bt_init();
	}

	k_work_submit(&bt_dev.init);
	return 0;
}
 10088b2:	4620      	mov	r0, r4
 10088b4:	371c      	adds	r7, #28
 10088b6:	46bd      	mov	sp, r7
 10088b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 10088ba:	f06f 0102 	mvn.w	r1, #2
 10088be:	f105 00cc 	add.w	r0, r5, #204	; 0xcc
 10088c2:	f01e f990 	bl	1026be6 <atomic_and.isra.0>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
 10088c6:	2101      	movs	r1, #1
 10088c8:	f01e f97f 	bl	1026bca <atomic_or>
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
 10088cc:	07c3      	lsls	r3, r0, #31
 10088ce:	d446      	bmi.n	100895e <bt_enable+0xd6>
		err = bt_settings_init();
 10088d0:	f7fe fcd0 	bl	1007274 <bt_settings_init>
		if (err) {
 10088d4:	4604      	mov	r4, r0
 10088d6:	2800      	cmp	r0, #0
 10088d8:	d1eb      	bne.n	10088b2 <bt_enable+0x2a>
	ready_cb = cb;
 10088da:	4b25      	ldr	r3, [pc, #148]	; (1008970 <bt_enable+0xe8>)
 10088dc:	601e      	str	r6, [r3, #0]
	return z_impl_k_sem_init(sem, initial_count, limit);
 10088de:	2201      	movs	r2, #1
 10088e0:	f505 7090 	add.w	r0, r5, #288	; 0x120
 10088e4:	4611      	mov	r1, r2
 10088e6:	f020 fd16 	bl	1029316 <z_impl_k_sem_init>
	z_impl_k_queue_init(queue);
 10088ea:	f505 709e 	add.w	r0, r5, #316	; 0x13c
 10088ee:	f020 fcf0 	bl	10292d2 <z_impl_k_queue_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 10088f2:	2200      	movs	r2, #0
 10088f4:	2300      	movs	r3, #0
 10088f6:	e9cd 2306 	strd	r2, r3, [sp, #24]
 10088fa:	f06f 0308 	mvn.w	r3, #8
 10088fe:	f44f 7240 	mov.w	r2, #768	; 0x300
 1008902:	e9cd 4302 	strd	r4, r3, [sp, #8]
 1008906:	e9cd 4400 	strd	r4, r4, [sp]
 100890a:	4b1a      	ldr	r3, [pc, #104]	; (1008974 <bt_enable+0xec>)
 100890c:	491a      	ldr	r1, [pc, #104]	; (1008978 <bt_enable+0xf0>)
 100890e:	9404      	str	r4, [sp, #16]
 1008910:	481a      	ldr	r0, [pc, #104]	; (100897c <bt_enable+0xf4>)
 1008912:	f018 fb13 	bl	1020f3c <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
 1008916:	491a      	ldr	r1, [pc, #104]	; (1008980 <bt_enable+0xf8>)
 1008918:	4818      	ldr	r0, [pc, #96]	; (100897c <bt_enable+0xf4>)
 100891a:	f020 fcb8 	bl	102928e <z_impl_k_thread_name_set>
	err = bt_dev.drv->open();
 100891e:	f8d5 3158 	ldr.w	r3, [r5, #344]	; 0x158
 1008922:	68db      	ldr	r3, [r3, #12]
 1008924:	4798      	blx	r3
	if (err) {
 1008926:	4604      	mov	r4, r0
 1008928:	b178      	cbz	r0, 100894a <bt_enable+0xc2>
		LOG_ERR("HCI driver open failed (%d)", err);
 100892a:	466d      	mov	r5, sp
 100892c:	b088      	sub	sp, #32
 100892e:	462a      	mov	r2, r5
 1008930:	4b14      	ldr	r3, [pc, #80]	; (1008984 <bt_enable+0xfc>)
 1008932:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1008936:	e9c5 3005 	strd	r3, r0, [r5, #20]
 100893a:	2303      	movs	r3, #3
 100893c:	480b      	ldr	r0, [pc, #44]	; (100896c <bt_enable+0xe4>)
 100893e:	f842 3f10 	str.w	r3, [r2, #16]!
 1008942:	f01e f94d 	bl	1026be0 <z_log_msg_static_create.constprop.0>
 1008946:	46ad      	mov	sp, r5
		return err;
 1008948:	e7b3      	b.n	10088b2 <bt_enable+0x2a>
	if (!cb) {
 100894a:	b91e      	cbnz	r6, 1008954 <bt_enable+0xcc>
		return bt_init();
 100894c:	f7f7 fd1c 	bl	1000388 <bt_init>
 1008950:	4604      	mov	r4, r0
 1008952:	e7ae      	b.n	10088b2 <bt_enable+0x2a>
	k_work_submit(&bt_dev.init);
 1008954:	f105 00bc 	add.w	r0, r5, #188	; 0xbc
 1008958:	f019 fa50 	bl	1021dfc <k_work_submit>
	return 0;
 100895c:	e7a9      	b.n	10088b2 <bt_enable+0x2a>
		return -EALREADY;
 100895e:	f06f 0477 	mvn.w	r4, #119	; 0x77
 1008962:	e7a6      	b.n	10088b2 <bt_enable+0x2a>
 1008964:	21000000 	.word	0x21000000
 1008968:	0102d425 	.word	0x0102d425
 100896c:	010299a4 	.word	0x010299a4
 1008970:	21004700 	.word	0x21004700
 1008974:	010078e9 	.word	0x010078e9
 1008978:	21009c88 	.word	0x21009c88
 100897c:	21001548 	.word	0x21001548
 1008980:	0102d43e 	.word	0x0102d43e
 1008984:	0102d444 	.word	0x0102d444

01008988 <bt_is_ready>:
 1008988:	4b02      	ldr	r3, [pc, #8]	; (1008994 <bt_is_ready+0xc>)
 100898a:	e8d3 0faf 	lda	r0, [r3]
}

bool bt_is_ready(void)
{
	return atomic_test_bit(bt_dev.flags, BT_DEV_READY);
}
 100898e:	f3c0 0080 	ubfx	r0, r0, #2, #1
 1008992:	4770      	bx	lr
 1008994:	210000cc 	.word	0x210000cc

01008998 <bt_get_name>:
#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	return bt_dev.name;
#else
	return CONFIG_BT_DEVICE_NAME;
#endif
}
 1008998:	4800      	ldr	r0, [pc, #0]	; (100899c <bt_get_name+0x4>)
 100899a:	4770      	bx	lr
 100899c:	0102b893 	.word	0x0102b893

010089a0 <id_find>:
		*count = bt_dev.id_count;
	}
}

static int id_find(const bt_addr_le_t *addr)
{
 10089a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10089a2:	4606      	mov	r6, r0
	uint8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
 10089a4:	2500      	movs	r5, #0
 10089a6:	4f09      	ldr	r7, [pc, #36]	; (10089cc <id_find+0x2c>)
 10089a8:	79fb      	ldrb	r3, [r7, #7]
 10089aa:	b2ec      	uxtb	r4, r5
 10089ac:	42a3      	cmp	r3, r4
 10089ae:	d802      	bhi.n	10089b6 <id_find+0x16>
		if (bt_addr_le_eq(addr, &bt_dev.id_addr[id])) {
			return id;
		}
	}

	return -ENOENT;
 10089b0:	f06f 0001 	mvn.w	r0, #1
 10089b4:	e009      	b.n	10089ca <id_find+0x2a>
		if (bt_addr_le_eq(addr, &bt_dev.id_addr[id])) {
 10089b6:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
 10089ba:	4630      	mov	r0, r6
 10089bc:	4439      	add	r1, r7
 10089be:	f01e fa0e 	bl	1026dde <bt_addr_le_eq>
 10089c2:	3501      	adds	r5, #1
 10089c4:	2800      	cmp	r0, #0
 10089c6:	d0ef      	beq.n	10089a8 <id_find+0x8>
 10089c8:	4620      	mov	r0, r4
}
 10089ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 10089cc:	21000000 	.word	0x21000000

010089d0 <id_create.constprop.0>:

static int id_create(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
 10089d0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 10089d2:	4604      	mov	r4, r0
{
	if (addr && !bt_addr_le_eq(addr, BT_ADDR_LE_ANY)) {
 10089d4:	460d      	mov	r5, r1
 10089d6:	b1a9      	cbz	r1, 1008a04 <id_create.constprop.0+0x34>
 10089d8:	4628      	mov	r0, r5
 10089da:	4916      	ldr	r1, [pc, #88]	; (1008a34 <id_create.constprop.0+0x64>)
 10089dc:	f01e f9ff 	bl	1026dde <bt_addr_le_eq>
 10089e0:	b980      	cbnz	r0, 1008a04 <id_create.constprop.0+0x34>
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
 10089e2:	4629      	mov	r1, r5
 10089e4:	4814      	ldr	r0, [pc, #80]	; (1008a38 <id_create.constprop.0+0x68>)
 10089e6:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
 10089ea:	4420      	add	r0, r4
		} while (id_find(&new_addr) >= 0);

		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);

		if (addr) {
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
 10089ec:	f01e f9ff 	bl	1026dee <bt_addr_le_copy>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
 10089f0:	4812      	ldr	r0, [pc, #72]	; (1008a3c <id_create.constprop.0+0x6c>)
 10089f2:	f01e f9ff 	bl	1026df4 <atomic_get>
#endif
	/* Only store if stack was already initialized. Before initialization
	 * we don't know the flash content, so it's potentially harmful to
	 * try to write anything there.
	 */
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
 10089f6:	0743      	lsls	r3, r0, #29
 10089f8:	d501      	bpl.n	10089fe <id_create.constprop.0+0x2e>
	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
		bt_settings_save_id();
 10089fa:	f7fe fbf1 	bl	10071e0 <bt_settings_save_id>
	}

	return 0;
 10089fe:	2000      	movs	r0, #0
}
 1008a00:	b003      	add	sp, #12
 1008a02:	bd30      	pop	{r4, r5, pc}
			err = bt_addr_le_create_static(&new_addr);
 1008a04:	4668      	mov	r0, sp
 1008a06:	f01e f8a4 	bl	1026b52 <bt_addr_le_create_static>
			if (err) {
 1008a0a:	2800      	cmp	r0, #0
 1008a0c:	d1f8      	bne.n	1008a00 <id_create.constprop.0+0x30>
		} while (id_find(&new_addr) >= 0);
 1008a0e:	4668      	mov	r0, sp
 1008a10:	f7ff ffc6 	bl	10089a0 <id_find>
 1008a14:	2800      	cmp	r0, #0
 1008a16:	daf5      	bge.n	1008a04 <id_create.constprop.0+0x34>
		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
 1008a18:	4b07      	ldr	r3, [pc, #28]	; (1008a38 <id_create.constprop.0+0x68>)
 1008a1a:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
 1008a1e:	441c      	add	r4, r3
 1008a20:	4669      	mov	r1, sp
 1008a22:	4620      	mov	r0, r4
 1008a24:	f01e f9e3 	bl	1026dee <bt_addr_le_copy>
		if (addr) {
 1008a28:	2d00      	cmp	r5, #0
 1008a2a:	d0e1      	beq.n	10089f0 <id_create.constprop.0+0x20>
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
 1008a2c:	4621      	mov	r1, r4
 1008a2e:	4628      	mov	r0, r5
 1008a30:	e7dc      	b.n	10089ec <id_create.constprop.0+0x1c>
 1008a32:	bf00      	nop
 1008a34:	0102cb79 	.word	0x0102cb79
 1008a38:	21000000 	.word	0x21000000
 1008a3c:	210000cc 	.word	0x210000cc

01008a40 <set_random_address>:
{
 1008a40:	b538      	push	{r3, r4, r5, lr}
	return memcmp(a, b, sizeof(*a));
 1008a42:	2206      	movs	r2, #6
 1008a44:	4912      	ldr	r1, [pc, #72]	; (1008a90 <set_random_address+0x50>)
 1008a46:	4605      	mov	r5, r0
 1008a48:	f01d ff84 	bl	1026954 <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
 1008a4c:	b1d8      	cbz	r0, 1008a86 <set_random_address+0x46>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
 1008a4e:	2106      	movs	r1, #6
 1008a50:	f242 0005 	movw	r0, #8197	; 0x2005
 1008a54:	f7ff f91a 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 1008a58:	4604      	mov	r4, r0
 1008a5a:	b1b0      	cbz	r0, 1008a8a <set_random_address+0x4a>
	return net_buf_simple_add_mem(&buf->b, mem, len);
 1008a5c:	2206      	movs	r2, #6
 1008a5e:	4629      	mov	r1, r5
 1008a60:	300c      	adds	r0, #12
 1008a62:	f020 f995 	bl	1028d90 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
 1008a66:	2200      	movs	r2, #0
 1008a68:	4621      	mov	r1, r4
 1008a6a:	f242 0005 	movw	r0, #8197	; 0x2005
 1008a6e:	f7ff fa63 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 1008a72:	b948      	cbnz	r0, 1008a88 <set_random_address+0x48>
	memcpy(dst, src, sizeof(*dst));
 1008a74:	2206      	movs	r2, #6
 1008a76:	4629      	mov	r1, r5
 1008a78:	4805      	ldr	r0, [pc, #20]	; (1008a90 <set_random_address+0x50>)
 1008a7a:	f01d ff7b 	bl	1026974 <memcpy>
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
 1008a7e:	2201      	movs	r2, #1
 1008a80:	4b04      	ldr	r3, [pc, #16]	; (1008a94 <set_random_address+0x54>)
 1008a82:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
		return 0;
 1008a86:	2000      	movs	r0, #0
}
 1008a88:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOBUFS;
 1008a8a:	f06f 0068 	mvn.w	r0, #104	; 0x68
 1008a8e:	e7fb      	b.n	1008a88 <set_random_address+0x48>
 1008a90:	21000061 	.word	0x21000061
 1008a94:	21000000 	.word	0x21000000

01008a98 <find_rl_conflict>:
{
 1008a98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1008a9c:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(conflict != NULL);
 1008a9e:	460c      	mov	r4, r1
{
 1008aa0:	b086      	sub	sp, #24
	__ASSERT_NO_MSG(conflict != NULL);
 1008aa2:	b959      	cbnz	r1, 1008abc <find_rl_conflict+0x24>
 1008aa4:	492b      	ldr	r1, [pc, #172]	; (1008b54 <find_rl_conflict+0xbc>)
 1008aa6:	f44f 7357 	mov.w	r3, #860	; 0x35c
 1008aaa:	4a2b      	ldr	r2, [pc, #172]	; (1008b58 <find_rl_conflict+0xc0>)
 1008aac:	482b      	ldr	r0, [pc, #172]	; (1008b5c <find_rl_conflict+0xc4>)
 1008aae:	f01c f892 	bl	1024bd6 <assert_print>
 1008ab2:	f44f 7157 	mov.w	r1, #860	; 0x35c
	__ASSERT_NO_MSG(conflict->candidate != NULL);
 1008ab6:	4828      	ldr	r0, [pc, #160]	; (1008b58 <find_rl_conflict+0xc0>)
 1008ab8:	f01c f886 	bl	1024bc8 <assert_post_action>
 1008abc:	6808      	ldr	r0, [r1, #0]
 1008abe:	b948      	cbnz	r0, 1008ad4 <find_rl_conflict+0x3c>
 1008ac0:	4927      	ldr	r1, [pc, #156]	; (1008b60 <find_rl_conflict+0xc8>)
 1008ac2:	f240 335d 	movw	r3, #861	; 0x35d
 1008ac6:	4a24      	ldr	r2, [pc, #144]	; (1008b58 <find_rl_conflict+0xc0>)
 1008ac8:	4824      	ldr	r0, [pc, #144]	; (1008b5c <find_rl_conflict+0xc4>)
 1008aca:	f01c f884 	bl	1024bd6 <assert_print>
 1008ace:	f240 315d 	movw	r1, #861	; 0x35d
 1008ad2:	e7f0      	b.n	1008ab6 <find_rl_conflict+0x1e>
	__ASSERT_NO_MSG(resident != NULL);
 1008ad4:	b94d      	cbnz	r5, 1008aea <find_rl_conflict+0x52>
 1008ad6:	4923      	ldr	r1, [pc, #140]	; (1008b64 <find_rl_conflict+0xcc>)
 1008ad8:	f240 335e 	movw	r3, #862	; 0x35e
 1008adc:	4a1e      	ldr	r2, [pc, #120]	; (1008b58 <find_rl_conflict+0xc0>)
 1008ade:	481f      	ldr	r0, [pc, #124]	; (1008b5c <find_rl_conflict+0xc4>)
 1008ae0:	f01c f879 	bl	1024bd6 <assert_print>
 1008ae4:	f240 315e 	movw	r1, #862	; 0x35e
 1008ae8:	e7e5      	b.n	1008ab6 <find_rl_conflict+0x1e>
	__ASSERT_NO_MSG((conflict->candidate->state & BT_KEYS_ID_ADDED) == 0);
 1008aea:	7a03      	ldrb	r3, [r0, #8]
 1008aec:	075a      	lsls	r2, r3, #29
 1008aee:	d509      	bpl.n	1008b04 <find_rl_conflict+0x6c>
 1008af0:	491d      	ldr	r1, [pc, #116]	; (1008b68 <find_rl_conflict+0xd0>)
 1008af2:	f44f 7358 	mov.w	r3, #864	; 0x360
 1008af6:	4a18      	ldr	r2, [pc, #96]	; (1008b58 <find_rl_conflict+0xc0>)
 1008af8:	4818      	ldr	r0, [pc, #96]	; (1008b5c <find_rl_conflict+0xc4>)
 1008afa:	f01c f86c 	bl	1024bd6 <assert_print>
 1008afe:	f44f 7158 	mov.w	r1, #864	; 0x360
 1008b02:	e7d8      	b.n	1008ab6 <find_rl_conflict+0x1e>
	if (conflict->found) {
 1008b04:	684f      	ldr	r7, [r1, #4]
 1008b06:	b9f7      	cbnz	r7, 1008b46 <find_rl_conflict+0xae>
	if ((resident->state & BT_KEYS_ID_ADDED) == 0) {
 1008b08:	7a2b      	ldrb	r3, [r5, #8]
 1008b0a:	075b      	lsls	r3, r3, #29
 1008b0c:	d51b      	bpl.n	1008b46 <find_rl_conflict+0xae>
	addr_conflict = bt_addr_le_eq(&conflict->candidate->addr, &resident->addr);
 1008b0e:	1c69      	adds	r1, r5, #1
 1008b10:	3001      	adds	r0, #1
 1008b12:	f01e f964 	bl	1026dde <bt_addr_le_eq>
	irk_conflict = (!bt_irk_eq(&conflict->candidate->irk, &(struct bt_irk){}) &&
 1008b16:	f8d4 8000 	ldr.w	r8, [r4]
 1008b1a:	2216      	movs	r2, #22
 1008b1c:	4639      	mov	r1, r7
	addr_conflict = bt_addr_le_eq(&conflict->candidate->addr, &resident->addr);
 1008b1e:	4606      	mov	r6, r0
	irk_conflict = (!bt_irk_eq(&conflict->candidate->irk, &(struct bt_irk){}) &&
 1008b20:	4668      	mov	r0, sp
 1008b22:	f01d ff32 	bl	102698a <memset>
	bt_addr_t               rpa;
};

static inline bool bt_irk_eq(struct bt_irk const *a, struct bt_irk const *b)
{
	return (memcmp(a->val, b->val, sizeof(a->val)) == 0);
 1008b26:	2210      	movs	r2, #16
 1008b28:	4669      	mov	r1, sp
 1008b2a:	f108 002a 	add.w	r0, r8, #42	; 0x2a
 1008b2e:	f01d ff11 	bl	1026954 <memcmp>
 1008b32:	b158      	cbz	r0, 1008b4c <find_rl_conflict+0xb4>
 1008b34:	6820      	ldr	r0, [r4, #0]
 1008b36:	2210      	movs	r2, #16
 1008b38:	f105 012a 	add.w	r1, r5, #42	; 0x2a
 1008b3c:	302a      	adds	r0, #42	; 0x2a
 1008b3e:	f01d ff09 	bl	1026954 <memcmp>
 1008b42:	b918      	cbnz	r0, 1008b4c <find_rl_conflict+0xb4>
		conflict->found = resident;
 1008b44:	6065      	str	r5, [r4, #4]
}
 1008b46:	b006      	add	sp, #24
 1008b48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (addr_conflict || irk_conflict) {
 1008b4c:	2e00      	cmp	r6, #0
 1008b4e:	d1f9      	bne.n	1008b44 <find_rl_conflict+0xac>
 1008b50:	e7f9      	b.n	1008b46 <find_rl_conflict+0xae>
 1008b52:	bf00      	nop
 1008b54:	0102d4c4 	.word	0x0102d4c4
 1008b58:	0102d496 	.word	0x0102d496
 1008b5c:	0102b695 	.word	0x0102b695
 1008b60:	0102d4dc 	.word	0x0102d4dc
 1008b64:	0102d4ff 	.word	0x0102d4ff
 1008b68:	0102d517 	.word	0x0102d517

01008b6c <bt_id_add.part.0>:
	conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, NULL, BT_CONN_CONNECTING);
 1008b6c:	2100      	movs	r1, #0
void bt_id_add(struct bt_keys *keys)
 1008b6e:	b5f0      	push	{r4, r5, r6, r7, lr}
	conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, NULL, BT_CONN_CONNECTING);
 1008b70:	2206      	movs	r2, #6
void bt_id_add(struct bt_keys *keys)
 1008b72:	4604      	mov	r4, r0
 1008b74:	b087      	sub	sp, #28
	conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, NULL, BT_CONN_CONNECTING);
 1008b76:	4608      	mov	r0, r1
 1008b78:	f001 fde0 	bl	100a73c <bt_conn_lookup_state_le>
	if (conn) {
 1008b7c:	4606      	mov	r6, r0
 1008b7e:	b188      	cbz	r0, 1008ba4 <bt_id_add.part.0+0x38>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1008b80:	4b49      	ldr	r3, [pc, #292]	; (1008ca8 <bt_id_add.part.0+0x13c>)
 1008b82:	e8d3 1fef 	ldaex	r1, [r3]
 1008b86:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 1008b8a:	e8c3 1fe2 	stlex	r2, r1, [r3]
 1008b8e:	2a00      	cmp	r2, #0
 1008b90:	d1f7      	bne.n	1008b82 <bt_id_add.part.0+0x16>
	keys->state |= flag;
 1008b92:	7a23      	ldrb	r3, [r4, #8]
 1008b94:	f043 0301 	orr.w	r3, r3, #1
 1008b98:	7223      	strb	r3, [r4, #8]
}
 1008b9a:	b007      	add	sp, #28
 1008b9c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		bt_conn_unref(conn);
 1008ba0:	f001 ba7c 	b.w	100a09c <bt_conn_unref>
	if (bt_dev.le.rl_entries) {
 1008ba4:	4d41      	ldr	r5, [pc, #260]	; (1008cac <bt_id_add.part.0+0x140>)
		bt_le_ext_adv_foreach(adv_pause_enabled, NULL);
 1008ba6:	4601      	mov	r1, r0
 1008ba8:	4841      	ldr	r0, [pc, #260]	; (1008cb0 <bt_id_add.part.0+0x144>)
 1008baa:	f000 fc03 	bl	10093b4 <bt_le_ext_adv_foreach>
	if (bt_dev.le.rl_entries) {
 1008bae:	f895 3119 	ldrb.w	r3, [r5, #281]	; 0x119
 1008bb2:	b173      	cbz	r3, 1008bd2 <bt_id_add.part.0+0x66>
		err = addr_res_enable(BT_HCI_ADDR_RES_DISABLE);
 1008bb4:	4630      	mov	r0, r6
 1008bb6:	f01e f95d 	bl	1026e74 <addr_res_enable>
		if (err) {
 1008bba:	b150      	cbz	r0, 1008bd2 <bt_id_add.part.0+0x66>
			LOG_WRN("Failed to disable address resolution");
 1008bbc:	4b3d      	ldr	r3, [pc, #244]	; (1008cb4 <bt_id_add.part.0+0x148>)
		LOG_WRN("Set privacy mode command is not supported");
 1008bbe:	9305      	str	r3, [sp, #20]
 1008bc0:	2302      	movs	r3, #2
 1008bc2:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 1008bc6:	9304      	str	r3, [sp, #16]
 1008bc8:	aa04      	add	r2, sp, #16
		LOG_ERR("Failed to set privacy mode");
 1008bca:	483b      	ldr	r0, [pc, #236]	; (1008cb8 <bt_id_add.part.0+0x14c>)
 1008bcc:	f01e f94f 	bl	1026e6e <z_log_msg_static_create.constprop.0>
		goto done;
 1008bd0:	e026      	b.n	1008c20 <bt_id_add.part.0+0xb4>
	if (bt_dev.le.rl_entries == bt_dev.le.rl_size) {
 1008bd2:	f895 2119 	ldrb.w	r2, [r5, #281]	; 0x119
 1008bd6:	f895 3118 	ldrb.w	r3, [r5, #280]	; 0x118
 1008bda:	429a      	cmp	r2, r3
 1008bdc:	d12a      	bne.n	1008c34 <bt_id_add.part.0+0xc8>
		LOG_WRN("Resolving list size exceeded. Switching to host.");
 1008bde:	2602      	movs	r6, #2
 1008be0:	4b36      	ldr	r3, [pc, #216]	; (1008cbc <bt_id_add.part.0+0x150>)
 1008be2:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 1008be6:	4834      	ldr	r0, [pc, #208]	; (1008cb8 <bt_id_add.part.0+0x14c>)
 1008be8:	aa04      	add	r2, sp, #16
 1008bea:	9305      	str	r3, [sp, #20]
 1008bec:	9604      	str	r6, [sp, #16]
 1008bee:	f01e f93e 	bl	1026e6e <z_log_msg_static_create.constprop.0>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_CLEAR_RL, NULL, NULL);
 1008bf2:	2200      	movs	r2, #0
 1008bf4:	f242 0029 	movw	r0, #8233	; 0x2029
 1008bf8:	4611      	mov	r1, r2
 1008bfa:	f7ff f99d 	bl	1007f38 <bt_hci_cmd_send_sync>
		if (err) {
 1008bfe:	b130      	cbz	r0, 1008c0e <bt_id_add.part.0+0xa2>
			LOG_ERR("Failed to clear resolution list");
 1008c00:	4b2f      	ldr	r3, [pc, #188]	; (1008cc0 <bt_id_add.part.0+0x154>)
 1008c02:	e9cd 6304 	strd	r6, r3, [sp, #16]
		LOG_ERR("Failed to set privacy mode");
 1008c06:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1008c0a:	aa04      	add	r2, sp, #16
 1008c0c:	e7dd      	b.n	1008bca <bt_id_add.part.0+0x5e>
		bt_dev.le.rl_entries++;
 1008c0e:	f895 3119 	ldrb.w	r3, [r5, #281]	; 0x119
 1008c12:	3301      	adds	r3, #1
 1008c14:	f885 3119 	strb.w	r3, [r5, #281]	; 0x119
		keys->state |= BT_KEYS_ID_ADDED;
 1008c18:	7a23      	ldrb	r3, [r4, #8]
 1008c1a:	f043 0304 	orr.w	r3, r3, #4
 1008c1e:	7223      	strb	r3, [r4, #8]
	addr_res_enable(BT_HCI_ADDR_RES_ENABLE);
 1008c20:	2001      	movs	r0, #1
 1008c22:	f01e f927 	bl	1026e74 <addr_res_enable>
		bt_le_ext_adv_foreach(adv_unpause_enabled, NULL);
 1008c26:	2100      	movs	r1, #0
 1008c28:	4826      	ldr	r0, [pc, #152]	; (1008cc4 <bt_id_add.part.0+0x158>)
}
 1008c2a:	b007      	add	sp, #28
 1008c2c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		bt_le_ext_adv_foreach(adv_unpause_enabled, NULL);
 1008c30:	f000 bbc0 	b.w	10093b4 <bt_le_ext_adv_foreach>
	err = hci_id_add(keys->id, &keys->addr, keys->irk.val);
 1008c34:	4622      	mov	r2, r4
 1008c36:	1c67      	adds	r7, r4, #1
 1008c38:	4639      	mov	r1, r7
 1008c3a:	f812 0b2a 	ldrb.w	r0, [r2], #42
 1008c3e:	f01e f8dc 	bl	1026dfa <hci_id_add>
	if (err) {
 1008c42:	4606      	mov	r6, r0
 1008c44:	b120      	cbz	r0, 1008c50 <bt_id_add.part.0+0xe4>
		LOG_ERR("Failed to add IRK to controller");
 1008c46:	4b20      	ldr	r3, [pc, #128]	; (1008cc8 <bt_id_add.part.0+0x15c>)
		LOG_ERR("Failed to set privacy mode");
 1008c48:	9305      	str	r3, [sp, #20]
 1008c4a:	2302      	movs	r3, #2
 1008c4c:	9304      	str	r3, [sp, #16]
 1008c4e:	e7da      	b.n	1008c06 <bt_id_add.part.0+0x9a>
	bt_dev.le.rl_entries++;
 1008c50:	f895 3119 	ldrb.w	r3, [r5, #281]	; 0x119
 1008c54:	3301      	adds	r3, #1
 1008c56:	f885 3119 	strb.w	r3, [r5, #281]	; 0x119
	keys->state |= BT_KEYS_ID_ADDED;
 1008c5a:	7a23      	ldrb	r3, [r4, #8]
 1008c5c:	f043 0304 	orr.w	r3, r3, #4
 1008c60:	7223      	strb	r3, [r4, #8]
	if (!BT_CMD_TEST(bt_dev.supported_commands, 39, 2)) {
 1008c62:	f895 309f 	ldrb.w	r3, [r5, #159]	; 0x9f
 1008c66:	075b      	lsls	r3, r3, #29
 1008c68:	d401      	bmi.n	1008c6e <bt_id_add.part.0+0x102>
		LOG_WRN("Set privacy mode command is not supported");
 1008c6a:	4b18      	ldr	r3, [pc, #96]	; (1008ccc <bt_id_add.part.0+0x160>)
 1008c6c:	e7a7      	b.n	1008bbe <bt_id_add.part.0+0x52>
	bt_addr_le_copy(&cp.id_addr, addr);
 1008c6e:	4639      	mov	r1, r7
 1008c70:	4668      	mov	r0, sp
 1008c72:	f01e f8bc 	bl	1026dee <bt_addr_le_copy>
	cp.mode = mode;
 1008c76:	2301      	movs	r3, #1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PRIVACY_MODE, sizeof(cp));
 1008c78:	2108      	movs	r1, #8
 1008c7a:	f242 004e 	movw	r0, #8270	; 0x204e
	cp.mode = mode;
 1008c7e:	f88d 3007 	strb.w	r3, [sp, #7]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PRIVACY_MODE, sizeof(cp));
 1008c82:	f7ff f803 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 1008c86:	4604      	mov	r4, r0
 1008c88:	b160      	cbz	r0, 1008ca4 <bt_id_add.part.0+0x138>
 1008c8a:	2208      	movs	r2, #8
 1008c8c:	4669      	mov	r1, sp
 1008c8e:	300c      	adds	r0, #12
 1008c90:	f020 f87e 	bl	1028d90 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PRIVACY_MODE, buf, NULL);
 1008c94:	4632      	mov	r2, r6
 1008c96:	4621      	mov	r1, r4
 1008c98:	f242 004e 	movw	r0, #8270	; 0x204e
 1008c9c:	f7ff f94c 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 1008ca0:	2800      	cmp	r0, #0
 1008ca2:	d0bd      	beq.n	1008c20 <bt_id_add.part.0+0xb4>
		LOG_ERR("Failed to set privacy mode");
 1008ca4:	4b0a      	ldr	r3, [pc, #40]	; (1008cd0 <bt_id_add.part.0+0x164>)
 1008ca6:	e7cf      	b.n	1008c48 <bt_id_add.part.0+0xdc>
 1008ca8:	210000cc 	.word	0x210000cc
 1008cac:	21000000 	.word	0x21000000
 1008cb0:	01026ecb 	.word	0x01026ecb
 1008cb4:	0102d54c 	.word	0x0102d54c
 1008cb8:	010299b4 	.word	0x010299b4
 1008cbc:	0102d571 	.word	0x0102d571
 1008cc0:	0102d5a2 	.word	0x0102d5a2
 1008cc4:	01026ea5 	.word	0x01026ea5
 1008cc8:	0102d5c2 	.word	0x0102d5c2
 1008ccc:	0102d5e2 	.word	0x0102d5e2
 1008cd0:	0102d60c 	.word	0x0102d60c

01008cd4 <bt_id_pending_keys_update>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1008cd4:	4b08      	ldr	r3, [pc, #32]	; (1008cf8 <bt_id_pending_keys_update+0x24>)
 1008cd6:	e8d3 2fef 	ldaex	r2, [r3]
 1008cda:	f422 4100 	bic.w	r1, r2, #32768	; 0x8000
 1008cde:	e8c3 1fe0 	stlex	r0, r1, [r3]
 1008ce2:	2800      	cmp	r0, #0
 1008ce4:	d1f7      	bne.n	1008cd6 <bt_id_pending_keys_update+0x2>
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_ID_PENDING)) {
 1008ce6:	0413      	lsls	r3, r2, #16
 1008ce8:	d504      	bpl.n	1008cf4 <bt_id_pending_keys_update+0x20>
			bt_keys_foreach_type(BT_KEYS_IRK, pending_id_update, NULL);
 1008cea:	2200      	movs	r2, #0
 1008cec:	2002      	movs	r0, #2
 1008cee:	4903      	ldr	r1, [pc, #12]	; (1008cfc <bt_id_pending_keys_update+0x28>)
 1008cf0:	f007 bd0e 	b.w	1010710 <bt_keys_foreach_type>
}
 1008cf4:	4770      	bx	lr
 1008cf6:	bf00      	nop
 1008cf8:	210000cc 	.word	0x210000cc
 1008cfc:	01026f59 	.word	0x01026f59

01008d00 <bt_id_find_conflict>:
	struct bt_id_conflict conflict = {
 1008d00:	2300      	movs	r3, #0
{
 1008d02:	b507      	push	{r0, r1, r2, lr}
	bt_keys_foreach_type(BT_KEYS_IRK, find_rl_conflict, &conflict);
 1008d04:	4905      	ldr	r1, [pc, #20]	; (1008d1c <bt_id_find_conflict+0x1c>)
	struct bt_id_conflict conflict = {
 1008d06:	e9cd 0300 	strd	r0, r3, [sp]
	bt_keys_foreach_type(BT_KEYS_IRK, find_rl_conflict, &conflict);
 1008d0a:	466a      	mov	r2, sp
 1008d0c:	2002      	movs	r0, #2
 1008d0e:	f007 fcff 	bl	1010710 <bt_keys_foreach_type>
}
 1008d12:	9801      	ldr	r0, [sp, #4]
 1008d14:	b003      	add	sp, #12
 1008d16:	f85d fb04 	ldr.w	pc, [sp], #4
 1008d1a:	bf00      	nop
 1008d1c:	01008a99 	.word	0x01008a99

01008d20 <bt_id_add>:
	CHECKIF(keys == NULL) {
 1008d20:	4603      	mov	r3, r0
{
 1008d22:	b410      	push	{r4}
	CHECKIF(keys == NULL) {
 1008d24:	b170      	cbz	r0, 1008d44 <bt_id_add+0x24>
	if (!bt_dev.le.rl_size || bt_dev.le.rl_entries > bt_dev.le.rl_size) {
 1008d26:	490a      	ldr	r1, [pc, #40]	; (1008d50 <bt_id_add+0x30>)
 1008d28:	f891 4118 	ldrb.w	r4, [r1, #280]	; 0x118
 1008d2c:	f891 2119 	ldrb.w	r2, [r1, #281]	; 0x119
 1008d30:	b10c      	cbz	r4, 1008d36 <bt_id_add+0x16>
 1008d32:	4294      	cmp	r4, r2
 1008d34:	d208      	bcs.n	1008d48 <bt_id_add+0x28>
		bt_dev.le.rl_entries++;
 1008d36:	3201      	adds	r2, #1
 1008d38:	f881 2119 	strb.w	r2, [r1, #281]	; 0x119
		keys->state |= BT_KEYS_ID_ADDED;
 1008d3c:	7a1a      	ldrb	r2, [r3, #8]
 1008d3e:	f042 0204 	orr.w	r2, r2, #4
 1008d42:	721a      	strb	r2, [r3, #8]
}
 1008d44:	bc10      	pop	{r4}
 1008d46:	4770      	bx	lr
 1008d48:	bc10      	pop	{r4}
 1008d4a:	f7ff bf0f 	b.w	1008b6c <bt_id_add.part.0>
 1008d4e:	bf00      	nop
 1008d50:	21000000 	.word	0x21000000

01008d54 <bt_id_del>:
{
 1008d54:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1008d58:	b087      	sub	sp, #28
	CHECKIF(keys == NULL) {
 1008d5a:	4605      	mov	r5, r0
{
 1008d5c:	af00      	add	r7, sp, #0
	CHECKIF(keys == NULL) {
 1008d5e:	b398      	cbz	r0, 1008dc8 <bt_id_del+0x74>
	if (!bt_dev.le.rl_size ||
 1008d60:	4c4e      	ldr	r4, [pc, #312]	; (1008e9c <bt_id_del+0x148>)
 1008d62:	f894 2118 	ldrb.w	r2, [r4, #280]	; 0x118
	    bt_dev.le.rl_entries > bt_dev.le.rl_size + 1) {
 1008d66:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
	if (!bt_dev.le.rl_size ||
 1008d6a:	b1ca      	cbz	r2, 1008da0 <bt_id_del+0x4c>
	    bt_dev.le.rl_entries > bt_dev.le.rl_size + 1) {
 1008d6c:	3201      	adds	r2, #1
	if (!bt_dev.le.rl_size ||
 1008d6e:	4293      	cmp	r3, r2
 1008d70:	dc23      	bgt.n	1008dba <bt_id_del+0x66>
	conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, NULL, BT_CONN_CONNECTING);
 1008d72:	2100      	movs	r1, #0
 1008d74:	2206      	movs	r2, #6
 1008d76:	4608      	mov	r0, r1
 1008d78:	f001 fce0 	bl	100a73c <bt_conn_lookup_state_le>
	if (conn) {
 1008d7c:	4606      	mov	r6, r0
 1008d7e:	b338      	cbz	r0, 1008dd0 <bt_id_del+0x7c>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1008d80:	34cc      	adds	r4, #204	; 0xcc
 1008d82:	e8d4 3fef 	ldaex	r3, [r4]
 1008d86:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 1008d8a:	e8c4 3fe2 	stlex	r2, r3, [r4]
 1008d8e:	2a00      	cmp	r2, #0
 1008d90:	d1f7      	bne.n	1008d82 <bt_id_del+0x2e>
	keys->state |= flag;
 1008d92:	7a2b      	ldrb	r3, [r5, #8]
 1008d94:	f043 0302 	orr.w	r3, r3, #2
 1008d98:	722b      	strb	r3, [r5, #8]
		bt_conn_unref(conn);
 1008d9a:	f001 f97f 	bl	100a09c <bt_conn_unref>
		return;
 1008d9e:	e013      	b.n	1008dc8 <bt_id_del+0x74>
		__ASSERT_NO_MSG(bt_dev.le.rl_entries > 0);
 1008da0:	b95b      	cbnz	r3, 1008dba <bt_id_del+0x66>
 1008da2:	493f      	ldr	r1, [pc, #252]	; (1008ea0 <bt_id_del+0x14c>)
 1008da4:	483f      	ldr	r0, [pc, #252]	; (1008ea4 <bt_id_del+0x150>)
 1008da6:	f240 4323 	movw	r3, #1059	; 0x423
 1008daa:	4a3f      	ldr	r2, [pc, #252]	; (1008ea8 <bt_id_del+0x154>)
 1008dac:	f01b ff13 	bl	1024bd6 <assert_print>
 1008db0:	f240 4123 	movw	r1, #1059	; 0x423
 1008db4:	483c      	ldr	r0, [pc, #240]	; (1008ea8 <bt_id_del+0x154>)
 1008db6:	f01b ff07 	bl	1024bc8 <assert_post_action>
			bt_dev.le.rl_entries--;
 1008dba:	3b01      	subs	r3, #1
 1008dbc:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
		keys->state &= ~BT_KEYS_ID_ADDED;
 1008dc0:	7a2b      	ldrb	r3, [r5, #8]
 1008dc2:	f023 0304 	bic.w	r3, r3, #4
 1008dc6:	722b      	strb	r3, [r5, #8]
}
 1008dc8:	371c      	adds	r7, #28
 1008dca:	46bd      	mov	sp, r7
 1008dcc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		bt_le_ext_adv_foreach(adv_pause_enabled, NULL);
 1008dd0:	4601      	mov	r1, r0
 1008dd2:	4836      	ldr	r0, [pc, #216]	; (1008eac <bt_id_del+0x158>)
 1008dd4:	f000 faee 	bl	10093b4 <bt_le_ext_adv_foreach>
	err = addr_res_enable(BT_HCI_ADDR_RES_DISABLE);
 1008dd8:	4630      	mov	r0, r6
 1008dda:	f01e f84b 	bl	1026e74 <addr_res_enable>
	if (err) {
 1008dde:	4606      	mov	r6, r0
 1008de0:	b1d0      	cbz	r0, 1008e18 <bt_id_del+0xc4>
		LOG_ERR("Disabling address resolution failed (err %d)", err);
 1008de2:	466d      	mov	r5, sp
 1008de4:	b088      	sub	sp, #32
 1008de6:	466b      	mov	r3, sp
 1008de8:	4a31      	ldr	r2, [pc, #196]	; (1008eb0 <bt_id_del+0x15c>)
 1008dea:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1008dee:	e9c3 2005 	strd	r2, r0, [r3, #20]
 1008df2:	461a      	mov	r2, r3
 1008df4:	2303      	movs	r3, #3
 1008df6:	482f      	ldr	r0, [pc, #188]	; (1008eb4 <bt_id_del+0x160>)
 1008df8:	f842 3f10 	str.w	r3, [r2, #16]!
 1008dfc:	f01e f837 	bl	1026e6e <z_log_msg_static_create.constprop.0>
 1008e00:	46ad      	mov	sp, r5
	if (bt_dev.le.rl_entries) {
 1008e02:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
 1008e06:	b113      	cbz	r3, 1008e0e <bt_id_del+0xba>
		addr_res_enable(BT_HCI_ADDR_RES_ENABLE);
 1008e08:	2001      	movs	r0, #1
 1008e0a:	f01e f833 	bl	1026e74 <addr_res_enable>
		bt_le_ext_adv_foreach(adv_unpause_enabled, NULL);
 1008e0e:	2100      	movs	r1, #0
 1008e10:	4829      	ldr	r0, [pc, #164]	; (1008eb8 <bt_id_del+0x164>)
 1008e12:	f000 facf 	bl	10093b4 <bt_le_ext_adv_foreach>
 1008e16:	e7d7      	b.n	1008dc8 <bt_id_del+0x74>
	if (bt_dev.le.rl_entries > bt_dev.le.rl_size) {
 1008e18:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
 1008e1c:	f894 2118 	ldrb.w	r2, [r4, #280]	; 0x118
 1008e20:	429a      	cmp	r2, r3
 1008e22:	d20c      	bcs.n	1008e3e <bt_id_del+0xea>
		bt_dev.le.rl_entries--;
 1008e24:	3b01      	subs	r3, #1
 1008e26:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
		keys->state &= ~BT_KEYS_ID_ADDED;
 1008e2a:	7a2b      	ldrb	r3, [r5, #8]
			bt_keys_foreach_type(BT_KEYS_IRK, keys_add_id, NULL);
 1008e2c:	4602      	mov	r2, r0
		keys->state &= ~BT_KEYS_ID_ADDED;
 1008e2e:	f023 0304 	bic.w	r3, r3, #4
			bt_keys_foreach_type(BT_KEYS_IRK, keys_add_id, NULL);
 1008e32:	2002      	movs	r0, #2
 1008e34:	4921      	ldr	r1, [pc, #132]	; (1008ebc <bt_id_del+0x168>)
		keys->state &= ~BT_KEYS_ID_ADDED;
 1008e36:	722b      	strb	r3, [r5, #8]
			bt_keys_foreach_type(BT_KEYS_IRK, keys_add_id, NULL);
 1008e38:	f007 fc6a 	bl	1010710 <bt_keys_foreach_type>
		goto done;
 1008e3c:	e7e1      	b.n	1008e02 <bt_id_del+0xae>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_REM_DEV_FROM_RL, sizeof(*cp));
 1008e3e:	2107      	movs	r1, #7
 1008e40:	f242 0028 	movw	r0, #8232	; 0x2028
 1008e44:	f7fe ff22 	bl	1007c8c <bt_hci_cmd_create>
	err = hci_id_del(&keys->addr);
 1008e48:	f105 0901 	add.w	r9, r5, #1
	if (!buf) {
 1008e4c:	4680      	mov	r8, r0
 1008e4e:	b958      	cbnz	r0, 1008e68 <bt_id_del+0x114>
		LOG_ERR("Failed to remove IRK from controller");
 1008e50:	4b1b      	ldr	r3, [pc, #108]	; (1008ec0 <bt_id_del+0x16c>)
 1008e52:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1008e56:	617b      	str	r3, [r7, #20]
 1008e58:	2302      	movs	r3, #2
 1008e5a:	4816      	ldr	r0, [pc, #88]	; (1008eb4 <bt_id_del+0x160>)
 1008e5c:	613b      	str	r3, [r7, #16]
 1008e5e:	f107 0210 	add.w	r2, r7, #16
 1008e62:	f01e f804 	bl	1026e6e <z_log_msg_static_create.constprop.0>
		goto done;
 1008e66:	e7cc      	b.n	1008e02 <bt_id_del+0xae>
	return net_buf_simple_add(&buf->b, len);
 1008e68:	2107      	movs	r1, #7
 1008e6a:	300c      	adds	r0, #12
 1008e6c:	f015 fa14 	bl	101e298 <net_buf_simple_add>
	bt_addr_le_copy(&cp->peer_id_addr, addr);
 1008e70:	4649      	mov	r1, r9
 1008e72:	f01d ffbc 	bl	1026dee <bt_addr_le_copy>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_REM_DEV_FROM_RL, buf, NULL);
 1008e76:	4632      	mov	r2, r6
 1008e78:	4641      	mov	r1, r8
 1008e7a:	f242 0028 	movw	r0, #8232	; 0x2028
 1008e7e:	f7ff f85b 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 1008e82:	2800      	cmp	r0, #0
 1008e84:	d1e4      	bne.n	1008e50 <bt_id_del+0xfc>
	bt_dev.le.rl_entries--;
 1008e86:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
 1008e8a:	3b01      	subs	r3, #1
 1008e8c:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
	keys->state &= ~BT_KEYS_ID_ADDED;
 1008e90:	7a2b      	ldrb	r3, [r5, #8]
 1008e92:	f023 0304 	bic.w	r3, r3, #4
 1008e96:	722b      	strb	r3, [r5, #8]
 1008e98:	e7b3      	b.n	1008e02 <bt_id_del+0xae>
 1008e9a:	bf00      	nop
 1008e9c:	21000000 	.word	0x21000000
 1008ea0:	0102d627 	.word	0x0102d627
 1008ea4:	0102b695 	.word	0x0102b695
 1008ea8:	0102d496 	.word	0x0102d496
 1008eac:	01026ecb 	.word	0x01026ecb
 1008eb0:	0102d640 	.word	0x0102d640
 1008eb4:	010299b4 	.word	0x010299b4
 1008eb8:	01026ea5 	.word	0x01026ea5
 1008ebc:	01026e59 	.word	0x01026e59
 1008ec0:	0102d66d 	.word	0x0102d66d

01008ec4 <bt_id_get>:
{
 1008ec4:	b538      	push	{r3, r4, r5, lr}
 1008ec6:	460d      	mov	r5, r1
		size_t to_copy = MIN(*count, bt_dev.id_count);
 1008ec8:	4906      	ldr	r1, [pc, #24]	; (1008ee4 <bt_id_get+0x20>)
 1008eca:	79cc      	ldrb	r4, [r1, #7]
	if (addrs) {
 1008ecc:	b138      	cbz	r0, 1008ede <bt_id_get+0x1a>
		size_t to_copy = MIN(*count, bt_dev.id_count);
 1008ece:	682b      	ldr	r3, [r5, #0]
 1008ed0:	429c      	cmp	r4, r3
 1008ed2:	bf28      	it	cs
 1008ed4:	461c      	movcs	r4, r3
		memcpy(addrs, bt_dev.id_addr, to_copy * sizeof(bt_addr_le_t));
 1008ed6:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
 1008eda:	f01d fd4b 	bl	1026974 <memcpy>
		*count = to_copy;
 1008ede:	602c      	str	r4, [r5, #0]
}
 1008ee0:	bd38      	pop	{r3, r4, r5, pc}
 1008ee2:	bf00      	nop
 1008ee4:	21000000 	.word	0x21000000

01008ee8 <bt_id_create>:

int bt_id_create(bt_addr_le_t *addr, uint8_t *irk)
{
 1008ee8:	b570      	push	{r4, r5, r6, lr}
 1008eea:	460d      	mov	r5, r1
	int new_id, err;

	if (addr && !bt_addr_le_eq(addr, BT_ADDR_LE_ANY)) {
 1008eec:	4604      	mov	r4, r0
{
 1008eee:	b086      	sub	sp, #24
	if (addr && !bt_addr_le_eq(addr, BT_ADDR_LE_ANY)) {
 1008ef0:	b920      	cbnz	r0, 1008efc <bt_id_create+0x14>
		if (id_find(addr) >= 0) {
			return -EALREADY;
		}
	}

	if (!IS_ENABLED(CONFIG_BT_PRIVACY) && irk) {
 1008ef2:	b31d      	cbz	r5, 1008f3c <bt_id_create+0x54>
			return -EINVAL;
 1008ef4:	f06f 0015 	mvn.w	r0, #21
	} else {
		bt_dev.id_count++;
	}

	return new_id;
}
 1008ef8:	b006      	add	sp, #24
 1008efa:	bd70      	pop	{r4, r5, r6, pc}
	if (addr && !bt_addr_le_eq(addr, BT_ADDR_LE_ANY)) {
 1008efc:	4920      	ldr	r1, [pc, #128]	; (1008f80 <bt_id_create+0x98>)
 1008efe:	f01d ff6e 	bl	1026dde <bt_addr_le_eq>
 1008f02:	2800      	cmp	r0, #0
 1008f04:	d1f5      	bne.n	1008ef2 <bt_id_create+0xa>
		if (addr->type != BT_ADDR_LE_RANDOM ||
 1008f06:	7823      	ldrb	r3, [r4, #0]
 1008f08:	2b01      	cmp	r3, #1
 1008f0a:	d104      	bne.n	1008f16 <bt_id_create+0x2e>
 1008f0c:	79a3      	ldrb	r3, [r4, #6]
 1008f0e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 1008f12:	2bc0      	cmp	r3, #192	; 0xc0
 1008f14:	d00a      	beq.n	1008f2c <bt_id_create+0x44>
			LOG_ERR("Only static random identity address supported");
 1008f16:	4b1b      	ldr	r3, [pc, #108]	; (1008f84 <bt_id_create+0x9c>)
 1008f18:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1008f1c:	9305      	str	r3, [sp, #20]
 1008f1e:	2302      	movs	r3, #2
 1008f20:	4819      	ldr	r0, [pc, #100]	; (1008f88 <bt_id_create+0xa0>)
 1008f22:	aa04      	add	r2, sp, #16
 1008f24:	9304      	str	r3, [sp, #16]
 1008f26:	f01d ffa2 	bl	1026e6e <z_log_msg_static_create.constprop.0>
			return -EINVAL;
 1008f2a:	e7e3      	b.n	1008ef4 <bt_id_create+0xc>
		if (id_find(addr) >= 0) {
 1008f2c:	4620      	mov	r0, r4
 1008f2e:	f7ff fd37 	bl	10089a0 <id_find>
 1008f32:	2800      	cmp	r0, #0
 1008f34:	dbdd      	blt.n	1008ef2 <bt_id_create+0xa>
			return -EALREADY;
 1008f36:	f06f 0077 	mvn.w	r0, #119	; 0x77
 1008f3a:	e7dd      	b.n	1008ef8 <bt_id_create+0x10>
	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
 1008f3c:	4d13      	ldr	r5, [pc, #76]	; (1008f8c <bt_id_create+0xa4>)
 1008f3e:	79eb      	ldrb	r3, [r5, #7]
 1008f40:	2b01      	cmp	r3, #1
 1008f42:	d01a      	beq.n	1008f7a <bt_id_create+0x92>
 1008f44:	f105 00cc 	add.w	r0, r5, #204	; 0xcc
 1008f48:	f01d ff54 	bl	1026df4 <atomic_get>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
 1008f4c:	07c3      	lsls	r3, r0, #31
 1008f4e:	d50b      	bpl.n	1008f68 <bt_id_create+0x80>
	new_id = bt_dev.id_count;
 1008f50:	79ee      	ldrb	r6, [r5, #7]
	err = id_create(new_id, addr, irk);
 1008f52:	4621      	mov	r1, r4
 1008f54:	4630      	mov	r0, r6
 1008f56:	f7ff fd3b 	bl	10089d0 <id_create.constprop.0>
	if (err) {
 1008f5a:	2800      	cmp	r0, #0
 1008f5c:	d1cc      	bne.n	1008ef8 <bt_id_create+0x10>
		bt_dev.id_count++;
 1008f5e:	79eb      	ldrb	r3, [r5, #7]
	new_id = bt_dev.id_count;
 1008f60:	4630      	mov	r0, r6
		bt_dev.id_count++;
 1008f62:	3301      	adds	r3, #1
 1008f64:	71eb      	strb	r3, [r5, #7]
	return new_id;
 1008f66:	e7c7      	b.n	1008ef8 <bt_id_create+0x10>
		if (!(addr && !bt_addr_le_eq(addr, BT_ADDR_LE_ANY))) {
 1008f68:	2c00      	cmp	r4, #0
 1008f6a:	d0c3      	beq.n	1008ef4 <bt_id_create+0xc>
 1008f6c:	4620      	mov	r0, r4
 1008f6e:	4904      	ldr	r1, [pc, #16]	; (1008f80 <bt_id_create+0x98>)
 1008f70:	f01d ff35 	bl	1026dde <bt_addr_le_eq>
 1008f74:	2800      	cmp	r0, #0
 1008f76:	d0eb      	beq.n	1008f50 <bt_id_create+0x68>
 1008f78:	e7bc      	b.n	1008ef4 <bt_id_create+0xc>
		return -ENOMEM;
 1008f7a:	f06f 000b 	mvn.w	r0, #11
 1008f7e:	e7bb      	b.n	1008ef8 <bt_id_create+0x10>
 1008f80:	0102cb79 	.word	0x0102cb79
 1008f84:	0102d692 	.word	0x0102d692
 1008f88:	010299b4 	.word	0x010299b4
 1008f8c:	21000000 	.word	0x21000000

01008f90 <bt_id_read_public_addr>:
#endif /* defined(CONFIG_BT_HCI_VS_EXT) */
}
#endif /* defined(CONFIG_BT_PRIVACY) */

uint8_t bt_id_read_public_addr(bt_addr_le_t *addr)
{
 1008f90:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_rp_read_bd_addr *rp;
	struct net_buf *rsp;
	int err;

	CHECKIF(addr == NULL) {
 1008f92:	4604      	mov	r4, r0
{
 1008f94:	b088      	sub	sp, #32
	CHECKIF(addr == NULL) {
 1008f96:	b960      	cbnz	r0, 1008fb2 <bt_id_read_public_addr+0x22>
		LOG_WRN("Invalid input parameters");
 1008f98:	4b1a      	ldr	r3, [pc, #104]	; (1009004 <bt_id_read_public_addr+0x74>)
	}

	/* Read Bluetooth Address */
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
	if (err) {
		LOG_WRN("Failed to read public address");
 1008f9a:	9307      	str	r3, [sp, #28]
 1008f9c:	2302      	movs	r3, #2
 1008f9e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 1008fa2:	4819      	ldr	r0, [pc, #100]	; (1009008 <bt_id_read_public_addr+0x78>)
 1008fa4:	aa06      	add	r2, sp, #24
 1008fa6:	9306      	str	r3, [sp, #24]
 1008fa8:	f01d ff61 	bl	1026e6e <z_log_msg_static_create.constprop.0>
		return 0U;
 1008fac:	2000      	movs	r0, #0
	bt_addr_copy(&addr->a, &rp->bdaddr);
	addr->type = BT_ADDR_LE_PUBLIC;

	net_buf_unref(rsp);
	return 1U;
}
 1008fae:	b008      	add	sp, #32
 1008fb0:	bd70      	pop	{r4, r5, r6, pc}
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
 1008fb2:	2100      	movs	r1, #0
 1008fb4:	f241 0009 	movw	r0, #4105	; 0x1009
 1008fb8:	aa01      	add	r2, sp, #4
 1008fba:	f7fe ffbd 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 1008fbe:	4606      	mov	r6, r0
 1008fc0:	b108      	cbz	r0, 1008fc6 <bt_id_read_public_addr+0x36>
		LOG_WRN("Failed to read public address");
 1008fc2:	4b12      	ldr	r3, [pc, #72]	; (100900c <bt_id_read_public_addr+0x7c>)
 1008fc4:	e7e9      	b.n	1008f9a <bt_id_read_public_addr+0xa>
	rp = (void *)rsp->data;
 1008fc6:	9b01      	ldr	r3, [sp, #4]
	return memcmp(a, b, sizeof(*a));
 1008fc8:	2206      	movs	r2, #6
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
 1008fca:	68dd      	ldr	r5, [r3, #12]
 1008fcc:	4910      	ldr	r1, [pc, #64]	; (1009010 <bt_id_read_public_addr+0x80>)
 1008fce:	3501      	adds	r5, #1
 1008fd0:	4628      	mov	r0, r5
 1008fd2:	f01d fcbf 	bl	1026954 <memcmp>
 1008fd6:	b918      	cbnz	r0, 1008fe0 <bt_id_read_public_addr+0x50>
		net_buf_unref(rsp);
 1008fd8:	9801      	ldr	r0, [sp, #4]
 1008fda:	f015 f801 	bl	101dfe0 <net_buf_unref>
		return 0U;
 1008fde:	e7e5      	b.n	1008fac <bt_id_read_public_addr+0x1c>
 1008fe0:	2206      	movs	r2, #6
 1008fe2:	4628      	mov	r0, r5
 1008fe4:	490b      	ldr	r1, [pc, #44]	; (1009014 <bt_id_read_public_addr+0x84>)
 1008fe6:	f01d fcb5 	bl	1026954 <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
 1008fea:	2800      	cmp	r0, #0
 1008fec:	d0f4      	beq.n	1008fd8 <bt_id_read_public_addr+0x48>
	memcpy(dst, src, sizeof(*dst));
 1008fee:	2206      	movs	r2, #6
 1008ff0:	4629      	mov	r1, r5
 1008ff2:	1c60      	adds	r0, r4, #1
 1008ff4:	f01d fcbe 	bl	1026974 <memcpy>
	net_buf_unref(rsp);
 1008ff8:	9801      	ldr	r0, [sp, #4]
	addr->type = BT_ADDR_LE_PUBLIC;
 1008ffa:	7026      	strb	r6, [r4, #0]
	net_buf_unref(rsp);
 1008ffc:	f014 fff0 	bl	101dfe0 <net_buf_unref>
	return 1U;
 1009000:	2001      	movs	r0, #1
 1009002:	e7d4      	b.n	1008fae <bt_id_read_public_addr+0x1e>
 1009004:	0102d6c0 	.word	0x0102d6c0
 1009008:	010299b4 	.word	0x010299b4
 100900c:	0102d6d9 	.word	0x0102d6d9
 1009010:	0102cb86 	.word	0x0102cb86
 1009014:	0102cb80 	.word	0x0102cb80

01009018 <bt_setup_public_id_addr>:

int bt_setup_public_id_addr(void)
{
 1009018:	b507      	push	{r0, r1, r2, lr}
	bt_addr_le_t addr;
	uint8_t *irk = NULL;

	bt_dev.id_count = bt_id_read_public_addr(&addr);
 100901a:	4668      	mov	r0, sp
 100901c:	f7ff ffb8 	bl	1008f90 <bt_id_read_public_addr>
 1009020:	4b04      	ldr	r3, [pc, #16]	; (1009034 <bt_setup_public_id_addr+0x1c>)
 1009022:	71d8      	strb	r0, [r3, #7]

	if (!bt_dev.id_count) {
 1009024:	b118      	cbz	r0, 100902e <bt_setup_public_id_addr+0x16>
		if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
			atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
		}
	}

	return id_create(BT_ID_DEFAULT, &addr, irk);
 1009026:	4669      	mov	r1, sp
 1009028:	2000      	movs	r0, #0
 100902a:	f7ff fcd1 	bl	10089d0 <id_create.constprop.0>
}
 100902e:	b003      	add	sp, #12
 1009030:	f85d fb04 	ldr.w	pc, [sp], #4
 1009034:	21000000 	.word	0x21000000

01009038 <bt_read_static_addr>:

#if defined(CONFIG_BT_HCI_VS_EXT)
uint8_t bt_read_static_addr(struct bt_hci_vs_static_addr addrs[], uint8_t size)
{
 1009038:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_hci_rp_vs_read_static_addrs *rp;
	struct net_buf *rsp;
	int err, i;
	uint8_t cnt;

	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
 100903c:	4b22      	ldr	r3, [pc, #136]	; (10090c8 <bt_read_static_addr+0x90>)
{
 100903e:	4607      	mov	r7, r0
	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
 1009040:	f893 30ba 	ldrb.w	r3, [r3, #186]	; 0xba
{
 1009044:	4688      	mov	r8, r1
	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
 1009046:	07db      	lsls	r3, r3, #31
{
 1009048:	b088      	sub	sp, #32
	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
 100904a:	d40e      	bmi.n	100906a <bt_read_static_addr+0x32>
		LOG_WRN("Read Static Addresses command not available");
 100904c:	4b1f      	ldr	r3, [pc, #124]	; (10090cc <bt_read_static_addr+0x94>)
		return 0;
	}

	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
	if (err) {
		LOG_WRN("Failed to read static addresses");
 100904e:	9307      	str	r3, [sp, #28]
		return 0;
 1009050:	2500      	movs	r5, #0
		LOG_WRN("Failed to read static addresses");
 1009052:	2302      	movs	r3, #2
 1009054:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 1009058:	481d      	ldr	r0, [pc, #116]	; (10090d0 <bt_read_static_addr+0x98>)
 100905a:	aa06      	add	r2, sp, #24
 100905c:	9306      	str	r3, [sp, #24]
 100905e:	f01d ff06 	bl	1026e6e <z_log_msg_static_create.constprop.0>
	if (!cnt) {
		LOG_WRN("No static addresses stored in controller");
	}

	return cnt;
}
 1009062:	4628      	mov	r0, r5
 1009064:	b008      	add	sp, #32
 1009066:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
 100906a:	2100      	movs	r1, #0
 100906c:	f64f 4009 	movw	r0, #64521	; 0xfc09
 1009070:	aa01      	add	r2, sp, #4
 1009072:	f7fe ff61 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 1009076:	4604      	mov	r4, r0
 1009078:	b108      	cbz	r0, 100907e <bt_read_static_addr+0x46>
		LOG_WRN("Failed to read static addresses");
 100907a:	4b16      	ldr	r3, [pc, #88]	; (10090d4 <bt_read_static_addr+0x9c>)
 100907c:	e7e7      	b.n	100904e <bt_read_static_addr+0x16>
	rp = (void *)rsp->data;
 100907e:	9b01      	ldr	r3, [sp, #4]
 1009080:	68de      	ldr	r6, [r3, #12]
	cnt = MIN(rp->num_addrs, size);
 1009082:	7875      	ldrb	r5, [r6, #1]
 1009084:	3602      	adds	r6, #2
 1009086:	4545      	cmp	r5, r8
 1009088:	bf28      	it	cs
 100908a:	4645      	movcs	r5, r8
		memcpy(&addrs[i], &rp->a[i], sizeof(struct bt_hci_vs_static_addr));
 100908c:	f04f 0816 	mov.w	r8, #22
	for (i = 0; i < cnt; i++) {
 1009090:	42a5      	cmp	r5, r4
 1009092:	dc0f      	bgt.n	10090b4 <bt_read_static_addr+0x7c>
	net_buf_unref(rsp);
 1009094:	9801      	ldr	r0, [sp, #4]
 1009096:	f014 ffa3 	bl	101dfe0 <net_buf_unref>
	if (!cnt) {
 100909a:	2d00      	cmp	r5, #0
 100909c:	d1e1      	bne.n	1009062 <bt_read_static_addr+0x2a>
		LOG_WRN("No static addresses stored in controller");
 100909e:	4b0e      	ldr	r3, [pc, #56]	; (10090d8 <bt_read_static_addr+0xa0>)
 10090a0:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 10090a4:	9307      	str	r3, [sp, #28]
 10090a6:	2302      	movs	r3, #2
 10090a8:	4809      	ldr	r0, [pc, #36]	; (10090d0 <bt_read_static_addr+0x98>)
 10090aa:	aa06      	add	r2, sp, #24
 10090ac:	9306      	str	r3, [sp, #24]
 10090ae:	f01d fede 	bl	1026e6e <z_log_msg_static_create.constprop.0>
 10090b2:	e7d6      	b.n	1009062 <bt_read_static_addr+0x2a>
		memcpy(&addrs[i], &rp->a[i], sizeof(struct bt_hci_vs_static_addr));
 10090b4:	4631      	mov	r1, r6
 10090b6:	fb08 7004 	mla	r0, r8, r4, r7
 10090ba:	2216      	movs	r2, #22
 10090bc:	f01d fc5a 	bl	1026974 <memcpy>
	for (i = 0; i < cnt; i++) {
 10090c0:	3401      	adds	r4, #1
 10090c2:	3616      	adds	r6, #22
 10090c4:	e7e4      	b.n	1009090 <bt_read_static_addr+0x58>
 10090c6:	bf00      	nop
 10090c8:	21000000 	.word	0x21000000
 10090cc:	0102d6f7 	.word	0x0102d6f7
 10090d0:	010299b4 	.word	0x010299b4
 10090d4:	0102d723 	.word	0x0102d723
 10090d8:	0102d743 	.word	0x0102d743

010090dc <bt_setup_random_id_addr>:
#endif /* CONFIG_BT_HCI_VS_EXT */

int bt_setup_random_id_addr(void)
{
 10090dc:	b5f0      	push	{r4, r5, r6, r7, lr}
#if defined(CONFIG_BT_HCI_VS_EXT) || defined(CONFIG_BT_CTLR)
	/* Only read the addresses if the user has not already configured one or
	 * more identities (!bt_dev.id_count).
	 */
	if (!bt_dev.id_count) {
 10090de:	4e15      	ldr	r6, [pc, #84]	; (1009134 <bt_setup_random_id_addr+0x58>)
{
 10090e0:	b089      	sub	sp, #36	; 0x24
	if (!bt_dev.id_count) {
 10090e2:	79f4      	ldrb	r4, [r6, #7]
 10090e4:	b92c      	cbnz	r4, 10090f2 <bt_setup_random_id_addr+0x16>
		struct bt_hci_vs_static_addr addrs[CONFIG_BT_ID_MAX];

		bt_dev.id_count = bt_read_static_addr(addrs, CONFIG_BT_ID_MAX);
 10090e6:	2101      	movs	r1, #1
 10090e8:	a802      	add	r0, sp, #8
 10090ea:	f7ff ffa5 	bl	1009038 <bt_read_static_addr>
 10090ee:	71f0      	strb	r0, [r6, #7]

		if (bt_dev.id_count) {
 10090f0:	b9c8      	cbnz	r0, 1009126 <bt_setup_random_id_addr+0x4a>

	if (IS_ENABLED(CONFIG_BT_PRIVACY) && IS_ENABLED(CONFIG_BT_SETTINGS)) {
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}

	return bt_id_create(NULL, NULL);
 10090f2:	2100      	movs	r1, #0
 10090f4:	4608      	mov	r0, r1
}
 10090f6:	b009      	add	sp, #36	; 0x24
 10090f8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	return bt_id_create(NULL, NULL);
 10090fc:	f7ff bef4 	b.w	1008ee8 <bt_id_create>
 1009100:	ab02      	add	r3, sp, #8
 1009102:	fb07 3105 	mla	r1, r7, r5, r3
 1009106:	2206      	movs	r2, #6
 1009108:	f10d 0001 	add.w	r0, sp, #1
 100910c:	f01d fc32 	bl	1026974 <memcpy>
				addr.type = BT_ADDR_LE_RANDOM;
 1009110:	2301      	movs	r3, #1
				err = id_create(i, &addr, irk);
 1009112:	4669      	mov	r1, sp
 1009114:	4628      	mov	r0, r5
				addr.type = BT_ADDR_LE_RANDOM;
 1009116:	f88d 3000 	strb.w	r3, [sp]
				err = id_create(i, &addr, irk);
 100911a:	f7ff fc59 	bl	10089d0 <id_create.constprop.0>
				if (err) {
 100911e:	3401      	adds	r4, #1
 1009120:	b110      	cbz	r0, 1009128 <bt_setup_random_id_addr+0x4c>
}
 1009122:	b009      	add	sp, #36	; 0x24
 1009124:	bdf0      	pop	{r4, r5, r6, r7, pc}
				bt_addr_copy(&addr.a, &addrs[i].bdaddr);
 1009126:	2716      	movs	r7, #22
			for (uint8_t i = 0; i < bt_dev.id_count; i++) {
 1009128:	79f3      	ldrb	r3, [r6, #7]
 100912a:	b2e5      	uxtb	r5, r4
 100912c:	42ab      	cmp	r3, r5
 100912e:	d8e7      	bhi.n	1009100 <bt_setup_random_id_addr+0x24>
			return 0;
 1009130:	2000      	movs	r0, #0
 1009132:	e7f6      	b.n	1009122 <bt_setup_random_id_addr+0x46>
 1009134:	21000000 	.word	0x21000000

01009138 <bt_id_set_adv_own_addr>:
}
#endif /* defined(CONFIG_BT_OBSERVER) */

int bt_id_set_adv_own_addr(struct bt_le_ext_adv *adv, uint32_t options,
			   bool dir_adv, uint8_t *own_addr_type)
{
 1009138:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100913c:	4690      	mov	r8, r2
 100913e:	460e      	mov	r6, r1
 1009140:	461d      	mov	r5, r3
	const bt_addr_le_t *id_addr;
	int err = 0;

	CHECKIF(adv == NULL || own_addr_type == NULL) {
 1009142:	4602      	mov	r2, r0
 1009144:	2800      	cmp	r0, #0
 1009146:	d047      	beq.n	10091d8 <bt_id_set_adv_own_addr+0xa0>
 1009148:	2b00      	cmp	r3, #0
 100914a:	d045      	beq.n	10091d8 <bt_id_set_adv_own_addr+0xa0>
	}

	/* Set which local identity address we're advertising with */
	id_addr = &bt_dev.id_addr[adv->id];

	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
 100914c:	07cf      	lsls	r7, r1, #31
	id_addr = &bt_dev.id_addr[adv->id];
 100914e:	7804      	ldrb	r4, [r0, #0]
	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
 1009150:	d52f      	bpl.n	10091b2 <bt_id_set_adv_own_addr+0x7a>
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
 1009152:	4f23      	ldr	r7, [pc, #140]	; (10091e0 <bt_id_set_adv_own_addr+0xa8>)
 1009154:	f1b8 0f00 	cmp.w	r8, #0
 1009158:	d013      	beq.n	1009182 <bt_id_set_adv_own_addr+0x4a>
 100915a:	0688      	lsls	r0, r1, #26
 100915c:	d40a      	bmi.n	1009174 <bt_id_set_adv_own_addr+0x3c>
			 * If Static Random address is used as Identity
			 * address we need to restore it before advertising
			 * is enabled. Otherwise NRPA used for active scan
			 * could be used for advertising.
			 */
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
 100915e:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 1009162:	5cfb      	ldrb	r3, [r7, r3]
 1009164:	2b01      	cmp	r3, #1
 1009166:	d015      	beq.n	1009194 <bt_id_set_adv_own_addr+0x5c>
				if (err) {
					return err;
				}
			}

			*own_addr_type = id_addr->type;
 1009168:	702b      	strb	r3, [r5, #0]

			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
 100916a:	06b2      	lsls	r2, r6, #26
 100916c:	d50f      	bpl.n	100918e <bt_id_set_adv_own_addr+0x56>
				*own_addr_type |= BT_HCI_OWN_ADDR_RPA_MASK;
 100916e:	f043 0302 	orr.w	r3, r3, #2
 1009172:	e00b      	b.n	100918c <bt_id_set_adv_own_addr+0x54>
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
 1009174:	f897 30d0 	ldrb.w	r3, [r7, #208]	; 0xd0
 1009178:	0659      	lsls	r1, r3, #25
 100917a:	d4f0      	bmi.n	100915e <bt_id_set_adv_own_addr+0x26>
			return -ENOTSUP;
 100917c:	f06f 0085 	mvn.w	r0, #133	; 0x85
 1009180:	e006      	b.n	1009190 <bt_id_set_adv_own_addr+0x58>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
 1009182:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 1009186:	5cfb      	ldrb	r3, [r7, r3]
 1009188:	2b01      	cmp	r3, #1
 100918a:	d003      	beq.n	1009194 <bt_id_set_adv_own_addr+0x5c>
			*own_addr_type = id_addr->type;
 100918c:	702b      	strb	r3, [r5, #0]
		if (err) {
			return err;
		}
	}

	return 0;
 100918e:	2000      	movs	r0, #0
}
 1009190:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
 1009194:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
 1009198:	1c61      	adds	r1, r4, #1
 100919a:	4610      	mov	r0, r2
 100919c:	4439      	add	r1, r7
 100919e:	f01d feb8 	bl	1026f12 <bt_id_set_adv_random_addr>
				if (err) {
 10091a2:	2800      	cmp	r0, #0
 10091a4:	d1f4      	bne.n	1009190 <bt_id_set_adv_own_addr+0x58>
			*own_addr_type = id_addr->type;
 10091a6:	5d3b      	ldrb	r3, [r7, r4]
 10091a8:	702b      	strb	r3, [r5, #0]
			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
 10091aa:	f1b8 0f00 	cmp.w	r8, #0
 10091ae:	d0ee      	beq.n	100918e <bt_id_set_adv_own_addr+0x56>
 10091b0:	e7db      	b.n	100916a <bt_id_set_adv_own_addr+0x32>
		if (options & BT_LE_ADV_OPT_USE_IDENTITY) {
 10091b2:	074b      	lsls	r3, r1, #29
 10091b4:	d50c      	bpl.n	10091d0 <bt_id_set_adv_own_addr+0x98>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
 10091b6:	4e0a      	ldr	r6, [pc, #40]	; (10091e0 <bt_id_set_adv_own_addr+0xa8>)
 10091b8:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
 10091bc:	5d33      	ldrb	r3, [r6, r4]
 10091be:	2b01      	cmp	r3, #1
 10091c0:	d1e4      	bne.n	100918c <bt_id_set_adv_own_addr+0x54>
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
 10091c2:	1c61      	adds	r1, r4, #1
 10091c4:	4431      	add	r1, r6
 10091c6:	f01d fea4 	bl	1026f12 <bt_id_set_adv_random_addr>
			*own_addr_type = id_addr->type;
 10091ca:	5d33      	ldrb	r3, [r6, r4]
 10091cc:	702b      	strb	r3, [r5, #0]
		if (err) {
 10091ce:	e7df      	b.n	1009190 <bt_id_set_adv_own_addr+0x58>
			err = bt_id_set_adv_private_addr(adv);
 10091d0:	f01d fea7 	bl	1026f22 <bt_id_set_adv_private_addr>
			*own_addr_type = BT_ADDR_LE_RANDOM;
 10091d4:	2301      	movs	r3, #1
 10091d6:	e7f9      	b.n	10091cc <bt_id_set_adv_own_addr+0x94>
		return -EINVAL;
 10091d8:	f06f 0015 	mvn.w	r0, #21
 10091dc:	e7d8      	b.n	1009190 <bt_id_set_adv_own_addr+0x58>
 10091de:	bf00      	nop
 10091e0:	21000000 	.word	0x21000000

010091e4 <hci_set_ad>:
	*data_len = set_data_len;
	return 0;
}

static int hci_set_ad(uint16_t hci_op, const struct bt_ad *ad, size_t ad_len)
{
 10091e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10091e8:	460c      	mov	r4, r1
 10091ea:	b089      	sub	sp, #36	; 0x24
	struct bt_hci_cp_le_set_adv_data *set_data;
	struct net_buf *buf;
	int err;

	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
 10091ec:	2120      	movs	r1, #32
{
 10091ee:	4692      	mov	sl, r2
 10091f0:	9000      	str	r0, [sp, #0]
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
 10091f2:	f7fe fd4b 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 10091f6:	4605      	mov	r5, r0
 10091f8:	2800      	cmp	r0, #0
 10091fa:	d05b      	beq.n	10092b4 <hci_set_ad+0xd0>
 10091fc:	2120      	movs	r1, #32
 10091fe:	300c      	adds	r0, #12
 1009200:	f015 f84a 	bl	101e298 <net_buf_simple_add>
		return -ENOBUFS;
	}

	set_data = net_buf_add(buf, sizeof(*set_data));
	(void)memset(set_data, 0, sizeof(*set_data));
 1009204:	2220      	movs	r2, #32
 1009206:	4681      	mov	r9, r0
 1009208:	2100      	movs	r1, #0
 100920a:	f01d fbbe 	bl	102698a <memset>
	uint8_t set_data_len = 0;
 100920e:	2600      	movs	r6, #0

	err = set_data_add_complete(set_data->data, BT_GAP_ADV_MAX_ADV_DATA_LEN,
 1009210:	f109 0b01 	add.w	fp, r9, #1
	for (size_t i = 0; i < ad_len; i++) {
 1009214:	eb04 0aca 	add.w	sl, r4, sl, lsl #3
		for (size_t j = 0; j < ad[i].len; j++) {
 1009218:	2300      	movs	r3, #0
 100921a:	f8d4 8000 	ldr.w	r8, [r4]
 100921e:	6862      	ldr	r2, [r4, #4]
 1009220:	4293      	cmp	r3, r2
 1009222:	d30c      	bcc.n	100923e <hci_set_ad+0x5a>
	for (size_t i = 0; i < ad_len; i++) {
 1009224:	3408      	adds	r4, #8
 1009226:	45a2      	cmp	sl, r4
 1009228:	d1f6      	bne.n	1009218 <hci_set_ad+0x34>
	if (err) {
		net_buf_unref(buf);
		return err;
	}

	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
 100922a:	2200      	movs	r2, #0
 100922c:	4629      	mov	r1, r5
 100922e:	9800      	ldr	r0, [sp, #0]
	*data_len = set_data_len;
 1009230:	f889 6000 	strb.w	r6, [r9]
}
 1009234:	b009      	add	sp, #36	; 0x24
 1009236:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
 100923a:	f7fe be7d 	b.w	1007f38 <bt_hci_cmd_send_sync>
			size_t len = data[j].data_len;
 100923e:	f898 2001 	ldrb.w	r2, [r8, #1]
			uint8_t type = data[j].type;
 1009242:	1cb0      	adds	r0, r6, #2
			if ((set_data_len + len + 2) > set_data_len_max) {
 1009244:	1811      	adds	r1, r2, r0
 1009246:	291f      	cmp	r1, #31
			uint8_t type = data[j].type;
 1009248:	f898 c000 	ldrb.w	ip, [r8]
			if ((set_data_len + len + 2) > set_data_len_max) {
 100924c:	d91b      	bls.n	1009286 <hci_set_ad+0xa2>
				if (!(type == BT_DATA_NAME_COMPLETE &&
 100924e:	f1bc 0f09 	cmp.w	ip, #9
				ssize_t shortened_len = set_data_len_max -
 1009252:	f1c0 021f 	rsb	r2, r0, #31
				if (!(type == BT_DATA_NAME_COMPLETE &&
 1009256:	d101      	bne.n	100925c <hci_set_ad+0x78>
 1009258:	2a00      	cmp	r2, #0
 100925a:	dc12      	bgt.n	1009282 <hci_set_ad+0x9e>
					LOG_ERR("Too big advertising data");
 100925c:	4b17      	ldr	r3, [pc, #92]	; (10092bc <hci_set_ad+0xd8>)
 100925e:	9307      	str	r3, [sp, #28]
 1009260:	2302      	movs	r3, #2
 1009262:	9306      	str	r3, [sp, #24]
 1009264:	2300      	movs	r3, #0
 1009266:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100926a:	4815      	ldr	r0, [pc, #84]	; (10092c0 <hci_set_ad+0xdc>)
 100926c:	aa06      	add	r2, sp, #24
 100926e:	f7fb fa4b 	bl	1004708 <z_impl_z_log_msg_static_create>
		net_buf_unref(buf);
 1009272:	4628      	mov	r0, r5
 1009274:	f014 feb4 	bl	101dfe0 <net_buf_unref>
					return -EINVAL;
 1009278:	f06f 0015 	mvn.w	r0, #21
}
 100927c:	b009      	add	sp, #36	; 0x24
 100927e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				type = BT_DATA_NAME_SHORTENED;
 1009282:	f04f 0c08 	mov.w	ip, #8
			set_data[set_data_len++] = len + 1;
 1009286:	b2d7      	uxtb	r7, r2
 1009288:	1c79      	adds	r1, r7, #1
 100928a:	f80b 1006 	strb.w	r1, [fp, r6]
 100928e:	1c71      	adds	r1, r6, #1
			set_data[set_data_len++] = type;
 1009290:	b2c9      	uxtb	r1, r1
 1009292:	f80b c001 	strb.w	ip, [fp, r1]
			memcpy(&set_data[set_data_len], data[j].data, len);
 1009296:	b2c0      	uxtb	r0, r0
 1009298:	f8d8 1004 	ldr.w	r1, [r8, #4]
 100929c:	4458      	add	r0, fp
 100929e:	9301      	str	r3, [sp, #4]
			set_data_len += len;
 10092a0:	3702      	adds	r7, #2
			memcpy(&set_data[set_data_len], data[j].data, len);
 10092a2:	f01d fb67 	bl	1026974 <memcpy>
		for (size_t j = 0; j < ad[i].len; j++) {
 10092a6:	9b01      	ldr	r3, [sp, #4]
			set_data_len += len;
 10092a8:	4437      	add	r7, r6
 10092aa:	b2fe      	uxtb	r6, r7
		for (size_t j = 0; j < ad[i].len; j++) {
 10092ac:	3301      	adds	r3, #1
 10092ae:	f108 0808 	add.w	r8, r8, #8
 10092b2:	e7b4      	b.n	100921e <hci_set_ad+0x3a>
		return -ENOBUFS;
 10092b4:	f06f 0068 	mvn.w	r0, #104	; 0x68
 10092b8:	e7e0      	b.n	100927c <hci_set_ad+0x98>
 10092ba:	bf00      	nop
 10092bc:	0102d772 	.word	0x0102d772
 10092c0:	01029954 	.word	0x01029954

010092c4 <le_adv_start_add_conn>:
	return channel_map;
}

static int le_adv_start_add_conn(const struct bt_le_ext_adv *adv,
				 struct bt_conn **out_conn)
{
 10092c4:	b570      	push	{r4, r5, r6, lr}
	struct bt_conn *conn;

	bt_dev.adv_conn_id = adv->id;
 10092c6:	4605      	mov	r5, r0
 10092c8:	4b16      	ldr	r3, [pc, #88]	; (1009324 <le_adv_start_add_conn+0x60>)
 10092ca:	f815 2b09 	ldrb.w	r2, [r5], #9
{
 10092ce:	4604      	mov	r4, r0
	bt_dev.adv_conn_id = adv->id;
 10092d0:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
{
 10092d4:	460e      	mov	r6, r1
	return memcmp(a, b, sizeof(*a));
 10092d6:	2207      	movs	r2, #7
 10092d8:	4628      	mov	r0, r5
 10092da:	4913      	ldr	r1, [pc, #76]	; (1009328 <le_adv_start_add_conn+0x64>)
 10092dc:	f01d fb3a 	bl	1026954 <memcmp>
 10092e0:	4603      	mov	r3, r0
 10092e2:	7820      	ldrb	r0, [r4, #0]

	if (bt_addr_le_eq(&adv->target_addr, BT_ADDR_LE_ANY)) {
 10092e4:	b96b      	cbnz	r3, 1009302 <le_adv_start_add_conn+0x3e>
		/* Undirected advertising */
		conn = bt_conn_add_le(adv->id, BT_ADDR_LE_NONE);
 10092e6:	4911      	ldr	r1, [pc, #68]	; (100932c <le_adv_start_add_conn+0x68>)
 10092e8:	f001 f9b8 	bl	100a65c <bt_conn_add_le>
		if (!conn) {
 10092ec:	4604      	mov	r4, r0
 10092ee:	b910      	cbnz	r0, 10092f6 <le_adv_start_add_conn+0x32>
			return -ENOMEM;
 10092f0:	f06f 000b 	mvn.w	r0, #11
	}

	bt_conn_set_state(conn, BT_CONN_CONNECTING_DIR_ADV);
	*out_conn = conn;
	return 0;
}
 10092f4:	bd70      	pop	{r4, r5, r6, pc}
		bt_conn_set_state(conn, BT_CONN_CONNECTING_ADV);
 10092f6:	2104      	movs	r1, #4
 10092f8:	f000 ff08 	bl	100a10c <bt_conn_set_state>
		return 0;
 10092fc:	2000      	movs	r0, #0
		*out_conn = conn;
 10092fe:	6034      	str	r4, [r6, #0]
 1009300:	e7f8      	b.n	10092f4 <le_adv_start_add_conn+0x30>
	if (bt_conn_exists_le(adv->id, &adv->target_addr)) {
 1009302:	4629      	mov	r1, r5
 1009304:	f001 f9ea 	bl	100a6dc <bt_conn_exists_le>
 1009308:	b940      	cbnz	r0, 100931c <le_adv_start_add_conn+0x58>
	conn = bt_conn_add_le(adv->id, &adv->target_addr);
 100930a:	7820      	ldrb	r0, [r4, #0]
 100930c:	4629      	mov	r1, r5
 100930e:	f001 f9a5 	bl	100a65c <bt_conn_add_le>
	if (!conn) {
 1009312:	4604      	mov	r4, r0
 1009314:	2800      	cmp	r0, #0
 1009316:	d0eb      	beq.n	10092f0 <le_adv_start_add_conn+0x2c>
	bt_conn_set_state(conn, BT_CONN_CONNECTING_DIR_ADV);
 1009318:	2105      	movs	r1, #5
 100931a:	e7ed      	b.n	10092f8 <le_adv_start_add_conn+0x34>
		return -EINVAL;
 100931c:	f06f 0015 	mvn.w	r0, #21
 1009320:	e7e8      	b.n	10092f4 <le_adv_start_add_conn+0x30>
 1009322:	bf00      	nop
 1009324:	21000000 	.word	0x21000000
 1009328:	0102cb79 	.word	0x0102cb79
 100932c:	0102cb72 	.word	0x0102cb72

01009330 <valid_adv_param>:
{
 1009330:	b538      	push	{r3, r4, r5, lr}
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
 1009332:	6843      	ldr	r3, [r0, #4]
{
 1009334:	4604      	mov	r4, r0
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
 1009336:	0558      	lsls	r0, r3, #21
 1009338:	d501      	bpl.n	100933e <valid_adv_param+0xe>
		return false;
 100933a:	2000      	movs	r0, #0
}
 100933c:	bd38      	pop	{r3, r4, r5, pc}
	if (param->peer && !(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
 100933e:	6922      	ldr	r2, [r4, #16]
 1009340:	b10a      	cbz	r2, 1009346 <valid_adv_param+0x16>
 1009342:	07d9      	lsls	r1, r3, #31
 1009344:	d5f9      	bpl.n	100933a <valid_adv_param+0xa>
	if (param->id >= bt_dev.id_count ||
 1009346:	4d19      	ldr	r5, [pc, #100]	; (10093ac <valid_adv_param+0x7c>)
 1009348:	7820      	ldrb	r0, [r4, #0]
 100934a:	79eb      	ldrb	r3, [r5, #7]
 100934c:	4283      	cmp	r3, r0
 100934e:	d9f4      	bls.n	100933a <valid_adv_param+0xa>
	    bt_addr_le_eq(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
 1009350:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 1009354:	2207      	movs	r2, #7
 1009356:	4916      	ldr	r1, [pc, #88]	; (10093b0 <valid_adv_param+0x80>)
 1009358:	4428      	add	r0, r5
 100935a:	f01d fafb 	bl	1026954 <memcmp>
	if (param->id >= bt_dev.id_count ||
 100935e:	2800      	cmp	r0, #0
 1009360:	d0eb      	beq.n	100933a <valid_adv_param+0xa>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
 1009362:	6860      	ldr	r0, [r4, #4]
 1009364:	07c2      	lsls	r2, r0, #31
 1009366:	d406      	bmi.n	1009376 <valid_adv_param+0x46>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
 1009368:	f895 3068 	ldrb.w	r3, [r5, #104]	; 0x68
 100936c:	2b08      	cmp	r3, #8
 100936e:	d802      	bhi.n	1009376 <valid_adv_param+0x46>
 1009370:	68a3      	ldr	r3, [r4, #8]
 1009372:	2b9f      	cmp	r3, #159	; 0x9f
 1009374:	d9e1      	bls.n	100933a <valid_adv_param+0xa>
	if ((param->options & (BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY |
 1009376:	f010 0f30 	tst.w	r0, #48	; 0x30
 100937a:	d002      	beq.n	1009382 <valid_adv_param+0x52>
			       BT_LE_ADV_OPT_DIR_ADDR_RPA)) &&
 100937c:	6923      	ldr	r3, [r4, #16]
 100937e:	2b00      	cmp	r3, #0
 1009380:	d0db      	beq.n	100933a <valid_adv_param+0xa>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) ||
 1009382:	06c3      	lsls	r3, r0, #27
 1009384:	d401      	bmi.n	100938a <valid_adv_param+0x5a>
 1009386:	6923      	ldr	r3, [r4, #16]
 1009388:	b943      	cbnz	r3, 100939c <valid_adv_param+0x6c>
		if (param->interval_min > param->interval_max ||
 100938a:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 100938e:	429a      	cmp	r2, r3
 1009390:	d8d3      	bhi.n	100933a <valid_adv_param+0xa>
 1009392:	2a1f      	cmp	r2, #31
 1009394:	d9d1      	bls.n	100933a <valid_adv_param+0xa>
		    param->interval_min < 0x0020 ||
 1009396:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 100939a:	d8ce      	bhi.n	100933a <valid_adv_param+0xa>
	    (param->options & BT_LE_ADV_OPT_DISABLE_CHAN_38) &&
 100939c:	f400 3060 	and.w	r0, r0, #229376	; 0x38000
	if ((param->options & BT_LE_ADV_OPT_DISABLE_CHAN_37) &&
 10093a0:	f5b0 3060 	subs.w	r0, r0, #229376	; 0x38000
 10093a4:	bf18      	it	ne
 10093a6:	2001      	movne	r0, #1
 10093a8:	e7c8      	b.n	100933c <valid_adv_param+0xc>
 10093aa:	bf00      	nop
 10093ac:	21000000 	.word	0x21000000
 10093b0:	0102cb79 	.word	0x0102cb79

010093b4 <bt_le_ext_adv_foreach>:
{
 10093b4:	4603      	mov	r3, r0
	func(&bt_dev.adv, data);
 10093b6:	4801      	ldr	r0, [pc, #4]	; (10093bc <bt_le_ext_adv_foreach+0x8>)
 10093b8:	4718      	bx	r3
 10093ba:	bf00      	nop
 10093bc:	21000018 	.word	0x21000018

010093c0 <bt_le_adv_lookup_legacy>:
}
 10093c0:	4800      	ldr	r0, [pc, #0]	; (10093c4 <bt_le_adv_lookup_legacy+0x4>)
 10093c2:	4770      	bx	lr
 10093c4:	21000018 	.word	0x21000018

010093c8 <bt_le_adv_start_legacy>:

int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv,
			   const struct bt_le_adv_param *param,
			   const struct bt_data *ad, size_t ad_len,
			   const struct bt_data *sd, size_t sd_len)
{
 10093c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10093cc:	b093      	sub	sp, #76	; 0x4c
 10093ce:	9305      	str	r3, [sp, #20]
	struct bt_hci_cp_le_set_adv_param set_param;
	struct bt_conn *conn = NULL;
 10093d0:	2300      	movs	r3, #0
	struct net_buf *buf;
	bool dir_adv = (param->peer != NULL), scannable = false;
 10093d2:	f8d1 a010 	ldr.w	sl, [r1, #16]
{
 10093d6:	4606      	mov	r6, r0
	bool dir_adv = (param->peer != NULL), scannable = false;
 10093d8:	ebba 0403 	subs.w	r4, sl, r3
 10093dc:	4892      	ldr	r0, [pc, #584]	; (1009628 <bt_le_adv_start_legacy+0x260>)
 10093de:	bf18      	it	ne
 10093e0:	2401      	movne	r4, #1
	struct bt_conn *conn = NULL;
 10093e2:	9307      	str	r3, [sp, #28]
 10093e4:	f01d fdd9 	bl	1026f9a <atomic_get>
	enum adv_name_type name_type;

	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
 10093e8:	0747      	lsls	r7, r0, #29
{
 10093ea:	460d      	mov	r5, r1
 10093ec:	4693      	mov	fp, r2
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
 10093ee:	f140 8112 	bpl.w	1009616 <bt_le_adv_start_legacy+0x24e>
		return -EAGAIN;
	}

	if (!valid_adv_param(param)) {
 10093f2:	4608      	mov	r0, r1
 10093f4:	f7ff ff9c 	bl	1009330 <valid_adv_param>
 10093f8:	b928      	cbnz	r0, 1009406 <bt_le_adv_start_legacy+0x3e>
		return -EINVAL;
 10093fa:	f06f 0415 	mvn.w	r4, #21

	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
			  param->options & BT_LE_ADV_OPT_USE_IDENTITY);

	return 0;
}
 10093fe:	4620      	mov	r0, r4
 1009400:	b013      	add	sp, #76	; 0x4c
 1009402:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!bt_id_adv_random_addr_check(param)) {
 1009406:	4628      	mov	r0, r5
 1009408:	f01d fda2 	bl	1026f50 <bt_id_adv_random_addr_check>
 100940c:	4681      	mov	r9, r0
 100940e:	2800      	cmp	r0, #0
 1009410:	d0f3      	beq.n	10093fa <bt_le_adv_start_legacy+0x32>
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
 1009412:	f106 0810 	add.w	r8, r6, #16
 1009416:	4640      	mov	r0, r8
 1009418:	f01d fdbf 	bl	1026f9a <atomic_get>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
 100941c:	f3c0 17c0 	ubfx	r7, r0, #7, #1
 1009420:	0600      	lsls	r0, r0, #24
 1009422:	f100 80fb 	bmi.w	100961c <bt_le_adv_start_legacy+0x254>
	(void)memset(&set_param, 0, sizeof(set_param));
 1009426:	220f      	movs	r2, #15
 1009428:	4639      	mov	r1, r7
 100942a:	a808      	add	r0, sp, #32
 100942c:	f01d faad 	bl	102698a <memset>
	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
 1009430:	68ab      	ldr	r3, [r5, #8]
	set_param.channel_map  = get_adv_channel_map(param->options);
 1009432:	6868      	ldr	r0, [r5, #4]
	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
 1009434:	f8ad 3020 	strh.w	r3, [sp, #32]
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
 1009438:	68eb      	ldr	r3, [r5, #12]
 100943a:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	set_param.channel_map  = get_adv_channel_map(param->options);
 100943e:	f01d fd9d 	bl	1026f7c <get_adv_channel_map>
	if (adv->id != param->id) {
 1009442:	7832      	ldrb	r2, [r6, #0]
 1009444:	782b      	ldrb	r3, [r5, #0]
	set_param.channel_map  = get_adv_channel_map(param->options);
 1009446:	f88d 002d 	strb.w	r0, [sp, #45]	; 0x2d
	if (adv->id != param->id) {
 100944a:	429a      	cmp	r2, r3
	set_param.filter_policy = get_filter_policy(param->options);
 100944c:	f88d 702e 	strb.w	r7, [sp, #46]	; 0x2e
	if (adv->id != param->id) {
 1009450:	d004      	beq.n	100945c <bt_le_adv_start_legacy+0x94>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 1009452:	f46f 5100 	mvn.w	r1, #8192	; 0x2000
 1009456:	4874      	ldr	r0, [pc, #464]	; (1009628 <bt_le_adv_start_legacy+0x260>)
 1009458:	f01d fda2 	bl	1026fa0 <atomic_and>
	adv->id = param->id;
 100945c:	782b      	ldrb	r3, [r5, #0]
	bt_dev.adv_conn_id = adv->id;
 100945e:	4a73      	ldr	r2, [pc, #460]	; (100962c <bt_le_adv_start_legacy+0x264>)
	adv->id = param->id;
 1009460:	7033      	strb	r3, [r6, #0]
	bt_dev.adv_conn_id = adv->id;
 1009462:	f882 3067 	strb.w	r3, [r2, #103]	; 0x67
	err = bt_id_set_adv_own_addr(adv, param->options, dir_adv,
 1009466:	4630      	mov	r0, r6
 1009468:	4622      	mov	r2, r4
 100946a:	6869      	ldr	r1, [r5, #4]
 100946c:	f10d 0325 	add.w	r3, sp, #37	; 0x25
 1009470:	f7ff fe62 	bl	1009138 <bt_id_set_adv_own_addr>
	if (err) {
 1009474:	4604      	mov	r4, r0
 1009476:	2800      	cmp	r0, #0
 1009478:	d1c1      	bne.n	10093fe <bt_le_adv_start_legacy+0x36>
	memcpy(dst, src, sizeof(*dst));
 100947a:	2207      	movs	r2, #7
		bt_addr_le_copy(&adv->target_addr, param->peer);
 100947c:	f106 0009 	add.w	r0, r6, #9
	if (dir_adv) {
 1009480:	f1ba 0f00 	cmp.w	sl, #0
 1009484:	d013      	beq.n	10094ae <bt_le_adv_start_legacy+0xe6>
 1009486:	6929      	ldr	r1, [r5, #16]
 1009488:	f01d fa74 	bl	1026974 <memcpy>
	name_type = get_adv_name_type_param(param);
 100948c:	4628      	mov	r0, r5
 100948e:	f01d fe17 	bl	10270c0 <get_adv_name_type_param>
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
 1009492:	686b      	ldr	r3, [r5, #4]
	name_type = get_adv_name_type_param(param);
 1009494:	4607      	mov	r7, r0
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
 1009496:	07d9      	lsls	r1, r3, #31
 1009498:	d416      	bmi.n	10094c8 <bt_le_adv_start_legacy+0x100>
	} else if ((param->options & BT_LE_ADV_OPT_SCANNABLE) || sd ||
 100949a:	059b      	lsls	r3, r3, #22
 100949c:	d403      	bmi.n	10094a6 <bt_le_adv_start_legacy+0xde>
 100949e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 10094a0:	b90b      	cbnz	r3, 10094a6 <bt_le_adv_start_legacy+0xde>
 10094a2:	2f02      	cmp	r7, #2
 10094a4:	d15a      	bne.n	100955c <bt_le_adv_start_legacy+0x194>
		set_param.type = BT_HCI_ADV_SCAN_IND;
 10094a6:	2302      	movs	r3, #2
 10094a8:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 10094ac:	e01a      	b.n	10094e4 <bt_le_adv_start_legacy+0x11c>
 10094ae:	4960      	ldr	r1, [pc, #384]	; (1009630 <bt_le_adv_start_legacy+0x268>)
 10094b0:	f01d fa60 	bl	1026974 <memcpy>
	name_type = get_adv_name_type_param(param);
 10094b4:	4628      	mov	r0, r5
 10094b6:	f01d fe03 	bl	10270c0 <get_adv_name_type_param>
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
 10094ba:	686b      	ldr	r3, [r5, #4]
	name_type = get_adv_name_type_param(param);
 10094bc:	4607      	mov	r7, r0
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
 10094be:	07da      	lsls	r2, r3, #31
 10094c0:	d5eb      	bpl.n	100949a <bt_le_adv_start_legacy+0xd2>
			set_param.type = BT_HCI_ADV_IND;
 10094c2:	f88d a024 	strb.w	sl, [sp, #36]	; 0x24
 10094c6:	e00d      	b.n	10094e4 <bt_le_adv_start_legacy+0x11c>
				set_param.type = BT_HCI_ADV_DIRECT_IND_LOW_DUTY;
 10094c8:	f013 0f10 	tst.w	r3, #16
 10094cc:	bf0c      	ite	eq
 10094ce:	2301      	moveq	r3, #1
 10094d0:	2304      	movne	r3, #4
 10094d2:	2207      	movs	r2, #7
 10094d4:	6929      	ldr	r1, [r5, #16]
 10094d6:	f10d 0026 	add.w	r0, sp, #38	; 0x26
 10094da:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
	bool dir_adv = (param->peer != NULL), scannable = false;
 10094de:	46a1      	mov	r9, r4
 10094e0:	f01d fa48 	bl	1026974 <memcpy>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_PARAM, sizeof(set_param));
 10094e4:	210f      	movs	r1, #15
 10094e6:	f242 0006 	movw	r0, #8198	; 0x2006
 10094ea:	f7fe fbcf 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 10094ee:	4604      	mov	r4, r0
 10094f0:	2800      	cmp	r0, #0
 10094f2:	f000 8096 	beq.w	1009622 <bt_le_adv_start_legacy+0x25a>
	return net_buf_simple_add_mem(&buf->b, mem, len);
 10094f6:	220f      	movs	r2, #15
 10094f8:	a908      	add	r1, sp, #32
 10094fa:	300c      	adds	r0, #12
 10094fc:	f01f fc48 	bl	1028d90 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
 1009500:	4621      	mov	r1, r4
 1009502:	2200      	movs	r2, #0
 1009504:	f242 0006 	movw	r0, #8198	; 0x2006
 1009508:	f7fe fd16 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 100950c:	4604      	mov	r4, r0
 100950e:	2800      	cmp	r0, #0
 1009510:	f47f af75 	bne.w	10093fe <bt_le_adv_start_legacy+0x36>
	if (!dir_adv) {
 1009514:	f1ba 0f00 	cmp.w	sl, #0
 1009518:	d026      	beq.n	1009568 <bt_le_adv_start_legacy+0x1a0>
	    (param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
 100951a:	686b      	ldr	r3, [r5, #4]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
 100951c:	07dc      	lsls	r4, r3, #31
 100951e:	d431      	bmi.n	1009584 <bt_le_adv_start_legacy+0x1bc>
	return bt_le_adv_set_enable_legacy(adv, enable);
 1009520:	2101      	movs	r1, #1
 1009522:	4630      	mov	r0, r6
 1009524:	f01d fddc 	bl	10270e0 <bt_le_adv_set_enable_legacy>
	if (err) {
 1009528:	4604      	mov	r4, r0
 100952a:	2800      	cmp	r0, #0
 100952c:	d06b      	beq.n	1009606 <bt_le_adv_start_legacy+0x23e>
		LOG_ERR("Failed to start advertiser");
 100952e:	4b41      	ldr	r3, [pc, #260]	; (1009634 <bt_le_adv_start_legacy+0x26c>)
 1009530:	9311      	str	r3, [sp, #68]	; 0x44
 1009532:	2302      	movs	r3, #2
 1009534:	9310      	str	r3, [sp, #64]	; 0x40
 1009536:	2300      	movs	r3, #0
 1009538:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100953c:	483e      	ldr	r0, [pc, #248]	; (1009638 <bt_le_adv_start_legacy+0x270>)
 100953e:	aa10      	add	r2, sp, #64	; 0x40
 1009540:	f7fb f8e2 	bl	1004708 <z_impl_z_log_msg_static_create>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
 1009544:	9d07      	ldr	r5, [sp, #28]
 1009546:	2d00      	cmp	r5, #0
 1009548:	f43f af59 	beq.w	10093fe <bt_le_adv_start_legacy+0x36>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
 100954c:	4628      	mov	r0, r5
 100954e:	2100      	movs	r1, #0
 1009550:	f000 fddc 	bl	100a10c <bt_conn_set_state>
			bt_conn_unref(conn);
 1009554:	4628      	mov	r0, r5
 1009556:	f000 fda1 	bl	100a09c <bt_conn_unref>
 100955a:	e750      	b.n	10093fe <bt_le_adv_start_legacy+0x36>
		set_param.type = BT_HCI_ADV_NONCONN_IND;
 100955c:	2303      	movs	r3, #3
	bool dir_adv = (param->peer != NULL), scannable = false;
 100955e:	f8dd 9070 	ldr.w	r9, [sp, #112]	; 0x70
		set_param.type = BT_HCI_ADV_NONCONN_IND;
 1009562:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 1009566:	e7bd      	b.n	10094e4 <bt_le_adv_start_legacy+0x11c>
		err = le_adv_update(adv, ad, ad_len, sd, sd_len, false,
 1009568:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 100956a:	4659      	mov	r1, fp
 100956c:	9300      	str	r3, [sp, #0]
 100956e:	4630      	mov	r0, r6
 1009570:	e9cd 9701 	strd	r9, r7, [sp, #4]
 1009574:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 1009576:	9a05      	ldr	r2, [sp, #20]
 1009578:	f01d fd30 	bl	1026fdc <le_adv_update.constprop.0>
		if (err) {
 100957c:	4604      	mov	r4, r0
 100957e:	2800      	cmp	r0, #0
 1009580:	d0cb      	beq.n	100951a <bt_le_adv_start_legacy+0x152>
 1009582:	e73c      	b.n	10093fe <bt_le_adv_start_legacy+0x36>
		err = le_adv_start_add_conn(adv, &conn);
 1009584:	4630      	mov	r0, r6
 1009586:	a907      	add	r1, sp, #28
 1009588:	f7ff fe9c 	bl	10092c4 <le_adv_start_add_conn>
		if (err) {
 100958c:	4604      	mov	r4, r0
 100958e:	2800      	cmp	r0, #0
 1009590:	d0c6      	beq.n	1009520 <bt_le_adv_start_legacy+0x158>
			if (err == -ENOMEM && !dir_adv &&
 1009592:	f110 0f0c 	cmn.w	r0, #12
 1009596:	f47f af32 	bne.w	10093fe <bt_le_adv_start_legacy+0x36>
 100959a:	f1ba 0f00 	cmp.w	sl, #0
 100959e:	f47f af2e 	bne.w	10093fe <bt_le_adv_start_legacy+0x36>
			    !(param->options & BT_LE_ADV_OPT_ONE_TIME)) {
 10095a2:	686b      	ldr	r3, [r5, #4]
			if (err == -ENOMEM && !dir_adv &&
 10095a4:	0798      	lsls	r0, r3, #30
 10095a6:	f53f af2a 	bmi.w	10093fe <bt_le_adv_start_legacy+0x36>
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
 10095aa:	686c      	ldr	r4, [r5, #4]
 10095ac:	f084 0402 	eor.w	r4, r4, #2
 10095b0:	f3c4 0440 	ubfx	r4, r4, #1, #1
 10095b4:	f004 0201 	and.w	r2, r4, #1
 10095b8:	210e      	movs	r1, #14
 10095ba:	4640      	mov	r0, r8
 10095bc:	f01d fcfb 	bl	1026fb6 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_AD,
 10095c0:	1e7b      	subs	r3, r7, #1
 10095c2:	425a      	negs	r2, r3
 10095c4:	415a      	adcs	r2, r3
 10095c6:	2108      	movs	r1, #8
 10095c8:	4640      	mov	r0, r8
 10095ca:	f01d fcf4 	bl	1026fb6 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_SD,
 10095ce:	1eb9      	subs	r1, r7, #2
 10095d0:	424a      	negs	r2, r1
 10095d2:	414a      	adcs	r2, r1
 10095d4:	4640      	mov	r0, r8
 10095d6:	2109      	movs	r1, #9
 10095d8:	f01d fced 	bl	1026fb6 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_CONNECTABLE,
 10095dc:	686a      	ldr	r2, [r5, #4]
 10095de:	210a      	movs	r1, #10
 10095e0:	4640      	mov	r0, r8
 10095e2:	f002 0201 	and.w	r2, r2, #1
 10095e6:	f01d fce6 	bl	1026fb6 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_SCANNABLE, scannable);
 10095ea:	464a      	mov	r2, r9
 10095ec:	210b      	movs	r1, #11
 10095ee:	4640      	mov	r0, r8
 10095f0:	f01d fce1 	bl	1026fb6 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
 10095f4:	686a      	ldr	r2, [r5, #4]
 10095f6:	210d      	movs	r1, #13
 10095f8:	4640      	mov	r0, r8
 10095fa:	f3c2 0280 	ubfx	r2, r2, #2, #1
 10095fe:	f01d fcda 	bl	1026fb6 <atomic_set_bit_to>
	return 0;
 1009602:	2400      	movs	r4, #0
 1009604:	e6fb      	b.n	10093fe <bt_le_adv_start_legacy+0x36>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
 1009606:	9807      	ldr	r0, [sp, #28]
 1009608:	b108      	cbz	r0, 100960e <bt_le_adv_start_legacy+0x246>
		bt_conn_unref(conn);
 100960a:	f000 fd47 	bl	100a09c <bt_conn_unref>
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
 100960e:	f1ba 0f00 	cmp.w	sl, #0
 1009612:	d1cf      	bne.n	10095b4 <bt_le_adv_start_legacy+0x1ec>
 1009614:	e7c9      	b.n	10095aa <bt_le_adv_start_legacy+0x1e2>
		return -EAGAIN;
 1009616:	f06f 040a 	mvn.w	r4, #10
 100961a:	e6f0      	b.n	10093fe <bt_le_adv_start_legacy+0x36>
		return -EALREADY;
 100961c:	f06f 0477 	mvn.w	r4, #119	; 0x77
 1009620:	e6ed      	b.n	10093fe <bt_le_adv_start_legacy+0x36>
		return -ENOBUFS;
 1009622:	f06f 0468 	mvn.w	r4, #104	; 0x68
 1009626:	e6ea      	b.n	10093fe <bt_le_adv_start_legacy+0x36>
 1009628:	210000cc 	.word	0x210000cc
 100962c:	21000000 	.word	0x21000000
 1009630:	0102cb79 	.word	0x0102cb79
 1009634:	0102d78b 	.word	0x0102d78b
 1009638:	01029954 	.word	0x01029954

0100963c <bt_le_adv_start>:
}

int bt_le_adv_start(const struct bt_le_adv_param *param,
		    const struct bt_data *ad, size_t ad_len,
		    const struct bt_data *sd, size_t sd_len)
{
 100963c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 100963e:	4615      	mov	r5, r2

	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
		err = bt_le_adv_start_ext(adv, param, ad, ad_len, sd, sd_len);
	} else {
		err = bt_le_adv_start_legacy(adv, param, ad, ad_len, sd, sd_len);
 1009640:	9a06      	ldr	r2, [sp, #24]
{
 1009642:	460c      	mov	r4, r1
		err = bt_le_adv_start_legacy(adv, param, ad, ad_len, sd, sd_len);
 1009644:	e9cd 3200 	strd	r3, r2, [sp]
 1009648:	462b      	mov	r3, r5
 100964a:	460a      	mov	r2, r1
 100964c:	4601      	mov	r1, r0
 100964e:	4811      	ldr	r0, [pc, #68]	; (1009694 <bt_le_adv_start+0x58>)
 1009650:	f7ff feba 	bl	10093c8 <bt_le_adv_start_legacy>
 1009654:	4621      	mov	r1, r4
 1009656:	4606      	mov	r6, r0
	for (i = 0; i < ad_len; i++) {
 1009658:	2300      	movs	r3, #0
		if (ad[i].type == BT_DATA_FLAGS &&
 100965a:	f240 1001 	movw	r0, #257	; 0x101
	for (i = 0; i < ad_len; i++) {
 100965e:	429d      	cmp	r5, r3
 1009660:	d102      	bne.n	1009668 <bt_le_adv_start+0x2c>
		k_work_reschedule(&adv->lim_adv_timeout_work,
				  K_SECONDS(CONFIG_BT_LIM_ADV_TIMEOUT));
	}

	return err;
}
 1009662:	4630      	mov	r0, r6
 1009664:	b002      	add	sp, #8
 1009666:	bd70      	pop	{r4, r5, r6, pc}
		if (ad[i].type == BT_DATA_FLAGS &&
 1009668:	880a      	ldrh	r2, [r1, #0]
 100966a:	4282      	cmp	r2, r0
 100966c:	d104      	bne.n	1009678 <bt_le_adv_start+0x3c>
		    ad[i].data != NULL) {
 100966e:	684a      	ldr	r2, [r1, #4]
		    ad[i].data_len == sizeof(uint8_t) &&
 1009670:	b112      	cbz	r2, 1009678 <bt_le_adv_start+0x3c>
			if (ad[i].data[0] & BT_LE_AD_LIMITED) {
 1009672:	7812      	ldrb	r2, [r2, #0]
 1009674:	07d2      	lsls	r2, r2, #31
 1009676:	d402      	bmi.n	100967e <bt_le_adv_start+0x42>
	for (i = 0; i < ad_len; i++) {
 1009678:	3301      	adds	r3, #1
 100967a:	3108      	adds	r1, #8
 100967c:	e7ef      	b.n	100965e <bt_le_adv_start+0x22>
		k_work_init_delayable(&adv->lim_adv_timeout_work, adv_timeout);
 100967e:	4906      	ldr	r1, [pc, #24]	; (1009698 <bt_le_adv_start+0x5c>)
 1009680:	4806      	ldr	r0, [pc, #24]	; (100969c <bt_le_adv_start+0x60>)
 1009682:	f018 fc43 	bl	1021f0c <k_work_init_delayable>
		k_work_reschedule(&adv->lim_adv_timeout_work,
 1009686:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
 100968a:	2300      	movs	r3, #0
 100968c:	4803      	ldr	r0, [pc, #12]	; (100969c <bt_le_adv_start+0x60>)
 100968e:	f018 fd59 	bl	1022144 <k_work_reschedule>
 1009692:	e7e6      	b.n	1009662 <bt_le_adv_start+0x26>
 1009694:	21000018 	.word	0x21000018
 1009698:	01009725 	.word	0x01009725
 100969c:	21000030 	.word	0x21000030

010096a0 <bt_le_adv_stop>:

int bt_le_adv_stop(void)
{
 10096a0:	b510      	push	{r4, lr}
	if (!adv) {
		LOG_ERR("No valid legacy adv");
		return 0;
	}

	(void)bt_le_lim_adv_cancel_timeout(adv);
 10096a2:	481a      	ldr	r0, [pc, #104]	; (100970c <bt_le_adv_stop+0x6c>)
 10096a4:	f01d fd43 	bl	102712e <bt_le_lim_adv_cancel_timeout>
 10096a8:	f46f 4180 	mvn.w	r1, #16384	; 0x4000
 10096ac:	4818      	ldr	r0, [pc, #96]	; (1009710 <bt_le_adv_stop+0x70>)
 10096ae:	f01d fc77 	bl	1026fa0 <atomic_and>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
 10096b2:	4817      	ldr	r0, [pc, #92]	; (1009710 <bt_le_adv_stop+0x70>)
 10096b4:	f01d fc71 	bl	1026f9a <atomic_get>
 10096b8:	4603      	mov	r3, r0
	/* Make sure advertising is not re-enabled later even if it's not
	 * currently enabled (i.e. BT_DEV_ADVERTISING is not set).
	 */
	atomic_clear_bit(adv->flags, BT_ADV_PERSIST);

	if (!atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
 10096ba:	061a      	lsls	r2, r3, #24
 10096bc:	f3c0 10c0 	ubfx	r0, r0, #7, #1
 10096c0:	d523      	bpl.n	100970a <bt_le_adv_stop+0x6a>
 10096c2:	4813      	ldr	r0, [pc, #76]	; (1009710 <bt_le_adv_stop+0x70>)
 10096c4:	f01d fc69 	bl	1026f9a <atomic_get>
		 */
		bt_le_adv_delete_legacy();
		return 0;
	}

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
 10096c8:	0543      	lsls	r3, r0, #21
 10096ca:	d514      	bpl.n	10096f6 <bt_le_adv_stop+0x56>
	return memcmp(a, b, sizeof(*a));
 10096cc:	2207      	movs	r2, #7
 10096ce:	4911      	ldr	r1, [pc, #68]	; (1009714 <bt_le_adv_stop+0x74>)
 10096d0:	4811      	ldr	r0, [pc, #68]	; (1009718 <bt_le_adv_stop+0x78>)
 10096d2:	f01d f93f 	bl	1026954 <memcmp>
 10096d6:	4b11      	ldr	r3, [pc, #68]	; (100971c <bt_le_adv_stop+0x7c>)
	if (bt_addr_le_eq(&adv->target_addr, BT_ADDR_LE_ANY)) {
 10096d8:	b998      	cbnz	r0, 1009702 <bt_le_adv_stop+0x62>
		conn = bt_conn_lookup_state_le(adv->id, BT_ADDR_LE_NONE,
 10096da:	2204      	movs	r2, #4
 10096dc:	4910      	ldr	r1, [pc, #64]	; (1009720 <bt_le_adv_stop+0x80>)
		conn = bt_conn_lookup_state_le(adv->id, &adv->target_addr,
 10096de:	7e18      	ldrb	r0, [r3, #24]
 10096e0:	f001 f82c 	bl	100a73c <bt_conn_lookup_state_le>
 10096e4:	4604      	mov	r4, r0
	if (conn) {
 10096e6:	b130      	cbz	r0, 10096f6 <bt_le_adv_stop+0x56>
		conn->err = status;
 10096e8:	2100      	movs	r1, #0
 10096ea:	7301      	strb	r1, [r0, #12]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
 10096ec:	f000 fd0e 	bl	100a10c <bt_conn_set_state>
		bt_conn_unref(conn);
 10096f0:	4620      	mov	r0, r4
 10096f2:	f000 fcd3 	bl	100a09c <bt_conn_unref>
		}
	}
#endif /* defined(CONFIG_BT_OBSERVER) */

	return 0;
}
 10096f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		err = bt_le_adv_set_enable_legacy(adv, false);
 10096fa:	2100      	movs	r1, #0
 10096fc:	4803      	ldr	r0, [pc, #12]	; (100970c <bt_le_adv_stop+0x6c>)
 10096fe:	f01d bcef 	b.w	10270e0 <bt_le_adv_set_enable_legacy>
		conn = bt_conn_lookup_state_le(adv->id, &adv->target_addr,
 1009702:	2205      	movs	r2, #5
 1009704:	f103 0121 	add.w	r1, r3, #33	; 0x21
 1009708:	e7e9      	b.n	10096de <bt_le_adv_stop+0x3e>
}
 100970a:	bd10      	pop	{r4, pc}
 100970c:	21000018 	.word	0x21000018
 1009710:	21000028 	.word	0x21000028
 1009714:	0102cb79 	.word	0x0102cb79
 1009718:	21000021 	.word	0x21000021
 100971c:	21000000 	.word	0x21000000
 1009720:	0102cb72 	.word	0x0102cb72

01009724 <adv_timeout>:
}
#endif /* defined(CONFIG_BT_EXT_ADV) */


static void adv_timeout(struct k_work *work)
{
 1009724:	b580      	push	{r7, lr}
 1009726:	af00      	add	r7, sp, #0
		err = bt_le_adv_stop();
	} else {
		err = bt_le_ext_adv_stop(adv);
	}
#else
	err = bt_le_adv_stop();
 1009728:	f7ff ffba 	bl	10096a0 <bt_le_adv_stop>
#endif
	LOG_WRN("Failed to stop advertising: %d", err);
 100972c:	b088      	sub	sp, #32
 100972e:	466a      	mov	r2, sp
 1009730:	4b06      	ldr	r3, [pc, #24]	; (100974c <adv_timeout+0x28>)
 1009732:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1009736:	2303      	movs	r3, #3
 1009738:	f842 3f10 	str.w	r3, [r2, #16]!
 100973c:	2300      	movs	r3, #0
 100973e:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 1009742:	4803      	ldr	r0, [pc, #12]	; (1009750 <adv_timeout+0x2c>)
 1009744:	f7fa ffe0 	bl	1004708 <z_impl_z_log_msg_static_create>
}
 1009748:	46bd      	mov	sp, r7
 100974a:	bd80      	pop	{r7, pc}
 100974c:	0102d7a6 	.word	0x0102d7a6
 1009750:	01029954 	.word	0x01029954

01009754 <bt_le_adv_resume>:
{
 1009754:	b573      	push	{r0, r1, r4, r5, r6, lr}
 1009756:	4c1e      	ldr	r4, [pc, #120]	; (10097d0 <bt_le_adv_resume+0x7c>)
 1009758:	4620      	mov	r0, r4
 100975a:	f01d fc1e 	bl	1026f9a <atomic_get>
	if (!(atomic_test_bit(adv->flags, BT_ADV_PERSIST) &&
 100975e:	0440      	lsls	r0, r0, #17
 1009760:	d534      	bpl.n	10097cc <bt_le_adv_resume+0x78>
 1009762:	4620      	mov	r0, r4
 1009764:	f01d fc19 	bl	1026f9a <atomic_get>
 1009768:	0601      	lsls	r1, r0, #24
 100976a:	d42f      	bmi.n	10097cc <bt_le_adv_resume+0x78>
 100976c:	4620      	mov	r0, r4
 100976e:	f01d fc14 	bl	1026f9a <atomic_get>
	if (!atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
 1009772:	0542      	lsls	r2, r0, #21
 1009774:	d52a      	bpl.n	10097cc <bt_le_adv_resume+0x78>
	err = le_adv_start_add_conn(adv, &conn);
 1009776:	a901      	add	r1, sp, #4
 1009778:	f1a4 0010 	sub.w	r0, r4, #16
 100977c:	f7ff fda2 	bl	10092c4 <le_adv_start_add_conn>
	if (err) {
 1009780:	4605      	mov	r5, r0
 1009782:	bb18      	cbnz	r0, 10097cc <bt_le_adv_resume+0x78>
	return bt_le_adv_set_enable_legacy(adv, enable);
 1009784:	2101      	movs	r1, #1
 1009786:	f1a4 0010 	sub.w	r0, r4, #16
 100978a:	f01d fca9 	bl	10270e0 <bt_le_adv_set_enable_legacy>
	bt_conn_unref(conn);
 100978e:	9e01      	ldr	r6, [sp, #4]
	if (err) {
 1009790:	b928      	cbnz	r0, 100979e <bt_le_adv_resume+0x4a>
	bt_conn_unref(conn);
 1009792:	4630      	mov	r0, r6
}
 1009794:	b002      	add	sp, #8
 1009796:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
 100979a:	f000 bc7f 	b.w	100a09c <bt_conn_unref>
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
 100979e:	4629      	mov	r1, r5
 10097a0:	4630      	mov	r0, r6
 10097a2:	f000 fcb3 	bl	100a10c <bt_conn_set_state>
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 10097a6:	f46f 4180 	mvn.w	r1, #16384	; 0x4000
 10097aa:	4620      	mov	r0, r4
 10097ac:	f01d fbf8 	bl	1026fa0 <atomic_and>
 10097b0:	4605      	mov	r5, r0
	bt_conn_unref(conn);
 10097b2:	4630      	mov	r0, r6
 10097b4:	f000 fc72 	bl	100a09c <bt_conn_unref>
	if (persist_paused) {
 10097b8:	046b      	lsls	r3, r5, #17
 10097ba:	d507      	bpl.n	10097cc <bt_le_adv_resume+0x78>
 10097bc:	e8d4 3fef 	ldaex	r3, [r4]
 10097c0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 10097c4:	e8c4 3fe2 	stlex	r2, r3, [r4]
 10097c8:	2a00      	cmp	r2, #0
 10097ca:	d1f7      	bne.n	10097bc <bt_le_adv_resume+0x68>
}
 10097cc:	b002      	add	sp, #8
 10097ce:	bd70      	pop	{r4, r5, r6, pc}
 10097d0:	21000028 	.word	0x21000028

010097d4 <bt_pub_key_is_debug>:
	0x6d, 0xeb, 0x2a, 0x65, 0x49, 0x9c, 0x80, 0xdc
};

bool bt_pub_key_is_debug(uint8_t *pub_key)
{
	return memcmp(pub_key, debug_public_key, BT_PUB_KEY_LEN) == 0;
 10097d4:	2240      	movs	r2, #64	; 0x40
{
 10097d6:	b508      	push	{r3, lr}
	return memcmp(pub_key, debug_public_key, BT_PUB_KEY_LEN) == 0;
 10097d8:	4903      	ldr	r1, [pc, #12]	; (10097e8 <bt_pub_key_is_debug+0x14>)
 10097da:	f01d f8bb 	bl	1026954 <memcmp>
}
 10097de:	fab0 f080 	clz	r0, r0
 10097e2:	0940      	lsrs	r0, r0, #5
 10097e4:	bd08      	pop	{r3, pc}
 10097e6:	bf00      	nop
 10097e8:	0102d853 	.word	0x0102d853

010097ec <bt_pub_key_gen>:

int bt_pub_key_gen(struct bt_pub_key_cb *new_cb)
{
 10097ec:	b5f0      	push	{r4, r5, r6, r7, lr}
	 * We check for both "LE Read Local P-256 Public Key" and
	 * "LE Generate DH Key" support here since both commands are needed for
	 * ECC support. If "LE Generate DH Key" is not supported then there
	 * is no point in reading local public key.
	 */
	if (!BT_CMD_TEST(bt_dev.supported_commands, 34, 1) ||
 10097ee:	4b3d      	ldr	r3, [pc, #244]	; (10098e4 <bt_pub_key_gen+0xf8>)
{
 10097f0:	b087      	sub	sp, #28
	if (!BT_CMD_TEST(bt_dev.supported_commands, 34, 1) ||
 10097f2:	f893 309a 	ldrb.w	r3, [r3, #154]	; 0x9a
 10097f6:	f003 0306 	and.w	r3, r3, #6
 10097fa:	2b06      	cmp	r3, #6
 10097fc:	d00f      	beq.n	100981e <bt_pub_key_gen+0x32>
	    !BT_CMD_TEST(bt_dev.supported_commands, 34, 2)) {
		LOG_WRN("ECC HCI commands not available");
 10097fe:	4b3a      	ldr	r3, [pc, #232]	; (10098e8 <bt_pub_key_gen+0xfc>)
 1009800:	9305      	str	r3, [sp, #20]
 1009802:	2302      	movs	r3, #2
 1009804:	9304      	str	r3, [sp, #16]
		return -ENOTSUP;
 1009806:	f06f 0585 	mvn.w	r5, #133	; 0x85
 100980a:	2300      	movs	r3, #0
 100980c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 1009810:	4836      	ldr	r0, [pc, #216]	; (10098ec <bt_pub_key_gen+0x100>)
 1009812:	aa04      	add	r2, sp, #16
 1009814:	f7fa ff78 	bl	1004708 <z_impl_z_log_msg_static_create>
		sys_slist_init(&pub_key_cb_slist);
		return err;
	}

	return 0;
}
 1009818:	4628      	mov	r0, r5
 100981a:	b007      	add	sp, #28
 100981c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!new_cb) {
 100981e:	2800      	cmp	r0, #0
 1009820:	d05d      	beq.n	10098de <bt_pub_key_gen+0xf2>
	return list->head;
 1009822:	4e33      	ldr	r6, [pc, #204]	; (10098f0 <bt_pub_key_gen+0x104>)
 1009824:	6832      	ldr	r2, [r6, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
 1009826:	b1a2      	cbz	r2, 1009852 <bt_pub_key_gen+0x66>
 1009828:	1f13      	subs	r3, r2, #4
		if (cb == new_cb) {
 100982a:	4283      	cmp	r3, r0
 100982c:	d10d      	bne.n	100984a <bt_pub_key_gen+0x5e>
			LOG_WRN("Callback already registered");
 100982e:	4b31      	ldr	r3, [pc, #196]	; (10098f4 <bt_pub_key_gen+0x108>)
 1009830:	9305      	str	r3, [sp, #20]
 1009832:	2302      	movs	r3, #2
 1009834:	9304      	str	r3, [sp, #16]
 1009836:	2300      	movs	r3, #0
 1009838:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100983c:	482b      	ldr	r0, [pc, #172]	; (10098ec <bt_pub_key_gen+0x100>)
 100983e:	aa04      	add	r2, sp, #16
 1009840:	f7fa ff62 	bl	1004708 <z_impl_z_log_msg_static_create>
			return -EALREADY;
 1009844:	f06f 0577 	mvn.w	r5, #119	; 0x77
 1009848:	e7e6      	b.n	1009818 <bt_pub_key_gen+0x2c>
	return node->next;
 100984a:	685b      	ldr	r3, [r3, #4]
	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
 100984c:	b10b      	cbz	r3, 1009852 <bt_pub_key_gen+0x66>
 100984e:	3b04      	subs	r3, #4
 1009850:	e7eb      	b.n	100982a <bt_pub_key_gen+0x3e>
	parent->next = child;
 1009852:	6042      	str	r2, [r0, #4]
Z_GENLIST_PREPEND(slist, snode)
 1009854:	6872      	ldr	r2, [r6, #4]
	sys_slist_prepend(&pub_key_cb_slist, &new_cb->node);
 1009856:	1d03      	adds	r3, r0, #4
	list->head = node;
 1009858:	6033      	str	r3, [r6, #0]
Z_GENLIST_PREPEND(slist, snode)
 100985a:	b902      	cbnz	r2, 100985e <bt_pub_key_gen+0x72>
	list->tail = node;
 100985c:	6073      	str	r3, [r6, #4]
 100985e:	4c26      	ldr	r4, [pc, #152]	; (10098f8 <bt_pub_key_gen+0x10c>)
 1009860:	e8d4 7fef 	ldaex	r7, [r4]
 1009864:	f047 0320 	orr.w	r3, r7, #32
 1009868:	e8c4 3fe2 	stlex	r2, r3, [r4]
 100986c:	2a00      	cmp	r2, #0
 100986e:	d1f7      	bne.n	1009860 <bt_pub_key_gen+0x74>
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
 1009870:	f017 0720 	ands.w	r7, r7, #32
 1009874:	d001      	beq.n	100987a <bt_pub_key_gen+0x8e>
	return 0;
 1009876:	2500      	movs	r5, #0
 1009878:	e7ce      	b.n	1009818 <bt_pub_key_gen+0x2c>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 100987a:	e8d4 3fef 	ldaex	r3, [r4]
 100987e:	f023 0310 	bic.w	r3, r3, #16
 1009882:	e8c4 3fe2 	stlex	r2, r3, [r4]
 1009886:	2a00      	cmp	r2, #0
 1009888:	d1f7      	bne.n	100987a <bt_pub_key_gen+0x8e>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_P256_PUBLIC_KEY, NULL, NULL);
 100988a:	463a      	mov	r2, r7
 100988c:	4639      	mov	r1, r7
 100988e:	f242 0025 	movw	r0, #8229	; 0x2025
 1009892:	f7fe fb51 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 1009896:	4605      	mov	r5, r0
 1009898:	2800      	cmp	r0, #0
 100989a:	d0ec      	beq.n	1009876 <bt_pub_key_gen+0x8a>
		LOG_ERR("Sending LE P256 Public Key command failed");
 100989c:	4b17      	ldr	r3, [pc, #92]	; (10098fc <bt_pub_key_gen+0x110>)
 100989e:	9305      	str	r3, [sp, #20]
 10098a0:	2302      	movs	r3, #2
 10098a2:	9304      	str	r3, [sp, #16]
 10098a4:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10098a8:	463b      	mov	r3, r7
 10098aa:	4810      	ldr	r0, [pc, #64]	; (10098ec <bt_pub_key_gen+0x100>)
 10098ac:	aa04      	add	r2, sp, #16
 10098ae:	f7fa ff2b 	bl	1004708 <z_impl_z_log_msg_static_create>
 10098b2:	e8d4 3fef 	ldaex	r3, [r4]
 10098b6:	f023 0320 	bic.w	r3, r3, #32
 10098ba:	e8c4 3fe2 	stlex	r2, r3, [r4]
 10098be:	2a00      	cmp	r2, #0
 10098c0:	d1f7      	bne.n	10098b2 <bt_pub_key_gen+0xc6>
	return list->head;
 10098c2:	6834      	ldr	r4, [r6, #0]
		SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
 10098c4:	b13c      	cbz	r4, 10098d6 <bt_pub_key_gen+0xea>
			if (cb->func) {
 10098c6:	f854 3c04 	ldr.w	r3, [r4, #-4]
		SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
 10098ca:	3c04      	subs	r4, #4
			if (cb->func) {
 10098cc:	b10b      	cbz	r3, 10098d2 <bt_pub_key_gen+0xe6>
				cb->func(NULL);
 10098ce:	2000      	movs	r0, #0
 10098d0:	4798      	blx	r3
	return node->next;
 10098d2:	6864      	ldr	r4, [r4, #4]
 10098d4:	e7f6      	b.n	10098c4 <bt_pub_key_gen+0xd8>
	list->head = NULL;
 10098d6:	2300      	movs	r3, #0
	list->tail = NULL;
 10098d8:	e9c6 3300 	strd	r3, r3, [r6]
		return err;
 10098dc:	e79c      	b.n	1009818 <bt_pub_key_gen+0x2c>
		return -EINVAL;
 10098de:	f06f 0515 	mvn.w	r5, #21
 10098e2:	e799      	b.n	1009818 <bt_pub_key_gen+0x2c>
 10098e4:	21000000 	.word	0x21000000
 10098e8:	0102d7cc 	.word	0x0102d7cc
 10098ec:	01029994 	.word	0x01029994
 10098f0:	21004708 	.word	0x21004708
 10098f4:	0102d7eb 	.word	0x0102d7eb
 10098f8:	210000cc 	.word	0x210000cc
 10098fc:	0102d807 	.word	0x0102d807

01009900 <bt_pub_key_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1009900:	4b04      	ldr	r3, [pc, #16]	; (1009914 <bt_pub_key_get+0x14>)
 1009902:	e8d3 3faf 	lda	r3, [r3]

	if (atomic_test_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY)) {
		return pub_key;
	}

	return NULL;
 1009906:	f013 0f10 	tst.w	r3, #16
}
 100990a:	4803      	ldr	r0, [pc, #12]	; (1009918 <bt_pub_key_get+0x18>)
 100990c:	bf08      	it	eq
 100990e:	2000      	moveq	r0, #0
 1009910:	4770      	bx	lr
 1009912:	bf00      	nop
 1009914:	210000cc 	.word	0x210000cc
 1009918:	21008305 	.word	0x21008305

0100991c <bt_dh_key_gen>:

	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_GENERATE_DHKEY_V2, buf, NULL);
}

int bt_dh_key_gen(const uint8_t remote_pk[BT_PUB_KEY_LEN], bt_dh_key_cb_t cb)
{
 100991c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int err;

	if (dh_key_cb == cb) {
 1009920:	4d25      	ldr	r5, [pc, #148]	; (10099b8 <bt_dh_key_gen+0x9c>)
{
 1009922:	4606      	mov	r6, r0
	if (dh_key_cb == cb) {
 1009924:	682b      	ldr	r3, [r5, #0]
{
 1009926:	af00      	add	r7, sp, #0
	if (dh_key_cb == cb) {
 1009928:	428b      	cmp	r3, r1
 100992a:	d03f      	beq.n	10099ac <bt_dh_key_gen+0x90>
		return -EALREADY;
	}

	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
 100992c:	b12b      	cbz	r3, 100993a <bt_dh_key_gen+0x1e>
		return -EBUSY;
 100992e:	f06f 040f 	mvn.w	r4, #15
		LOG_WRN("Failed to generate DHKey (err %d)", err);
		return err;
	}

	return 0;
}
 1009932:	4620      	mov	r0, r4
 1009934:	46bd      	mov	sp, r7
 1009936:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100993a:	4b20      	ldr	r3, [pc, #128]	; (10099bc <bt_dh_key_gen+0xa0>)
 100993c:	e8d3 2faf 	lda	r2, [r3]
	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
 1009940:	f3c2 1840 	ubfx	r8, r2, #5, #1
 1009944:	0692      	lsls	r2, r2, #26
 1009946:	d4f2      	bmi.n	100992e <bt_dh_key_gen+0x12>
 1009948:	e8d3 3faf 	lda	r3, [r3]
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY)) {
 100994c:	06db      	lsls	r3, r3, #27
 100994e:	d530      	bpl.n	10099b2 <bt_dh_key_gen+0x96>
	dh_key_cb = cb;
 1009950:	6029      	str	r1, [r5, #0]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_GENERATE_DHKEY, sizeof(*cp));
 1009952:	f242 0026 	movw	r0, #8230	; 0x2026
 1009956:	2140      	movs	r1, #64	; 0x40
 1009958:	f7fe f998 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 100995c:	4604      	mov	r4, r0
 100995e:	b310      	cbz	r0, 10099a6 <bt_dh_key_gen+0x8a>
	return net_buf_simple_add(&buf->b, len);
 1009960:	2140      	movs	r1, #64	; 0x40
 1009962:	300c      	adds	r0, #12
 1009964:	f014 fc98 	bl	101e298 <net_buf_simple_add>
	memcpy(cp->key, remote_pk, sizeof(cp->key));
 1009968:	2240      	movs	r2, #64	; 0x40
 100996a:	4631      	mov	r1, r6
 100996c:	f01d f802 	bl	1026974 <memcpy>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_GENERATE_DHKEY, buf, NULL);
 1009970:	4621      	mov	r1, r4
 1009972:	4642      	mov	r2, r8
 1009974:	f242 0026 	movw	r0, #8230	; 0x2026
 1009978:	f7fe fade 	bl	1007f38 <bt_hci_cmd_send_sync>
	if (err) {
 100997c:	4604      	mov	r4, r0
 100997e:	2800      	cmp	r0, #0
 1009980:	d0d7      	beq.n	1009932 <bt_dh_key_gen+0x16>
		dh_key_cb = NULL;
 1009982:	2300      	movs	r3, #0
 1009984:	602b      	str	r3, [r5, #0]
		LOG_WRN("Failed to generate DHKey (err %d)", err);
 1009986:	466d      	mov	r5, sp
 1009988:	b088      	sub	sp, #32
 100998a:	466a      	mov	r2, sp
 100998c:	490c      	ldr	r1, [pc, #48]	; (10099c0 <bt_dh_key_gen+0xa4>)
 100998e:	e9c2 1405 	strd	r1, r4, [r2, #20]
 1009992:	2103      	movs	r1, #3
 1009994:	f842 1f10 	str.w	r1, [r2, #16]!
 1009998:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100999c:	4809      	ldr	r0, [pc, #36]	; (10099c4 <bt_dh_key_gen+0xa8>)
 100999e:	f7fa feb3 	bl	1004708 <z_impl_z_log_msg_static_create>
 10099a2:	46ad      	mov	sp, r5
		return err;
 10099a4:	e7c5      	b.n	1009932 <bt_dh_key_gen+0x16>
		return -ENOBUFS;
 10099a6:	f06f 0468 	mvn.w	r4, #104	; 0x68
 10099aa:	e7ea      	b.n	1009982 <bt_dh_key_gen+0x66>
		return -EALREADY;
 10099ac:	f06f 0477 	mvn.w	r4, #119	; 0x77
 10099b0:	e7bf      	b.n	1009932 <bt_dh_key_gen+0x16>
		return -EADDRNOTAVAIL;
 10099b2:	f06f 047c 	mvn.w	r4, #124	; 0x7c
 10099b6:	e7bc      	b.n	1009932 <bt_dh_key_gen+0x16>
 10099b8:	21004704 	.word	0x21004704
 10099bc:	210000cc 	.word	0x210000cc
 10099c0:	0102d831 	.word	0x0102d831
 10099c4:	01029994 	.word	0x01029994

010099c8 <bt_hci_evt_le_pkey_complete>:

void bt_hci_evt_le_pkey_complete(struct net_buf *buf)
{
 10099c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 10099ca:	4c17      	ldr	r4, [pc, #92]	; (1009a28 <bt_hci_evt_le_pkey_complete+0x60>)
	struct bt_hci_evt_le_p256_public_key_complete *evt = (void *)buf->data;
 10099cc:	68c6      	ldr	r6, [r0, #12]
 10099ce:	e8d4 3fef 	ldaex	r3, [r4]
 10099d2:	f023 0320 	bic.w	r3, r3, #32
 10099d6:	e8c4 3fe2 	stlex	r2, r3, [r4]
 10099da:	2a00      	cmp	r2, #0
 10099dc:	d1f7      	bne.n	10099ce <bt_hci_evt_le_pkey_complete+0x6>

	LOG_DBG("status: 0x%02x", evt->status);

	atomic_clear_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY);

	if (!evt->status) {
 10099de:	7833      	ldrb	r3, [r6, #0]
 10099e0:	b963      	cbnz	r3, 10099fc <bt_hci_evt_le_pkey_complete+0x34>
		memcpy(pub_key, evt->key, BT_PUB_KEY_LEN);
 10099e2:	2240      	movs	r2, #64	; 0x40
 10099e4:	4811      	ldr	r0, [pc, #68]	; (1009a2c <bt_hci_evt_le_pkey_complete+0x64>)
 10099e6:	1c71      	adds	r1, r6, #1
 10099e8:	f01c ffc4 	bl	1026974 <memcpy>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 10099ec:	e8d4 3fef 	ldaex	r3, [r4]
 10099f0:	f043 0310 	orr.w	r3, r3, #16
 10099f4:	e8c4 3fe2 	stlex	r2, r3, [r4]
 10099f8:	2a00      	cmp	r2, #0
 10099fa:	d1f7      	bne.n	10099ec <bt_hci_evt_le_pkey_complete+0x24>
	return list->head;
 10099fc:	4d0c      	ldr	r5, [pc, #48]	; (1009a30 <bt_hci_evt_le_pkey_complete+0x68>)
 10099fe:	682c      	ldr	r4, [r5, #0]
		atomic_set_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY);
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
 1009a00:	b16c      	cbz	r4, 1009a1e <bt_hci_evt_le_pkey_complete+0x56>
		if (cb->func) {
			cb->func(evt->status ? NULL : pub_key);
 1009a02:	4f0a      	ldr	r7, [pc, #40]	; (1009a2c <bt_hci_evt_le_pkey_complete+0x64>)
	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
 1009a04:	3c04      	subs	r4, #4
		if (cb->func) {
 1009a06:	6823      	ldr	r3, [r4, #0]
 1009a08:	b12b      	cbz	r3, 1009a16 <bt_hci_evt_le_pkey_complete+0x4e>
			cb->func(evt->status ? NULL : pub_key);
 1009a0a:	7832      	ldrb	r2, [r6, #0]
 1009a0c:	2a00      	cmp	r2, #0
 1009a0e:	bf0c      	ite	eq
 1009a10:	4638      	moveq	r0, r7
 1009a12:	2000      	movne	r0, #0
 1009a14:	4798      	blx	r3
	return node->next;
 1009a16:	6864      	ldr	r4, [r4, #4]
	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
 1009a18:	b10c      	cbz	r4, 1009a1e <bt_hci_evt_le_pkey_complete+0x56>
 1009a1a:	3c04      	subs	r4, #4
 1009a1c:	e7f3      	b.n	1009a06 <bt_hci_evt_le_pkey_complete+0x3e>
	list->head = NULL;
 1009a1e:	2300      	movs	r3, #0
	list->tail = NULL;
 1009a20:	e9c5 3300 	strd	r3, r3, [r5]
		}
	}

	sys_slist_init(&pub_key_cb_slist);
}
 1009a24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1009a26:	bf00      	nop
 1009a28:	210000cc 	.word	0x210000cc
 1009a2c:	21008305 	.word	0x21008305
 1009a30:	21004708 	.word	0x21004708

01009a34 <bt_hci_evt_le_dhkey_complete>:
{
	struct bt_hci_evt_le_generate_dhkey_complete *evt = (void *)buf->data;

	LOG_DBG("status: 0x%02x", evt->status);

	if (dh_key_cb) {
 1009a34:	4905      	ldr	r1, [pc, #20]	; (1009a4c <bt_hci_evt_le_dhkey_complete+0x18>)
 1009a36:	680b      	ldr	r3, [r1, #0]
 1009a38:	b133      	cbz	r3, 1009a48 <bt_hci_evt_le_dhkey_complete+0x14>
	struct bt_hci_evt_le_generate_dhkey_complete *evt = (void *)buf->data;
 1009a3a:	68c2      	ldr	r2, [r0, #12]
		bt_dh_key_cb_t cb = dh_key_cb;

		dh_key_cb = NULL;
 1009a3c:	2000      	movs	r0, #0
 1009a3e:	6008      	str	r0, [r1, #0]
		cb(evt->status ? NULL : evt->dhkey);
 1009a40:	7811      	ldrb	r1, [r2, #0]
 1009a42:	b901      	cbnz	r1, 1009a46 <bt_hci_evt_le_dhkey_complete+0x12>
 1009a44:	1c50      	adds	r0, r2, #1
 1009a46:	4718      	bx	r3
	}
}
 1009a48:	4770      	bx	lr
 1009a4a:	bf00      	nop
 1009a4c:	21004704 	.word	0x21004704

01009a50 <notify_connected>:
		return -ENOTCONN;
	}
}

static void notify_connected(struct bt_conn *conn)
{
 1009a50:	b570      	push	{r4, r5, r6, lr}
 1009a52:	4604      	mov	r4, r0
	struct bt_conn_cb *cb;

	for (cb = callback_list; cb; cb = cb->_next) {
 1009a54:	4b12      	ldr	r3, [pc, #72]	; (1009aa0 <notify_connected+0x50>)
 1009a56:	681d      	ldr	r5, [r3, #0]
 1009a58:	b995      	cbnz	r5, 1009a80 <notify_connected+0x30>
		if (cb->connected) {
			cb->connected(conn, conn->err);
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 1009a5a:	4d12      	ldr	r5, [pc, #72]	; (1009aa4 <notify_connected+0x54>)
 1009a5c:	4e12      	ldr	r6, [pc, #72]	; (1009aa8 <notify_connected+0x58>)
 1009a5e:	42b5      	cmp	r5, r6
 1009a60:	d91c      	bls.n	1009a9c <notify_connected+0x4c>
 1009a62:	4912      	ldr	r1, [pc, #72]	; (1009aac <notify_connected+0x5c>)
 1009a64:	f240 535b 	movw	r3, #1371	; 0x55b
 1009a68:	4a11      	ldr	r2, [pc, #68]	; (1009ab0 <notify_connected+0x60>)
 1009a6a:	4812      	ldr	r0, [pc, #72]	; (1009ab4 <notify_connected+0x64>)
 1009a6c:	f01b f8b3 	bl	1024bd6 <assert_print>
 1009a70:	4811      	ldr	r0, [pc, #68]	; (1009ab8 <notify_connected+0x68>)
 1009a72:	f01b f8b0 	bl	1024bd6 <assert_print>
 1009a76:	f240 515b 	movw	r1, #1371	; 0x55b
 1009a7a:	480d      	ldr	r0, [pc, #52]	; (1009ab0 <notify_connected+0x60>)
 1009a7c:	f01b f8a4 	bl	1024bc8 <assert_post_action>
		if (cb->connected) {
 1009a80:	682b      	ldr	r3, [r5, #0]
 1009a82:	b113      	cbz	r3, 1009a8a <notify_connected+0x3a>
			cb->connected(conn, conn->err);
 1009a84:	4620      	mov	r0, r4
 1009a86:	7b21      	ldrb	r1, [r4, #12]
 1009a88:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
 1009a8a:	69ad      	ldr	r5, [r5, #24]
 1009a8c:	e7e4      	b.n	1009a58 <notify_connected+0x8>
		if (cb->connected) {
 1009a8e:	682b      	ldr	r3, [r5, #0]
 1009a90:	b113      	cbz	r3, 1009a98 <notify_connected+0x48>
			cb->connected(conn, conn->err);
 1009a92:	4620      	mov	r0, r4
 1009a94:	7b21      	ldrb	r1, [r4, #12]
 1009a96:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 1009a98:	351c      	adds	r5, #28
 1009a9a:	e7e0      	b.n	1009a5e <notify_connected+0xe>
 1009a9c:	d3f7      	bcc.n	1009a8e <notify_connected+0x3e>
		}
	}
}
 1009a9e:	bd70      	pop	{r4, r5, r6, pc}
 1009aa0:	21004740 	.word	0x21004740
 1009aa4:	01029910 	.word	0x01029910
 1009aa8:	0102992c 	.word	0x0102992c
 1009aac:	0102d8ca 	.word	0x0102d8ca
 1009ab0:	0102d89a 	.word	0x0102d89a
 1009ab4:	0102b695 	.word	0x0102b695
 1009ab8:	0102bf04 	.word	0x0102bf04

01009abc <tx_notify>:
{
 1009abc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1009ac0:	4604      	mov	r4, r0
	tx->cb = NULL;
 1009ac2:	f04f 0800 	mov.w	r8, #0
	k_fifo_put(&free_tx, tx);
 1009ac6:	4f14      	ldr	r7, [pc, #80]	; (1009b18 <tx_notify+0x5c>)
	__asm__ volatile(
 1009ac8:	f04f 0220 	mov.w	r2, #32
 1009acc:	f3ef 8311 	mrs	r3, BASEPRI
 1009ad0:	f382 8812 	msr	BASEPRI_MAX, r2
 1009ad4:	f3bf 8f6f 	isb	sy
	return list->head;
 1009ad8:	6a21      	ldr	r1, [r4, #32]
		if (!sys_slist_is_empty(&conn->tx_complete)) {
 1009ada:	b929      	cbnz	r1, 1009ae8 <tx_notify+0x2c>
	__asm__ volatile(
 1009adc:	f383 8811 	msr	BASEPRI, r3
 1009ae0:	f3bf 8f6f 	isb	sy
}
 1009ae4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1009ae8:	6a60      	ldr	r0, [r4, #36]	; 0x24
	return node->next;
 1009aea:	680a      	ldr	r2, [r1, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1009aec:	4281      	cmp	r1, r0
	list->tail = node;
 1009aee:	bf08      	it	eq
 1009af0:	6262      	streq	r2, [r4, #36]	; 0x24
	list->head = node;
 1009af2:	6222      	str	r2, [r4, #32]
 1009af4:	f383 8811 	msr	BASEPRI, r3
 1009af8:	f3bf 8f6f 	isb	sy
		user_data = tx->user_data;
 1009afc:	e9d1 5601 	ldrd	r5, r6, [r1, #4]
	k_fifo_put(&free_tx, tx);
 1009b00:	4638      	mov	r0, r7
	tx->user_data = NULL;
 1009b02:	e9c1 8801 	strd	r8, r8, [r1, #4]
	tx->pending_no_cb = 0U;
 1009b06:	f8c1 800c 	str.w	r8, [r1, #12]
	k_fifo_put(&free_tx, tx);
 1009b0a:	f01f fbef 	bl	10292ec <k_queue_append>
		cb(conn, user_data, 0);
 1009b0e:	2200      	movs	r2, #0
 1009b10:	4631      	mov	r1, r6
 1009b12:	4620      	mov	r0, r4
 1009b14:	47a8      	blx	r5
	while (1) {
 1009b16:	e7d7      	b.n	1009ac8 <tx_notify+0xc>
 1009b18:	21000d60 	.word	0x21000d60

01009b1c <conn_tx_destroy>:
{
 1009b1c:	b570      	push	{r4, r5, r6, lr}
 1009b1e:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(tx);
 1009b20:	b949      	cbnz	r1, 1009b36 <conn_tx_destroy+0x1a>
 1009b22:	490d      	ldr	r1, [pc, #52]	; (1009b58 <conn_tx_destroy+0x3c>)
 1009b24:	480d      	ldr	r0, [pc, #52]	; (1009b5c <conn_tx_destroy+0x40>)
 1009b26:	2339      	movs	r3, #57	; 0x39
 1009b28:	4a0d      	ldr	r2, [pc, #52]	; (1009b60 <conn_tx_destroy+0x44>)
 1009b2a:	f01b f854 	bl	1024bd6 <assert_print>
 1009b2e:	2139      	movs	r1, #57	; 0x39
 1009b30:	480b      	ldr	r0, [pc, #44]	; (1009b60 <conn_tx_destroy+0x44>)
 1009b32:	f01b f849 	bl	1024bc8 <assert_post_action>
	tx->cb = NULL;
 1009b36:	2200      	movs	r2, #0
	void *user_data = tx->user_data;
 1009b38:	e9d1 5601 	ldrd	r5, r6, [r1, #4]
	tx->pending_no_cb = 0U;
 1009b3c:	60ca      	str	r2, [r1, #12]
	tx->user_data = NULL;
 1009b3e:	e9c1 2201 	strd	r2, r2, [r1, #4]
	k_fifo_put(&free_tx, tx);
 1009b42:	4808      	ldr	r0, [pc, #32]	; (1009b64 <conn_tx_destroy+0x48>)
 1009b44:	f01f fbd2 	bl	10292ec <k_queue_append>
	cb(conn, user_data, -ESHUTDOWN);
 1009b48:	4631      	mov	r1, r6
 1009b4a:	4620      	mov	r0, r4
 1009b4c:	462b      	mov	r3, r5
}
 1009b4e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	cb(conn, user_data, -ESHUTDOWN);
 1009b52:	f06f 026d 	mvn.w	r2, #109	; 0x6d
 1009b56:	4718      	bx	r3
 1009b58:	0102d8e5 	.word	0x0102d8e5
 1009b5c:	0102b695 	.word	0x0102b695
 1009b60:	0102d89a 	.word	0x0102d89a
 1009b64:	21000d60 	.word	0x21000d60

01009b68 <send_frag>:
{
 1009b68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1009b6c:	4604      	mov	r4, r0
 1009b6e:	460e      	mov	r6, r1
 1009b70:	4692      	mov	sl, r2
 1009b72:	4699      	mov	r9, r3
	struct bt_conn_tx *tx = tx_data(buf)->tx;
 1009b74:	698d      	ldr	r5, [r1, #24]
{
 1009b76:	af00      	add	r7, sp, #0
	return z_impl_k_sem_take(sem, timeout);
 1009b78:	f04f 33ff 	mov.w	r3, #4294967295
 1009b7c:	f04f 32ff 	mov.w	r2, #4294967295
 1009b80:	484c      	ldr	r0, [pc, #304]	; (1009cb4 <send_frag+0x14c>)
 1009b82:	f017 fdd1 	bl	1021728 <z_impl_k_sem_take>
	if (conn->state != BT_CONN_CONNECTED) {
 1009b86:	7b63      	ldrb	r3, [r4, #13]
 1009b88:	2b07      	cmp	r3, #7
 1009b8a:	f040 8086 	bne.w	1009c9a <send_frag+0x132>
	__asm__ volatile(
 1009b8e:	f04f 0320 	mov.w	r3, #32
 1009b92:	f3ef 8211 	mrs	r2, BASEPRI
 1009b96:	f383 8812 	msr	BASEPRI_MAX, r3
 1009b9a:	f3bf 8f6f 	isb	sy
	if (tx) {
 1009b9e:	2d00      	cmp	r5, #0
 1009ba0:	d04e      	beq.n	1009c40 <send_frag+0xd8>
	parent->next = child;
 1009ba2:	2300      	movs	r3, #0
 1009ba4:	602b      	str	r3, [r5, #0]
	return list->tail;
 1009ba6:	69a3      	ldr	r3, [r4, #24]
Z_GENLIST_APPEND(slist, snode)
 1009ba8:	2b00      	cmp	r3, #0
 1009baa:	d146      	bne.n	1009c3a <send_frag+0xd2>
	list->head = node;
 1009bac:	e9c4 5505 	strd	r5, r5, [r4, #20]
	__asm__ volatile(
 1009bb0:	f382 8811 	msr	BASEPRI, r2
 1009bb4:	f3bf 8f6f 	isb	sy
	return net_buf_simple_push(&buf->b, len);
 1009bb8:	2104      	movs	r1, #4
 1009bba:	f106 000c 	add.w	r0, r6, #12
 1009bbe:	f014 fb0f 	bl	101e1e0 <net_buf_simple_push>
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
 1009bc2:	8823      	ldrh	r3, [r4, #0]
 1009bc4:	f00a 0afd 	and.w	sl, sl, #253	; 0xfd
 1009bc8:	ea43 3a0a 	orr.w	sl, r3, sl, lsl #12
 1009bcc:	f8a0 a000 	strh.w	sl, [r0]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
 1009bd0:	8a33      	ldrh	r3, [r6, #16]
 1009bd2:	3b04      	subs	r3, #4
 1009bd4:	8043      	strh	r3, [r0, #2]
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
 1009bd6:	2302      	movs	r3, #2
	return bt_send(buf);
 1009bd8:	4630      	mov	r0, r6
 1009bda:	7633      	strb	r3, [r6, #24]
 1009bdc:	f01d f8bb 	bl	1026d56 <bt_send>
	if (err) {
 1009be0:	2800      	cmp	r0, #0
 1009be2:	d064      	beq.n	1009cae <send_frag+0x146>
		LOG_ERR("Unable to send to driver (err %d)", err);
 1009be4:	46ea      	mov	sl, sp
 1009be6:	b088      	sub	sp, #32
 1009be8:	466a      	mov	r2, sp
 1009bea:	4b33      	ldr	r3, [pc, #204]	; (1009cb8 <send_frag+0x150>)
 1009bec:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1009bf0:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1009bf4:	2303      	movs	r3, #3
 1009bf6:	4831      	ldr	r0, [pc, #196]	; (1009cbc <send_frag+0x154>)
 1009bf8:	f842 3f10 	str.w	r3, [r2, #16]!
 1009bfc:	f01d fac0 	bl	1027180 <z_log_msg_static_create.constprop.0>
 1009c00:	46d5      	mov	sp, sl
	__asm__ volatile(
 1009c02:	f04f 0320 	mov.w	r3, #32
 1009c06:	f3ef 8a11 	mrs	sl, BASEPRI
 1009c0a:	f383 8812 	msr	BASEPRI_MAX, r3
 1009c0e:	f3bf 8f6f 	isb	sy
		if (tx) {
 1009c12:	b315      	cbz	r5, 1009c5a <send_frag+0xf2>
			sys_slist_find_and_remove(&conn->tx_pending, &tx->node);
 1009c14:	4629      	mov	r1, r5
 1009c16:	f104 0014 	add.w	r0, r4, #20
 1009c1a:	f01d fa8b 	bl	1027134 <sys_slist_find_and_remove>
	__asm__ volatile(
 1009c1e:	f38a 8811 	msr	BASEPRI, sl
 1009c22:	f3bf 8f6f 	isb	sy
	z_impl_k_sem_give(sem);
 1009c26:	4823      	ldr	r0, [pc, #140]	; (1009cb4 <send_frag+0x14c>)
 1009c28:	f017 fd3a 	bl	10216a0 <z_impl_k_sem_give>
		tx_data(buf)->tx = NULL;
 1009c2c:	2300      	movs	r3, #0
		conn_tx_destroy(conn, tx);
 1009c2e:	4629      	mov	r1, r5
 1009c30:	4620      	mov	r0, r4
		tx_data(buf)->tx = NULL;
 1009c32:	61b3      	str	r3, [r6, #24]
		conn_tx_destroy(conn, tx);
 1009c34:	f7ff ff72 	bl	1009b1c <conn_tx_destroy>
 1009c38:	e028      	b.n	1009c8c <send_frag+0x124>
	parent->next = child;
 1009c3a:	601d      	str	r5, [r3, #0]
	list->tail = node;
 1009c3c:	61a5      	str	r5, [r4, #24]
}
 1009c3e:	e7b7      	b.n	1009bb0 <send_frag+0x48>
	return list->tail;
 1009c40:	69a3      	ldr	r3, [r4, #24]
		if (tail_tx) {
 1009c42:	b133      	cbz	r3, 1009c52 <send_frag+0xea>
			pending_no_cb = &tail_tx->pending_no_cb;
 1009c44:	f103 080c 	add.w	r8, r3, #12
 1009c48:	68db      	ldr	r3, [r3, #12]
		(*pending_no_cb)++;
 1009c4a:	3301      	adds	r3, #1
 1009c4c:	f8c8 3000 	str.w	r3, [r8]
 1009c50:	e7ae      	b.n	1009bb0 <send_frag+0x48>
			pending_no_cb = &conn->pending_no_cb;
 1009c52:	69e3      	ldr	r3, [r4, #28]
 1009c54:	f104 081c 	add.w	r8, r4, #28
 1009c58:	e7f7      	b.n	1009c4a <send_frag+0xe2>
			__ASSERT_NO_MSG(*pending_no_cb > 0);
 1009c5a:	f8d8 3000 	ldr.w	r3, [r8]
 1009c5e:	b95b      	cbnz	r3, 1009c78 <send_frag+0x110>
 1009c60:	4917      	ldr	r1, [pc, #92]	; (1009cc0 <send_frag+0x158>)
 1009c62:	4818      	ldr	r0, [pc, #96]	; (1009cc4 <send_frag+0x15c>)
 1009c64:	f240 2327 	movw	r3, #551	; 0x227
 1009c68:	4a17      	ldr	r2, [pc, #92]	; (1009cc8 <send_frag+0x160>)
 1009c6a:	f01a ffb4 	bl	1024bd6 <assert_print>
 1009c6e:	f240 2127 	movw	r1, #551	; 0x227
 1009c72:	4815      	ldr	r0, [pc, #84]	; (1009cc8 <send_frag+0x160>)
 1009c74:	f01a ffa8 	bl	1024bc8 <assert_post_action>
			(*pending_no_cb)--;
 1009c78:	3b01      	subs	r3, #1
 1009c7a:	f8c8 3000 	str.w	r3, [r8]
 1009c7e:	f38a 8811 	msr	BASEPRI, sl
 1009c82:	f3bf 8f6f 	isb	sy
 1009c86:	480b      	ldr	r0, [pc, #44]	; (1009cb4 <send_frag+0x14c>)
 1009c88:	f017 fd0a 	bl	10216a0 <z_impl_k_sem_give>
	if (always_consume) {
 1009c8c:	f1b9 0f00 	cmp.w	r9, #0
 1009c90:	d109      	bne.n	1009ca6 <send_frag+0x13e>
	return false;
 1009c92:	2000      	movs	r0, #0
}
 1009c94:	46bd      	mov	sp, r7
 1009c96:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1009c9a:	4806      	ldr	r0, [pc, #24]	; (1009cb4 <send_frag+0x14c>)
 1009c9c:	f017 fd00 	bl	10216a0 <z_impl_k_sem_give>
	if (tx) {
 1009ca0:	2d00      	cmp	r5, #0
 1009ca2:	d1c3      	bne.n	1009c2c <send_frag+0xc4>
 1009ca4:	e7f2      	b.n	1009c8c <send_frag+0x124>
		net_buf_unref(buf);
 1009ca6:	4630      	mov	r0, r6
 1009ca8:	f014 f99a 	bl	101dfe0 <net_buf_unref>
 1009cac:	e7f1      	b.n	1009c92 <send_frag+0x12a>
	return true;
 1009cae:	2001      	movs	r0, #1
 1009cb0:	e7f0      	b.n	1009c94 <send_frag+0x12c>
 1009cb2:	bf00      	nop
 1009cb4:	21000100 	.word	0x21000100
 1009cb8:	0102d0a5 	.word	0x0102d0a5
 1009cbc:	01029964 	.word	0x01029964
 1009cc0:	0102d8e8 	.word	0x0102d8e8
 1009cc4:	0102b695 	.word	0x0102b695
 1009cc8:	0102d89a 	.word	0x0102d89a

01009ccc <bt_conn_get_pkts>:
}
 1009ccc:	4800      	ldr	r0, [pc, #0]	; (1009cd0 <bt_conn_get_pkts+0x4>)
 1009cce:	4770      	bx	lr
 1009cd0:	21000100 	.word	0x21000100

01009cd4 <bt_conn_new>:
{
 1009cd4:	b538      	push	{r3, r4, r5, lr}
	for (i = 0; i < size; i++) {
 1009cd6:	2200      	movs	r2, #0
 1009cd8:	4604      	mov	r4, r0
 1009cda:	428a      	cmp	r2, r1
 1009cdc:	d102      	bne.n	1009ce4 <bt_conn_new+0x10>
		if (atomic_cas(&conns[i].ref, 0, 1)) {
 1009cde:	2400      	movs	r4, #0
}
 1009ce0:	4620      	mov	r0, r4
 1009ce2:	bd38      	pop	{r3, r4, r5, pc}
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 1009ce4:	2001      	movs	r0, #1
 1009ce6:	f104 03c4 	add.w	r3, r4, #196	; 0xc4
 1009cea:	e8d3 5fef 	ldaex	r5, [r3]
 1009cee:	2d00      	cmp	r5, #0
 1009cf0:	d104      	bne.n	1009cfc <bt_conn_new+0x28>
 1009cf2:	e8c3 0fec 	stlex	ip, r0, [r3]
 1009cf6:	f1bc 0f00 	cmp.w	ip, #0
 1009cfa:	d1f6      	bne.n	1009cea <bt_conn_new+0x16>
		if (atomic_cas(&conns[i].ref, 0, 1)) {
 1009cfc:	d002      	beq.n	1009d04 <bt_conn_new+0x30>
 1009cfe:	34c8      	adds	r4, #200	; 0xc8
	for (i = 0; i < size; i++) {
 1009d00:	4402      	add	r2, r0
 1009d02:	e7ea      	b.n	1009cda <bt_conn_new+0x6>
	if (!conn) {
 1009d04:	2c00      	cmp	r4, #0
 1009d06:	d0ea      	beq.n	1009cde <bt_conn_new+0xa>
	(void)memset(conn, 0, offsetof(struct bt_conn, ref));
 1009d08:	22c4      	movs	r2, #196	; 0xc4
 1009d0a:	2100      	movs	r1, #0
 1009d0c:	4620      	mov	r0, r4
 1009d0e:	f01c fe3c 	bl	102698a <memset>
	k_work_init_delayable(&conn->deferred_work, deferred_work);
 1009d12:	f104 0060 	add.w	r0, r4, #96	; 0x60
 1009d16:	4904      	ldr	r1, [pc, #16]	; (1009d28 <bt_conn_new+0x54>)
 1009d18:	f018 f8f8 	bl	1021f0c <k_work_init_delayable>
	k_work_init(&conn->tx_complete_work, tx_complete_work);
 1009d1c:	4903      	ldr	r1, [pc, #12]	; (1009d2c <bt_conn_new+0x58>)
 1009d1e:	f104 0028 	add.w	r0, r4, #40	; 0x28
 1009d22:	f017 ffa5 	bl	1021c70 <k_work_init>
	return conn;
 1009d26:	e7db      	b.n	1009ce0 <bt_conn_new+0xc>
 1009d28:	0100a801 	.word	0x0100a801
 1009d2c:	01027187 	.word	0x01027187

01009d30 <conn_cleanup>:
{
 1009d30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1009d34:	4604      	mov	r4, r0
		tx_data(buf)->tx = NULL;
 1009d36:	2700      	movs	r7, #0
	while ((buf = net_buf_get(&conn->tx_queue, K_NO_WAIT))) {
 1009d38:	f104 0638 	add.w	r6, r4, #56	; 0x38
 1009d3c:	2300      	movs	r3, #0
 1009d3e:	2200      	movs	r2, #0
 1009d40:	4630      	mov	r0, r6
 1009d42:	f01f f806 	bl	1028d52 <net_buf_get>
 1009d46:	4603      	mov	r3, r0
 1009d48:	b980      	cbnz	r0, 1009d6c <conn_cleanup+0x3c>
	__ASSERT(sys_slist_is_empty(&conn->tx_pending), "Pending TX packets");
 1009d4a:	6963      	ldr	r3, [r4, #20]
 1009d4c:	b1cb      	cbz	r3, 1009d82 <conn_cleanup+0x52>
 1009d4e:	4918      	ldr	r1, [pc, #96]	; (1009db0 <conn_cleanup+0x80>)
 1009d50:	f44f 732d 	mov.w	r3, #692	; 0x2b4
 1009d54:	4a17      	ldr	r2, [pc, #92]	; (1009db4 <conn_cleanup+0x84>)
 1009d56:	4818      	ldr	r0, [pc, #96]	; (1009db8 <conn_cleanup+0x88>)
 1009d58:	f01a ff3d 	bl	1024bd6 <assert_print>
 1009d5c:	4817      	ldr	r0, [pc, #92]	; (1009dbc <conn_cleanup+0x8c>)
 1009d5e:	f01a ff3a 	bl	1024bd6 <assert_print>
 1009d62:	f44f 712d 	mov.w	r1, #692	; 0x2b4
	__ASSERT_NO_MSG(conn->pending_no_cb == 0);
 1009d66:	4813      	ldr	r0, [pc, #76]	; (1009db4 <conn_cleanup+0x84>)
 1009d68:	f01a ff2e 	bl	1024bc8 <assert_post_action>
		struct bt_conn_tx *tx = tx_data(buf)->tx;
 1009d6c:	699d      	ldr	r5, [r3, #24]
		tx_data(buf)->tx = NULL;
 1009d6e:	619f      	str	r7, [r3, #24]
		net_buf_unref(buf);
 1009d70:	f014 f936 	bl	101dfe0 <net_buf_unref>
		if (tx) {
 1009d74:	2d00      	cmp	r5, #0
 1009d76:	d0e1      	beq.n	1009d3c <conn_cleanup+0xc>
			conn_tx_destroy(conn, tx);
 1009d78:	4629      	mov	r1, r5
 1009d7a:	4620      	mov	r0, r4
 1009d7c:	f7ff fece 	bl	1009b1c <conn_tx_destroy>
 1009d80:	e7da      	b.n	1009d38 <conn_cleanup+0x8>
	__ASSERT_NO_MSG(conn->pending_no_cb == 0);
 1009d82:	69e3      	ldr	r3, [r4, #28]
 1009d84:	b14b      	cbz	r3, 1009d9a <conn_cleanup+0x6a>
 1009d86:	490e      	ldr	r1, [pc, #56]	; (1009dc0 <conn_cleanup+0x90>)
 1009d88:	f240 23b5 	movw	r3, #693	; 0x2b5
 1009d8c:	4a09      	ldr	r2, [pc, #36]	; (1009db4 <conn_cleanup+0x84>)
 1009d8e:	480a      	ldr	r0, [pc, #40]	; (1009db8 <conn_cleanup+0x88>)
 1009d90:	f01a ff21 	bl	1024bd6 <assert_print>
 1009d94:	f240 21b5 	movw	r1, #693	; 0x2b5
 1009d98:	e7e5      	b.n	1009d66 <conn_cleanup+0x36>
	bt_conn_reset_rx_state(conn);
 1009d9a:	4620      	mov	r0, r4
 1009d9c:	f01d f9f6 	bl	102718c <bt_conn_reset_rx_state>
	k_work_reschedule(&conn->deferred_work, K_NO_WAIT);
 1009da0:	f104 0060 	add.w	r0, r4, #96	; 0x60
 1009da4:	2200      	movs	r2, #0
}
 1009da6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	k_work_reschedule(&conn->deferred_work, K_NO_WAIT);
 1009daa:	2300      	movs	r3, #0
 1009dac:	f018 b9ca 	b.w	1022144 <k_work_reschedule>
 1009db0:	0102d8fb 	.word	0x0102d8fb
 1009db4:	0102d89a 	.word	0x0102d89a
 1009db8:	0102b695 	.word	0x0102b695
 1009dbc:	0102d921 	.word	0x0102d921
 1009dc0:	0102d936 	.word	0x0102d936

01009dc4 <bt_conn_recv>:
{
 1009dc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1009dc8:	4616      	mov	r6, r2
 1009dca:	b086      	sub	sp, #24
 1009dcc:	af00      	add	r7, sp, #0
 1009dce:	4604      	mov	r4, r0
 1009dd0:	460d      	mov	r5, r1
	tx_notify(conn);
 1009dd2:	f7ff fe73 	bl	1009abc <tx_notify>
	switch (flags) {
 1009dd6:	2e01      	cmp	r6, #1
 1009dd8:	d030      	beq.n	1009e3c <bt_conn_recv+0x78>
 1009dda:	2e02      	cmp	r6, #2
 1009ddc:	d16a      	bne.n	1009eb4 <bt_conn_recv+0xf0>
		if (conn->rx) {
 1009dde:	6923      	ldr	r3, [r4, #16]
 1009de0:	b163      	cbz	r3, 1009dfc <bt_conn_recv+0x38>
			LOG_ERR("Unexpected first L2CAP frame");
 1009de2:	4b40      	ldr	r3, [pc, #256]	; (1009ee4 <bt_conn_recv+0x120>)
 1009de4:	4840      	ldr	r0, [pc, #256]	; (1009ee8 <bt_conn_recv+0x124>)
 1009de6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1009dea:	e9c7 6304 	strd	r6, r3, [r7, #16]
 1009dee:	f107 0210 	add.w	r2, r7, #16
 1009df2:	f01d f9c5 	bl	1027180 <z_log_msg_static_create.constprop.0>
			bt_conn_reset_rx_state(conn);
 1009df6:	4620      	mov	r0, r4
 1009df8:	f01d f9c8 	bl	102718c <bt_conn_reset_rx_state>
		conn->rx = buf;
 1009dfc:	6125      	str	r5, [r4, #16]
	if (conn->rx->len < sizeof(uint16_t)) {
 1009dfe:	6921      	ldr	r1, [r4, #16]
 1009e00:	8a08      	ldrh	r0, [r1, #16]
 1009e02:	2801      	cmp	r0, #1
 1009e04:	d930      	bls.n	1009e68 <bt_conn_recv+0xa4>
	acl_total_len = sys_get_le16(conn->rx->data) + sizeof(struct bt_l2cap_hdr);
 1009e06:	68cb      	ldr	r3, [r1, #12]
 1009e08:	881b      	ldrh	r3, [r3, #0]
 1009e0a:	3304      	adds	r3, #4
 1009e0c:	b29b      	uxth	r3, r3
	if (conn->rx->len < acl_total_len) {
 1009e0e:	4298      	cmp	r0, r3
 1009e10:	d32a      	bcc.n	1009e68 <bt_conn_recv+0xa4>
	if (conn->rx->len > acl_total_len) {
 1009e12:	d95f      	bls.n	1009ed4 <bt_conn_recv+0x110>
		LOG_ERR("ACL len mismatch (%u > %u)", conn->rx->len, acl_total_len);
 1009e14:	466d      	mov	r5, sp
 1009e16:	b088      	sub	sp, #32
 1009e18:	466a      	mov	r2, sp
 1009e1a:	61d3      	str	r3, [r2, #28]
 1009e1c:	2304      	movs	r3, #4
 1009e1e:	4933      	ldr	r1, [pc, #204]	; (1009eec <bt_conn_recv+0x128>)
 1009e20:	e9c2 1005 	strd	r1, r0, [r2, #20]
 1009e24:	f44f 5101 	mov.w	r1, #8256	; 0x2040
 1009e28:	482f      	ldr	r0, [pc, #188]	; (1009ee8 <bt_conn_recv+0x124>)
 1009e2a:	f842 3f10 	str.w	r3, [r2, #16]!
 1009e2e:	f01d f9a7 	bl	1027180 <z_log_msg_static_create.constprop.0>
		bt_conn_reset_rx_state(conn);
 1009e32:	4620      	mov	r0, r4
 1009e34:	46ad      	mov	sp, r5
 1009e36:	f01d f9a9 	bl	102718c <bt_conn_reset_rx_state>
		return;
 1009e3a:	e015      	b.n	1009e68 <bt_conn_recv+0xa4>
		if (!conn->rx) {
 1009e3c:	6920      	ldr	r0, [r4, #16]
 1009e3e:	b970      	cbnz	r0, 1009e5e <bt_conn_recv+0x9a>
			LOG_ERR("Unexpected L2CAP continuation");
 1009e40:	4b2b      	ldr	r3, [pc, #172]	; (1009ef0 <bt_conn_recv+0x12c>)
 1009e42:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1009e46:	617b      	str	r3, [r7, #20]
 1009e48:	2302      	movs	r3, #2
 1009e4a:	4827      	ldr	r0, [pc, #156]	; (1009ee8 <bt_conn_recv+0x124>)
 1009e4c:	613b      	str	r3, [r7, #16]
 1009e4e:	f107 0210 	add.w	r2, r7, #16
 1009e52:	f01d f995 	bl	1027180 <z_log_msg_static_create.constprop.0>
		bt_conn_reset_rx_state(conn);
 1009e56:	4620      	mov	r0, r4
 1009e58:	f01d f998 	bl	102718c <bt_conn_reset_rx_state>
 1009e5c:	e001      	b.n	1009e62 <bt_conn_recv+0x9e>
		if (!buf->len) {
 1009e5e:	8a2e      	ldrh	r6, [r5, #16]
 1009e60:	b936      	cbnz	r6, 1009e70 <bt_conn_recv+0xac>
		net_buf_unref(buf);
 1009e62:	4628      	mov	r0, r5
 1009e64:	f014 f8bc 	bl	101dfe0 <net_buf_unref>
}
 1009e68:	3718      	adds	r7, #24
 1009e6a:	46bd      	mov	sp, r7
 1009e6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 *
 * @return Number of bytes available at the end of the buffer.
 */
static inline size_t net_buf_tailroom(struct net_buf *buf)
{
	return net_buf_simple_tailroom(&buf->b);
 1009e70:	300c      	adds	r0, #12
 1009e72:	f01e ff85 	bl	1028d80 <net_buf_simple_tailroom>
		if (buf->len > net_buf_tailroom(conn->rx)) {
 1009e76:	4286      	cmp	r6, r0
 1009e78:	d912      	bls.n	1009ea0 <bt_conn_recv+0xdc>
			LOG_ERR("Not enough buffer space for L2CAP data");
 1009e7a:	4b1e      	ldr	r3, [pc, #120]	; (1009ef4 <bt_conn_recv+0x130>)
 1009e7c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1009e80:	617b      	str	r3, [r7, #20]
 1009e82:	2302      	movs	r3, #2
 1009e84:	4818      	ldr	r0, [pc, #96]	; (1009ee8 <bt_conn_recv+0x124>)
 1009e86:	613b      	str	r3, [r7, #16]
 1009e88:	f107 0210 	add.w	r2, r7, #16
 1009e8c:	f01d f978 	bl	1027180 <z_log_msg_static_create.constprop.0>
			bt_l2cap_recv(conn, conn->rx, false);
 1009e90:	2200      	movs	r2, #0
 1009e92:	4620      	mov	r0, r4
 1009e94:	6921      	ldr	r1, [r4, #16]
 1009e96:	f001 fb2b 	bl	100b4f0 <bt_l2cap_recv>
			conn->rx = NULL;
 1009e9a:	2300      	movs	r3, #0
 1009e9c:	6123      	str	r3, [r4, #16]
			net_buf_unref(buf);
 1009e9e:	e7e0      	b.n	1009e62 <bt_conn_recv+0x9e>
	return net_buf_simple_add_mem(&buf->b, mem, len);
 1009ea0:	6920      	ldr	r0, [r4, #16]
 1009ea2:	8a2a      	ldrh	r2, [r5, #16]
 1009ea4:	68e9      	ldr	r1, [r5, #12]
 1009ea6:	300c      	adds	r0, #12
 1009ea8:	f01e ff72 	bl	1028d90 <net_buf_simple_add_mem>
		net_buf_unref(buf);
 1009eac:	4628      	mov	r0, r5
 1009eae:	f014 f897 	bl	101dfe0 <net_buf_unref>
		break;
 1009eb2:	e7a4      	b.n	1009dfe <bt_conn_recv+0x3a>
		LOG_ERR("Unexpected ACL flags (0x%02x)", flags);
 1009eb4:	46e8      	mov	r8, sp
 1009eb6:	b088      	sub	sp, #32
 1009eb8:	466a      	mov	r2, sp
 1009eba:	4b0f      	ldr	r3, [pc, #60]	; (1009ef8 <bt_conn_recv+0x134>)
 1009ebc:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
	switch (flags) {
 1009ec0:	e9c2 3605 	strd	r3, r6, [r2, #20]
		LOG_ERR("Unexpected ACL flags (0x%02x)", flags);
 1009ec4:	2303      	movs	r3, #3
 1009ec6:	4808      	ldr	r0, [pc, #32]	; (1009ee8 <bt_conn_recv+0x124>)
 1009ec8:	f842 3f10 	str.w	r3, [r2, #16]!
 1009ecc:	f01d f958 	bl	1027180 <z_log_msg_static_create.constprop.0>
 1009ed0:	46c5      	mov	sp, r8
 1009ed2:	e7c0      	b.n	1009e56 <bt_conn_recv+0x92>
	conn->rx = NULL;
 1009ed4:	2300      	movs	r3, #0
	bt_l2cap_recv(conn, buf, true);
 1009ed6:	2201      	movs	r2, #1
 1009ed8:	4620      	mov	r0, r4
	conn->rx = NULL;
 1009eda:	6123      	str	r3, [r4, #16]
	bt_l2cap_recv(conn, buf, true);
 1009edc:	f001 fb08 	bl	100b4f0 <bt_l2cap_recv>
		__ASSERT(false, "Invalid connection type %u", conn->type);
 1009ee0:	e7c2      	b.n	1009e68 <bt_conn_recv+0xa4>
 1009ee2:	bf00      	nop
 1009ee4:	0102d94f 	.word	0x0102d94f
 1009ee8:	01029964 	.word	0x01029964
 1009eec:	0102d9cf 	.word	0x0102d9cf
 1009ef0:	0102d96c 	.word	0x0102d96c
 1009ef4:	0102d98a 	.word	0x0102d98a
 1009ef8:	0102d9b1 	.word	0x0102d9b1

01009efc <bt_conn_send_cb>:
{
 1009efc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1009f00:	4698      	mov	r8, r3
	if (conn->state != BT_CONN_CONNECTED) {
 1009f02:	7b43      	ldrb	r3, [r0, #13]
{
 1009f04:	4605      	mov	r5, r0
	if (conn->state != BT_CONN_CONNECTED) {
 1009f06:	2b07      	cmp	r3, #7
{
 1009f08:	460f      	mov	r7, r1
 1009f0a:	4616      	mov	r6, r2
 1009f0c:	b086      	sub	sp, #24
	if (conn->state != BT_CONN_CONNECTED) {
 1009f0e:	d00c      	beq.n	1009f2a <bt_conn_send_cb+0x2e>
		LOG_ERR("not connected!");
 1009f10:	4b28      	ldr	r3, [pc, #160]	; (1009fb4 <bt_conn_send_cb+0xb8>)
 1009f12:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1009f16:	9305      	str	r3, [sp, #20]
 1009f18:	2302      	movs	r3, #2
 1009f1a:	4827      	ldr	r0, [pc, #156]	; (1009fb8 <bt_conn_send_cb+0xbc>)
 1009f1c:	aa04      	add	r2, sp, #16
 1009f1e:	9304      	str	r3, [sp, #16]
 1009f20:	f01d f92e 	bl	1027180 <z_log_msg_static_create.constprop.0>
		return -ENOTCONN;
 1009f24:	f06f 007f 	mvn.w	r0, #127	; 0x7f
 1009f28:	e01d      	b.n	1009f66 <bt_conn_send_cb+0x6a>
	if (cb) {
 1009f2a:	2a00      	cmp	r2, #0
 1009f2c:	d040      	beq.n	1009fb0 <bt_conn_send_cb+0xb4>
	return z_impl_z_current_get();
 1009f2e:	f019 fa91 	bl	1023454 <z_impl_z_current_get>
	if (k_current_get() == &k_sys_work_q.thread) {
 1009f32:	4b22      	ldr	r3, [pc, #136]	; (1009fbc <bt_conn_send_cb+0xc0>)
 1009f34:	4283      	cmp	r3, r0
	return z_impl_k_queue_get(queue, timeout);
 1009f36:	4822      	ldr	r0, [pc, #136]	; (1009fc0 <bt_conn_send_cb+0xc4>)
 1009f38:	bf07      	ittee	eq
 1009f3a:	2200      	moveq	r2, #0
 1009f3c:	2300      	moveq	r3, #0
 1009f3e:	f04f 32ff 	movne.w	r2, #4294967295
 1009f42:	f04f 33ff 	movne.w	r3, #4294967295
 1009f46:	f017 fb41 	bl	10215cc <z_impl_k_queue_get>
 1009f4a:	4604      	mov	r4, r0
		if (!tx) {
 1009f4c:	b970      	cbnz	r0, 1009f6c <bt_conn_send_cb+0x70>
			LOG_ERR("Unable to allocate TX context");
 1009f4e:	4b1d      	ldr	r3, [pc, #116]	; (1009fc4 <bt_conn_send_cb+0xc8>)
 1009f50:	4819      	ldr	r0, [pc, #100]	; (1009fb8 <bt_conn_send_cb+0xbc>)
 1009f52:	9305      	str	r3, [sp, #20]
 1009f54:	2302      	movs	r3, #2
 1009f56:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1009f5a:	aa04      	add	r2, sp, #16
 1009f5c:	9304      	str	r3, [sp, #16]
 1009f5e:	f01d f90f 	bl	1027180 <z_log_msg_static_create.constprop.0>
			return -ENOBUFS;
 1009f62:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
 1009f66:	b006      	add	sp, #24
 1009f68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (conn->state != BT_CONN_CONNECTED) {
 1009f6c:	7b6b      	ldrb	r3, [r5, #13]
 1009f6e:	2b07      	cmp	r3, #7
 1009f70:	d012      	beq.n	1009f98 <bt_conn_send_cb+0x9c>
			LOG_WRN("Disconnected while allocating context");
 1009f72:	4b15      	ldr	r3, [pc, #84]	; (1009fc8 <bt_conn_send_cb+0xcc>)
 1009f74:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 1009f78:	9305      	str	r3, [sp, #20]
 1009f7a:	2302      	movs	r3, #2
 1009f7c:	480e      	ldr	r0, [pc, #56]	; (1009fb8 <bt_conn_send_cb+0xbc>)
 1009f7e:	aa04      	add	r2, sp, #16
 1009f80:	9304      	str	r3, [sp, #16]
 1009f82:	f01d f8fd 	bl	1027180 <z_log_msg_static_create.constprop.0>
	tx->cb = NULL;
 1009f86:	2300      	movs	r3, #0
	k_fifo_put(&free_tx, tx);
 1009f88:	4621      	mov	r1, r4
	tx->user_data = NULL;
 1009f8a:	e9c4 3301 	strd	r3, r3, [r4, #4]
	k_fifo_put(&free_tx, tx);
 1009f8e:	480c      	ldr	r0, [pc, #48]	; (1009fc0 <bt_conn_send_cb+0xc4>)
	tx->pending_no_cb = 0U;
 1009f90:	60e3      	str	r3, [r4, #12]
	k_fifo_put(&free_tx, tx);
 1009f92:	f01f f9ab 	bl	10292ec <k_queue_append>
}
 1009f96:	e7c5      	b.n	1009f24 <bt_conn_send_cb+0x28>
		tx->pending_no_cb = 0U;
 1009f98:	2300      	movs	r3, #0
		tx->user_data = user_data;
 1009f9a:	e9c0 6801 	strd	r6, r8, [r0, #4]
		tx->pending_no_cb = 0U;
 1009f9e:	60c3      	str	r3, [r0, #12]
	net_buf_put(&conn->tx_queue, buf);
 1009fa0:	f105 0038 	add.w	r0, r5, #56	; 0x38
 1009fa4:	4639      	mov	r1, r7
		tx_data(buf)->tx = tx;
 1009fa6:	61bc      	str	r4, [r7, #24]
	net_buf_put(&conn->tx_queue, buf);
 1009fa8:	f013 fff4 	bl	101df94 <net_buf_put>
	return 0;
 1009fac:	2000      	movs	r0, #0
 1009fae:	e7da      	b.n	1009f66 <bt_conn_send_cb+0x6a>
 1009fb0:	4614      	mov	r4, r2
 1009fb2:	e7f5      	b.n	1009fa0 <bt_conn_send_cb+0xa4>
 1009fb4:	0102d9ea 	.word	0x0102d9ea
 1009fb8:	01029964 	.word	0x01029964
 1009fbc:	21004510 	.word	0x21004510
 1009fc0:	21000d60 	.word	0x21000d60
 1009fc4:	0102d9f9 	.word	0x0102d9f9
 1009fc8:	0102da17 	.word	0x0102da17

01009fcc <bt_conn_prepare_events>:
{
 1009fcc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1009fd0:	4606      	mov	r6, r0
	z_impl_k_poll_signal_init(sig);
 1009fd2:	481c      	ldr	r0, [pc, #112]	; (100a044 <bt_conn_prepare_events+0x78>)
 1009fd4:	f01f fb32 	bl	102963c <z_impl_k_poll_signal_init>
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
 1009fd8:	2200      	movs	r2, #0
 1009fda:	2101      	movs	r1, #1
 1009fdc:	4630      	mov	r0, r6
 1009fde:	4b19      	ldr	r3, [pc, #100]	; (100a044 <bt_conn_prepare_events+0x78>)
 1009fe0:	f01a f8fa 	bl	10241d8 <k_poll_event_init>
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
 1009fe4:	2700      	movs	r7, #0
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
 1009fe6:	2501      	movs	r5, #1
		if (!conn_prepare_events(conn, &events[ev_count])) {
 1009fe8:	f04f 0914 	mov.w	r9, #20
 1009fec:	4c16      	ldr	r4, [pc, #88]	; (100a048 <bt_conn_prepare_events+0x7c>)
 1009fee:	fb09 6805 	mla	r8, r9, r5, r6
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1009ff2:	f104 03c4 	add.w	r3, r4, #196	; 0xc4
 1009ff6:	e8d3 3faf 	lda	r3, [r3]
	if (!atomic_get(&conn->ref)) {
 1009ffa:	b15b      	cbz	r3, 100a014 <bt_conn_prepare_events+0x48>
	if (conn->state == BT_CONN_DISCONNECTED &&
 1009ffc:	7b63      	ldrb	r3, [r4, #13]
 1009ffe:	b98b      	cbnz	r3, 100a024 <bt_conn_prepare_events+0x58>
 100a000:	f06f 0140 	mvn.w	r1, #64	; 0x40
 100a004:	1d20      	adds	r0, r4, #4
 100a006:	f01d f8b0 	bl	102716a <atomic_and>
 100a00a:	0643      	lsls	r3, r0, #25
 100a00c:	d50a      	bpl.n	100a024 <bt_conn_prepare_events+0x58>
		conn_cleanup(conn);
 100a00e:	4620      	mov	r0, r4
 100a010:	f7ff fe8e 	bl	1009d30 <conn_cleanup>
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
 100a014:	3701      	adds	r7, #1
 100a016:	2f08      	cmp	r7, #8
 100a018:	f104 04c8 	add.w	r4, r4, #200	; 0xc8
 100a01c:	d1e7      	bne.n	1009fee <bt_conn_prepare_events+0x22>
}
 100a01e:	4628      	mov	r0, r5
 100a020:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (conn->state != BT_CONN_CONNECTED) {
 100a024:	7b63      	ldrb	r3, [r4, #13]
 100a026:	2b07      	cmp	r3, #7
 100a028:	d1f4      	bne.n	100a014 <bt_conn_prepare_events+0x48>
	k_poll_event_init(&events[0],
 100a02a:	f104 0338 	add.w	r3, r4, #56	; 0x38
 100a02e:	2200      	movs	r2, #0
 100a030:	2104      	movs	r1, #4
 100a032:	4640      	mov	r0, r8
 100a034:	f01a f8d0 	bl	10241d8 <k_poll_event_init>
	events[0].tag = BT_EVENT_CONN_TX_QUEUE;
 100a038:	2301      	movs	r3, #1
 100a03a:	f888 300c 	strb.w	r3, [r8, #12]
			ev_count++;
 100a03e:	441d      	add	r5, r3
 100a040:	e7e8      	b.n	100a014 <bt_conn_prepare_events+0x48>
 100a042:	bf00      	nop
 100a044:	210003f0 	.word	0x210003f0
 100a048:	210015c8 	.word	0x210015c8

0100a04c <bt_conn_ref>:
{
 100a04c:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(conn);
 100a04e:	b180      	cbz	r0, 100a072 <bt_conn_ref+0x26>
		old = atomic_get(&conn->ref);
 100a050:	f100 02c4 	add.w	r2, r0, #196	; 0xc4
 100a054:	e8d2 3faf 	lda	r3, [r2]
		if (!old) {
 100a058:	b1bb      	cbz	r3, 100a08a <bt_conn_ref+0x3e>
	} while (!atomic_cas(&conn->ref, old, old + 1));
 100a05a:	1c59      	adds	r1, r3, #1
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 100a05c:	e8d2 4fef 	ldaex	r4, [r2]
 100a060:	429c      	cmp	r4, r3
 100a062:	d104      	bne.n	100a06e <bt_conn_ref+0x22>
 100a064:	e8c2 1fec 	stlex	ip, r1, [r2]
 100a068:	f1bc 0f00 	cmp.w	ip, #0
 100a06c:	d1f6      	bne.n	100a05c <bt_conn_ref+0x10>
 100a06e:	d1f1      	bne.n	100a054 <bt_conn_ref+0x8>
}
 100a070:	bd10      	pop	{r4, pc}
	__ASSERT_NO_MSG(conn);
 100a072:	4907      	ldr	r1, [pc, #28]	; (100a090 <bt_conn_ref+0x44>)
 100a074:	4807      	ldr	r0, [pc, #28]	; (100a094 <bt_conn_ref+0x48>)
 100a076:	f240 437c 	movw	r3, #1148	; 0x47c
 100a07a:	4a07      	ldr	r2, [pc, #28]	; (100a098 <bt_conn_ref+0x4c>)
 100a07c:	f01a fdab 	bl	1024bd6 <assert_print>
 100a080:	f240 417c 	movw	r1, #1148	; 0x47c
 100a084:	4804      	ldr	r0, [pc, #16]	; (100a098 <bt_conn_ref+0x4c>)
 100a086:	f01a fd9f 	bl	1024bc8 <assert_post_action>
			return NULL;
 100a08a:	4618      	mov	r0, r3
 100a08c:	e7f0      	b.n	100a070 <bt_conn_ref+0x24>
 100a08e:	bf00      	nop
 100a090:	0102dca4 	.word	0x0102dca4
 100a094:	0102b695 	.word	0x0102b695
 100a098:	0102d89a 	.word	0x0102d89a

0100a09c <bt_conn_unref>:
{
 100a09c:	b510      	push	{r4, lr}
	old = atomic_dec(&conn->ref);
 100a09e:	f100 03c4 	add.w	r3, r0, #196	; 0xc4
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 100a0a2:	e8d3 2fef 	ldaex	r2, [r3]
 100a0a6:	1e51      	subs	r1, r2, #1
 100a0a8:	e8c3 1fe4 	stlex	r4, r1, [r3]
 100a0ac:	2c00      	cmp	r4, #0
 100a0ae:	d1f8      	bne.n	100a0a2 <bt_conn_unref+0x6>
	__ASSERT(old > 0, "Conn reference counter is 0");
 100a0b0:	2a00      	cmp	r2, #0
 100a0b2:	dc0e      	bgt.n	100a0d2 <bt_conn_unref+0x36>
 100a0b4:	490d      	ldr	r1, [pc, #52]	; (100a0ec <bt_conn_unref+0x50>)
 100a0b6:	f44f 6393 	mov.w	r3, #1176	; 0x498
 100a0ba:	4a0d      	ldr	r2, [pc, #52]	; (100a0f0 <bt_conn_unref+0x54>)
 100a0bc:	480d      	ldr	r0, [pc, #52]	; (100a0f4 <bt_conn_unref+0x58>)
 100a0be:	f01a fd8a 	bl	1024bd6 <assert_print>
 100a0c2:	480d      	ldr	r0, [pc, #52]	; (100a0f8 <bt_conn_unref+0x5c>)
 100a0c4:	f01a fd87 	bl	1024bd6 <assert_print>
 100a0c8:	f44f 6193 	mov.w	r1, #1176	; 0x498
 100a0cc:	4808      	ldr	r0, [pc, #32]	; (100a0f0 <bt_conn_unref+0x54>)
 100a0ce:	f01a fd7b 	bl	1024bc8 <assert_post_action>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->type == BT_CONN_TYPE_LE &&
 100a0d2:	f240 1201 	movw	r2, #257	; 0x101
 100a0d6:	8841      	ldrh	r1, [r0, #2]
 100a0d8:	4291      	cmp	r1, r2
 100a0da:	d106      	bne.n	100a0ea <bt_conn_unref+0x4e>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 100a0dc:	e8d3 3faf 	lda	r3, [r3]
	    conn->role == BT_CONN_ROLE_PERIPHERAL && atomic_get(&conn->ref) == 0) {
 100a0e0:	b91b      	cbnz	r3, 100a0ea <bt_conn_unref+0x4e>
}
 100a0e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_le_adv_resume();
 100a0e6:	f7ff bb35 	b.w	1009754 <bt_le_adv_resume>
}
 100a0ea:	bd10      	pop	{r4, pc}
 100a0ec:	0102da3d 	.word	0x0102da3d
 100a0f0:	0102d89a 	.word	0x0102d89a
 100a0f4:	0102b695 	.word	0x0102b695
 100a0f8:	0102da45 	.word	0x0102da45

0100a0fc <bt_conn_lookup_handle>:
{
 100a0fc:	4602      	mov	r2, r0
	conn = conn_lookup_handle(acl_conns, ARRAY_SIZE(acl_conns), handle);
 100a0fe:	2108      	movs	r1, #8
 100a100:	4801      	ldr	r0, [pc, #4]	; (100a108 <bt_conn_lookup_handle+0xc>)
 100a102:	f01d b84c 	b.w	102719e <conn_lookup_handle>
 100a106:	bf00      	nop
 100a108:	210015c8 	.word	0x210015c8

0100a10c <bt_conn_set_state>:
{
 100a10c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (conn->state == state) {
 100a10e:	7b46      	ldrb	r6, [r0, #13]
{
 100a110:	4604      	mov	r4, r0
	if (conn->state == state) {
 100a112:	428e      	cmp	r6, r1
{
 100a114:	460d      	mov	r5, r1
 100a116:	af00      	add	r7, sp, #0
	if (conn->state == state) {
 100a118:	d119      	bne.n	100a14e <bt_conn_set_state+0x42>
	switch (state) {
 100a11a:	2e08      	cmp	r6, #8
 100a11c:	bf98      	it	ls
 100a11e:	4b6c      	ldrls	r3, [pc, #432]	; (100a2d0 <bt_conn_set_state+0x1c4>)
		LOG_WRN("no transition %s", state2str(state));
 100a120:	466c      	mov	r4, sp
 100a122:	b088      	sub	sp, #32
 100a124:	bf94      	ite	ls
 100a126:	f853 3026 	ldrls.w	r3, [r3, r6, lsl #2]
	if (conn->state == state) {
 100a12a:	4b6a      	ldrhi	r3, [pc, #424]	; (100a2d4 <bt_conn_set_state+0x1c8>)
		LOG_WRN("no transition %s", state2str(state));
 100a12c:	466a      	mov	r2, sp
 100a12e:	496a      	ldr	r1, [pc, #424]	; (100a2d8 <bt_conn_set_state+0x1cc>)
 100a130:	e9c2 1305 	strd	r1, r3, [r2, #20]
 100a134:	f44f 7300 	mov.w	r3, #512	; 0x200
 100a138:	f44f 51e4 	mov.w	r1, #7296	; 0x1c80
 100a13c:	8393      	strh	r3, [r2, #28]
 100a13e:	4b67      	ldr	r3, [pc, #412]	; (100a2dc <bt_conn_set_state+0x1d0>)
 100a140:	f842 3f10 	str.w	r3, [r2, #16]!
		LOG_WRN("no valid (%u) state was set", state);
 100a144:	4866      	ldr	r0, [pc, #408]	; (100a2e0 <bt_conn_set_state+0x1d4>)
 100a146:	f01d f81b 	bl	1027180 <z_log_msg_static_create.constprop.0>
 100a14a:	46a5      	mov	sp, r4
 100a14c:	e043      	b.n	100a1d6 <bt_conn_set_state+0xca>
	conn->state = state;
 100a14e:	7341      	strb	r1, [r0, #13]
	switch (old_state) {
 100a150:	b926      	cbnz	r6, 100a15c <bt_conn_set_state+0x50>
		if (conn->type != BT_CONN_TYPE_ISO) {
 100a152:	7883      	ldrb	r3, [r0, #2]
 100a154:	2b08      	cmp	r3, #8
 100a156:	d001      	beq.n	100a15c <bt_conn_set_state+0x50>
			bt_conn_ref(conn);
 100a158:	f7ff ff78 	bl	100a04c <bt_conn_ref>
	switch (conn->state) {
 100a15c:	7b63      	ldrb	r3, [r4, #13]
 100a15e:	2b08      	cmp	r3, #8
 100a160:	f200 80b0 	bhi.w	100a2c4 <bt_conn_set_state+0x1b8>
 100a164:	e8df f003 	tbb	[pc, r3]
 100a168:	37370539 	.word	0x37370539
 100a16c:	1c373737 	.word	0x1c373737
 100a170:	37          	.byte	0x37
 100a171:	00          	.byte	0x00
		tx->pending_no_cb = 0U;
 100a172:	2600      	movs	r6, #0
	z_impl_k_sem_give(sem);
 100a174:	4d5b      	ldr	r5, [pc, #364]	; (100a2e4 <bt_conn_set_state+0x1d8>)
	__asm__ volatile(
 100a176:	f04f 0220 	mov.w	r2, #32
 100a17a:	f3ef 8311 	mrs	r3, BASEPRI
 100a17e:	f382 8812 	msr	BASEPRI_MAX, r2
 100a182:	f3bf 8f6f 	isb	sy
		if (conn->pending_no_cb) {
 100a186:	69e2      	ldr	r2, [r4, #28]
 100a188:	2a00      	cmp	r2, #0
 100a18a:	d077      	beq.n	100a27c <bt_conn_set_state+0x170>
			conn->pending_no_cb--;
 100a18c:	3a01      	subs	r2, #1
 100a18e:	61e2      	str	r2, [r4, #28]
	__asm__ volatile(
 100a190:	f383 8811 	msr	BASEPRI, r3
 100a194:	f3bf 8f6f 	isb	sy
 100a198:	4628      	mov	r0, r5
 100a19a:	f017 fa81 	bl	10216a0 <z_impl_k_sem_give>
}
 100a19e:	e7ea      	b.n	100a176 <bt_conn_set_state+0x6a>
		if (conn->type == BT_CONN_TYPE_SCO) {
 100a1a0:	78a3      	ldrb	r3, [r4, #2]
 100a1a2:	2b04      	cmp	r3, #4
 100a1a4:	d017      	beq.n	100a1d6 <bt_conn_set_state+0xca>
	z_impl_k_queue_init(queue);
 100a1a6:	f104 0038 	add.w	r0, r4, #56	; 0x38
 100a1aa:	f01f f892 	bl	10292d2 <z_impl_k_queue_init>
	return z_impl_k_poll_signal_raise(sig, result);
 100a1ae:	2100      	movs	r1, #0
 100a1b0:	484d      	ldr	r0, [pc, #308]	; (100a2e8 <bt_conn_set_state+0x1dc>)
 100a1b2:	f01a f92f 	bl	1024414 <z_impl_k_poll_signal_raise>
	list->head = NULL;
 100a1b6:	2300      	movs	r3, #0
	list->tail = NULL;
 100a1b8:	e9c4 3315 	strd	r3, r3, [r4, #84]	; 0x54
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
 100a1bc:	78e3      	ldrb	r3, [r4, #3]
 100a1be:	2b01      	cmp	r3, #1
 100a1c0:	d109      	bne.n	100a1d6 <bt_conn_set_state+0xca>
			conn->le.conn_param_retry_countdown =
 100a1c2:	2303      	movs	r3, #3
			k_work_schedule(&conn->deferred_work,
 100a1c4:	f44f 3220 	mov.w	r2, #163840	; 0x28000
			conn->le.conn_param_retry_countdown =
 100a1c8:	f884 30b4 	strb.w	r3, [r4, #180]	; 0xb4
			k_work_schedule(&conn->deferred_work,
 100a1cc:	f104 0060 	add.w	r0, r4, #96	; 0x60
 100a1d0:	2300      	movs	r3, #0
 100a1d2:	f017 ff3d 	bl	1022050 <k_work_schedule>
}
 100a1d6:	46bd      	mov	sp, r7
 100a1d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (conn->type == BT_CONN_TYPE_SCO) {
 100a1da:	78a3      	ldrb	r3, [r4, #2]
 100a1dc:	2b04      	cmp	r3, #4
 100a1de:	d103      	bne.n	100a1e8 <bt_conn_set_state+0xdc>
			bt_conn_unref(conn);
 100a1e0:	4620      	mov	r0, r4
 100a1e2:	f7ff ff5b 	bl	100a09c <bt_conn_unref>
			break;
 100a1e6:	e7f6      	b.n	100a1d6 <bt_conn_set_state+0xca>
		switch (old_state) {
 100a1e8:	2e08      	cmp	r6, #8
 100a1ea:	d8f4      	bhi.n	100a1d6 <bt_conn_set_state+0xca>
 100a1ec:	a301      	add	r3, pc, #4	; (adr r3, 100a1f4 <bt_conn_set_state+0xe8>)
 100a1ee:	f853 f026 	ldr.w	pc, [r3, r6, lsl #2]
 100a1f2:	bf00      	nop
 100a1f4:	0100a265 	.word	0x0100a265
 100a1f8:	0100a219 	.word	0x0100a219
 100a1fc:	0100a257 	.word	0x0100a257
 100a200:	0100a1e1 	.word	0x0100a1e1
 100a204:	0100a1e1 	.word	0x0100a1e1
 100a208:	0100a257 	.word	0x0100a257
 100a20c:	0100a257 	.word	0x0100a257
 100a210:	0100a1d7 	.word	0x0100a1d7
 100a214:	0100a265 	.word	0x0100a265
			tx_notify(conn);
 100a218:	4620      	mov	r0, r4
 100a21a:	f7ff fc4f 	bl	1009abc <tx_notify>
			if ((conn->type == BT_CONN_TYPE_LE) &&
 100a21e:	78a3      	ldrb	r3, [r4, #2]
 100a220:	2b01      	cmp	r3, #1
 100a222:	d10a      	bne.n	100a23a <bt_conn_set_state+0x12e>
			    (k_work_delayable_busy_get(&conn->deferred_work) &
 100a224:	f104 0560 	add.w	r5, r4, #96	; 0x60
 100a228:	4628      	mov	r0, r5
 100a22a:	f01f f8e8 	bl	10293fe <k_work_delayable_busy_get>
			if ((conn->type == BT_CONN_TYPE_LE) &&
 100a22e:	f010 0f0c 	tst.w	r0, #12
 100a232:	d002      	beq.n	100a23a <bt_conn_set_state+0x12e>
				k_work_cancel_delayable(&conn->deferred_work);
 100a234:	4628      	mov	r0, r5
 100a236:	f017 ff8b 	bl	1022150 <k_work_cancel_delayable>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 100a23a:	3404      	adds	r4, #4
 100a23c:	e8d4 3fef 	ldaex	r3, [r4]
 100a240:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 100a244:	e8c4 3fe2 	stlex	r2, r3, [r4]
 100a248:	2a00      	cmp	r2, #0
 100a24a:	d1f7      	bne.n	100a23c <bt_conn_set_state+0x130>
 100a24c:	2100      	movs	r1, #0
 100a24e:	4826      	ldr	r0, [pc, #152]	; (100a2e8 <bt_conn_set_state+0x1dc>)
 100a250:	f01a f8e0 	bl	1024414 <z_impl_k_poll_signal_raise>
 100a254:	e7bf      	b.n	100a1d6 <bt_conn_set_state+0xca>
			if (conn->err) {
 100a256:	7b23      	ldrb	r3, [r4, #12]
 100a258:	2b00      	cmp	r3, #0
 100a25a:	d0c1      	beq.n	100a1e0 <bt_conn_set_state+0xd4>
				notify_connected(conn);
 100a25c:	4620      	mov	r0, r4
 100a25e:	f7ff fbf7 	bl	1009a50 <notify_connected>
 100a262:	e7bd      	b.n	100a1e0 <bt_conn_set_state+0xd4>
			LOG_WRN("Invalid (%u) old state", state);
 100a264:	466c      	mov	r4, sp
 100a266:	b088      	sub	sp, #32
 100a268:	466a      	mov	r2, sp
 100a26a:	4b20      	ldr	r3, [pc, #128]	; (100a2ec <bt_conn_set_state+0x1e0>)
		LOG_WRN("no valid (%u) state was set", state);
 100a26c:	e9c2 3505 	strd	r3, r5, [r2, #20]
 100a270:	2303      	movs	r3, #3
 100a272:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100a276:	f842 3f10 	str.w	r3, [r2, #16]!
 100a27a:	e763      	b.n	100a144 <bt_conn_set_state+0x38>
	return list->head;
 100a27c:	6961      	ldr	r1, [r4, #20]
Z_GENLIST_GET(slist, snode)
 100a27e:	b921      	cbnz	r1, 100a28a <bt_conn_set_state+0x17e>
 100a280:	f383 8811 	msr	BASEPRI, r3
 100a284:	f3bf 8f6f 	isb	sy
		if (!node) {
 100a288:	e7a5      	b.n	100a1d6 <bt_conn_set_state+0xca>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 100a28a:	69a0      	ldr	r0, [r4, #24]
	return node->next;
 100a28c:	680a      	ldr	r2, [r1, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 100a28e:	4281      	cmp	r1, r0
	list->tail = node;
 100a290:	bf08      	it	eq
 100a292:	61a2      	streq	r2, [r4, #24]
	list->head = node;
 100a294:	6162      	str	r2, [r4, #20]
 100a296:	f383 8811 	msr	BASEPRI, r3
 100a29a:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
 100a29e:	f04f 0220 	mov.w	r2, #32
 100a2a2:	f3ef 8311 	mrs	r3, BASEPRI
 100a2a6:	f382 8812 	msr	BASEPRI_MAX, r2
 100a2aa:	f3bf 8f6f 	isb	sy
		conn->pending_no_cb = tx->pending_no_cb;
 100a2ae:	68ca      	ldr	r2, [r1, #12]
 100a2b0:	61e2      	str	r2, [r4, #28]
		tx->pending_no_cb = 0U;
 100a2b2:	60ce      	str	r6, [r1, #12]
	__asm__ volatile(
 100a2b4:	f383 8811 	msr	BASEPRI, r3
 100a2b8:	f3bf 8f6f 	isb	sy
		conn_tx_destroy(conn, tx);
 100a2bc:	4620      	mov	r0, r4
 100a2be:	f7ff fc2d 	bl	1009b1c <conn_tx_destroy>
 100a2c2:	e769      	b.n	100a198 <bt_conn_set_state+0x8c>
		LOG_WRN("no valid (%u) state was set", state);
 100a2c4:	466c      	mov	r4, sp
 100a2c6:	b088      	sub	sp, #32
 100a2c8:	466a      	mov	r2, sp
 100a2ca:	4b09      	ldr	r3, [pc, #36]	; (100a2f0 <bt_conn_set_state+0x1e4>)
 100a2cc:	e7ce      	b.n	100a26c <bt_conn_set_state+0x160>
 100a2ce:	bf00      	nop
 100a2d0:	01029f68 	.word	0x01029f68
 100a2d4:	0102da63 	.word	0x0102da63
 100a2d8:	0102da6d 	.word	0x0102da6d
 100a2dc:	01000003 	.word	0x01000003
 100a2e0:	01029964 	.word	0x01029964
 100a2e4:	21000100 	.word	0x21000100
 100a2e8:	210003f0 	.word	0x210003f0
 100a2ec:	0102da7e 	.word	0x0102da7e
 100a2f0:	0102da95 	.word	0x0102da95

0100a2f4 <bt_conn_foreach>:
{
 100a2f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100a2f8:	4606      	mov	r6, r0
 100a2fa:	460f      	mov	r7, r1
 100a2fc:	4690      	mov	r8, r2
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
 100a2fe:	2500      	movs	r5, #0
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
 100a300:	f04f 09c8 	mov.w	r9, #200	; 0xc8
 100a304:	f8df a028 	ldr.w	sl, [pc, #40]	; 100a330 <bt_conn_foreach+0x3c>
 100a308:	fb09 a005 	mla	r0, r9, r5, sl
 100a30c:	f7ff fe9e 	bl	100a04c <bt_conn_ref>
		if (!conn) {
 100a310:	4604      	mov	r4, r0
 100a312:	b120      	cbz	r0, 100a31e <bt_conn_foreach+0x2a>
		if (!(conn->type & type)) {
 100a314:	7883      	ldrb	r3, [r0, #2]
 100a316:	4233      	tst	r3, r6
 100a318:	d106      	bne.n	100a328 <bt_conn_foreach+0x34>
		bt_conn_unref(conn);
 100a31a:	f7ff febf 	bl	100a09c <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
 100a31e:	3501      	adds	r5, #1
 100a320:	2d08      	cmp	r5, #8
 100a322:	d1f1      	bne.n	100a308 <bt_conn_foreach+0x14>
}
 100a324:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		func(conn, data);
 100a328:	4641      	mov	r1, r8
 100a32a:	47b8      	blx	r7
		bt_conn_unref(conn);
 100a32c:	4620      	mov	r0, r4
 100a32e:	e7f4      	b.n	100a31a <bt_conn_foreach+0x26>
 100a330:	210015c8 	.word	0x210015c8

0100a334 <bt_conn_index>:
{
 100a334:	b508      	push	{r3, lr}
		index = conn - acl_conns;
 100a336:	4b0d      	ldr	r3, [pc, #52]	; (100a36c <bt_conn_index+0x38>)
 100a338:	4a0d      	ldr	r2, [pc, #52]	; (100a370 <bt_conn_index+0x3c>)
 100a33a:	1ac3      	subs	r3, r0, r3
 100a33c:	10d8      	asrs	r0, r3, #3
		__ASSERT(index >= 0 && index < ARRAY_SIZE(acl_conns),
 100a33e:	f5b3 6faf 	cmp.w	r3, #1400	; 0x578
		index = conn - acl_conns;
 100a342:	fb02 f000 	mul.w	r0, r2, r0
		__ASSERT(index >= 0 && index < ARRAY_SIZE(acl_conns),
 100a346:	d90e      	bls.n	100a366 <bt_conn_index+0x32>
 100a348:	490a      	ldr	r1, [pc, #40]	; (100a374 <bt_conn_index+0x40>)
 100a34a:	f240 43b6 	movw	r3, #1206	; 0x4b6
 100a34e:	4a0a      	ldr	r2, [pc, #40]	; (100a378 <bt_conn_index+0x44>)
 100a350:	480a      	ldr	r0, [pc, #40]	; (100a37c <bt_conn_index+0x48>)
 100a352:	f01a fc40 	bl	1024bd6 <assert_print>
 100a356:	480a      	ldr	r0, [pc, #40]	; (100a380 <bt_conn_index+0x4c>)
 100a358:	f01a fc3d 	bl	1024bd6 <assert_print>
 100a35c:	f240 41b6 	movw	r1, #1206	; 0x4b6
 100a360:	4805      	ldr	r0, [pc, #20]	; (100a378 <bt_conn_index+0x44>)
 100a362:	f01a fc31 	bl	1024bc8 <assert_post_action>
}
 100a366:	b2c0      	uxtb	r0, r0
 100a368:	bd08      	pop	{r3, pc}
 100a36a:	bf00      	nop
 100a36c:	210015c8 	.word	0x210015c8
 100a370:	c28f5c29 	.word	0xc28f5c29
 100a374:	0102dab1 	.word	0x0102dab1
 100a378:	0102d89a 	.word	0x0102d89a
 100a37c:	0102b695 	.word	0x0102b695
 100a380:	0102db7a 	.word	0x0102db7a

0100a384 <bt_conn_create_pdu_timeout>:
{
 100a384:	b5f0      	push	{r4, r5, r6, r7, lr}
 100a386:	b087      	sub	sp, #28
 100a388:	4604      	mov	r4, r0
 100a38a:	460d      	mov	r5, r1
 100a38c:	4617      	mov	r7, r2
 100a38e:	461e      	mov	r6, r3
	__ASSERT_NO_MSG(!k_is_in_isr());
 100a390:	f01e ff77 	bl	1029282 <k_is_in_isr>
 100a394:	b158      	cbz	r0, 100a3ae <bt_conn_create_pdu_timeout+0x2a>
 100a396:	4914      	ldr	r1, [pc, #80]	; (100a3e8 <bt_conn_create_pdu_timeout+0x64>)
 100a398:	4814      	ldr	r0, [pc, #80]	; (100a3ec <bt_conn_create_pdu_timeout+0x68>)
 100a39a:	f240 43d2 	movw	r3, #1234	; 0x4d2
 100a39e:	4a14      	ldr	r2, [pc, #80]	; (100a3f0 <bt_conn_create_pdu_timeout+0x6c>)
 100a3a0:	f01a fc19 	bl	1024bd6 <assert_print>
 100a3a4:	f240 41d2 	movw	r1, #1234	; 0x4d2
 100a3a8:	4811      	ldr	r0, [pc, #68]	; (100a3f0 <bt_conn_create_pdu_timeout+0x6c>)
 100a3aa:	f01a fc0d 	bl	1024bc8 <assert_post_action>
	return net_buf_alloc_fixed(pool, timeout);
 100a3ae:	4911      	ldr	r1, [pc, #68]	; (100a3f4 <bt_conn_create_pdu_timeout+0x70>)
 100a3b0:	463a      	mov	r2, r7
 100a3b2:	2c00      	cmp	r4, #0
 100a3b4:	bf14      	ite	ne
 100a3b6:	4620      	movne	r0, r4
 100a3b8:	4608      	moveq	r0, r1
 100a3ba:	4633      	mov	r3, r6
 100a3bc:	f01e fcc4 	bl	1028d48 <net_buf_alloc_fixed>
	if (!buf) {
 100a3c0:	4604      	mov	r4, r0
 100a3c2:	b960      	cbnz	r0, 100a3de <bt_conn_create_pdu_timeout+0x5a>
		LOG_WRN("Unable to allocate buffer within timeout");
 100a3c4:	4b0c      	ldr	r3, [pc, #48]	; (100a3f8 <bt_conn_create_pdu_timeout+0x74>)
 100a3c6:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100a3ca:	9305      	str	r3, [sp, #20]
 100a3cc:	2302      	movs	r3, #2
 100a3ce:	480b      	ldr	r0, [pc, #44]	; (100a3fc <bt_conn_create_pdu_timeout+0x78>)
 100a3d0:	aa04      	add	r2, sp, #16
 100a3d2:	9304      	str	r3, [sp, #16]
 100a3d4:	f01c fed4 	bl	1027180 <z_log_msg_static_create.constprop.0>
}
 100a3d8:	4620      	mov	r0, r4
 100a3da:	b007      	add	sp, #28
 100a3dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	net_buf_simple_reserve(&buf->b, reserve);
 100a3de:	1d29      	adds	r1, r5, #4
 100a3e0:	300c      	adds	r0, #12
 100a3e2:	f013 fdb1 	bl	101df48 <net_buf_simple_reserve>
	return buf;
 100a3e6:	e7f7      	b.n	100a3d8 <bt_conn_create_pdu_timeout+0x54>
 100a3e8:	0102db94 	.word	0x0102db94
 100a3ec:	0102b695 	.word	0x0102b695
 100a3f0:	0102d89a 	.word	0x0102d89a
 100a3f4:	21000d7c 	.word	0x21000d7c
 100a3f8:	0102dba3 	.word	0x0102dba3
 100a3fc:	01029964 	.word	0x01029964

0100a400 <notify_le_param_updated>:
	}
}
#endif /* defined(CONFIG_BT_REMOTE_INFO) */

void notify_le_param_updated(struct bt_conn *conn)
{
 100a400:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100a402:	4604      	mov	r4, r0
	struct bt_conn_cb *cb;

	/* If new connection parameters meet requirement of pending
	 * parameters don't send peripheral conn param request anymore on timeout
	 */
	if (atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET) &&
 100a404:	3004      	adds	r0, #4
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 100a406:	e8d0 3faf 	lda	r3, [r0]
 100a40a:	059b      	lsls	r3, r3, #22
 100a40c:	d511      	bpl.n	100a432 <notify_le_param_updated+0x32>
	    conn->le.interval >= conn->le.interval_min &&
 100a40e:	f8b4 30a6 	ldrh.w	r3, [r4, #166]	; 0xa6
	if (atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET) &&
 100a412:	f8b4 20a8 	ldrh.w	r2, [r4, #168]	; 0xa8
 100a416:	429a      	cmp	r2, r3
 100a418:	d80b      	bhi.n	100a432 <notify_le_param_updated+0x32>
	    conn->le.interval >= conn->le.interval_min &&
 100a41a:	f8b4 20aa 	ldrh.w	r2, [r4, #170]	; 0xaa
 100a41e:	429a      	cmp	r2, r3
 100a420:	d307      	bcc.n	100a432 <notify_le_param_updated+0x32>
	    conn->le.interval <= conn->le.interval_max &&
	    conn->le.latency == conn->le.pending_latency &&
 100a422:	e9d4 232b 	ldrd	r2, r3, [r4, #172]	; 0xac
 100a426:	429a      	cmp	r2, r3
 100a428:	d103      	bne.n	100a432 <notify_le_param_updated+0x32>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 100a42a:	f46f 7100 	mvn.w	r1, #512	; 0x200
 100a42e:	f01c fe9c 	bl	102716a <atomic_and>
	    conn->le.timeout == conn->le.pending_timeout) {
		atomic_clear_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET);
	}

	for (cb = callback_list; cb; cb = cb->_next) {
 100a432:	4b18      	ldr	r3, [pc, #96]	; (100a494 <notify_le_param_updated+0x94>)
 100a434:	681d      	ldr	r5, [r3, #0]
 100a436:	b995      	cbnz	r5, 100a45e <notify_le_param_updated+0x5e>
					     conn->le.latency,
					     conn->le.timeout);
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 100a438:	4d17      	ldr	r5, [pc, #92]	; (100a498 <notify_le_param_updated+0x98>)
 100a43a:	4f18      	ldr	r7, [pc, #96]	; (100a49c <notify_le_param_updated+0x9c>)
 100a43c:	42bd      	cmp	r5, r7
 100a43e:	d926      	bls.n	100a48e <notify_le_param_updated+0x8e>
 100a440:	4917      	ldr	r1, [pc, #92]	; (100a4a0 <notify_le_param_updated+0xa0>)
 100a442:	f240 53a5 	movw	r3, #1445	; 0x5a5
 100a446:	4a17      	ldr	r2, [pc, #92]	; (100a4a4 <notify_le_param_updated+0xa4>)
 100a448:	4817      	ldr	r0, [pc, #92]	; (100a4a8 <notify_le_param_updated+0xa8>)
 100a44a:	f01a fbc4 	bl	1024bd6 <assert_print>
 100a44e:	4817      	ldr	r0, [pc, #92]	; (100a4ac <notify_le_param_updated+0xac>)
 100a450:	f01a fbc1 	bl	1024bd6 <assert_print>
 100a454:	f240 51a5 	movw	r1, #1445	; 0x5a5
 100a458:	4812      	ldr	r0, [pc, #72]	; (100a4a4 <notify_le_param_updated+0xa4>)
 100a45a:	f01a fbb5 	bl	1024bc8 <assert_post_action>
		if (cb->le_param_updated) {
 100a45e:	68ee      	ldr	r6, [r5, #12]
 100a460:	b13e      	cbz	r6, 100a472 <notify_le_param_updated+0x72>
			cb->le_param_updated(conn, conn->le.interval,
 100a462:	4620      	mov	r0, r4
 100a464:	f8b4 30ae 	ldrh.w	r3, [r4, #174]	; 0xae
 100a468:	f8b4 20ac 	ldrh.w	r2, [r4, #172]	; 0xac
 100a46c:	f8b4 10a6 	ldrh.w	r1, [r4, #166]	; 0xa6
 100a470:	47b0      	blx	r6
	for (cb = callback_list; cb; cb = cb->_next) {
 100a472:	69ad      	ldr	r5, [r5, #24]
 100a474:	e7df      	b.n	100a436 <notify_le_param_updated+0x36>
		if (cb->le_param_updated) {
 100a476:	68ee      	ldr	r6, [r5, #12]
 100a478:	b13e      	cbz	r6, 100a48a <notify_le_param_updated+0x8a>
			cb->le_param_updated(conn, conn->le.interval,
 100a47a:	4620      	mov	r0, r4
 100a47c:	f8b4 30ae 	ldrh.w	r3, [r4, #174]	; 0xae
 100a480:	f8b4 20ac 	ldrh.w	r2, [r4, #172]	; 0xac
 100a484:	f8b4 10a6 	ldrh.w	r1, [r4, #166]	; 0xa6
 100a488:	47b0      	blx	r6
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 100a48a:	351c      	adds	r5, #28
 100a48c:	e7d6      	b.n	100a43c <notify_le_param_updated+0x3c>
 100a48e:	d3f2      	bcc.n	100a476 <notify_le_param_updated+0x76>
					     conn->le.latency,
					     conn->le.timeout);
		}
	}
}
 100a490:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 100a492:	bf00      	nop
 100a494:	21004740 	.word	0x21004740
 100a498:	01029910 	.word	0x01029910
 100a49c:	0102992c 	.word	0x0102992c
 100a4a0:	0102d8ca 	.word	0x0102d8ca
 100a4a4:	0102d89a 	.word	0x0102d89a
 100a4a8:	0102b695 	.word	0x0102b695
 100a4ac:	0102bf04 	.word	0x0102bf04

0100a4b0 <le_param_req>:
	}
}
#endif

bool le_param_req(struct bt_conn *conn, struct bt_le_conn_param *param)
{
 100a4b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100a4b4:	4607      	mov	r7, r0
	struct bt_conn_cb *cb;

	if (!bt_le_conn_params_valid(param)) {
 100a4b6:	4608      	mov	r0, r1
{
 100a4b8:	460c      	mov	r4, r1
	if (!bt_le_conn_params_valid(param)) {
 100a4ba:	f01c fc2b 	bl	1026d14 <bt_le_conn_params_valid>
 100a4be:	4605      	mov	r5, r0
 100a4c0:	b918      	cbnz	r0, 100a4ca <le_param_req+0x1a>
		return false;
 100a4c2:	2500      	movs	r5, #0
		}
	}

	/* Default to accepting if there's no app callback */
	return true;
}
 100a4c4:	4628      	mov	r0, r5
 100a4c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (cb = callback_list; cb; cb = cb->_next) {
 100a4ca:	4b1b      	ldr	r3, [pc, #108]	; (100a538 <le_param_req+0x88>)
 100a4cc:	681e      	ldr	r6, [r3, #0]
 100a4ce:	b99e      	cbnz	r6, 100a4f8 <le_param_req+0x48>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 100a4d0:	4e1a      	ldr	r6, [pc, #104]	; (100a53c <le_param_req+0x8c>)
 100a4d2:	f8df 806c 	ldr.w	r8, [pc, #108]	; 100a540 <le_param_req+0x90>
 100a4d6:	4546      	cmp	r6, r8
 100a4d8:	d927      	bls.n	100a52a <le_param_req+0x7a>
 100a4da:	491a      	ldr	r1, [pc, #104]	; (100a544 <le_param_req+0x94>)
 100a4dc:	f240 53ed 	movw	r3, #1517	; 0x5ed
 100a4e0:	4a19      	ldr	r2, [pc, #100]	; (100a548 <le_param_req+0x98>)
 100a4e2:	481a      	ldr	r0, [pc, #104]	; (100a54c <le_param_req+0x9c>)
 100a4e4:	f01a fb77 	bl	1024bd6 <assert_print>
 100a4e8:	4819      	ldr	r0, [pc, #100]	; (100a550 <le_param_req+0xa0>)
 100a4ea:	f01a fb74 	bl	1024bd6 <assert_print>
 100a4ee:	f240 51ed 	movw	r1, #1517	; 0x5ed
 100a4f2:	4815      	ldr	r0, [pc, #84]	; (100a548 <le_param_req+0x98>)
 100a4f4:	f01a fb68 	bl	1024bc8 <assert_post_action>
		if (!cb->le_param_req) {
 100a4f8:	68b3      	ldr	r3, [r6, #8]
 100a4fa:	b90b      	cbnz	r3, 100a500 <le_param_req+0x50>
	for (cb = callback_list; cb; cb = cb->_next) {
 100a4fc:	69b6      	ldr	r6, [r6, #24]
 100a4fe:	e7e6      	b.n	100a4ce <le_param_req+0x1e>
		if (!cb->le_param_req(conn, param)) {
 100a500:	4621      	mov	r1, r4
 100a502:	4638      	mov	r0, r7
 100a504:	4798      	blx	r3
 100a506:	2800      	cmp	r0, #0
 100a508:	d0db      	beq.n	100a4c2 <le_param_req+0x12>
		if (!bt_le_conn_params_valid(param)) {
 100a50a:	4620      	mov	r0, r4
 100a50c:	f01c fc02 	bl	1026d14 <bt_le_conn_params_valid>
 100a510:	2800      	cmp	r0, #0
 100a512:	d1f3      	bne.n	100a4fc <le_param_req+0x4c>
 100a514:	e7d5      	b.n	100a4c2 <le_param_req+0x12>
		if (!cb->le_param_req(conn, param)) {
 100a516:	4621      	mov	r1, r4
 100a518:	4638      	mov	r0, r7
 100a51a:	4798      	blx	r3
 100a51c:	2800      	cmp	r0, #0
 100a51e:	d0d0      	beq.n	100a4c2 <le_param_req+0x12>
		if (!bt_le_conn_params_valid(param)) {
 100a520:	4620      	mov	r0, r4
 100a522:	f01c fbf7 	bl	1026d14 <bt_le_conn_params_valid>
 100a526:	b920      	cbnz	r0, 100a532 <le_param_req+0x82>
 100a528:	e7cb      	b.n	100a4c2 <le_param_req+0x12>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 100a52a:	d2cb      	bcs.n	100a4c4 <le_param_req+0x14>
		if (!cb->le_param_req) {
 100a52c:	68b3      	ldr	r3, [r6, #8]
 100a52e:	2b00      	cmp	r3, #0
 100a530:	d1f1      	bne.n	100a516 <le_param_req+0x66>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 100a532:	361c      	adds	r6, #28
 100a534:	e7cf      	b.n	100a4d6 <le_param_req+0x26>
 100a536:	bf00      	nop
 100a538:	21004740 	.word	0x21004740
 100a53c:	01029910 	.word	0x01029910
 100a540:	0102992c 	.word	0x0102992c
 100a544:	0102d8ca 	.word	0x0102d8ca
 100a548:	0102d89a 	.word	0x0102d89a
 100a54c:	0102b695 	.word	0x0102b695
 100a550:	0102bf04 	.word	0x0102bf04

0100a554 <bt_conn_identity_resolved>:

#endif /* CONFIG_BT_BREDR */

#if defined(CONFIG_BT_SMP)
void bt_conn_identity_resolved(struct bt_conn *conn)
{
 100a554:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const bt_addr_le_t *rpa;
	struct bt_conn_cb *cb;

	if (conn->role == BT_HCI_ROLE_CENTRAL) {
 100a558:	78c3      	ldrb	r3, [r0, #3]
{
 100a55a:	4604      	mov	r4, r0
	if (conn->role == BT_HCI_ROLE_CENTRAL) {
 100a55c:	b9db      	cbnz	r3, 100a596 <bt_conn_identity_resolved+0x42>
		rpa = &conn->le.resp_addr;
 100a55e:	f100 069e 	add.w	r6, r0, #158	; 0x9e
	} else {
		rpa = &conn->le.init_addr;
	}

	for (cb = callback_list; cb; cb = cb->_next) {
 100a562:	4b18      	ldr	r3, [pc, #96]	; (100a5c4 <bt_conn_identity_resolved+0x70>)
		if (cb->identity_resolved) {
			cb->identity_resolved(conn, rpa, &conn->le.dst);
 100a564:	f104 0790 	add.w	r7, r4, #144	; 0x90
	for (cb = callback_list; cb; cb = cb->_next) {
 100a568:	681d      	ldr	r5, [r3, #0]
 100a56a:	b9bd      	cbnz	r5, 100a59c <bt_conn_identity_resolved+0x48>
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 100a56c:	4d16      	ldr	r5, [pc, #88]	; (100a5c8 <bt_conn_identity_resolved+0x74>)
 100a56e:	4f17      	ldr	r7, [pc, #92]	; (100a5cc <bt_conn_identity_resolved+0x78>)
		if (cb->identity_resolved) {
			cb->identity_resolved(conn, rpa, &conn->le.dst);
 100a570:	f104 0890 	add.w	r8, r4, #144	; 0x90
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 100a574:	42bd      	cmp	r5, r7
 100a576:	d921      	bls.n	100a5bc <bt_conn_identity_resolved+0x68>
 100a578:	4915      	ldr	r1, [pc, #84]	; (100a5d0 <bt_conn_identity_resolved+0x7c>)
 100a57a:	f240 73bc 	movw	r3, #1980	; 0x7bc
 100a57e:	4a15      	ldr	r2, [pc, #84]	; (100a5d4 <bt_conn_identity_resolved+0x80>)
 100a580:	4815      	ldr	r0, [pc, #84]	; (100a5d8 <bt_conn_identity_resolved+0x84>)
 100a582:	f01a fb28 	bl	1024bd6 <assert_print>
 100a586:	4815      	ldr	r0, [pc, #84]	; (100a5dc <bt_conn_identity_resolved+0x88>)
 100a588:	f01a fb25 	bl	1024bd6 <assert_print>
 100a58c:	f240 71bc 	movw	r1, #1980	; 0x7bc
 100a590:	4810      	ldr	r0, [pc, #64]	; (100a5d4 <bt_conn_identity_resolved+0x80>)
 100a592:	f01a fb19 	bl	1024bc8 <assert_post_action>
		rpa = &conn->le.init_addr;
 100a596:	f100 0697 	add.w	r6, r0, #151	; 0x97
 100a59a:	e7e2      	b.n	100a562 <bt_conn_identity_resolved+0xe>
		if (cb->identity_resolved) {
 100a59c:	692b      	ldr	r3, [r5, #16]
 100a59e:	b11b      	cbz	r3, 100a5a8 <bt_conn_identity_resolved+0x54>
			cb->identity_resolved(conn, rpa, &conn->le.dst);
 100a5a0:	463a      	mov	r2, r7
 100a5a2:	4631      	mov	r1, r6
 100a5a4:	4620      	mov	r0, r4
 100a5a6:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
 100a5a8:	69ad      	ldr	r5, [r5, #24]
 100a5aa:	e7de      	b.n	100a56a <bt_conn_identity_resolved+0x16>
		if (cb->identity_resolved) {
 100a5ac:	692b      	ldr	r3, [r5, #16]
 100a5ae:	b11b      	cbz	r3, 100a5b8 <bt_conn_identity_resolved+0x64>
			cb->identity_resolved(conn, rpa, &conn->le.dst);
 100a5b0:	4642      	mov	r2, r8
 100a5b2:	4631      	mov	r1, r6
 100a5b4:	4620      	mov	r0, r4
 100a5b6:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 100a5b8:	351c      	adds	r5, #28
 100a5ba:	e7db      	b.n	100a574 <bt_conn_identity_resolved+0x20>
 100a5bc:	d3f6      	bcc.n	100a5ac <bt_conn_identity_resolved+0x58>
		}
	}
}
 100a5be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100a5c2:	bf00      	nop
 100a5c4:	21004740 	.word	0x21004740
 100a5c8:	01029910 	.word	0x01029910
 100a5cc:	0102992c 	.word	0x0102992c
 100a5d0:	0102d8ca 	.word	0x0102d8ca
 100a5d4:	0102d89a 	.word	0x0102d89a
 100a5d8:	0102b695 	.word	0x0102b695
 100a5dc:	0102bf04 	.word	0x0102bf04

0100a5e0 <bt_conn_security_changed>:
	conn->required_sec_level = conn->sec_level;
}

void bt_conn_security_changed(struct bt_conn *conn, uint8_t hci_err,
			      enum bt_security_err err)
{
 100a5e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	conn->required_sec_level = conn->sec_level;
 100a5e2:	7a43      	ldrb	r3, [r0, #9]
{
 100a5e4:	4604      	mov	r4, r0
	conn->required_sec_level = conn->sec_level;
 100a5e6:	7283      	strb	r3, [r0, #10]
{
 100a5e8:	4616      	mov	r6, r2
	struct bt_conn_cb *cb;

	reset_pairing(conn);
	bt_l2cap_security_changed(conn, hci_err);
 100a5ea:	f01d f890 	bl	102770e <bt_l2cap_security_changed>
	if (IS_ENABLED(CONFIG_BT_ISO_CENTRAL)) {
		bt_iso_security_changed(conn, hci_err);
	}

	for (cb = callback_list; cb; cb = cb->_next) {
 100a5ee:	4b14      	ldr	r3, [pc, #80]	; (100a640 <bt_conn_security_changed+0x60>)
 100a5f0:	681d      	ldr	r5, [r3, #0]
 100a5f2:	b995      	cbnz	r5, 100a61a <bt_conn_security_changed+0x3a>
		if (cb->security_changed) {
			cb->security_changed(conn, conn->sec_level, err);
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 100a5f4:	4d13      	ldr	r5, [pc, #76]	; (100a644 <bt_conn_security_changed+0x64>)
 100a5f6:	4f14      	ldr	r7, [pc, #80]	; (100a648 <bt_conn_security_changed+0x68>)
 100a5f8:	42bd      	cmp	r5, r7
 100a5fa:	d91e      	bls.n	100a63a <bt_conn_security_changed+0x5a>
 100a5fc:	4913      	ldr	r1, [pc, #76]	; (100a64c <bt_conn_security_changed+0x6c>)
 100a5fe:	f640 0328 	movw	r3, #2088	; 0x828
 100a602:	4a13      	ldr	r2, [pc, #76]	; (100a650 <bt_conn_security_changed+0x70>)
 100a604:	4813      	ldr	r0, [pc, #76]	; (100a654 <bt_conn_security_changed+0x74>)
 100a606:	f01a fae6 	bl	1024bd6 <assert_print>
 100a60a:	4813      	ldr	r0, [pc, #76]	; (100a658 <bt_conn_security_changed+0x78>)
 100a60c:	f01a fae3 	bl	1024bd6 <assert_print>
 100a610:	f640 0128 	movw	r1, #2088	; 0x828
 100a614:	480e      	ldr	r0, [pc, #56]	; (100a650 <bt_conn_security_changed+0x70>)
 100a616:	f01a fad7 	bl	1024bc8 <assert_post_action>
		if (cb->security_changed) {
 100a61a:	696b      	ldr	r3, [r5, #20]
 100a61c:	b11b      	cbz	r3, 100a626 <bt_conn_security_changed+0x46>
			cb->security_changed(conn, conn->sec_level, err);
 100a61e:	4632      	mov	r2, r6
 100a620:	4620      	mov	r0, r4
 100a622:	7a61      	ldrb	r1, [r4, #9]
 100a624:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
 100a626:	69ad      	ldr	r5, [r5, #24]
 100a628:	e7e3      	b.n	100a5f2 <bt_conn_security_changed+0x12>
		if (cb->security_changed) {
 100a62a:	696b      	ldr	r3, [r5, #20]
 100a62c:	b11b      	cbz	r3, 100a636 <bt_conn_security_changed+0x56>
			cb->security_changed(conn, conn->sec_level, err);
 100a62e:	4632      	mov	r2, r6
 100a630:	4620      	mov	r0, r4
 100a632:	7a61      	ldrb	r1, [r4, #9]
 100a634:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 100a636:	351c      	adds	r5, #28
 100a638:	e7de      	b.n	100a5f8 <bt_conn_security_changed+0x18>
 100a63a:	d3f6      	bcc.n	100a62a <bt_conn_security_changed+0x4a>
		}
#endif /* CONFIG_BT_BREDR */

	}
#endif
}
 100a63c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 100a63e:	bf00      	nop
 100a640:	21004740 	.word	0x21004740
 100a644:	01029910 	.word	0x01029910
 100a648:	0102992c 	.word	0x0102992c
 100a64c:	0102d8ca 	.word	0x0102d8ca
 100a650:	0102d89a 	.word	0x0102d89a
 100a654:	0102b695 	.word	0x0102b695
 100a658:	0102bf04 	.word	0x0102bf04

0100a65c <bt_conn_add_le>:

	return false;
}

struct bt_conn *bt_conn_add_le(uint8_t id, const bt_addr_le_t *peer)
{
 100a65c:	b570      	push	{r4, r5, r6, lr}
 100a65e:	4606      	mov	r6, r0
 100a660:	460d      	mov	r5, r1
	return bt_conn_new(acl_conns, ARRAY_SIZE(acl_conns));
 100a662:	480a      	ldr	r0, [pc, #40]	; (100a68c <bt_conn_add_le+0x30>)
 100a664:	2108      	movs	r1, #8
 100a666:	f7ff fb35 	bl	1009cd4 <bt_conn_new>
	struct bt_conn *conn = acl_conn_new();

	if (!conn) {
 100a66a:	4604      	mov	r4, r0
 100a66c:	b160      	cbz	r0, 100a688 <bt_conn_add_le+0x2c>
		return NULL;
	}

	conn->id = id;
 100a66e:	7206      	strb	r6, [r0, #8]
	memcpy(dst, src, sizeof(*dst));
 100a670:	2207      	movs	r2, #7
 100a672:	4629      	mov	r1, r5
 100a674:	3090      	adds	r0, #144	; 0x90
 100a676:	f01c f97d 	bl	1026974 <memcpy>
	bt_addr_le_copy(&conn->le.dst, peer);
#if defined(CONFIG_BT_SMP)
	conn->sec_level = BT_SECURITY_L1;
 100a67a:	2301      	movs	r3, #1
 100a67c:	7263      	strb	r3, [r4, #9]
	conn->required_sec_level = BT_SECURITY_L1;
 100a67e:	72a3      	strb	r3, [r4, #10]
#endif /* CONFIG_BT_SMP */
	conn->type = BT_CONN_TYPE_LE;
 100a680:	70a3      	strb	r3, [r4, #2]
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
 100a682:	4b03      	ldr	r3, [pc, #12]	; (100a690 <bt_conn_add_le+0x34>)
 100a684:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
	conn->le.interval_max = BT_GAP_INIT_CONN_INT_MAX;

	return conn;
}
 100a688:	4620      	mov	r0, r4
 100a68a:	bd70      	pop	{r4, r5, r6, pc}
 100a68c:	210015c8 	.word	0x210015c8
 100a690:	00280018 	.word	0x00280018

0100a694 <bt_conn_lookup_addr_le>:

	return bt_addr_le_eq(peer, &conn->le.init_addr);
}

struct bt_conn *bt_conn_lookup_addr_le(uint8_t id, const bt_addr_le_t *peer)
{
 100a694:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100a698:	4607      	mov	r7, r0
 100a69a:	4688      	mov	r8, r1
	int i;

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
 100a69c:	2500      	movs	r5, #0
 100a69e:	4e0e      	ldr	r6, [pc, #56]	; (100a6d8 <bt_conn_lookup_addr_le+0x44>)
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
 100a6a0:	4630      	mov	r0, r6
 100a6a2:	f7ff fcd3 	bl	100a04c <bt_conn_ref>

		if (!conn) {
 100a6a6:	4604      	mov	r4, r0
 100a6a8:	b120      	cbz	r0, 100a6b4 <bt_conn_lookup_addr_le+0x20>
			continue;
		}

		if (conn->type != BT_CONN_TYPE_LE) {
 100a6aa:	7883      	ldrb	r3, [r0, #2]
 100a6ac:	2b01      	cmp	r3, #1
 100a6ae:	d00a      	beq.n	100a6c6 <bt_conn_lookup_addr_le+0x32>
			bt_conn_unref(conn);
			continue;
		}

		if (!bt_conn_is_peer_addr_le(conn, id, peer)) {
			bt_conn_unref(conn);
 100a6b0:	f7ff fcf4 	bl	100a09c <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
 100a6b4:	3501      	adds	r5, #1
 100a6b6:	2d08      	cmp	r5, #8
 100a6b8:	f106 06c8 	add.w	r6, r6, #200	; 0xc8
 100a6bc:	d1f0      	bne.n	100a6a0 <bt_conn_lookup_addr_le+0xc>
		}

		return conn;
	}

	return NULL;
 100a6be:	2400      	movs	r4, #0
}
 100a6c0:	4620      	mov	r0, r4
 100a6c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!bt_conn_is_peer_addr_le(conn, id, peer)) {
 100a6c6:	4642      	mov	r2, r8
 100a6c8:	4639      	mov	r1, r7
 100a6ca:	f01c fde1 	bl	1027290 <bt_conn_is_peer_addr_le>
 100a6ce:	2800      	cmp	r0, #0
 100a6d0:	d1f6      	bne.n	100a6c0 <bt_conn_lookup_addr_le+0x2c>
			bt_conn_unref(conn);
 100a6d2:	4620      	mov	r0, r4
 100a6d4:	e7ec      	b.n	100a6b0 <bt_conn_lookup_addr_le+0x1c>
 100a6d6:	bf00      	nop
 100a6d8:	210015c8 	.word	0x210015c8

0100a6dc <bt_conn_exists_le>:
{
 100a6dc:	b5b0      	push	{r4, r5, r7, lr}
 100a6de:	af00      	add	r7, sp, #0
	struct bt_conn *conn = bt_conn_lookup_addr_le(id, peer);
 100a6e0:	f7ff ffd8 	bl	100a694 <bt_conn_lookup_addr_le>
	if (conn) {
 100a6e4:	4604      	mov	r4, r0
 100a6e6:	b1e8      	cbz	r0, 100a724 <bt_conn_exists_le+0x48>
		LOG_WRN("Found valid connection in %s state", state2str(conn->state));
 100a6e8:	7b43      	ldrb	r3, [r0, #13]
 100a6ea:	466d      	mov	r5, sp
 100a6ec:	2b08      	cmp	r3, #8
 100a6ee:	bf98      	it	ls
 100a6f0:	4a0d      	ldrls	r2, [pc, #52]	; (100a728 <bt_conn_exists_le+0x4c>)
 100a6f2:	b088      	sub	sp, #32
 100a6f4:	bf94      	ite	ls
 100a6f6:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
 100a6fa:	4b0c      	ldrhi	r3, [pc, #48]	; (100a72c <bt_conn_exists_le+0x50>)
 100a6fc:	466a      	mov	r2, sp
 100a6fe:	490c      	ldr	r1, [pc, #48]	; (100a730 <bt_conn_exists_le+0x54>)
 100a700:	480c      	ldr	r0, [pc, #48]	; (100a734 <bt_conn_exists_le+0x58>)
 100a702:	e9c2 1305 	strd	r1, r3, [r2, #20]
 100a706:	f44f 7300 	mov.w	r3, #512	; 0x200
 100a70a:	8393      	strh	r3, [r2, #28]
 100a70c:	4b0a      	ldr	r3, [pc, #40]	; (100a738 <bt_conn_exists_le+0x5c>)
 100a70e:	f44f 51e4 	mov.w	r1, #7296	; 0x1c80
 100a712:	f842 3f10 	str.w	r3, [r2, #16]!
 100a716:	f01c fd33 	bl	1027180 <z_log_msg_static_create.constprop.0>
		bt_conn_unref(conn);
 100a71a:	4620      	mov	r0, r4
 100a71c:	46ad      	mov	sp, r5
 100a71e:	f7ff fcbd 	bl	100a09c <bt_conn_unref>
		return true;
 100a722:	2001      	movs	r0, #1
}
 100a724:	46bd      	mov	sp, r7
 100a726:	bdb0      	pop	{r4, r5, r7, pc}
 100a728:	01029f68 	.word	0x01029f68
 100a72c:	0102da63 	.word	0x0102da63
 100a730:	0102dbcc 	.word	0x0102dbcc
 100a734:	01029964 	.word	0x01029964
 100a738:	01000003 	.word	0x01000003

0100a73c <bt_conn_lookup_state_le>:

struct bt_conn *bt_conn_lookup_state_le(uint8_t id, const bt_addr_le_t *peer,
					const bt_conn_state_t state)
{
 100a73c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100a740:	4606      	mov	r6, r0
 100a742:	460f      	mov	r7, r1
 100a744:	4690      	mov	r8, r2
	int i;

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
 100a746:	2500      	movs	r5, #0
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
 100a748:	f04f 09c8 	mov.w	r9, #200	; 0xc8
 100a74c:	f8df a044 	ldr.w	sl, [pc, #68]	; 100a794 <bt_conn_lookup_state_le+0x58>
 100a750:	fb09 a005 	mla	r0, r9, r5, sl
 100a754:	f7ff fc7a 	bl	100a04c <bt_conn_ref>

		if (!conn) {
 100a758:	4604      	mov	r4, r0
 100a75a:	b120      	cbz	r0, 100a766 <bt_conn_lookup_state_le+0x2a>
			continue;
		}

		if (conn->type != BT_CONN_TYPE_LE) {
 100a75c:	7883      	ldrb	r3, [r0, #2]
 100a75e:	2b01      	cmp	r3, #1
 100a760:	d006      	beq.n	100a770 <bt_conn_lookup_state_le+0x34>
			bt_conn_unref(conn);
			continue;
		}

		if (!(conn->state == state && conn->id == id)) {
			bt_conn_unref(conn);
 100a762:	f7ff fc9b 	bl	100a09c <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
 100a766:	3501      	adds	r5, #1
 100a768:	2d08      	cmp	r5, #8
 100a76a:	d1f1      	bne.n	100a750 <bt_conn_lookup_state_le+0x14>
		}

		return conn;
	}

	return NULL;
 100a76c:	2400      	movs	r4, #0
 100a76e:	e00d      	b.n	100a78c <bt_conn_lookup_state_le+0x50>
		if (peer && !bt_conn_is_peer_addr_le(conn, id, peer)) {
 100a770:	b137      	cbz	r7, 100a780 <bt_conn_lookup_state_le+0x44>
 100a772:	463a      	mov	r2, r7
 100a774:	4631      	mov	r1, r6
 100a776:	f01c fd8b 	bl	1027290 <bt_conn_is_peer_addr_le>
 100a77a:	b908      	cbnz	r0, 100a780 <bt_conn_lookup_state_le+0x44>
			bt_conn_unref(conn);
 100a77c:	4620      	mov	r0, r4
 100a77e:	e7f0      	b.n	100a762 <bt_conn_lookup_state_le+0x26>
		if (!(conn->state == state && conn->id == id)) {
 100a780:	7b63      	ldrb	r3, [r4, #13]
 100a782:	4543      	cmp	r3, r8
 100a784:	d1fa      	bne.n	100a77c <bt_conn_lookup_state_le+0x40>
 100a786:	7a23      	ldrb	r3, [r4, #8]
 100a788:	42b3      	cmp	r3, r6
 100a78a:	d1f7      	bne.n	100a77c <bt_conn_lookup_state_le+0x40>
}
 100a78c:	4620      	mov	r0, r4
 100a78e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 100a792:	bf00      	nop
 100a794:	210015c8 	.word	0x210015c8

0100a798 <send_conn_le_param_update>:
{
 100a798:	b538      	push	{r3, r4, r5, lr}
 100a79a:	4604      	mov	r4, r0
	if (!bt_le_conn_params_valid(param)) {
 100a79c:	4608      	mov	r0, r1
{
 100a79e:	460d      	mov	r5, r1
	if (!bt_le_conn_params_valid(param)) {
 100a7a0:	f01c fab8 	bl	1026d14 <bt_le_conn_params_valid>
 100a7a4:	b338      	cbz	r0, 100a7f6 <send_conn_le_param_update+0x5e>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
 100a7a6:	4b15      	ldr	r3, [pc, #84]	; (100a7fc <send_conn_le_param_update+0x64>)
 100a7a8:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
 100a7ac:	0799      	lsls	r1, r3, #30
 100a7ae:	d407      	bmi.n	100a7c0 <send_conn_le_param_update+0x28>
	     !atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_L2CAP)) ||
 100a7b0:	78e3      	ldrb	r3, [r4, #3]
 100a7b2:	b173      	cbz	r3, 100a7d2 <send_conn_le_param_update+0x3a>
	return bt_l2cap_update_conn_param(conn, param);
 100a7b4:	4629      	mov	r1, r5
 100a7b6:	4620      	mov	r0, r4
}
 100a7b8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_l2cap_update_conn_param(conn, param);
 100a7bc:	f01c bff6 	b.w	10277ac <bt_l2cap_update_conn_param>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
 100a7c0:	f894 30b5 	ldrb.w	r3, [r4, #181]	; 0xb5
 100a7c4:	079a      	lsls	r2, r3, #30
 100a7c6:	d5f3      	bpl.n	100a7b0 <send_conn_le_param_update+0x18>
 100a7c8:	1d23      	adds	r3, r4, #4
 100a7ca:	e8d3 3faf 	lda	r3, [r3]
	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
 100a7ce:	055b      	lsls	r3, r3, #21
 100a7d0:	d4ee      	bmi.n	100a7b0 <send_conn_le_param_update+0x18>
		rc = bt_conn_le_conn_update(conn, param);
 100a7d2:	4629      	mov	r1, r5
 100a7d4:	4620      	mov	r0, r4
 100a7d6:	f01c fd7d 	bl	10272d4 <bt_conn_le_conn_update>
		if (rc == 0) {
 100a7da:	b958      	cbnz	r0, 100a7f4 <send_conn_le_param_update+0x5c>
			conn->le.interval_min = param->interval_min;
 100a7dc:	882b      	ldrh	r3, [r5, #0]
 100a7de:	f8a4 30a8 	strh.w	r3, [r4, #168]	; 0xa8
			conn->le.interval_max = param->interval_max;
 100a7e2:	886b      	ldrh	r3, [r5, #2]
 100a7e4:	f8a4 30aa 	strh.w	r3, [r4, #170]	; 0xaa
			conn->le.pending_latency = param->latency;
 100a7e8:	88ab      	ldrh	r3, [r5, #4]
 100a7ea:	f8a4 30b0 	strh.w	r3, [r4, #176]	; 0xb0
			conn->le.pending_timeout = param->timeout;
 100a7ee:	88eb      	ldrh	r3, [r5, #6]
 100a7f0:	f8a4 30b2 	strh.w	r3, [r4, #178]	; 0xb2
}
 100a7f4:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
 100a7f6:	f06f 0015 	mvn.w	r0, #21
 100a7fa:	e7fb      	b.n	100a7f4 <send_conn_le_param_update+0x5c>
 100a7fc:	21000000 	.word	0x21000000

0100a800 <deferred_work>:
{
 100a800:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100a804:	b082      	sub	sp, #8
	if (conn->state == BT_CONN_DISCONNECTED) {
 100a806:	f810 3c53 	ldrb.w	r3, [r0, #-83]
{
 100a80a:	4604      	mov	r4, r0
 100a80c:	af00      	add	r7, sp, #0
	struct bt_conn *conn = CONTAINER_OF(dwork, struct bt_conn, deferred_work);
 100a80e:	f1a0 0660 	sub.w	r6, r0, #96	; 0x60
	if (conn->state == BT_CONN_DISCONNECTED) {
 100a812:	bb8b      	cbnz	r3, 100a878 <deferred_work+0x78>
		bt_l2cap_disconnected(conn);
 100a814:	4630      	mov	r0, r6
 100a816:	f01c fe86 	bl	1027526 <bt_l2cap_disconnected>
	for (cb = callback_list; cb; cb = cb->_next) {
 100a81a:	4b3d      	ldr	r3, [pc, #244]	; (100a910 <deferred_work+0x110>)
 100a81c:	681d      	ldr	r5, [r3, #0]
 100a81e:	b99d      	cbnz	r5, 100a848 <deferred_work+0x48>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 100a820:	4d3c      	ldr	r5, [pc, #240]	; (100a914 <deferred_work+0x114>)
 100a822:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 100a918 <deferred_work+0x118>
 100a826:	4545      	cmp	r5, r8
 100a828:	d91e      	bls.n	100a868 <deferred_work+0x68>
 100a82a:	493c      	ldr	r1, [pc, #240]	; (100a91c <deferred_work+0x11c>)
 100a82c:	f240 536c 	movw	r3, #1388	; 0x56c
 100a830:	4a3b      	ldr	r2, [pc, #236]	; (100a920 <deferred_work+0x120>)
 100a832:	483c      	ldr	r0, [pc, #240]	; (100a924 <deferred_work+0x124>)
 100a834:	f01a f9cf 	bl	1024bd6 <assert_print>
 100a838:	483b      	ldr	r0, [pc, #236]	; (100a928 <deferred_work+0x128>)
 100a83a:	f01a f9cc 	bl	1024bd6 <assert_print>
 100a83e:	f240 516c 	movw	r1, #1388	; 0x56c
 100a842:	4837      	ldr	r0, [pc, #220]	; (100a920 <deferred_work+0x120>)
 100a844:	f01a f9c0 	bl	1024bc8 <assert_post_action>
		if (cb->disconnected) {
 100a848:	686b      	ldr	r3, [r5, #4]
 100a84a:	b11b      	cbz	r3, 100a854 <deferred_work+0x54>
			cb->disconnected(conn, conn->err);
 100a84c:	4630      	mov	r0, r6
 100a84e:	f814 1c54 	ldrb.w	r1, [r4, #-84]
 100a852:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
 100a854:	69ad      	ldr	r5, [r5, #24]
 100a856:	e7e2      	b.n	100a81e <deferred_work+0x1e>
		if (cb->disconnected) {
 100a858:	686b      	ldr	r3, [r5, #4]
 100a85a:	b11b      	cbz	r3, 100a864 <deferred_work+0x64>
			cb->disconnected(conn, conn->err);
 100a85c:	4630      	mov	r0, r6
 100a85e:	f814 1c54 	ldrb.w	r1, [r4, #-84]
 100a862:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 100a864:	351c      	adds	r5, #28
 100a866:	e7de      	b.n	100a826 <deferred_work+0x26>
 100a868:	d3f6      	bcc.n	100a858 <deferred_work+0x58>
		bt_conn_unref(conn);
 100a86a:	4630      	mov	r0, r6
 100a86c:	f7ff fc16 	bl	100a09c <bt_conn_unref>
}
 100a870:	3708      	adds	r7, #8
 100a872:	46bd      	mov	sp, r7
 100a874:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (conn->type != BT_CONN_TYPE_LE) {
 100a878:	f810 3c5e 	ldrb.w	r3, [r0, #-94]
 100a87c:	2b01      	cmp	r3, #1
 100a87e:	d1f7      	bne.n	100a870 <deferred_work+0x70>
	if (atomic_test_and_clear_bit(conn->flags,
 100a880:	f1a0 055c 	sub.w	r5, r0, #92	; 0x5c
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 100a884:	f46f 7100 	mvn.w	r1, #512	; 0x200
 100a888:	4628      	mov	r0, r5
 100a88a:	f01c fc6e 	bl	102716a <atomic_and>
 100a88e:	0581      	lsls	r1, r0, #22
 100a890:	d526      	bpl.n	100a8e0 <deferred_work+0xe0>
		param = BT_LE_CONN_PARAM(conn->le.interval_min,
 100a892:	6ca3      	ldr	r3, [r4, #72]	; 0x48
		err = send_conn_le_param_update(conn, param);
 100a894:	4639      	mov	r1, r7
		param = BT_LE_CONN_PARAM(conn->le.interval_min,
 100a896:	603b      	str	r3, [r7, #0]
 100a898:	6d23      	ldr	r3, [r4, #80]	; 0x50
		err = send_conn_le_param_update(conn, param);
 100a89a:	4630      	mov	r0, r6
		param = BT_LE_CONN_PARAM(conn->le.interval_min,
 100a89c:	607b      	str	r3, [r7, #4]
		err = send_conn_le_param_update(conn, param);
 100a89e:	f7ff ff7b 	bl	100a798 <send_conn_le_param_update>
		if (!err) {
 100a8a2:	b968      	cbnz	r0, 100a8c0 <deferred_work+0xc0>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 100a8a4:	f46f 7180 	mvn.w	r1, #256	; 0x100
 100a8a8:	4628      	mov	r0, r5
 100a8aa:	f01c fc5e 	bl	102716a <atomic_and>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 100a8ae:	e8d5 3fef 	ldaex	r3, [r5]
 100a8b2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 100a8b6:	e8c5 3fe2 	stlex	r2, r3, [r5]
 100a8ba:	2a00      	cmp	r2, #0
 100a8bc:	d0d8      	beq.n	100a870 <deferred_work+0x70>
 100a8be:	e7f6      	b.n	100a8ae <deferred_work+0xae>
			LOG_WRN("Send LE param update failed (err %d)", err);
 100a8c0:	466c      	mov	r4, sp
 100a8c2:	b088      	sub	sp, #32
 100a8c4:	466a      	mov	r2, sp
 100a8c6:	4b19      	ldr	r3, [pc, #100]	; (100a92c <deferred_work+0x12c>)
			LOG_WRN("Send auto LE param update failed (err %d)",
 100a8c8:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100a8cc:	2303      	movs	r3, #3
 100a8ce:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100a8d2:	4817      	ldr	r0, [pc, #92]	; (100a930 <deferred_work+0x130>)
 100a8d4:	f842 3f10 	str.w	r3, [r2, #16]!
 100a8d8:	f01c fc52 	bl	1027180 <z_log_msg_static_create.constprop.0>
 100a8dc:	46a5      	mov	sp, r4
 100a8de:	e7e6      	b.n	100a8ae <deferred_work+0xae>
		param = BT_LE_CONN_PARAM(
 100a8e0:	f44f 1328 	mov.w	r3, #2752512	; 0x2a0000
 100a8e4:	4a13      	ldr	r2, [pc, #76]	; (100a934 <deferred_work+0x134>)
		err = send_conn_le_param_update(conn, param);
 100a8e6:	4639      	mov	r1, r7
 100a8e8:	4630      	mov	r0, r6
		param = BT_LE_CONN_PARAM(
 100a8ea:	e9c7 2300 	strd	r2, r3, [r7]
		err = send_conn_le_param_update(conn, param);
 100a8ee:	f7ff ff53 	bl	100a798 <send_conn_le_param_update>
		if (!err) {
 100a8f2:	b940      	cbnz	r0, 100a906 <deferred_work+0x106>
 100a8f4:	e8d5 3fef 	ldaex	r3, [r5]
 100a8f8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 100a8fc:	e8c5 3fe2 	stlex	r2, r3, [r5]
 100a900:	2a00      	cmp	r2, #0
 100a902:	d0d4      	beq.n	100a8ae <deferred_work+0xae>
 100a904:	e7f6      	b.n	100a8f4 <deferred_work+0xf4>
			LOG_WRN("Send auto LE param update failed (err %d)",
 100a906:	466c      	mov	r4, sp
 100a908:	b088      	sub	sp, #32
 100a90a:	466a      	mov	r2, sp
 100a90c:	4b0a      	ldr	r3, [pc, #40]	; (100a938 <deferred_work+0x138>)
 100a90e:	e7db      	b.n	100a8c8 <deferred_work+0xc8>
 100a910:	21004740 	.word	0x21004740
 100a914:	01029910 	.word	0x01029910
 100a918:	0102992c 	.word	0x0102992c
 100a91c:	0102d8ca 	.word	0x0102d8ca
 100a920:	0102d89a 	.word	0x0102d89a
 100a924:	0102b695 	.word	0x0102b695
 100a928:	0102bf04 	.word	0x0102bf04
 100a92c:	0102dbef 	.word	0x0102dbef
 100a930:	01029964 	.word	0x01029964
 100a934:	00090006 	.word	0x00090006
 100a938:	0102dc14 	.word	0x0102dc14

0100a93c <bt_conn_create_frag_timeout>:
						  k_timeout_t timeout,
						  const char *func, int line)
#else
struct net_buf *bt_conn_create_frag_timeout(size_t reserve, k_timeout_t timeout)
#endif
{
 100a93c:	4601      	mov	r1, r0

#if defined(CONFIG_NET_BUF_LOG)
	return bt_conn_create_pdu_timeout_debug(pool, reserve, timeout,
						func, line);
#else
	return bt_conn_create_pdu_timeout(pool, reserve, timeout);
 100a93e:	4801      	ldr	r0, [pc, #4]	; (100a944 <bt_conn_create_frag_timeout+0x8>)
 100a940:	f7ff bd20 	b.w	100a384 <bt_conn_create_pdu_timeout>
 100a944:	21000e18 	.word	0x21000e18

0100a948 <create_frag>:
{
 100a948:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100a94c:	4606      	mov	r6, r0
		frag = bt_conn_create_frag(0);
 100a94e:	f04f 33ff 	mov.w	r3, #4294967295
 100a952:	f04f 32ff 	mov.w	r2, #4294967295
 100a956:	2000      	movs	r0, #0
{
 100a958:	460c      	mov	r4, r1
		frag = bt_conn_create_frag(0);
 100a95a:	f7ff ffef 	bl	100a93c <bt_conn_create_frag_timeout>
	if (conn->state != BT_CONN_CONNECTED) {
 100a95e:	7b73      	ldrb	r3, [r6, #13]
		frag = bt_conn_create_frag(0);
 100a960:	4605      	mov	r5, r0
	if (conn->state != BT_CONN_CONNECTED) {
 100a962:	2b07      	cmp	r3, #7
 100a964:	f04f 0600 	mov.w	r6, #0
 100a968:	d005      	beq.n	100a976 <create_frag+0x2e>
		net_buf_unref(frag);
 100a96a:	f013 fb39 	bl	101dfe0 <net_buf_unref>
		return NULL;
 100a96e:	4635      	mov	r5, r6
}
 100a970:	4628      	mov	r0, r5
 100a972:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	tx_data(frag)->tx = NULL;
 100a976:	6186      	str	r6, [r0, #24]
	return net_buf_simple_tailroom(&buf->b);
 100a978:	f100 070c 	add.w	r7, r0, #12
	return bt_dev.le.acl_mtu;
 100a97c:	4e0c      	ldr	r6, [pc, #48]	; (100a9b0 <create_frag+0x68>)
 100a97e:	4638      	mov	r0, r7
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
 100a980:	f8b6 80fc 	ldrh.w	r8, [r6, #252]	; 0xfc
 100a984:	f01e f9fc 	bl	1028d80 <net_buf_simple_tailroom>
 100a988:	4580      	cmp	r8, r0
 100a98a:	d20c      	bcs.n	100a9a6 <create_frag+0x5e>
	return bt_dev.le.acl_mtu;
 100a98c:	f8b6 60fc 	ldrh.w	r6, [r6, #252]	; 0xfc
	return net_buf_simple_add_mem(&buf->b, mem, len);
 100a990:	f854 1f0c 	ldr.w	r1, [r4, #12]!
 100a994:	4632      	mov	r2, r6
 100a996:	4638      	mov	r0, r7
 100a998:	f01e f9fa 	bl	1028d90 <net_buf_simple_add_mem>
	return net_buf_simple_pull(&buf->b, len);
 100a99c:	4631      	mov	r1, r6
 100a99e:	4620      	mov	r0, r4
 100a9a0:	f013 fc3e 	bl	101e220 <net_buf_simple_pull>
 100a9a4:	e7e4      	b.n	100a970 <create_frag+0x28>
	return net_buf_simple_tailroom(&buf->b);
 100a9a6:	4638      	mov	r0, r7
 100a9a8:	f01e f9ea 	bl	1028d80 <net_buf_simple_tailroom>
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
 100a9ac:	b286      	uxth	r6, r0
 100a9ae:	e7ef      	b.n	100a990 <create_frag+0x48>
 100a9b0:	21000000 	.word	0x21000000

0100a9b4 <bt_conn_process_tx>:
{
 100a9b4:	b570      	push	{r4, r5, r6, lr}
	if (conn->state == BT_CONN_DISCONNECTED &&
 100a9b6:	7b43      	ldrb	r3, [r0, #13]
{
 100a9b8:	4604      	mov	r4, r0
	if (conn->state == BT_CONN_DISCONNECTED &&
 100a9ba:	b95b      	cbnz	r3, 100a9d4 <bt_conn_process_tx+0x20>
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 100a9bc:	f06f 0140 	mvn.w	r1, #64	; 0x40
 100a9c0:	3004      	adds	r0, #4
 100a9c2:	f01c fbd2 	bl	102716a <atomic_and>
 100a9c6:	0643      	lsls	r3, r0, #25
 100a9c8:	d504      	bpl.n	100a9d4 <bt_conn_process_tx+0x20>
		conn_cleanup(conn);
 100a9ca:	4620      	mov	r0, r4
}
 100a9cc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		conn_cleanup(conn);
 100a9d0:	f7ff b9ae 	b.w	1009d30 <conn_cleanup>
	buf = net_buf_get(&conn->tx_queue, K_NO_WAIT);
 100a9d4:	2200      	movs	r2, #0
 100a9d6:	2300      	movs	r3, #0
 100a9d8:	f104 0038 	add.w	r0, r4, #56	; 0x38
 100a9dc:	f01e f9b9 	bl	1028d52 <net_buf_get>
	BT_ASSERT(buf);
 100a9e0:	4605      	mov	r5, r0
 100a9e2:	b960      	cbnz	r0, 100a9fe <bt_conn_process_tx+0x4a>
 100a9e4:	f240 331a 	movw	r3, #794	; 0x31a
 100a9e8:	4a22      	ldr	r2, [pc, #136]	; (100aa74 <bt_conn_process_tx+0xc0>)
 100a9ea:	4923      	ldr	r1, [pc, #140]	; (100aa78 <bt_conn_process_tx+0xc4>)
 100a9ec:	4823      	ldr	r0, [pc, #140]	; (100aa7c <bt_conn_process_tx+0xc8>)
 100a9ee:	f01a f8f2 	bl	1024bd6 <assert_print>
 100a9f2:	4040      	eors	r0, r0
 100a9f4:	f380 8811 	msr	BASEPRI, r0
 100a9f8:	f04f 0003 	mov.w	r0, #3
 100a9fc:	df02      	svc	2
	return bt_dev.le.acl_mtu;
 100a9fe:	4e20      	ldr	r6, [pc, #128]	; (100aa80 <bt_conn_process_tx+0xcc>)
	if (buf->len <= conn_mtu(conn)) {
 100aa00:	8a2a      	ldrh	r2, [r5, #16]
 100aa02:	f8b6 30fc 	ldrh.w	r3, [r6, #252]	; 0xfc
 100aa06:	429a      	cmp	r2, r3
 100aa08:	d807      	bhi.n	100aa1a <bt_conn_process_tx+0x66>
		return send_frag(conn, buf, FRAG_SINGLE, false);
 100aa0a:	2300      	movs	r3, #0
 100aa0c:	2202      	movs	r2, #2
	return send_frag(conn, buf, FRAG_END, false);
 100aa0e:	4629      	mov	r1, r5
 100aa10:	4620      	mov	r0, r4
 100aa12:	f7ff f8a9 	bl	1009b68 <send_frag>
	if (!send_buf(conn, buf)) {
 100aa16:	b968      	cbnz	r0, 100aa34 <bt_conn_process_tx+0x80>
 100aa18:	e005      	b.n	100aa26 <bt_conn_process_tx+0x72>
	frag = create_frag(conn, buf);
 100aa1a:	4629      	mov	r1, r5
 100aa1c:	4620      	mov	r0, r4
 100aa1e:	f7ff ff93 	bl	100a948 <create_frag>
	if (!frag) {
 100aa22:	4601      	mov	r1, r0
 100aa24:	b938      	cbnz	r0, 100aa36 <bt_conn_process_tx+0x82>
		tx_data(buf)->tx = NULL;
 100aa26:	2300      	movs	r3, #0
		struct bt_conn_tx *tx = tx_data(buf)->tx;
 100aa28:	69ae      	ldr	r6, [r5, #24]
		net_buf_unref(buf);
 100aa2a:	4628      	mov	r0, r5
		tx_data(buf)->tx = NULL;
 100aa2c:	61ab      	str	r3, [r5, #24]
		net_buf_unref(buf);
 100aa2e:	f013 fad7 	bl	101dfe0 <net_buf_unref>
		if (tx) {
 100aa32:	b9ce      	cbnz	r6, 100aa68 <bt_conn_process_tx+0xb4>
}
 100aa34:	bd70      	pop	{r4, r5, r6, pc}
	if (!send_frag(conn, frag, FRAG_START, true)) {
 100aa36:	2301      	movs	r3, #1
 100aa38:	2200      	movs	r2, #0
		if (!send_frag(conn, frag, FRAG_CONT, true)) {
 100aa3a:	4620      	mov	r0, r4
 100aa3c:	f7ff f894 	bl	1009b68 <send_frag>
 100aa40:	2800      	cmp	r0, #0
 100aa42:	d0f0      	beq.n	100aa26 <bt_conn_process_tx+0x72>
	while (buf->len > conn_mtu(conn)) {
 100aa44:	8a2a      	ldrh	r2, [r5, #16]
 100aa46:	f8b6 30fc 	ldrh.w	r3, [r6, #252]	; 0xfc
 100aa4a:	429a      	cmp	r2, r3
 100aa4c:	d802      	bhi.n	100aa54 <bt_conn_process_tx+0xa0>
	return send_frag(conn, buf, FRAG_END, false);
 100aa4e:	2300      	movs	r3, #0
 100aa50:	2203      	movs	r2, #3
 100aa52:	e7dc      	b.n	100aa0e <bt_conn_process_tx+0x5a>
		frag = create_frag(conn, buf);
 100aa54:	4629      	mov	r1, r5
 100aa56:	4620      	mov	r0, r4
 100aa58:	f7ff ff76 	bl	100a948 <create_frag>
		if (!frag) {
 100aa5c:	4601      	mov	r1, r0
 100aa5e:	2800      	cmp	r0, #0
 100aa60:	d0e1      	beq.n	100aa26 <bt_conn_process_tx+0x72>
		if (!send_frag(conn, frag, FRAG_CONT, true)) {
 100aa62:	2301      	movs	r3, #1
 100aa64:	461a      	mov	r2, r3
 100aa66:	e7e8      	b.n	100aa3a <bt_conn_process_tx+0x86>
			conn_tx_destroy(conn, tx);
 100aa68:	4631      	mov	r1, r6
 100aa6a:	4620      	mov	r0, r4
}
 100aa6c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			conn_tx_destroy(conn, tx);
 100aa70:	f7ff b854 	b.w	1009b1c <conn_tx_destroy>
 100aa74:	0102d89a 	.word	0x0102d89a
 100aa78:	0102ef22 	.word	0x0102ef22
 100aa7c:	0102b695 	.word	0x0102b695
 100aa80:	21000000 	.word	0x21000000

0100aa84 <bt_conn_auth_cb_register>:
}

#if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_BREDR)
int bt_conn_auth_cb_register(const struct bt_conn_auth_cb *cb)
{
	if (!cb) {
 100aa84:	4b0b      	ldr	r3, [pc, #44]	; (100aab4 <bt_conn_auth_cb_register+0x30>)
 100aa86:	b158      	cbz	r0, 100aaa0 <bt_conn_auth_cb_register+0x1c>
		bt_auth = NULL;
		return 0;
	}

	if (bt_auth) {
 100aa88:	681a      	ldr	r2, [r3, #0]
 100aa8a:	b962      	cbnz	r2, 100aaa6 <bt_conn_auth_cb_register+0x22>
	}

	/* The cancel callback must always be provided if the app provides
	 * interactive callbacks.
	 */
	if (!cb->cancel &&
 100aa8c:	6902      	ldr	r2, [r0, #16]
 100aa8e:	b93a      	cbnz	r2, 100aaa0 <bt_conn_auth_cb_register+0x1c>
 100aa90:	6802      	ldr	r2, [r0, #0]
 100aa92:	b95a      	cbnz	r2, 100aaac <bt_conn_auth_cb_register+0x28>
	    (cb->passkey_display || cb->passkey_entry || cb->passkey_confirm ||
 100aa94:	6842      	ldr	r2, [r0, #4]
 100aa96:	b94a      	cbnz	r2, 100aaac <bt_conn_auth_cb_register+0x28>
 100aa98:	6882      	ldr	r2, [r0, #8]
 100aa9a:	b93a      	cbnz	r2, 100aaac <bt_conn_auth_cb_register+0x28>
 100aa9c:	6942      	ldr	r2, [r0, #20]
 100aa9e:	b92a      	cbnz	r2, 100aaac <bt_conn_auth_cb_register+0x28>
#endif
	     cb->pairing_confirm)) {
		return -EINVAL;
	}

	bt_auth = cb;
 100aaa0:	6018      	str	r0, [r3, #0]
		return 0;
 100aaa2:	2000      	movs	r0, #0
 100aaa4:	4770      	bx	lr
		return -EALREADY;
 100aaa6:	f06f 0077 	mvn.w	r0, #119	; 0x77
 100aaaa:	4770      	bx	lr
		return -EINVAL;
 100aaac:	f06f 0015 	mvn.w	r0, #21
	return 0;
}
 100aab0:	4770      	bx	lr
 100aab2:	bf00      	nop
 100aab4:	2100474c 	.word	0x2100474c

0100aab8 <bt_conn_auth_info_cb_register>:
}
#endif

int bt_conn_auth_info_cb_register(struct bt_conn_auth_info_cb *cb)
{
	CHECKIF(cb == NULL) {
 100aab8:	b168      	cbz	r0, 100aad6 <bt_conn_auth_info_cb_register+0x1e>
	parent->next = child;
 100aaba:	2300      	movs	r3, #0
 100aabc:	60c3      	str	r3, [r0, #12]
	return list->tail;
 100aabe:	4b07      	ldr	r3, [pc, #28]	; (100aadc <bt_conn_auth_info_cb_register+0x24>)
		return -EINVAL;
	}

	sys_slist_append(&bt_auth_info_cbs, &cb->node);
 100aac0:	f100 020c 	add.w	r2, r0, #12
 100aac4:	6859      	ldr	r1, [r3, #4]
Z_GENLIST_APPEND(slist, snode)
 100aac6:	b919      	cbnz	r1, 100aad0 <bt_conn_auth_info_cb_register+0x18>
	list->head = node;
 100aac8:	e9c3 2200 	strd	r2, r2, [r3]

	return 0;
 100aacc:	2000      	movs	r0, #0
 100aace:	4770      	bx	lr
	parent->next = child;
 100aad0:	600a      	str	r2, [r1, #0]
	list->tail = node;
 100aad2:	605a      	str	r2, [r3, #4]
}
 100aad4:	e7fa      	b.n	100aacc <bt_conn_auth_info_cb_register+0x14>
		return -EINVAL;
 100aad6:	f06f 0015 	mvn.w	r0, #21
}
 100aada:	4770      	bx	lr
 100aadc:	21004744 	.word	0x21004744

0100aae0 <bt_conn_init>:

	return bt_conn_ref(&acl_conns[index]);
}

int bt_conn_init(void)
{
 100aae0:	b510      	push	{r4, lr}
	z_impl_k_queue_init(queue);
 100aae2:	480c      	ldr	r0, [pc, #48]	; (100ab14 <bt_conn_init+0x34>)
 100aae4:	f01e fbf5 	bl	10292d2 <z_impl_k_queue_init>
	int err, i;

	k_fifo_init(&free_tx);
	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
		k_fifo_put(&free_tx, &conn_tx[i]);
 100aae8:	490b      	ldr	r1, [pc, #44]	; (100ab18 <bt_conn_init+0x38>)
 100aaea:	480a      	ldr	r0, [pc, #40]	; (100ab14 <bt_conn_init+0x34>)
 100aaec:	f01e fbfe 	bl	10292ec <k_queue_append>
 100aaf0:	490a      	ldr	r1, [pc, #40]	; (100ab1c <bt_conn_init+0x3c>)
 100aaf2:	4808      	ldr	r0, [pc, #32]	; (100ab14 <bt_conn_init+0x34>)
 100aaf4:	f01e fbfa 	bl	10292ec <k_queue_append>
 100aaf8:	4909      	ldr	r1, [pc, #36]	; (100ab20 <bt_conn_init+0x40>)
 100aafa:	4806      	ldr	r0, [pc, #24]	; (100ab14 <bt_conn_init+0x34>)
 100aafc:	f01e fbf6 	bl	10292ec <k_queue_append>
	}

	bt_att_init();
 100ab00:	f001 ffa0 	bl	100ca44 <bt_att_init>

	err = bt_smp_init();
 100ab04:	f005 fd80 	bl	1010608 <bt_smp_init>
	if (err) {
 100ab08:	4604      	mov	r4, r0
 100ab0a:	b908      	cbnz	r0, 100ab10 <bt_conn_init+0x30>
		return err;
	}

	bt_l2cap_init();
 100ab0c:	f000 fb86 	bl	100b21c <bt_l2cap_init>
			bt_conn_unref(conn);
		}
	}

	return 0;
}
 100ab10:	4620      	mov	r0, r4
 100ab12:	bd10      	pop	{r4, pc}
 100ab14:	21000d60 	.word	0x21000d60
 100ab18:	21004710 	.word	0x21004710
 100ab1c:	21004720 	.word	0x21004720
 100ab20:	21004730 	.word	0x21004730

0100ab24 <get_ident>:

static uint8_t get_ident(void)
{
	static uint8_t ident;

	ident++;
 100ab24:	4b04      	ldr	r3, [pc, #16]	; (100ab38 <get_ident+0x14>)
 100ab26:	7818      	ldrb	r0, [r3, #0]
 100ab28:	3001      	adds	r0, #1
 100ab2a:	b2c0      	uxtb	r0, r0
 100ab2c:	2801      	cmp	r0, #1
 100ab2e:	bf38      	it	cc
 100ab30:	2001      	movcc	r0, #1
 100ab32:	7018      	strb	r0, [r3, #0]
	if (!ident) {
		ident++;
	}

	return ident;
}
 100ab34:	4770      	bx	lr
 100ab36:	bf00      	nop
 100ab38:	21008345 	.word	0x21008345

0100ab3c <l2cap_create_le_sig_pdu.part.0>:
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
		bt_l2cap_chan_del(chan);
	}
}

static struct net_buf *l2cap_create_le_sig_pdu(struct net_buf *buf,
 100ab3c:	b580      	push	{r7, lr}
 100ab3e:	af00      	add	r7, sp, #0
	buf = bt_l2cap_create_pdu_timeout(pool, 0, L2CAP_RTX_TIMEOUT);
	if (!buf) {
		/* If it was not possible to allocate a buffer within the
		 * timeout return NULL.
		 */
		LOG_ERR("Unable to allocate buffer for op 0x%02x", code);
 100ab40:	b088      	sub	sp, #32
 100ab42:	466a      	mov	r2, sp
 100ab44:	4b06      	ldr	r3, [pc, #24]	; (100ab60 <l2cap_create_le_sig_pdu.part.0+0x24>)
 100ab46:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100ab4a:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100ab4e:	2303      	movs	r3, #3
 100ab50:	4804      	ldr	r0, [pc, #16]	; (100ab64 <l2cap_create_le_sig_pdu.part.0+0x28>)
 100ab52:	f842 3f10 	str.w	r3, [r2, #16]!
 100ab56:	f01c fc93 	bl	1027480 <z_log_msg_static_create.constprop.0>
	hdr->code = code;
	hdr->ident = ident;
	hdr->len = sys_cpu_to_le16(len);

	return buf;
}
 100ab5a:	2000      	movs	r0, #0
 100ab5c:	46bd      	mov	sp, r7
 100ab5e:	bd80      	pop	{r7, pc}
 100ab60:	0102dca9 	.word	0x0102dca9
 100ab64:	010299c4 	.word	0x010299c4

0100ab68 <l2cap_create_le_sig_pdu.constprop.0>:
		pool = &disc_pool;
 100ab68:	2806      	cmp	r0, #6
static struct net_buf *l2cap_create_le_sig_pdu(struct net_buf *buf,
 100ab6a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100ab6c:	4605      	mov	r5, r0
 100ab6e:	460f      	mov	r7, r1

struct net_buf *bt_l2cap_create_pdu_timeout(struct net_buf_pool *pool,
					    size_t reserve,
					    k_timeout_t timeout)
{
	return bt_conn_create_pdu_timeout(pool,
 100ab70:	480d      	ldr	r0, [pc, #52]	; (100aba8 <l2cap_create_le_sig_pdu.constprop.0+0x40>)
static struct net_buf *l2cap_create_le_sig_pdu(struct net_buf *buf,
 100ab72:	4616      	mov	r6, r2
	return bt_conn_create_pdu_timeout(pool,
 100ab74:	f04f 0300 	mov.w	r3, #0
 100ab78:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 100ab7c:	f04f 0104 	mov.w	r1, #4
 100ab80:	bf18      	it	ne
 100ab82:	2000      	movne	r0, #0
 100ab84:	f7ff fbfe 	bl	100a384 <bt_conn_create_pdu_timeout>
	if (!buf) {
 100ab88:	4604      	mov	r4, r0
 100ab8a:	b920      	cbnz	r0, 100ab96 <l2cap_create_le_sig_pdu.constprop.0+0x2e>
 100ab8c:	4628      	mov	r0, r5
}
 100ab8e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 100ab92:	f7ff bfd3 	b.w	100ab3c <l2cap_create_le_sig_pdu.part.0>
	return net_buf_simple_add(&buf->b, len);
 100ab96:	2104      	movs	r1, #4
 100ab98:	300c      	adds	r0, #12
 100ab9a:	f013 fb7d 	bl	101e298 <net_buf_simple_add>
	hdr->code = code;
 100ab9e:	7005      	strb	r5, [r0, #0]
	hdr->ident = ident;
 100aba0:	7047      	strb	r7, [r0, #1]
	hdr->len = sys_cpu_to_le16(len);
 100aba2:	8046      	strh	r6, [r0, #2]
}
 100aba4:	4620      	mov	r0, r4
 100aba6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 100aba8:	21000db0 	.word	0x21000db0

0100abac <l2cap_accept.part.0>:
	 */
	(void)k_work_cancel_delayable(&le_chan->rtx_work);
#endif /* CONFIG_BT_L2CAP_DYNAMIC_CHANNEL */
}

static int l2cap_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
 100abac:	b580      	push	{r7, lr}
 100abae:	af00      	add	r7, sp, #0
		*chan = &l2cap->chan.chan;

		return 0;
	}

	LOG_ERR("No available L2CAP context for conn %p", conn);
 100abb0:	b088      	sub	sp, #32
 100abb2:	466a      	mov	r2, sp
 100abb4:	4b07      	ldr	r3, [pc, #28]	; (100abd4 <l2cap_accept.part.0+0x28>)
 100abb6:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100abba:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100abbe:	2303      	movs	r3, #3
 100abc0:	4805      	ldr	r0, [pc, #20]	; (100abd8 <l2cap_accept.part.0+0x2c>)
 100abc2:	f842 3f10 	str.w	r3, [r2, #16]!
 100abc6:	f01c fc5b 	bl	1027480 <z_log_msg_static_create.constprop.0>

	return -ENOMEM;
}
 100abca:	f06f 000b 	mvn.w	r0, #11
 100abce:	46bd      	mov	sp, r7
 100abd0:	bd80      	pop	{r7, pc}
 100abd2:	bf00      	nop
 100abd4:	0102dcd1 	.word	0x0102dcd1
 100abd8:	010299c4 	.word	0x010299c4

0100abdc <l2cap_accept>:
{
 100abdc:	b470      	push	{r4, r5, r6}
	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
 100abde:	2300      	movs	r3, #0
 100abe0:	26f8      	movs	r6, #248	; 0xf8
		if (l2cap->chan.chan.conn) {
 100abe2:	4d09      	ldr	r5, [pc, #36]	; (100ac08 <l2cap_accept+0x2c>)
 100abe4:	fb06 f203 	mul.w	r2, r6, r3
 100abe8:	1954      	adds	r4, r2, r5
 100abea:	58aa      	ldr	r2, [r5, r2]
 100abec:	b12a      	cbz	r2, 100abfa <l2cap_accept+0x1e>
	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
 100abee:	3301      	adds	r3, #1
 100abf0:	2b08      	cmp	r3, #8
 100abf2:	d1f7      	bne.n	100abe4 <l2cap_accept+0x8>
}
 100abf4:	bc70      	pop	{r4, r5, r6}
 100abf6:	f7ff bfd9 	b.w	100abac <l2cap_accept.part.0>
		l2cap->chan.chan.ops = &ops;
 100abfa:	4b04      	ldr	r3, [pc, #16]	; (100ac0c <l2cap_accept+0x30>)
}
 100abfc:	4610      	mov	r0, r2
		l2cap->chan.chan.ops = &ops;
 100abfe:	6063      	str	r3, [r4, #4]
		*chan = &l2cap->chan.chan;
 100ac00:	600c      	str	r4, [r1, #0]
}
 100ac02:	bc70      	pop	{r4, r5, r6}
 100ac04:	4770      	bx	lr
 100ac06:	bf00      	nop
 100ac08:	21001c08 	.word	0x21001c08
 100ac0c:	01029fac 	.word	0x01029fac

0100ac10 <l2cap_chan_rx_init>:
{
 100ac10:	b510      	push	{r4, lr}
	if (!chan->rx.mtu) {
 100ac12:	8ac3      	ldrh	r3, [r0, #22]
{
 100ac14:	4604      	mov	r4, r0
 100ac16:	b086      	sub	sp, #24
	if (!chan->rx.mtu) {
 100ac18:	b913      	cbnz	r3, 100ac20 <l2cap_chan_rx_init+0x10>
		chan->rx.mtu = BT_L2CAP_SDU_RX_MTU;
 100ac1a:	f44f 73f8 	mov.w	r3, #496	; 0x1f0
 100ac1e:	82c3      	strh	r3, [r0, #22]
	chan->rx.mps = MIN(chan->rx.mtu + BT_L2CAP_SDU_HDR_SIZE,
 100ac20:	8ae2      	ldrh	r2, [r4, #22]
	if (!chan->chan.ops->alloc_buf &&
 100ac22:	6861      	ldr	r1, [r4, #4]
	chan->rx.mps = MIN(chan->rx.mtu + BT_L2CAP_SDU_HDR_SIZE,
 100ac24:	f5b2 7ff8 	cmp.w	r2, #496	; 0x1f0
 100ac28:	4613      	mov	r3, r2
 100ac2a:	bf28      	it	cs
 100ac2c:	f44f 73f8 	movcs.w	r3, #496	; 0x1f0
 100ac30:	3302      	adds	r3, #2
 100ac32:	b29b      	uxth	r3, r3
 100ac34:	8323      	strh	r3, [r4, #24]
	if (!chan->chan.ops->alloc_buf &&
 100ac36:	6909      	ldr	r1, [r1, #16]
 100ac38:	b979      	cbnz	r1, 100ac5a <l2cap_chan_rx_init+0x4a>
	    (chan->rx.mps < chan->rx.mtu + BT_L2CAP_SDU_HDR_SIZE)) {
 100ac3a:	3201      	adds	r2, #1
	if (!chan->chan.ops->alloc_buf &&
 100ac3c:	429a      	cmp	r2, r3
 100ac3e:	db0c      	blt.n	100ac5a <l2cap_chan_rx_init+0x4a>
		LOG_WRN("Segmentation disabled but MTU > MPS, truncating MTU");
 100ac40:	4b12      	ldr	r3, [pc, #72]	; (100ac8c <l2cap_chan_rx_init+0x7c>)
 100ac42:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100ac46:	9305      	str	r3, [sp, #20]
 100ac48:	2302      	movs	r3, #2
 100ac4a:	4811      	ldr	r0, [pc, #68]	; (100ac90 <l2cap_chan_rx_init+0x80>)
 100ac4c:	aa04      	add	r2, sp, #16
 100ac4e:	9304      	str	r3, [sp, #16]
 100ac50:	f01c fc16 	bl	1027480 <z_log_msg_static_create.constprop.0>
		chan->rx.mtu = chan->rx.mps - BT_L2CAP_SDU_HDR_SIZE;
 100ac54:	8b23      	ldrh	r3, [r4, #24]
 100ac56:	3b02      	subs	r3, #2
 100ac58:	82e3      	strh	r3, [r4, #22]
	if (!chan->rx.init_credits) {
 100ac5a:	8b63      	ldrh	r3, [r4, #26]
 100ac5c:	b953      	cbnz	r3, 100ac74 <l2cap_chan_rx_init+0x64>
		if (chan->chan.ops->alloc_buf) {
 100ac5e:	6863      	ldr	r3, [r4, #4]
 100ac60:	691b      	ldr	r3, [r3, #16]
 100ac62:	b18b      	cbz	r3, 100ac88 <l2cap_chan_rx_init+0x78>
				ceiling_fraction(chan->rx.mtu,
 100ac64:	f44f 72f9 	mov.w	r2, #498	; 0x1f2
 100ac68:	8ae3      	ldrh	r3, [r4, #22]
 100ac6a:	f203 13f1 	addw	r3, r3, #497	; 0x1f1
 100ac6e:	fbb3 f3f2 	udiv	r3, r3, r2
			chan->rx.init_credits = L2CAP_LE_MAX_CREDITS;
 100ac72:	8363      	strh	r3, [r4, #26]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 100ac74:	2300      	movs	r3, #0
 100ac76:	341c      	adds	r4, #28
 100ac78:	e8d4 2fef 	ldaex	r2, [r4]
 100ac7c:	e8c4 3fe1 	stlex	r1, r3, [r4]
 100ac80:	2900      	cmp	r1, #0
 100ac82:	d1f9      	bne.n	100ac78 <l2cap_chan_rx_init+0x68>
}
 100ac84:	b006      	add	sp, #24
 100ac86:	bd10      	pop	{r4, pc}
			chan->rx.init_credits = L2CAP_LE_MAX_CREDITS;
 100ac88:	2302      	movs	r3, #2
 100ac8a:	e7f2      	b.n	100ac72 <l2cap_chan_rx_init+0x62>
 100ac8c:	0102dcf8 	.word	0x0102dcf8
 100ac90:	010299c4 	.word	0x010299c4

0100ac94 <l2cap_chan_tx_init>:
	(void)memset(&chan->tx, 0, sizeof(chan->tx));
 100ac94:	220c      	movs	r2, #12
{
 100ac96:	b510      	push	{r4, lr}
	(void)memset(&chan->tx, 0, sizeof(chan->tx));
 100ac98:	2100      	movs	r1, #0
{
 100ac9a:	4604      	mov	r4, r0
	(void)memset(&chan->tx, 0, sizeof(chan->tx));
 100ac9c:	3024      	adds	r0, #36	; 0x24
 100ac9e:	f01b fe74 	bl	102698a <memset>
 100aca2:	2200      	movs	r2, #0
 100aca4:	f104 032c 	add.w	r3, r4, #44	; 0x2c
 100aca8:	e8d3 1fef 	ldaex	r1, [r3]
 100acac:	e8c3 2fe0 	stlex	r0, r2, [r3]
 100acb0:	2800      	cmp	r0, #0
 100acb2:	d1f9      	bne.n	100aca8 <l2cap_chan_tx_init+0x14>
 100acb4:	f104 0030 	add.w	r0, r4, #48	; 0x30
 100acb8:	f01e fb0b 	bl	10292d2 <z_impl_k_queue_init>
	k_work_init(&chan->tx_work, l2cap_chan_tx_process);
 100acbc:	f104 0050 	add.w	r0, r4, #80	; 0x50
 100acc0:	4902      	ldr	r1, [pc, #8]	; (100accc <l2cap_chan_tx_init+0x38>)
}
 100acc2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_work_init(&chan->tx_work, l2cap_chan_tx_process);
 100acc6:	f016 bfd3 	b.w	1021c70 <k_work_init>
 100acca:	bf00      	nop
 100accc:	01027611 	.word	0x01027611

0100acd0 <l2cap_rtx_timeout>:
{
 100acd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	LOG_ERR("chan %p timeout", chan);
 100acd2:	466e      	mov	r6, sp
{
 100acd4:	af00      	add	r7, sp, #0
	LOG_ERR("chan %p timeout", chan);
 100acd6:	b088      	sub	sp, #32
	struct bt_l2cap_le_chan *chan = LE_CHAN_RTX(work);
 100acd8:	f1a0 04a0 	sub.w	r4, r0, #160	; 0xa0
	struct bt_conn *conn = chan->chan.conn;
 100acdc:	f850 5ca0 	ldr.w	r5, [r0, #-160]
	LOG_ERR("chan %p timeout", chan);
 100ace0:	466a      	mov	r2, sp
 100ace2:	4b0f      	ldr	r3, [pc, #60]	; (100ad20 <l2cap_rtx_timeout+0x50>)
 100ace4:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100ace8:	e9c2 3405 	strd	r3, r4, [r2, #20]
 100acec:	2303      	movs	r3, #3
 100acee:	480d      	ldr	r0, [pc, #52]	; (100ad24 <l2cap_rtx_timeout+0x54>)
 100acf0:	f842 3f10 	str.w	r3, [r2, #16]!
 100acf4:	f01c fbc4 	bl	1027480 <z_log_msg_static_create.constprop.0>
	bt_l2cap_chan_remove(conn, &chan->chan);
 100acf8:	4628      	mov	r0, r5
 100acfa:	46b5      	mov	sp, r6
 100acfc:	4621      	mov	r1, r4
 100acfe:	f01c fbe3 	bl	10274c8 <bt_l2cap_chan_remove>
	bt_l2cap_chan_del(&chan->chan);
 100ad02:	4620      	mov	r0, r4
		bt_l2cap_chan_del(&chan->chan);
 100ad04:	f01c fbf5 	bl	10274f2 <bt_l2cap_chan_del>
	while ((chan = l2cap_remove_ident(conn, chan->ident))) {
 100ad08:	f894 1098 	ldrb.w	r1, [r4, #152]	; 0x98
 100ad0c:	2201      	movs	r2, #1
 100ad0e:	4628      	mov	r0, r5
 100ad10:	f01c fb20 	bl	1027354 <__l2cap_lookup_ident>
 100ad14:	4604      	mov	r4, r0
 100ad16:	2800      	cmp	r0, #0
 100ad18:	d1f4      	bne.n	100ad04 <l2cap_rtx_timeout+0x34>
}
 100ad1a:	46bd      	mov	sp, r7
 100ad1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 100ad1e:	bf00      	nop
 100ad20:	0102dd2c 	.word	0x0102dd2c
 100ad24:	010299c4 	.word	0x010299c4

0100ad28 <l2cap_chan_le_send>:
{
 100ad28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100ad2c:	4606      	mov	r6, r0
 100ad2e:	460d      	mov	r5, r1
 100ad30:	4690      	mov	r8, r2
 100ad32:	b08d      	sub	sp, #52	; 0x34
	if (!test_and_dec(&ch->tx.credits)) {
 100ad34:	f100 092c 	add.w	r9, r0, #44	; 0x2c
{
 100ad38:	af02      	add	r7, sp, #8
		old_value = atomic_get(target);
 100ad3a:	4648      	mov	r0, r9
 100ad3c:	f01c fb48 	bl	10273d0 <atomic_get>
		if (!old_value) {
 100ad40:	2800      	cmp	r0, #0
 100ad42:	f000 80db 	beq.w	100aefc <l2cap_chan_le_send+0x1d4>
		new_value = old_value - 1;
 100ad46:	1e43      	subs	r3, r0, #1
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 100ad48:	e8d9 2fef 	ldaex	r2, [r9]
 100ad4c:	4282      	cmp	r2, r0
 100ad4e:	d103      	bne.n	100ad58 <l2cap_chan_le_send+0x30>
 100ad50:	e8c9 3fe1 	stlex	r1, r3, [r9]
 100ad54:	2900      	cmp	r1, #0
 100ad56:	d1f7      	bne.n	100ad48 <l2cap_chan_le_send+0x20>
	} while (atomic_cas(target, old_value, new_value) == 0);
 100ad58:	d1ef      	bne.n	100ad3a <l2cap_chan_le_send+0x12>
	net_buf_simple_save(&buf->b, &state);
 100ad5a:	f105 0a0c 	add.w	sl, r5, #12
	state->offset = net_buf_simple_headroom(buf);
 100ad5e:	4650      	mov	r0, sl
 100ad60:	f01e f80a 	bl	1028d78 <net_buf_simple_headroom>
	state->len = buf->len;
 100ad64:	8a2b      	ldrh	r3, [r5, #16]
	state->offset = net_buf_simple_headroom(buf);
 100ad66:	60b8      	str	r0, [r7, #8]
	if (buf->len + sdu_hdr_len > ch->tx.mps) {
 100ad68:	eb03 0208 	add.w	r2, r3, r8
	state->len = buf->len;
 100ad6c:	60fb      	str	r3, [r7, #12]
 100ad6e:	8d33      	ldrh	r3, [r6, #40]	; 0x28
 100ad70:	429a      	cmp	r2, r3
 100ad72:	d824      	bhi.n	100adbe <l2cap_chan_le_send+0x96>
 *
 * @return Number of bytes available in the beginning of the buffer.
 */
static inline size_t net_buf_headroom(struct net_buf *buf)
{
	return net_buf_simple_headroom(&buf->b);
 100ad74:	4650      	mov	r0, sl
 100ad76:	f01d ffff 	bl	1028d78 <net_buf_simple_headroom>
	headroom = BT_L2CAP_CHAN_SEND_RESERVE + sdu_hdr_len;
 100ad7a:	f108 0308 	add.w	r3, r8, #8
	if (net_buf_headroom(buf) >= headroom && !buf->frags) {
 100ad7e:	b29b      	uxth	r3, r3
 100ad80:	4298      	cmp	r0, r3
 100ad82:	d31c      	bcc.n	100adbe <l2cap_chan_le_send+0x96>
 100ad84:	686b      	ldr	r3, [r5, #4]
 100ad86:	b9d3      	cbnz	r3, 100adbe <l2cap_chan_le_send+0x96>
		if (sdu_hdr_len) {
 100ad88:	f1b8 0f00 	cmp.w	r8, #0
 100ad8c:	d006      	beq.n	100ad9c <l2cap_chan_le_send+0x74>
			net_buf_push_le16(buf, net_buf_frags_len(buf));
 100ad8e:	4628      	mov	r0, r5
 100ad90:	f01c fad8 	bl	1027344 <net_buf_frags_len>
	net_buf_simple_push_le16(&buf->b, val);
 100ad94:	b281      	uxth	r1, r0
 100ad96:	4650      	mov	r0, sl
 100ad98:	f01d ffdd 	bl	1028d56 <net_buf_simple_push_le16>
		return net_buf_ref(buf);
 100ad9c:	4628      	mov	r0, r5
 100ad9e:	f013 f961 	bl	101e064 <net_buf_ref>
	if (!seg) {
 100ada2:	4604      	mov	r4, r0
 100ada4:	2800      	cmp	r0, #0
 100ada6:	d152      	bne.n	100ae4e <l2cap_chan_le_send+0x126>
	return atomic_add(target, 1);
 100ada8:	2101      	movs	r1, #1
 100adaa:	4648      	mov	r0, r9
 100adac:	f01c fb6b 	bl	1027486 <atomic_add.isra.0>
		return -EAGAIN;
 100adb0:	f06f 0b0a 	mvn.w	fp, #10
}
 100adb4:	4658      	mov	r0, fp
 100adb6:	372c      	adds	r7, #44	; 0x2c
 100adb8:	46bd      	mov	sp, r7
 100adba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 100adbe:	7aa8      	ldrb	r0, [r5, #10]
 100adc0:	f012 ff9a 	bl	101dcf8 <net_buf_pool_get>
	if (ch->chan.ops->alloc_seg) {
 100adc4:	6873      	ldr	r3, [r6, #4]
 100adc6:	68db      	ldr	r3, [r3, #12]
 100adc8:	b17b      	cbz	r3, 100adea <l2cap_chan_le_send+0xc2>
		seg = ch->chan.ops->alloc_seg(&ch->chan);
 100adca:	4630      	mov	r0, r6
 100adcc:	4798      	blx	r3
		__ASSERT_NO_MSG(seg);
 100adce:	4604      	mov	r4, r0
 100add0:	b990      	cbnz	r0, 100adf8 <l2cap_chan_le_send+0xd0>
 100add2:	4950      	ldr	r1, [pc, #320]	; (100af14 <l2cap_chan_le_send+0x1ec>)
 100add4:	4850      	ldr	r0, [pc, #320]	; (100af18 <l2cap_chan_le_send+0x1f0>)
 100add6:	f240 7302 	movw	r3, #1794	; 0x702
 100adda:	4a50      	ldr	r2, [pc, #320]	; (100af1c <l2cap_chan_le_send+0x1f4>)
 100addc:	f019 fefb 	bl	1024bd6 <assert_print>
 100ade0:	f240 7102 	movw	r1, #1794	; 0x702
 100ade4:	484d      	ldr	r0, [pc, #308]	; (100af1c <l2cap_chan_le_send+0x1f4>)
 100ade6:	f019 feef 	bl	1024bc8 <assert_post_action>
	return net_buf_alloc_fixed(pool, timeout);
 100adea:	2200      	movs	r2, #0
 100adec:	2300      	movs	r3, #0
 100adee:	f01d ffab 	bl	1028d48 <net_buf_alloc_fixed>
	if (seg) {
 100adf2:	4604      	mov	r4, r0
 100adf4:	2800      	cmp	r0, #0
 100adf6:	d05b      	beq.n	100aeb0 <l2cap_chan_le_send+0x188>
	net_buf_simple_reserve(&buf->b, reserve);
 100adf8:	2108      	movs	r1, #8
 100adfa:	f104 000c 	add.w	r0, r4, #12
 100adfe:	f013 f8a3 	bl	101df48 <net_buf_simple_reserve>
	net_buf_simple_add_le16(&buf->b, val);
 100ae02:	f104 0b0c 	add.w	fp, r4, #12
	if (sdu_hdr_len) {
 100ae06:	f1b8 0f00 	cmp.w	r8, #0
 100ae0a:	d006      	beq.n	100ae1a <l2cap_chan_le_send+0xf2>
		net_buf_add_le16(seg, net_buf_frags_len(buf));
 100ae0c:	4628      	mov	r0, r5
 100ae0e:	f01c fa99 	bl	1027344 <net_buf_frags_len>
 100ae12:	b281      	uxth	r1, r0
 100ae14:	4658      	mov	r0, fp
 100ae16:	f01d ffce 	bl	1028db6 <net_buf_simple_add_le16>
	return net_buf_simple_tailroom(&buf->b);
 100ae1a:	4658      	mov	r0, fp
 100ae1c:	f01d ffb0 	bl	1028d80 <net_buf_simple_tailroom>
	len = MIN(net_buf_tailroom(seg), ch->tx.mps - sdu_hdr_len);
 100ae20:	8d33      	ldrh	r3, [r6, #40]	; 0x28
 100ae22:	eba3 0308 	sub.w	r3, r3, r8
 100ae26:	4298      	cmp	r0, r3
 100ae28:	d24b      	bcs.n	100aec2 <l2cap_chan_le_send+0x19a>
 100ae2a:	4658      	mov	r0, fp
 100ae2c:	f01d ffa8 	bl	1028d80 <net_buf_simple_tailroom>
 100ae30:	b283      	uxth	r3, r0
	len = MIN(buf->len, len);
 100ae32:	8a2a      	ldrh	r2, [r5, #16]
	return net_buf_simple_add_mem(&buf->b, mem, len);
 100ae34:	68e9      	ldr	r1, [r5, #12]
	net_buf_add_mem(seg, buf->data, len);
 100ae36:	429a      	cmp	r2, r3
 100ae38:	bf28      	it	cs
 100ae3a:	461a      	movcs	r2, r3
 100ae3c:	4658      	mov	r0, fp
 100ae3e:	607a      	str	r2, [r7, #4]
 100ae40:	f01d ffa6 	bl	1028d90 <net_buf_simple_add_mem>
	return net_buf_simple_pull(&buf->b, len);
 100ae44:	687a      	ldr	r2, [r7, #4]
 100ae46:	4650      	mov	r0, sl
 100ae48:	4611      	mov	r1, r2
 100ae4a:	f013 f9e9 	bl	101e220 <net_buf_simple_pull>
	if (buf == seg || !buf->len) {
 100ae4e:	42a5      	cmp	r5, r4
	len = seg->len - sdu_hdr_len;
 100ae50:	f8b4 a010 	ldrh.w	sl, [r4, #16]
		err = bt_l2cap_send_cb(ch->chan.conn, ch->tx.cid, seg,
 100ae54:	6830      	ldr	r0, [r6, #0]
 100ae56:	8cb1      	ldrh	r1, [r6, #36]	; 0x24
				       l2cap_tx_meta_data(buf));
 100ae58:	69ab      	ldr	r3, [r5, #24]
	if (buf == seg || !buf->len) {
 100ae5a:	d002      	beq.n	100ae62 <l2cap_chan_le_send+0x13a>
 100ae5c:	8a2a      	ldrh	r2, [r5, #16]
 100ae5e:	2a00      	cmp	r2, #0
 100ae60:	d131      	bne.n	100aec6 <l2cap_chan_le_send+0x19e>
		err = bt_l2cap_send_cb(ch->chan.conn, ch->tx.cid, seg,
 100ae62:	9300      	str	r3, [sp, #0]
 100ae64:	4b2e      	ldr	r3, [pc, #184]	; (100af20 <l2cap_chan_le_send+0x1f8>)
		err = bt_l2cap_send_cb(ch->chan.conn, ch->tx.cid, seg,
 100ae66:	4622      	mov	r2, r4
 100ae68:	f01c fb78 	bl	102755c <bt_l2cap_send_cb>
 100ae6c:	4683      	mov	fp, r0
	if (err) {
 100ae6e:	b368      	cbz	r0, 100aecc <l2cap_chan_le_send+0x1a4>
		LOG_WRN("Unable to send seg %d", err);
 100ae70:	466e      	mov	r6, sp
 100ae72:	b088      	sub	sp, #32
 100ae74:	aa02      	add	r2, sp, #8
 100ae76:	4b2b      	ldr	r3, [pc, #172]	; (100af24 <l2cap_chan_le_send+0x1fc>)
 100ae78:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100ae7c:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100ae80:	2303      	movs	r3, #3
 100ae82:	4829      	ldr	r0, [pc, #164]	; (100af28 <l2cap_chan_le_send+0x200>)
 100ae84:	f842 3f10 	str.w	r3, [r2, #16]!
 100ae88:	f01c fafa 	bl	1027480 <z_log_msg_static_create.constprop.0>
 100ae8c:	2101      	movs	r1, #1
 100ae8e:	46b5      	mov	sp, r6
 100ae90:	4648      	mov	r0, r9
 100ae92:	f01c faf8 	bl	1027486 <atomic_add.isra.0>
		net_buf_unref(seg);
 100ae96:	4620      	mov	r0, r4
 100ae98:	f013 f8a2 	bl	101dfe0 <net_buf_unref>
		if (err == -ENOBUFS) {
 100ae9c:	f11b 0f69 	cmn.w	fp, #105	; 0x69
 100aea0:	d188      	bne.n	100adb4 <l2cap_chan_le_send+0x8c>
	buf->data = buf->__buf + state->offset;
 100aea2:	893a      	ldrh	r2, [r7, #8]
 100aea4:	696b      	ldr	r3, [r5, #20]
 100aea6:	4413      	add	r3, r2
 100aea8:	60eb      	str	r3, [r5, #12]
	buf->len = state->len;
 100aeaa:	68fb      	ldr	r3, [r7, #12]
 100aeac:	822b      	strh	r3, [r5, #16]
}
 100aeae:	e77f      	b.n	100adb0 <l2cap_chan_le_send+0x88>
	return bt_conn_create_pdu_timeout(pool,
 100aeb0:	2200      	movs	r2, #0
 100aeb2:	2300      	movs	r3, #0
 100aeb4:	2104      	movs	r1, #4
 100aeb6:	f7ff fa65 	bl	100a384 <bt_conn_create_pdu_timeout>
	if (!seg) {
 100aeba:	4604      	mov	r4, r0
 100aebc:	2800      	cmp	r0, #0
 100aebe:	d1a0      	bne.n	100ae02 <l2cap_chan_le_send+0xda>
 100aec0:	e772      	b.n	100ada8 <l2cap_chan_le_send+0x80>
	len = MIN(net_buf_tailroom(seg), ch->tx.mps - sdu_hdr_len);
 100aec2:	b29b      	uxth	r3, r3
 100aec4:	e7b5      	b.n	100ae32 <l2cap_chan_le_send+0x10a>
		err = bt_l2cap_send_cb(ch->chan.conn, ch->tx.cid, seg,
 100aec6:	9300      	str	r3, [sp, #0]
 100aec8:	4b18      	ldr	r3, [pc, #96]	; (100af2c <l2cap_chan_le_send+0x204>)
 100aeca:	e7cc      	b.n	100ae66 <l2cap_chan_le_send+0x13e>
	if (!atomic_get(&ch->tx.credits)) {
 100aecc:	4648      	mov	r0, r9
 100aece:	f01c fa7f 	bl	10273d0 <atomic_get>
 100aed2:	b110      	cbz	r0, 100aeda <l2cap_chan_le_send+0x1b2>
	len = seg->len - sdu_hdr_len;
 100aed4:	ebaa 0b08 	sub.w	fp, sl, r8
 100aed8:	e76c      	b.n	100adb4 <l2cap_chan_le_send+0x8c>
		atomic_clear_bit(ch->chan.status, BT_L2CAP_STATUS_OUT);
 100aeda:	f106 0110 	add.w	r1, r6, #16
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 100aede:	e8d1 3fef 	ldaex	r3, [r1]
 100aee2:	f023 0301 	bic.w	r3, r3, #1
 100aee6:	e8c1 3fe2 	stlex	r2, r3, [r1]
 100aeea:	2a00      	cmp	r2, #0
 100aeec:	d1f7      	bne.n	100aede <l2cap_chan_le_send+0x1b6>
		if (ch->chan.ops->status) {
 100aeee:	6873      	ldr	r3, [r6, #4]
 100aef0:	69db      	ldr	r3, [r3, #28]
 100aef2:	2b00      	cmp	r3, #0
 100aef4:	d0ee      	beq.n	100aed4 <l2cap_chan_le_send+0x1ac>
			ch->chan.ops->status(&ch->chan, ch->chan.status);
 100aef6:	4630      	mov	r0, r6
 100aef8:	4798      	blx	r3
 100aefa:	e7eb      	b.n	100aed4 <l2cap_chan_le_send+0x1ac>
		LOG_WRN("No credits to transmit packet");
 100aefc:	4b0c      	ldr	r3, [pc, #48]	; (100af30 <l2cap_chan_le_send+0x208>)
 100aefe:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100af02:	627b      	str	r3, [r7, #36]	; 0x24
 100af04:	2302      	movs	r3, #2
 100af06:	4808      	ldr	r0, [pc, #32]	; (100af28 <l2cap_chan_le_send+0x200>)
 100af08:	623b      	str	r3, [r7, #32]
 100af0a:	f107 0220 	add.w	r2, r7, #32
 100af0e:	f01c fab7 	bl	1027480 <z_log_msg_static_create.constprop.0>
		return -EAGAIN;
 100af12:	e74d      	b.n	100adb0 <l2cap_chan_le_send+0x88>
 100af14:	0102dd6d 	.word	0x0102dd6d
 100af18:	0102b695 	.word	0x0102b695
 100af1c:	0102dd3c 	.word	0x0102dd3c
 100af20:	0100b04d 	.word	0x0100b04d
 100af24:	0102dd71 	.word	0x0102dd71
 100af28:	010299c4 	.word	0x010299c4
 100af2c:	01027785 	.word	0x01027785
 100af30:	0102dd87 	.word	0x0102dd87

0100af34 <l2cap_chan_send_credits.isra.0>:
static void l2cap_chan_send_credits(struct bt_l2cap_le_chan *chan,
 100af34:	b5f0      	push	{r4, r5, r6, r7, lr}
	__ASSERT_NO_MSG(bt_l2cap_chan_get_state(&chan->chan) == BT_L2CAP_CONNECTED);
 100af36:	f890 3094 	ldrb.w	r3, [r0, #148]	; 0x94
static void l2cap_chan_send_credits(struct bt_l2cap_le_chan *chan,
 100af3a:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(bt_l2cap_chan_get_state(&chan->chan) == BT_L2CAP_CONNECTED);
 100af3c:	2b03      	cmp	r3, #3
static void l2cap_chan_send_credits(struct bt_l2cap_le_chan *chan,
 100af3e:	b087      	sub	sp, #28
	__ASSERT_NO_MSG(bt_l2cap_chan_get_state(&chan->chan) == BT_L2CAP_CONNECTED);
 100af40:	d00b      	beq.n	100af5a <l2cap_chan_send_credits.isra.0+0x26>
 100af42:	493d      	ldr	r1, [pc, #244]	; (100b038 <l2cap_chan_send_credits.isra.0+0x104>)
 100af44:	483d      	ldr	r0, [pc, #244]	; (100b03c <l2cap_chan_send_credits.isra.0+0x108>)
 100af46:	f640 03f9 	movw	r3, #2297	; 0x8f9
 100af4a:	4a3d      	ldr	r2, [pc, #244]	; (100b040 <l2cap_chan_send_credits.isra.0+0x10c>)
 100af4c:	f019 fe43 	bl	1024bd6 <assert_print>
 100af50:	f640 01f9 	movw	r1, #2297	; 0x8f9
 100af54:	483a      	ldr	r0, [pc, #232]	; (100b040 <l2cap_chan_send_credits.isra.0+0x10c>)
 100af56:	f019 fe37 	bl	1024bc8 <assert_post_action>
	if (credits > chan->rx.init_credits) {
 100af5a:	8b46      	ldrh	r6, [r0, #26]
	old_credits = atomic_get(&chan->rx.credits);
 100af5c:	f100 071c 	add.w	r7, r0, #28
 100af60:	428e      	cmp	r6, r1
 100af62:	4638      	mov	r0, r7
 100af64:	bf28      	it	cs
 100af66:	460e      	movcs	r6, r1
 100af68:	f01c fa32 	bl	10273d0 <atomic_get>
	if (credits + old_credits > chan->rx.init_credits) {
 100af6c:	8b63      	ldrh	r3, [r4, #26]
 100af6e:	b282      	uxth	r2, r0
 100af70:	4432      	add	r2, r6
 100af72:	429a      	cmp	r2, r3
		credits = chan->rx.init_credits - old_credits;
 100af74:	bfc4      	itt	gt
 100af76:	1a1b      	subgt	r3, r3, r0
 100af78:	b29e      	uxthgt	r6, r3
	buf = l2cap_create_le_sig_pdu(buf, BT_L2CAP_LE_CREDITS, get_ident(),
 100af7a:	f7ff fdd3 	bl	100ab24 <get_ident>
 100af7e:	2204      	movs	r2, #4
 100af80:	4601      	mov	r1, r0
 100af82:	2016      	movs	r0, #22
 100af84:	f7ff fdf0 	bl	100ab68 <l2cap_create_le_sig_pdu.constprop.0>
	if (!buf) {
 100af88:	4605      	mov	r5, r0
 100af8a:	2800      	cmp	r0, #0
 100af8c:	d13f      	bne.n	100b00e <l2cap_chan_send_credits.isra.0+0xda>
		LOG_ERR("Unable to send credits update");
 100af8e:	4b2d      	ldr	r3, [pc, #180]	; (100b044 <l2cap_chan_send_credits.isra.0+0x110>)
 100af90:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100af94:	9305      	str	r3, [sp, #20]
 100af96:	2302      	movs	r3, #2
 100af98:	482b      	ldr	r0, [pc, #172]	; (100b048 <l2cap_chan_send_credits.isra.0+0x114>)
 100af9a:	aa04      	add	r2, sp, #16
	atomic_set_bit(chan->status, BT_L2CAP_STATUS_SHUTDOWN);
 100af9c:	f104 0610 	add.w	r6, r4, #16
		LOG_ERR("Unable to send credits update");
 100afa0:	9304      	str	r3, [sp, #16]
 100afa2:	f01c fa6d 	bl	1027480 <z_log_msg_static_create.constprop.0>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 100afa6:	e8d6 3fef 	ldaex	r3, [r6]
 100afaa:	f043 0302 	orr.w	r3, r3, #2
 100afae:	e8c6 3fe2 	stlex	r2, r3, [r6]
 100afb2:	2a00      	cmp	r2, #0
 100afb4:	d1f7      	bne.n	100afa6 <l2cap_chan_send_credits.isra.0+0x72>
	if (le_chan->_sdu) {
 100afb6:	6e20      	ldr	r0, [r4, #96]	; 0x60
 100afb8:	b120      	cbz	r0, 100afc4 <l2cap_chan_send_credits.isra.0+0x90>
		net_buf_unref(le_chan->_sdu);
 100afba:	f013 f811 	bl	101dfe0 <net_buf_unref>
		le_chan->_sdu = NULL;
 100afbe:	6625      	str	r5, [r4, #96]	; 0x60
		le_chan->_sdu_len = 0U;
 100afc0:	f8a4 5064 	strh.w	r5, [r4, #100]	; 0x64
	if (le_chan->tx_buf) {
 100afc4:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 100afc6:	b118      	cbz	r0, 100afd0 <l2cap_chan_send_credits.isra.0+0x9c>
		net_buf_unref(le_chan->tx_buf);
 100afc8:	f013 f80a 	bl	101dfe0 <net_buf_unref>
		le_chan->tx_buf = NULL;
 100afcc:	2300      	movs	r3, #0
 100afce:	64e3      	str	r3, [r4, #76]	; 0x4c
	while ((buf = net_buf_get(&le_chan->tx_queue, K_NO_WAIT))) {
 100afd0:	f104 0530 	add.w	r5, r4, #48	; 0x30
 100afd4:	2200      	movs	r2, #0
 100afd6:	2300      	movs	r3, #0
 100afd8:	4628      	mov	r0, r5
 100afda:	f01d feba 	bl	1028d52 <net_buf_get>
 100afde:	b980      	cbnz	r0, 100b002 <l2cap_chan_send_credits.isra.0+0xce>
	while ((buf = net_buf_get(&le_chan->rx_queue, K_NO_WAIT))) {
 100afe0:	f104 0578 	add.w	r5, r4, #120	; 0x78
 100afe4:	2200      	movs	r2, #0
 100afe6:	2300      	movs	r3, #0
 100afe8:	4628      	mov	r0, r5
 100afea:	f01d feb2 	bl	1028d52 <net_buf_get>
 100afee:	b958      	cbnz	r0, 100b008 <l2cap_chan_send_credits.isra.0+0xd4>
	if (chan->ops->status) {
 100aff0:	6863      	ldr	r3, [r4, #4]
 100aff2:	69db      	ldr	r3, [r3, #28]
 100aff4:	b1f3      	cbz	r3, 100b034 <l2cap_chan_send_credits.isra.0+0x100>
		chan->ops->status(chan, chan->status);
 100aff6:	4631      	mov	r1, r6
 100aff8:	4620      	mov	r0, r4
}
 100affa:	b007      	add	sp, #28
 100affc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		chan->ops->status(chan, chan->status);
 100b000:	4718      	bx	r3
		net_buf_unref(buf);
 100b002:	f012 ffed 	bl	101dfe0 <net_buf_unref>
 100b006:	e7e5      	b.n	100afd4 <l2cap_chan_send_credits.isra.0+0xa0>
		net_buf_unref(buf);
 100b008:	f012 ffea 	bl	101dfe0 <net_buf_unref>
 100b00c:	e7ea      	b.n	100afe4 <l2cap_chan_send_credits.isra.0+0xb0>
	atomic_add(&chan->rx.credits, credits);
 100b00e:	4631      	mov	r1, r6
 100b010:	4638      	mov	r0, r7
 100b012:	f01c fa38 	bl	1027486 <atomic_add.isra.0>
	return net_buf_simple_add(&buf->b, len);
 100b016:	2104      	movs	r1, #4
 100b018:	f105 000c 	add.w	r0, r5, #12
 100b01c:	f013 f93c 	bl	101e298 <net_buf_simple_add>
	l2cap_send(chan->chan.conn, BT_L2CAP_CID_LE_SIG, buf);
 100b020:	4629      	mov	r1, r5
	ev->cid = sys_cpu_to_le16(chan->rx.cid);
 100b022:	8aa3      	ldrh	r3, [r4, #20]
	ev->credits = sys_cpu_to_le16(credits);
 100b024:	8046      	strh	r6, [r0, #2]
	ev->cid = sys_cpu_to_le16(chan->rx.cid);
 100b026:	8003      	strh	r3, [r0, #0]
	l2cap_send(chan->chan.conn, BT_L2CAP_CID_LE_SIG, buf);
 100b028:	6820      	ldr	r0, [r4, #0]
}
 100b02a:	b007      	add	sp, #28
 100b02c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	l2cap_send(chan->chan.conn, BT_L2CAP_CID_LE_SIG, buf);
 100b030:	f01c bb18 	b.w	1027664 <l2cap_send.constprop.0>
}
 100b034:	b007      	add	sp, #28
 100b036:	bdf0      	pop	{r4, r5, r6, r7, pc}
 100b038:	0102dda5 	.word	0x0102dda5
 100b03c:	0102b695 	.word	0x0102b695
 100b040:	0102dd3c 	.word	0x0102dd3c
 100b044:	0102dde0 	.word	0x0102dde0
 100b048:	010299c4 	.word	0x010299c4

0100b04c <l2cap_chan_sdu_sent>:
{
 100b04c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100b050:	460c      	mov	r4, r1
	void *cb_user_data = data->user_data;
 100b052:	e9d1 6802 	ldrd	r6, r8, [r1, #8]
{
 100b056:	4617      	mov	r7, r2
	uint16_t cid = data->cid;
 100b058:	f8b1 9004 	ldrh.w	r9, [r1, #4]
{
 100b05c:	4605      	mov	r5, r0
	(void)memset(data, 0, sizeof(*data));
 100b05e:	2100      	movs	r1, #0
 100b060:	2210      	movs	r2, #16
 100b062:	4620      	mov	r0, r4
 100b064:	f01b fc91 	bl	102698a <memset>
	k_fifo_put(&free_l2cap_tx_meta_data, data);
 100b068:	4621      	mov	r1, r4
 100b06a:	4813      	ldr	r0, [pc, #76]	; (100b0b8 <l2cap_chan_sdu_sent+0x6c>)
 100b06c:	f01e f93e 	bl	10292ec <k_queue_append>
	if (err) {
 100b070:	b13f      	cbz	r7, 100b082 <l2cap_chan_sdu_sent+0x36>
		if (cb) {
 100b072:	b1fe      	cbz	r6, 100b0b4 <l2cap_chan_sdu_sent+0x68>
			cb(conn, cb_user_data, err);
 100b074:	463a      	mov	r2, r7
 100b076:	4641      	mov	r1, r8
 100b078:	4628      	mov	r0, r5
 100b07a:	4633      	mov	r3, r6
}
 100b07c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			cb(conn, cb_user_data, err);
 100b080:	4718      	bx	r3
	chan = bt_l2cap_le_lookup_tx_cid(conn, cid);
 100b082:	4649      	mov	r1, r9
 100b084:	4628      	mov	r0, r5
 100b086:	f01c fb74 	bl	1027772 <bt_l2cap_le_lookup_tx_cid>
 100b08a:	4604      	mov	r4, r0
	if (!chan) {
 100b08c:	b190      	cbz	r0, 100b0b4 <l2cap_chan_sdu_sent+0x68>
	if (chan->ops->sent) {
 100b08e:	6843      	ldr	r3, [r0, #4]
 100b090:	699b      	ldr	r3, [r3, #24]
 100b092:	b103      	cbz	r3, 100b096 <l2cap_chan_sdu_sent+0x4a>
		chan->ops->sent(chan);
 100b094:	4798      	blx	r3
	if (cb) {
 100b096:	b11e      	cbz	r6, 100b0a0 <l2cap_chan_sdu_sent+0x54>
		cb(conn, cb_user_data, 0);
 100b098:	2200      	movs	r2, #0
 100b09a:	4641      	mov	r1, r8
 100b09c:	4628      	mov	r0, r5
 100b09e:	47b0      	blx	r6
	l2cap_chan_tx_resume(BT_L2CAP_LE_CHAN(chan));
 100b0a0:	4620      	mov	r0, r4
 100b0a2:	f01c f998 	bl	10273d6 <l2cap_chan_tx_resume>
}
 100b0a6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		bt_conn_foreach(BT_CONN_TYPE_LE, resume_all_channels, NULL);
 100b0aa:	2200      	movs	r2, #0
 100b0ac:	2001      	movs	r0, #1
 100b0ae:	4903      	ldr	r1, [pc, #12]	; (100b0bc <l2cap_chan_sdu_sent+0x70>)
 100b0b0:	f7ff b920 	b.w	100a2f4 <bt_conn_foreach>
}
 100b0b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 100b0b8:	21000d44 	.word	0x21000d44
 100b0bc:	010273f9 	.word	0x010273f9

0100b0c0 <l2cap_chan_add>:
{
 100b0c0:	b570      	push	{r4, r5, r6, lr}
	if (le_chan->rx.cid > 0) {
 100b0c2:	8a8b      	ldrh	r3, [r1, #20]
{
 100b0c4:	4605      	mov	r5, r0
 100b0c6:	460c      	mov	r4, r1
 100b0c8:	b086      	sub	sp, #24
	if (le_chan->rx.cid > 0) {
 100b0ca:	b92b      	cbnz	r3, 100b0d8 <l2cap_chan_add+0x18>
	for (cid = L2CAP_LE_CID_DYN_START; cid <= L2CAP_LE_CID_DYN_END; cid++) {
 100b0cc:	2140      	movs	r1, #64	; 0x40
		if (!bt_l2cap_le_lookup_rx_cid(conn, cid)) {
 100b0ce:	4628      	mov	r0, r5
 100b0d0:	f01c fb63 	bl	102779a <bt_l2cap_le_lookup_rx_cid>
 100b0d4:	b9f0      	cbnz	r0, 100b114 <l2cap_chan_add+0x54>
			le_chan->rx.cid = cid;
 100b0d6:	82a1      	strh	r1, [r4, #20]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 100b0d8:	2100      	movs	r1, #0
 100b0da:	f104 0310 	add.w	r3, r4, #16
 100b0de:	e8d3 0fef 	ldaex	r0, [r3]
 100b0e2:	e8c3 1fe6 	stlex	r6, r1, [r3]
 100b0e6:	2e00      	cmp	r6, #0
 100b0e8:	d1f9      	bne.n	100b0de <l2cap_chan_add+0x1e>
	parent->next = child;
 100b0ea:	60a1      	str	r1, [r4, #8]
	return list->tail;
 100b0ec:	6da9      	ldr	r1, [r5, #88]	; 0x58
	sys_slist_append(&conn->channels, &chan->node);
 100b0ee:	f104 0308 	add.w	r3, r4, #8
Z_GENLIST_APPEND(slist, snode)
 100b0f2:	bb01      	cbnz	r1, 100b136 <l2cap_chan_add+0x76>
	list->head = node;
 100b0f4:	e9c5 3315 	strd	r3, r3, [r5, #84]	; 0x54
	k_work_init_delayable(&le_chan->rtx_work, l2cap_rtx_timeout);
 100b0f8:	4917      	ldr	r1, [pc, #92]	; (100b158 <l2cap_chan_add+0x98>)
	chan->conn = conn;
 100b0fa:	6025      	str	r5, [r4, #0]
	chan->destroy = destroy;
 100b0fc:	60e2      	str	r2, [r4, #12]
	k_work_init_delayable(&le_chan->rtx_work, l2cap_rtx_timeout);
 100b0fe:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
 100b102:	f016 ff03 	bl	1021f0c <k_work_init_delayable>
	if (L2CAP_LE_CID_IS_DYN(le_chan->rx.cid)) {
 100b106:	8aa3      	ldrh	r3, [r4, #20]
 100b108:	3b40      	subs	r3, #64	; 0x40
 100b10a:	b29b      	uxth	r3, r3
 100b10c:	2b3f      	cmp	r3, #63	; 0x3f
 100b10e:	d915      	bls.n	100b13c <l2cap_chan_add+0x7c>
	return true;
 100b110:	2001      	movs	r0, #1
 100b112:	e00e      	b.n	100b132 <l2cap_chan_add+0x72>
	for (cid = L2CAP_LE_CID_DYN_START; cid <= L2CAP_LE_CID_DYN_END; cid++) {
 100b114:	3101      	adds	r1, #1
 100b116:	b289      	uxth	r1, r1
 100b118:	2980      	cmp	r1, #128	; 0x80
 100b11a:	d1d8      	bne.n	100b0ce <l2cap_chan_add+0xe>
		LOG_ERR("Unable to allocate L2CAP channel ID");
 100b11c:	4b0f      	ldr	r3, [pc, #60]	; (100b15c <l2cap_chan_add+0x9c>)
 100b11e:	4810      	ldr	r0, [pc, #64]	; (100b160 <l2cap_chan_add+0xa0>)
 100b120:	9305      	str	r3, [sp, #20]
 100b122:	2302      	movs	r3, #2
 100b124:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100b128:	aa04      	add	r2, sp, #16
 100b12a:	9304      	str	r3, [sp, #16]
 100b12c:	f01c f9a8 	bl	1027480 <z_log_msg_static_create.constprop.0>
		return false;
 100b130:	2000      	movs	r0, #0
}
 100b132:	b006      	add	sp, #24
 100b134:	bd70      	pop	{r4, r5, r6, pc}
	parent->next = child;
 100b136:	600b      	str	r3, [r1, #0]
	list->tail = node;
 100b138:	65ab      	str	r3, [r5, #88]	; 0x58
}
 100b13a:	e7dd      	b.n	100b0f8 <l2cap_chan_add+0x38>
		k_work_init(&le_chan->rx_work, l2cap_rx_process);
 100b13c:	4909      	ldr	r1, [pc, #36]	; (100b164 <l2cap_chan_add+0xa4>)
 100b13e:	f104 0068 	add.w	r0, r4, #104	; 0x68
 100b142:	f016 fd95 	bl	1021c70 <k_work_init>
 100b146:	f104 0078 	add.w	r0, r4, #120	; 0x78
 100b14a:	f01e f8c2 	bl	10292d2 <z_impl_k_queue_init>
	BT_L2CAP_LE_CHAN(chan)->state = state;
 100b14e:	2301      	movs	r3, #1
 100b150:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
}
 100b154:	e7dc      	b.n	100b110 <l2cap_chan_add+0x50>
 100b156:	bf00      	nop
 100b158:	0100acd1 	.word	0x0100acd1
 100b15c:	0102ddfe 	.word	0x0102ddfe
 100b160:	010299c4 	.word	0x010299c4
 100b164:	01027853 	.word	0x01027853

0100b168 <bt_l2cap_connected>:
{
 100b168:	b573      	push	{r0, r1, r4, r5, r6, lr}
 100b16a:	4605      	mov	r5, r0
	STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
 100b16c:	4c1e      	ldr	r4, [pc, #120]	; (100b1e8 <bt_l2cap_connected+0x80>)
 100b16e:	4e1f      	ldr	r6, [pc, #124]	; (100b1ec <bt_l2cap_connected+0x84>)
 100b170:	42b4      	cmp	r4, r6
 100b172:	d935      	bls.n	100b1e0 <bt_l2cap_connected+0x78>
 100b174:	491e      	ldr	r1, [pc, #120]	; (100b1f0 <bt_l2cap_connected+0x88>)
 100b176:	f240 1381 	movw	r3, #385	; 0x181
 100b17a:	4a1e      	ldr	r2, [pc, #120]	; (100b1f4 <bt_l2cap_connected+0x8c>)
 100b17c:	481e      	ldr	r0, [pc, #120]	; (100b1f8 <bt_l2cap_connected+0x90>)
 100b17e:	f019 fd2a 	bl	1024bd6 <assert_print>
 100b182:	481e      	ldr	r0, [pc, #120]	; (100b1fc <bt_l2cap_connected+0x94>)
 100b184:	f019 fd27 	bl	1024bd6 <assert_print>
 100b188:	f240 1181 	movw	r1, #385	; 0x181
 100b18c:	4819      	ldr	r0, [pc, #100]	; (100b1f4 <bt_l2cap_connected+0x8c>)
 100b18e:	f019 fd1b 	bl	1024bc8 <assert_post_action>
		if (fchan->accept(conn, &chan) < 0) {
 100b192:	4628      	mov	r0, r5
 100b194:	6863      	ldr	r3, [r4, #4]
 100b196:	a901      	add	r1, sp, #4
 100b198:	4798      	blx	r3
 100b19a:	2800      	cmp	r0, #0
 100b19c:	db1e      	blt.n	100b1dc <bt_l2cap_connected+0x74>
		le_chan = BT_L2CAP_LE_CHAN(chan);
 100b19e:	9901      	ldr	r1, [sp, #4]
		le_chan->rx.cid = fchan->cid;
 100b1a0:	8823      	ldrh	r3, [r4, #0]
		if (!l2cap_chan_add(conn, chan, fchan->destroy)) {
 100b1a2:	4628      	mov	r0, r5
		le_chan->rx.cid = fchan->cid;
 100b1a4:	828b      	strh	r3, [r1, #20]
		le_chan->tx.cid = fchan->cid;
 100b1a6:	848b      	strh	r3, [r1, #36]	; 0x24
		if (!l2cap_chan_add(conn, chan, fchan->destroy)) {
 100b1a8:	68a2      	ldr	r2, [r4, #8]
 100b1aa:	f7ff ff89 	bl	100b0c0 <l2cap_chan_add>
 100b1ae:	b1c0      	cbz	r0, 100b1e2 <bt_l2cap_connected+0x7a>
		if (chan->ops->connected) {
 100b1b0:	9801      	ldr	r0, [sp, #4]
 100b1b2:	6843      	ldr	r3, [r0, #4]
 100b1b4:	681b      	ldr	r3, [r3, #0]
 100b1b6:	b103      	cbz	r3, 100b1ba <bt_l2cap_connected+0x52>
			chan->ops->connected(chan);
 100b1b8:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 100b1ba:	9b01      	ldr	r3, [sp, #4]
 100b1bc:	3310      	adds	r3, #16
 100b1be:	e8d3 1fef 	ldaex	r1, [r3]
 100b1c2:	f041 0101 	orr.w	r1, r1, #1
 100b1c6:	e8c3 1fe2 	stlex	r2, r1, [r3]
 100b1ca:	2a00      	cmp	r2, #0
 100b1cc:	d1f7      	bne.n	100b1be <bt_l2cap_connected+0x56>
		if (chan->ops->status) {
 100b1ce:	9801      	ldr	r0, [sp, #4]
 100b1d0:	6843      	ldr	r3, [r0, #4]
 100b1d2:	69db      	ldr	r3, [r3, #28]
 100b1d4:	b113      	cbz	r3, 100b1dc <bt_l2cap_connected+0x74>
			chan->ops->status(chan, chan->status);
 100b1d6:	f100 0110 	add.w	r1, r0, #16
 100b1da:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
 100b1dc:	340c      	adds	r4, #12
 100b1de:	e7c7      	b.n	100b170 <bt_l2cap_connected+0x8>
 100b1e0:	d3d7      	bcc.n	100b192 <bt_l2cap_connected+0x2a>
}
 100b1e2:	b002      	add	sp, #8
 100b1e4:	bd70      	pop	{r4, r5, r6, pc}
 100b1e6:	bf00      	nop
 100b1e8:	010298ec 	.word	0x010298ec
 100b1ec:	01029910 	.word	0x01029910
 100b1f0:	0102de22 	.word	0x0102de22
 100b1f4:	0102dd3c 	.word	0x0102dd3c
 100b1f8:	0102b695 	.word	0x0102b695
 100b1fc:	0102bf04 	.word	0x0102bf04

0100b200 <bt_l2cap_server_lookup_psm>:
	return list->head;
 100b200:	4a05      	ldr	r2, [pc, #20]	; (100b218 <bt_l2cap_server_lookup_psm+0x18>)
{
 100b202:	4603      	mov	r3, r0
 100b204:	6810      	ldr	r0, [r2, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&servers, server, node) {
 100b206:	b130      	cbz	r0, 100b216 <bt_l2cap_server_lookup_psm+0x16>
		if (server->psm == psm) {
 100b208:	f830 2c08 	ldrh.w	r2, [r0, #-8]
	SYS_SLIST_FOR_EACH_CONTAINER(&servers, server, node) {
 100b20c:	3808      	subs	r0, #8
		if (server->psm == psm) {
 100b20e:	429a      	cmp	r2, r3
 100b210:	d001      	beq.n	100b216 <bt_l2cap_server_lookup_psm+0x16>
	return node->next;
 100b212:	6880      	ldr	r0, [r0, #8]
 100b214:	e7f7      	b.n	100b206 <bt_l2cap_server_lookup_psm+0x6>
}
 100b216:	4770      	bx	lr
 100b218:	21004750 	.word	0x21004750

0100b21c <bt_l2cap_init>:

BT_L2CAP_CHANNEL_DEFINE(le_fixed_chan, BT_L2CAP_CID_LE_SIG, l2cap_accept, NULL);

void bt_l2cap_init(void)
{
 100b21c:	b570      	push	{r4, r5, r6, lr}
 100b21e:	480a      	ldr	r0, [pc, #40]	; (100b248 <bt_l2cap_init+0x2c>)
 100b220:	f01e f857 	bl	10292d2 <z_impl_k_queue_init>
		bt_l2cap_br_init();
	}

#if defined(CONFIG_BT_L2CAP_DYNAMIC_CHANNEL)
	k_fifo_init(&free_l2cap_tx_meta_data);
	for (size_t i = 0; i < ARRAY_SIZE(l2cap_tx_meta_data_storage); i++) {
 100b224:	2500      	movs	r5, #0
 100b226:	4c09      	ldr	r4, [pc, #36]	; (100b24c <bt_l2cap_init+0x30>)
		(void)memset(&l2cap_tx_meta_data_storage[i], 0,
					sizeof(l2cap_tx_meta_data_storage[i]));
		k_fifo_put(&free_l2cap_tx_meta_data, &l2cap_tx_meta_data_storage[i]);
 100b228:	4e07      	ldr	r6, [pc, #28]	; (100b248 <bt_l2cap_init+0x2c>)
		(void)memset(&l2cap_tx_meta_data_storage[i], 0,
 100b22a:	2210      	movs	r2, #16
 100b22c:	2100      	movs	r1, #0
 100b22e:	4620      	mov	r0, r4
 100b230:	f01b fbab 	bl	102698a <memset>
	for (size_t i = 0; i < ARRAY_SIZE(l2cap_tx_meta_data_storage); i++) {
 100b234:	3501      	adds	r5, #1
		k_fifo_put(&free_l2cap_tx_meta_data, &l2cap_tx_meta_data_storage[i]);
 100b236:	4621      	mov	r1, r4
 100b238:	4630      	mov	r0, r6
 100b23a:	f01e f857 	bl	10292ec <k_queue_append>
	for (size_t i = 0; i < ARRAY_SIZE(l2cap_tx_meta_data_storage); i++) {
 100b23e:	2d03      	cmp	r5, #3
 100b240:	f104 0410 	add.w	r4, r4, #16
 100b244:	d1f1      	bne.n	100b22a <bt_l2cap_init+0xe>
	}
#endif /* CONFIG_BT_L2CAP_DYNAMIC_CHANNEL */
}
 100b246:	bd70      	pop	{r4, r5, r6, pc}
 100b248:	21000d44 	.word	0x21000d44
 100b24c:	21004758 	.word	0x21004758

0100b250 <l2cap_chan_le_recv_seg>:
{
 100b250:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100b254:	b08d      	sub	sp, #52	; 0x34
	uint16_t seg = 0U;
 100b256:	2300      	movs	r3, #0
{
 100b258:	460e      	mov	r6, r1
	len = net_buf_frags_len(chan->_sdu);
 100b25a:	6e01      	ldr	r1, [r0, #96]	; 0x60
{
 100b25c:	af04      	add	r7, sp, #16
 100b25e:	4604      	mov	r4, r0
	len = net_buf_frags_len(chan->_sdu);
 100b260:	4608      	mov	r0, r1
	uint16_t seg = 0U;
 100b262:	80fb      	strh	r3, [r7, #6]
	len = net_buf_frags_len(chan->_sdu);
 100b264:	f01c f86e 	bl	1027344 <net_buf_frags_len>
	if (len) {
 100b268:	b283      	uxth	r3, r0
	len = net_buf_frags_len(chan->_sdu);
 100b26a:	4605      	mov	r5, r0
	if (len) {
 100b26c:	b123      	cbz	r3, 100b278 <l2cap_chan_le_recv_seg+0x28>
		memcpy(&seg, net_buf_user_data(chan->_sdu), sizeof(seg));
 100b26e:	2202      	movs	r2, #2
 100b270:	3118      	adds	r1, #24
 100b272:	1db8      	adds	r0, r7, #6
 100b274:	f01b fb7e 	bl	1026974 <memcpy>
	if (len + buf->len > chan->_sdu_len) {
 100b278:	8a33      	ldrh	r3, [r6, #16]
 100b27a:	b2ad      	uxth	r5, r5
 100b27c:	441d      	add	r5, r3
 100b27e:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 100b282:	429d      	cmp	r5, r3
 100b284:	dd11      	ble.n	100b2aa <l2cap_chan_le_recv_seg+0x5a>
		LOG_ERR("SDU length mismatch");
 100b286:	4b4c      	ldr	r3, [pc, #304]	; (100b3b8 <l2cap_chan_le_recv_seg+0x168>)
		LOG_ERR("Unable to store SDU");
 100b288:	61fb      	str	r3, [r7, #28]
 100b28a:	2302      	movs	r3, #2
 100b28c:	484b      	ldr	r0, [pc, #300]	; (100b3bc <l2cap_chan_le_recv_seg+0x16c>)
 100b28e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100b292:	61bb      	str	r3, [r7, #24]
 100b294:	f107 0218 	add.w	r2, r7, #24
 100b298:	f01c f8f2 	bl	1027480 <z_log_msg_static_create.constprop.0>
		bt_l2cap_chan_disconnect(&chan->chan);
 100b29c:	4620      	mov	r0, r4
 100b29e:	f01c faaf 	bl	1027800 <bt_l2cap_chan_disconnect>
}
 100b2a2:	3724      	adds	r7, #36	; 0x24
 100b2a4:	46bd      	mov	sp, r7
 100b2a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	len = net_buf_append_bytes(chan->_sdu, buf->len, buf->data, K_NO_WAIT,
 100b2aa:	f04f 0800 	mov.w	r8, #0
 100b2ae:	f04f 0900 	mov.w	r9, #0
	seg++;
 100b2b2:	88fb      	ldrh	r3, [r7, #6]
	return (void *)buf->user_data;
 100b2b4:	6e20      	ldr	r0, [r4, #96]	; 0x60
 100b2b6:	3301      	adds	r3, #1
	memcpy(net_buf_user_data(chan->_sdu), &seg, sizeof(seg));
 100b2b8:	2202      	movs	r2, #2
 100b2ba:	1db9      	adds	r1, r7, #6
 100b2bc:	3018      	adds	r0, #24
	seg++;
 100b2be:	80fb      	strh	r3, [r7, #6]
	memcpy(net_buf_user_data(chan->_sdu), &seg, sizeof(seg));
 100b2c0:	f01b fb58 	bl	1026974 <memcpy>
	len = net_buf_append_bytes(chan->_sdu, buf->len, buf->data, K_NO_WAIT,
 100b2c4:	4b3e      	ldr	r3, [pc, #248]	; (100b3c0 <l2cap_chan_le_recv_seg+0x170>)
 100b2c6:	6e20      	ldr	r0, [r4, #96]	; 0x60
 100b2c8:	8a31      	ldrh	r1, [r6, #16]
 100b2ca:	68f2      	ldr	r2, [r6, #12]
 100b2cc:	9302      	str	r3, [sp, #8]
 100b2ce:	e9cd 8900 	strd	r8, r9, [sp]
 100b2d2:	9403      	str	r4, [sp, #12]
 100b2d4:	f013 f800 	bl	101e2d8 <net_buf_append_bytes>
	if (len != buf->len) {
 100b2d8:	8a33      	ldrh	r3, [r6, #16]
 100b2da:	b280      	uxth	r0, r0
 100b2dc:	4283      	cmp	r3, r0
 100b2de:	d001      	beq.n	100b2e4 <l2cap_chan_le_recv_seg+0x94>
		LOG_ERR("Unable to store SDU");
 100b2e0:	4b38      	ldr	r3, [pc, #224]	; (100b3c4 <l2cap_chan_le_recv_seg+0x174>)
 100b2e2:	e7d1      	b.n	100b288 <l2cap_chan_le_recv_seg+0x38>
	if (net_buf_frags_len(chan->_sdu) < chan->_sdu_len) {
 100b2e4:	6e25      	ldr	r5, [r4, #96]	; 0x60
 100b2e6:	4628      	mov	r0, r5
 100b2e8:	f01c f82c 	bl	1027344 <net_buf_frags_len>
 100b2ec:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 100b2f0:	4298      	cmp	r0, r3
 100b2f2:	d222      	bcs.n	100b33a <l2cap_chan_le_recv_seg+0xea>
		if (!atomic_get(&chan->rx.credits) &&
 100b2f4:	f104 031c 	add.w	r3, r4, #28
 100b2f8:	4618      	mov	r0, r3
 100b2fa:	f01c f869 	bl	10273d0 <atomic_get>
 100b2fe:	2800      	cmp	r0, #0
 100b300:	d1cf      	bne.n	100b2a2 <l2cap_chan_le_recv_seg+0x52>
 100b302:	8b61      	ldrh	r1, [r4, #26]
 100b304:	88fa      	ldrh	r2, [r7, #6]
 100b306:	4291      	cmp	r1, r2
 100b308:	d1cb      	bne.n	100b2a2 <l2cap_chan_le_recv_seg+0x52>
	atomic_val_t old_credits = atomic_get(&chan->rx.credits);
 100b30a:	4618      	mov	r0, r3
 100b30c:	f01c f860 	bl	10273d0 <atomic_get>
 100b310:	4605      	mov	r5, r0
	credits = ((chan->_sdu_len - net_buf_frags_len(buf)) +
 100b312:	4630      	mov	r0, r6
 100b314:	f01c f816 	bl	1027344 <net_buf_frags_len>
 100b318:	8b23      	ldrh	r3, [r4, #24]
 100b31a:	f8b4 1064 	ldrh.w	r1, [r4, #100]	; 0x64
 100b31e:	4419      	add	r1, r3
 100b320:	3901      	subs	r1, #1
 100b322:	1a09      	subs	r1, r1, r0
		   (chan->rx.mps - 1)) / chan->rx.mps;
 100b324:	fbb1 f1f3 	udiv	r1, r1, r3
	if (credits < old_credits) {
 100b328:	b28b      	uxth	r3, r1
 100b32a:	429d      	cmp	r5, r3
 100b32c:	dcb9      	bgt.n	100b2a2 <l2cap_chan_le_recv_seg+0x52>
	credits -= old_credits;
 100b32e:	1b49      	subs	r1, r1, r5
	l2cap_chan_send_credits(chan, buf, credits);
 100b330:	4620      	mov	r0, r4
 100b332:	b289      	uxth	r1, r1
 100b334:	f7ff fdfe 	bl	100af34 <l2cap_chan_send_credits.isra.0>
 100b338:	e7b3      	b.n	100b2a2 <l2cap_chan_le_recv_seg+0x52>
	chan->_sdu = NULL;
 100b33a:	2300      	movs	r3, #0
	__ASSERT_NO_MSG(bt_l2cap_chan_get_state(&chan->chan) == BT_L2CAP_CONNECTED);
 100b33c:	f894 6094 	ldrb.w	r6, [r4, #148]	; 0x94
	l2cap_chan_le_recv_sdu(chan, buf, seg);
 100b340:	f8b7 8006 	ldrh.w	r8, [r7, #6]
	__ASSERT_NO_MSG(bt_l2cap_chan_get_state(&chan->chan) == BT_L2CAP_CONNECTED);
 100b344:	2e03      	cmp	r6, #3
	chan->_sdu = NULL;
 100b346:	6623      	str	r3, [r4, #96]	; 0x60
	chan->_sdu_len = 0U;
 100b348:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
	__ASSERT_NO_MSG(bt_l2cap_chan_get_state(&chan->chan) == BT_L2CAP_CONNECTED);
 100b34c:	d00b      	beq.n	100b366 <l2cap_chan_le_recv_seg+0x116>
 100b34e:	491e      	ldr	r1, [pc, #120]	; (100b3c8 <l2cap_chan_le_recv_seg+0x178>)
 100b350:	481e      	ldr	r0, [pc, #120]	; (100b3cc <l2cap_chan_le_recv_seg+0x17c>)
 100b352:	f640 1367 	movw	r3, #2407	; 0x967
 100b356:	4a1e      	ldr	r2, [pc, #120]	; (100b3d0 <l2cap_chan_le_recv_seg+0x180>)
 100b358:	f019 fc3d 	bl	1024bd6 <assert_print>
 100b35c:	f640 1167 	movw	r1, #2407	; 0x967
 100b360:	481b      	ldr	r0, [pc, #108]	; (100b3d0 <l2cap_chan_le_recv_seg+0x180>)
 100b362:	f019 fc31 	bl	1024bc8 <assert_post_action>
	err = chan->chan.ops->recv(&chan->chan, buf);
 100b366:	6863      	ldr	r3, [r4, #4]
 100b368:	4629      	mov	r1, r5
 100b36a:	4620      	mov	r0, r4
 100b36c:	695b      	ldr	r3, [r3, #20]
 100b36e:	4798      	blx	r3
	if (err < 0) {
 100b370:	2800      	cmp	r0, #0
 100b372:	da17      	bge.n	100b3a4 <l2cap_chan_le_recv_seg+0x154>
		if (err != -EINPROGRESS) {
 100b374:	f110 0f77 	cmn.w	r0, #119	; 0x77
 100b378:	d093      	beq.n	100b2a2 <l2cap_chan_le_recv_seg+0x52>
			LOG_ERR("err %d", err);
 100b37a:	46e8      	mov	r8, sp
 100b37c:	b088      	sub	sp, #32
 100b37e:	aa04      	add	r2, sp, #16
 100b380:	4b14      	ldr	r3, [pc, #80]	; (100b3d4 <l2cap_chan_le_recv_seg+0x184>)
 100b382:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100b386:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100b38a:	480c      	ldr	r0, [pc, #48]	; (100b3bc <l2cap_chan_le_recv_seg+0x16c>)
 100b38c:	f842 6f10 	str.w	r6, [r2, #16]!
 100b390:	f01c f876 	bl	1027480 <z_log_msg_static_create.constprop.0>
			bt_l2cap_chan_disconnect(&chan->chan);
 100b394:	4620      	mov	r0, r4
 100b396:	46c5      	mov	sp, r8
 100b398:	f01c fa32 	bl	1027800 <bt_l2cap_chan_disconnect>
	net_buf_unref(buf);
 100b39c:	4628      	mov	r0, r5
 100b39e:	f012 fe1f 	bl	101dfe0 <net_buf_unref>
 100b3a2:	e77e      	b.n	100b2a2 <l2cap_chan_le_recv_seg+0x52>
	if (bt_l2cap_chan_get_state(&chan->chan) == BT_L2CAP_CONNECTED) {
 100b3a4:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
 100b3a8:	2b03      	cmp	r3, #3
 100b3aa:	d1f7      	bne.n	100b39c <l2cap_chan_le_recv_seg+0x14c>
		l2cap_chan_send_credits(chan, buf, seg);
 100b3ac:	4641      	mov	r1, r8
 100b3ae:	4620      	mov	r0, r4
 100b3b0:	f7ff fdc0 	bl	100af34 <l2cap_chan_send_credits.isra.0>
 100b3b4:	e7f2      	b.n	100b39c <l2cap_chan_le_recv_seg+0x14c>
 100b3b6:	bf00      	nop
 100b3b8:	0102de49 	.word	0x0102de49
 100b3bc:	010299c4 	.word	0x010299c4
 100b3c0:	010273c7 	.word	0x010273c7
 100b3c4:	0102de5d 	.word	0x0102de5d
 100b3c8:	0102dda5 	.word	0x0102dda5
 100b3cc:	0102b695 	.word	0x0102b695
 100b3d0:	0102dd3c 	.word	0x0102dd3c
 100b3d4:	0102b56a 	.word	0x0102b56a

0100b3d8 <l2cap_chan_le_recv>:
{
 100b3d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 100b3da:	4604      	mov	r4, r0
 100b3dc:	460d      	mov	r5, r1
 100b3de:	b087      	sub	sp, #28
	if (!test_and_dec(&chan->rx.credits)) {
 100b3e0:	f100 031c 	add.w	r3, r0, #28
{
 100b3e4:	af00      	add	r7, sp, #0
		old_value = atomic_get(target);
 100b3e6:	4618      	mov	r0, r3
 100b3e8:	f01b fff2 	bl	10273d0 <atomic_get>
		if (!old_value) {
 100b3ec:	2800      	cmp	r0, #0
 100b3ee:	d06f      	beq.n	100b4d0 <l2cap_chan_le_recv+0xf8>
		new_value = old_value - 1;
 100b3f0:	1e42      	subs	r2, r0, #1
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 100b3f2:	e8d3 1fef 	ldaex	r1, [r3]
 100b3f6:	4281      	cmp	r1, r0
 100b3f8:	d103      	bne.n	100b402 <l2cap_chan_le_recv+0x2a>
 100b3fa:	e8c3 2fe6 	stlex	r6, r2, [r3]
 100b3fe:	2e00      	cmp	r6, #0
 100b400:	d1f7      	bne.n	100b3f2 <l2cap_chan_le_recv+0x1a>
	} while (atomic_cas(target, old_value, new_value) == 0);
 100b402:	d1f0      	bne.n	100b3e6 <l2cap_chan_le_recv+0xe>
	if (buf->len > chan->rx.mps) {
 100b404:	8a2b      	ldrh	r3, [r5, #16]
 100b406:	8b21      	ldrh	r1, [r4, #24]
 100b408:	428b      	cmp	r3, r1
 100b40a:	d913      	bls.n	100b434 <l2cap_chan_le_recv+0x5c>
		LOG_WRN("PDU size > MPS (%u > %u)", buf->len, chan->rx.mps);
 100b40c:	466d      	mov	r5, sp
 100b40e:	b088      	sub	sp, #32
 100b410:	466a      	mov	r2, sp
 100b412:	4830      	ldr	r0, [pc, #192]	; (100b4d4 <l2cap_chan_le_recv+0xfc>)
 100b414:	61d1      	str	r1, [r2, #28]
 100b416:	e9c2 0305 	strd	r0, r3, [r2, #20]
 100b41a:	2304      	movs	r3, #4
 100b41c:	f44f 5102 	mov.w	r1, #8320	; 0x2080
 100b420:	f842 3f10 	str.w	r3, [r2, #16]!
			LOG_ERR("err %d", err);
 100b424:	482c      	ldr	r0, [pc, #176]	; (100b4d8 <l2cap_chan_le_recv+0x100>)
 100b426:	f01c f82b 	bl	1027480 <z_log_msg_static_create.constprop.0>
 100b42a:	46ad      	mov	sp, r5
		bt_l2cap_chan_disconnect(&chan->chan);
 100b42c:	4620      	mov	r0, r4
 100b42e:	f01c f9e7 	bl	1027800 <bt_l2cap_chan_disconnect>
		return;
 100b432:	e005      	b.n	100b440 <l2cap_chan_le_recv+0x68>
	if (chan->_sdu) {
 100b434:	6e22      	ldr	r2, [r4, #96]	; 0x60
 100b436:	b132      	cbz	r2, 100b446 <l2cap_chan_le_recv+0x6e>
		l2cap_chan_le_recv_seg(chan, buf);
 100b438:	4629      	mov	r1, r5
 100b43a:	4620      	mov	r0, r4
 100b43c:	f7ff ff08 	bl	100b250 <l2cap_chan_le_recv_seg>
}
 100b440:	371c      	adds	r7, #28
 100b442:	46bd      	mov	sp, r7
 100b444:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (buf->len < 2) {
 100b446:	2b01      	cmp	r3, #1
 100b448:	d80b      	bhi.n	100b462 <l2cap_chan_le_recv+0x8a>
		LOG_WRN("Too short data packet");
 100b44a:	4b24      	ldr	r3, [pc, #144]	; (100b4dc <l2cap_chan_le_recv+0x104>)
 100b44c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100b450:	617b      	str	r3, [r7, #20]
 100b452:	2302      	movs	r3, #2
 100b454:	f107 0210 	add.w	r2, r7, #16
 100b458:	613b      	str	r3, [r7, #16]
		LOG_ERR("No credits to receive packet");
 100b45a:	481f      	ldr	r0, [pc, #124]	; (100b4d8 <l2cap_chan_le_recv+0x100>)
 100b45c:	f01c f810 	bl	1027480 <z_log_msg_static_create.constprop.0>
 100b460:	e7e4      	b.n	100b42c <l2cap_chan_le_recv+0x54>
	return net_buf_simple_pull_le16(&buf->b);
 100b462:	f105 000c 	add.w	r0, r5, #12
 100b466:	f01d fc7f 	bl	1028d68 <net_buf_simple_pull_le16>
	if (sdu_len > chan->rx.mtu) {
 100b46a:	8ae3      	ldrh	r3, [r4, #22]
 100b46c:	4606      	mov	r6, r0
 100b46e:	4283      	cmp	r3, r0
 100b470:	d208      	bcs.n	100b484 <l2cap_chan_le_recv+0xac>
		LOG_ERR("Invalid SDU length");
 100b472:	4b1b      	ldr	r3, [pc, #108]	; (100b4e0 <l2cap_chan_le_recv+0x108>)
		LOG_ERR("No credits to receive packet");
 100b474:	617b      	str	r3, [r7, #20]
 100b476:	2302      	movs	r3, #2
 100b478:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100b47c:	613b      	str	r3, [r7, #16]
 100b47e:	f107 0210 	add.w	r2, r7, #16
 100b482:	e7ea      	b.n	100b45a <l2cap_chan_le_recv+0x82>
	if (chan->chan.ops->alloc_buf) {
 100b484:	6863      	ldr	r3, [r4, #4]
 100b486:	691a      	ldr	r2, [r3, #16]
 100b488:	b142      	cbz	r2, 100b49c <l2cap_chan_le_recv+0xc4>
		chan->_sdu = chan->chan.ops->alloc_buf(&chan->chan);
 100b48a:	4620      	mov	r0, r4
 100b48c:	4790      	blx	r2
 100b48e:	6620      	str	r0, [r4, #96]	; 0x60
		if (!chan->_sdu) {
 100b490:	b908      	cbnz	r0, 100b496 <l2cap_chan_le_recv+0xbe>
			LOG_ERR("Unable to allocate buffer for SDU");
 100b492:	4b14      	ldr	r3, [pc, #80]	; (100b4e4 <l2cap_chan_le_recv+0x10c>)
 100b494:	e7ee      	b.n	100b474 <l2cap_chan_le_recv+0x9c>
		chan->_sdu_len = sdu_len;
 100b496:	f8a4 6064 	strh.w	r6, [r4, #100]	; 0x64
 100b49a:	e7cd      	b.n	100b438 <l2cap_chan_le_recv+0x60>
	err = chan->chan.ops->recv(&chan->chan, buf);
 100b49c:	4629      	mov	r1, r5
 100b49e:	4620      	mov	r0, r4
 100b4a0:	695b      	ldr	r3, [r3, #20]
 100b4a2:	4798      	blx	r3
	if (err < 0) {
 100b4a4:	2800      	cmp	r0, #0
 100b4a6:	da0e      	bge.n	100b4c6 <l2cap_chan_le_recv+0xee>
		if (err != -EINPROGRESS) {
 100b4a8:	f110 0f77 	cmn.w	r0, #119	; 0x77
 100b4ac:	d0c8      	beq.n	100b440 <l2cap_chan_le_recv+0x68>
			LOG_ERR("err %d", err);
 100b4ae:	466d      	mov	r5, sp
 100b4b0:	b088      	sub	sp, #32
 100b4b2:	466a      	mov	r2, sp
 100b4b4:	4b0c      	ldr	r3, [pc, #48]	; (100b4e8 <l2cap_chan_le_recv+0x110>)
 100b4b6:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100b4ba:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100b4be:	2303      	movs	r3, #3
 100b4c0:	f842 3f10 	str.w	r3, [r2, #16]!
 100b4c4:	e7ae      	b.n	100b424 <l2cap_chan_le_recv+0x4c>
	l2cap_chan_send_credits(chan, buf, 1);
 100b4c6:	2101      	movs	r1, #1
 100b4c8:	4620      	mov	r0, r4
 100b4ca:	f7ff fd33 	bl	100af34 <l2cap_chan_send_credits.isra.0>
 100b4ce:	e7b7      	b.n	100b440 <l2cap_chan_le_recv+0x68>
		LOG_ERR("No credits to receive packet");
 100b4d0:	4b06      	ldr	r3, [pc, #24]	; (100b4ec <l2cap_chan_le_recv+0x114>)
 100b4d2:	e7cf      	b.n	100b474 <l2cap_chan_le_recv+0x9c>
 100b4d4:	0102de71 	.word	0x0102de71
 100b4d8:	010299c4 	.word	0x010299c4
 100b4dc:	0102de8a 	.word	0x0102de8a
 100b4e0:	0102dea0 	.word	0x0102dea0
 100b4e4:	0102deb3 	.word	0x0102deb3
 100b4e8:	0102b56a 	.word	0x0102b56a
 100b4ec:	0102ded5 	.word	0x0102ded5

0100b4f0 <bt_l2cap_recv>:
{
 100b4f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 100b4f2:	b087      	sub	sp, #28
	if (buf->len < sizeof(*hdr)) {
 100b4f4:	8a0b      	ldrh	r3, [r1, #16]
{
 100b4f6:	4605      	mov	r5, r0
	if (buf->len < sizeof(*hdr)) {
 100b4f8:	2b03      	cmp	r3, #3
{
 100b4fa:	460c      	mov	r4, r1
 100b4fc:	4616      	mov	r6, r2
 100b4fe:	af00      	add	r7, sp, #0
	if (buf->len < sizeof(*hdr)) {
 100b500:	d80b      	bhi.n	100b51a <bt_l2cap_recv+0x2a>
		LOG_ERR("Too small L2CAP PDU received");
 100b502:	4b31      	ldr	r3, [pc, #196]	; (100b5c8 <bt_l2cap_recv+0xd8>)
 100b504:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100b508:	617b      	str	r3, [r7, #20]
 100b50a:	2302      	movs	r3, #2
 100b50c:	f107 0210 	add.w	r2, r7, #16
 100b510:	613b      	str	r3, [r7, #16]
		LOG_WRN("Ignoring data received while channel has shutdown");
 100b512:	482e      	ldr	r0, [pc, #184]	; (100b5cc <bt_l2cap_recv+0xdc>)
 100b514:	f01b ffb4 	bl	1027480 <z_log_msg_static_create.constprop.0>
		net_buf_unref(buf);
 100b518:	e019      	b.n	100b54e <bt_l2cap_recv+0x5e>
	return net_buf_simple_pull_mem(&buf->b, len);
 100b51a:	2104      	movs	r1, #4
 100b51c:	f104 000c 	add.w	r0, r4, #12
 100b520:	f012 fe9c 	bl	101e25c <net_buf_simple_pull_mem>
	cid = sys_le16_to_cpu(hdr->cid);
 100b524:	8841      	ldrh	r1, [r0, #2]
	chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
 100b526:	4628      	mov	r0, r5
 100b528:	f01c f937 	bl	102779a <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
 100b52c:	4605      	mov	r5, r0
 100b52e:	b990      	cbnz	r0, 100b556 <bt_l2cap_recv+0x66>
		LOG_WRN("Ignoring data for unknown channel ID 0x%04x", cid);
 100b530:	466d      	mov	r5, sp
 100b532:	b088      	sub	sp, #32
 100b534:	466a      	mov	r2, sp
 100b536:	4b26      	ldr	r3, [pc, #152]	; (100b5d0 <bt_l2cap_recv+0xe0>)
 100b538:	4824      	ldr	r0, [pc, #144]	; (100b5cc <bt_l2cap_recv+0xdc>)
 100b53a:	e9c2 3105 	strd	r3, r1, [r2, #20]
 100b53e:	2303      	movs	r3, #3
 100b540:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100b544:	f842 3f10 	str.w	r3, [r2, #16]!
 100b548:	f01b ff9a 	bl	1027480 <z_log_msg_static_create.constprop.0>
 100b54c:	46ad      	mov	sp, r5
	net_buf_unref(buf);
 100b54e:	4620      	mov	r0, r4
 100b550:	f012 fd46 	bl	101dfe0 <net_buf_unref>
 100b554:	e02c      	b.n	100b5b0 <bt_l2cap_recv+0xc0>
	if (L2CAP_LE_CID_IS_DYN(le_chan->rx.cid)) {
 100b556:	8a83      	ldrh	r3, [r0, #20]
 100b558:	3b40      	subs	r3, #64	; 0x40
 100b55a:	b29b      	uxth	r3, r3
 100b55c:	2b3f      	cmp	r3, #63	; 0x3f
 100b55e:	d82d      	bhi.n	100b5bc <bt_l2cap_recv+0xcc>
		if (complete) {
 100b560:	b34e      	cbz	r6, 100b5b6 <bt_l2cap_recv+0xc6>
	if (chan->state == BT_L2CAP_DISCONNECTING) {
 100b562:	f890 3094 	ldrb.w	r3, [r0, #148]	; 0x94
 100b566:	2b04      	cmp	r3, #4
 100b568:	d108      	bne.n	100b57c <bt_l2cap_recv+0x8c>
		LOG_WRN("Ignoring data received while disconnecting");
 100b56a:	4b1a      	ldr	r3, [pc, #104]	; (100b5d4 <bt_l2cap_recv+0xe4>)
		LOG_WRN("Ignoring data received while channel has shutdown");
 100b56c:	617b      	str	r3, [r7, #20]
 100b56e:	2302      	movs	r3, #2
 100b570:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100b574:	613b      	str	r3, [r7, #16]
 100b576:	f107 0210 	add.w	r2, r7, #16
 100b57a:	e7ca      	b.n	100b512 <bt_l2cap_recv+0x22>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
 100b57c:	3010      	adds	r0, #16
 100b57e:	f01b ff27 	bl	10273d0 <atomic_get>
	if (atomic_test_bit(chan->chan.status, BT_L2CAP_STATUS_SHUTDOWN)) {
 100b582:	0783      	lsls	r3, r0, #30
 100b584:	d501      	bpl.n	100b58a <bt_l2cap_recv+0x9a>
		LOG_WRN("Ignoring data received while channel has shutdown");
 100b586:	4b14      	ldr	r3, [pc, #80]	; (100b5d8 <bt_l2cap_recv+0xe8>)
 100b588:	e7f0      	b.n	100b56c <bt_l2cap_recv+0x7c>
	if (!L2CAP_LE_PSM_IS_DYN(chan->psm)) {
 100b58a:	f8b5 3096 	ldrh.w	r3, [r5, #150]	; 0x96
		l2cap_chan_le_recv(chan, buf);
 100b58e:	4621      	mov	r1, r4
	if (!L2CAP_LE_PSM_IS_DYN(chan->psm)) {
 100b590:	3b80      	subs	r3, #128	; 0x80
 100b592:	b29b      	uxth	r3, r3
 100b594:	2b7f      	cmp	r3, #127	; 0x7f
 100b596:	d903      	bls.n	100b5a0 <bt_l2cap_recv+0xb0>
		l2cap_chan_le_recv(chan, buf);
 100b598:	4628      	mov	r0, r5
 100b59a:	f7ff ff1d 	bl	100b3d8 <l2cap_chan_le_recv>
		net_buf_unref(buf);
 100b59e:	e7d6      	b.n	100b54e <bt_l2cap_recv+0x5e>
	net_buf_put(&chan->rx_queue, buf);
 100b5a0:	f105 0078 	add.w	r0, r5, #120	; 0x78
 100b5a4:	f012 fcf6 	bl	101df94 <net_buf_put>
	k_work_submit(&chan->rx_work);
 100b5a8:	f105 0068 	add.w	r0, r5, #104	; 0x68
 100b5ac:	f016 fc26 	bl	1021dfc <k_work_submit>
}
 100b5b0:	371c      	adds	r7, #28
 100b5b2:	46bd      	mov	sp, r7
 100b5b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
			bt_l2cap_chan_disconnect(chan);
 100b5b6:	f01c f923 	bl	1027800 <bt_l2cap_chan_disconnect>
			net_buf_unref(buf);
 100b5ba:	e7c8      	b.n	100b54e <bt_l2cap_recv+0x5e>
	chan->ops->recv(chan, buf);
 100b5bc:	6843      	ldr	r3, [r0, #4]
 100b5be:	4621      	mov	r1, r4
 100b5c0:	695b      	ldr	r3, [r3, #20]
 100b5c2:	4798      	blx	r3
 100b5c4:	e7c3      	b.n	100b54e <bt_l2cap_recv+0x5e>
 100b5c6:	bf00      	nop
 100b5c8:	0102def2 	.word	0x0102def2
 100b5cc:	010299c4 	.word	0x010299c4
 100b5d0:	0102df0f 	.word	0x0102df0f
 100b5d4:	0102df3b 	.word	0x0102df3b
 100b5d8:	0102df66 	.word	0x0102df66

0100b5dc <l2cap_recv>:
{
 100b5dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100b5e0:	b08d      	sub	sp, #52	; 0x34
	if (buf->len < sizeof(*hdr)) {
 100b5e2:	8a0b      	ldrh	r3, [r1, #16]
{
 100b5e4:	4604      	mov	r4, r0
	if (buf->len < sizeof(*hdr)) {
 100b5e6:	2b03      	cmp	r3, #3
{
 100b5e8:	4688      	mov	r8, r1
 100b5ea:	af00      	add	r7, sp, #0
	if (buf->len < sizeof(*hdr)) {
 100b5ec:	d80f      	bhi.n	100b60e <l2cap_recv+0x32>
		LOG_ERR("Too small L2CAP signaling PDU");
 100b5ee:	4ba4      	ldr	r3, [pc, #656]	; (100b880 <l2cap_recv+0x2a4>)
		LOG_ERR("Invalid ident value in L2CAP PDU");
 100b5f0:	62fb      	str	r3, [r7, #44]	; 0x2c
 100b5f2:	2302      	movs	r3, #2
 100b5f4:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100b5f8:	48a2      	ldr	r0, [pc, #648]	; (100b884 <l2cap_recv+0x2a8>)
 100b5fa:	62bb      	str	r3, [r7, #40]	; 0x28
 100b5fc:	f107 0228 	add.w	r2, r7, #40	; 0x28
 100b600:	f01b ff3e 	bl	1027480 <z_log_msg_static_create.constprop.0>
}
 100b604:	2000      	movs	r0, #0
 100b606:	3734      	adds	r7, #52	; 0x34
 100b608:	46bd      	mov	sp, r7
 100b60a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 100b60e:	2104      	movs	r1, #4
 100b610:	f108 000c 	add.w	r0, r8, #12
 100b614:	f012 fe22 	bl	101e25c <net_buf_simple_pull_mem>
	if (buf->len != len) {
 100b618:	f8b8 3010 	ldrh.w	r3, [r8, #16]
	len = sys_le16_to_cpu(hdr->len);
 100b61c:	8841      	ldrh	r1, [r0, #2]
 100b61e:	4606      	mov	r6, r0
	if (buf->len != len) {
 100b620:	428b      	cmp	r3, r1
 100b622:	d010      	beq.n	100b646 <l2cap_recv+0x6a>
		LOG_ERR("L2CAP length mismatch (%u != %u)", buf->len, len);
 100b624:	466c      	mov	r4, sp
 100b626:	b088      	sub	sp, #32
 100b628:	466a      	mov	r2, sp
 100b62a:	4897      	ldr	r0, [pc, #604]	; (100b888 <l2cap_recv+0x2ac>)
 100b62c:	61d1      	str	r1, [r2, #28]
 100b62e:	e9c2 0305 	strd	r0, r3, [r2, #20]
 100b632:	2304      	movs	r3, #4
 100b634:	f44f 5101 	mov.w	r1, #8256	; 0x2040
 100b638:	f842 3f10 	str.w	r3, [r2, #16]!
		LOG_ERR("Cannot find channel for ident %u", ident);
 100b63c:	4891      	ldr	r0, [pc, #580]	; (100b884 <l2cap_recv+0x2a8>)
 100b63e:	f01b ff1f 	bl	1027480 <z_log_msg_static_create.constprop.0>
 100b642:	46a5      	mov	sp, r4
		return;
 100b644:	e7de      	b.n	100b604 <l2cap_recv+0x28>
	if (!hdr->ident) {
 100b646:	7845      	ldrb	r5, [r0, #1]
 100b648:	b90d      	cbnz	r5, 100b64e <l2cap_recv+0x72>
		LOG_ERR("Invalid ident value in L2CAP PDU");
 100b64a:	4b90      	ldr	r3, [pc, #576]	; (100b88c <l2cap_recv+0x2b0>)
 100b64c:	e7d0      	b.n	100b5f0 <l2cap_recv+0x14>
	switch (hdr->code) {
 100b64e:	7802      	ldrb	r2, [r0, #0]
 100b650:	2a01      	cmp	r2, #1
 100b652:	f000 8217 	beq.w	100ba84 <l2cap_recv+0x4a8>
 100b656:	1f91      	subs	r1, r2, #6
 100b658:	b2c8      	uxtb	r0, r1
 100b65a:	2810      	cmp	r0, #16
 100b65c:	f200 8217 	bhi.w	100ba8e <l2cap_recv+0x4b2>
 100b660:	2910      	cmp	r1, #16
 100b662:	f200 8214 	bhi.w	100ba8e <l2cap_recv+0x4b2>
 100b666:	e8df f011 	tbh	[pc, r1, lsl #1]
 100b66a:	018c      	.short	0x018c
 100b66c:	021201d3 	.word	0x021201d3
 100b670:	02120212 	.word	0x02120212
 100b674:	02120212 	.word	0x02120212
 100b678:	02120212 	.word	0x02120212
 100b67c:	02120212 	.word	0x02120212
 100b680:	02120212 	.word	0x02120212
 100b684:	00150011 	.word	0x00150011
 100b688:	01e000e2 	.word	0x01e000e2
	if (buf->len < sizeof(*rsp)) {
 100b68c:	2b01      	cmp	r3, #1
 100b68e:	d8b9      	bhi.n	100b604 <l2cap_recv+0x28>
		LOG_ERR("Too small LE conn param rsp");
 100b690:	4b7f      	ldr	r3, [pc, #508]	; (100b890 <l2cap_recv+0x2b4>)
 100b692:	e7ad      	b.n	100b5f0 <l2cap_recv+0x14>
	if (buf->len < sizeof(*req)) {
 100b694:	2b09      	cmp	r3, #9
 100b696:	6824      	ldr	r4, [r4, #0]
	struct bt_l2cap_le_conn_req *req = (void *)buf->data;
 100b698:	f8d8 200c 	ldr.w	r2, [r8, #12]
	if (buf->len < sizeof(*req)) {
 100b69c:	d801      	bhi.n	100b6a2 <l2cap_recv+0xc6>
		LOG_ERR("Too small LE conn req packet size");
 100b69e:	4b7d      	ldr	r3, [pc, #500]	; (100b894 <l2cap_recv+0x2b8>)
 100b6a0:	e7a6      	b.n	100b5f0 <l2cap_recv+0x14>
	mtu = sys_le16_to_cpu(req->mtu);
 100b6a2:	8893      	ldrh	r3, [r2, #4]
	scid = sys_le16_to_cpu(req->scid);
 100b6a4:	f8b2 a002 	ldrh.w	sl, [r2, #2]
	mtu = sys_le16_to_cpu(req->mtu);
 100b6a8:	60fb      	str	r3, [r7, #12]
	mps = sys_le16_to_cpu(req->mps);
 100b6aa:	f8b2 9006 	ldrh.w	r9, [r2, #6]
	psm = sys_le16_to_cpu(req->psm);
 100b6ae:	8816      	ldrh	r6, [r2, #0]
	credits = sys_le16_to_cpu(req->credits);
 100b6b0:	8912      	ldrh	r2, [r2, #8]
	mtu = sys_le16_to_cpu(req->mtu);
 100b6b2:	89b9      	ldrh	r1, [r7, #12]
	credits = sys_le16_to_cpu(req->credits);
 100b6b4:	60ba      	str	r2, [r7, #8]
 100b6b6:	893a      	ldrh	r2, [r7, #8]
	if (mtu < L2CAP_LE_MIN_MTU || mps < L2CAP_LE_MIN_MTU) {
 100b6b8:	2916      	cmp	r1, #22
	scid = sys_le16_to_cpu(req->scid);
 100b6ba:	fa1f fb8a 	uxth.w	fp, sl
	mps = sys_le16_to_cpu(req->mps);
 100b6be:	fa1f f389 	uxth.w	r3, r9
	credits = sys_le16_to_cpu(req->credits);
 100b6c2:	607a      	str	r2, [r7, #4]
	if (mtu < L2CAP_LE_MIN_MTU || mps < L2CAP_LE_MIN_MTU) {
 100b6c4:	d901      	bls.n	100b6ca <l2cap_recv+0xee>
 100b6c6:	2b16      	cmp	r3, #22
 100b6c8:	d801      	bhi.n	100b6ce <l2cap_recv+0xf2>
		LOG_ERR("Invalid LE-Conn Req params");
 100b6ca:	4b73      	ldr	r3, [pc, #460]	; (100b898 <l2cap_recv+0x2bc>)
 100b6cc:	e790      	b.n	100b5f0 <l2cap_recv+0x14>
	buf = l2cap_create_le_sig_pdu(buf, BT_L2CAP_LE_CONN_RSP, ident,
 100b6ce:	220a      	movs	r2, #10
 100b6d0:	4629      	mov	r1, r5
 100b6d2:	2015      	movs	r0, #21
 100b6d4:	f7ff fa48 	bl	100ab68 <l2cap_create_le_sig_pdu.constprop.0>
	if (!buf) {
 100b6d8:	4680      	mov	r8, r0
 100b6da:	2800      	cmp	r0, #0
 100b6dc:	d092      	beq.n	100b604 <l2cap_recv+0x28>
	return net_buf_simple_add(&buf->b, len);
 100b6de:	210a      	movs	r1, #10
 100b6e0:	300c      	adds	r0, #12
 100b6e2:	f012 fdd9 	bl	101e298 <net_buf_simple_add>
	(void)memset(rsp, 0, sizeof(*rsp));
 100b6e6:	220a      	movs	r2, #10
 100b6e8:	2100      	movs	r1, #0
 100b6ea:	4605      	mov	r5, r0
 100b6ec:	f01b f94d 	bl	102698a <memset>
	server = bt_l2cap_server_lookup_psm(psm);
 100b6f0:	4630      	mov	r0, r6
 100b6f2:	f7ff fd85 	bl	100b200 <bt_l2cap_server_lookup_psm>
	if (!server) {
 100b6f6:	4606      	mov	r6, r0
 100b6f8:	2800      	cmp	r0, #0
 100b6fa:	f000 8096 	beq.w	100b82a <l2cap_recv+0x24e>
	const struct bt_keys *keys = bt_keys_find_addr(conn->id, &conn->le.dst);
 100b6fe:	7a20      	ldrb	r0, [r4, #8]
 100b700:	f104 0190 	add.w	r1, r4, #144	; 0x90
 100b704:	f005 f8cc 	bl	10108a0 <bt_keys_find_addr>
	if (conn->sec_level >= server->sec_level) {
 100b708:	7a63      	ldrb	r3, [r4, #9]
 100b70a:	78b2      	ldrb	r2, [r6, #2]
 100b70c:	429a      	cmp	r2, r3
 100b70e:	d805      	bhi.n	100b71c <l2cap_recv+0x140>
	if (!L2CAP_LE_CID_IS_DYN(scid)) {
 100b710:	f1ab 0340 	sub.w	r3, fp, #64	; 0x40
 100b714:	2b3f      	cmp	r3, #63	; 0x3f
 100b716:	d917      	bls.n	100b748 <l2cap_recv+0x16c>
		return BT_L2CAP_LE_ERR_INVALID_SCID;
 100b718:	2309      	movs	r3, #9
 100b71a:	e00a      	b.n	100b732 <l2cap_recv+0x156>
	if (conn->sec_level > BT_SECURITY_L1) {
 100b71c:	2b01      	cmp	r3, #1
 100b71e:	d811      	bhi.n	100b744 <l2cap_recv+0x168>
	if (keys) {
 100b720:	b180      	cbz	r0, 100b744 <l2cap_recv+0x168>
		if (conn->role == BT_HCI_ROLE_CENTRAL) {
 100b722:	78e2      	ldrb	r2, [r4, #3]
			ltk_present = keys->keys & (BT_KEYS_LTK_P256 | BT_KEYS_PERIPH_LTK);
 100b724:	89c3      	ldrh	r3, [r0, #14]
		if (conn->role == BT_HCI_ROLE_CENTRAL) {
 100b726:	b952      	cbnz	r2, 100b73e <l2cap_recv+0x162>
		return BT_L2CAP_LE_ERR_ENCRYPTION;
 100b728:	f013 0f21 	tst.w	r3, #33	; 0x21
 100b72c:	bf0c      	ite	eq
 100b72e:	2305      	moveq	r3, #5
 100b730:	2308      	movne	r3, #8
	l2cap_send(conn, BT_L2CAP_CID_LE_SIG, buf);
 100b732:	4641      	mov	r1, r8
 100b734:	4620      	mov	r0, r4
		rsp->result = sys_cpu_to_le16(BT_L2CAP_LE_ERR_PSM_NOT_SUPP);
 100b736:	812b      	strh	r3, [r5, #8]
	l2cap_send(conn, BT_L2CAP_CID_LE_SIG, buf);
 100b738:	f01b ff94 	bl	1027664 <l2cap_send.constprop.0>
 100b73c:	e762      	b.n	100b604 <l2cap_recv+0x28>
		return BT_L2CAP_LE_ERR_ENCRYPTION;
 100b73e:	f013 0f24 	tst.w	r3, #36	; 0x24
 100b742:	e7f3      	b.n	100b72c <l2cap_recv+0x150>
	return BT_L2CAP_LE_ERR_AUTHENTICATION;
 100b744:	2305      	movs	r3, #5
 100b746:	e7f4      	b.n	100b732 <l2cap_recv+0x156>
	*chan = bt_l2cap_le_lookup_tx_cid(conn, scid);
 100b748:	4659      	mov	r1, fp
 100b74a:	4620      	mov	r0, r4
 100b74c:	f01c f811 	bl	1027772 <bt_l2cap_le_lookup_tx_cid>
 100b750:	6178      	str	r0, [r7, #20]
	if (*chan) {
 100b752:	2800      	cmp	r0, #0
 100b754:	d165      	bne.n	100b822 <l2cap_recv+0x246>
	err = server->accept(conn, chan);
 100b756:	4620      	mov	r0, r4
 100b758:	6873      	ldr	r3, [r6, #4]
 100b75a:	f107 0114 	add.w	r1, r7, #20
 100b75e:	4798      	blx	r3
	if (err < 0) {
 100b760:	2800      	cmp	r0, #0
 100b762:	da12      	bge.n	100b78a <l2cap_recv+0x1ae>
	switch (err) {
 100b764:	f110 0f0c 	cmn.w	r0, #12
 100b768:	d00d      	beq.n	100b786 <l2cap_recv+0x1aa>
 100b76a:	f110 0f0b 	cmn.w	r0, #11
 100b76e:	da06      	bge.n	100b77e <l2cap_recv+0x1a2>
 100b770:	f110 0f86 	cmn.w	r0, #134	; 0x86
 100b774:	d059      	beq.n	100b82a <l2cap_recv+0x24e>
 100b776:	300d      	adds	r0, #13
 100b778:	d055      	beq.n	100b826 <l2cap_recv+0x24a>
		return BT_L2CAP_LE_ERR_UNACCEPT_PARAMS;
 100b77a:	230b      	movs	r3, #11
 100b77c:	e7d9      	b.n	100b732 <l2cap_recv+0x156>
	switch (err) {
 100b77e:	3001      	adds	r0, #1
 100b780:	d1fb      	bne.n	100b77a <l2cap_recv+0x19e>
 100b782:	2307      	movs	r3, #7
		goto rsp;
 100b784:	e7d5      	b.n	100b732 <l2cap_recv+0x156>
		return BT_L2CAP_LE_ERR_NO_RESOURCES;
 100b786:	2304      	movs	r3, #4
 100b788:	e7d3      	b.n	100b732 <l2cap_recv+0x156>
	if (!(*chan)->ops->recv) {
 100b78a:	f8d7 b014 	ldr.w	fp, [r7, #20]
 100b78e:	f8db 3004 	ldr.w	r3, [fp, #4]
 100b792:	695b      	ldr	r3, [r3, #20]
 100b794:	b95b      	cbnz	r3, 100b7ae <l2cap_recv+0x1d2>
		LOG_ERR("Mandatory callback 'recv' missing");
 100b796:	4b41      	ldr	r3, [pc, #260]	; (100b89c <l2cap_recv+0x2c0>)
 100b798:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100b79c:	62fb      	str	r3, [r7, #44]	; 0x2c
 100b79e:	2302      	movs	r3, #2
 100b7a0:	4838      	ldr	r0, [pc, #224]	; (100b884 <l2cap_recv+0x2a8>)
 100b7a2:	62bb      	str	r3, [r7, #40]	; 0x28
 100b7a4:	f107 0228 	add.w	r2, r7, #40	; 0x28
 100b7a8:	f01b fe6a 	bl	1027480 <z_log_msg_static_create.constprop.0>
	if (result != BT_L2CAP_LE_SUCCESS) {
 100b7ac:	e7e5      	b.n	100b77a <l2cap_recv+0x19e>
	le_chan->required_sec_level = server->sec_level;
 100b7ae:	78b3      	ldrb	r3, [r6, #2]
	if (!l2cap_chan_add(conn, *chan, l2cap_chan_destroy)) {
 100b7b0:	4659      	mov	r1, fp
 100b7b2:	4620      	mov	r0, r4
 100b7b4:	4a3a      	ldr	r2, [pc, #232]	; (100b8a0 <l2cap_recv+0x2c4>)
	le_chan->required_sec_level = server->sec_level;
 100b7b6:	f88b 3099 	strb.w	r3, [fp, #153]	; 0x99
	if (!l2cap_chan_add(conn, *chan, l2cap_chan_destroy)) {
 100b7ba:	f7ff fc81 	bl	100b0c0 <l2cap_chan_add>
 100b7be:	2800      	cmp	r0, #0
 100b7c0:	d0e1      	beq.n	100b786 <l2cap_recv+0x1aa>
	l2cap_chan_tx_init(le_chan);
 100b7c2:	4658      	mov	r0, fp
 100b7c4:	f7ff fa66 	bl	100ac94 <l2cap_chan_tx_init>
	le_chan->tx.mtu = mtu;
 100b7c8:	89bb      	ldrh	r3, [r7, #12]
	l2cap_chan_tx_give_credits(le_chan, credits);
 100b7ca:	6879      	ldr	r1, [r7, #4]
	le_chan->tx.mtu = mtu;
 100b7cc:	f8ab 3026 	strh.w	r3, [fp, #38]	; 0x26
	le_chan->tx.init_credits = credits;
 100b7d0:	893b      	ldrh	r3, [r7, #8]
	l2cap_chan_tx_give_credits(le_chan, credits);
 100b7d2:	4658      	mov	r0, fp
	le_chan->tx.init_credits = credits;
 100b7d4:	f8ab 302a 	strh.w	r3, [fp, #42]	; 0x2a
	le_chan->tx.cid = scid;
 100b7d8:	f8ab a024 	strh.w	sl, [fp, #36]	; 0x24
	le_chan->tx.mps = mps;
 100b7dc:	f8ab 9028 	strh.w	r9, [fp, #40]	; 0x28
	l2cap_chan_tx_give_credits(le_chan, credits);
 100b7e0:	f01b fe59 	bl	1027496 <l2cap_chan_tx_give_credits>
	l2cap_chan_rx_init(le_chan);
 100b7e4:	4658      	mov	r0, fp
 100b7e6:	f7ff fa13 	bl	100ac10 <l2cap_chan_rx_init>
	atomic_add(&chan->rx.credits, credits);
 100b7ea:	f10b 001c 	add.w	r0, fp, #28
 100b7ee:	f8bb 101a 	ldrh.w	r1, [fp, #26]
 100b7f2:	f01b fe48 	bl	1027486 <atomic_add.isra.0>
	le_chan->psm = server->psm;
 100b7f6:	8833      	ldrh	r3, [r6, #0]
	bt_l2cap_chan_set_state(*chan, BT_L2CAP_CONNECTED);
 100b7f8:	6978      	ldr	r0, [r7, #20]
	le_chan->psm = server->psm;
 100b7fa:	f8ab 3096 	strh.w	r3, [fp, #150]	; 0x96
	BT_L2CAP_LE_CHAN(chan)->state = state;
 100b7fe:	2303      	movs	r3, #3
 100b800:	f880 3094 	strb.w	r3, [r0, #148]	; 0x94
	if ((*chan)->ops->connected) {
 100b804:	6843      	ldr	r3, [r0, #4]
 100b806:	681b      	ldr	r3, [r3, #0]
 100b808:	b103      	cbz	r3, 100b80c <l2cap_recv+0x230>
		(*chan)->ops->connected(*chan);
 100b80a:	4798      	blx	r3
	le_chan = BT_L2CAP_LE_CHAN(chan);
 100b80c:	697b      	ldr	r3, [r7, #20]
	rsp->dcid = sys_cpu_to_le16(le_chan->rx.cid);
 100b80e:	8a9a      	ldrh	r2, [r3, #20]
 100b810:	802a      	strh	r2, [r5, #0]
	rsp->mps = sys_cpu_to_le16(le_chan->rx.mps);
 100b812:	8b1a      	ldrh	r2, [r3, #24]
 100b814:	80aa      	strh	r2, [r5, #4]
	rsp->mtu = sys_cpu_to_le16(le_chan->rx.mtu);
 100b816:	8ada      	ldrh	r2, [r3, #22]
 100b818:	806a      	strh	r2, [r5, #2]
	rsp->credits = sys_cpu_to_le16(le_chan->rx.init_credits);
 100b81a:	8b5b      	ldrh	r3, [r3, #26]
 100b81c:	80eb      	strh	r3, [r5, #6]
 100b81e:	2300      	movs	r3, #0
 100b820:	e787      	b.n	100b732 <l2cap_recv+0x156>
		return BT_L2CAP_LE_ERR_SCID_IN_USE;
 100b822:	230a      	movs	r3, #10
 100b824:	e785      	b.n	100b732 <l2cap_recv+0x156>
		return BT_L2CAP_LE_ERR_AUTHORIZATION;
 100b826:	2306      	movs	r3, #6
 100b828:	e783      	b.n	100b732 <l2cap_recv+0x156>
 100b82a:	2302      	movs	r3, #2
 100b82c:	e781      	b.n	100b732 <l2cap_recv+0x156>
	if (buf->len < sizeof(*rsp)) {
 100b82e:	2b09      	cmp	r3, #9
 100b830:	6826      	ldr	r6, [r4, #0]
	struct bt_l2cap_le_conn_rsp *rsp = (void *)buf->data;
 100b832:	f8d8 200c 	ldr.w	r2, [r8, #12]
	if (buf->len < sizeof(*rsp)) {
 100b836:	d801      	bhi.n	100b83c <l2cap_recv+0x260>
		LOG_ERR("Too small LE conn rsp packet size");
 100b838:	4b1a      	ldr	r3, [pc, #104]	; (100b8a4 <l2cap_recv+0x2c8>)
 100b83a:	e6d9      	b.n	100b5f0 <l2cap_recv+0x14>
	credits = sys_le16_to_cpu(rsp->credits);
 100b83c:	88d3      	ldrh	r3, [r2, #6]
	mtu = sys_le16_to_cpu(rsp->mtu);
 100b83e:	f8b2 a002 	ldrh.w	sl, [r2, #2]
	mps = sys_le16_to_cpu(rsp->mps);
 100b842:	f8b2 9004 	ldrh.w	r9, [r2, #4]
	credits = sys_le16_to_cpu(rsp->credits);
 100b846:	60fb      	str	r3, [r7, #12]
	result = sys_le16_to_cpu(rsp->result);
 100b848:	8914      	ldrh	r4, [r2, #8]
	dcid = sys_le16_to_cpu(rsp->dcid);
 100b84a:	f8b2 b000 	ldrh.w	fp, [r2]
	if (result == BT_L2CAP_LE_SUCCESS ||
 100b84e:	f024 0308 	bic.w	r3, r4, #8
 100b852:	b10b      	cbz	r3, 100b858 <l2cap_recv+0x27c>
 100b854:	2c05      	cmp	r4, #5
 100b856:	d129      	bne.n	100b8ac <l2cap_recv+0x2d0>
		chan = l2cap_lookup_ident(conn, ident);
 100b858:	2200      	movs	r2, #0
 100b85a:	4629      	mov	r1, r5
 100b85c:	4630      	mov	r0, r6
 100b85e:	f01b fd79 	bl	1027354 <__l2cap_lookup_ident>
	if (!chan) {
 100b862:	4680      	mov	r8, r0
 100b864:	2800      	cmp	r0, #0
 100b866:	d14d      	bne.n	100b904 <l2cap_recv+0x328>
		LOG_ERR("Cannot find channel for ident %u", ident);
 100b868:	466c      	mov	r4, sp
 100b86a:	b088      	sub	sp, #32
 100b86c:	466a      	mov	r2, sp
 100b86e:	4b0e      	ldr	r3, [pc, #56]	; (100b8a8 <l2cap_recv+0x2cc>)
 100b870:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100b874:	e9c2 3505 	strd	r3, r5, [r2, #20]
 100b878:	2303      	movs	r3, #3
 100b87a:	f842 3f10 	str.w	r3, [r2, #16]!
 100b87e:	e6dd      	b.n	100b63c <l2cap_recv+0x60>
 100b880:	0102df98 	.word	0x0102df98
 100b884:	010299c4 	.word	0x010299c4
 100b888:	0102dfb6 	.word	0x0102dfb6
 100b88c:	0102dfd7 	.word	0x0102dfd7
 100b890:	0102dff8 	.word	0x0102dff8
 100b894:	0102e014 	.word	0x0102e014
 100b898:	0102e036 	.word	0x0102e036
 100b89c:	0102e051 	.word	0x0102e051
 100b8a0:	01027413 	.word	0x01027413
 100b8a4:	0102e073 	.word	0x0102e073
 100b8a8:	0102e095 	.word	0x0102e095
		chan = l2cap_remove_ident(conn, ident);
 100b8ac:	2201      	movs	r2, #1
 100b8ae:	4629      	mov	r1, r5
 100b8b0:	4630      	mov	r0, r6
 100b8b2:	f01b fd4f 	bl	1027354 <__l2cap_lookup_ident>
	if (!chan) {
 100b8b6:	4680      	mov	r8, r0
 100b8b8:	2800      	cmp	r0, #0
 100b8ba:	d0d5      	beq.n	100b868 <l2cap_recv+0x28c>
	k_work_cancel_delayable(&chan->rtx_work);
 100b8bc:	30a0      	adds	r0, #160	; 0xa0
 100b8be:	f016 fc47 	bl	1022150 <k_work_cancel_delayable>
	chan->ident = 0U;
 100b8c2:	2200      	movs	r2, #0
 100b8c4:	f888 2098 	strb.w	r2, [r8, #152]	; 0x98
	switch (result) {
 100b8c8:	2c08      	cmp	r4, #8
 100b8ca:	d043      	beq.n	100b954 <l2cap_recv+0x378>
 100b8cc:	2c00      	cmp	r4, #0
 100b8ce:	d14d      	bne.n	100b96c <l2cap_recv+0x390>
	BT_L2CAP_LE_CHAN(chan)->state = state;
 100b8d0:	2203      	movs	r2, #3
 100b8d2:	f888 2094 	strb.w	r2, [r8, #148]	; 0x94
		if (chan->chan.ops->connected) {
 100b8d6:	f8d8 2004 	ldr.w	r2, [r8, #4]
		chan->tx.cid = dcid;
 100b8da:	f8a8 b024 	strh.w	fp, [r8, #36]	; 0x24
		chan->tx.mtu = mtu;
 100b8de:	f8a8 a026 	strh.w	sl, [r8, #38]	; 0x26
		chan->tx.mps = mps;
 100b8e2:	f8a8 9028 	strh.w	r9, [r8, #40]	; 0x28
		if (chan->chan.ops->connected) {
 100b8e6:	6812      	ldr	r2, [r2, #0]
 100b8e8:	b10a      	cbz	r2, 100b8ee <l2cap_recv+0x312>
			chan->chan.ops->connected(&chan->chan);
 100b8ea:	4640      	mov	r0, r8
 100b8ec:	4790      	blx	r2
		l2cap_chan_tx_give_credits(chan, credits);
 100b8ee:	4640      	mov	r0, r8
 100b8f0:	68f9      	ldr	r1, [r7, #12]
 100b8f2:	f01b fdd0 	bl	1027496 <l2cap_chan_tx_give_credits>
	atomic_add(&chan->rx.credits, credits);
 100b8f6:	f8b8 101a 	ldrh.w	r1, [r8, #26]
 100b8fa:	f108 001c 	add.w	r0, r8, #28
 100b8fe:	f01b fdc2 	bl	1027486 <atomic_add.isra.0>
}
 100b902:	e67f      	b.n	100b604 <l2cap_recv+0x28>
	k_work_cancel_delayable(&chan->rtx_work);
 100b904:	30a0      	adds	r0, #160	; 0xa0
 100b906:	f016 fc23 	bl	1022150 <k_work_cancel_delayable>
	chan->ident = 0U;
 100b90a:	2200      	movs	r2, #0
	switch (result) {
 100b90c:	2c05      	cmp	r4, #5
	chan->ident = 0U;
 100b90e:	f888 2098 	strb.w	r2, [r8, #152]	; 0x98
	switch (result) {
 100b912:	d1d9      	bne.n	100b8c8 <l2cap_recv+0x2ec>
	struct bt_conn *conn = chan->chan.conn;
 100b914:	4644      	mov	r4, r8
 100b916:	f854 2b10 	ldr.w	r2, [r4], #16
 100b91a:	4620      	mov	r0, r4
 100b91c:	f01b fd58 	bl	10273d0 <atomic_get>
	if (atomic_test_bit(chan->chan.status,
 100b920:	0743      	lsls	r3, r0, #29
 100b922:	d41f      	bmi.n	100b964 <l2cap_recv+0x388>
		if (conn->sec_level < BT_SECURITY_L2) {
 100b924:	7a52      	ldrb	r2, [r2, #9]
 100b926:	2a01      	cmp	r2, #1
 100b928:	d927      	bls.n	100b97a <l2cap_recv+0x39e>
		} else if (conn->sec_level < BT_SECURITY_L3) {
 100b92a:	2a02      	cmp	r2, #2
 100b92c:	d027      	beq.n	100b97e <l2cap_recv+0x3a2>
		} else if (conn->sec_level < BT_SECURITY_L4) {
 100b92e:	2a03      	cmp	r2, #3
 100b930:	d118      	bne.n	100b964 <l2cap_recv+0x388>
			sec = BT_SECURITY_L4;
 100b932:	2104      	movs	r1, #4
	ret = bt_conn_set_security(chan->chan.conn, sec);
 100b934:	f8d8 0000 	ldr.w	r0, [r8]
 100b938:	f01b fc7c 	bl	1027234 <bt_conn_set_security>
	if (ret < 0) {
 100b93c:	2800      	cmp	r0, #0
 100b93e:	db11      	blt.n	100b964 <l2cap_recv+0x388>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 100b940:	e8d4 3fef 	ldaex	r3, [r4]
 100b944:	f043 0304 	orr.w	r3, r3, #4
 100b948:	e8c4 3fe2 	stlex	r2, r3, [r4]
 100b94c:	2a00      	cmp	r2, #0
 100b94e:	f43f ae59 	beq.w	100b604 <l2cap_recv+0x28>
 100b952:	e7f5      	b.n	100b940 <l2cap_recv+0x364>
	struct bt_conn *conn = chan->chan.conn;
 100b954:	4644      	mov	r4, r8
 100b956:	f854 2b10 	ldr.w	r2, [r4], #16
 100b95a:	4620      	mov	r0, r4
 100b95c:	f01b fd38 	bl	10273d0 <atomic_get>
	if (atomic_test_bit(chan->chan.status,
 100b960:	0741      	lsls	r1, r0, #29
 100b962:	d507      	bpl.n	100b974 <l2cap_recv+0x398>
		bt_l2cap_chan_remove(conn, &chan->chan);
 100b964:	4641      	mov	r1, r8
 100b966:	4630      	mov	r0, r6
 100b968:	f01b fdae 	bl	10274c8 <bt_l2cap_chan_remove>
		bt_l2cap_chan_del(&chan->chan);
 100b96c:	4640      	mov	r0, r8
	bt_l2cap_chan_del(&chan->chan);
 100b96e:	f01b fdc0 	bl	10274f2 <bt_l2cap_chan_del>
 100b972:	e647      	b.n	100b604 <l2cap_recv+0x28>
		if (conn->sec_level >= BT_SECURITY_L2) {
 100b974:	7a52      	ldrb	r2, [r2, #9]
 100b976:	2a01      	cmp	r2, #1
 100b978:	d8f4      	bhi.n	100b964 <l2cap_recv+0x388>
		sec = BT_SECURITY_L2;
 100b97a:	2102      	movs	r1, #2
 100b97c:	e7da      	b.n	100b934 <l2cap_recv+0x358>
			sec = BT_SECURITY_L3;
 100b97e:	2103      	movs	r1, #3
 100b980:	e7d8      	b.n	100b934 <l2cap_recv+0x358>
	if (buf->len < sizeof(*req)) {
 100b982:	2b03      	cmp	r3, #3
 100b984:	6826      	ldr	r6, [r4, #0]
	struct bt_l2cap_disconn_req *req = (void *)buf->data;
 100b986:	f8d8 800c 	ldr.w	r8, [r8, #12]
	if (buf->len < sizeof(*req)) {
 100b98a:	f67f ae88 	bls.w	100b69e <l2cap_recv+0xc2>
	chan = l2cap_remove_rx_cid(conn, dcid);
 100b98e:	4630      	mov	r0, r6
 100b990:	f8b8 1000 	ldrh.w	r1, [r8]
 100b994:	f01b fcfb 	bl	102738e <l2cap_remove_rx_cid>
	if (!chan) {
 100b998:	4604      	mov	r4, r0
 100b99a:	bb20      	cbnz	r0, 100b9e6 <l2cap_recv+0x40a>
		data.scid = req->scid;
 100b99c:	f898 2003 	ldrb.w	r2, [r8, #3]
 100b9a0:	f898 3002 	ldrb.w	r3, [r8, #2]
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
 100b9a4:	4629      	mov	r1, r5
		data.scid = req->scid;
 100b9a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 100b9aa:	833b      	strh	r3, [r7, #24]
		data.dcid = req->dcid;
 100b9ac:	f8b8 3000 	ldrh.w	r3, [r8]
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
 100b9b0:	2206      	movs	r2, #6
 100b9b2:	2001      	movs	r0, #1
		data.dcid = req->dcid;
 100b9b4:	837b      	strh	r3, [r7, #26]
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
 100b9b6:	f7ff f8d7 	bl	100ab68 <l2cap_create_le_sig_pdu.constprop.0>
	if (!buf) {
 100b9ba:	4605      	mov	r5, r0
 100b9bc:	2800      	cmp	r0, #0
 100b9be:	f43f ae21 	beq.w	100b604 <l2cap_recv+0x28>
 100b9c2:	f100 080c 	add.w	r8, r0, #12
 100b9c6:	2102      	movs	r1, #2
 100b9c8:	4640      	mov	r0, r8
 100b9ca:	f012 fc65 	bl	101e298 <net_buf_simple_add>
	rej->reason = sys_cpu_to_le16(reason);
 100b9ce:	2302      	movs	r3, #2
 100b9d0:	7044      	strb	r4, [r0, #1]
 100b9d2:	7003      	strb	r3, [r0, #0]
	return net_buf_simple_add_mem(&buf->b, mem, len);
 100b9d4:	2204      	movs	r2, #4
 100b9d6:	4640      	mov	r0, r8
 100b9d8:	f107 0118 	add.w	r1, r7, #24
 100b9dc:	f01d f9d8 	bl	1028d90 <net_buf_simple_add_mem>
	l2cap_send(conn, BT_L2CAP_CID_LE_SIG, buf);
 100b9e0:	4629      	mov	r1, r5
 100b9e2:	4630      	mov	r0, r6
 100b9e4:	e6a8      	b.n	100b738 <l2cap_recv+0x15c>
	buf = l2cap_create_le_sig_pdu(buf, BT_L2CAP_DISCONN_RSP, ident,
 100b9e6:	4629      	mov	r1, r5
 100b9e8:	2204      	movs	r2, #4
 100b9ea:	2007      	movs	r0, #7
 100b9ec:	f7ff f8bc 	bl	100ab68 <l2cap_create_le_sig_pdu.constprop.0>
	if (!buf) {
 100b9f0:	4605      	mov	r5, r0
 100b9f2:	2800      	cmp	r0, #0
 100b9f4:	f43f ae06 	beq.w	100b604 <l2cap_recv+0x28>
	return net_buf_simple_add(&buf->b, len);
 100b9f8:	2104      	movs	r1, #4
 100b9fa:	300c      	adds	r0, #12
 100b9fc:	f012 fc4c 	bl	101e298 <net_buf_simple_add>
	rsp->dcid = sys_cpu_to_le16(chan->rx.cid);
 100ba00:	8aa3      	ldrh	r3, [r4, #20]
 100ba02:	8003      	strh	r3, [r0, #0]
	rsp->scid = sys_cpu_to_le16(chan->tx.cid);
 100ba04:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
 100ba06:	8043      	strh	r3, [r0, #2]
	bt_l2cap_chan_del(&chan->chan);
 100ba08:	4620      	mov	r0, r4
 100ba0a:	f01b fd72 	bl	10274f2 <bt_l2cap_chan_del>
 100ba0e:	e7e7      	b.n	100b9e0 <l2cap_recv+0x404>
	if (buf->len < sizeof(*rsp)) {
 100ba10:	2b03      	cmp	r3, #3
 100ba12:	6820      	ldr	r0, [r4, #0]
	struct bt_l2cap_disconn_rsp *rsp = (void *)buf->data;
 100ba14:	f8d8 200c 	ldr.w	r2, [r8, #12]
	if (buf->len < sizeof(*rsp)) {
 100ba18:	d801      	bhi.n	100ba1e <l2cap_recv+0x442>
		LOG_ERR("Too small LE disconn rsp packet size");
 100ba1a:	4b2f      	ldr	r3, [pc, #188]	; (100bad8 <l2cap_recv+0x4fc>)
 100ba1c:	e5e8      	b.n	100b5f0 <l2cap_recv+0x14>
	chan = l2cap_remove_rx_cid(conn, scid);
 100ba1e:	8851      	ldrh	r1, [r2, #2]
 100ba20:	f01b fcb5 	bl	102738e <l2cap_remove_rx_cid>
	if (!chan) {
 100ba24:	2800      	cmp	r0, #0
 100ba26:	d1a2      	bne.n	100b96e <l2cap_recv+0x392>
 100ba28:	e5ec      	b.n	100b604 <l2cap_recv+0x28>
	if (buf->len < sizeof(*ev)) {
 100ba2a:	2b03      	cmp	r3, #3
 100ba2c:	6820      	ldr	r0, [r4, #0]
	struct bt_l2cap_le_credits *ev = (void *)buf->data;
 100ba2e:	f8d8 100c 	ldr.w	r1, [r8, #12]
	if (buf->len < sizeof(*ev)) {
 100ba32:	d801      	bhi.n	100ba38 <l2cap_recv+0x45c>
		LOG_ERR("Too small LE Credits packet size");
 100ba34:	4b29      	ldr	r3, [pc, #164]	; (100badc <l2cap_recv+0x500>)
 100ba36:	e5db      	b.n	100b5f0 <l2cap_recv+0x14>
	credits = sys_le16_to_cpu(ev->credits);
 100ba38:	884a      	ldrh	r2, [r1, #2]
	chan = bt_l2cap_le_lookup_tx_cid(conn, cid);
 100ba3a:	8809      	ldrh	r1, [r1, #0]
 100ba3c:	f01b fe99 	bl	1027772 <bt_l2cap_le_lookup_tx_cid>
	if (!chan) {
 100ba40:	4604      	mov	r4, r0
 100ba42:	b908      	cbnz	r0, 100ba48 <l2cap_recv+0x46c>
		LOG_ERR("Unable to find channel of LE Credits packet");
 100ba44:	4b26      	ldr	r3, [pc, #152]	; (100bae0 <l2cap_recv+0x504>)
 100ba46:	e5d3      	b.n	100b5f0 <l2cap_recv+0x14>
	if (atomic_get(&le_chan->tx.credits) + credits > UINT16_MAX) {
 100ba48:	302c      	adds	r0, #44	; 0x2c
 100ba4a:	f01b fcc1 	bl	10273d0 <atomic_get>
 100ba4e:	4410      	add	r0, r2
 100ba50:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 100ba54:	db0e      	blt.n	100ba74 <l2cap_recv+0x498>
		LOG_ERR("Credits overflow");
 100ba56:	4b23      	ldr	r3, [pc, #140]	; (100bae4 <l2cap_recv+0x508>)
 100ba58:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100ba5c:	62fb      	str	r3, [r7, #44]	; 0x2c
 100ba5e:	2302      	movs	r3, #2
 100ba60:	4821      	ldr	r0, [pc, #132]	; (100bae8 <l2cap_recv+0x50c>)
 100ba62:	62bb      	str	r3, [r7, #40]	; 0x28
 100ba64:	f107 0228 	add.w	r2, r7, #40	; 0x28
 100ba68:	f01b fd0a 	bl	1027480 <z_log_msg_static_create.constprop.0>
		bt_l2cap_chan_disconnect(chan);
 100ba6c:	4620      	mov	r0, r4
 100ba6e:	f01b fec7 	bl	1027800 <bt_l2cap_chan_disconnect>
		return;
 100ba72:	e5c7      	b.n	100b604 <l2cap_recv+0x28>
	l2cap_chan_tx_give_credits(le_chan, credits);
 100ba74:	4620      	mov	r0, r4
 100ba76:	4611      	mov	r1, r2
 100ba78:	f01b fd0d 	bl	1027496 <l2cap_chan_tx_give_credits>
	l2cap_chan_tx_resume(le_chan);
 100ba7c:	4620      	mov	r0, r4
 100ba7e:	f01b fcaa 	bl	10273d6 <l2cap_chan_tx_resume>
 100ba82:	e5bf      	b.n	100b604 <l2cap_recv+0x28>
	chan = l2cap_remove_ident(conn, ident);
 100ba84:	4629      	mov	r1, r5
 100ba86:	6820      	ldr	r0, [r4, #0]
 100ba88:	f01b fc64 	bl	1027354 <__l2cap_lookup_ident>
 100ba8c:	e7ca      	b.n	100ba24 <l2cap_recv+0x448>
		LOG_WRN("Rejecting unknown L2CAP PDU code 0x%02x", hdr->code);
 100ba8e:	466d      	mov	r5, sp
 100ba90:	b088      	sub	sp, #32
 100ba92:	466b      	mov	r3, sp
 100ba94:	4915      	ldr	r1, [pc, #84]	; (100baec <l2cap_recv+0x510>)
 100ba96:	4814      	ldr	r0, [pc, #80]	; (100bae8 <l2cap_recv+0x50c>)
	switch (hdr->code) {
 100ba98:	e9c3 1205 	strd	r1, r2, [r3, #20]
		LOG_WRN("Rejecting unknown L2CAP PDU code 0x%02x", hdr->code);
 100ba9c:	461a      	mov	r2, r3
 100ba9e:	2303      	movs	r3, #3
 100baa0:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100baa4:	f842 3f10 	str.w	r3, [r2, #16]!
 100baa8:	f01b fcea 	bl	1027480 <z_log_msg_static_create.constprop.0>
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
 100baac:	2202      	movs	r2, #2
 100baae:	46ad      	mov	sp, r5
 100bab0:	2001      	movs	r0, #1
 100bab2:	7871      	ldrb	r1, [r6, #1]
		l2cap_send_reject(chan->conn, hdr->ident,
 100bab4:	6825      	ldr	r5, [r4, #0]
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
 100bab6:	f7ff f857 	bl	100ab68 <l2cap_create_le_sig_pdu.constprop.0>
	if (!buf) {
 100baba:	4604      	mov	r4, r0
 100babc:	2800      	cmp	r0, #0
 100babe:	f43f ada1 	beq.w	100b604 <l2cap_recv+0x28>
 100bac2:	2102      	movs	r1, #2
 100bac4:	300c      	adds	r0, #12
 100bac6:	f012 fbe7 	bl	101e298 <net_buf_simple_add>
	rej->reason = sys_cpu_to_le16(reason);
 100baca:	2300      	movs	r3, #0
	l2cap_send(conn, BT_L2CAP_CID_LE_SIG, buf);
 100bacc:	4621      	mov	r1, r4
	rej->reason = sys_cpu_to_le16(reason);
 100bace:	7003      	strb	r3, [r0, #0]
 100bad0:	7043      	strb	r3, [r0, #1]
	l2cap_send(conn, BT_L2CAP_CID_LE_SIG, buf);
 100bad2:	4628      	mov	r0, r5
 100bad4:	e630      	b.n	100b738 <l2cap_recv+0x15c>
 100bad6:	bf00      	nop
 100bad8:	0102e0b6 	.word	0x0102e0b6
 100badc:	0102e0db 	.word	0x0102e0db
 100bae0:	0102e0fc 	.word	0x0102e0fc
 100bae4:	0102e128 	.word	0x0102e128
 100bae8:	010299c4 	.word	0x010299c4
 100baec:	0102e139 	.word	0x0102e139

0100baf0 <att_op_get_type>:
#endif /* CONFIG_BT_GATT_CLIENT */
};

static att_type_t att_op_get_type(uint8_t op)
{
	switch (op) {
 100baf0:	2823      	cmp	r0, #35	; 0x23
 100baf2:	d81f      	bhi.n	100bb34 <att_op_get_type+0x44>
 100baf4:	281a      	cmp	r0, #26
 100baf6:	d804      	bhi.n	100bb02 <att_op_get_type+0x12>
 100baf8:	1e43      	subs	r3, r0, #1
 100bafa:	2b18      	cmp	r3, #24
 100bafc:	d90e      	bls.n	100bb1c <att_op_get_type+0x2c>

	if (op & ATT_CMD_MASK) {
		return ATT_COMMAND;
	}

	return ATT_UNKNOWN;
 100bafe:	2006      	movs	r0, #6
 100bb00:	4770      	bx	lr
	switch (op) {
 100bb02:	f1a0 031b 	sub.w	r3, r0, #27
 100bb06:	2b08      	cmp	r3, #8
 100bb08:	d81e      	bhi.n	100bb48 <att_op_get_type+0x58>
 100bb0a:	e8df f003 	tbb	[pc, r3]
 100bb0e:	1d05      	.short	0x1d05
 100bb10:	191d231b 	.word	0x191d231b
 100bb14:	1d25      	.short	0x1d25
 100bb16:	05          	.byte	0x05
 100bb17:	00          	.byte	0x00
		return ATT_NOTIFICATION;
 100bb18:	2003      	movs	r0, #3
 100bb1a:	4770      	bx	lr
 100bb1c:	2301      	movs	r3, #1
	switch (op) {
 100bb1e:	4a0f      	ldr	r2, [pc, #60]	; (100bb5c <att_op_get_type+0x6c>)
 100bb20:	4083      	lsls	r3, r0
 100bb22:	401a      	ands	r2, r3
 100bb24:	b9c2      	cbnz	r2, 100bb58 <att_op_get_type+0x68>
 100bb26:	4a0e      	ldr	r2, [pc, #56]	; (100bb60 <att_op_get_type+0x70>)
 100bb28:	401a      	ands	r2, r3
	return ATT_UNKNOWN;
 100bb2a:	2a00      	cmp	r2, #0
 100bb2c:	bf14      	ite	ne
 100bb2e:	2001      	movne	r0, #1
 100bb30:	2006      	moveq	r0, #6
 100bb32:	4770      	bx	lr
	switch (op) {
 100bb34:	f000 037f 	and.w	r3, r0, #127	; 0x7f
 100bb38:	2b52      	cmp	r3, #82	; 0x52
 100bb3a:	d105      	bne.n	100bb48 <att_op_get_type+0x58>
		return ATT_COMMAND;
 100bb3c:	2000      	movs	r0, #0
}
 100bb3e:	4770      	bx	lr
		return ATT_REQUEST;
 100bb40:	2001      	movs	r0, #1
 100bb42:	4770      	bx	lr
		return ATT_INDICATION;
 100bb44:	2005      	movs	r0, #5
 100bb46:	4770      	bx	lr
		return ATT_COMMAND;
 100bb48:	f010 0f40 	tst.w	r0, #64	; 0x40
 100bb4c:	bf0c      	ite	eq
 100bb4e:	2006      	moveq	r0, #6
 100bb50:	2000      	movne	r0, #0
 100bb52:	4770      	bx	lr
	switch (op) {
 100bb54:	2004      	movs	r0, #4
 100bb56:	4770      	bx	lr
		return ATT_RESPONSE;
 100bb58:	2002      	movs	r0, #2
 100bb5a:	4770      	bx	lr
 100bb5c:	028aaaaa 	.word	0x028aaaaa
 100bb60:	01455554 	.word	0x01455554

0100bb64 <bt_att_released>:
	/* Prepend back to the list as it could not be sent */
	sys_slist_prepend(&chan->att->reqs, node);
}

static void bt_att_released(struct bt_l2cap_chan *ch)
{
 100bb64:	b507      	push	{r0, r1, r2, lr}
	struct bt_att_chan *chan = ATT_CHAN(ch);
 100bb66:	3808      	subs	r0, #8
 100bb68:	9001      	str	r0, [sp, #4]

	LOG_DBG("chan %p", chan);

	k_mem_slab_free(&chan_slab, (void **)&chan);
 100bb6a:	a901      	add	r1, sp, #4
 100bb6c:	4802      	ldr	r0, [pc, #8]	; (100bb78 <bt_att_released+0x14>)
 100bb6e:	f015 f92f 	bl	1020dd0 <k_mem_slab_free>
}
 100bb72:	b003      	add	sp, #12
 100bb74:	f85d fb04 	ldr.w	pc, [sp], #4
 100bb78:	21000c30 	.word	0x21000c30

0100bb7c <tx_meta_data_free>:
{
 100bb7c:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(data);
 100bb7e:	4604      	mov	r4, r0
 100bb80:	b948      	cbnz	r0, 100bb96 <tx_meta_data_free+0x1a>
 100bb82:	490a      	ldr	r1, [pc, #40]	; (100bbac <tx_meta_data_free+0x30>)
 100bb84:	480a      	ldr	r0, [pc, #40]	; (100bbb0 <tx_meta_data_free+0x34>)
 100bb86:	23a6      	movs	r3, #166	; 0xa6
 100bb88:	4a0a      	ldr	r2, [pc, #40]	; (100bbb4 <tx_meta_data_free+0x38>)
 100bb8a:	f019 f824 	bl	1024bd6 <assert_print>
 100bb8e:	21a6      	movs	r1, #166	; 0xa6
 100bb90:	4808      	ldr	r0, [pc, #32]	; (100bbb4 <tx_meta_data_free+0x38>)
 100bb92:	f019 f819 	bl	1024bc8 <assert_post_action>
	(void)memset(data, 0, sizeof(*data));
 100bb96:	2100      	movs	r1, #0
 100bb98:	2214      	movs	r2, #20
 100bb9a:	f01a fef6 	bl	102698a <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
 100bb9e:	4621      	mov	r1, r4
}
 100bba0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_fifo_put(&free_att_tx_meta_data, data);
 100bba4:	4804      	ldr	r0, [pc, #16]	; (100bbb8 <tx_meta_data_free+0x3c>)
 100bba6:	f01d bba1 	b.w	10292ec <k_queue_append>
 100bbaa:	bf00      	nop
 100bbac:	0102d9ac 	.word	0x0102d9ac
 100bbb0:	0102b695 	.word	0x0102b695
 100bbb4:	0102e16a 	.word	0x0102e16a
 100bbb8:	21000d28 	.word	0x21000d28

0100bbbc <find_type_cb>:
{
 100bbbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100bbc0:	b093      	sub	sp, #76	; 0x4c
	struct bt_att_chan *chan = data->chan;
 100bbc2:	f8d2 a000 	ldr.w	sl, [r2]
{
 100bbc6:	af02      	add	r7, sp, #8
	struct bt_conn *conn = chan->chan.chan.conn;
 100bbc8:	f8da 3008 	ldr.w	r3, [sl, #8]
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
 100bbcc:	2500      	movs	r5, #0
	struct bt_conn *conn = chan->chan.chan.conn;
 100bbce:	607b      	str	r3, [r7, #4]
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
 100bbd0:	f642 0301 	movw	r3, #10241	; 0x2801
{
 100bbd4:	4680      	mov	r8, r0
 100bbd6:	460e      	mov	r6, r1
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
 100bbd8:	6800      	ldr	r0, [r0, #0]
 100bbda:	f887 502c 	strb.w	r5, [r7, #44]	; 0x2c
 100bbde:	85fb      	strh	r3, [r7, #46]	; 0x2e
 100bbe0:	f107 012c 	add.w	r1, r7, #44	; 0x2c
{
 100bbe4:	4614      	mov	r4, r2
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
 100bbe6:	f01a ff6b 	bl	1026ac0 <bt_uuid_cmp>
 100bbea:	2800      	cmp	r0, #0
 100bbec:	d070      	beq.n	100bcd0 <find_type_cb+0x114>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY)) {
 100bbee:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 100bbf2:	f8d8 0000 	ldr.w	r0, [r8]
 100bbf6:	f887 502c 	strb.w	r5, [r7, #44]	; 0x2c
 100bbfa:	85fb      	strh	r3, [r7, #46]	; 0x2e
 100bbfc:	f107 012c 	add.w	r1, r7, #44	; 0x2c
 100bc00:	f01a ff5e 	bl	1026ac0 <bt_uuid_cmp>
 100bc04:	b138      	cbz	r0, 100bc16 <find_type_cb+0x5a>
		if (data->group &&
 100bc06:	68a3      	ldr	r3, [r4, #8]
 100bc08:	b11b      	cbz	r3, 100bc12 <find_type_cb+0x56>
 100bc0a:	885a      	ldrh	r2, [r3, #2]
 100bc0c:	42b2      	cmp	r2, r6
 100bc0e:	d200      	bcs.n	100bc12 <find_type_cb+0x56>
	data->group->end_handle = sys_cpu_to_le16(handle);
 100bc10:	805e      	strh	r6, [r3, #2]
		return BT_GATT_ITER_CONTINUE;
 100bc12:	2001      	movs	r0, #1
 100bc14:	e009      	b.n	100bc2a <find_type_cb+0x6e>
	if (chan->chan.tx.mtu - net_buf_frags_len(data->buf) <
 100bc16:	6861      	ldr	r1, [r4, #4]
 100bc18:	4608      	mov	r0, r1
 100bc1a:	f01b fe39 	bl	1027890 <net_buf_frags_len>
 100bc1e:	f8ba 302e 	ldrh.w	r3, [sl, #46]	; 0x2e
 100bc22:	1a1b      	subs	r3, r3, r0
 100bc24:	2b03      	cmp	r3, #3
 100bc26:	d804      	bhi.n	100bc32 <find_type_cb+0x76>
		return BT_GATT_ITER_STOP;
 100bc28:	2000      	movs	r0, #0
}
 100bc2a:	3744      	adds	r7, #68	; 0x44
 100bc2c:	46bd      	mov	sp, r7
 100bc2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	frag = net_buf_frag_last(data->buf);
 100bc32:	4608      	mov	r0, r1
 100bc34:	f012 fa2e 	bl	101e094 <net_buf_frag_last>
 100bc38:	4605      	mov	r5, r0
	len = MIN(chan->chan.tx.mtu - net_buf_frags_len(data->buf),
 100bc3a:	6860      	ldr	r0, [r4, #4]
 100bc3c:	f01b fe28 	bl	1027890 <net_buf_frags_len>
 100bc40:	f8ba b02e 	ldrh.w	fp, [sl, #46]	; 0x2e
	return net_buf_simple_tailroom(&buf->b);
 100bc44:	f105 090c 	add.w	r9, r5, #12
 100bc48:	ebab 0b00 	sub.w	fp, fp, r0
 100bc4c:	4648      	mov	r0, r9
 100bc4e:	f01d f897 	bl	1028d80 <net_buf_simple_tailroom>
 100bc52:	4558      	cmp	r0, fp
 100bc54:	d93f      	bls.n	100bcd6 <find_type_cb+0x11a>
 100bc56:	6860      	ldr	r0, [r4, #4]
 100bc58:	f01b fe1a 	bl	1027890 <net_buf_frags_len>
 100bc5c:	f8ba 302e 	ldrh.w	r3, [sl, #46]	; 0x2e
 100bc60:	1a18      	subs	r0, r3, r0
	if (!len) {
 100bc62:	b970      	cbnz	r0, 100bc82 <find_type_cb+0xc6>
		frag = net_buf_alloc(net_buf_pool_get(data->buf->pool_id),
 100bc64:	6863      	ldr	r3, [r4, #4]
 100bc66:	7a98      	ldrb	r0, [r3, #10]
 100bc68:	f012 f846 	bl	101dcf8 <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
 100bc6c:	2200      	movs	r2, #0
 100bc6e:	2300      	movs	r3, #0
 100bc70:	f01d f86a 	bl	1028d48 <net_buf_alloc_fixed>
		if (!frag) {
 100bc74:	4605      	mov	r5, r0
 100bc76:	2800      	cmp	r0, #0
 100bc78:	d0d6      	beq.n	100bc28 <find_type_cb+0x6c>
		net_buf_frag_add(data->buf, frag);
 100bc7a:	4601      	mov	r1, r0
 100bc7c:	6860      	ldr	r0, [r4, #4]
 100bc7e:	f012 fa4f 	bl	101e120 <net_buf_frag_add>
	read = attr->read(conn, attr, uuid, sizeof(uuid), 0);
 100bc82:	2300      	movs	r3, #0
 100bc84:	9300      	str	r3, [sp, #0]
 100bc86:	4641      	mov	r1, r8
 100bc88:	f8d8 a004 	ldr.w	sl, [r8, #4]
 100bc8c:	2310      	movs	r3, #16
 100bc8e:	6878      	ldr	r0, [r7, #4]
 100bc90:	f107 0208 	add.w	r2, r7, #8
 100bc94:	47d0      	blx	sl
	if (read < 0) {
 100bc96:	f1b0 0800 	subs.w	r8, r0, #0
 100bc9a:	db19      	blt.n	100bcd0 <find_type_cb+0x114>
	if (read != data->value_len) {
 100bc9c:	7c22      	ldrb	r2, [r4, #16]
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
 100bc9e:	68e0      	ldr	r0, [r4, #12]
	if (read != data->value_len) {
 100bca0:	4542      	cmp	r2, r8
 100bca2:	d03f      	beq.n	100bd24 <find_type_cb+0x168>
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
 100bca4:	4601      	mov	r1, r0
 100bca6:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 100bcaa:	f01a ff37 	bl	1026b1c <bt_uuid_create>
 100bcae:	b9b0      	cbnz	r0, 100bcde <find_type_cb+0x122>
			LOG_WRN("Unable to create UUID: size %u", data->value_len);
 100bcb0:	466d      	mov	r5, sp
 100bcb2:	b088      	sub	sp, #32
 100bcb4:	7c23      	ldrb	r3, [r4, #16]
 100bcb6:	aa02      	add	r2, sp, #8
 100bcb8:	491d      	ldr	r1, [pc, #116]	; (100bd30 <find_type_cb+0x174>)
 100bcba:	e9c2 1305 	strd	r1, r3, [r2, #20]
			LOG_WRN("Unable to create UUID: size %d", read);
 100bcbe:	2303      	movs	r3, #3
 100bcc0:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100bcc4:	481b      	ldr	r0, [pc, #108]	; (100bd34 <find_type_cb+0x178>)
 100bcc6:	f842 3f10 	str.w	r3, [r2, #16]!
 100bcca:	f01b fece 	bl	1027a6a <z_log_msg_static_create.constprop.0>
 100bcce:	46ad      	mov	sp, r5
	data->group = NULL;
 100bcd0:	2300      	movs	r3, #0
 100bcd2:	60a3      	str	r3, [r4, #8]
	return BT_GATT_ITER_CONTINUE;
 100bcd4:	e79d      	b.n	100bc12 <find_type_cb+0x56>
	return net_buf_simple_tailroom(&buf->b);
 100bcd6:	4648      	mov	r0, r9
 100bcd8:	f01d f852 	bl	1028d80 <net_buf_simple_tailroom>
 100bcdc:	e7c1      	b.n	100bc62 <find_type_cb+0xa6>
		if (!bt_uuid_create(&ref_uuid.uuid, uuid, read)) {
 100bcde:	fa5f f288 	uxtb.w	r2, r8
 100bce2:	f107 0108 	add.w	r1, r7, #8
 100bce6:	f107 0018 	add.w	r0, r7, #24
 100bcea:	f01a ff17 	bl	1026b1c <bt_uuid_create>
 100bcee:	b930      	cbnz	r0, 100bcfe <find_type_cb+0x142>
			LOG_WRN("Unable to create UUID: size %d", read);
 100bcf0:	466d      	mov	r5, sp
 100bcf2:	b088      	sub	sp, #32
 100bcf4:	aa02      	add	r2, sp, #8
 100bcf6:	4b10      	ldr	r3, [pc, #64]	; (100bd38 <find_type_cb+0x17c>)
 100bcf8:	e9c2 3805 	strd	r3, r8, [r2, #20]
 100bcfc:	e7df      	b.n	100bcbe <find_type_cb+0x102>
		if (bt_uuid_cmp(&recvd_uuid.uuid, &ref_uuid.uuid)) {
 100bcfe:	f107 0118 	add.w	r1, r7, #24
 100bd02:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 100bd06:	f01a fedb 	bl	1026ac0 <bt_uuid_cmp>
	} else if (memcmp(data->value, uuid, read)) {
 100bd0a:	2800      	cmp	r0, #0
 100bd0c:	d1e0      	bne.n	100bcd0 <find_type_cb+0x114>
	data->err = 0x00;
 100bd0e:	2300      	movs	r3, #0
	return net_buf_simple_add(&buf->b, len);
 100bd10:	2104      	movs	r1, #4
 100bd12:	7463      	strb	r3, [r4, #17]
 100bd14:	f105 000c 	add.w	r0, r5, #12
 100bd18:	f012 fabe 	bl	101e298 <net_buf_simple_add>
	data->group = net_buf_add(frag, sizeof(*data->group));
 100bd1c:	60a0      	str	r0, [r4, #8]
	data->group->start_handle = sys_cpu_to_le16(handle);
 100bd1e:	8006      	strh	r6, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(handle);
 100bd20:	68a3      	ldr	r3, [r4, #8]
 100bd22:	e775      	b.n	100bc10 <find_type_cb+0x54>
	} else if (memcmp(data->value, uuid, read)) {
 100bd24:	f107 0108 	add.w	r1, r7, #8
 100bd28:	f01a fe14 	bl	1026954 <memcmp>
 100bd2c:	e7ed      	b.n	100bd0a <find_type_cb+0x14e>
 100bd2e:	bf00      	nop
 100bd30:	0102e199 	.word	0x0102e199
 100bd34:	0102995c 	.word	0x0102995c
 100bd38:	0102e1b8 	.word	0x0102e1b8

0100bd3c <chan_send>:
{
 100bd3c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100bd40:	4606      	mov	r6, r0
 100bd42:	460c      	mov	r4, r1
	struct bt_att_tx_meta_data *data = bt_att_tx_meta_data(buf);
 100bd44:	f8d1 9018 	ldr.w	r9, [r1, #24]
	hdr = (void *)buf->data;
 100bd48:	68cb      	ldr	r3, [r1, #12]
{
 100bd4a:	b089      	sub	sp, #36	; 0x24
	if (!atomic_test_bit(chan->flags, ATT_CONNECTED)) {
 100bd4c:	2102      	movs	r1, #2
 100bd4e:	f500 7080 	add.w	r0, r0, #256	; 0x100
 100bd52:	f01b fdb7 	bl	10278c4 <atomic_test_bit>
 100bd56:	2800      	cmp	r0, #0
 100bd58:	d052      	beq.n	100be00 <chan_send+0xc4>
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
 100bd5a:	781b      	ldrb	r3, [r3, #0]
 100bd5c:	2bd2      	cmp	r3, #210	; 0xd2
 100bd5e:	d11a      	bne.n	100bd96 <chan_send+0x5a>
		err = bt_smp_sign(chan->att->conn, buf);
 100bd60:	6833      	ldr	r3, [r6, #0]
 100bd62:	4621      	mov	r1, r4
 100bd64:	6818      	ldr	r0, [r3, #0]
 100bd66:	f01c fedb 	bl	1028b20 <bt_smp_sign>
		if (err) {
 100bd6a:	4605      	mov	r5, r0
 100bd6c:	b198      	cbz	r0, 100bd96 <chan_send+0x5a>
			LOG_ERR("Error signing data");
 100bd6e:	4b26      	ldr	r3, [pc, #152]	; (100be08 <chan_send+0xcc>)
 100bd70:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100bd74:	9307      	str	r3, [sp, #28]
 100bd76:	2302      	movs	r3, #2
 100bd78:	4824      	ldr	r0, [pc, #144]	; (100be0c <chan_send+0xd0>)
 100bd7a:	aa06      	add	r2, sp, #24
 100bd7c:	9306      	str	r3, [sp, #24]
 100bd7e:	f01b fe74 	bl	1027a6a <z_log_msg_static_create.constprop.0>
			tx_meta_data_free(bt_att_tx_meta_data(buf));
 100bd82:	69a0      	ldr	r0, [r4, #24]
 100bd84:	f7ff fefa 	bl	100bb7c <tx_meta_data_free>
			net_buf_unref(buf);
 100bd88:	4620      	mov	r0, r4
 100bd8a:	f012 f929 	bl	101dfe0 <net_buf_unref>
}
 100bd8e:	4628      	mov	r0, r5
 100bd90:	b009      	add	sp, #36	; 0x24
 100bd92:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	state->offset = net_buf_simple_headroom(buf);
 100bd96:	f104 000c 	add.w	r0, r4, #12
 100bd9a:	f01c ffed 	bl	1028d78 <net_buf_simple_headroom>
	state->len = buf->len;
 100bd9e:	8a27      	ldrh	r7, [r4, #16]
	data->att_chan = chan;
 100bda0:	f8c9 6000 	str.w	r6, [r9]
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
 100bda4:	6833      	ldr	r3, [r6, #0]
	state->offset = net_buf_simple_headroom(buf);
 100bda6:	4680      	mov	r8, r0
 100bda8:	681e      	ldr	r6, [r3, #0]
	const att_type_t op_type = att_op_get_type(buf->data[0]);
 100bdaa:	68e3      	ldr	r3, [r4, #12]
 100bdac:	7818      	ldrb	r0, [r3, #0]
 100bdae:	f7ff fe9f 	bl	100baf0 <att_op_get_type>
 100bdb2:	2805      	cmp	r0, #5
 100bdb4:	4605      	mov	r5, r0
	switch (op_type) {
 100bdb6:	d813      	bhi.n	100bde0 <chan_send+0xa4>
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
 100bdb8:	4b15      	ldr	r3, [pc, #84]	; (100be10 <chan_send+0xd4>)
 100bdba:	4622      	mov	r2, r4
 100bdbc:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 100bdc0:	2104      	movs	r1, #4
 100bdc2:	4630      	mov	r0, r6
 100bdc4:	f8cd 9000 	str.w	r9, [sp]
 100bdc8:	f01b fbc8 	bl	102755c <bt_l2cap_send_cb>
	if (err) {
 100bdcc:	4605      	mov	r5, r0
 100bdce:	2800      	cmp	r0, #0
 100bdd0:	d0dd      	beq.n	100bd8e <chan_send+0x52>
	buf->data = buf->__buf + state->offset;
 100bdd2:	6963      	ldr	r3, [r4, #20]
 100bdd4:	fa1f f088 	uxth.w	r0, r8
 100bdd8:	4403      	add	r3, r0
 100bdda:	60e3      	str	r3, [r4, #12]
	buf->len = state->len;
 100bddc:	8227      	strh	r7, [r4, #16]
}
 100bdde:	e7d6      	b.n	100bd8e <chan_send+0x52>
		__ASSERT(false, "Unknown op type 0x%02X", op_type);
 100bde0:	f240 2357 	movw	r3, #599	; 0x257
 100bde4:	4a0b      	ldr	r2, [pc, #44]	; (100be14 <chan_send+0xd8>)
 100bde6:	490c      	ldr	r1, [pc, #48]	; (100be18 <chan_send+0xdc>)
 100bde8:	480c      	ldr	r0, [pc, #48]	; (100be1c <chan_send+0xe0>)
 100bdea:	f018 fef4 	bl	1024bd6 <assert_print>
 100bdee:	4629      	mov	r1, r5
 100bdf0:	480b      	ldr	r0, [pc, #44]	; (100be20 <chan_send+0xe4>)
 100bdf2:	f018 fef0 	bl	1024bd6 <assert_print>
 100bdf6:	f240 2157 	movw	r1, #599	; 0x257
 100bdfa:	4806      	ldr	r0, [pc, #24]	; (100be14 <chan_send+0xd8>)
 100bdfc:	f018 fee4 	bl	1024bc8 <assert_post_action>
		return -EINVAL;
 100be00:	f06f 0515 	mvn.w	r5, #21
 100be04:	e7c3      	b.n	100bd8e <chan_send+0x52>
 100be06:	bf00      	nop
 100be08:	0102e1d7 	.word	0x0102e1d7
 100be0c:	0102995c 	.word	0x0102995c
 100be10:	01029fe4 	.word	0x01029fe4
 100be14:	0102e16a 	.word	0x0102e16a
 100be18:	0102ff6e 	.word	0x0102ff6e
 100be1c:	0102b695 	.word	0x0102b695
 100be20:	0102e1ea 	.word	0x0102e1ea

0100be24 <bt_att_chan_req_send>:
{
 100be24:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(chan);
 100be26:	b958      	cbnz	r0, 100be40 <bt_att_chan_req_send+0x1c>
 100be28:	4919      	ldr	r1, [pc, #100]	; (100be90 <bt_att_chan_req_send+0x6c>)
 100be2a:	f44f 7346 	mov.w	r3, #792	; 0x318
 100be2e:	4a19      	ldr	r2, [pc, #100]	; (100be94 <bt_att_chan_req_send+0x70>)
 100be30:	4819      	ldr	r0, [pc, #100]	; (100be98 <bt_att_chan_req_send+0x74>)
 100be32:	f018 fed0 	bl	1024bd6 <assert_print>
 100be36:	f44f 7146 	mov.w	r1, #792	; 0x318
	__ASSERT_NO_MSG(req);
 100be3a:	4816      	ldr	r0, [pc, #88]	; (100be94 <bt_att_chan_req_send+0x70>)
 100be3c:	f018 fec4 	bl	1024bc8 <assert_post_action>
 100be40:	b949      	cbnz	r1, 100be56 <bt_att_chan_req_send+0x32>
 100be42:	4916      	ldr	r1, [pc, #88]	; (100be9c <bt_att_chan_req_send+0x78>)
 100be44:	f240 3319 	movw	r3, #793	; 0x319
 100be48:	4a12      	ldr	r2, [pc, #72]	; (100be94 <bt_att_chan_req_send+0x70>)
 100be4a:	4813      	ldr	r0, [pc, #76]	; (100be98 <bt_att_chan_req_send+0x74>)
 100be4c:	f018 fec3 	bl	1024bd6 <assert_print>
 100be50:	f240 3119 	movw	r1, #793	; 0x319
 100be54:	e7f1      	b.n	100be3a <bt_att_chan_req_send+0x16>
	__ASSERT_NO_MSG(req->func);
 100be56:	684a      	ldr	r2, [r1, #4]
 100be58:	b94a      	cbnz	r2, 100be6e <bt_att_chan_req_send+0x4a>
 100be5a:	4911      	ldr	r1, [pc, #68]	; (100bea0 <bt_att_chan_req_send+0x7c>)
 100be5c:	f240 331a 	movw	r3, #794	; 0x31a
 100be60:	4a0c      	ldr	r2, [pc, #48]	; (100be94 <bt_att_chan_req_send+0x70>)
 100be62:	480d      	ldr	r0, [pc, #52]	; (100be98 <bt_att_chan_req_send+0x74>)
 100be64:	f018 feb7 	bl	1024bd6 <assert_print>
 100be68:	f240 311a 	movw	r1, #794	; 0x31a
 100be6c:	e7e5      	b.n	100be3a <bt_att_chan_req_send+0x16>
	__ASSERT_NO_MSG(!chan->req);
 100be6e:	f8d0 3104 	ldr.w	r3, [r0, #260]	; 0x104
 100be72:	b14b      	cbz	r3, 100be88 <bt_att_chan_req_send+0x64>
 100be74:	490b      	ldr	r1, [pc, #44]	; (100bea4 <bt_att_chan_req_send+0x80>)
 100be76:	f240 331b 	movw	r3, #795	; 0x31b
 100be7a:	4a06      	ldr	r2, [pc, #24]	; (100be94 <bt_att_chan_req_send+0x70>)
 100be7c:	4806      	ldr	r0, [pc, #24]	; (100be98 <bt_att_chan_req_send+0x74>)
 100be7e:	f018 feaa 	bl	1024bd6 <assert_print>
 100be82:	f240 311b 	movw	r1, #795	; 0x31b
 100be86:	e7d8      	b.n	100be3a <bt_att_chan_req_send+0x16>
}
 100be88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return chan_req_send(chan, req);
 100be8c:	f01b bdf0 	b.w	1027a70 <chan_req_send>
 100be90:	0102e203 	.word	0x0102e203
 100be94:	0102e16a 	.word	0x0102e16a
 100be98:	0102b695 	.word	0x0102b695
 100be9c:	0102e219 	.word	0x0102e219
 100bea0:	0102e208 	.word	0x0102e208
 100bea4:	0102e212 	.word	0x0102e212

0100bea8 <att_get>:
{
 100bea8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	if (conn->state != BT_CONN_CONNECTED) {
 100beaa:	7b43      	ldrb	r3, [r0, #13]
 100beac:	2b07      	cmp	r3, #7
 100beae:	d00d      	beq.n	100becc <att_get+0x24>
		LOG_WRN("Not connected");
 100beb0:	4b18      	ldr	r3, [pc, #96]	; (100bf14 <att_get+0x6c>)
 100beb2:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100beb6:	9305      	str	r3, [sp, #20]
 100beb8:	2302      	movs	r3, #2
 100beba:	aa04      	add	r2, sp, #16
 100bebc:	9304      	str	r3, [sp, #16]
		LOG_ERR("Unable to find ATT channel");
 100bebe:	4816      	ldr	r0, [pc, #88]	; (100bf18 <att_get+0x70>)
 100bec0:	f01b fdd3 	bl	1027a6a <z_log_msg_static_create.constprop.0>
		return NULL;
 100bec4:	2000      	movs	r0, #0
}
 100bec6:	b007      	add	sp, #28
 100bec8:	f85d fb04 	ldr.w	pc, [sp], #4
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
 100becc:	2104      	movs	r1, #4
 100bece:	f01b fc64 	bl	102779a <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
 100bed2:	4603      	mov	r3, r0
 100bed4:	b938      	cbnz	r0, 100bee6 <att_get+0x3e>
		LOG_ERR("Unable to find ATT channel");
 100bed6:	4b11      	ldr	r3, [pc, #68]	; (100bf1c <att_get+0x74>)
 100bed8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100bedc:	9305      	str	r3, [sp, #20]
 100bede:	2302      	movs	r3, #2
 100bee0:	aa04      	add	r2, sp, #16
 100bee2:	9304      	str	r3, [sp, #16]
 100bee4:	e7eb      	b.n	100bebe <att_get+0x16>
	__ASSERT(atomic_test_bit(att_chan->flags, ATT_CONNECTED),
 100bee6:	2102      	movs	r1, #2
 100bee8:	30f8      	adds	r0, #248	; 0xf8
 100beea:	f01b fceb 	bl	10278c4 <atomic_test_bit>
 100beee:	b970      	cbnz	r0, 100bf0e <att_get+0x66>
 100bef0:	490b      	ldr	r1, [pc, #44]	; (100bf20 <att_get+0x78>)
 100bef2:	f640 332a 	movw	r3, #2858	; 0xb2a
 100bef6:	4a0b      	ldr	r2, [pc, #44]	; (100bf24 <att_get+0x7c>)
 100bef8:	480b      	ldr	r0, [pc, #44]	; (100bf28 <att_get+0x80>)
 100befa:	f018 fe6c 	bl	1024bd6 <assert_print>
 100befe:	480b      	ldr	r0, [pc, #44]	; (100bf2c <att_get+0x84>)
 100bf00:	f018 fe69 	bl	1024bd6 <assert_print>
 100bf04:	f640 312a 	movw	r1, #2858	; 0xb2a
 100bf08:	4806      	ldr	r0, [pc, #24]	; (100bf24 <att_get+0x7c>)
 100bf0a:	f018 fe5d 	bl	1024bc8 <assert_post_action>
	return att_chan->att;
 100bf0e:	f853 0c08 	ldr.w	r0, [r3, #-8]
 100bf12:	e7d8      	b.n	100bec6 <att_get+0x1e>
 100bf14:	0102e21d 	.word	0x0102e21d
 100bf18:	0102995c 	.word	0x0102995c
 100bf1c:	0102e22b 	.word	0x0102e22b
 100bf20:	0102e246 	.word	0x0102e246
 100bf24:	0102e16a 	.word	0x0102e16a
 100bf28:	0102b695 	.word	0x0102b695
 100bf2c:	0102e276 	.word	0x0102e276

0100bf30 <bt_att_connected>:
{
 100bf30:	b510      	push	{r4, lr}
 100bf32:	4604      	mov	r4, r0
 100bf34:	f100 03f8 	add.w	r3, r0, #248	; 0xf8
 100bf38:	e8d3 1fef 	ldaex	r1, [r3]
 100bf3c:	f041 0104 	orr.w	r1, r1, #4
 100bf40:	e8c3 1fe2 	stlex	r2, r1, [r3]
 100bf44:	2a00      	cmp	r2, #0
 100bf46:	d1f7      	bne.n	100bf38 <bt_att_connected+0x8>
		le_chan->tx.mtu = BT_ATT_DEFAULT_LE_MTU;
 100bf48:	2317      	movs	r3, #23
	att_chan_mtu_updated(att_chan);
 100bf4a:	f1a4 0008 	sub.w	r0, r4, #8
		le_chan->tx.mtu = BT_ATT_DEFAULT_LE_MTU;
 100bf4e:	84e3      	strh	r3, [r4, #38]	; 0x26
		le_chan->rx.mtu = BT_ATT_DEFAULT_LE_MTU;
 100bf50:	82e3      	strh	r3, [r4, #22]
	att_chan_mtu_updated(att_chan);
 100bf52:	f01b fd45 	bl	10279e0 <att_chan_mtu_updated>
	k_work_init_delayable(&att_chan->timeout_work, att_timeout);
 100bf56:	f504 7090 	add.w	r0, r4, #288	; 0x120
 100bf5a:	4904      	ldr	r1, [pc, #16]	; (100bf6c <bt_att_connected+0x3c>)
 100bf5c:	f015 ffd6 	bl	1021f0c <k_work_init_delayable>
	bt_gatt_connected(le_chan->chan.conn);
 100bf60:	6820      	ldr	r0, [r4, #0]
}
 100bf62:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_gatt_connected(le_chan->chan.conn);
 100bf66:	f002 bd01 	b.w	100e96c <bt_gatt_connected>
 100bf6a:	bf00      	nop
 100bf6c:	0100cc49 	.word	0x0100cc49

0100bf70 <read_group_cb>:
{
 100bf70:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
 100bf74:	f04f 0800 	mov.w	r8, #0
 100bf78:	f44f 5320 	mov.w	r3, #10240	; 0x2800
{
 100bf7c:	4605      	mov	r5, r0
 100bf7e:	460e      	mov	r6, r1
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
 100bf80:	6800      	ldr	r0, [r0, #0]
 100bf82:	a902      	add	r1, sp, #8
{
 100bf84:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
 100bf86:	6817      	ldr	r7, [r2, #0]
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
 100bf88:	f88d 8008 	strb.w	r8, [sp, #8]
 100bf8c:	f8ad 300a 	strh.w	r3, [sp, #10]
 100bf90:	f01a fd96 	bl	1026ac0 <bt_uuid_cmp>
 100bf94:	b1a0      	cbz	r0, 100bfc0 <read_group_cb+0x50>
	    bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
 100bf96:	f642 0301 	movw	r3, #10241	; 0x2801
 100bf9a:	6828      	ldr	r0, [r5, #0]
 100bf9c:	a903      	add	r1, sp, #12
 100bf9e:	f88d 800c 	strb.w	r8, [sp, #12]
 100bfa2:	f8ad 300e 	strh.w	r3, [sp, #14]
 100bfa6:	f01a fd8b 	bl	1026ac0 <bt_uuid_cmp>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
 100bfaa:	b148      	cbz	r0, 100bfc0 <read_group_cb+0x50>
		if (data->group &&
 100bfac:	6923      	ldr	r3, [r4, #16]
 100bfae:	b11b      	cbz	r3, 100bfb8 <read_group_cb+0x48>
 100bfb0:	885a      	ldrh	r2, [r3, #2]
 100bfb2:	42b2      	cmp	r2, r6
 100bfb4:	d200      	bcs.n	100bfb8 <read_group_cb+0x48>
			data->group->end_handle = sys_cpu_to_le16(handle);
 100bfb6:	805e      	strh	r6, [r3, #2]
		return BT_GATT_ITER_CONTINUE;
 100bfb8:	2001      	movs	r0, #1
}
 100bfba:	b004      	add	sp, #16
 100bfbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
 100bfc0:	6861      	ldr	r1, [r4, #4]
 100bfc2:	6828      	ldr	r0, [r5, #0]
 100bfc4:	f01a fd7c 	bl	1026ac0 <bt_uuid_cmp>
 100bfc8:	b110      	cbz	r0, 100bfd0 <read_group_cb+0x60>
		data->group = NULL;
 100bfca:	2300      	movs	r3, #0
 100bfcc:	6123      	str	r3, [r4, #16]
		return BT_GATT_ITER_CONTINUE;
 100bfce:	e7f3      	b.n	100bfb8 <read_group_cb+0x48>
	if (data->rsp->len &&
 100bfd0:	68e3      	ldr	r3, [r4, #12]
	    chan->chan.tx.mtu - data->buf->len < data->rsp->len) {
 100bfd2:	68a0      	ldr	r0, [r4, #8]
	if (data->rsp->len &&
 100bfd4:	781a      	ldrb	r2, [r3, #0]
 100bfd6:	b132      	cbz	r2, 100bfe6 <read_group_cb+0x76>
	    chan->chan.tx.mtu - data->buf->len < data->rsp->len) {
 100bfd8:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 100bfda:	8a01      	ldrh	r1, [r0, #16]
 100bfdc:	1a5b      	subs	r3, r3, r1
	if (data->rsp->len &&
 100bfde:	4293      	cmp	r3, r2
 100bfe0:	da01      	bge.n	100bfe6 <read_group_cb+0x76>
		return BT_GATT_ITER_STOP;
 100bfe2:	2000      	movs	r0, #0
 100bfe4:	e7e9      	b.n	100bfba <read_group_cb+0x4a>
	return net_buf_simple_add(&buf->b, len);
 100bfe6:	2104      	movs	r1, #4
 100bfe8:	300c      	adds	r0, #12
 100bfea:	f012 f955 	bl	101e298 <net_buf_simple_add>
	data->group = net_buf_add(data->buf, sizeof(*data->group));
 100bfee:	6120      	str	r0, [r4, #16]
	data->group->start_handle = sys_cpu_to_le16(handle);
 100bff0:	8006      	strh	r6, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(handle);
 100bff2:	6923      	ldr	r3, [r4, #16]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
 100bff4:	4629      	mov	r1, r5
	data->group->end_handle = sys_cpu_to_le16(handle);
 100bff6:	805e      	strh	r6, [r3, #2]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
 100bff8:	4b07      	ldr	r3, [pc, #28]	; (100c018 <read_group_cb+0xa8>)
 100bffa:	9401      	str	r4, [sp, #4]
 100bffc:	9300      	str	r3, [sp, #0]
 100bffe:	4638      	mov	r0, r7
 100c000:	2300      	movs	r3, #0
 100c002:	68a2      	ldr	r2, [r4, #8]
 100c004:	f01b fd75 	bl	1027af2 <att_chan_read>
	if (read < 0) {
 100c008:	2800      	cmp	r0, #0
 100c00a:	dbea      	blt.n	100bfe2 <read_group_cb+0x72>
	if (!data->group) {
 100c00c:	6920      	ldr	r0, [r4, #16]
 100c00e:	3800      	subs	r0, #0
 100c010:	bf18      	it	ne
 100c012:	2001      	movne	r0, #1
 100c014:	e7d1      	b.n	100bfba <read_group_cb+0x4a>
 100c016:	bf00      	nop
 100c018:	01027a4b 	.word	0x01027a4b

0100c01c <read_type_cb>:
{
 100c01c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	struct bt_att_chan *chan = data->chan;
 100c020:	6817      	ldr	r7, [r2, #0]
{
 100c022:	4605      	mov	r5, r0
 100c024:	4688      	mov	r8, r1
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
 100c026:	6800      	ldr	r0, [r0, #0]
 100c028:	6851      	ldr	r1, [r2, #4]
{
 100c02a:	4614      	mov	r4, r2
	struct bt_conn *conn = chan->chan.chan.conn;
 100c02c:	68be      	ldr	r6, [r7, #8]
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
 100c02e:	f01a fd47 	bl	1026ac0 <bt_uuid_cmp>
 100c032:	4681      	mov	r9, r0
 100c034:	2800      	cmp	r0, #0
 100c036:	d13c      	bne.n	100c0b2 <read_type_cb+0x96>
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
 100c038:	4630      	mov	r0, r6
 100c03a:	2295      	movs	r2, #149	; 0x95
 100c03c:	4629      	mov	r1, r5
 100c03e:	f01c faab 	bl	1028598 <bt_gatt_check_perm>
 100c042:	4606      	mov	r6, r0
 100c044:	7520      	strb	r0, [r4, #20]
	if (data->err) {
 100c046:	b140      	cbz	r0, 100c05a <read_type_cb+0x3e>
		if (data->rsp->len) {
 100c048:	68e3      	ldr	r3, [r4, #12]
 100c04a:	781b      	ldrb	r3, [r3, #0]
 100c04c:	b10b      	cbz	r3, 100c052 <read_type_cb+0x36>
			data->err = 0x00;
 100c04e:	f884 9014 	strb.w	r9, [r4, #20]
		return BT_GATT_ITER_STOP;
 100c052:	2000      	movs	r0, #0
}
 100c054:	b003      	add	sp, #12
 100c056:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	data->item = net_buf_add(net_buf_frag_last(data->buf),
 100c05a:	68a0      	ldr	r0, [r4, #8]
 100c05c:	f012 f81a 	bl	101e094 <net_buf_frag_last>
 100c060:	2102      	movs	r1, #2
 100c062:	300c      	adds	r0, #12
 100c064:	f012 f918 	bl	101e298 <net_buf_simple_add>
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
 100c068:	4b13      	ldr	r3, [pc, #76]	; (100c0b8 <read_type_cb+0x9c>)
	data->item = net_buf_add(net_buf_frag_last(data->buf),
 100c06a:	6120      	str	r0, [r4, #16]
	data->item->handle = sys_cpu_to_le16(handle);
 100c06c:	f8a0 8000 	strh.w	r8, [r0]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
 100c070:	9300      	str	r3, [sp, #0]
 100c072:	9401      	str	r4, [sp, #4]
 100c074:	4633      	mov	r3, r6
 100c076:	4629      	mov	r1, r5
 100c078:	4638      	mov	r0, r7
 100c07a:	68a2      	ldr	r2, [r4, #8]
 100c07c:	f01b fd39 	bl	1027af2 <att_chan_read>
	if (read < 0) {
 100c080:	2800      	cmp	r0, #0
 100c082:	da07      	bge.n	100c094 <read_type_cb+0x78>
	if (err < 0 && err >= -0xff) {
 100c084:	f110 0fff 	cmn.w	r0, #255	; 0xff
	return BT_ATT_ERR_UNLIKELY;
 100c088:	bf32      	itee	cc
 100c08a:	200e      	movcc	r0, #14
		return -err;
 100c08c:	4240      	negcs	r0, r0
 100c08e:	b2c0      	uxtbcs	r0, r0
		data->err = err_to_att(read);
 100c090:	7520      	strb	r0, [r4, #20]
		return BT_GATT_ITER_STOP;
 100c092:	e7de      	b.n	100c052 <read_type_cb+0x36>
	if (!data->item) {
 100c094:	6923      	ldr	r3, [r4, #16]
 100c096:	2b00      	cmp	r3, #0
 100c098:	d0db      	beq.n	100c052 <read_type_cb+0x36>
	return chan->chan.tx.mtu - net_buf_frags_len(data->buf) >
 100c09a:	68a0      	ldr	r0, [r4, #8]
 100c09c:	f01b fbf8 	bl	1027890 <net_buf_frags_len>
 100c0a0:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 100c0a2:	1a18      	subs	r0, r3, r0
	       data->rsp->len ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
 100c0a4:	68e3      	ldr	r3, [r4, #12]
 100c0a6:	781b      	ldrb	r3, [r3, #0]
 100c0a8:	4298      	cmp	r0, r3
 100c0aa:	bf94      	ite	ls
 100c0ac:	2000      	movls	r0, #0
 100c0ae:	2001      	movhi	r0, #1
 100c0b0:	e7d0      	b.n	100c054 <read_type_cb+0x38>
		return BT_GATT_ITER_CONTINUE;
 100c0b2:	2001      	movs	r0, #1
 100c0b4:	e7ce      	b.n	100c054 <read_type_cb+0x38>
 100c0b6:	bf00      	nop
 100c0b8:	010278a1 	.word	0x010278a1

0100c0bc <bt_att_accept>:

}
#endif /* CONFIG_BT_EATT */

static int bt_att_accept(struct bt_conn *conn, struct bt_l2cap_chan **ch)
{
 100c0bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100c0c0:	b082      	sub	sp, #8
 100c0c2:	af00      	add	r7, sp, #0
 100c0c4:	4604      	mov	r4, r0
 100c0c6:	460e      	mov	r6, r1
	struct bt_att *att;
	struct bt_att_chan *chan;

	LOG_DBG("conn %p handle %u", conn, conn->handle);

	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
 100c0c8:	2200      	movs	r2, #0
 100c0ca:	2300      	movs	r3, #0
 100c0cc:	4639      	mov	r1, r7
 100c0ce:	483a      	ldr	r0, [pc, #232]	; (100c1b8 <bt_att_accept+0xfc>)
 100c0d0:	f014 fe14 	bl	1020cfc <k_mem_slab_alloc>
 100c0d4:	4605      	mov	r5, r0
 100c0d6:	b1a8      	cbz	r0, 100c104 <bt_att_accept+0x48>
		LOG_ERR("No available ATT context for conn %p", conn);
 100c0d8:	466d      	mov	r5, sp
 100c0da:	b088      	sub	sp, #32
 100c0dc:	466a      	mov	r2, sp
 100c0de:	4b37      	ldr	r3, [pc, #220]	; (100c1bc <bt_att_accept+0x100>)
 100c0e0:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100c0e4:	e9c2 3405 	strd	r3, r4, [r2, #20]
 100c0e8:	2303      	movs	r3, #3
 100c0ea:	4835      	ldr	r0, [pc, #212]	; (100c1c0 <bt_att_accept+0x104>)
 100c0ec:	f842 3f10 	str.w	r3, [r2, #16]!
 100c0f0:	f01b fcbb 	bl	1027a6a <z_log_msg_static_create.constprop.0>
 100c0f4:	46ad      	mov	sp, r5
		return -ENOMEM;
 100c0f6:	f06f 050b 	mvn.w	r5, #11
	}

	*ch = &chan->chan.chan;

	return 0;
}
 100c0fa:	4628      	mov	r0, r5
 100c0fc:	3708      	adds	r7, #8
 100c0fe:	46bd      	mov	sp, r7
 100c100:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return z_impl_z_current_get();
 100c104:	f017 f9a6 	bl	1023454 <z_impl_z_current_get>
	att_handle_rsp_thread = k_current_get();
 100c108:	4b2e      	ldr	r3, [pc, #184]	; (100c1c4 <bt_att_accept+0x108>)
	(void)memset(att, 0, sizeof(*att));
 100c10a:	4629      	mov	r1, r5
	att_handle_rsp_thread = k_current_get();
 100c10c:	6018      	str	r0, [r3, #0]
	(void)memset(att, 0, sizeof(*att));
 100c10e:	2230      	movs	r2, #48	; 0x30
 100c110:	6838      	ldr	r0, [r7, #0]
 100c112:	f01a fc3a 	bl	102698a <memset>
	att->conn = conn;
 100c116:	683b      	ldr	r3, [r7, #0]
	if (k_mem_slab_alloc(&chan_slab, (void **)&chan, K_NO_WAIT)) {
 100c118:	2200      	movs	r2, #0
	att->conn = conn;
 100c11a:	601c      	str	r4, [r3, #0]
	sys_slist_init(&att->reqs);
 100c11c:	683c      	ldr	r4, [r7, #0]
	if (k_mem_slab_alloc(&chan_slab, (void **)&chan, K_NO_WAIT)) {
 100c11e:	2300      	movs	r3, #0
	list->tail = NULL;
 100c120:	e9c4 5501 	strd	r5, r5, [r4, #4]
 100c124:	e9c4 550a 	strd	r5, r5, [r4, #40]	; 0x28
 100c128:	4827      	ldr	r0, [pc, #156]	; (100c1c8 <bt_att_accept+0x10c>)
 100c12a:	1d39      	adds	r1, r7, #4
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
 100c12c:	607d      	str	r5, [r7, #4]
	if (k_mem_slab_alloc(&chan_slab, (void **)&chan, K_NO_WAIT)) {
 100c12e:	f014 fde5 	bl	1020cfc <k_mem_slab_alloc>
 100c132:	4605      	mov	r5, r0
 100c134:	b180      	cbz	r0, 100c158 <bt_att_accept+0x9c>
		LOG_WRN("No available ATT channel for conn %p", att->conn);
 100c136:	6823      	ldr	r3, [r4, #0]
 100c138:	466c      	mov	r4, sp
 100c13a:	b088      	sub	sp, #32
 100c13c:	466a      	mov	r2, sp
 100c13e:	4923      	ldr	r1, [pc, #140]	; (100c1cc <bt_att_accept+0x110>)
 100c140:	481f      	ldr	r0, [pc, #124]	; (100c1c0 <bt_att_accept+0x104>)
 100c142:	e9c2 1305 	strd	r1, r3, [r2, #20]
 100c146:	2303      	movs	r3, #3
 100c148:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100c14c:	f842 3f10 	str.w	r3, [r2, #16]!
 100c150:	f01b fc8b 	bl	1027a6a <z_log_msg_static_create.constprop.0>
 100c154:	46a5      	mov	sp, r4
	if (!chan) {
 100c156:	e7ce      	b.n	100c0f6 <bt_att_accept+0x3a>
	(void)memset(chan, 0, sizeof(*chan));
 100c158:	4601      	mov	r1, r0
 100c15a:	f44f 72b0 	mov.w	r2, #352	; 0x160
 100c15e:	6878      	ldr	r0, [r7, #4]
 100c160:	f01a fc13 	bl	102698a <memset>
	chan->chan.chan.ops = &ops;
 100c164:	6878      	ldr	r0, [r7, #4]
 100c166:	4b1a      	ldr	r3, [pc, #104]	; (100c1d0 <bt_att_accept+0x114>)
 100c168:	60c3      	str	r3, [r0, #12]
	z_impl_k_queue_init(queue);
 100c16a:	f500 7084 	add.w	r0, r0, #264	; 0x108
 100c16e:	f01d f8b0 	bl	10292d2 <z_impl_k_queue_init>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 100c172:	687b      	ldr	r3, [r7, #4]
 100c174:	f503 7380 	add.w	r3, r3, #256	; 0x100
 100c178:	e8d3 2fef 	ldaex	r2, [r3]
 100c17c:	e8c3 5fe1 	stlex	r1, r5, [r3]
 100c180:	2900      	cmp	r1, #0
 100c182:	d1f9      	bne.n	100c178 <bt_att_accept+0xbc>
	chan->att = att;
 100c184:	687b      	ldr	r3, [r7, #4]
 100c186:	601c      	str	r4, [r3, #0]
	if (sys_slist_is_empty(&att->chans)) {
 100c188:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	att_chan_attach(att, chan);
 100c18a:	f8d7 8004 	ldr.w	r8, [r7, #4]
	if (sys_slist_is_empty(&att->chans)) {
 100c18e:	b91b      	cbnz	r3, 100c198 <bt_att_accept+0xdc>
 100c190:	f104 000c 	add.w	r0, r4, #12
 100c194:	f01d f89d 	bl	10292d2 <z_impl_k_queue_init>
	return list->head;
 100c198:	6aa2      	ldr	r2, [r4, #40]	; 0x28
	sys_slist_prepend(&att->chans, &chan->node);
 100c19a:	f508 73ac 	add.w	r3, r8, #344	; 0x158
	parent->next = child;
 100c19e:	f8c8 2158 	str.w	r2, [r8, #344]	; 0x158
Z_GENLIST_PREPEND(slist, snode)
 100c1a2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
	list->head = node;
 100c1a4:	62a3      	str	r3, [r4, #40]	; 0x28
Z_GENLIST_PREPEND(slist, snode)
 100c1a6:	b902      	cbnz	r2, 100c1aa <bt_att_accept+0xee>
	list->tail = node;
 100c1a8:	62e3      	str	r3, [r4, #44]	; 0x2c
	return chan;
 100c1aa:	687b      	ldr	r3, [r7, #4]
	if (!chan) {
 100c1ac:	2b00      	cmp	r3, #0
 100c1ae:	d0a2      	beq.n	100c0f6 <bt_att_accept+0x3a>
	*ch = &chan->chan.chan;
 100c1b0:	3308      	adds	r3, #8
 100c1b2:	6033      	str	r3, [r6, #0]
	return 0;
 100c1b4:	e7a1      	b.n	100c0fa <bt_att_accept+0x3e>
 100c1b6:	bf00      	nop
 100c1b8:	21000c10 	.word	0x21000c10
 100c1bc:	0102e292 	.word	0x0102e292
 100c1c0:	0102995c 	.word	0x0102995c
 100c1c4:	210047c4 	.word	0x210047c4
 100c1c8:	21000c30 	.word	0x21000c30
 100c1cc:	0102e2b7 	.word	0x0102e2b7
 100c1d0:	21000400 	.word	0x21000400

0100c1d4 <bt_att_chan_create_pdu>:
{
 100c1d4:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 100c1d8:	b086      	sub	sp, #24
 100c1da:	460d      	mov	r5, r1
	if (len + sizeof(op) > chan->chan.tx.mtu) {
 100c1dc:	8dc1      	ldrh	r1, [r0, #46]	; 0x2e
 100c1de:	1c53      	adds	r3, r2, #1
 100c1e0:	428b      	cmp	r3, r1
{
 100c1e2:	af00      	add	r7, sp, #0
	if (len + sizeof(op) > chan->chan.tx.mtu) {
 100c1e4:	d915      	bls.n	100c212 <bt_att_chan_create_pdu+0x3e>
		LOG_WRN("ATT MTU exceeded, max %u, wanted %zu", chan->chan.tx.mtu,
 100c1e6:	466c      	mov	r4, sp
 100c1e8:	b088      	sub	sp, #32
 100c1ea:	466a      	mov	r2, sp
 100c1ec:	4829      	ldr	r0, [pc, #164]	; (100c294 <bt_att_chan_create_pdu+0xc0>)
 100c1ee:	61d3      	str	r3, [r2, #28]
 100c1f0:	2304      	movs	r3, #4
 100c1f2:	e9c2 0105 	strd	r0, r1, [r2, #20]
 100c1f6:	f44f 5102 	mov.w	r1, #8320	; 0x2080
 100c1fa:	f842 3f10 	str.w	r3, [r2, #16]!
		LOG_ERR("Unable to allocate buffer for op 0x%02x", op);
 100c1fe:	4826      	ldr	r0, [pc, #152]	; (100c298 <bt_att_chan_create_pdu+0xc4>)
 100c200:	f01b fc33 	bl	1027a6a <z_log_msg_static_create.constprop.0>
 100c204:	46a5      	mov	sp, r4
		return NULL;
 100c206:	2400      	movs	r4, #0
}
 100c208:	4620      	mov	r0, r4
 100c20a:	3718      	adds	r7, #24
 100c20c:	46bd      	mov	sp, r7
 100c20e:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
	switch (att_op_get_type(op)) {
 100c212:	4628      	mov	r0, r5
 100c214:	f7ff fc6c 	bl	100baf0 <att_op_get_type>
 100c218:	2802      	cmp	r0, #2
 100c21a:	d019      	beq.n	100c250 <bt_att_chan_create_pdu+0x7c>
 100c21c:	2804      	cmp	r0, #4
 100c21e:	d017      	beq.n	100c250 <bt_att_chan_create_pdu+0x7c>
		timeout = K_FOREVER;
 100c220:	f04f 38ff 	mov.w	r8, #4294967295
 100c224:	f04f 39ff 	mov.w	r9, #4294967295
	buf = bt_l2cap_create_pdu_timeout(NULL, 0, timeout);
 100c228:	2100      	movs	r1, #0
 100c22a:	4642      	mov	r2, r8
 100c22c:	464b      	mov	r3, r9
 100c22e:	4608      	mov	r0, r1
 100c230:	f01b f991 	bl	1027556 <bt_l2cap_create_pdu_timeout>
	if (!buf) {
 100c234:	4604      	mov	r4, r0
 100c236:	b980      	cbnz	r0, 100c25a <bt_att_chan_create_pdu+0x86>
		LOG_ERR("Unable to allocate buffer for op 0x%02x", op);
 100c238:	466c      	mov	r4, sp
 100c23a:	b088      	sub	sp, #32
 100c23c:	466a      	mov	r2, sp
 100c23e:	4b17      	ldr	r3, [pc, #92]	; (100c29c <bt_att_chan_create_pdu+0xc8>)
 100c240:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100c244:	e9c2 3505 	strd	r3, r5, [r2, #20]
 100c248:	2303      	movs	r3, #3
 100c24a:	f842 3f10 	str.w	r3, [r2, #16]!
 100c24e:	e7d6      	b.n	100c1fe <bt_att_chan_create_pdu+0x2a>
	switch (att_op_get_type(op)) {
 100c250:	f44f 2870 	mov.w	r8, #983040	; 0xf0000
 100c254:	f04f 0900 	mov.w	r9, #0
 100c258:	e7e6      	b.n	100c228 <bt_att_chan_create_pdu+0x54>
	return z_impl_k_queue_get(queue, timeout);
 100c25a:	4811      	ldr	r0, [pc, #68]	; (100c2a0 <bt_att_chan_create_pdu+0xcc>)
 100c25c:	4642      	mov	r2, r8
 100c25e:	464b      	mov	r3, r9
 100c260:	f015 f9b4 	bl	10215cc <z_impl_k_queue_get>
	if (!data) {
 100c264:	b970      	cbnz	r0, 100c284 <bt_att_chan_create_pdu+0xb0>
		LOG_WRN("Unable to allocate ATT TX meta");
 100c266:	4b0f      	ldr	r3, [pc, #60]	; (100c2a4 <bt_att_chan_create_pdu+0xd0>)
 100c268:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100c26c:	617b      	str	r3, [r7, #20]
 100c26e:	2302      	movs	r3, #2
 100c270:	4809      	ldr	r0, [pc, #36]	; (100c298 <bt_att_chan_create_pdu+0xc4>)
 100c272:	613b      	str	r3, [r7, #16]
 100c274:	f107 0210 	add.w	r2, r7, #16
 100c278:	f01b fbf7 	bl	1027a6a <z_log_msg_static_create.constprop.0>
		net_buf_unref(buf);
 100c27c:	4620      	mov	r0, r4
 100c27e:	f011 feaf 	bl	101dfe0 <net_buf_unref>
		return NULL;
 100c282:	e7c0      	b.n	100c206 <bt_att_chan_create_pdu+0x32>
	bt_att_tx_meta_data(buf) = data;
 100c284:	61a0      	str	r0, [r4, #24]
 100c286:	2101      	movs	r1, #1
 100c288:	f104 000c 	add.w	r0, r4, #12
 100c28c:	f012 f804 	bl	101e298 <net_buf_simple_add>
	hdr->code = op;
 100c290:	7005      	strb	r5, [r0, #0]
	return buf;
 100c292:	e7b9      	b.n	100c208 <bt_att_chan_create_pdu+0x34>
 100c294:	0102e2dc 	.word	0x0102e2dc
 100c298:	0102995c 	.word	0x0102995c
 100c29c:	0102dca9 	.word	0x0102dca9
 100c2a0:	21000d28 	.word	0x21000d28
 100c2a4:	0102e301 	.word	0x0102e301

0100c2a8 <bt_att_recv>:
{
 100c2a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100c2ac:	b087      	sub	sp, #28
	if (buf->len < sizeof(*hdr)) {
 100c2ae:	8a0b      	ldrh	r3, [r1, #16]
{
 100c2b0:	4682      	mov	sl, r0
 100c2b2:	460c      	mov	r4, r1
 100c2b4:	af00      	add	r7, sp, #0
	if (buf->len < sizeof(*hdr)) {
 100c2b6:	b97b      	cbnz	r3, 100c2d8 <bt_att_recv+0x30>
		LOG_ERR("Too small ATT PDU received");
 100c2b8:	4b4c      	ldr	r3, [pc, #304]	; (100c3ec <bt_att_recv+0x144>)
 100c2ba:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100c2be:	617b      	str	r3, [r7, #20]
 100c2c0:	2302      	movs	r3, #2
 100c2c2:	f107 0210 	add.w	r2, r7, #16
 100c2c6:	613b      	str	r3, [r7, #16]
			LOG_WRN("Ignoring unexpected request");
 100c2c8:	4849      	ldr	r0, [pc, #292]	; (100c3f0 <bt_att_recv+0x148>)
 100c2ca:	f01b fbce 	bl	1027a6a <z_log_msg_static_create.constprop.0>
}
 100c2ce:	2000      	movs	r0, #0
 100c2d0:	371c      	adds	r7, #28
 100c2d2:	46bd      	mov	sp, r7
 100c2d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return net_buf_simple_pull_mem(&buf->b, len);
 100c2d8:	2101      	movs	r1, #1
 100c2da:	f104 000c 	add.w	r0, r4, #12
 100c2de:	f011 ffbd 	bl	101e25c <net_buf_simple_pull_mem>
	if (!att_chan->att) {
 100c2e2:	f85a 3c08 	ldr.w	r3, [sl, #-8]
 100c2e6:	4605      	mov	r5, r0
 100c2e8:	2b00      	cmp	r3, #0
 100c2ea:	d0f0      	beq.n	100c2ce <bt_att_recv+0x26>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
 100c2ec:	2300      	movs	r3, #0
		if (hdr->code == handlers[i].op) {
 100c2ee:	7801      	ldrb	r1, [r0, #0]
 100c2f0:	f8df 8100 	ldr.w	r8, [pc, #256]	; 100c3f4 <bt_att_recv+0x14c>
	struct bt_att_chan *att_chan = ATT_CHAN(chan);
 100c2f4:	f1aa 0608 	sub.w	r6, sl, #8
		if (hdr->code == handlers[i].op) {
 100c2f8:	f818 0033 	ldrb.w	r0, [r8, r3, lsl #3]
 100c2fc:	ea4f 0bc3 	mov.w	fp, r3, lsl #3
 100c300:	4288      	cmp	r0, r1
 100c302:	eb08 02c3 	add.w	r2, r8, r3, lsl #3
 100c306:	d114      	bne.n	100c332 <bt_att_recv+0x8a>
		if (handler->type == ATT_REQUEST &&
 100c308:	f892 9002 	ldrb.w	r9, [r2, #2]
 100c30c:	f1b9 0f01 	cmp.w	r9, #1
 100c310:	d131      	bne.n	100c376 <bt_att_recv+0xce>
		    atomic_test_and_set_bit(att_chan->flags, ATT_PENDING_RSP)) {
 100c312:	2100      	movs	r1, #0
 100c314:	f10a 00f8 	add.w	r0, sl, #248	; 0xf8
 100c318:	f01b fc91 	bl	1027c3e <atomic_test_and_set_bit>
		if (handler->type == ATT_REQUEST &&
 100c31c:	2800      	cmp	r0, #0
 100c31e:	d035      	beq.n	100c38c <bt_att_recv+0xe4>
			LOG_WRN("Ignoring unexpected request");
 100c320:	4b35      	ldr	r3, [pc, #212]	; (100c3f8 <bt_att_recv+0x150>)
 100c322:	617b      	str	r3, [r7, #20]
 100c324:	2302      	movs	r3, #2
 100c326:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100c32a:	613b      	str	r3, [r7, #16]
 100c32c:	f107 0210 	add.w	r2, r7, #16
 100c330:	e7ca      	b.n	100c2c8 <bt_att_recv+0x20>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
 100c332:	3301      	adds	r3, #1
 100c334:	2b0e      	cmp	r3, #14
 100c336:	d1df      	bne.n	100c2f8 <bt_att_recv+0x50>
		LOG_WRN("Unhandled ATT code 0x%02x", hdr->code);
 100c338:	466c      	mov	r4, sp
 100c33a:	b088      	sub	sp, #32
 100c33c:	466a      	mov	r2, sp
 100c33e:	4b2f      	ldr	r3, [pc, #188]	; (100c3fc <bt_att_recv+0x154>)
 100c340:	482b      	ldr	r0, [pc, #172]	; (100c3f0 <bt_att_recv+0x148>)
 100c342:	e9c2 3105 	strd	r3, r1, [r2, #20]
 100c346:	2303      	movs	r3, #3
 100c348:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100c34c:	f842 3f10 	str.w	r3, [r2, #16]!
 100c350:	f01b fb8b 	bl	1027a6a <z_log_msg_static_create.constprop.0>
		if (att_op_get_type(hdr->code) != ATT_COMMAND &&
 100c354:	7829      	ldrb	r1, [r5, #0]
 100c356:	46a5      	mov	sp, r4
 100c358:	4608      	mov	r0, r1
 100c35a:	f7ff fbc9 	bl	100baf0 <att_op_get_type>
 100c35e:	2800      	cmp	r0, #0
 100c360:	d0b5      	beq.n	100c2ce <bt_att_recv+0x26>
 100c362:	2805      	cmp	r0, #5
 100c364:	d0b3      	beq.n	100c2ce <bt_att_recv+0x26>
	if (!req) {
 100c366:	2900      	cmp	r1, #0
 100c368:	d0b1      	beq.n	100c2ce <bt_att_recv+0x26>
 100c36a:	2306      	movs	r3, #6
 100c36c:	2200      	movs	r2, #0
 100c36e:	4630      	mov	r0, r6
 100c370:	f01b fdcd 	bl	1027f0e <send_err_rsp.part.0>
 100c374:	e7ab      	b.n	100c2ce <bt_att_recv+0x26>
		} else if (handler->type == ATT_INDICATION &&
 100c376:	f1b9 0f05 	cmp.w	r9, #5
 100c37a:	d107      	bne.n	100c38c <bt_att_recv+0xe4>
			   atomic_test_and_set_bit(att_chan->flags,
 100c37c:	2101      	movs	r1, #1
 100c37e:	f10a 00f8 	add.w	r0, sl, #248	; 0xf8
 100c382:	f01b fc5c 	bl	1027c3e <atomic_test_and_set_bit>
		} else if (handler->type == ATT_INDICATION &&
 100c386:	b108      	cbz	r0, 100c38c <bt_att_recv+0xe4>
			LOG_WRN("Ignoring unexpected indication");
 100c388:	4b1d      	ldr	r3, [pc, #116]	; (100c400 <bt_att_recv+0x158>)
 100c38a:	e7ca      	b.n	100c322 <bt_att_recv+0x7a>
	if (buf->len < handler->expect_len) {
 100c38c:	44d8      	add	r8, fp
 100c38e:	8a23      	ldrh	r3, [r4, #16]
 100c390:	f898 2001 	ldrb.w	r2, [r8, #1]
 100c394:	429a      	cmp	r2, r3
 100c396:	d916      	bls.n	100c3c6 <bt_att_recv+0x11e>
		LOG_ERR("Invalid len %u for code 0x%02x", buf->len, hdr->code);
 100c398:	46e9      	mov	r9, sp
 100c39a:	b088      	sub	sp, #32
 100c39c:	466a      	mov	r2, sp
 100c39e:	7829      	ldrb	r1, [r5, #0]
 100c3a0:	2404      	movs	r4, #4
 100c3a2:	4818      	ldr	r0, [pc, #96]	; (100c404 <bt_att_recv+0x15c>)
 100c3a4:	61d1      	str	r1, [r2, #28]
 100c3a6:	e9c2 0305 	strd	r0, r3, [r2, #20]
 100c3aa:	f44f 5101 	mov.w	r1, #8256	; 0x2040
 100c3ae:	4810      	ldr	r0, [pc, #64]	; (100c3f0 <bt_att_recv+0x148>)
 100c3b0:	f842 4f10 	str.w	r4, [r2, #16]!
 100c3b4:	f01b fb59 	bl	1027a6a <z_log_msg_static_create.constprop.0>
	if (handler->type == ATT_REQUEST && err) {
 100c3b8:	f898 3002 	ldrb.w	r3, [r8, #2]
 100c3bc:	46cd      	mov	sp, r9
 100c3be:	2b01      	cmp	r3, #1
 100c3c0:	d185      	bne.n	100c2ce <bt_att_recv+0x26>
		err = BT_ATT_ERR_INVALID_PDU;
 100c3c2:	4623      	mov	r3, r4
 100c3c4:	e00c      	b.n	100c3e0 <bt_att_recv+0x138>
		err = handler->func(att_chan, buf);
 100c3c6:	f8d8 3004 	ldr.w	r3, [r8, #4]
 100c3ca:	4621      	mov	r1, r4
 100c3cc:	4630      	mov	r0, r6
 100c3ce:	4798      	blx	r3
	if (handler->type == ATT_REQUEST && err) {
 100c3d0:	f1b9 0f01 	cmp.w	r9, #1
		err = handler->func(att_chan, buf);
 100c3d4:	4603      	mov	r3, r0
	if (handler->type == ATT_REQUEST && err) {
 100c3d6:	f47f af7a 	bne.w	100c2ce <bt_att_recv+0x26>
 100c3da:	2800      	cmp	r0, #0
 100c3dc:	f43f af77 	beq.w	100c2ce <bt_att_recv+0x26>
		send_err_rsp(att_chan, hdr->code, 0, err);
 100c3e0:	7829      	ldrb	r1, [r5, #0]
	if (!req) {
 100c3e2:	2900      	cmp	r1, #0
 100c3e4:	f43f af73 	beq.w	100c2ce <bt_att_recv+0x26>
 100c3e8:	e7c0      	b.n	100c36c <bt_att_recv+0xc4>
 100c3ea:	bf00      	nop
 100c3ec:	0102e320 	.word	0x0102e320
 100c3f0:	0102995c 	.word	0x0102995c
 100c3f4:	01029ffc 	.word	0x01029ffc
 100c3f8:	0102e355 	.word	0x0102e355
 100c3fc:	0102e33b 	.word	0x0102e33b
 100c400:	0102e371 	.word	0x0102e371
 100c404:	0102e390 	.word	0x0102e390

0100c408 <att_write_rsp.constprop.0>:
static uint8_t att_write_rsp(struct bt_att_chan *chan, uint8_t req, uint8_t rsp,
 100c408:	b5f0      	push	{r4, r5, r6, r7, lr}
 100c40a:	461e      	mov	r6, r3
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
 100c40c:	6803      	ldr	r3, [r0, #0]
 100c40e:	460d      	mov	r5, r1
 100c410:	3900      	subs	r1, #0
static uint8_t att_write_rsp(struct bt_att_chan *chan, uint8_t req, uint8_t rsp,
 100c412:	4604      	mov	r4, r0
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
 100c414:	bf18      	it	ne
 100c416:	2101      	movne	r1, #1
static uint8_t att_write_rsp(struct bt_att_chan *chan, uint8_t req, uint8_t rsp,
 100c418:	b087      	sub	sp, #28
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
 100c41a:	6818      	ldr	r0, [r3, #0]
static uint8_t att_write_rsp(struct bt_att_chan *chan, uint8_t req, uint8_t rsp,
 100c41c:	4617      	mov	r7, r2
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
 100c41e:	f01c f8ef 	bl	1028600 <bt_gatt_change_aware>
 100c422:	b948      	cbnz	r0, 100c438 <att_write_rsp.constprop.0+0x30>
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
 100c424:	2105      	movs	r1, #5
 100c426:	f504 7080 	add.w	r0, r4, #256	; 0x100
 100c42a:	f01b fc08 	bl	1027c3e <atomic_test_and_set_bit>
 100c42e:	2800      	cmp	r0, #0
 100c430:	d048      	beq.n	100c4c4 <att_write_rsp.constprop.0+0xbc>
			return 0;
 100c432:	2000      	movs	r0, #0
}
 100c434:	b007      	add	sp, #28
 100c436:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!handle) {
 100c438:	2e00      	cmp	r6, #0
 100c43a:	d045      	beq.n	100c4c8 <att_write_rsp.constprop.0+0xc0>
	(void)memset(&data, 0, sizeof(data));
 100c43c:	2218      	movs	r2, #24
 100c43e:	2100      	movs	r1, #0
 100c440:	4668      	mov	r0, sp
 100c442:	f01a faa2 	bl	102698a <memset>
	if (rsp) {
 100c446:	bb67      	cbnz	r7, 100c4a2 <att_write_rsp.constprop.0+0x9a>
	data.conn = chan->att->conn;
 100c448:	6823      	ldr	r3, [r4, #0]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
 100c44a:	4631      	mov	r1, r6
	data.conn = chan->att->conn;
 100c44c:	681b      	ldr	r3, [r3, #0]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
 100c44e:	4630      	mov	r0, r6
	data.conn = chan->att->conn;
 100c450:	9300      	str	r3, [sp, #0]
	data.offset = offset;
 100c452:	2300      	movs	r3, #0
 100c454:	f8ad 3012 	strh.w	r3, [sp, #18]
	data.value = value;
 100c458:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
 100c45a:	4a1c      	ldr	r2, [pc, #112]	; (100c4cc <att_write_rsp.constprop.0+0xc4>)
	data.value = value;
 100c45c:	9303      	str	r3, [sp, #12]
	data.len = len;
 100c45e:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
	data.req = req;
 100c462:	f88d 5008 	strb.w	r5, [sp, #8]
	data.len = len;
 100c466:	f8ad 3010 	strh.w	r3, [sp, #16]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
 100c46a:	2301      	movs	r3, #1
 100c46c:	f88d 3014 	strb.w	r3, [sp, #20]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
 100c470:	466b      	mov	r3, sp
 100c472:	f01b fa5e 	bl	1027932 <bt_gatt_foreach_attr>
	if (data.err) {
 100c476:	f89d 3014 	ldrb.w	r3, [sp, #20]
 100c47a:	b1e3      	cbz	r3, 100c4b6 <att_write_rsp.constprop.0+0xae>
		if (rsp) {
 100c47c:	2f00      	cmp	r7, #0
 100c47e:	d0d8      	beq.n	100c432 <att_write_rsp.constprop.0+0x2a>
			tx_meta_data_free(bt_att_tx_meta_data(data.buf));
 100c480:	9b01      	ldr	r3, [sp, #4]
 100c482:	6998      	ldr	r0, [r3, #24]
 100c484:	f7ff fb7a 	bl	100bb7c <tx_meta_data_free>
			net_buf_unref(data.buf);
 100c488:	9801      	ldr	r0, [sp, #4]
 100c48a:	f011 fda9 	bl	101dfe0 <net_buf_unref>
			send_err_rsp(chan, req, handle, data.err);
 100c48e:	f89d 3014 	ldrb.w	r3, [sp, #20]
	if (!req) {
 100c492:	2d00      	cmp	r5, #0
 100c494:	d0cd      	beq.n	100c432 <att_write_rsp.constprop.0+0x2a>
 100c496:	4632      	mov	r2, r6
 100c498:	4629      	mov	r1, r5
 100c49a:	4620      	mov	r0, r4
 100c49c:	f01b fd37 	bl	1027f0e <send_err_rsp.part.0>
 100c4a0:	e7c7      	b.n	100c432 <att_write_rsp.constprop.0+0x2a>
		data.buf = bt_att_chan_create_pdu(chan, rsp, 0);
 100c4a2:	2200      	movs	r2, #0
 100c4a4:	4639      	mov	r1, r7
 100c4a6:	4620      	mov	r0, r4
 100c4a8:	f7ff fe94 	bl	100c1d4 <bt_att_chan_create_pdu>
 100c4ac:	9001      	str	r0, [sp, #4]
		if (!data.buf) {
 100c4ae:	2800      	cmp	r0, #0
 100c4b0:	d1ca      	bne.n	100c448 <att_write_rsp.constprop.0+0x40>
			return BT_ATT_ERR_UNLIKELY;
 100c4b2:	200e      	movs	r0, #14
 100c4b4:	e7be      	b.n	100c434 <att_write_rsp.constprop.0+0x2c>
	if (data.buf) {
 100c4b6:	9901      	ldr	r1, [sp, #4]
 100c4b8:	2900      	cmp	r1, #0
 100c4ba:	d0ba      	beq.n	100c432 <att_write_rsp.constprop.0+0x2a>
		bt_att_chan_send_rsp(chan, data.buf);
 100c4bc:	4620      	mov	r0, r4
 100c4be:	f01b fb0a 	bl	1027ad6 <bt_att_chan_send_rsp>
 100c4c2:	e7b6      	b.n	100c432 <att_write_rsp.constprop.0+0x2a>
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
 100c4c4:	2012      	movs	r0, #18
 100c4c6:	e7b5      	b.n	100c434 <att_write_rsp.constprop.0+0x2c>
		return BT_ATT_ERR_INVALID_HANDLE;
 100c4c8:	2001      	movs	r0, #1
 100c4ca:	e7b3      	b.n	100c434 <att_write_rsp.constprop.0+0x2c>
 100c4cc:	010278d1 	.word	0x010278d1

0100c4d0 <bt_att_create_pdu>:
{
 100c4d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100c4d2:	af00      	add	r7, sp, #0
 100c4d4:	460e      	mov	r6, r1
 100c4d6:	4615      	mov	r5, r2
	att = att_get(conn);
 100c4d8:	f7ff fce6 	bl	100bea8 <att_get>
	if (!att) {
 100c4dc:	b1e8      	cbz	r0, 100c51a <bt_att_create_pdu+0x4a>
	return list->head;
 100c4de:	6a83      	ldr	r3, [r0, #40]	; 0x28
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 100c4e0:	b1eb      	cbz	r3, 100c51e <bt_att_create_pdu+0x4e>
 100c4e2:	f5a3 70ac 	sub.w	r0, r3, #344	; 0x158
	return node->next;
 100c4e6:	681b      	ldr	r3, [r3, #0]
 100c4e8:	b10b      	cbz	r3, 100c4ee <bt_att_create_pdu+0x1e>
 100c4ea:	f5a3 73ac 	sub.w	r3, r3, #344	; 0x158
		if (len + sizeof(op) > chan->chan.tx.mtu) {
 100c4ee:	1c6c      	adds	r4, r5, #1
 100c4f0:	4622      	mov	r2, r4
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 100c4f2:	b118      	cbz	r0, 100c4fc <bt_att_create_pdu+0x2c>
		if (len + sizeof(op) > chan->chan.tx.mtu) {
 100c4f4:	8dc1      	ldrh	r1, [r0, #46]	; 0x2e
 100c4f6:	42a1      	cmp	r1, r4
 100c4f8:	d21c      	bcs.n	100c534 <bt_att_create_pdu+0x64>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 100c4fa:	b993      	cbnz	r3, 100c522 <bt_att_create_pdu+0x52>
	LOG_WRN("No ATT channel for MTU %zu", len + sizeof(op));
 100c4fc:	466d      	mov	r5, sp
 100c4fe:	b088      	sub	sp, #32
 100c500:	466a      	mov	r2, sp
 100c502:	4b10      	ldr	r3, [pc, #64]	; (100c544 <bt_att_create_pdu+0x74>)
 100c504:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100c508:	e9c2 3405 	strd	r3, r4, [r2, #20]
 100c50c:	2303      	movs	r3, #3
 100c50e:	480e      	ldr	r0, [pc, #56]	; (100c548 <bt_att_create_pdu+0x78>)
 100c510:	f842 3f10 	str.w	r3, [r2, #16]!
 100c514:	f01b faa9 	bl	1027a6a <z_log_msg_static_create.constprop.0>
 100c518:	46ad      	mov	sp, r5
		return NULL;
 100c51a:	2000      	movs	r0, #0
 100c51c:	e00e      	b.n	100c53c <bt_att_create_pdu+0x6c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 100c51e:	4618      	mov	r0, r3
 100c520:	e7e5      	b.n	100c4ee <bt_att_create_pdu+0x1e>
 100c522:	4618      	mov	r0, r3
 100c524:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
 100c528:	b153      	cbz	r3, 100c540 <bt_att_create_pdu+0x70>
		if (len + sizeof(op) > chan->chan.tx.mtu) {
 100c52a:	8dc1      	ldrh	r1, [r0, #46]	; 0x2e
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 100c52c:	f5a3 73ac 	sub.w	r3, r3, #344	; 0x158
		if (len + sizeof(op) > chan->chan.tx.mtu) {
 100c530:	428a      	cmp	r2, r1
 100c532:	d8f6      	bhi.n	100c522 <bt_att_create_pdu+0x52>
		return bt_att_chan_create_pdu(chan, op, len);
 100c534:	462a      	mov	r2, r5
 100c536:	4631      	mov	r1, r6
 100c538:	f7ff fe4c 	bl	100c1d4 <bt_att_chan_create_pdu>
}
 100c53c:	46bd      	mov	sp, r7
 100c53e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (len + sizeof(op) > chan->chan.tx.mtu) {
 100c540:	4614      	mov	r4, r2
 100c542:	e7d7      	b.n	100c4f4 <bt_att_create_pdu+0x24>
 100c544:	0102e3af 	.word	0x0102e3af
 100c548:	0102995c 	.word	0x0102995c

0100c54c <att_read_group_req>:
{
 100c54c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t uuid_len = buf->len - sizeof(*req);
 100c550:	8a0e      	ldrh	r6, [r1, #16]
{
 100c552:	4604      	mov	r4, r0
	uint8_t uuid_len = buf->len - sizeof(*req);
 100c554:	3e04      	subs	r6, #4
 100c556:	b2f6      	uxtb	r6, r6
	if (uuid_len != 2 && uuid_len != 16) {
 100c558:	2e02      	cmp	r6, #2
{
 100c55a:	4608      	mov	r0, r1
 100c55c:	b08c      	sub	sp, #48	; 0x30
	if (uuid_len != 2 && uuid_len != 16) {
 100c55e:	d001      	beq.n	100c564 <att_read_group_req+0x18>
 100c560:	2e10      	cmp	r6, #16
 100c562:	d16a      	bne.n	100c63a <att_read_group_req+0xee>
 100c564:	2104      	movs	r1, #4
 100c566:	300c      	adds	r0, #12
 100c568:	f011 fe78 	bl	101e25c <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
 100c56c:	f10d 0808 	add.w	r8, sp, #8
	start_handle = sys_le16_to_cpu(req->start_handle);
 100c570:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
 100c572:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
 100c574:	1d01      	adds	r1, r0, #4
 100c576:	4632      	mov	r2, r6
 100c578:	4640      	mov	r0, r8
 100c57a:	f01a facf 	bl	1026b1c <bt_uuid_create>
 100c57e:	2800      	cmp	r0, #0
 100c580:	d05d      	beq.n	100c63e <att_read_group_req+0xf2>
	if (!start || !end) {
 100c582:	2d00      	cmp	r5, #0
 100c584:	d03a      	beq.n	100c5fc <att_read_group_req+0xb0>
 100c586:	2600      	movs	r6, #0
 100c588:	2f00      	cmp	r7, #0
 100c58a:	d036      	beq.n	100c5fa <att_read_group_req+0xae>
	if (start > end) {
 100c58c:	42bd      	cmp	r5, r7
 100c58e:	d835      	bhi.n	100c5fc <att_read_group_req+0xb0>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
 100c590:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 100c594:	4640      	mov	r0, r8
 100c596:	a901      	add	r1, sp, #4
 100c598:	f88d 6004 	strb.w	r6, [sp, #4]
 100c59c:	f8ad 3006 	strh.w	r3, [sp, #6]
 100c5a0:	f01a fa8e 	bl	1026ac0 <bt_uuid_cmp>
 100c5a4:	bb70      	cbnz	r0, 100c604 <att_read_group_req+0xb8>
	struct bt_conn *conn = chan->chan.chan.conn;
 100c5a6:	68a6      	ldr	r6, [r4, #8]
	(void)memset(&data, 0, sizeof(data));
 100c5a8:	2214      	movs	r2, #20
 100c5aa:	2100      	movs	r1, #0
 100c5ac:	a807      	add	r0, sp, #28
 100c5ae:	f01a f9ec 	bl	102698a <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_RSP,
 100c5b2:	2201      	movs	r2, #1
 100c5b4:	2111      	movs	r1, #17
 100c5b6:	4630      	mov	r0, r6
 100c5b8:	f7ff ff8a 	bl	100c4d0 <bt_att_create_pdu>
 100c5bc:	9009      	str	r0, [sp, #36]	; 0x24
	if (!data.buf) {
 100c5be:	2800      	cmp	r0, #0
 100c5c0:	d03d      	beq.n	100c63e <att_read_group_req+0xf2>
	return net_buf_simple_add(&buf->b, len);
 100c5c2:	2101      	movs	r1, #1
 100c5c4:	300c      	adds	r0, #12
	data.uuid = uuid;
 100c5c6:	e9cd 4807 	strd	r4, r8, [sp, #28]
 100c5ca:	f011 fe65 	bl	101e298 <net_buf_simple_add>
	data.rsp->len = 0U;
 100c5ce:	2300      	movs	r3, #0
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
 100c5d0:	900a      	str	r0, [sp, #40]	; 0x28
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
 100c5d2:	4639      	mov	r1, r7
	data.rsp->len = 0U;
 100c5d4:	7003      	strb	r3, [r0, #0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
 100c5d6:	4a1b      	ldr	r2, [pc, #108]	; (100c644 <att_read_group_req+0xf8>)
	data.group = NULL;
 100c5d8:	930b      	str	r3, [sp, #44]	; 0x2c
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
 100c5da:	4628      	mov	r0, r5
 100c5dc:	ab07      	add	r3, sp, #28
 100c5de:	f01b f9a8 	bl	1027932 <bt_gatt_foreach_attr>
	if (!data.rsp->len) {
 100c5e2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 100c5e4:	781b      	ldrb	r3, [r3, #0]
 100c5e6:	bb1b      	cbnz	r3, 100c630 <att_read_group_req+0xe4>
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
 100c5e8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 100c5ea:	6998      	ldr	r0, [r3, #24]
 100c5ec:	f7ff fac6 	bl	100bb7c <tx_meta_data_free>
		net_buf_unref(data.buf);
 100c5f0:	9809      	ldr	r0, [sp, #36]	; 0x24
 100c5f2:	f011 fcf5 	bl	101dfe0 <net_buf_unref>
	if (!req) {
 100c5f6:	230a      	movs	r3, #10
 100c5f8:	e001      	b.n	100c5fe <att_read_group_req+0xb2>
			*err = 0U;
 100c5fa:	463d      	mov	r5, r7
	if (!req) {
 100c5fc:	2301      	movs	r3, #1
 100c5fe:	462a      	mov	r2, r5
 100c600:	2110      	movs	r1, #16
 100c602:	e00e      	b.n	100c622 <att_read_group_req+0xd6>
	    bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY)) {
 100c604:	f642 0301 	movw	r3, #10241	; 0x2801
 100c608:	4640      	mov	r0, r8
 100c60a:	a907      	add	r1, sp, #28
 100c60c:	f88d 601c 	strb.w	r6, [sp, #28]
 100c610:	f8ad 301e 	strh.w	r3, [sp, #30]
 100c614:	f01a fa54 	bl	1026ac0 <bt_uuid_cmp>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
 100c618:	2800      	cmp	r0, #0
 100c61a:	d0c4      	beq.n	100c5a6 <att_read_group_req+0x5a>
	if (!req) {
 100c61c:	2310      	movs	r3, #16
 100c61e:	462a      	mov	r2, r5
 100c620:	4619      	mov	r1, r3
 100c622:	4620      	mov	r0, r4
 100c624:	f01b fc73 	bl	1027f0e <send_err_rsp.part.0>
		return 0;
 100c628:	2000      	movs	r0, #0
}
 100c62a:	b00c      	add	sp, #48	; 0x30
 100c62c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	bt_att_chan_send_rsp(chan, data.buf);
 100c630:	4620      	mov	r0, r4
 100c632:	9909      	ldr	r1, [sp, #36]	; 0x24
 100c634:	f01b fa4f 	bl	1027ad6 <bt_att_chan_send_rsp>
	return 0;
 100c638:	e7f6      	b.n	100c628 <att_read_group_req+0xdc>
		return BT_ATT_ERR_INVALID_PDU;
 100c63a:	2004      	movs	r0, #4
 100c63c:	e7f5      	b.n	100c62a <att_read_group_req+0xde>
		return BT_ATT_ERR_UNLIKELY;
 100c63e:	200e      	movs	r0, #14
 100c640:	e7f3      	b.n	100c62a <att_read_group_req+0xde>
 100c642:	bf00      	nop
 100c644:	0100bf71 	.word	0x0100bf71

0100c648 <att_read_mult_vl_req>:
{
 100c648:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn *conn = chan->chan.chan.conn;
 100c64c:	6886      	ldr	r6, [r0, #8]
{
 100c64e:	4604      	mov	r4, r0
 100c650:	460d      	mov	r5, r1
 100c652:	b085      	sub	sp, #20
	if (!bt_gatt_change_aware(conn, true)) {
 100c654:	2101      	movs	r1, #1
 100c656:	4630      	mov	r0, r6
 100c658:	f01b ffd2 	bl	1028600 <bt_gatt_change_aware>
 100c65c:	b950      	cbnz	r0, 100c674 <att_read_mult_vl_req+0x2c>
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
 100c65e:	2105      	movs	r1, #5
 100c660:	f504 7080 	add.w	r0, r4, #256	; 0x100
 100c664:	f01b faeb 	bl	1027c3e <atomic_test_and_set_bit>
 100c668:	2800      	cmp	r0, #0
 100c66a:	d13b      	bne.n	100c6e4 <att_read_mult_vl_req+0x9c>
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
 100c66c:	2012      	movs	r0, #18
}
 100c66e:	b005      	add	sp, #20
 100c670:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	(void)memset(&data, 0, sizeof(data));
 100c674:	2210      	movs	r2, #16
 100c676:	2100      	movs	r1, #0
 100c678:	4668      	mov	r0, sp
 100c67a:	f01a f986 	bl	102698a <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_VL_RSP, 0);
 100c67e:	2200      	movs	r2, #0
 100c680:	2121      	movs	r1, #33	; 0x21
 100c682:	4630      	mov	r0, r6
 100c684:	f7ff ff24 	bl	100c4d0 <bt_att_create_pdu>
 100c688:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
 100c68a:	b368      	cbz	r0, 100c6e8 <att_read_mult_vl_req+0xa0>
		data.err = BT_ATT_ERR_INVALID_HANDLE;
 100c68c:	f04f 0801 	mov.w	r8, #1
		bt_gatt_foreach_attr(handle, handle, read_vl_cb, &data);
 100c690:	f8df 9058 	ldr.w	r9, [pc, #88]	; 100c6ec <att_read_mult_vl_req+0xa4>
	data.chan = chan;
 100c694:	9400      	str	r4, [sp, #0]
	return net_buf_simple_pull_le16(&buf->b);
 100c696:	f105 070c 	add.w	r7, r5, #12
	while (buf->len >= sizeof(uint16_t)) {
 100c69a:	8a2b      	ldrh	r3, [r5, #16]
 100c69c:	2b01      	cmp	r3, #1
 100c69e:	d804      	bhi.n	100c6aa <att_read_mult_vl_req+0x62>
	bt_att_chan_send_rsp(chan, data.buf);
 100c6a0:	4620      	mov	r0, r4
 100c6a2:	9902      	ldr	r1, [sp, #8]
 100c6a4:	f01b fa17 	bl	1027ad6 <bt_att_chan_send_rsp>
	return 0;
 100c6a8:	e01c      	b.n	100c6e4 <att_read_mult_vl_req+0x9c>
 100c6aa:	4638      	mov	r0, r7
 100c6ac:	f01c fb5c 	bl	1028d68 <net_buf_simple_pull_le16>
		bt_gatt_foreach_attr(handle, handle, read_vl_cb, &data);
 100c6b0:	466b      	mov	r3, sp
 100c6b2:	464a      	mov	r2, r9
 100c6b4:	4601      	mov	r1, r0
 100c6b6:	4606      	mov	r6, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
 100c6b8:	f88d 800c 	strb.w	r8, [sp, #12]
		bt_gatt_foreach_attr(handle, handle, read_vl_cb, &data);
 100c6bc:	f01b f939 	bl	1027932 <bt_gatt_foreach_attr>
		if (data.err) {
 100c6c0:	f89d 300c 	ldrb.w	r3, [sp, #12]
 100c6c4:	2b00      	cmp	r3, #0
 100c6c6:	d0e8      	beq.n	100c69a <att_read_mult_vl_req+0x52>
			tx_meta_data_free(bt_att_tx_meta_data(data.buf));
 100c6c8:	9b02      	ldr	r3, [sp, #8]
 100c6ca:	6998      	ldr	r0, [r3, #24]
 100c6cc:	f7ff fa56 	bl	100bb7c <tx_meta_data_free>
			net_buf_unref(data.buf);
 100c6d0:	9802      	ldr	r0, [sp, #8]
 100c6d2:	f011 fc85 	bl	101dfe0 <net_buf_unref>
	if (!req) {
 100c6d6:	4632      	mov	r2, r6
 100c6d8:	2120      	movs	r1, #32
 100c6da:	4620      	mov	r0, r4
 100c6dc:	f89d 300c 	ldrb.w	r3, [sp, #12]
 100c6e0:	f01b fc15 	bl	1027f0e <send_err_rsp.part.0>
			return 0;
 100c6e4:	2000      	movs	r0, #0
 100c6e6:	e7c2      	b.n	100c66e <att_read_mult_vl_req+0x26>
		return BT_ATT_ERR_UNLIKELY;
 100c6e8:	200e      	movs	r0, #14
 100c6ea:	e7c0      	b.n	100c66e <att_read_mult_vl_req+0x26>
 100c6ec:	01027ca7 	.word	0x01027ca7

0100c6f0 <att_read_mult_req>:
{
 100c6f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn *conn = chan->chan.chan.conn;
 100c6f4:	6886      	ldr	r6, [r0, #8]
{
 100c6f6:	4604      	mov	r4, r0
 100c6f8:	460d      	mov	r5, r1
 100c6fa:	b085      	sub	sp, #20
	if (!bt_gatt_change_aware(conn, true)) {
 100c6fc:	2101      	movs	r1, #1
 100c6fe:	4630      	mov	r0, r6
 100c700:	f01b ff7e 	bl	1028600 <bt_gatt_change_aware>
 100c704:	b950      	cbnz	r0, 100c71c <att_read_mult_req+0x2c>
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
 100c706:	2105      	movs	r1, #5
 100c708:	f504 7080 	add.w	r0, r4, #256	; 0x100
 100c70c:	f01b fa97 	bl	1027c3e <atomic_test_and_set_bit>
 100c710:	2800      	cmp	r0, #0
 100c712:	d13b      	bne.n	100c78c <att_read_mult_req+0x9c>
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
 100c714:	2012      	movs	r0, #18
}
 100c716:	b005      	add	sp, #20
 100c718:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	(void)memset(&data, 0, sizeof(data));
 100c71c:	2210      	movs	r2, #16
 100c71e:	2100      	movs	r1, #0
 100c720:	4668      	mov	r0, sp
 100c722:	f01a f932 	bl	102698a <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
 100c726:	2200      	movs	r2, #0
 100c728:	210f      	movs	r1, #15
 100c72a:	4630      	mov	r0, r6
 100c72c:	f7ff fed0 	bl	100c4d0 <bt_att_create_pdu>
 100c730:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
 100c732:	b368      	cbz	r0, 100c790 <att_read_mult_req+0xa0>
		data.err = BT_ATT_ERR_INVALID_HANDLE;
 100c734:	f04f 0801 	mov.w	r8, #1
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
 100c738:	f8df 9058 	ldr.w	r9, [pc, #88]	; 100c794 <att_read_mult_req+0xa4>
	data.chan = chan;
 100c73c:	9400      	str	r4, [sp, #0]
 100c73e:	f105 070c 	add.w	r7, r5, #12
	while (buf->len >= sizeof(uint16_t)) {
 100c742:	8a2b      	ldrh	r3, [r5, #16]
 100c744:	2b01      	cmp	r3, #1
 100c746:	d804      	bhi.n	100c752 <att_read_mult_req+0x62>
	bt_att_chan_send_rsp(chan, data.buf);
 100c748:	4620      	mov	r0, r4
 100c74a:	9902      	ldr	r1, [sp, #8]
 100c74c:	f01b f9c3 	bl	1027ad6 <bt_att_chan_send_rsp>
	return 0;
 100c750:	e01c      	b.n	100c78c <att_read_mult_req+0x9c>
 100c752:	4638      	mov	r0, r7
 100c754:	f01c fb08 	bl	1028d68 <net_buf_simple_pull_le16>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
 100c758:	466b      	mov	r3, sp
 100c75a:	464a      	mov	r2, r9
 100c75c:	4601      	mov	r1, r0
 100c75e:	4606      	mov	r6, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
 100c760:	f88d 800c 	strb.w	r8, [sp, #12]
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
 100c764:	f01b f8e5 	bl	1027932 <bt_gatt_foreach_attr>
		if (data.err) {
 100c768:	f89d 300c 	ldrb.w	r3, [sp, #12]
 100c76c:	2b00      	cmp	r3, #0
 100c76e:	d0e8      	beq.n	100c742 <att_read_mult_req+0x52>
			tx_meta_data_free(bt_att_tx_meta_data(data.buf));
 100c770:	9b02      	ldr	r3, [sp, #8]
 100c772:	6998      	ldr	r0, [r3, #24]
 100c774:	f7ff fa02 	bl	100bb7c <tx_meta_data_free>
			net_buf_unref(data.buf);
 100c778:	9802      	ldr	r0, [sp, #8]
 100c77a:	f011 fc31 	bl	101dfe0 <net_buf_unref>
	if (!req) {
 100c77e:	4632      	mov	r2, r6
 100c780:	210e      	movs	r1, #14
 100c782:	4620      	mov	r0, r4
 100c784:	f89d 300c 	ldrb.w	r3, [sp, #12]
 100c788:	f01b fbc1 	bl	1027f0e <send_err_rsp.part.0>
			return 0;
 100c78c:	2000      	movs	r0, #0
 100c78e:	e7c2      	b.n	100c716 <att_read_mult_req+0x26>
		return BT_ATT_ERR_UNLIKELY;
 100c790:	200e      	movs	r0, #14
 100c792:	e7c0      	b.n	100c716 <att_read_mult_req+0x26>
 100c794:	01027c61 	.word	0x01027c61

0100c798 <att_read_rsp>:
{
 100c798:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct bt_conn *conn = chan->chan.chan.conn;
 100c79c:	f8d0 8008 	ldr.w	r8, [r0, #8]
{
 100c7a0:	4604      	mov	r4, r0
 100c7a2:	460e      	mov	r6, r1
	if (!bt_gatt_change_aware(conn, true)) {
 100c7a4:	4640      	mov	r0, r8
 100c7a6:	2101      	movs	r1, #1
{
 100c7a8:	4617      	mov	r7, r2
 100c7aa:	461d      	mov	r5, r3
	if (!bt_gatt_change_aware(conn, true)) {
 100c7ac:	f01b ff28 	bl	1028600 <bt_gatt_change_aware>
 100c7b0:	b948      	cbnz	r0, 100c7c6 <att_read_rsp+0x2e>
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
 100c7b2:	2105      	movs	r1, #5
 100c7b4:	f504 7080 	add.w	r0, r4, #256	; 0x100
 100c7b8:	f01b fa41 	bl	1027c3e <atomic_test_and_set_bit>
 100c7bc:	bb78      	cbnz	r0, 100c81e <att_read_rsp+0x86>
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
 100c7be:	2012      	movs	r0, #18
}
 100c7c0:	b004      	add	sp, #16
 100c7c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!handle) {
 100c7c6:	b38d      	cbz	r5, 100c82c <att_read_rsp+0x94>
	(void)memset(&data, 0, sizeof(data));
 100c7c8:	2210      	movs	r2, #16
 100c7ca:	2100      	movs	r1, #0
 100c7cc:	4668      	mov	r0, sp
 100c7ce:	f01a f8dc 	bl	102698a <memset>
	data.buf = bt_att_create_pdu(conn, rsp, 0);
 100c7d2:	2200      	movs	r2, #0
 100c7d4:	4639      	mov	r1, r7
 100c7d6:	4640      	mov	r0, r8
 100c7d8:	f7ff fe7a 	bl	100c4d0 <bt_att_create_pdu>
 100c7dc:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
 100c7de:	b338      	cbz	r0, 100c830 <att_read_rsp+0x98>
	data.offset = offset;
 100c7e0:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
 100c7e4:	4629      	mov	r1, r5
	data.offset = offset;
 100c7e6:	f8ad 3004 	strh.w	r3, [sp, #4]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
 100c7ea:	2301      	movs	r3, #1
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
 100c7ec:	4628      	mov	r0, r5
	data.err = BT_ATT_ERR_INVALID_HANDLE;
 100c7ee:	f88d 300c 	strb.w	r3, [sp, #12]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
 100c7f2:	4a10      	ldr	r2, [pc, #64]	; (100c834 <att_read_rsp+0x9c>)
 100c7f4:	466b      	mov	r3, sp
	data.chan = chan;
 100c7f6:	9400      	str	r4, [sp, #0]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
 100c7f8:	f01b f89b 	bl	1027932 <bt_gatt_foreach_attr>
	if (data.err) {
 100c7fc:	f89d 300c 	ldrb.w	r3, [sp, #12]
 100c800:	b17b      	cbz	r3, 100c822 <att_read_rsp+0x8a>
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
 100c802:	9b02      	ldr	r3, [sp, #8]
 100c804:	6998      	ldr	r0, [r3, #24]
 100c806:	f7ff f9b9 	bl	100bb7c <tx_meta_data_free>
		net_buf_unref(data.buf);
 100c80a:	9802      	ldr	r0, [sp, #8]
 100c80c:	f011 fbe8 	bl	101dfe0 <net_buf_unref>
	if (!req) {
 100c810:	462a      	mov	r2, r5
 100c812:	4631      	mov	r1, r6
 100c814:	4620      	mov	r0, r4
 100c816:	f89d 300c 	ldrb.w	r3, [sp, #12]
 100c81a:	f01b fb78 	bl	1027f0e <send_err_rsp.part.0>
			return 0;
 100c81e:	2000      	movs	r0, #0
 100c820:	e7ce      	b.n	100c7c0 <att_read_rsp+0x28>
	bt_att_chan_send_rsp(chan, data.buf);
 100c822:	4620      	mov	r0, r4
 100c824:	9902      	ldr	r1, [sp, #8]
 100c826:	f01b f956 	bl	1027ad6 <bt_att_chan_send_rsp>
	return 0;
 100c82a:	e7f8      	b.n	100c81e <att_read_rsp+0x86>
		return BT_ATT_ERR_INVALID_HANDLE;
 100c82c:	2001      	movs	r0, #1
 100c82e:	e7c7      	b.n	100c7c0 <att_read_rsp+0x28>
		return BT_ATT_ERR_UNLIKELY;
 100c830:	200e      	movs	r0, #14
 100c832:	e7c5      	b.n	100c7c0 <att_read_rsp+0x28>
 100c834:	01027c61 	.word	0x01027c61

0100c838 <att_read_type_req>:
{
 100c838:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t uuid_len = buf->len - sizeof(*req);
 100c83c:	8a0d      	ldrh	r5, [r1, #16]
{
 100c83e:	4604      	mov	r4, r0
	uint8_t uuid_len = buf->len - sizeof(*req);
 100c840:	3d04      	subs	r5, #4
 100c842:	b2ed      	uxtb	r5, r5
	if (uuid_len != 2 && uuid_len != 16) {
 100c844:	2d02      	cmp	r5, #2
{
 100c846:	4608      	mov	r0, r1
 100c848:	b08c      	sub	sp, #48	; 0x30
	if (uuid_len != 2 && uuid_len != 16) {
 100c84a:	d001      	beq.n	100c850 <att_read_type_req+0x18>
 100c84c:	2d10      	cmp	r5, #16
 100c84e:	d150      	bne.n	100c8f2 <att_read_type_req+0xba>
	return net_buf_simple_pull_mem(&buf->b, len);
 100c850:	2104      	movs	r1, #4
 100c852:	300c      	adds	r0, #12
 100c854:	f011 fd02 	bl	101e25c <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
 100c858:	f10d 0804 	add.w	r8, sp, #4
	start_handle = sys_le16_to_cpu(req->start_handle);
 100c85c:	8806      	ldrh	r6, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
 100c85e:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
 100c860:	1d01      	adds	r1, r0, #4
 100c862:	462a      	mov	r2, r5
 100c864:	4640      	mov	r0, r8
 100c866:	f01a f959 	bl	1026b1c <bt_uuid_create>
 100c86a:	b188      	cbz	r0, 100c890 <att_read_type_req+0x58>
	if (!start || !end) {
 100c86c:	b19e      	cbz	r6, 100c896 <att_read_type_req+0x5e>
 100c86e:	b18f      	cbz	r7, 100c894 <att_read_type_req+0x5c>
	if (start > end) {
 100c870:	42b7      	cmp	r7, r6
 100c872:	d310      	bcc.n	100c896 <att_read_type_req+0x5e>
	(void)memset(&data, 0, sizeof(data));
 100c874:	2218      	movs	r2, #24
	struct bt_conn *conn = chan->chan.chan.conn;
 100c876:	68a5      	ldr	r5, [r4, #8]
	(void)memset(&data, 0, sizeof(data));
 100c878:	2100      	movs	r1, #0
 100c87a:	eb0d 0002 	add.w	r0, sp, r2
 100c87e:	f01a f884 	bl	102698a <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_RSP,
 100c882:	2201      	movs	r2, #1
 100c884:	2109      	movs	r1, #9
 100c886:	4628      	mov	r0, r5
 100c888:	f7ff fe22 	bl	100c4d0 <bt_att_create_pdu>
 100c88c:	9008      	str	r0, [sp, #32]
	if (!data.buf) {
 100c88e:	b960      	cbnz	r0, 100c8aa <att_read_type_req+0x72>
		return BT_ATT_ERR_UNLIKELY;
 100c890:	200e      	movs	r0, #14
 100c892:	e007      	b.n	100c8a4 <att_read_type_req+0x6c>
			*err = 0U;
 100c894:	463e      	mov	r6, r7
	if (!req) {
 100c896:	2301      	movs	r3, #1
 100c898:	4632      	mov	r2, r6
 100c89a:	2108      	movs	r1, #8
 100c89c:	4620      	mov	r0, r4
 100c89e:	f01b fb36 	bl	1027f0e <send_err_rsp.part.0>
		return 0;
 100c8a2:	2000      	movs	r0, #0
}
 100c8a4:	b00c      	add	sp, #48	; 0x30
 100c8a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return net_buf_simple_add(&buf->b, len);
 100c8aa:	2101      	movs	r1, #1
 100c8ac:	300c      	adds	r0, #12
	data.uuid = uuid;
 100c8ae:	e9cd 4806 	strd	r4, r8, [sp, #24]
 100c8b2:	f011 fcf1 	bl	101e298 <net_buf_simple_add>
	data.rsp->len = 0U;
 100c8b6:	2300      	movs	r3, #0
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
 100c8b8:	9009      	str	r0, [sp, #36]	; 0x24
	data.rsp->len = 0U;
 100c8ba:	7003      	strb	r3, [r0, #0]
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
 100c8bc:	230a      	movs	r3, #10
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
 100c8be:	4639      	mov	r1, r7
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
 100c8c0:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
 100c8c4:	4630      	mov	r0, r6
 100c8c6:	ab06      	add	r3, sp, #24
 100c8c8:	4a0b      	ldr	r2, [pc, #44]	; (100c8f8 <att_read_type_req+0xc0>)
 100c8ca:	f01b f832 	bl	1027932 <bt_gatt_foreach_attr>
	if (data.err) {
 100c8ce:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 100c8d2:	b14b      	cbz	r3, 100c8e8 <att_read_type_req+0xb0>
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
 100c8d4:	9b08      	ldr	r3, [sp, #32]
 100c8d6:	6998      	ldr	r0, [r3, #24]
 100c8d8:	f7ff f950 	bl	100bb7c <tx_meta_data_free>
		net_buf_unref(data.buf);
 100c8dc:	9808      	ldr	r0, [sp, #32]
 100c8de:	f011 fb7f 	bl	101dfe0 <net_buf_unref>
	if (!req) {
 100c8e2:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 100c8e6:	e7d7      	b.n	100c898 <att_read_type_req+0x60>
	bt_att_chan_send_rsp(chan, data.buf);
 100c8e8:	4620      	mov	r0, r4
 100c8ea:	9908      	ldr	r1, [sp, #32]
 100c8ec:	f01b f8f3 	bl	1027ad6 <bt_att_chan_send_rsp>
	return 0;
 100c8f0:	e7d7      	b.n	100c8a2 <att_read_type_req+0x6a>
		return BT_ATT_ERR_INVALID_PDU;
 100c8f2:	2004      	movs	r0, #4
 100c8f4:	e7d6      	b.n	100c8a4 <att_read_type_req+0x6c>
 100c8f6:	bf00      	nop
 100c8f8:	0100c01d 	.word	0x0100c01d

0100c8fc <att_find_type_req>:
{
 100c8fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100c900:	460f      	mov	r7, r1
 100c902:	4604      	mov	r4, r0
	return net_buf_simple_pull_mem(&buf->b, len);
 100c904:	2106      	movs	r1, #6
 100c906:	b086      	sub	sp, #24
 100c908:	f107 000c 	add.w	r0, r7, #12
 100c90c:	f011 fca6 	bl	101e25c <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
 100c910:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
 100c912:	f8b0 8002 	ldrh.w	r8, [r0, #2]
	type = sys_le16_to_cpu(req->type);
 100c916:	8882      	ldrh	r2, [r0, #4]
	value = buf->data;
 100c918:	f8d7 900c 	ldr.w	r9, [r7, #12]
	if (!start || !end) {
 100c91c:	b1c5      	cbz	r5, 100c950 <att_find_type_req+0x54>
 100c91e:	2300      	movs	r3, #0
 100c920:	f1b8 0f00 	cmp.w	r8, #0
 100c924:	d013      	beq.n	100c94e <att_find_type_req+0x52>
	if (start > end) {
 100c926:	4545      	cmp	r5, r8
 100c928:	d812      	bhi.n	100c950 <att_find_type_req+0x54>
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
 100c92a:	f88d 3000 	strb.w	r3, [sp]
 100c92e:	f88d 3004 	strb.w	r3, [sp, #4]
 100c932:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 100c936:	4668      	mov	r0, sp
 100c938:	a901      	add	r1, sp, #4
 100c93a:	f8ad 2002 	strh.w	r2, [sp, #2]
 100c93e:	f8ad 3006 	strh.w	r3, [sp, #6]
 100c942:	f01a f8bd 	bl	1026ac0 <bt_uuid_cmp>
 100c946:	4606      	mov	r6, r0
 100c948:	b160      	cbz	r0, 100c964 <att_find_type_req+0x68>
	if (!req) {
 100c94a:	230a      	movs	r3, #10
 100c94c:	e001      	b.n	100c952 <att_find_type_req+0x56>
			*err = 0U;
 100c94e:	4645      	mov	r5, r8
	if (!req) {
 100c950:	2301      	movs	r3, #1
 100c952:	462a      	mov	r2, r5
 100c954:	2106      	movs	r1, #6
 100c956:	4620      	mov	r0, r4
 100c958:	f01b fad9 	bl	1027f0e <send_err_rsp.part.0>
		return 0;
 100c95c:	2000      	movs	r0, #0
}
 100c95e:	b006      	add	sp, #24
 100c960:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	struct bt_conn *conn = chan->chan.chan.conn;
 100c964:	f8d4 a008 	ldr.w	sl, [r4, #8]
	(void)memset(&data, 0, sizeof(data));
 100c968:	4601      	mov	r1, r0
 100c96a:	2214      	movs	r2, #20
 100c96c:	a801      	add	r0, sp, #4
	return att_find_type_rsp(chan, start_handle, end_handle, value,
 100c96e:	7c3f      	ldrb	r7, [r7, #16]
	(void)memset(&data, 0, sizeof(data));
 100c970:	f01a f80b 	bl	102698a <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_RSP, 0);
 100c974:	4632      	mov	r2, r6
 100c976:	2107      	movs	r1, #7
 100c978:	4650      	mov	r0, sl
 100c97a:	f7ff fda9 	bl	100c4d0 <bt_att_create_pdu>
 100c97e:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
 100c980:	b1f8      	cbz	r0, 100c9c2 <att_find_type_req+0xc6>
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
 100c982:	230a      	movs	r3, #10
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
 100c984:	4641      	mov	r1, r8
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
 100c986:	f88d 3015 	strb.w	r3, [sp, #21]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
 100c98a:	4628      	mov	r0, r5
 100c98c:	ab01      	add	r3, sp, #4
 100c98e:	4a0e      	ldr	r2, [pc, #56]	; (100c9c8 <att_find_type_req+0xcc>)
	data.value = value;
 100c990:	e9cd 6903 	strd	r6, r9, [sp, #12]
	data.chan = chan;
 100c994:	9401      	str	r4, [sp, #4]
	data.value_len = value_len;
 100c996:	f88d 7014 	strb.w	r7, [sp, #20]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
 100c99a:	f01a ffca 	bl	1027932 <bt_gatt_foreach_attr>
	if (data.err) {
 100c99e:	f89d 3015 	ldrb.w	r3, [sp, #21]
 100c9a2:	b14b      	cbz	r3, 100c9b8 <att_find_type_req+0xbc>
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
 100c9a4:	9b02      	ldr	r3, [sp, #8]
 100c9a6:	6998      	ldr	r0, [r3, #24]
 100c9a8:	f7ff f8e8 	bl	100bb7c <tx_meta_data_free>
		net_buf_unref(data.buf);
 100c9ac:	9802      	ldr	r0, [sp, #8]
 100c9ae:	f011 fb17 	bl	101dfe0 <net_buf_unref>
	if (!req) {
 100c9b2:	f89d 3015 	ldrb.w	r3, [sp, #21]
 100c9b6:	e7cc      	b.n	100c952 <att_find_type_req+0x56>
	bt_att_chan_send_rsp(chan, data.buf);
 100c9b8:	4620      	mov	r0, r4
 100c9ba:	9902      	ldr	r1, [sp, #8]
 100c9bc:	f01b f88b 	bl	1027ad6 <bt_att_chan_send_rsp>
	return 0;
 100c9c0:	e7cc      	b.n	100c95c <att_find_type_req+0x60>
		return BT_ATT_ERR_UNLIKELY;
 100c9c2:	200e      	movs	r0, #14
	return att_find_type_rsp(chan, start_handle, end_handle, value,
 100c9c4:	e7cb      	b.n	100c95e <att_find_type_req+0x62>
 100c9c6:	bf00      	nop
 100c9c8:	0100bbbd 	.word	0x0100bbbd

0100c9cc <att_find_info_req>:
{
 100c9cc:	b5f0      	push	{r4, r5, r6, r7, lr}
	req = (void *)buf->data;
 100c9ce:	68cb      	ldr	r3, [r1, #12]
{
 100c9d0:	4604      	mov	r4, r0
	start_handle = sys_le16_to_cpu(req->start_handle);
 100c9d2:	881d      	ldrh	r5, [r3, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
 100c9d4:	885e      	ldrh	r6, [r3, #2]
{
 100c9d6:	b085      	sub	sp, #20
	if (!start || !end) {
 100c9d8:	b195      	cbz	r5, 100ca00 <att_find_info_req+0x34>
 100c9da:	b186      	cbz	r6, 100c9fe <att_find_info_req+0x32>
	if (start > end) {
 100c9dc:	42b5      	cmp	r5, r6
 100c9de:	d80f      	bhi.n	100ca00 <att_find_info_req+0x34>
	struct bt_conn *conn = chan->chan.chan.conn;
 100c9e0:	6887      	ldr	r7, [r0, #8]
	(void)memset(&data, 0, sizeof(data));
 100c9e2:	2210      	movs	r2, #16
 100c9e4:	2100      	movs	r1, #0
 100c9e6:	4668      	mov	r0, sp
 100c9e8:	f019 ffcf 	bl	102698a <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_RSP, 0);
 100c9ec:	2200      	movs	r2, #0
 100c9ee:	2105      	movs	r1, #5
 100c9f0:	4638      	mov	r0, r7
 100c9f2:	f7ff fd6d 	bl	100c4d0 <bt_att_create_pdu>
 100c9f6:	9001      	str	r0, [sp, #4]
	if (!data.buf) {
 100c9f8:	b958      	cbnz	r0, 100ca12 <att_find_info_req+0x46>
		return BT_ATT_ERR_UNLIKELY;
 100c9fa:	200e      	movs	r0, #14
	return att_find_info_rsp(chan, start_handle, end_handle);
 100c9fc:	e007      	b.n	100ca0e <att_find_info_req+0x42>
			*err = 0U;
 100c9fe:	4635      	mov	r5, r6
	if (!req) {
 100ca00:	2301      	movs	r3, #1
 100ca02:	462a      	mov	r2, r5
 100ca04:	2104      	movs	r1, #4
 100ca06:	4620      	mov	r0, r4
 100ca08:	f01b fa81 	bl	1027f0e <send_err_rsp.part.0>
		return 0;
 100ca0c:	2000      	movs	r0, #0
}
 100ca0e:	b005      	add	sp, #20
 100ca10:	bdf0      	pop	{r4, r5, r6, r7, pc}
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
 100ca12:	466b      	mov	r3, sp
 100ca14:	4631      	mov	r1, r6
 100ca16:	4628      	mov	r0, r5
 100ca18:	4a09      	ldr	r2, [pc, #36]	; (100ca40 <att_find_info_req+0x74>)
	data.chan = chan;
 100ca1a:	9400      	str	r4, [sp, #0]
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
 100ca1c:	f01a ff89 	bl	1027932 <bt_gatt_foreach_attr>
	if (!data.rsp) {
 100ca20:	9b02      	ldr	r3, [sp, #8]
 100ca22:	b943      	cbnz	r3, 100ca36 <att_find_info_req+0x6a>
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
 100ca24:	9b01      	ldr	r3, [sp, #4]
 100ca26:	6998      	ldr	r0, [r3, #24]
 100ca28:	f7ff f8a8 	bl	100bb7c <tx_meta_data_free>
		net_buf_unref(data.buf);
 100ca2c:	9801      	ldr	r0, [sp, #4]
 100ca2e:	f011 fad7 	bl	101dfe0 <net_buf_unref>
	if (!req) {
 100ca32:	230a      	movs	r3, #10
 100ca34:	e7e5      	b.n	100ca02 <att_find_info_req+0x36>
	bt_att_chan_send_rsp(chan, data.buf);
 100ca36:	4620      	mov	r0, r4
 100ca38:	9901      	ldr	r1, [sp, #4]
 100ca3a:	f01b f84c 	bl	1027ad6 <bt_att_chan_send_rsp>
	return 0;
 100ca3e:	e7e5      	b.n	100ca0c <att_find_info_req+0x40>
 100ca40:	01027949 	.word	0x01027949

0100ca44 <bt_att_init>:
	bt_l2cap_register_ecred_cb(&cb);
#endif /* CONFIG_BT_EATT */
}

void bt_att_init(void)
{
 100ca44:	b538      	push	{r3, r4, r5, lr}
	z_impl_k_queue_init(queue);
 100ca46:	4c0b      	ldr	r4, [pc, #44]	; (100ca74 <bt_att_init+0x30>)
	k_fifo_init(&free_att_tx_meta_data);
	for (size_t i = 0; i < ARRAY_SIZE(tx_meta_data); i++) {
		k_fifo_put(&free_att_tx_meta_data, &tx_meta_data[i]);
 100ca48:	4d0b      	ldr	r5, [pc, #44]	; (100ca78 <bt_att_init+0x34>)
 100ca4a:	4620      	mov	r0, r4
 100ca4c:	f01c fc41 	bl	10292d2 <z_impl_k_queue_init>
 100ca50:	4629      	mov	r1, r5
 100ca52:	4620      	mov	r0, r4
 100ca54:	f01c fc4a 	bl	10292ec <k_queue_append>
 100ca58:	4620      	mov	r0, r4
 100ca5a:	f105 0114 	add.w	r1, r5, #20
 100ca5e:	f01c fc45 	bl	10292ec <k_queue_append>
 100ca62:	4620      	mov	r0, r4
 100ca64:	f105 0128 	add.w	r1, r5, #40	; 0x28
 100ca68:	f01c fc40 	bl	10292ec <k_queue_append>
	bt_gatt_init();

	if (IS_ENABLED(CONFIG_BT_EATT)) {
		bt_eatt_init();
	}
}
 100ca6c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_gatt_init();
 100ca70:	f000 bf7c 	b.w	100d96c <bt_gatt_init>
 100ca74:	21000d28 	.word	0x21000d28
 100ca78:	21004788 	.word	0x21004788

0100ca7c <bt_att_req_alloc>:
	}
}

struct bt_att_req *bt_att_req_alloc(k_timeout_t timeout)
{
	struct bt_att_req *req = NULL;
 100ca7c:	2300      	movs	r3, #0
{
 100ca7e:	b537      	push	{r0, r1, r2, r4, r5, lr}
 100ca80:	4605      	mov	r5, r0
 100ca82:	460c      	mov	r4, r1
	struct bt_att_req *req = NULL;
 100ca84:	9301      	str	r3, [sp, #4]
	return z_impl_z_current_get();
 100ca86:	f016 fce5 	bl	1023454 <z_impl_z_current_get>

	if (k_current_get() == att_handle_rsp_thread) {
 100ca8a:	4b0b      	ldr	r3, [pc, #44]	; (100cab8 <bt_att_req_alloc+0x3c>)
		 */
		timeout = K_NO_WAIT;
	}

	/* Reserve space for request */
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
 100ca8c:	a901      	add	r1, sp, #4
	if (k_current_get() == att_handle_rsp_thread) {
 100ca8e:	681b      	ldr	r3, [r3, #0]
 100ca90:	4283      	cmp	r3, r0
		timeout = K_NO_WAIT;
 100ca92:	bf04      	itt	eq
 100ca94:	2500      	moveq	r5, #0
 100ca96:	462c      	moveq	r4, r5
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
 100ca98:	462a      	mov	r2, r5
 100ca9a:	4623      	mov	r3, r4
 100ca9c:	4807      	ldr	r0, [pc, #28]	; (100cabc <bt_att_req_alloc+0x40>)
 100ca9e:	f014 f92d 	bl	1020cfc <k_mem_slab_alloc>
 100caa2:	4601      	mov	r1, r0
 100caa4:	b930      	cbnz	r0, 100cab4 <bt_att_req_alloc+0x38>
		return NULL;
	}

	LOG_DBG("req %p", req);

	memset(req, 0, sizeof(*req));
 100caa6:	221c      	movs	r2, #28
 100caa8:	9801      	ldr	r0, [sp, #4]
 100caaa:	f019 ff6e 	bl	102698a <memset>

	return req;
 100caae:	9801      	ldr	r0, [sp, #4]
}
 100cab0:	b003      	add	sp, #12
 100cab2:	bd30      	pop	{r4, r5, pc}
		return NULL;
 100cab4:	2000      	movs	r0, #0
 100cab6:	e7fb      	b.n	100cab0 <bt_att_req_alloc+0x34>
 100cab8:	210047c4 	.word	0x210047c4
 100cabc:	21000c50 	.word	0x21000c50

0100cac0 <bt_att_req_free>:

void bt_att_req_free(struct bt_att_req *req)
{
 100cac0:	b507      	push	{r0, r1, r2, lr}
	LOG_DBG("req %p", req);

	if (req->buf) {
 100cac2:	6883      	ldr	r3, [r0, #8]
{
 100cac4:	9001      	str	r0, [sp, #4]
	if (req->buf) {
 100cac6:	b14b      	cbz	r3, 100cadc <bt_att_req_free+0x1c>
		tx_meta_data_free(bt_att_tx_meta_data(req->buf));
 100cac8:	6998      	ldr	r0, [r3, #24]
 100caca:	f7ff f857 	bl	100bb7c <tx_meta_data_free>
		net_buf_unref(req->buf);
 100cace:	9b01      	ldr	r3, [sp, #4]
 100cad0:	6898      	ldr	r0, [r3, #8]
 100cad2:	f011 fa85 	bl	101dfe0 <net_buf_unref>
		req->buf = NULL;
 100cad6:	2200      	movs	r2, #0
 100cad8:	9b01      	ldr	r3, [sp, #4]
 100cada:	609a      	str	r2, [r3, #8]
	}

	k_mem_slab_free(&req_slab, (void **)&req);
 100cadc:	4803      	ldr	r0, [pc, #12]	; (100caec <bt_att_req_free+0x2c>)
 100cade:	a901      	add	r1, sp, #4
 100cae0:	f014 f976 	bl	1020dd0 <k_mem_slab_free>
}
 100cae4:	b003      	add	sp, #12
 100cae6:	f85d fb04 	ldr.w	pc, [sp], #4
 100caea:	bf00      	nop
 100caec:	21000c50 	.word	0x21000c50

0100caf0 <att_handle_rsp>:
{
 100caf0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100caf4:	4604      	mov	r4, r0
 100caf6:	b088      	sub	sp, #32
	k_work_cancel_delayable(&chan->timeout_work);
 100caf8:	f500 7094 	add.w	r0, r0, #296	; 0x128
{
 100cafc:	460e      	mov	r6, r1
 100cafe:	4617      	mov	r7, r2
 100cb00:	461d      	mov	r5, r3
	k_work_cancel_delayable(&chan->timeout_work);
 100cb02:	f015 fb25 	bl	1022150 <k_work_cancel_delayable>
	if (!chan->req) {
 100cb06:	f8d4 0104 	ldr.w	r0, [r4, #260]	; 0x104
 100cb0a:	b980      	cbnz	r0, 100cb2e <att_handle_rsp+0x3e>
		LOG_WRN("No pending ATT request");
 100cb0c:	4b19      	ldr	r3, [pc, #100]	; (100cb74 <att_handle_rsp+0x84>)
 100cb0e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100cb12:	9307      	str	r3, [sp, #28]
 100cb14:	2302      	movs	r3, #2
 100cb16:	4818      	ldr	r0, [pc, #96]	; (100cb78 <att_handle_rsp+0x88>)
 100cb18:	aa06      	add	r2, sp, #24
 100cb1a:	9306      	str	r3, [sp, #24]
 100cb1c:	f01a ffa5 	bl	1027a6a <z_log_msg_static_create.constprop.0>
	att_req_send_process(chan->att);
 100cb20:	6820      	ldr	r0, [r4, #0]
 100cb22:	f01b f929 	bl	1027d78 <att_req_send_process>
}
 100cb26:	2000      	movs	r0, #0
 100cb28:	b008      	add	sp, #32
 100cb2a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (chan->req == &cancel) {
 100cb2e:	4b13      	ldr	r3, [pc, #76]	; (100cb7c <att_handle_rsp+0x8c>)
 100cb30:	f04f 0800 	mov.w	r8, #0
 100cb34:	4298      	cmp	r0, r3
 100cb36:	d102      	bne.n	100cb3e <att_handle_rsp+0x4e>
		chan->req = NULL;
 100cb38:	f8c4 8104 	str.w	r8, [r4, #260]	; 0x104
 100cb3c:	e7f0      	b.n	100cb20 <att_handle_rsp+0x30>
	func = chan->req->func;
 100cb3e:	f8d0 9004 	ldr.w	r9, [r0, #4]
	chan->req->func = NULL;
 100cb42:	f8c0 8004 	str.w	r8, [r0, #4]
	params = chan->req->user_data;
 100cb46:	f8d4 0104 	ldr.w	r0, [r4, #260]	; 0x104
 100cb4a:	f8d0 a018 	ldr.w	sl, [r0, #24]
	bt_att_req_free(chan->req);
 100cb4e:	f7ff ffb7 	bl	100cac0 <bt_att_req_free>
	att_req_send_process(chan->att);
 100cb52:	6820      	ldr	r0, [r4, #0]
	chan->req = NULL;
 100cb54:	f8c4 8104 	str.w	r8, [r4, #260]	; 0x104
	att_req_send_process(chan->att);
 100cb58:	f01b f90e 	bl	1027d78 <att_req_send_process>
	if (func) {
 100cb5c:	f1b9 0f00 	cmp.w	r9, #0
 100cb60:	d0e1      	beq.n	100cb26 <att_handle_rsp+0x36>
		func(chan->att->conn, err, pdu, len, params);
 100cb62:	6820      	ldr	r0, [r4, #0]
 100cb64:	f8cd a000 	str.w	sl, [sp]
 100cb68:	463b      	mov	r3, r7
 100cb6a:	4632      	mov	r2, r6
 100cb6c:	4629      	mov	r1, r5
 100cb6e:	6800      	ldr	r0, [r0, #0]
 100cb70:	47c8      	blx	r9
 100cb72:	e7d8      	b.n	100cb26 <att_handle_rsp+0x36>
 100cb74:	0102e3ca 	.word	0x0102e3ca
 100cb78:	0102995c 	.word	0x0102995c
 100cb7c:	210047c8 	.word	0x210047c8

0100cb80 <bt_att_disconnected>:
{
 100cb80:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct bt_att *att = att_chan->att;
 100cb84:	f850 6c08 	ldr.w	r6, [r0, #-8]
{
 100cb88:	4604      	mov	r4, r0
	if (!att_chan->att) {
 100cb8a:	2e00      	cmp	r6, #0
 100cb8c:	d057      	beq.n	100cc3e <bt_att_disconnected+0xbe>
	sys_slist_find_and_remove(&chan->att->chans, &chan->node);
 100cb8e:	f500 71a8 	add.w	r1, r0, #336	; 0x150
 100cb92:	f106 0028 	add.w	r0, r6, #40	; 0x28
 100cb96:	f01b f837 	bl	1027c08 <sys_slist_find_and_remove.isra.0>
	while ((buf = net_buf_get(&chan->tx_queue, K_NO_WAIT))) {
 100cb9a:	f1a4 0708 	sub.w	r7, r4, #8
 100cb9e:	f504 7880 	add.w	r8, r4, #256	; 0x100
 100cba2:	2200      	movs	r2, #0
 100cba4:	2300      	movs	r3, #0
 100cba6:	4640      	mov	r0, r8
 100cba8:	f01c f8d3 	bl	1028d52 <net_buf_get>
 100cbac:	4605      	mov	r5, r0
 100cbae:	bb28      	cbnz	r0, 100cbfc <bt_att_disconnected+0x7c>
	if (chan->req) {
 100cbb0:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 100cbb4:	b12b      	cbz	r3, 100cbc2 <bt_att_disconnected+0x42>
		att_handle_rsp(chan, NULL, 0, BT_ATT_ERR_UNLIKELY);
 100cbb6:	4602      	mov	r2, r0
 100cbb8:	4601      	mov	r1, r0
 100cbba:	230e      	movs	r3, #14
 100cbbc:	4638      	mov	r0, r7
 100cbbe:	f7ff ff97 	bl	100caf0 <att_handle_rsp>
	chan->att = NULL;
 100cbc2:	2300      	movs	r3, #0
 100cbc4:	f844 3c08 	str.w	r3, [r4, #-8]
	if (!sys_slist_is_empty(&att->chans)) {
 100cbc8:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 100cbca:	2b00      	cmp	r3, #0
 100cbcc:	d137      	bne.n	100cc3e <bt_att_disconnected+0xbe>
	att_reset(att);
 100cbce:	9603      	str	r6, [sp, #12]
	while ((buf = net_buf_get(&att->tx_queue, K_NO_WAIT))) {
 100cbd0:	9803      	ldr	r0, [sp, #12]
 100cbd2:	2200      	movs	r2, #0
 100cbd4:	2300      	movs	r3, #0
 100cbd6:	300c      	adds	r0, #12
 100cbd8:	f01c f8bb 	bl	1028d52 <net_buf_get>
 100cbdc:	4605      	mov	r5, r0
 100cbde:	b9a0      	cbnz	r0, 100cc0a <bt_att_disconnected+0x8a>
	while (!sys_slist_is_empty(&att->reqs)) {
 100cbe0:	9803      	ldr	r0, [sp, #12]
	return list->head;
 100cbe2:	6845      	ldr	r5, [r0, #4]
 100cbe4:	b9c5      	cbnz	r5, 100cc18 <bt_att_disconnected+0x98>
	att->conn = NULL;
 100cbe6:	6005      	str	r5, [r0, #0]
	k_mem_slab_free(&att_slab, (void **)&att);
 100cbe8:	a903      	add	r1, sp, #12
 100cbea:	4816      	ldr	r0, [pc, #88]	; (100cc44 <bt_att_disconnected+0xc4>)
 100cbec:	f014 f8f0 	bl	1020dd0 <k_mem_slab_free>
	bt_gatt_disconnected(le_chan->chan.conn);
 100cbf0:	6820      	ldr	r0, [r4, #0]
}
 100cbf2:	b004      	add	sp, #16
 100cbf4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	bt_gatt_disconnected(le_chan->chan.conn);
 100cbf8:	f001 bf7c 	b.w	100eaf4 <bt_gatt_disconnected>
		tx_meta_data_free(bt_att_tx_meta_data(buf));
 100cbfc:	69a8      	ldr	r0, [r5, #24]
 100cbfe:	f7fe ffbd 	bl	100bb7c <tx_meta_data_free>
		net_buf_unref(buf);
 100cc02:	4628      	mov	r0, r5
 100cc04:	f011 f9ec 	bl	101dfe0 <net_buf_unref>
 100cc08:	e7cb      	b.n	100cba2 <bt_att_disconnected+0x22>
		tx_meta_data_free(bt_att_tx_meta_data(buf));
 100cc0a:	69a8      	ldr	r0, [r5, #24]
 100cc0c:	f7fe ffb6 	bl	100bb7c <tx_meta_data_free>
		net_buf_unref(buf);
 100cc10:	4628      	mov	r0, r5
 100cc12:	f011 f9e5 	bl	101dfe0 <net_buf_unref>
 100cc16:	e7db      	b.n	100cbd0 <bt_att_disconnected+0x50>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 100cc18:	6882      	ldr	r2, [r0, #8]
	return node->next;
 100cc1a:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 100cc1c:	4295      	cmp	r5, r2
	list->head = node;
 100cc1e:	6043      	str	r3, [r0, #4]
	list->tail = node;
 100cc20:	bf08      	it	eq
 100cc22:	6083      	streq	r3, [r0, #8]
		if (req->func) {
 100cc24:	686e      	ldr	r6, [r5, #4]
 100cc26:	b136      	cbz	r6, 100cc36 <bt_att_disconnected+0xb6>
			req->func(att->conn, BT_ATT_ERR_UNLIKELY, NULL, 0,
 100cc28:	69ab      	ldr	r3, [r5, #24]
 100cc2a:	210e      	movs	r1, #14
 100cc2c:	9300      	str	r3, [sp, #0]
 100cc2e:	2300      	movs	r3, #0
 100cc30:	6800      	ldr	r0, [r0, #0]
 100cc32:	461a      	mov	r2, r3
 100cc34:	47b0      	blx	r6
		bt_att_req_free(req);
 100cc36:	4628      	mov	r0, r5
 100cc38:	f7ff ff42 	bl	100cac0 <bt_att_req_free>
 100cc3c:	e7d0      	b.n	100cbe0 <bt_att_disconnected+0x60>
}
 100cc3e:	b004      	add	sp, #16
 100cc40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100cc44:	21000c10 	.word	0x21000c10

0100cc48 <att_timeout>:
{
 100cc48:	b510      	push	{r4, lr}
 100cc4a:	4604      	mov	r4, r0
 100cc4c:	b086      	sub	sp, #24
	LOG_ERR("ATT Timeout");
 100cc4e:	4b08      	ldr	r3, [pc, #32]	; (100cc70 <att_timeout+0x28>)
 100cc50:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100cc54:	9305      	str	r3, [sp, #20]
 100cc56:	2302      	movs	r3, #2
 100cc58:	4806      	ldr	r0, [pc, #24]	; (100cc74 <att_timeout+0x2c>)
 100cc5a:	aa04      	add	r2, sp, #16
 100cc5c:	9304      	str	r3, [sp, #16]
 100cc5e:	f01a ff04 	bl	1027a6a <z_log_msg_static_create.constprop.0>
	bt_att_disconnected(&chan->chan.chan);
 100cc62:	f5a4 7090 	sub.w	r0, r4, #288	; 0x120
}
 100cc66:	b006      	add	sp, #24
 100cc68:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_att_disconnected(&chan->chan.chan);
 100cc6c:	f7ff bf88 	b.w	100cb80 <bt_att_disconnected>
 100cc70:	0102e3e1 	.word	0x0102e3e1
 100cc74:	0102995c 	.word	0x0102995c

0100cc78 <bt_att_send>:

int bt_att_send(struct bt_conn *conn, struct net_buf *buf)
{
 100cc78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100cc7a:	460c      	mov	r4, r1
	struct bt_att *att;

	__ASSERT_NO_MSG(conn);
 100cc7c:	b958      	cbnz	r0, 100cc96 <bt_att_send+0x1e>
 100cc7e:	492b      	ldr	r1, [pc, #172]	; (100cd2c <bt_att_send+0xb4>)
 100cc80:	f640 63a4 	movw	r3, #3748	; 0xea4
 100cc84:	4a2a      	ldr	r2, [pc, #168]	; (100cd30 <bt_att_send+0xb8>)
 100cc86:	482b      	ldr	r0, [pc, #172]	; (100cd34 <bt_att_send+0xbc>)
 100cc88:	f017 ffa5 	bl	1024bd6 <assert_print>
 100cc8c:	f640 61a4 	movw	r1, #3748	; 0xea4
	__ASSERT_NO_MSG(buf);
 100cc90:	4827      	ldr	r0, [pc, #156]	; (100cd30 <bt_att_send+0xb8>)
 100cc92:	f017 ff99 	bl	1024bc8 <assert_post_action>
 100cc96:	b949      	cbnz	r1, 100ccac <bt_att_send+0x34>
 100cc98:	4927      	ldr	r1, [pc, #156]	; (100cd38 <bt_att_send+0xc0>)
 100cc9a:	f640 63a5 	movw	r3, #3749	; 0xea5
 100cc9e:	4a24      	ldr	r2, [pc, #144]	; (100cd30 <bt_att_send+0xb8>)
 100cca0:	4824      	ldr	r0, [pc, #144]	; (100cd34 <bt_att_send+0xbc>)
 100cca2:	f017 ff98 	bl	1024bd6 <assert_print>
 100cca6:	f640 61a5 	movw	r1, #3749	; 0xea5
 100ccaa:	e7f1      	b.n	100cc90 <bt_att_send+0x18>

	att = att_get(conn);
 100ccac:	f7ff f8fc 	bl	100bea8 <att_get>
	if (!att) {
 100ccb0:	4605      	mov	r5, r0
 100ccb2:	b940      	cbnz	r0, 100ccc6 <bt_att_send+0x4e>
		tx_meta_data_free(bt_att_tx_meta_data(buf));
 100ccb4:	69a0      	ldr	r0, [r4, #24]
 100ccb6:	f7fe ff61 	bl	100bb7c <tx_meta_data_free>
		net_buf_unref(buf);
 100ccba:	4620      	mov	r0, r4
 100ccbc:	f011 f990 	bl	101dfe0 <net_buf_unref>
		return -ENOTCONN;
 100ccc0:	f06f 007f 	mvn.w	r0, #127	; 0x7f

	net_buf_put(&att->tx_queue, buf);
	att_send_process(att);

	return 0;
}
 100ccc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	net_buf_put(&att->tx_queue, buf);
 100ccc6:	f100 060c 	add.w	r6, r0, #12
 100ccca:	4621      	mov	r1, r4
 100cccc:	4630      	mov	r0, r6
 100ccce:	f011 f961 	bl	101df94 <net_buf_put>
	return list->head;
 100ccd2:	6aab      	ldr	r3, [r5, #40]	; 0x28
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 100ccd4:	b15b      	cbz	r3, 100ccee <bt_att_send+0x76>
	return node->next;
 100ccd6:	681c      	ldr	r4, [r3, #0]
 100ccd8:	f5a3 75ac 	sub.w	r5, r3, #344	; 0x158
 100ccdc:	b10c      	cbz	r4, 100cce2 <bt_att_send+0x6a>
 100ccde:	f5a4 74ac 	sub.w	r4, r4, #344	; 0x158
		err = process_queue(chan, &att->tx_queue);
 100cce2:	4631      	mov	r1, r6
 100cce4:	4628      	mov	r0, r5
 100cce6:	f01a fedd 	bl	1027aa4 <process_queue>
		if (!err) {
 100ccea:	4603      	mov	r3, r0
 100ccec:	b980      	cbnz	r0, 100cd10 <bt_att_send+0x98>
	return 0;
 100ccee:	2000      	movs	r0, #0
 100ccf0:	e7e8      	b.n	100ccc4 <bt_att_send+0x4c>
		    (atomic_test_bit(chan->flags, ATT_ENHANCED) ==
 100ccf2:	2103      	movs	r1, #3
 100ccf4:	f504 7080 	add.w	r0, r4, #256	; 0x100
 100ccf8:	f01a fde4 	bl	10278c4 <atomic_test_bit>
 100ccfc:	4607      	mov	r7, r0
		     atomic_test_bit(prev->flags, ATT_ENHANCED))) {
 100ccfe:	f505 7080 	add.w	r0, r5, #256	; 0x100
 100cd02:	f01a fddf 	bl	10278c4 <atomic_test_bit>
		if (err == -ENOENT && prev &&
 100cd06:	4287      	cmp	r7, r0
 100cd08:	f06f 0301 	mvn.w	r3, #1
 100cd0c:	d107      	bne.n	100cd1e <bt_att_send+0xa6>
 100cd0e:	4614      	mov	r4, r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 100cd10:	2c00      	cmp	r4, #0
 100cd12:	d0ec      	beq.n	100ccee <bt_att_send+0x76>
 100cd14:	f8d4 2158 	ldr.w	r2, [r4, #344]	; 0x158
 100cd18:	b922      	cbnz	r2, 100cd24 <bt_att_send+0xac>
		if (err == -ENOENT && prev &&
 100cd1a:	3302      	adds	r3, #2
 100cd1c:	d0e9      	beq.n	100ccf2 <bt_att_send+0x7a>
{
 100cd1e:	4625      	mov	r5, r4
 100cd20:	4614      	mov	r4, r2
 100cd22:	e7de      	b.n	100cce2 <bt_att_send+0x6a>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 100cd24:	f5a2 72ac 	sub.w	r2, r2, #344	; 0x158
 100cd28:	e7f7      	b.n	100cd1a <bt_att_send+0xa2>
 100cd2a:	bf00      	nop
 100cd2c:	0102dca4 	.word	0x0102dca4
 100cd30:	0102e16a 	.word	0x0102e16a
 100cd34:	0102b695 	.word	0x0102b695
 100cd38:	0102ef22 	.word	0x0102ef22

0100cd3c <bt_att_req_send>:

int bt_att_req_send(struct bt_conn *conn, struct bt_att_req *req)
{
 100cd3c:	b510      	push	{r4, lr}
 100cd3e:	460c      	mov	r4, r1
	struct bt_att *att;

	LOG_DBG("conn %p req %p", conn, req);

	__ASSERT_NO_MSG(conn);
 100cd40:	b958      	cbnz	r0, 100cd5a <bt_att_req_send+0x1e>
 100cd42:	4915      	ldr	r1, [pc, #84]	; (100cd98 <bt_att_req_send+0x5c>)
 100cd44:	f640 63ba 	movw	r3, #3770	; 0xeba
 100cd48:	4a14      	ldr	r2, [pc, #80]	; (100cd9c <bt_att_req_send+0x60>)
 100cd4a:	4815      	ldr	r0, [pc, #84]	; (100cda0 <bt_att_req_send+0x64>)
 100cd4c:	f017 ff43 	bl	1024bd6 <assert_print>
 100cd50:	f640 61ba 	movw	r1, #3770	; 0xeba
	__ASSERT_NO_MSG(req);
 100cd54:	4811      	ldr	r0, [pc, #68]	; (100cd9c <bt_att_req_send+0x60>)
 100cd56:	f017 ff37 	bl	1024bc8 <assert_post_action>
 100cd5a:	b949      	cbnz	r1, 100cd70 <bt_att_req_send+0x34>
 100cd5c:	4911      	ldr	r1, [pc, #68]	; (100cda4 <bt_att_req_send+0x68>)
 100cd5e:	f640 63bb 	movw	r3, #3771	; 0xebb
 100cd62:	4a0e      	ldr	r2, [pc, #56]	; (100cd9c <bt_att_req_send+0x60>)
 100cd64:	480e      	ldr	r0, [pc, #56]	; (100cda0 <bt_att_req_send+0x64>)
 100cd66:	f017 ff36 	bl	1024bd6 <assert_print>
 100cd6a:	f640 61bb 	movw	r1, #3771	; 0xebb
 100cd6e:	e7f1      	b.n	100cd54 <bt_att_req_send+0x18>

	att = att_get(conn);
 100cd70:	f7ff f89a 	bl	100bea8 <att_get>
	if (!att) {
 100cd74:	b160      	cbz	r0, 100cd90 <bt_att_req_send+0x54>
	parent->next = child;
 100cd76:	2300      	movs	r3, #0
 100cd78:	6023      	str	r3, [r4, #0]
	return list->tail;
 100cd7a:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_APPEND(slist, snode)
 100cd7c:	b92b      	cbnz	r3, 100cd8a <bt_att_req_send+0x4e>
	list->head = node;
 100cd7e:	e9c0 4401 	strd	r4, r4, [r0, #4]
		return -ENOTCONN;
	}

	sys_slist_append(&att->reqs, &req->node);
	att_req_send_process(att);
 100cd82:	f01a fff9 	bl	1027d78 <att_req_send_process>

	return 0;
 100cd86:	2000      	movs	r0, #0
}
 100cd88:	bd10      	pop	{r4, pc}
	parent->next = child;
 100cd8a:	601c      	str	r4, [r3, #0]
	list->tail = node;
 100cd8c:	6084      	str	r4, [r0, #8]
}
 100cd8e:	e7f8      	b.n	100cd82 <bt_att_req_send+0x46>
		return -ENOTCONN;
 100cd90:	f06f 007f 	mvn.w	r0, #127	; 0x7f
 100cd94:	e7f8      	b.n	100cd88 <bt_att_req_send+0x4c>
 100cd96:	bf00      	nop
 100cd98:	0102dca4 	.word	0x0102dca4
 100cd9c:	0102e16a 	.word	0x0102e16a
 100cda0:	0102b695 	.word	0x0102b695
 100cda4:	0102e219 	.word	0x0102e219

0100cda8 <find_cf_cfg>:
	atomic_set(cfg->flags, 0);
}

#if defined(CONFIG_BT_GATT_CACHING)
static struct gatt_cf_cfg *find_cf_cfg(struct bt_conn *conn)
{
 100cda8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100cdac:	4605      	mov	r5, r0
	int i;

	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
 100cdae:	2600      	movs	r6, #0
 100cdb0:	4c0c      	ldr	r4, [pc, #48]	; (100cde4 <find_cf_cfg+0x3c>)
		struct gatt_cf_cfg *cfg = &cf_cfg[i];

		if (!conn) {
			if (bt_addr_le_eq(&cfg->peer, BT_ADDR_LE_ANY)) {
 100cdb2:	f8df 8034 	ldr.w	r8, [pc, #52]	; 100cde8 <find_cf_cfg+0x40>
		struct gatt_cf_cfg *cfg = &cf_cfg[i];
 100cdb6:	4627      	mov	r7, r4
			if (bt_addr_le_eq(&cfg->peer, BT_ADDR_LE_ANY)) {
 100cdb8:	1c62      	adds	r2, r4, #1
		if (!conn) {
 100cdba:	b96d      	cbnz	r5, 100cdd8 <find_cf_cfg+0x30>
			if (bt_addr_le_eq(&cfg->peer, BT_ADDR_LE_ANY)) {
 100cdbc:	4641      	mov	r1, r8
 100cdbe:	4610      	mov	r0, r2
 100cdc0:	f01b fa4a 	bl	1028258 <bt_addr_le_eq>
 100cdc4:	b928      	cbnz	r0, 100cdd2 <find_cf_cfg+0x2a>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
 100cdc6:	3601      	adds	r6, #1
 100cdc8:	2e0d      	cmp	r6, #13
 100cdca:	f104 0410 	add.w	r4, r4, #16
 100cdce:	d1f2      	bne.n	100cdb6 <find_cf_cfg+0xe>
		} else if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
			return cfg;
		}
	}

	return NULL;
 100cdd0:	2700      	movs	r7, #0
}
 100cdd2:	4638      	mov	r0, r7
 100cdd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
 100cdd8:	4628      	mov	r0, r5
 100cdda:	7821      	ldrb	r1, [r4, #0]
 100cddc:	f01a fa58 	bl	1027290 <bt_conn_is_peer_addr_le>
 100cde0:	e7f0      	b.n	100cdc4 <find_cf_cfg+0x1c>
 100cde2:	bf00      	nop
 100cde4:	210048a4 	.word	0x210048a4
 100cde8:	0102cb79 	.word	0x0102cb79

0100cdec <find_sc_cfg>:
{
 100cdec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100cdee:	4606      	mov	r6, r0
 100cdf0:	460f      	mov	r7, r1
 100cdf2:	2400      	movs	r4, #0
 100cdf4:	4d09      	ldr	r5, [pc, #36]	; (100ce1c <find_sc_cfg+0x30>)
		if (id == sc_cfg[i].id &&
 100cdf6:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 100cdfa:	42b3      	cmp	r3, r6
 100cdfc:	d107      	bne.n	100ce0e <find_sc_cfg+0x22>
		    bt_addr_le_eq(&sc_cfg[i].peer, addr)) {
 100cdfe:	4639      	mov	r1, r7
 100ce00:	4628      	mov	r0, r5
 100ce02:	f01b fa29 	bl	1028258 <bt_addr_le_eq>
		if (id == sc_cfg[i].id &&
 100ce06:	b110      	cbz	r0, 100ce0e <find_sc_cfg+0x22>
			return &sc_cfg[i];
 100ce08:	4805      	ldr	r0, [pc, #20]	; (100ce20 <find_sc_cfg+0x34>)
 100ce0a:	4420      	add	r0, r4
}
 100ce0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
 100ce0e:	340c      	adds	r4, #12
 100ce10:	2c9c      	cmp	r4, #156	; 0x9c
 100ce12:	f105 050c 	add.w	r5, r5, #12
 100ce16:	d1ee      	bne.n	100cdf6 <find_sc_cfg+0xa>
	return NULL;
 100ce18:	2000      	movs	r0, #0
 100ce1a:	e7f7      	b.n	100ce0c <find_sc_cfg+0x20>
 100ce1c:	21008135 	.word	0x21008135
 100ce20:	21008134 	.word	0x21008134

0100ce24 <find_ccc_cfg>:
	return next;
}

static struct bt_gatt_ccc_cfg *find_ccc_cfg(const struct bt_conn *conn,
					    struct _bt_gatt_ccc *ccc)
{
 100ce24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100ce26:	4606      	mov	r6, r0
		if (conn) {
			if (bt_conn_is_peer_addr_le(conn, cfg->id,
						    &cfg->peer)) {
				return cfg;
			}
		} else if (bt_addr_le_eq(&cfg->peer, BT_ADDR_LE_ANY)) {
 100ce28:	4f0b      	ldr	r7, [pc, #44]	; (100ce58 <find_ccc_cfg+0x34>)
 100ce2a:	1c4c      	adds	r4, r1, #1
 100ce2c:	f101 0551 	add.w	r5, r1, #81	; 0x51
		if (conn) {
 100ce30:	b16e      	cbz	r6, 100ce4e <find_ccc_cfg+0x2a>
			if (bt_conn_is_peer_addr_le(conn, cfg->id,
 100ce32:	4622      	mov	r2, r4
 100ce34:	4630      	mov	r0, r6
 100ce36:	f814 1c01 	ldrb.w	r1, [r4, #-1]
 100ce3a:	f01a fa29 	bl	1027290 <bt_conn_is_peer_addr_le>
 100ce3e:	b108      	cbz	r0, 100ce44 <find_ccc_cfg+0x20>
		struct bt_gatt_ccc_cfg *cfg = &ccc->cfg[i];
 100ce40:	1e60      	subs	r0, r4, #1
			return cfg;
		}
	}

	return NULL;
}
 100ce42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (size_t i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
 100ce44:	340a      	adds	r4, #10
 100ce46:	42ac      	cmp	r4, r5
 100ce48:	d1f2      	bne.n	100ce30 <find_ccc_cfg+0xc>
	return NULL;
 100ce4a:	2000      	movs	r0, #0
 100ce4c:	e7f9      	b.n	100ce42 <find_ccc_cfg+0x1e>
		} else if (bt_addr_le_eq(&cfg->peer, BT_ADDR_LE_ANY)) {
 100ce4e:	4639      	mov	r1, r7
 100ce50:	4620      	mov	r0, r4
 100ce52:	f01b fa01 	bl	1028258 <bt_addr_le_eq>
 100ce56:	e7f2      	b.n	100ce3e <find_ccc_cfg+0x1a>
 100ce58:	0102cb79 	.word	0x0102cb79

0100ce5c <find_cf_cfg_by_addr>:
#endif
}

static struct gatt_cf_cfg *find_cf_cfg_by_addr(uint8_t id,
					       const bt_addr_le_t *addr)
{
 100ce5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100ce5e:	4606      	mov	r6, r0
 100ce60:	460f      	mov	r7, r1
 100ce62:	2400      	movs	r4, #0
 100ce64:	4d09      	ldr	r5, [pc, #36]	; (100ce8c <find_cf_cfg_by_addr+0x30>)
	if (IS_ENABLED(CONFIG_BT_GATT_CACHING)) {
		int i;

		for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
			if (id == cf_cfg[i].id &&
 100ce66:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 100ce6a:	42b3      	cmp	r3, r6
 100ce6c:	d107      	bne.n	100ce7e <find_cf_cfg_by_addr+0x22>
			    bt_addr_le_eq(addr, &cf_cfg[i].peer)) {
 100ce6e:	4629      	mov	r1, r5
 100ce70:	4638      	mov	r0, r7
 100ce72:	f01b f9f1 	bl	1028258 <bt_addr_le_eq>
			if (id == cf_cfg[i].id &&
 100ce76:	b110      	cbz	r0, 100ce7e <find_cf_cfg_by_addr+0x22>
				return &cf_cfg[i];
 100ce78:	4805      	ldr	r0, [pc, #20]	; (100ce90 <find_cf_cfg_by_addr+0x34>)
 100ce7a:	4420      	add	r0, r4
			}
		}
	}

	return NULL;
}
 100ce7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
 100ce7e:	3410      	adds	r4, #16
 100ce80:	2cd0      	cmp	r4, #208	; 0xd0
 100ce82:	f105 0510 	add.w	r5, r5, #16
 100ce86:	d1ee      	bne.n	100ce66 <find_cf_cfg_by_addr+0xa>
	return NULL;
 100ce88:	2000      	movs	r0, #0
 100ce8a:	e7f7      	b.n	100ce7c <find_cf_cfg_by_addr+0x20>
 100ce8c:	210048a5 	.word	0x210048a5
 100ce90:	210048a4 	.word	0x210048a4

0100ce94 <ccc_load>:
{
 100ce94:	b570      	push	{r4, r5, r6, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
 100ce96:	4b20      	ldr	r3, [pc, #128]	; (100cf18 <ccc_load+0x84>)
{
 100ce98:	4614      	mov	r4, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
 100ce9a:	6882      	ldr	r2, [r0, #8]
 100ce9c:	429a      	cmp	r2, r3
 100ce9e:	d10f      	bne.n	100cec0 <ccc_load+0x2c>
	if (!load->entry) {
 100cea0:	68a5      	ldr	r5, [r4, #8]
	ccc = attr->user_data;
 100cea2:	68c6      	ldr	r6, [r0, #12]
	if (!load->entry) {
 100cea4:	b975      	cbnz	r5, 100cec4 <ccc_load+0x30>
	cfg = ccc_find_cfg(ccc, addr, id);
 100cea6:	7922      	ldrb	r2, [r4, #4]
 100cea8:	6821      	ldr	r1, [r4, #0]
 100ceaa:	4630      	mov	r0, r6
 100ceac:	f01b f9dc 	bl	1028268 <ccc_find_cfg>
	if (!cfg) {
 100ceb0:	4604      	mov	r4, r0
 100ceb2:	b128      	cbz	r0, 100cec0 <ccc_load+0x2c>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
 100ceb4:	4919      	ldr	r1, [pc, #100]	; (100cf1c <ccc_load+0x88>)
 100ceb6:	3001      	adds	r0, #1
 100ceb8:	f01b f9fe 	bl	10282b8 <bt_addr_le_copy>
	cfg->id = 0U;
 100cebc:	7025      	strb	r5, [r4, #0]
	cfg->value = 0U;
 100cebe:	8125      	strh	r5, [r4, #8]
		return BT_GATT_ITER_CONTINUE;
 100cec0:	2001      	movs	r0, #1
}
 100cec2:	bd70      	pop	{r4, r5, r6, pc}
	} else if (!load->count) {
 100cec4:	68e0      	ldr	r0, [r4, #12]
 100cec6:	2800      	cmp	r0, #0
 100cec8:	d0fb      	beq.n	100cec2 <ccc_load+0x2e>
	if (load->entry->handle != handle) {
 100ceca:	882b      	ldrh	r3, [r5, #0]
 100cecc:	428b      	cmp	r3, r1
 100cece:	d00a      	beq.n	100cee6 <ccc_load+0x52>
		if (load->entry->handle < handle) {
 100ced0:	d2f6      	bcs.n	100cec0 <ccc_load+0x2c>
	load->count--;
 100ced2:	68e0      	ldr	r0, [r4, #12]
	load->entry++;
 100ced4:	68a3      	ldr	r3, [r4, #8]
	load->count--;
 100ced6:	3801      	subs	r0, #1
	load->entry++;
 100ced8:	3304      	adds	r3, #4
	load->count--;
 100ceda:	60e0      	str	r0, [r4, #12]
	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
 100cedc:	3800      	subs	r0, #0
 100cede:	bf18      	it	ne
 100cee0:	2001      	movne	r0, #1
	load->entry++;
 100cee2:	60a3      	str	r3, [r4, #8]
	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
 100cee4:	e7ed      	b.n	100cec2 <ccc_load+0x2e>
	cfg = ccc_find_cfg(ccc, load->addr_with_id.addr, load->addr_with_id.id);
 100cee6:	4630      	mov	r0, r6
 100cee8:	7922      	ldrb	r2, [r4, #4]
 100ceea:	6821      	ldr	r1, [r4, #0]
 100ceec:	f01b f9bc 	bl	1028268 <ccc_find_cfg>
	if (!cfg) {
 100cef0:	4605      	mov	r5, r0
 100cef2:	b968      	cbnz	r0, 100cf10 <ccc_load+0x7c>
		cfg = ccc_find_cfg(ccc, BT_ADDR_LE_ANY, 0);
 100cef4:	4602      	mov	r2, r0
 100cef6:	4909      	ldr	r1, [pc, #36]	; (100cf1c <ccc_load+0x88>)
 100cef8:	4630      	mov	r0, r6
 100cefa:	f01b f9b5 	bl	1028268 <ccc_find_cfg>
		if (!cfg) {
 100cefe:	4605      	mov	r5, r0
 100cf00:	2800      	cmp	r0, #0
 100cf02:	d0e6      	beq.n	100ced2 <ccc_load+0x3e>
		bt_addr_le_copy(&cfg->peer, load->addr_with_id.addr);
 100cf04:	6821      	ldr	r1, [r4, #0]
 100cf06:	3001      	adds	r0, #1
 100cf08:	f01b f9d6 	bl	10282b8 <bt_addr_le_copy>
		cfg->id = load->addr_with_id.id;
 100cf0c:	7923      	ldrb	r3, [r4, #4]
 100cf0e:	702b      	strb	r3, [r5, #0]
	cfg->value = load->entry->value;
 100cf10:	68a3      	ldr	r3, [r4, #8]
 100cf12:	885b      	ldrh	r3, [r3, #2]
 100cf14:	812b      	strh	r3, [r5, #8]
 100cf16:	e7dc      	b.n	100ced2 <ccc_load+0x3e>
 100cf18:	0100d791 	.word	0x0100d791
 100cf1c:	0102cb79 	.word	0x0102cb79

0100cf20 <bt_gatt_service_init>:
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 100cf20:	2201      	movs	r2, #1
{
 100cf22:	b510      	push	{r4, lr}
 100cf24:	4b15      	ldr	r3, [pc, #84]	; (100cf7c <bt_gatt_service_init+0x5c>)
 100cf26:	e8d3 1fef 	ldaex	r1, [r3]
 100cf2a:	2900      	cmp	r1, #0
 100cf2c:	d103      	bne.n	100cf36 <bt_gatt_service_init+0x16>
 100cf2e:	e8c3 2fe0 	stlex	r0, r2, [r3]
 100cf32:	2800      	cmp	r0, #0
 100cf34:	d1f7      	bne.n	100cf26 <bt_gatt_service_init+0x6>
	if (!atomic_cas(&service_init, 0, 1)) {
 100cf36:	d120      	bne.n	100cf7a <bt_gatt_service_init+0x5a>
 100cf38:	2000      	movs	r0, #0
 100cf3a:	4911      	ldr	r1, [pc, #68]	; (100cf80 <bt_gatt_service_init+0x60>)
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
 100cf3c:	4a11      	ldr	r2, [pc, #68]	; (100cf84 <bt_gatt_service_init+0x64>)
 100cf3e:	880b      	ldrh	r3, [r1, #0]
 100cf40:	4c11      	ldr	r4, [pc, #68]	; (100cf88 <bt_gatt_service_init+0x68>)
 100cf42:	42a2      	cmp	r2, r4
 100cf44:	d916      	bls.n	100cf74 <bt_gatt_service_init+0x54>
 100cf46:	b100      	cbz	r0, 100cf4a <bt_gatt_service_init+0x2a>
 100cf48:	800b      	strh	r3, [r1, #0]
 100cf4a:	4910      	ldr	r1, [pc, #64]	; (100cf8c <bt_gatt_service_init+0x6c>)
 100cf4c:	f44f 63a1 	mov.w	r3, #1288	; 0x508
 100cf50:	4a0f      	ldr	r2, [pc, #60]	; (100cf90 <bt_gatt_service_init+0x70>)
 100cf52:	4810      	ldr	r0, [pc, #64]	; (100cf94 <bt_gatt_service_init+0x74>)
 100cf54:	f017 fe3f 	bl	1024bd6 <assert_print>
 100cf58:	480f      	ldr	r0, [pc, #60]	; (100cf98 <bt_gatt_service_init+0x78>)
 100cf5a:	f017 fe3c 	bl	1024bd6 <assert_print>
 100cf5e:	f44f 61a1 	mov.w	r1, #1288	; 0x508
 100cf62:	480b      	ldr	r0, [pc, #44]	; (100cf90 <bt_gatt_service_init+0x70>)
 100cf64:	f017 fe30 	bl	1024bc8 <assert_post_action>
		last_static_handle += svc->attr_count;
 100cf68:	6850      	ldr	r0, [r2, #4]
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
 100cf6a:	3208      	adds	r2, #8
		last_static_handle += svc->attr_count;
 100cf6c:	4403      	add	r3, r0
 100cf6e:	b29b      	uxth	r3, r3
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
 100cf70:	2001      	movs	r0, #1
 100cf72:	e7e6      	b.n	100cf42 <bt_gatt_service_init+0x22>
 100cf74:	d3f8      	bcc.n	100cf68 <bt_gatt_service_init+0x48>
 100cf76:	b100      	cbz	r0, 100cf7a <bt_gatt_service_init+0x5a>
 100cf78:	800b      	strh	r3, [r1, #0]
}
 100cf7a:	bd10      	pop	{r4, pc}
 100cf7c:	21004974 	.word	0x21004974
 100cf80:	210081d0 	.word	0x210081d0
 100cf84:	0102992c 	.word	0x0102992c
 100cf88:	01029944 	.word	0x01029944
 100cf8c:	0102e5e9 	.word	0x0102e5e9
 100cf90:	0102e3f4 	.word	0x0102e3f4
 100cf94:	0102b695 	.word	0x0102b695
 100cf98:	0102bf04 	.word	0x0102bf04

0100cf9c <gatt_ccc_conn_enqueue>:
{
 100cf9c:	b570      	push	{r4, r5, r6, lr}
 100cf9e:	4604      	mov	r4, r0
	return (conn == gatt_ccc_store.conn_list[bt_conn_index(conn)]);
 100cfa0:	f7fd f9c8 	bl	100a334 <bt_conn_index>
 100cfa4:	4d0e      	ldr	r5, [pc, #56]	; (100cfe0 <gatt_ccc_conn_enqueue+0x44>)
	if ((!gatt_ccc_conn_is_queued(conn)) &&
 100cfa6:	f855 3020 	ldr.w	r3, [r5, r0, lsl #2]
 100cfaa:	429c      	cmp	r4, r3
 100cfac:	d017      	beq.n	100cfde <gatt_ccc_conn_enqueue+0x42>
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 100cfae:	7a20      	ldrb	r0, [r4, #8]
 100cfb0:	f104 0190 	add.w	r1, r4, #144	; 0x90
 100cfb4:	f019 fed3 	bl	1026d5e <bt_addr_le_is_bonded>
	if ((!gatt_ccc_conn_is_queued(conn)) &&
 100cfb8:	b188      	cbz	r0, 100cfde <gatt_ccc_conn_enqueue+0x42>
		gatt_ccc_store.conn_list[bt_conn_index(conn)] =
 100cfba:	4620      	mov	r0, r4
 100cfbc:	f7fd f9ba 	bl	100a334 <bt_conn_index>
 100cfc0:	4606      	mov	r6, r0
			bt_conn_ref(conn);
 100cfc2:	4620      	mov	r0, r4
 100cfc4:	f7fd f842 	bl	100a04c <bt_conn_ref>
		gatt_ccc_store.conn_list[bt_conn_index(conn)] =
 100cfc8:	f845 0026 	str.w	r0, [r5, r6, lsl #2]
		k_work_reschedule(&gatt_ccc_store.work, CCC_STORE_DELAY);
 100cfcc:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 100cfd0:	f105 0020 	add.w	r0, r5, #32
 100cfd4:	2300      	movs	r3, #0
}
 100cfd6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		k_work_reschedule(&gatt_ccc_store.work, CCC_STORE_DELAY);
 100cfda:	f015 b8b3 	b.w	1022144 <k_work_reschedule>
}
 100cfde:	bd70      	pop	{r4, r5, r6, pc}
 100cfe0:	210023c8 	.word	0x210023c8

0100cfe4 <ccc_set_direct.part.0>:
static int ccc_set_direct(const char *key, size_t len, settings_read_cb read_cb,
 100cfe4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
			LOG_ERR("Invalid key");
 100cfe6:	4b07      	ldr	r3, [pc, #28]	; (100d004 <ccc_set_direct.part.0+0x20>)
 100cfe8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100cfec:	9305      	str	r3, [sp, #20]
 100cfee:	2302      	movs	r3, #2
 100cff0:	4805      	ldr	r0, [pc, #20]	; (100d008 <ccc_set_direct.part.0+0x24>)
 100cff2:	aa04      	add	r2, sp, #16
 100cff4:	9304      	str	r3, [sp, #16]
 100cff6:	f01b f993 	bl	1028320 <z_log_msg_static_create.constprop.0>
}
 100cffa:	f06f 0015 	mvn.w	r0, #21
 100cffe:	b007      	add	sp, #28
 100d000:	f85d fb04 	ldr.w	pc, [sp], #4
 100d004:	0102e424 	.word	0x0102e424
 100d008:	0102999c 	.word	0x0102999c

0100d00c <sc_set>:
}

#if defined(CONFIG_BT_GATT_SERVICE_CHANGED)
static int sc_set(const char *name, size_t len_rd, settings_read_cb read_cb,
		  void *cb_arg)
{
 100d00c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100d010:	b08b      	sub	sp, #44	; 0x2c
 100d012:	460e      	mov	r6, r1
 100d014:	4690      	mov	r8, r2
 100d016:	4699      	mov	r9, r3
	bt_addr_le_t addr;
	ssize_t len;
	int err;
	const char *next;

	if (!name) {
 100d018:	4604      	mov	r4, r0
{
 100d01a:	af00      	add	r7, sp, #0
	if (!name) {
 100d01c:	b988      	cbnz	r0, 100d042 <sc_set+0x36>
		LOG_ERR("Insufficient number of arguments");
 100d01e:	4b44      	ldr	r3, [pc, #272]	; (100d130 <sc_set+0x124>)
 100d020:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100d024:	627b      	str	r3, [r7, #36]	; 0x24
 100d026:	2302      	movs	r3, #2
 100d028:	4842      	ldr	r0, [pc, #264]	; (100d134 <sc_set+0x128>)
 100d02a:	623b      	str	r3, [r7, #32]
 100d02c:	f107 0220 	add.w	r2, r7, #32
 100d030:	f01b f976 	bl	1028320 <z_log_msg_static_create.constprop.0>
		return -EINVAL;
 100d034:	f06f 0515 	mvn.w	r5, #21

		LOG_DBG("Removed SC for %s", bt_addr_le_str(&addr));
	}

	return 0;
}
 100d038:	4628      	mov	r0, r5
 100d03a:	372c      	adds	r7, #44	; 0x2c
 100d03c:	46bd      	mov	sp, r7
 100d03e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	err = bt_settings_decode_key(name, &addr);
 100d042:	f107 0108 	add.w	r1, r7, #8
 100d046:	f019 fd17 	bl	1026a78 <bt_settings_decode_key>
	if (err) {
 100d04a:	4605      	mov	r5, r0
 100d04c:	b190      	cbz	r0, 100d074 <sc_set+0x68>
		LOG_ERR("Unable to decode address %s", name);
 100d04e:	466d      	mov	r5, sp
 100d050:	b088      	sub	sp, #32
 100d052:	466a      	mov	r2, sp
 100d054:	4b38      	ldr	r3, [pc, #224]	; (100d138 <sc_set+0x12c>)
 100d056:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 100d05a:	e9c2 3405 	strd	r3, r4, [r2, #20]
 100d05e:	f44f 7300 	mov.w	r3, #512	; 0x200
 100d062:	8393      	strh	r3, [r2, #28]
 100d064:	4b35      	ldr	r3, [pc, #212]	; (100d13c <sc_set+0x130>)
 100d066:	4833      	ldr	r0, [pc, #204]	; (100d134 <sc_set+0x128>)
 100d068:	f842 3f10 	str.w	r3, [r2, #16]!
 100d06c:	f01b f958 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100d070:	46ad      	mov	sp, r5
		return -EINVAL;
 100d072:	e7df      	b.n	100d034 <sc_set+0x28>
	settings_name_next(name, &next);
 100d074:	4620      	mov	r0, r4
 100d076:	1d39      	adds	r1, r7, #4
 100d078:	f018 f9a4 	bl	10253c4 <settings_name_next>
	if (!next) {
 100d07c:	6878      	ldr	r0, [r7, #4]
 100d07e:	b1a0      	cbz	r0, 100d0aa <sc_set+0x9e>
		unsigned long next_id = strtoul(next, NULL, 10);
 100d080:	220a      	movs	r2, #10
 100d082:	4629      	mov	r1, r5
 100d084:	f019 fbb6 	bl	10267f4 <strtoul>
		if (next_id >= CONFIG_BT_ID_MAX) {
 100d088:	b178      	cbz	r0, 100d0aa <sc_set+0x9e>
			LOG_ERR("Invalid local identity %lu", next_id);
 100d08a:	466c      	mov	r4, sp
 100d08c:	b088      	sub	sp, #32
 100d08e:	466a      	mov	r2, sp
 100d090:	4b2b      	ldr	r3, [pc, #172]	; (100d140 <sc_set+0x134>)
 100d092:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100d096:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100d09a:	2303      	movs	r3, #3
 100d09c:	4825      	ldr	r0, [pc, #148]	; (100d134 <sc_set+0x128>)
 100d09e:	f842 3f10 	str.w	r3, [r2, #16]!
 100d0a2:	f01b f93d 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100d0a6:	46a5      	mov	sp, r4
			return -EINVAL;
 100d0a8:	e7c4      	b.n	100d034 <sc_set+0x28>
	cfg = find_sc_cfg(id, &addr);
 100d0aa:	2000      	movs	r0, #0
 100d0ac:	f107 0108 	add.w	r1, r7, #8
 100d0b0:	f7ff fe9c 	bl	100cdec <find_sc_cfg>
	if (!cfg && len_rd) {
 100d0b4:	4604      	mov	r4, r0
 100d0b6:	bb98      	cbnz	r0, 100d120 <sc_set+0x114>
 100d0b8:	2e00      	cmp	r6, #0
 100d0ba:	d0bd      	beq.n	100d038 <sc_set+0x2c>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
 100d0bc:	4921      	ldr	r1, [pc, #132]	; (100d144 <sc_set+0x138>)
 100d0be:	f7ff fe95 	bl	100cdec <find_sc_cfg>
		if (!cfg) {
 100d0c2:	4604      	mov	r4, r0
 100d0c4:	b968      	cbnz	r0, 100d0e2 <sc_set+0xd6>
			LOG_ERR("Unable to restore SC: no cfg left");
 100d0c6:	4b20      	ldr	r3, [pc, #128]	; (100d148 <sc_set+0x13c>)
 100d0c8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100d0cc:	627b      	str	r3, [r7, #36]	; 0x24
 100d0ce:	2302      	movs	r3, #2
 100d0d0:	4818      	ldr	r0, [pc, #96]	; (100d134 <sc_set+0x128>)
 100d0d2:	623b      	str	r3, [r7, #32]
 100d0d4:	f107 0220 	add.w	r2, r7, #32
 100d0d8:	f01b f922 	bl	1028320 <z_log_msg_static_create.constprop.0>
			return -ENOMEM;
 100d0dc:	f06f 050b 	mvn.w	r5, #11
 100d0e0:	e7aa      	b.n	100d038 <sc_set+0x2c>
		cfg->id = id;
 100d0e2:	2300      	movs	r3, #0
		bt_addr_le_copy(&cfg->peer, &addr);
 100d0e4:	f107 0108 	add.w	r1, r7, #8
		cfg->id = id;
 100d0e8:	f800 3b01 	strb.w	r3, [r0], #1
		bt_addr_le_copy(&cfg->peer, &addr);
 100d0ec:	f01b f8e4 	bl	10282b8 <bt_addr_le_copy>
		len = read_cb(cb_arg, &cfg->data, sizeof(cfg->data));
 100d0f0:	f104 0108 	add.w	r1, r4, #8
 100d0f4:	2204      	movs	r2, #4
 100d0f6:	4648      	mov	r0, r9
 100d0f8:	47c0      	blx	r8
		if (len < 0) {
 100d0fa:	1e04      	subs	r4, r0, #0
 100d0fc:	da9c      	bge.n	100d038 <sc_set+0x2c>
			LOG_ERR("Failed to decode value (err %zd)", len);
 100d0fe:	466d      	mov	r5, sp
 100d100:	b088      	sub	sp, #32
 100d102:	466a      	mov	r2, sp
 100d104:	4b11      	ldr	r3, [pc, #68]	; (100d14c <sc_set+0x140>)
 100d106:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100d10a:	e9c2 3405 	strd	r3, r4, [r2, #20]
 100d10e:	2303      	movs	r3, #3
 100d110:	4808      	ldr	r0, [pc, #32]	; (100d134 <sc_set+0x128>)
 100d112:	f842 3f10 	str.w	r3, [r2, #16]!
 100d116:	f01b f903 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100d11a:	46ad      	mov	sp, r5
			return len;
 100d11c:	4625      	mov	r5, r4
 100d11e:	e78b      	b.n	100d038 <sc_set+0x2c>
	if (len_rd) {
 100d120:	2e00      	cmp	r6, #0
 100d122:	d1e5      	bne.n	100d0f0 <sc_set+0xe4>
		memset(cfg, 0, sizeof(*cfg));
 100d124:	220c      	movs	r2, #12
 100d126:	4631      	mov	r1, r6
 100d128:	f019 fc2f 	bl	102698a <memset>
		LOG_DBG("Removed SC for %s", bt_addr_le_str(&addr));
 100d12c:	e784      	b.n	100d038 <sc_set+0x2c>
 100d12e:	bf00      	nop
 100d130:	0102cd4a 	.word	0x0102cd4a
 100d134:	0102999c 	.word	0x0102999c
 100d138:	0102e430 	.word	0x0102e430
 100d13c:	01000003 	.word	0x01000003
 100d140:	0102e44c 	.word	0x0102e44c
 100d144:	0102cb79 	.word	0x0102cb79
 100d148:	0102e467 	.word	0x0102e467
 100d14c:	0102e489 	.word	0x0102e489

0100d150 <db_hash_commit>:

	return 0;
}

static int db_hash_commit(void)
{
 100d150:	b5b0      	push	{r4, r5, r7, lr}
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
 100d152:	2108      	movs	r1, #8
 100d154:	af00      	add	r7, sp, #0
 100d156:	480f      	ldr	r0, [pc, #60]	; (100d194 <db_hash_commit+0x44>)
 100d158:	f01b f8a3 	bl	10282a2 <atomic_or>
	atomic_set_bit(gatt_sc.flags, DB_HASH_LOAD);
	/* Reschedule work to calculate and compare against the Hash value
	 * loaded from flash.
	 */
	if (IS_ENABLED(CONFIG_BT_LONG_WQ)) {
		err = bt_long_wq_reschedule(&db_hash.work, K_NO_WAIT);
 100d15c:	2200      	movs	r2, #0
 100d15e:	2300      	movs	r3, #0
 100d160:	480d      	ldr	r0, [pc, #52]	; (100d198 <db_hash_commit+0x48>)
 100d162:	f7fa f8c7 	bl	10072f4 <bt_long_wq_reschedule>
	/* Settings commit uses non-zero value to indicate failure. */
	if (err > 0) {
		err = 0;
	}

	if (err) {
 100d166:	1e04      	subs	r4, r0, #0
 100d168:	da11      	bge.n	100d18e <db_hash_commit+0x3e>
		LOG_ERR("Unable to reschedule database hash process (err %d)", err);
 100d16a:	466d      	mov	r5, sp
 100d16c:	b088      	sub	sp, #32
 100d16e:	466a      	mov	r2, sp
 100d170:	4b0a      	ldr	r3, [pc, #40]	; (100d19c <db_hash_commit+0x4c>)
 100d172:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100d176:	e9c2 3405 	strd	r3, r4, [r2, #20]
 100d17a:	2303      	movs	r3, #3
 100d17c:	4808      	ldr	r0, [pc, #32]	; (100d1a0 <db_hash_commit+0x50>)
 100d17e:	f842 3f10 	str.w	r3, [r2, #16]!
 100d182:	f01b f8cd 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100d186:	46ad      	mov	sp, r5
	}

	return err;
}
 100d188:	4620      	mov	r0, r4
 100d18a:	46bd      	mov	sp, r7
 100d18c:	bdb0      	pop	{r4, r5, r7, pc}
		err = bt_long_wq_reschedule(&db_hash.work, K_NO_WAIT);
 100d18e:	2400      	movs	r4, #0
	return err;
 100d190:	e7fa      	b.n	100d188 <db_hash_commit+0x38>
 100d192:	bf00      	nop
 100d194:	210024e0 	.word	0x210024e0
 100d198:	21002438 	.word	0x21002438
 100d19c:	0102e4aa 	.word	0x0102e4aa
 100d1a0:	0102999c 	.word	0x0102999c

0100d1a4 <sc_store>:
{
 100d1a4:	b5b0      	push	{r4, r5, r7, lr}
 100d1a6:	b08c      	sub	sp, #48	; 0x30
	if (cfg->id) {
 100d1a8:	4605      	mov	r5, r0
 100d1aa:	f815 2b01 	ldrb.w	r2, [r5], #1
{
 100d1ae:	4604      	mov	r4, r0
 100d1b0:	af02      	add	r7, sp, #8
	if (cfg->id) {
 100d1b2:	b31a      	cbz	r2, 100d1fc <sc_store+0x58>
		u8_to_dec(id_str, sizeof(id_str), cfg->id);
 100d1b4:	2104      	movs	r1, #4
 100d1b6:	4638      	mov	r0, r7
 100d1b8:	f017 fa75 	bl	10246a6 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "sc",
 100d1bc:	9700      	str	r7, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "sc",
 100d1be:	2124      	movs	r1, #36	; 0x24
 100d1c0:	4a0f      	ldr	r2, [pc, #60]	; (100d200 <sc_store+0x5c>)
 100d1c2:	1d38      	adds	r0, r7, #4
 100d1c4:	462b      	mov	r3, r5
 100d1c6:	f7f9 ffdb 	bl	1007180 <bt_settings_encode_key>
	err = settings_save_one(key, (char *)&cfg->data, sizeof(cfg->data));
 100d1ca:	2204      	movs	r2, #4
 100d1cc:	f104 0108 	add.w	r1, r4, #8
 100d1d0:	18b8      	adds	r0, r7, r2
 100d1d2:	f7f8 f9bf 	bl	1005554 <settings_save_one>
	if (err) {
 100d1d6:	b170      	cbz	r0, 100d1f6 <sc_store+0x52>
		LOG_ERR("failed to store SC (err %d)", err);
 100d1d8:	466c      	mov	r4, sp
 100d1da:	b088      	sub	sp, #32
 100d1dc:	aa02      	add	r2, sp, #8
 100d1de:	4b09      	ldr	r3, [pc, #36]	; (100d204 <sc_store+0x60>)
 100d1e0:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100d1e4:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100d1e8:	2303      	movs	r3, #3
 100d1ea:	4807      	ldr	r0, [pc, #28]	; (100d208 <sc_store+0x64>)
 100d1ec:	f842 3f10 	str.w	r3, [r2, #16]!
 100d1f0:	f01b f896 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100d1f4:	46a5      	mov	sp, r4
}
 100d1f6:	3728      	adds	r7, #40	; 0x28
 100d1f8:	46bd      	mov	sp, r7
 100d1fa:	bdb0      	pop	{r4, r5, r7, pc}
		bt_settings_encode_key(key, sizeof(key), "sc",
 100d1fc:	9200      	str	r2, [sp, #0]
 100d1fe:	e7de      	b.n	100d1be <sc_store+0x1a>
 100d200:	0102e877 	.word	0x0102e877
 100d204:	0102e4de 	.word	0x0102e4de
 100d208:	0102999c 	.word	0x0102999c

0100d20c <sc_save>:
{
 100d20c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100d210:	b086      	sub	sp, #24
 100d212:	4680      	mov	r8, r0
 100d214:	460f      	mov	r7, r1
 100d216:	4616      	mov	r6, r2
 100d218:	461d      	mov	r5, r3
	cfg = find_sc_cfg(id, peer);
 100d21a:	f7ff fde7 	bl	100cdec <find_sc_cfg>
	if (!cfg) {
 100d21e:	4604      	mov	r4, r0
 100d220:	b9b0      	cbnz	r0, 100d250 <sc_save+0x44>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
 100d222:	4919      	ldr	r1, [pc, #100]	; (100d288 <sc_save+0x7c>)
 100d224:	f7ff fde2 	bl	100cdec <find_sc_cfg>
		if (!cfg) {
 100d228:	4604      	mov	r4, r0
 100d22a:	b960      	cbnz	r0, 100d246 <sc_save+0x3a>
			LOG_ERR("unable to save SC: no cfg left");
 100d22c:	4b17      	ldr	r3, [pc, #92]	; (100d28c <sc_save+0x80>)
 100d22e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100d232:	9305      	str	r3, [sp, #20]
 100d234:	2302      	movs	r3, #2
 100d236:	4816      	ldr	r0, [pc, #88]	; (100d290 <sc_save+0x84>)
 100d238:	aa04      	add	r2, sp, #16
 100d23a:	9304      	str	r3, [sp, #16]
 100d23c:	f01b f870 	bl	1028320 <z_log_msg_static_create.constprop.0>
}
 100d240:	b006      	add	sp, #24
 100d242:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		bt_addr_le_copy(&cfg->peer, peer);
 100d246:	4639      	mov	r1, r7
		cfg->id = id;
 100d248:	f800 8b01 	strb.w	r8, [r0], #1
		bt_addr_le_copy(&cfg->peer, peer);
 100d24c:	f01b f834 	bl	10282b8 <bt_addr_le_copy>
	if (!(cfg->data.start || cfg->data.end)) {
 100d250:	8922      	ldrh	r2, [r4, #8]
 100d252:	8963      	ldrh	r3, [r4, #10]
 100d254:	b97a      	cbnz	r2, 100d276 <sc_save+0x6a>
 100d256:	b983      	cbnz	r3, 100d27a <sc_save+0x6e>
		cfg->data.start = start;
 100d258:	8126      	strh	r6, [r4, #8]
		*end = new_end;
 100d25a:	8165      	strh	r5, [r4, #10]
	    modified && bt_addr_le_is_bonded(cfg->id, &cfg->peer)) {
 100d25c:	4621      	mov	r1, r4
 100d25e:	f811 0b01 	ldrb.w	r0, [r1], #1
 100d262:	f019 fd7c 	bl	1026d5e <bt_addr_le_is_bonded>
 100d266:	2800      	cmp	r0, #0
 100d268:	d0ea      	beq.n	100d240 <sc_save+0x34>
		sc_store(cfg);
 100d26a:	4620      	mov	r0, r4
}
 100d26c:	b006      	add	sp, #24
 100d26e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		sc_store(cfg);
 100d272:	f7ff bf97 	b.w	100d1a4 <sc_store>
	if (new_start >= *start && new_end <= *end) {
 100d276:	4296      	cmp	r6, r2
 100d278:	d302      	bcc.n	100d280 <sc_save+0x74>
 100d27a:	429d      	cmp	r5, r3
 100d27c:	d8ed      	bhi.n	100d25a <sc_save+0x4e>
 100d27e:	e7df      	b.n	100d240 <sc_save+0x34>
	if (*end < new_end) {
 100d280:	429d      	cmp	r5, r3
		*start = new_start;
 100d282:	8126      	strh	r6, [r4, #8]
	if (*end < new_end) {
 100d284:	d9ea      	bls.n	100d25c <sc_save+0x50>
 100d286:	e7e8      	b.n	100d25a <sc_save+0x4e>
 100d288:	0102cb79 	.word	0x0102cb79
 100d28c:	0102e4fa 	.word	0x0102e4fa
 100d290:	0102999c 	.word	0x0102999c

0100d294 <cf_write>:
{
 100d294:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100d298:	b086      	sub	sp, #24
 100d29a:	461f      	mov	r7, r3
 100d29c:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
 100d2a0:	4606      	mov	r6, r0
	if (offset > sizeof(cfg->data)) {
 100d2a2:	2b01      	cmp	r3, #1
{
 100d2a4:	4690      	mov	r8, r2
	if (offset > sizeof(cfg->data)) {
 100d2a6:	d83c      	bhi.n	100d322 <cf_write+0x8e>
	if (offset + len > sizeof(cfg->data)) {
 100d2a8:	443b      	add	r3, r7
 100d2aa:	2b01      	cmp	r3, #1
 100d2ac:	463d      	mov	r5, r7
 100d2ae:	dc3b      	bgt.n	100d328 <cf_write+0x94>
	cfg = find_cf_cfg(conn);
 100d2b0:	f7ff fd7a 	bl	100cda8 <find_cf_cfg>
	if (!cfg) {
 100d2b4:	4604      	mov	r4, r0
 100d2b6:	b998      	cbnz	r0, 100d2e0 <cf_write+0x4c>
		cfg = find_cf_cfg(NULL);
 100d2b8:	f7ff fd76 	bl	100cda8 <find_cf_cfg>
	if (!cfg) {
 100d2bc:	4604      	mov	r4, r0
 100d2be:	b978      	cbnz	r0, 100d2e0 <cf_write+0x4c>
		LOG_WRN("No space to store Client Supported Features");
 100d2c0:	4b1c      	ldr	r3, [pc, #112]	; (100d334 <cf_write+0xa0>)
		return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
 100d2c2:	f06f 0510 	mvn.w	r5, #16
		LOG_WRN("No space to store Client Supported Features");
 100d2c6:	9305      	str	r3, [sp, #20]
 100d2c8:	2302      	movs	r3, #2
 100d2ca:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100d2ce:	481a      	ldr	r0, [pc, #104]	; (100d338 <cf_write+0xa4>)
 100d2d0:	aa04      	add	r2, sp, #16
 100d2d2:	9304      	str	r3, [sp, #16]
 100d2d4:	f01b f824 	bl	1028320 <z_log_msg_static_create.constprop.0>
}
 100d2d8:	4628      	mov	r0, r5
 100d2da:	b006      	add	sp, #24
 100d2dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (i = 0U; i <= CF_BIT_LAST && (i / 8) < len; i++) {
 100d2e0:	b197      	cbz	r7, 100d308 <cf_write+0x74>
		    !(value[i / 8] & BIT(i % 8))) {
 100d2e2:	2300      	movs	r3, #0
		if ((cfg->data[i / 8] & BIT(i % 8)) &&
 100d2e4:	7a21      	ldrb	r1, [r4, #8]
		    !(value[i / 8] & BIT(i % 8))) {
 100d2e6:	f898 2000 	ldrb.w	r2, [r8]
		if ((cfg->data[i / 8] & BIT(i % 8)) &&
 100d2ea:	fa21 f003 	lsr.w	r0, r1, r3
 100d2ee:	07c7      	lsls	r7, r0, #31
 100d2f0:	d503      	bpl.n	100d2fa <cf_write+0x66>
		    !(value[i / 8] & BIT(i % 8))) {
 100d2f2:	fa22 f003 	lsr.w	r0, r2, r3
		if ((cfg->data[i / 8] & BIT(i % 8)) &&
 100d2f6:	07c0      	lsls	r0, r0, #31
 100d2f8:	d519      	bpl.n	100d32e <cf_write+0x9a>
	for (i = 0U; i <= CF_BIT_LAST && (i / 8) < len; i++) {
 100d2fa:	3301      	adds	r3, #1
 100d2fc:	2b03      	cmp	r3, #3
 100d2fe:	d1f4      	bne.n	100d2ea <cf_write+0x56>
			cfg->data[i] |= value[i] & BIT_MASK(CF_NUM_BITS % 8);
 100d300:	f002 0207 	and.w	r2, r2, #7
 100d304:	4311      	orrs	r1, r2
 100d306:	7221      	strb	r1, [r4, #8]
	bt_addr_le_copy(&cfg->peer, &conn->le.dst);
 100d308:	f106 0190 	add.w	r1, r6, #144	; 0x90
 100d30c:	1c60      	adds	r0, r4, #1
 100d30e:	f01a ffd3 	bl	10282b8 <bt_addr_le_copy>
	cfg->id = conn->id;
 100d312:	4620      	mov	r0, r4
 100d314:	7a33      	ldrb	r3, [r6, #8]
 100d316:	2101      	movs	r1, #1
 100d318:	f800 3b0c 	strb.w	r3, [r0], #12
 100d31c:	f01a ffc1 	bl	10282a2 <atomic_or>
}
 100d320:	e7da      	b.n	100d2d8 <cf_write+0x44>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 100d322:	f06f 0506 	mvn.w	r5, #6
 100d326:	e7d7      	b.n	100d2d8 <cf_write+0x44>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 100d328:	f06f 050c 	mvn.w	r5, #12
 100d32c:	e7d4      	b.n	100d2d8 <cf_write+0x44>
		return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED);
 100d32e:	f06f 0512 	mvn.w	r5, #18
 100d332:	e7d1      	b.n	100d2d8 <cf_write+0x44>
 100d334:	0102e519 	.word	0x0102e519
 100d338:	0102999c 	.word	0x0102999c

0100d33c <db_hash_store>:
{
 100d33c:	b598      	push	{r3, r4, r7, lr}
	err = settings_save_one("bt/hash", &db_hash.hash, sizeof(db_hash.hash));
 100d33e:	2210      	movs	r2, #16
{
 100d340:	af00      	add	r7, sp, #0
	err = settings_save_one("bt/hash", &db_hash.hash, sizeof(db_hash.hash));
 100d342:	490b      	ldr	r1, [pc, #44]	; (100d370 <db_hash_store+0x34>)
 100d344:	480b      	ldr	r0, [pc, #44]	; (100d374 <db_hash_store+0x38>)
 100d346:	f7f8 f905 	bl	1005554 <settings_save_one>
	if (err) {
 100d34a:	b170      	cbz	r0, 100d36a <db_hash_store+0x2e>
		LOG_ERR("Failed to save Database Hash (err %d)", err);
 100d34c:	466c      	mov	r4, sp
 100d34e:	b088      	sub	sp, #32
 100d350:	466a      	mov	r2, sp
 100d352:	4b09      	ldr	r3, [pc, #36]	; (100d378 <db_hash_store+0x3c>)
 100d354:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100d358:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100d35c:	2303      	movs	r3, #3
 100d35e:	4807      	ldr	r0, [pc, #28]	; (100d37c <db_hash_store+0x40>)
 100d360:	f842 3f10 	str.w	r3, [r2, #16]!
 100d364:	f01a ffdc 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100d368:	46a5      	mov	sp, r4
}
 100d36a:	46bd      	mov	sp, r7
 100d36c:	bd98      	pop	{r3, r4, r7, pc}
 100d36e:	bf00      	nop
 100d370:	21002418 	.word	0x21002418
 100d374:	0102e545 	.word	0x0102e545
 100d378:	0102e54d 	.word	0x0102e54d
 100d37c:	0102999c 	.word	0x0102999c

0100d380 <db_hash_set>:
{
 100d380:	b5b0      	push	{r4, r5, r7, lr}
	len = read_cb(cb_arg, db_hash.stored_hash, sizeof(db_hash.stored_hash));
 100d382:	4618      	mov	r0, r3
{
 100d384:	4614      	mov	r4, r2
	len = read_cb(cb_arg, db_hash.stored_hash, sizeof(db_hash.stored_hash));
 100d386:	490d      	ldr	r1, [pc, #52]	; (100d3bc <db_hash_set+0x3c>)
 100d388:	2210      	movs	r2, #16
{
 100d38a:	af00      	add	r7, sp, #0
	len = read_cb(cb_arg, db_hash.stored_hash, sizeof(db_hash.stored_hash));
 100d38c:	47a0      	blx	r4
	if (len < 0) {
 100d38e:	1e04      	subs	r4, r0, #0
 100d390:	da11      	bge.n	100d3b6 <db_hash_set+0x36>
		LOG_ERR("Failed to decode value (err %zd)", len);
 100d392:	466d      	mov	r5, sp
 100d394:	b088      	sub	sp, #32
 100d396:	466a      	mov	r2, sp
 100d398:	4b09      	ldr	r3, [pc, #36]	; (100d3c0 <db_hash_set+0x40>)
 100d39a:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100d39e:	e9c2 3405 	strd	r3, r4, [r2, #20]
 100d3a2:	2303      	movs	r3, #3
 100d3a4:	4807      	ldr	r0, [pc, #28]	; (100d3c4 <db_hash_set+0x44>)
 100d3a6:	f842 3f10 	str.w	r3, [r2, #16]!
 100d3aa:	f01a ffb9 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100d3ae:	46ad      	mov	sp, r5
}
 100d3b0:	4620      	mov	r0, r4
 100d3b2:	46bd      	mov	sp, r7
 100d3b4:	bdb0      	pop	{r4, r5, r7, pc}
	return 0;
 100d3b6:	2400      	movs	r4, #0
 100d3b8:	e7fa      	b.n	100d3b0 <db_hash_set+0x30>
 100d3ba:	bf00      	nop
 100d3bc:	21002428 	.word	0x21002428
 100d3c0:	0102e489 	.word	0x0102e489
 100d3c4:	0102999c 	.word	0x0102999c

0100d3c8 <clear_cf_cfg>:
{
 100d3c8:	b510      	push	{r4, lr}
 100d3ca:	4604      	mov	r4, r0
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
 100d3cc:	4909      	ldr	r1, [pc, #36]	; (100d3f4 <clear_cf_cfg+0x2c>)
 100d3ce:	3001      	adds	r0, #1
 100d3d0:	f01a ff72 	bl	10282b8 <bt_addr_le_copy>
	memset(cfg->data, 0, sizeof(cfg->data));
 100d3d4:	f104 0008 	add.w	r0, r4, #8
 100d3d8:	2201      	movs	r2, #1
 100d3da:	2100      	movs	r1, #0
 100d3dc:	f019 fad5 	bl	102698a <memset>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 100d3e0:	2300      	movs	r3, #0
 100d3e2:	340c      	adds	r4, #12
 100d3e4:	e8d4 2fef 	ldaex	r2, [r4]
 100d3e8:	e8c4 3fe1 	stlex	r1, r3, [r4]
 100d3ec:	2900      	cmp	r1, #0
 100d3ee:	d1f9      	bne.n	100d3e4 <clear_cf_cfg+0x1c>
}
 100d3f0:	bd10      	pop	{r4, pc}
 100d3f2:	bf00      	nop
 100d3f4:	0102cb79 	.word	0x0102cb79

0100d3f8 <cf_set>:
{
 100d3f8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100d3fc:	b08b      	sub	sp, #44	; 0x2c
 100d3fe:	4689      	mov	r9, r1
 100d400:	4616      	mov	r6, r2
 100d402:	4698      	mov	r8, r3
	if (!name) {
 100d404:	4604      	mov	r4, r0
{
 100d406:	af00      	add	r7, sp, #0
	if (!name) {
 100d408:	b988      	cbnz	r0, 100d42e <cf_set+0x36>
		LOG_ERR("Insufficient number of arguments");
 100d40a:	4b42      	ldr	r3, [pc, #264]	; (100d514 <cf_set+0x11c>)
 100d40c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100d410:	627b      	str	r3, [r7, #36]	; 0x24
 100d412:	2302      	movs	r3, #2
 100d414:	4840      	ldr	r0, [pc, #256]	; (100d518 <cf_set+0x120>)
 100d416:	623b      	str	r3, [r7, #32]
 100d418:	f107 0220 	add.w	r2, r7, #32
 100d41c:	f01a ff80 	bl	1028320 <z_log_msg_static_create.constprop.0>
		return -EINVAL;
 100d420:	f06f 0515 	mvn.w	r5, #21
}
 100d424:	4628      	mov	r0, r5
 100d426:	372c      	adds	r7, #44	; 0x2c
 100d428:	46bd      	mov	sp, r7
 100d42a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	err = bt_settings_decode_key(name, &addr);
 100d42e:	f107 0108 	add.w	r1, r7, #8
 100d432:	f019 fb21 	bl	1026a78 <bt_settings_decode_key>
	if (err) {
 100d436:	4605      	mov	r5, r0
 100d438:	b190      	cbz	r0, 100d460 <cf_set+0x68>
		LOG_ERR("Unable to decode address %s", name);
 100d43a:	466d      	mov	r5, sp
 100d43c:	b088      	sub	sp, #32
 100d43e:	466a      	mov	r2, sp
 100d440:	4b36      	ldr	r3, [pc, #216]	; (100d51c <cf_set+0x124>)
 100d442:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 100d446:	e9c2 3405 	strd	r3, r4, [r2, #20]
 100d44a:	f44f 7300 	mov.w	r3, #512	; 0x200
 100d44e:	8393      	strh	r3, [r2, #28]
 100d450:	4b33      	ldr	r3, [pc, #204]	; (100d520 <cf_set+0x128>)
 100d452:	4831      	ldr	r0, [pc, #196]	; (100d518 <cf_set+0x120>)
 100d454:	f842 3f10 	str.w	r3, [r2, #16]!
 100d458:	f01a ff62 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100d45c:	46ad      	mov	sp, r5
		return -EINVAL;
 100d45e:	e7df      	b.n	100d420 <cf_set+0x28>
	settings_name_next(name, &next);
 100d460:	4620      	mov	r0, r4
 100d462:	1d39      	adds	r1, r7, #4
 100d464:	f017 ffae 	bl	10253c4 <settings_name_next>
	if (!next) {
 100d468:	6878      	ldr	r0, [r7, #4]
 100d46a:	b1a0      	cbz	r0, 100d496 <cf_set+0x9e>
		unsigned long next_id = strtoul(next, NULL, 10);
 100d46c:	220a      	movs	r2, #10
 100d46e:	4629      	mov	r1, r5
 100d470:	f019 f9c0 	bl	10267f4 <strtoul>
		if (next_id >= CONFIG_BT_ID_MAX) {
 100d474:	b178      	cbz	r0, 100d496 <cf_set+0x9e>
			LOG_ERR("Invalid local identity %lu", next_id);
 100d476:	466c      	mov	r4, sp
 100d478:	b088      	sub	sp, #32
 100d47a:	466a      	mov	r2, sp
 100d47c:	4b29      	ldr	r3, [pc, #164]	; (100d524 <cf_set+0x12c>)
 100d47e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100d482:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100d486:	2303      	movs	r3, #3
 100d488:	4823      	ldr	r0, [pc, #140]	; (100d518 <cf_set+0x120>)
 100d48a:	f842 3f10 	str.w	r3, [r2, #16]!
 100d48e:	f01a ff47 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100d492:	46a5      	mov	sp, r4
			return -EINVAL;
 100d494:	e7c4      	b.n	100d420 <cf_set+0x28>
	cfg = find_cf_cfg_by_addr(id, &addr);
 100d496:	2000      	movs	r0, #0
 100d498:	f107 0108 	add.w	r1, r7, #8
 100d49c:	f7ff fcde 	bl	100ce5c <find_cf_cfg_by_addr>
	if (!cfg) {
 100d4a0:	4604      	mov	r4, r0
 100d4a2:	b9c0      	cbnz	r0, 100d4d6 <cf_set+0xde>
		cfg = find_cf_cfg(NULL);
 100d4a4:	f7ff fc80 	bl	100cda8 <find_cf_cfg>
		if (!cfg) {
 100d4a8:	4604      	mov	r4, r0
 100d4aa:	b968      	cbnz	r0, 100d4c8 <cf_set+0xd0>
			LOG_ERR("Unable to restore CF: no cfg left");
 100d4ac:	4b1e      	ldr	r3, [pc, #120]	; (100d528 <cf_set+0x130>)
 100d4ae:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100d4b2:	627b      	str	r3, [r7, #36]	; 0x24
 100d4b4:	2302      	movs	r3, #2
 100d4b6:	4818      	ldr	r0, [pc, #96]	; (100d518 <cf_set+0x120>)
 100d4b8:	623b      	str	r3, [r7, #32]
 100d4ba:	f107 0220 	add.w	r2, r7, #32
 100d4be:	f01a ff2f 	bl	1028320 <z_log_msg_static_create.constprop.0>
			return -ENOMEM;
 100d4c2:	f06f 050b 	mvn.w	r5, #11
 100d4c6:	e7ad      	b.n	100d424 <cf_set+0x2c>
		cfg->id = id;
 100d4c8:	2300      	movs	r3, #0
		bt_addr_le_copy(&cfg->peer, &addr);
 100d4ca:	f107 0108 	add.w	r1, r7, #8
		cfg->id = id;
 100d4ce:	f800 3b01 	strb.w	r3, [r0], #1
		bt_addr_le_copy(&cfg->peer, &addr);
 100d4d2:	f01a fef1 	bl	10282b8 <bt_addr_le_copy>
	if (len_rd) {
 100d4d6:	f1b9 0f00 	cmp.w	r9, #0
 100d4da:	d017      	beq.n	100d50c <cf_set+0x114>
		len = read_cb(cb_arg, cfg->data, sizeof(cfg->data));
 100d4dc:	f104 0108 	add.w	r1, r4, #8
 100d4e0:	2201      	movs	r2, #1
 100d4e2:	4640      	mov	r0, r8
 100d4e4:	47b0      	blx	r6
		if (len < 0) {
 100d4e6:	1e04      	subs	r4, r0, #0
 100d4e8:	da9c      	bge.n	100d424 <cf_set+0x2c>
			LOG_ERR("Failed to decode value (err %zd)", len);
 100d4ea:	466d      	mov	r5, sp
 100d4ec:	b088      	sub	sp, #32
 100d4ee:	466a      	mov	r2, sp
 100d4f0:	4b0e      	ldr	r3, [pc, #56]	; (100d52c <cf_set+0x134>)
 100d4f2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100d4f6:	e9c2 3405 	strd	r3, r4, [r2, #20]
 100d4fa:	2303      	movs	r3, #3
 100d4fc:	4806      	ldr	r0, [pc, #24]	; (100d518 <cf_set+0x120>)
 100d4fe:	f842 3f10 	str.w	r3, [r2, #16]!
 100d502:	f01a ff0d 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100d506:	46ad      	mov	sp, r5
			return len;
 100d508:	4625      	mov	r5, r4
 100d50a:	e78b      	b.n	100d424 <cf_set+0x2c>
		clear_cf_cfg(cfg);
 100d50c:	4620      	mov	r0, r4
 100d50e:	f7ff ff5b 	bl	100d3c8 <clear_cf_cfg>
 100d512:	e787      	b.n	100d424 <cf_set+0x2c>
 100d514:	0102cd4a 	.word	0x0102cd4a
 100d518:	0102999c 	.word	0x0102999c
 100d51c:	0102e430 	.word	0x0102e430
 100d520:	01000003 	.word	0x01000003
 100d524:	0102e44c 	.word	0x0102e44c
 100d528:	0102e573 	.word	0x0102e573
 100d52c:	0102e489 	.word	0x0102e489

0100d530 <remove_peer_from_attr>:
#endif /*CONFIG_BT_GATT_CACHING */
#endif /* CONFIG_BT_SETTINGS */

static uint8_t remove_peer_from_attr(const struct bt_gatt_attr *attr,
				     uint16_t handle, void *user_data)
{
 100d530:	b508      	push	{r3, lr}
 100d532:	4613      	mov	r3, r2
	const struct addr_with_id *addr_with_id = user_data;
	struct _bt_gatt_ccc *ccc;
	struct bt_gatt_ccc_cfg *cfg;

	/* Check if attribute is a CCC */
	if (attr->write != bt_gatt_attr_write_ccc) {
 100d534:	6881      	ldr	r1, [r0, #8]
 100d536:	4a07      	ldr	r2, [pc, #28]	; (100d554 <remove_peer_from_attr+0x24>)
 100d538:	4291      	cmp	r1, r2
 100d53a:	d109      	bne.n	100d550 <remove_peer_from_attr+0x20>
	}

	ccc = attr->user_data;

	/* Check if there is a cfg for the peer */
	cfg = ccc_find_cfg(ccc, addr_with_id->addr, addr_with_id->id);
 100d53c:	791a      	ldrb	r2, [r3, #4]
 100d53e:	6819      	ldr	r1, [r3, #0]
 100d540:	68c0      	ldr	r0, [r0, #12]
 100d542:	f01a fe91 	bl	1028268 <ccc_find_cfg>
	if (cfg) {
 100d546:	b118      	cbz	r0, 100d550 <remove_peer_from_attr+0x20>
		memset(cfg, 0, sizeof(*cfg));
 100d548:	220a      	movs	r2, #10
 100d54a:	2100      	movs	r1, #0
 100d54c:	f019 fa1d 	bl	102698a <memset>
	}

	return BT_GATT_ITER_CONTINUE;
}
 100d550:	2001      	movs	r0, #1
 100d552:	bd08      	pop	{r3, pc}
 100d554:	0100d791 	.word	0x0100d791

0100d558 <ccc_save>:
{
 100d558:	b538      	push	{r3, r4, r5, lr}
 100d55a:	4614      	mov	r4, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
 100d55c:	4b0b      	ldr	r3, [pc, #44]	; (100d58c <ccc_save+0x34>)
 100d55e:	6882      	ldr	r2, [r0, #8]
{
 100d560:	460d      	mov	r5, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
 100d562:	429a      	cmp	r2, r3
 100d564:	d10f      	bne.n	100d586 <ccc_save+0x2e>
	cfg = ccc_find_cfg(ccc, save->addr_with_id.addr, save->addr_with_id.id);
 100d566:	7922      	ldrb	r2, [r4, #4]
 100d568:	6821      	ldr	r1, [r4, #0]
 100d56a:	68c0      	ldr	r0, [r0, #12]
 100d56c:	f01a fe7c 	bl	1028268 <ccc_find_cfg>
	if (!cfg) {
 100d570:	b148      	cbz	r0, 100d586 <ccc_save+0x2e>
	save->store[save->count].handle = handle;
 100d572:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 100d576:	eb04 0283 	add.w	r2, r4, r3, lsl #2
 100d57a:	8115      	strh	r5, [r2, #8]
	save->store[save->count].value = cfg->value;
 100d57c:	8901      	ldrh	r1, [r0, #8]
	save->count++;
 100d57e:	3301      	adds	r3, #1
	save->store[save->count].value = cfg->value;
 100d580:	8151      	strh	r1, [r2, #10]
	save->count++;
 100d582:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
}
 100d586:	2001      	movs	r0, #1
 100d588:	bd38      	pop	{r3, r4, r5, pc}
 100d58a:	bf00      	nop
 100d58c:	0100d791 	.word	0x0100d791

0100d590 <sc_commit.part.0>:
	k_work_reschedule(&gatt_sc.work, timeout);
 100d590:	f44f 72a4 	mov.w	r2, #328	; 0x148
 100d594:	2300      	movs	r3, #0
 100d596:	4801      	ldr	r0, [pc, #4]	; (100d59c <sc_commit.part.0+0xc>)
 100d598:	f014 bdd4 	b.w	1022144 <k_work_reschedule>
 100d59c:	210024b0 	.word	0x210024b0

0100d5a0 <sc_commit>:
{
 100d5a0:	b508      	push	{r3, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 100d5a2:	f06f 0102 	mvn.w	r1, #2
 100d5a6:	4806      	ldr	r0, [pc, #24]	; (100d5c0 <sc_commit+0x20>)
 100d5a8:	f01a fe89 	bl	10282be <atomic_and>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
 100d5ac:	4804      	ldr	r0, [pc, #16]	; (100d5c0 <sc_commit+0x20>)
 100d5ae:	f01a fe75 	bl	102829c <atomic_get>
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
 100d5b2:	07c3      	lsls	r3, r0, #31
 100d5b4:	d501      	bpl.n	100d5ba <sc_commit+0x1a>
 100d5b6:	f7ff ffeb 	bl	100d590 <sc_commit.part.0>
}
 100d5ba:	2000      	movs	r0, #0
 100d5bc:	bd08      	pop	{r3, pc}
 100d5be:	bf00      	nop
 100d5c0:	210024e0 	.word	0x210024e0

0100d5c4 <db_changed>:
{
 100d5c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 100d5c6:	f06f 0104 	mvn.w	r1, #4
 100d5ca:	4818      	ldr	r0, [pc, #96]	; (100d62c <db_changed+0x68>)
 100d5cc:	f01a fe77 	bl	10282be <atomic_and>
		bt_long_wq_reschedule(&db_hash.work, DB_HASH_TIMEOUT);
 100d5d0:	f44f 72a4 	mov.w	r2, #328	; 0x148
 100d5d4:	2300      	movs	r3, #0
 100d5d6:	4816      	ldr	r0, [pc, #88]	; (100d630 <db_changed+0x6c>)
 100d5d8:	f7f9 fe8c 	bl	10072f4 <bt_long_wq_reschedule>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
 100d5dc:	2600      	movs	r6, #0
 100d5de:	4c15      	ldr	r4, [pc, #84]	; (100d634 <db_changed+0x70>)
		if (bt_addr_le_eq(&cfg->peer, BT_ADDR_LE_ANY)) {
 100d5e0:	4f15      	ldr	r7, [pc, #84]	; (100d638 <db_changed+0x74>)
 100d5e2:	4639      	mov	r1, r7
 100d5e4:	4620      	mov	r0, r4
 100d5e6:	f01a fe37 	bl	1028258 <bt_addr_le_eq>
 100d5ea:	b9c0      	cbnz	r0, 100d61e <db_changed+0x5a>
		if (CF_ROBUST_CACHING(cfg)) {
 100d5ec:	79e3      	ldrb	r3, [r4, #7]
 100d5ee:	07db      	lsls	r3, r3, #31
 100d5f0:	d515      	bpl.n	100d61e <db_changed+0x5a>
			conn = bt_conn_lookup_addr_le(BT_ID_DEFAULT, &cfg->peer);
 100d5f2:	4621      	mov	r1, r4
 100d5f4:	f7fd f84e 	bl	100a694 <bt_conn_lookup_addr_le>
			if (conn) {
 100d5f8:	4605      	mov	r5, r0
 100d5fa:	b120      	cbz	r0, 100d606 <db_changed+0x42>
				bt_att_clear_out_of_sync_sent(conn);
 100d5fc:	f01a fd7b 	bl	10280f6 <bt_att_clear_out_of_sync_sent>
				bt_conn_unref(conn);
 100d600:	4628      	mov	r0, r5
 100d602:	f7fc fd4b 	bl	100a09c <bt_conn_unref>
			atomic_clear_bit(cfg->flags, CF_DB_HASH_READ);
 100d606:	f104 050b 	add.w	r5, r4, #11
 100d60a:	f06f 0102 	mvn.w	r1, #2
 100d60e:	4628      	mov	r0, r5
 100d610:	f01a fe55 	bl	10282be <atomic_and>
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 100d614:	f06f 0101 	mvn.w	r1, #1
 100d618:	4628      	mov	r0, r5
 100d61a:	f01a fe50 	bl	10282be <atomic_and>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
 100d61e:	3601      	adds	r6, #1
 100d620:	2e0d      	cmp	r6, #13
 100d622:	f104 0410 	add.w	r4, r4, #16
 100d626:	d1dc      	bne.n	100d5e2 <db_changed+0x1e>
}
 100d628:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 100d62a:	bf00      	nop
 100d62c:	210024e0 	.word	0x210024e0
 100d630:	21002438 	.word	0x21002438
 100d634:	210048a5 	.word	0x210048a5
 100d638:	0102cb79 	.word	0x0102cb79

0100d63c <bt_gatt_clear_sc>:
{
 100d63c:	b5b0      	push	{r4, r5, r7, lr}
 100d63e:	b08c      	sub	sp, #48	; 0x30
 100d640:	af02      	add	r7, sp, #8
	cfg = find_sc_cfg(id, (bt_addr_le_t *)addr);
 100d642:	f7ff fbd3 	bl	100cdec <find_sc_cfg>
	if (!cfg) {
 100d646:	4604      	mov	r4, r0
 100d648:	b330      	cbz	r0, 100d698 <bt_gatt_clear_sc+0x5c>
		if (cfg->id) {
 100d64a:	4605      	mov	r5, r0
 100d64c:	f815 2b01 	ldrb.w	r2, [r5], #1
 100d650:	b332      	cbz	r2, 100d6a0 <bt_gatt_clear_sc+0x64>
			u8_to_dec(id_str, sizeof(id_str), cfg->id);
 100d652:	2104      	movs	r1, #4
 100d654:	4638      	mov	r0, r7
 100d656:	f017 f826 	bl	10246a6 <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "sc",
 100d65a:	9700      	str	r7, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "sc",
 100d65c:	1d38      	adds	r0, r7, #4
 100d65e:	462b      	mov	r3, r5
 100d660:	2124      	movs	r1, #36	; 0x24
 100d662:	4a10      	ldr	r2, [pc, #64]	; (100d6a4 <bt_gatt_clear_sc+0x68>)
 100d664:	f7f9 fd8c 	bl	1007180 <bt_settings_encode_key>
		err = settings_delete(key);
 100d668:	1d38      	adds	r0, r7, #4
 100d66a:	f017 fe83 	bl	1025374 <settings_delete>
		if (err) {
 100d66e:	b170      	cbz	r0, 100d68e <bt_gatt_clear_sc+0x52>
			LOG_ERR("failed to delete SC (err %d)", err);
 100d670:	466d      	mov	r5, sp
 100d672:	b088      	sub	sp, #32
 100d674:	aa02      	add	r2, sp, #8
 100d676:	4b0c      	ldr	r3, [pc, #48]	; (100d6a8 <bt_gatt_clear_sc+0x6c>)
 100d678:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100d67c:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100d680:	2303      	movs	r3, #3
 100d682:	480a      	ldr	r0, [pc, #40]	; (100d6ac <bt_gatt_clear_sc+0x70>)
 100d684:	f842 3f10 	str.w	r3, [r2, #16]!
 100d688:	f01a fe4a 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100d68c:	46ad      	mov	sp, r5
	memset(cfg, 0, sizeof(*cfg));
 100d68e:	220c      	movs	r2, #12
 100d690:	2100      	movs	r1, #0
 100d692:	4620      	mov	r0, r4
 100d694:	f019 f979 	bl	102698a <memset>
}
 100d698:	2000      	movs	r0, #0
 100d69a:	3728      	adds	r7, #40	; 0x28
 100d69c:	46bd      	mov	sp, r7
 100d69e:	bdb0      	pop	{r4, r5, r7, pc}
			bt_settings_encode_key(key, sizeof(key), "sc",
 100d6a0:	9200      	str	r2, [sp, #0]
 100d6a2:	e7db      	b.n	100d65c <bt_gatt_clear_sc+0x20>
 100d6a4:	0102e877 	.word	0x0102e877
 100d6a8:	0102e595 	.word	0x0102e595
 100d6ac:	0102999c 	.word	0x0102999c

0100d6b0 <sc_clear>:
{
 100d6b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 100d6b2:	f100 0690 	add.w	r6, r0, #144	; 0x90
{
 100d6b6:	4604      	mov	r4, r0
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 100d6b8:	4631      	mov	r1, r6
 100d6ba:	7a00      	ldrb	r0, [r0, #8]
{
 100d6bc:	af00      	add	r7, sp, #0
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 100d6be:	f019 fb4e 	bl	1026d5e <bt_addr_le_is_bonded>
 100d6c2:	4605      	mov	r5, r0
		err = bt_gatt_clear_sc(conn->id, &conn->le.dst);
 100d6c4:	4631      	mov	r1, r6
 100d6c6:	7a20      	ldrb	r0, [r4, #8]
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 100d6c8:	b19d      	cbz	r5, 100d6f2 <sc_clear+0x42>
		err = bt_gatt_clear_sc(conn->id, &conn->le.dst);
 100d6ca:	f7ff ffb7 	bl	100d63c <bt_gatt_clear_sc>
		if (err) {
 100d6ce:	b170      	cbz	r0, 100d6ee <sc_clear+0x3e>
			LOG_ERR("Failed to clear SC %d", err);
 100d6d0:	466c      	mov	r4, sp
 100d6d2:	b088      	sub	sp, #32
 100d6d4:	466a      	mov	r2, sp
 100d6d6:	4b0b      	ldr	r3, [pc, #44]	; (100d704 <sc_clear+0x54>)
 100d6d8:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100d6dc:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100d6e0:	2303      	movs	r3, #3
 100d6e2:	4809      	ldr	r0, [pc, #36]	; (100d708 <sc_clear+0x58>)
 100d6e4:	f842 3f10 	str.w	r3, [r2, #16]!
 100d6e8:	f01a fe1a 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100d6ec:	46a5      	mov	sp, r4
}
 100d6ee:	46bd      	mov	sp, r7
 100d6f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		cfg = find_sc_cfg(conn->id, &conn->le.dst);
 100d6f2:	f7ff fb7b 	bl	100cdec <find_sc_cfg>
		if (cfg) {
 100d6f6:	2800      	cmp	r0, #0
 100d6f8:	d0f9      	beq.n	100d6ee <sc_clear+0x3e>
	memset(cfg, 0, sizeof(*cfg));
 100d6fa:	220c      	movs	r2, #12
 100d6fc:	4629      	mov	r1, r5
 100d6fe:	f019 f944 	bl	102698a <memset>
}
 100d702:	e7f4      	b.n	100d6ee <sc_clear+0x3e>
 100d704:	0102e5b2 	.word	0x0102e5b2
 100d708:	0102999c 	.word	0x0102999c

0100d70c <sc_indicate>:
{
 100d70c:	b538      	push	{r3, r4, r5, lr}
 100d70e:	4605      	mov	r5, r0
 100d710:	460c      	mov	r4, r1
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
 100d712:	480f      	ldr	r0, [pc, #60]	; (100d750 <sc_indicate+0x44>)
 100d714:	2101      	movs	r1, #1
 100d716:	f01a fdc4 	bl	10282a2 <atomic_or>
	if (!atomic_test_and_set_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
 100d71a:	f010 0f01 	tst.w	r0, #1
 100d71e:	4b0d      	ldr	r3, [pc, #52]	; (100d754 <sc_indicate+0x48>)
 100d720:	d10a      	bne.n	100d738 <sc_indicate+0x2c>
		gatt_sc.start = start;
 100d722:	831d      	strh	r5, [r3, #24]
		*end = new_end;
 100d724:	835c      	strh	r4, [r3, #26]
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
 100d726:	480a      	ldr	r0, [pc, #40]	; (100d750 <sc_indicate+0x44>)
 100d728:	f01a fdb8 	bl	102829c <atomic_get>
	if (atomic_test_bit(gatt_sc.flags, SC_INDICATE_PENDING)) {
 100d72c:	0783      	lsls	r3, r0, #30
 100d72e:	d409      	bmi.n	100d744 <sc_indicate+0x38>
}
 100d730:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 100d734:	f7ff bf2c 	b.w	100d590 <sc_commit.part.0>
	if (new_start >= *start && new_end <= *end) {
 100d738:	8b19      	ldrh	r1, [r3, #24]
 100d73a:	8b5a      	ldrh	r2, [r3, #26]
 100d73c:	42a9      	cmp	r1, r5
 100d73e:	d802      	bhi.n	100d746 <sc_indicate+0x3a>
 100d740:	4294      	cmp	r4, r2
 100d742:	d8ef      	bhi.n	100d724 <sc_indicate+0x18>
}
 100d744:	bd38      	pop	{r3, r4, r5, pc}
	if (*end < new_end) {
 100d746:	4294      	cmp	r4, r2
		*start = new_start;
 100d748:	831d      	strh	r5, [r3, #24]
	if (*end < new_end) {
 100d74a:	d9ec      	bls.n	100d726 <sc_indicate+0x1a>
 100d74c:	e7ea      	b.n	100d724 <sc_indicate+0x18>
 100d74e:	bf00      	nop
 100d750:	210024e0 	.word	0x210024e0
 100d754:	21002490 	.word	0x21002490

0100d758 <read_ppcp>:
{
 100d758:	b513      	push	{r0, r1, r4, lr}
 100d75a:	4610      	mov	r0, r2
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_LATENCY);
 100d75c:	f44f 1228 	mov.w	r2, #2752512	; 0x2a0000
{
 100d760:	f8bd 1010 	ldrh.w	r1, [sp, #16]
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_LATENCY);
 100d764:	4c09      	ldr	r4, [pc, #36]	; (100d78c <read_ppcp+0x34>)
	if (offset > value_len) {
 100d766:	2908      	cmp	r1, #8
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_LATENCY);
 100d768:	e9cd 4200 	strd	r4, r2, [sp]
	if (offset > value_len) {
 100d76c:	d80b      	bhi.n	100d786 <read_ppcp+0x2e>
	len = MIN(buf_len, value_len - offset);
 100d76e:	f1c1 0408 	rsb	r4, r1, #8
 100d772:	429c      	cmp	r4, r3
 100d774:	bfa8      	it	ge
 100d776:	461c      	movge	r4, r3
	memcpy(buf, (uint8_t *)value + offset, len);
 100d778:	4469      	add	r1, sp
 100d77a:	4622      	mov	r2, r4
 100d77c:	f019 f8fa 	bl	1026974 <memcpy>
}
 100d780:	4620      	mov	r0, r4
 100d782:	b002      	add	sp, #8
 100d784:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 100d786:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp,
 100d78a:	e7f9      	b.n	100d780 <read_ppcp+0x28>
 100d78c:	00090006 	.word	0x00090006

0100d790 <bt_gatt_attr_write_ccc>:
{
 100d790:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100d794:	b086      	sub	sp, #24
 100d796:	461f      	mov	r7, r3
 100d798:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
 100d79c:	4606      	mov	r6, r0
 100d79e:	4688      	mov	r8, r1
	struct _bt_gatt_ccc *ccc = attr->user_data;
 100d7a0:	f8d1 900c 	ldr.w	r9, [r1, #12]
	if (offset) {
 100d7a4:	2b00      	cmp	r3, #0
 100d7a6:	d151      	bne.n	100d84c <bt_gatt_attr_write_ccc+0xbc>
	if (!len || len > sizeof(uint16_t)) {
 100d7a8:	1e7b      	subs	r3, r7, #1
 100d7aa:	2b01      	cmp	r3, #1
 100d7ac:	d851      	bhi.n	100d852 <bt_gatt_attr_write_ccc+0xc2>
	if (len < sizeof(uint16_t)) {
 100d7ae:	2f01      	cmp	r7, #1
	cfg = find_ccc_cfg(conn, ccc);
 100d7b0:	4649      	mov	r1, r9
		value = *(uint8_t *)buf;
 100d7b2:	7815      	ldrb	r5, [r2, #0]
 100d7b4:	bf18      	it	ne
 100d7b6:	8815      	ldrhne	r5, [r2, #0]
	cfg = find_ccc_cfg(conn, ccc);
 100d7b8:	f7ff fb34 	bl	100ce24 <find_ccc_cfg>
	if (!cfg) {
 100d7bc:	4604      	mov	r4, r0
 100d7be:	b9e8      	cbnz	r0, 100d7fc <bt_gatt_attr_write_ccc+0x6c>
		if (!value) {
 100d7c0:	b91d      	cbnz	r5, 100d7ca <bt_gatt_attr_write_ccc+0x3a>
			return len;
 100d7c2:	4638      	mov	r0, r7
}
 100d7c4:	b006      	add	sp, #24
 100d7c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		cfg = find_ccc_cfg(NULL, ccc);
 100d7ca:	4649      	mov	r1, r9
 100d7cc:	f7ff fb2a 	bl	100ce24 <find_ccc_cfg>
		if (!cfg) {
 100d7d0:	4604      	mov	r4, r0
 100d7d2:	b960      	cbnz	r0, 100d7ee <bt_gatt_attr_write_ccc+0x5e>
			LOG_WRN("No space to store CCC cfg");
 100d7d4:	4b20      	ldr	r3, [pc, #128]	; (100d858 <bt_gatt_attr_write_ccc+0xc8>)
 100d7d6:	4821      	ldr	r0, [pc, #132]	; (100d85c <bt_gatt_attr_write_ccc+0xcc>)
 100d7d8:	9305      	str	r3, [sp, #20]
 100d7da:	2302      	movs	r3, #2
 100d7dc:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100d7e0:	aa04      	add	r2, sp, #16
 100d7e2:	9304      	str	r3, [sp, #16]
 100d7e4:	f01a fd9c 	bl	1028320 <z_log_msg_static_create.constprop.0>
			return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
 100d7e8:	f06f 0010 	mvn.w	r0, #16
 100d7ec:	e7ea      	b.n	100d7c4 <bt_gatt_attr_write_ccc+0x34>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
 100d7ee:	f106 0190 	add.w	r1, r6, #144	; 0x90
 100d7f2:	3001      	adds	r0, #1
 100d7f4:	f01a fd60 	bl	10282b8 <bt_addr_le_copy>
		cfg->id = conn->id;
 100d7f8:	7a33      	ldrb	r3, [r6, #8]
 100d7fa:	7023      	strb	r3, [r4, #0]
	if (ccc->cfg_write) {
 100d7fc:	f8d9 3058 	ldr.w	r3, [r9, #88]	; 0x58
 100d800:	b9c3      	cbnz	r3, 100d834 <bt_gatt_attr_write_ccc+0xa4>
	value_changed = cfg->value != value;
 100d802:	f8b4 a008 	ldrh.w	sl, [r4, #8]
	cfg->value = value;
 100d806:	8125      	strh	r5, [r4, #8]
	if (cfg->value != ccc->value) {
 100d808:	f8b9 3050 	ldrh.w	r3, [r9, #80]	; 0x50
 100d80c:	42ab      	cmp	r3, r5
 100d80e:	d003      	beq.n	100d818 <bt_gatt_attr_write_ccc+0x88>
		gatt_ccc_changed(attr, ccc);
 100d810:	4649      	mov	r1, r9
 100d812:	4640      	mov	r0, r8
 100d814:	f01a fc9b 	bl	102814e <gatt_ccc_changed>
	if (value_changed) {
 100d818:	45aa      	cmp	sl, r5
 100d81a:	d002      	beq.n	100d822 <bt_gatt_attr_write_ccc+0x92>
		gatt_ccc_conn_enqueue(conn);
 100d81c:	4630      	mov	r0, r6
 100d81e:	f7ff fbbd 	bl	100cf9c <gatt_ccc_conn_enqueue>
	if (!value) {
 100d822:	2d00      	cmp	r5, #0
 100d824:	d1cd      	bne.n	100d7c2 <bt_gatt_attr_write_ccc+0x32>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
 100d826:	490e      	ldr	r1, [pc, #56]	; (100d860 <bt_gatt_attr_write_ccc+0xd0>)
 100d828:	1c60      	adds	r0, r4, #1
 100d82a:	f01a fd45 	bl	10282b8 <bt_addr_le_copy>
	cfg->id = 0U;
 100d82e:	7025      	strb	r5, [r4, #0]
	cfg->value = 0U;
 100d830:	8125      	strh	r5, [r4, #8]
}
 100d832:	e7c6      	b.n	100d7c2 <bt_gatt_attr_write_ccc+0x32>
		ssize_t write = ccc->cfg_write(conn, attr, value);
 100d834:	462a      	mov	r2, r5
 100d836:	4641      	mov	r1, r8
 100d838:	4630      	mov	r0, r6
 100d83a:	4798      	blx	r3
		if (write < 0) {
 100d83c:	2800      	cmp	r0, #0
 100d83e:	dbc1      	blt.n	100d7c4 <bt_gatt_attr_write_ccc+0x34>
		if (write != sizeof(value) && write != 1) {
 100d840:	3801      	subs	r0, #1
 100d842:	2801      	cmp	r0, #1
 100d844:	d9dd      	bls.n	100d802 <bt_gatt_attr_write_ccc+0x72>
			return BT_GATT_ERR(BT_ATT_ERR_UNLIKELY);
 100d846:	f06f 000d 	mvn.w	r0, #13
 100d84a:	e7bb      	b.n	100d7c4 <bt_gatt_attr_write_ccc+0x34>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 100d84c:	f06f 0006 	mvn.w	r0, #6
 100d850:	e7b8      	b.n	100d7c4 <bt_gatt_attr_write_ccc+0x34>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 100d852:	f06f 000c 	mvn.w	r0, #12
 100d856:	e7b5      	b.n	100d7c4 <bt_gatt_attr_write_ccc+0x34>
 100d858:	0102e5c8 	.word	0x0102e5c8
 100d85c:	0102999c 	.word	0x0102999c
 100d860:	0102cb79 	.word	0x0102cb79

0100d864 <disconnected_cb>:
{
 100d864:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100d868:	4616      	mov	r6, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
 100d86a:	4b29      	ldr	r3, [pc, #164]	; (100d910 <disconnected_cb+0xac>)
 100d86c:	6882      	ldr	r2, [r0, #8]
{
 100d86e:	4607      	mov	r7, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
 100d870:	429a      	cmp	r2, r3
 100d872:	d130      	bne.n	100d8d6 <disconnected_cb+0x72>
	ccc = attr->user_data;
 100d874:	68c5      	ldr	r5, [r0, #12]
	if (!ccc->value) {
 100d876:	f8b5 3050 	ldrh.w	r3, [r5, #80]	; 0x50
 100d87a:	b363      	cbz	r3, 100d8d6 <disconnected_cb+0x72>
	value_used = false;
 100d87c:	f04f 0800 	mov.w	r8, #0
				if (ccc == &sc_ccc) {
 100d880:	f8df b090 	ldr.w	fp, [pc, #144]	; 100d914 <disconnected_cb+0xb0>
 100d884:	1c6c      	adds	r4, r5, #1
 100d886:	f105 0a51 	add.w	sl, r5, #81	; 0x51
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 100d88a:	f106 0990 	add.w	r9, r6, #144	; 0x90
		if (!cfg->value) {
 100d88e:	f8b4 3007 	ldrh.w	r3, [r4, #7]
 100d892:	b19b      	cbz	r3, 100d8bc <disconnected_cb+0x58>
		if (!bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
 100d894:	4622      	mov	r2, r4
 100d896:	4630      	mov	r0, r6
 100d898:	f814 1c01 	ldrb.w	r1, [r4, #-1]
 100d89c:	f019 fcf8 	bl	1027290 <bt_conn_is_peer_addr_le>
 100d8a0:	b9e0      	cbnz	r0, 100d8dc <disconnected_cb+0x78>
			tmp = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
 100d8a2:	4621      	mov	r1, r4
 100d8a4:	f814 0c01 	ldrb.w	r0, [r4, #-1]
 100d8a8:	f7fc fef4 	bl	100a694 <bt_conn_lookup_addr_le>
			if (tmp) {
 100d8ac:	b130      	cbz	r0, 100d8bc <disconnected_cb+0x58>
				if (tmp->state == BT_CONN_CONNECTED) {
 100d8ae:	7b43      	ldrb	r3, [r0, #13]
					value_used = true;
 100d8b0:	2b07      	cmp	r3, #7
 100d8b2:	bf08      	it	eq
 100d8b4:	f04f 0801 	moveq.w	r8, #1
				bt_conn_unref(tmp);
 100d8b8:	f7fc fbf0 	bl	100a09c <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
 100d8bc:	340a      	adds	r4, #10
 100d8be:	4554      	cmp	r4, sl
 100d8c0:	d1e5      	bne.n	100d88e <disconnected_cb+0x2a>
	if (!value_used) {
 100d8c2:	f1b8 0f00 	cmp.w	r8, #0
 100d8c6:	d106      	bne.n	100d8d6 <disconnected_cb+0x72>
		if (ccc->cfg_changed) {
 100d8c8:	6d6b      	ldr	r3, [r5, #84]	; 0x54
		ccc->value = 0U;
 100d8ca:	f8a5 8050 	strh.w	r8, [r5, #80]	; 0x50
		if (ccc->cfg_changed) {
 100d8ce:	b113      	cbz	r3, 100d8d6 <disconnected_cb+0x72>
			ccc->cfg_changed(attr, ccc->value);
 100d8d0:	4641      	mov	r1, r8
 100d8d2:	4638      	mov	r0, r7
 100d8d4:	4798      	blx	r3
}
 100d8d6:	2001      	movs	r0, #1
 100d8d8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 100d8dc:	4649      	mov	r1, r9
 100d8de:	7a30      	ldrb	r0, [r6, #8]
 100d8e0:	f019 fa3d 	bl	1026d5e <bt_addr_le_is_bonded>
 100d8e4:	b970      	cbnz	r0, 100d904 <disconnected_cb+0xa0>
				if (ccc == &sc_ccc) {
 100d8e6:	455d      	cmp	r5, fp
 100d8e8:	d102      	bne.n	100d8f0 <disconnected_cb+0x8c>
					sc_clear(conn);
 100d8ea:	4630      	mov	r0, r6
 100d8ec:	f7ff fee0 	bl	100d6b0 <sc_clear>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
 100d8f0:	4620      	mov	r0, r4
 100d8f2:	4909      	ldr	r1, [pc, #36]	; (100d918 <disconnected_cb+0xb4>)
 100d8f4:	f01a fce0 	bl	10282b8 <bt_addr_le_copy>
	cfg->id = 0U;
 100d8f8:	2300      	movs	r3, #0
 100d8fa:	f804 3c01 	strb.w	r3, [r4, #-1]
	cfg->value = 0U;
 100d8fe:	f8a4 3007 	strh.w	r3, [r4, #7]
}
 100d902:	e7db      	b.n	100d8bc <disconnected_cb+0x58>
				bt_addr_le_copy(&cfg->peer, &conn->le.dst);
 100d904:	4649      	mov	r1, r9
 100d906:	4620      	mov	r0, r4
 100d908:	f01a fcd6 	bl	10282b8 <bt_addr_le_copy>
 100d90c:	e7d6      	b.n	100d8bc <disconnected_cb+0x58>
 100d90e:	bf00      	nop
 100d910:	0100d791 	.word	0x0100d791
 100d914:	21000440 	.word	0x21000440
 100d918:	0102cb79 	.word	0x0102cb79

0100d91c <sc_indicate_rsp>:
{
 100d91c:	b510      	push	{r4, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 100d91e:	f06f 0102 	mvn.w	r1, #2
 100d922:	4604      	mov	r4, r0
 100d924:	480f      	ldr	r0, [pc, #60]	; (100d964 <sc_indicate_rsp+0x48>)
 100d926:	f01a fcca 	bl	10282be <atomic_and>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
 100d92a:	480e      	ldr	r0, [pc, #56]	; (100d964 <sc_indicate_rsp+0x48>)
 100d92c:	f01a fcb6 	bl	102829c <atomic_get>
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
 100d930:	07c2      	lsls	r2, r0, #31
 100d932:	d504      	bpl.n	100d93e <sc_indicate_rsp+0x22>
	k_work_reschedule(&gatt_sc.work, timeout);
 100d934:	2200      	movs	r2, #0
 100d936:	2300      	movs	r3, #0
 100d938:	480b      	ldr	r0, [pc, #44]	; (100d968 <sc_indicate_rsp+0x4c>)
 100d93a:	f014 fc03 	bl	1022144 <k_work_reschedule>
	if (bt_att_fixed_chan_only(conn)) {
 100d93e:	4620      	mov	r0, r4
 100d940:	f01a fbd7 	bl	10280f2 <bt_att_fixed_chan_only>
 100d944:	b160      	cbz	r0, 100d960 <sc_indicate_rsp+0x44>
		cfg = find_cf_cfg(conn);
 100d946:	4620      	mov	r0, r4
 100d948:	f7ff fa2e 	bl	100cda8 <find_cf_cfg>
		if (cfg && CF_ROBUST_CACHING(cfg)) {
 100d94c:	b140      	cbz	r0, 100d960 <sc_indicate_rsp+0x44>
 100d94e:	7a03      	ldrb	r3, [r0, #8]
 100d950:	07db      	lsls	r3, r3, #31
 100d952:	d505      	bpl.n	100d960 <sc_indicate_rsp+0x44>
}
 100d954:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
 100d958:	2101      	movs	r1, #1
 100d95a:	300c      	adds	r0, #12
 100d95c:	f01a bca1 	b.w	10282a2 <atomic_or>
 100d960:	bd10      	pop	{r4, pc}
 100d962:	bf00      	nop
 100d964:	210024e0 	.word	0x210024e0
 100d968:	210024b0 	.word	0x210024b0

0100d96c <bt_gatt_init>:
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 100d96c:	2201      	movs	r2, #1
{
 100d96e:	b508      	push	{r3, lr}
 100d970:	4b14      	ldr	r3, [pc, #80]	; (100d9c4 <bt_gatt_init+0x58>)
 100d972:	e8d3 1fef 	ldaex	r1, [r3]
 100d976:	2900      	cmp	r1, #0
 100d978:	d103      	bne.n	100d982 <bt_gatt_init+0x16>
 100d97a:	e8c3 2fe0 	stlex	r0, r2, [r3]
 100d97e:	2800      	cmp	r0, #0
 100d980:	d1f7      	bne.n	100d972 <bt_gatt_init+0x6>
	if (!atomic_cas(&init, 0, 1)) {
 100d982:	d11d      	bne.n	100d9c0 <bt_gatt_init+0x54>
	bt_gatt_service_init();
 100d984:	f7ff facc 	bl	100cf20 <bt_gatt_service_init>
	list->head = NULL;
 100d988:	2200      	movs	r2, #0
 100d98a:	4b0f      	ldr	r3, [pc, #60]	; (100d9c8 <bt_gatt_init+0x5c>)
	k_work_init_delayable(&db_hash.work, db_hash_process);
 100d98c:	490f      	ldr	r1, [pc, #60]	; (100d9cc <bt_gatt_init+0x60>)
 100d98e:	4810      	ldr	r0, [pc, #64]	; (100d9d0 <bt_gatt_init+0x64>)
	list->tail = NULL;
 100d990:	e9c3 2200 	strd	r2, r2, [r3]
 100d994:	f014 faba 	bl	1021f0c <k_work_init_delayable>
		bt_long_wq_schedule(&db_hash.work, DB_HASH_TIMEOUT);
 100d998:	2300      	movs	r3, #0
 100d99a:	f44f 72a4 	mov.w	r2, #328	; 0x148
 100d99e:	480c      	ldr	r0, [pc, #48]	; (100d9d0 <bt_gatt_init+0x64>)
 100d9a0:	f7f9 fca2 	bl	10072e8 <bt_long_wq_schedule>
	k_work_init_delayable(&gatt_sc.work, sc_process);
 100d9a4:	490b      	ldr	r1, [pc, #44]	; (100d9d4 <bt_gatt_init+0x68>)
 100d9a6:	480c      	ldr	r0, [pc, #48]	; (100d9d8 <bt_gatt_init+0x6c>)
 100d9a8:	f014 fab0 	bl	1021f0c <k_work_init_delayable>
 100d9ac:	2102      	movs	r1, #2
 100d9ae:	480b      	ldr	r0, [pc, #44]	; (100d9dc <bt_gatt_init+0x70>)
 100d9b0:	f01a fc77 	bl	10282a2 <atomic_or>
}
 100d9b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	k_work_init_delayable(&gatt_ccc_store.work, ccc_delayed_store);
 100d9b8:	4909      	ldr	r1, [pc, #36]	; (100d9e0 <bt_gatt_init+0x74>)
 100d9ba:	480a      	ldr	r0, [pc, #40]	; (100d9e4 <bt_gatt_init+0x78>)
 100d9bc:	f014 baa6 	b.w	1021f0c <k_work_init_delayable>
}
 100d9c0:	bd08      	pop	{r3, pc}
 100d9c2:	bf00      	nop
 100d9c4:	21004978 	.word	0x21004978
 100d9c8:	21004984 	.word	0x21004984
 100d9cc:	0100dca9 	.word	0x0100dca9
 100d9d0:	21002438 	.word	0x21002438
 100d9d4:	0100e469 	.word	0x0100e469
 100d9d8:	210024b0 	.word	0x210024b0
 100d9dc:	210024e0 	.word	0x210024e0
 100d9e0:	01028669 	.word	0x01028669
 100d9e4:	210023e8 	.word	0x210023e8

0100d9e8 <bt_gatt_attr_get_handle>:
	if (!attr) {
 100d9e8:	4603      	mov	r3, r0
{
 100d9ea:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!attr) {
 100d9ee:	b398      	cbz	r0, 100da58 <bt_gatt_attr_get_handle+0x70>
	if (attr->handle) {
 100d9f0:	8a00      	ldrh	r0, [r0, #16]
 100d9f2:	bb88      	cbnz	r0, 100da58 <bt_gatt_attr_get_handle+0x70>
	uint16_t handle = 1;
 100d9f4:	2401      	movs	r4, #1
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
 100d9f6:	f04f 0c14 	mov.w	ip, #20
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
 100d9fa:	4919      	ldr	r1, [pc, #100]	; (100da60 <bt_gatt_attr_get_handle+0x78>)
 100d9fc:	f8df e064 	ldr.w	lr, [pc, #100]	; 100da64 <bt_gatt_attr_get_handle+0x7c>
 100da00:	4571      	cmp	r1, lr
 100da02:	d928      	bls.n	100da56 <bt_gatt_attr_get_handle+0x6e>
 100da04:	4918      	ldr	r1, [pc, #96]	; (100da68 <bt_gatt_attr_get_handle+0x80>)
 100da06:	f240 635d 	movw	r3, #1629	; 0x65d
 100da0a:	4a18      	ldr	r2, [pc, #96]	; (100da6c <bt_gatt_attr_get_handle+0x84>)
 100da0c:	4818      	ldr	r0, [pc, #96]	; (100da70 <bt_gatt_attr_get_handle+0x88>)
 100da0e:	f017 f8e2 	bl	1024bd6 <assert_print>
 100da12:	4818      	ldr	r0, [pc, #96]	; (100da74 <bt_gatt_attr_get_handle+0x8c>)
 100da14:	f017 f8df 	bl	1024bd6 <assert_print>
 100da18:	f240 615d 	movw	r1, #1629	; 0x65d
 100da1c:	4813      	ldr	r0, [pc, #76]	; (100da6c <bt_gatt_attr_get_handle+0x84>)
 100da1e:	f017 f8d3 	bl	1024bc8 <assert_post_action>
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
 100da22:	e9d1 7600 	ldrd	r7, r6, [r1]
		if ((attr < &static_svc->attrs[0]) ||
 100da26:	42bb      	cmp	r3, r7
 100da28:	d304      	bcc.n	100da34 <bt_gatt_attr_get_handle+0x4c>
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
 100da2a:	fb0c 7206 	mla	r2, ip, r6, r7
 100da2e:	3a14      	subs	r2, #20
		if ((attr < &static_svc->attrs[0]) ||
 100da30:	4293      	cmp	r3, r2
 100da32:	d90e      	bls.n	100da52 <bt_gatt_attr_get_handle+0x6a>
			handle += static_svc->attr_count;
 100da34:	4434      	add	r4, r6
 100da36:	b2a2      	uxth	r2, r4
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
 100da38:	4614      	mov	r4, r2
 100da3a:	3108      	adds	r1, #8
 100da3c:	e7e0      	b.n	100da00 <bt_gatt_attr_get_handle+0x18>
			if (attr == &static_svc->attrs[i]) {
 100da3e:	fb0c 7805 	mla	r8, ip, r5, r7
 100da42:	4543      	cmp	r3, r8
 100da44:	d00a      	beq.n	100da5c <bt_gatt_attr_get_handle+0x74>
		for (size_t i = 0; i < static_svc->attr_count; i++, handle++) {
 100da46:	3501      	adds	r5, #1
 100da48:	1962      	adds	r2, r4, r5
 100da4a:	42b5      	cmp	r5, r6
 100da4c:	b292      	uxth	r2, r2
 100da4e:	d1f6      	bne.n	100da3e <bt_gatt_attr_get_handle+0x56>
 100da50:	e7f2      	b.n	100da38 <bt_gatt_attr_get_handle+0x50>
 100da52:	2500      	movs	r5, #0
 100da54:	e7f8      	b.n	100da48 <bt_gatt_attr_get_handle+0x60>
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
 100da56:	d3e4      	bcc.n	100da22 <bt_gatt_attr_get_handle+0x3a>
}
 100da58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100da5c:	4610      	mov	r0, r2
 100da5e:	e7fb      	b.n	100da58 <bt_gatt_attr_get_handle+0x70>
 100da60:	0102992c 	.word	0x0102992c
 100da64:	01029944 	.word	0x01029944
 100da68:	0102e5e2 	.word	0x0102e5e2
 100da6c:	0102e3f4 	.word	0x0102e3f4
 100da70:	0102b695 	.word	0x0102b695
 100da74:	0102bf04 	.word	0x0102bf04

0100da78 <bt_gatt_foreach_attr_type>:
{
 100da78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100da7c:	b089      	sub	sp, #36	; 0x24
 100da7e:	4699      	mov	r9, r3
	if (!num_matches) {
 100da80:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
{
 100da84:	4604      	mov	r4, r0
 100da86:	460f      	mov	r7, r1
 100da88:	4690      	mov	r8, r2
	if (!num_matches) {
 100da8a:	b91b      	cbnz	r3, 100da94 <bt_gatt_foreach_attr_type+0x1c>
		num_matches = UINT16_MAX;
 100da8c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 100da90:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
	if (start_handle <= last_static_handle) {
 100da94:	4b39      	ldr	r3, [pc, #228]	; (100db7c <bt_gatt_foreach_attr_type+0x104>)
 100da96:	881b      	ldrh	r3, [r3, #0]
 100da98:	42a3      	cmp	r3, r4
 100da9a:	d226      	bcs.n	100daea <bt_gatt_foreach_attr_type+0x72>
	foreach_attr_type_dyndb(start_handle, end_handle, uuid, attr_data,
 100da9c:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
 100daa0:	f8ad 301e 	strh.w	r3, [sp, #30]
	return list->head;
 100daa4:	4b36      	ldr	r3, [pc, #216]	; (100db80 <bt_gatt_foreach_attr_type+0x108>)
 100daa6:	681d      	ldr	r5, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&db, svc, node) {
 100daa8:	2d00      	cmp	r5, #0
 100daaa:	d13e      	bne.n	100db2a <bt_gatt_foreach_attr_type+0xb2>
}
 100daac:	b009      	add	sp, #36	; 0x24
 100daae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (gatt_foreach_iter(&static_svc->attrs[i],
 100dab2:	9b14      	ldr	r3, [sp, #80]	; 0x50
 100dab4:	6828      	ldr	r0, [r5, #0]
 100dab6:	9304      	str	r3, [sp, #16]
 100dab8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 100daba:	4622      	mov	r2, r4
 100dabc:	9303      	str	r3, [sp, #12]
 100dabe:	ab12      	add	r3, sp, #72	; 0x48
 100dac0:	e9cd 9301 	strd	r9, r3, [sp, #4]
 100dac4:	fb0b 0006 	mla	r0, fp, r6, r0
 100dac8:	463b      	mov	r3, r7
 100daca:	f8cd 8000 	str.w	r8, [sp]
 100dace:	f01a fc01 	bl	10282d4 <gatt_foreach_iter>
 100dad2:	2800      	cmp	r0, #0
 100dad4:	d0ea      	beq.n	100daac <bt_gatt_foreach_attr_type+0x34>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
 100dad6:	3601      	adds	r6, #1
 100dad8:	686b      	ldr	r3, [r5, #4]
 100dada:	eb0a 0106 	add.w	r1, sl, r6
 100dade:	42b3      	cmp	r3, r6
 100dae0:	b289      	uxth	r1, r1
 100dae2:	d8e6      	bhi.n	100dab2 <bt_gatt_foreach_attr_type+0x3a>
 100dae4:	e00d      	b.n	100db02 <bt_gatt_foreach_attr_type+0x8a>
 100dae6:	2600      	movs	r6, #0
 100dae8:	e7f6      	b.n	100dad8 <bt_gatt_foreach_attr_type+0x60>
		uint16_t handle = 1;
 100daea:	f04f 0a01 	mov.w	sl, #1
				if (gatt_foreach_iter(&static_svc->attrs[i],
 100daee:	f04f 0b14 	mov.w	fp, #20
		STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
 100daf2:	4d24      	ldr	r5, [pc, #144]	; (100db84 <bt_gatt_foreach_attr_type+0x10c>)
 100daf4:	e007      	b.n	100db06 <bt_gatt_foreach_attr_type+0x8e>
 100daf6:	d2d1      	bcs.n	100da9c <bt_gatt_foreach_attr_type+0x24>
			if (handle + static_svc->attr_count < start_handle) {
 100daf8:	6869      	ldr	r1, [r5, #4]
 100dafa:	4451      	add	r1, sl
 100dafc:	42a1      	cmp	r1, r4
 100dafe:	d2f2      	bcs.n	100dae6 <bt_gatt_foreach_attr_type+0x6e>
				handle += static_svc->attr_count;
 100db00:	b289      	uxth	r1, r1
		STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
 100db02:	468a      	mov	sl, r1
 100db04:	3508      	adds	r5, #8
 100db06:	4b20      	ldr	r3, [pc, #128]	; (100db88 <bt_gatt_foreach_attr_type+0x110>)
 100db08:	429d      	cmp	r5, r3
 100db0a:	d9f4      	bls.n	100daf6 <bt_gatt_foreach_attr_type+0x7e>
 100db0c:	491f      	ldr	r1, [pc, #124]	; (100db8c <bt_gatt_foreach_attr_type+0x114>)
 100db0e:	f240 7321 	movw	r3, #1825	; 0x721
 100db12:	4a1f      	ldr	r2, [pc, #124]	; (100db90 <bt_gatt_foreach_attr_type+0x118>)
 100db14:	481f      	ldr	r0, [pc, #124]	; (100db94 <bt_gatt_foreach_attr_type+0x11c>)
 100db16:	f017 f85e 	bl	1024bd6 <assert_print>
 100db1a:	481f      	ldr	r0, [pc, #124]	; (100db98 <bt_gatt_foreach_attr_type+0x120>)
 100db1c:	f017 f85b 	bl	1024bd6 <assert_print>
 100db20:	f240 7121 	movw	r1, #1825	; 0x721
 100db24:	481a      	ldr	r0, [pc, #104]	; (100db90 <bt_gatt_foreach_attr_type+0x118>)
 100db26:	f017 f84f 	bl	1024bc8 <assert_post_action>
			struct bt_gatt_attr *attr = &svc->attrs[i];
 100db2a:	f04f 0a14 	mov.w	sl, #20
	SYS_SLIST_FOR_EACH_CONTAINER(&db, svc, node) {
 100db2e:	3d08      	subs	r5, #8
			if (gatt_foreach_iter(attr, attr->handle,
 100db30:	f10d 0b1e 	add.w	fp, sp, #30
	return node->next;
 100db34:	68ae      	ldr	r6, [r5, #8]
		next = SYS_SLIST_PEEK_NEXT_CONTAINER(svc, node);
 100db36:	b9be      	cbnz	r6, 100db68 <bt_gatt_foreach_attr_type+0xf0>
		for (i = 0; i < svc->attr_count; i++) {
 100db38:	686b      	ldr	r3, [r5, #4]
 100db3a:	429e      	cmp	r6, r3
 100db3c:	d219      	bcs.n	100db72 <bt_gatt_foreach_attr_type+0xfa>
			struct bt_gatt_attr *attr = &svc->attrs[i];
 100db3e:	6828      	ldr	r0, [r5, #0]
			if (gatt_foreach_iter(attr, attr->handle,
 100db40:	9b14      	ldr	r3, [sp, #80]	; 0x50
			struct bt_gatt_attr *attr = &svc->attrs[i];
 100db42:	fb0a 0006 	mla	r0, sl, r6, r0
			if (gatt_foreach_iter(attr, attr->handle,
 100db46:	8a01      	ldrh	r1, [r0, #16]
 100db48:	9304      	str	r3, [sp, #16]
 100db4a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 100db4c:	4622      	mov	r2, r4
 100db4e:	e9cd b302 	strd	fp, r3, [sp, #8]
 100db52:	e9cd 8900 	strd	r8, r9, [sp]
 100db56:	463b      	mov	r3, r7
 100db58:	f01a fbbc 	bl	10282d4 <gatt_foreach_iter>
 100db5c:	2800      	cmp	r0, #0
 100db5e:	d0a5      	beq.n	100daac <bt_gatt_foreach_attr_type+0x34>
		for (i = 0; i < svc->attr_count; i++) {
 100db60:	3601      	adds	r6, #1
 100db62:	e7e9      	b.n	100db38 <bt_gatt_foreach_attr_type+0xc0>
 100db64:	2600      	movs	r6, #0
 100db66:	e7e7      	b.n	100db38 <bt_gatt_foreach_attr_type+0xc0>
			if (next->attrs[0].handle <= start_handle) {
 100db68:	f856 3c08 	ldr.w	r3, [r6, #-8]
 100db6c:	8a1b      	ldrh	r3, [r3, #16]
 100db6e:	42a3      	cmp	r3, r4
 100db70:	d8f8      	bhi.n	100db64 <bt_gatt_foreach_attr_type+0xec>
 100db72:	68ad      	ldr	r5, [r5, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&db, svc, node) {
 100db74:	2d00      	cmp	r5, #0
 100db76:	d099      	beq.n	100daac <bt_gatt_foreach_attr_type+0x34>
 100db78:	3d08      	subs	r5, #8
 100db7a:	e7db      	b.n	100db34 <bt_gatt_foreach_attr_type+0xbc>
 100db7c:	210081d0 	.word	0x210081d0
 100db80:	2100497c 	.word	0x2100497c
 100db84:	0102992c 	.word	0x0102992c
 100db88:	01029944 	.word	0x01029944
 100db8c:	0102e5e2 	.word	0x0102e5e2
 100db90:	0102e3f4 	.word	0x0102e3f4
 100db94:	0102b695 	.word	0x0102b695
 100db98:	0102bf04 	.word	0x0102bf04

0100db9c <db_hash_gen>:
{
 100db9c:	b530      	push	{r4, r5, lr}
	uint8_t key[16] = {};
 100db9e:	2400      	movs	r4, #0
{
 100dba0:	b0cf      	sub	sp, #316	; 0x13c
 100dba2:	4605      	mov	r5, r0
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
 100dba4:	4669      	mov	r1, sp
 100dba6:	aa22      	add	r2, sp, #136	; 0x88
 100dba8:	a80a      	add	r0, sp, #40	; 0x28
	uint8_t key[16] = {};
 100dbaa:	e9cd 4400 	strd	r4, r4, [sp]
 100dbae:	e9cd 4402 	strd	r4, r4, [sp, #8]
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
 100dbb2:	f018 fd15 	bl	10265e0 <tc_cmac_setup>
 100dbb6:	b958      	cbnz	r0, 100dbd0 <db_hash_gen+0x34>
		LOG_ERR("Unable to setup AES CMAC");
 100dbb8:	4b16      	ldr	r3, [pc, #88]	; (100dc14 <db_hash_gen+0x78>)
		LOG_ERR("Unable to calculate hash");
 100dbba:	9309      	str	r3, [sp, #36]	; 0x24
 100dbbc:	2302      	movs	r3, #2
 100dbbe:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100dbc2:	4815      	ldr	r0, [pc, #84]	; (100dc18 <db_hash_gen+0x7c>)
 100dbc4:	aa08      	add	r2, sp, #32
 100dbc6:	9308      	str	r3, [sp, #32]
 100dbc8:	f01a fbaa 	bl	1028320 <z_log_msg_static_create.constprop.0>
}
 100dbcc:	b04f      	add	sp, #316	; 0x13c
 100dbce:	bd30      	pop	{r4, r5, pc}
	bt_gatt_foreach_attr(0x0001, 0xffff, gen_hash_m, &state);
 100dbd0:	f64f 71ff 	movw	r1, #65535	; 0xffff
 100dbd4:	2001      	movs	r0, #1
 100dbd6:	4a11      	ldr	r2, [pc, #68]	; (100dc1c <db_hash_gen+0x80>)
 100dbd8:	ab0a      	add	r3, sp, #40	; 0x28
 100dbda:	f01a fcd0 	bl	102857e <bt_gatt_foreach_attr>
	if (tc_cmac_final(db_hash.hash, &state.state) == TC_CRYPTO_FAIL) {
 100dbde:	4810      	ldr	r0, [pc, #64]	; (100dc20 <db_hash_gen+0x84>)
 100dbe0:	a90a      	add	r1, sp, #40	; 0x28
 100dbe2:	f018 fd92 	bl	102670a <tc_cmac_final>
 100dbe6:	b908      	cbnz	r0, 100dbec <db_hash_gen+0x50>
		LOG_ERR("Unable to calculate hash");
 100dbe8:	4b0e      	ldr	r3, [pc, #56]	; (100dc24 <db_hash_gen+0x88>)
 100dbea:	e7e6      	b.n	100dbba <db_hash_gen+0x1e>
 100dbec:	4b0c      	ldr	r3, [pc, #48]	; (100dc20 <db_hash_gen+0x84>)
 100dbee:	f103 0210 	add.w	r2, r3, #16
static inline void sys_mem_swap(void *buf, size_t length)
{
	size_t i;

	for (i = 0; i < (length/2); i++) {
		uint8_t tmp = ((uint8_t *)buf)[i];
 100dbf2:	7819      	ldrb	r1, [r3, #0]

		((uint8_t *)buf)[i] = ((uint8_t *)buf)[length - 1 - i];
 100dbf4:	f812 0d01 	ldrb.w	r0, [r2, #-1]!
	for (i = 0; i < (length/2); i++) {
 100dbf8:	3401      	adds	r4, #1
 100dbfa:	2c08      	cmp	r4, #8
		((uint8_t *)buf)[i] = ((uint8_t *)buf)[length - 1 - i];
 100dbfc:	f803 0b01 	strb.w	r0, [r3], #1
		((uint8_t *)buf)[length - 1 - i] = tmp;
 100dc00:	7011      	strb	r1, [r2, #0]
	for (i = 0; i < (length/2); i++) {
 100dc02:	d1f6      	bne.n	100dbf2 <db_hash_gen+0x56>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) && store) {
 100dc04:	b10d      	cbz	r5, 100dc0a <db_hash_gen+0x6e>
		db_hash_store();
 100dc06:	f7ff fb99 	bl	100d33c <db_hash_store>
 100dc0a:	2104      	movs	r1, #4
 100dc0c:	4806      	ldr	r0, [pc, #24]	; (100dc28 <db_hash_gen+0x8c>)
 100dc0e:	f01a fb48 	bl	10282a2 <atomic_or>
 100dc12:	e7db      	b.n	100dbcc <db_hash_gen+0x30>
 100dc14:	0102e611 	.word	0x0102e611
 100dc18:	0102999c 	.word	0x0102999c
 100dc1c:	010281b3 	.word	0x010281b3
 100dc20:	21002418 	.word	0x21002418
 100dc24:	0102e62a 	.word	0x0102e62a
 100dc28:	210024e0 	.word	0x210024e0

0100dc2c <db_hash_read>:
{
 100dc2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	(void)k_work_cancel_delayable_sync(&db_hash.work, &db_hash.sync);
 100dc2e:	491b      	ldr	r1, [pc, #108]	; (100dc9c <db_hash_read+0x70>)
{
 100dc30:	4604      	mov	r4, r0
	(void)k_work_cancel_delayable_sync(&db_hash.work, &db_hash.sync);
 100dc32:	f1a1 0030 	sub.w	r0, r1, #48	; 0x30
{
 100dc36:	4615      	mov	r5, r2
 100dc38:	461f      	mov	r7, r3
 100dc3a:	f8bd 6018 	ldrh.w	r6, [sp, #24]
	(void)k_work_cancel_delayable_sync(&db_hash.work, &db_hash.sync);
 100dc3e:	f014 fae1 	bl	1022204 <k_work_cancel_delayable_sync>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
 100dc42:	4817      	ldr	r0, [pc, #92]	; (100dca0 <db_hash_read+0x74>)
 100dc44:	f01a fb2a 	bl	102829c <atomic_get>
	if (!atomic_test_bit(gatt_sc.flags, DB_HASH_VALID)) {
 100dc48:	0741      	lsls	r1, r0, #29
 100dc4a:	d402      	bmi.n	100dc52 <db_hash_read+0x26>
		db_hash_gen(true);
 100dc4c:	2001      	movs	r0, #1
 100dc4e:	f7ff ffa5 	bl	100db9c <db_hash_gen>
	cfg = find_cf_cfg(conn);
 100dc52:	4620      	mov	r0, r4
 100dc54:	f7ff f8a8 	bl	100cda8 <find_cf_cfg>
	if (cfg &&
 100dc58:	b168      	cbz	r0, 100dc76 <db_hash_read+0x4a>
 100dc5a:	7a03      	ldrb	r3, [r0, #8]
 100dc5c:	07da      	lsls	r2, r3, #31
 100dc5e:	d50a      	bpl.n	100dc76 <db_hash_read+0x4a>
	    !atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
 100dc60:	f100 040c 	add.w	r4, r0, #12
 100dc64:	4620      	mov	r0, r4
 100dc66:	f01a fb19 	bl	102829c <atomic_get>
	    CF_ROBUST_CACHING(cfg) &&
 100dc6a:	07c3      	lsls	r3, r0, #31
 100dc6c:	d403      	bmi.n	100dc76 <db_hash_read+0x4a>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
 100dc6e:	2102      	movs	r1, #2
 100dc70:	4620      	mov	r0, r4
 100dc72:	f01a fb16 	bl	10282a2 <atomic_or>
	if (offset > value_len) {
 100dc76:	2e10      	cmp	r6, #16
 100dc78:	d80c      	bhi.n	100dc94 <db_hash_read+0x68>
	len = MIN(buf_len, value_len - offset);
 100dc7a:	f1c6 0410 	rsb	r4, r6, #16
 100dc7e:	42bc      	cmp	r4, r7
 100dc80:	bfa8      	it	ge
 100dc82:	463c      	movge	r4, r7
	memcpy(buf, (uint8_t *)value + offset, len);
 100dc84:	4907      	ldr	r1, [pc, #28]	; (100dca4 <db_hash_read+0x78>)
 100dc86:	4622      	mov	r2, r4
 100dc88:	4628      	mov	r0, r5
 100dc8a:	4431      	add	r1, r6
 100dc8c:	f018 fe72 	bl	1026974 <memcpy>
}
 100dc90:	4620      	mov	r0, r4
 100dc92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 100dc94:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash.hash,
 100dc98:	e7fa      	b.n	100dc90 <db_hash_read+0x64>
 100dc9a:	bf00      	nop
 100dc9c:	21002468 	.word	0x21002468
 100dca0:	210024e0 	.word	0x210024e0
 100dca4:	21002418 	.word	0x21002418

0100dca8 <db_hash_process>:
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 100dca8:	f06f 0108 	mvn.w	r1, #8
{
 100dcac:	b508      	push	{r3, lr}
 100dcae:	4816      	ldr	r0, [pc, #88]	; (100dd08 <db_hash_process+0x60>)
 100dcb0:	f01a fb05 	bl	10282be <atomic_and>
	if (atomic_test_and_clear_bit(gatt_sc.flags, DB_HASH_LOAD)) {
 100dcb4:	0702      	lsls	r2, r0, #28
 100dcb6:	d522      	bpl.n	100dcfe <db_hash_process+0x56>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
 100dcb8:	4813      	ldr	r0, [pc, #76]	; (100dd08 <db_hash_process+0x60>)
 100dcba:	f01a faef 	bl	102829c <atomic_get>
 100dcbe:	4603      	mov	r3, r0
		if (!atomic_test_bit(gatt_sc.flags, DB_HASH_VALID)) {
 100dcc0:	075b      	lsls	r3, r3, #29
 100dcc2:	f3c0 0080 	ubfx	r0, r0, #2, #1
 100dcc6:	d401      	bmi.n	100dccc <db_hash_process+0x24>
			db_hash_gen(false);
 100dcc8:	f7ff ff68 	bl	100db9c <db_hash_gen>
		if (!memcmp(db_hash.stored_hash, db_hash.hash,
 100dccc:	2210      	movs	r2, #16
 100dcce:	490f      	ldr	r1, [pc, #60]	; (100dd0c <db_hash_process+0x64>)
 100dcd0:	1888      	adds	r0, r1, r2
 100dcd2:	f018 fe3f 	bl	1026954 <memcmp>
 100dcd6:	b948      	cbnz	r0, 100dcec <db_hash_process+0x44>
			k_work_cancel_delayable(&gatt_sc.work);
 100dcd8:	480d      	ldr	r0, [pc, #52]	; (100dd10 <db_hash_process+0x68>)
 100dcda:	f014 fa39 	bl	1022150 <k_work_cancel_delayable>
}
 100dcde:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 100dce2:	f06f 0101 	mvn.w	r1, #1
 100dce6:	4808      	ldr	r0, [pc, #32]	; (100dd08 <db_hash_process+0x60>)
 100dce8:	f01a bae9 	b.w	10282be <atomic_and>
		sc_indicate(0x0001, 0xffff);
 100dcec:	f64f 71ff 	movw	r1, #65535	; 0xffff
 100dcf0:	2001      	movs	r0, #1
 100dcf2:	f7ff fd0b 	bl	100d70c <sc_indicate>
}
 100dcf6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		db_hash_store();
 100dcfa:	f7ff bb1f 	b.w	100d33c <db_hash_store>
	db_hash_gen(true);
 100dcfe:	2001      	movs	r0, #1
}
 100dd00:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	db_hash_gen(true);
 100dd04:	f7ff bf4a 	b.w	100db9c <db_hash_gen>
 100dd08:	210024e0 	.word	0x210024e0
 100dd0c:	21002418 	.word	0x21002418
 100dd10:	210024b0 	.word	0x210024b0

0100dd14 <bt_gatt_service_register>:
{
 100dd14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100dd18:	b083      	sub	sp, #12
	__ASSERT(svc, "invalid parameters\n");
 100dd1a:	4604      	mov	r4, r0
{
 100dd1c:	af00      	add	r7, sp, #0
	__ASSERT(svc, "invalid parameters\n");
 100dd1e:	b970      	cbnz	r0, 100dd3e <bt_gatt_service_register+0x2a>
 100dd20:	4977      	ldr	r1, [pc, #476]	; (100df00 <bt_gatt_service_register+0x1ec>)
 100dd22:	f240 53c1 	movw	r3, #1473	; 0x5c1
 100dd26:	4a77      	ldr	r2, [pc, #476]	; (100df04 <bt_gatt_service_register+0x1f0>)
 100dd28:	4877      	ldr	r0, [pc, #476]	; (100df08 <bt_gatt_service_register+0x1f4>)
 100dd2a:	f016 ff54 	bl	1024bd6 <assert_print>
 100dd2e:	4877      	ldr	r0, [pc, #476]	; (100df0c <bt_gatt_service_register+0x1f8>)
 100dd30:	f016 ff51 	bl	1024bd6 <assert_print>
 100dd34:	f240 51c1 	movw	r1, #1473	; 0x5c1
	__ASSERT(svc->attrs, "invalid parameters\n");
 100dd38:	4872      	ldr	r0, [pc, #456]	; (100df04 <bt_gatt_service_register+0x1f0>)
 100dd3a:	f016 ff45 	bl	1024bc8 <assert_post_action>
 100dd3e:	6803      	ldr	r3, [r0, #0]
 100dd40:	b963      	cbnz	r3, 100dd5c <bt_gatt_service_register+0x48>
 100dd42:	4973      	ldr	r1, [pc, #460]	; (100df10 <bt_gatt_service_register+0x1fc>)
 100dd44:	f240 53c2 	movw	r3, #1474	; 0x5c2
 100dd48:	4a6e      	ldr	r2, [pc, #440]	; (100df04 <bt_gatt_service_register+0x1f0>)
 100dd4a:	486f      	ldr	r0, [pc, #444]	; (100df08 <bt_gatt_service_register+0x1f4>)
 100dd4c:	f016 ff43 	bl	1024bd6 <assert_print>
 100dd50:	486e      	ldr	r0, [pc, #440]	; (100df0c <bt_gatt_service_register+0x1f8>)
 100dd52:	f016 ff40 	bl	1024bd6 <assert_print>
 100dd56:	f240 51c2 	movw	r1, #1474	; 0x5c2
 100dd5a:	e7ed      	b.n	100dd38 <bt_gatt_service_register+0x24>
	__ASSERT(svc->attr_count, "invalid parameters\n");
 100dd5c:	6843      	ldr	r3, [r0, #4]
 100dd5e:	b963      	cbnz	r3, 100dd7a <bt_gatt_service_register+0x66>
 100dd60:	496c      	ldr	r1, [pc, #432]	; (100df14 <bt_gatt_service_register+0x200>)
 100dd62:	f240 53c3 	movw	r3, #1475	; 0x5c3
 100dd66:	4a67      	ldr	r2, [pc, #412]	; (100df04 <bt_gatt_service_register+0x1f0>)
 100dd68:	4867      	ldr	r0, [pc, #412]	; (100df08 <bt_gatt_service_register+0x1f4>)
 100dd6a:	f016 ff34 	bl	1024bd6 <assert_print>
 100dd6e:	4867      	ldr	r0, [pc, #412]	; (100df0c <bt_gatt_service_register+0x1f8>)
 100dd70:	f016 ff31 	bl	1024bd6 <assert_print>
 100dd74:	f240 51c3 	movw	r1, #1475	; 0x5c3
 100dd78:	e7de      	b.n	100dd38 <bt_gatt_service_register+0x24>
	bt_gatt_service_init();
 100dd7a:	f7ff f8d1 	bl	100cf20 <bt_gatt_service_init>
	if (!bt_uuid_cmp(svc->attrs[0].uuid, BT_UUID_GAP) ||
 100dd7e:	6823      	ldr	r3, [r4, #0]
 100dd80:	2500      	movs	r5, #0
 100dd82:	6818      	ldr	r0, [r3, #0]
 100dd84:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 100dd88:	4639      	mov	r1, r7
 100dd8a:	703d      	strb	r5, [r7, #0]
 100dd8c:	807b      	strh	r3, [r7, #2]
 100dd8e:	f018 fe97 	bl	1026ac0 <bt_uuid_cmp>
 100dd92:	b928      	cbnz	r0, 100dda0 <bt_gatt_service_register+0x8c>
		return -EALREADY;
 100dd94:	f06f 0077 	mvn.w	r0, #119	; 0x77
}
 100dd98:	370c      	adds	r7, #12
 100dd9a:	46bd      	mov	sp, r7
 100dd9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    !bt_uuid_cmp(svc->attrs[0].uuid, BT_UUID_GATT)) {
 100dda0:	6823      	ldr	r3, [r4, #0]
 100dda2:	1d39      	adds	r1, r7, #4
 100dda4:	6818      	ldr	r0, [r3, #0]
 100dda6:	f641 0301 	movw	r3, #6145	; 0x1801
 100ddaa:	713d      	strb	r5, [r7, #4]
 100ddac:	80fb      	strh	r3, [r7, #6]
 100ddae:	f018 fe87 	bl	1026ac0 <bt_uuid_cmp>
	if (!bt_uuid_cmp(svc->attrs[0].uuid, BT_UUID_GAP) ||
 100ddb2:	2800      	cmp	r0, #0
 100ddb4:	d0ee      	beq.n	100dd94 <bt_gatt_service_register+0x80>
	return list->head;
 100ddb6:	4d58      	ldr	r5, [pc, #352]	; (100df18 <bt_gatt_service_register+0x204>)
	k_sched_lock();
 100ddb8:	f014 fcca 	bl	1022750 <k_sched_lock>
	if (sys_slist_is_empty(&db)) {
 100ddbc:	682b      	ldr	r3, [r5, #0]
	struct bt_gatt_attr *attrs = svc->attrs;
 100ddbe:	f8d4 8000 	ldr.w	r8, [r4]
	uint16_t count = svc->attr_count;
 100ddc2:	f8b4 a004 	ldrh.w	sl, [r4, #4]
	if (sys_slist_is_empty(&db)) {
 100ddc6:	b9b3      	cbnz	r3, 100ddf6 <bt_gatt_service_register+0xe2>
		handle = last_static_handle;
 100ddc8:	4a54      	ldr	r2, [pc, #336]	; (100df1c <bt_gatt_service_register+0x208>)
 100ddca:	8816      	ldrh	r6, [r2, #0]
	for (; attrs && count; attrs++, count--) {
 100ddcc:	f1b8 0f00 	cmp.w	r8, #0
 100ddd0:	d16f      	bne.n	100deb2 <bt_gatt_service_register+0x19e>
	parent->next = child;
 100ddd2:	2200      	movs	r2, #0
		sys_slist_append(&db, &svc->node);
 100ddd4:	f104 0308 	add.w	r3, r4, #8
 100ddd8:	60a2      	str	r2, [r4, #8]
	return list->tail;
 100ddda:	686a      	ldr	r2, [r5, #4]
Z_GENLIST_APPEND(slist, snode)
 100dddc:	2a00      	cmp	r2, #0
 100ddde:	d16f      	bne.n	100dec0 <bt_gatt_service_register+0x1ac>
	list->head = node;
 100dde0:	e9c5 3300 	strd	r3, r3, [r5]
	if (!atomic_get(&init)) {
 100dde4:	484e      	ldr	r0, [pc, #312]	; (100df20 <bt_gatt_service_register+0x20c>)
 100dde6:	f01a fa59 	bl	102829c <atomic_get>
 100ddea:	2800      	cmp	r0, #0
 100ddec:	d178      	bne.n	100dee0 <bt_gatt_service_register+0x1cc>
	k_sched_unlock();
 100ddee:	f014 fd1b 	bl	1022828 <k_sched_unlock>
		return 0;
 100ddf2:	2000      	movs	r0, #0
 100ddf4:	e7d0      	b.n	100dd98 <bt_gatt_service_register+0x84>
	return list->tail;
 100ddf6:	686b      	ldr	r3, [r5, #4]
	last = SYS_SLIST_PEEK_TAIL_CONTAINER(&db, last, node);
 100ddf8:	2b00      	cmp	r3, #0
 100ddfa:	d07e      	beq.n	100defa <bt_gatt_service_register+0x1e6>
	handle = last->attrs[last->attr_count - 1].handle;
 100ddfc:	e953 3202 	ldrd	r3, r2, [r3, #-8]
 100de00:	2114      	movs	r1, #20
 100de02:	fb01 3302 	mla	r3, r1, r2, r3
 100de06:	f833 6c04 	ldrh.w	r6, [r3, #-4]
	for (; attrs && count; attrs++, count--) {
 100de0a:	f1b8 0f00 	cmp.w	r8, #0
 100de0e:	d155      	bne.n	100debc <bt_gatt_service_register+0x1a8>
	if (last_handle == 0 || svc->attrs[0].handle > last_handle) {
 100de10:	2e00      	cmp	r6, #0
 100de12:	d0de      	beq.n	100ddd2 <bt_gatt_service_register+0xbe>
 100de14:	6823      	ldr	r3, [r4, #0]
 100de16:	f8b3 c010 	ldrh.w	ip, [r3, #16]
 100de1a:	45b4      	cmp	ip, r6
 100de1c:	d8d9      	bhi.n	100ddd2 <bt_gatt_service_register+0xbe>
	return list->head;
 100de1e:	6829      	ldr	r1, [r5, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&db, tmp, node) {
 100de20:	2900      	cmp	r1, #0
 100de22:	d0df      	beq.n	100dde4 <bt_gatt_service_register+0xd0>
 100de24:	2200      	movs	r2, #0
 100de26:	f1a1 0308 	sub.w	r3, r1, #8
		if (tmp->attrs[0].handle > svc->attrs[0].handle) {
 100de2a:	6818      	ldr	r0, [r3, #0]
 100de2c:	8a00      	ldrh	r0, [r0, #16]
 100de2e:	4560      	cmp	r0, ip
 100de30:	d94f      	bls.n	100ded2 <bt_gatt_service_register+0x1be>
				sys_slist_insert(&db, &prev->node, &svc->node);
 100de32:	f104 0308 	add.w	r3, r4, #8
			if (prev) {
 100de36:	2a00      	cmp	r2, #0
 100de38:	d045      	beq.n	100dec6 <bt_gatt_service_register+0x1b2>
	return node->next;
 100de3a:	6891      	ldr	r1, [r2, #8]
	parent->next = child;
 100de3c:	60a1      	str	r1, [r4, #8]
Z_GENLIST_INSERT(slist, snode)
 100de3e:	2900      	cmp	r1, #0
 100de40:	d0cb      	beq.n	100ddda <bt_gatt_service_register+0xc6>
	parent->next = child;
 100de42:	6093      	str	r3, [r2, #8]
	if (err < 0) {
 100de44:	e7ce      	b.n	100dde4 <bt_gatt_service_register+0xd0>
		if (!attrs->handle) {
 100de46:	f8b8 1010 	ldrh.w	r1, [r8, #16]
 100de4a:	b979      	cbnz	r1, 100de6c <bt_gatt_service_register+0x158>
			attrs->handle = ++handle;
 100de4c:	1c71      	adds	r1, r6, #1
 100de4e:	b289      	uxth	r1, r1
 100de50:	f8a8 1010 	strh.w	r1, [r8, #16]
	for (; attrs && count; attrs++, count--) {
 100de54:	460e      	mov	r6, r1
 100de56:	f10a 3aff 	add.w	sl, sl, #4294967295
 100de5a:	f108 0814 	add.w	r8, r8, #20
 100de5e:	fa1f fa8a 	uxth.w	sl, sl
 100de62:	f1ba 0f00 	cmp.w	sl, #0
 100de66:	d1ee      	bne.n	100de46 <bt_gatt_service_register+0x132>
 100de68:	464e      	mov	r6, r9
 100de6a:	e7d1      	b.n	100de10 <bt_gatt_service_register+0xfc>
		} else if (attrs->handle > handle) {
 100de6c:	42b1      	cmp	r1, r6
 100de6e:	d8f1      	bhi.n	100de54 <bt_gatt_service_register+0x140>
	bt_gatt_foreach_attr(handle, handle, found_attr, &attr);
 100de70:	1d3b      	adds	r3, r7, #4
 100de72:	4608      	mov	r0, r1
	const struct bt_gatt_attr *attr = NULL;
 100de74:	f8c7 b004 	str.w	fp, [r7, #4]
	bt_gatt_foreach_attr(handle, handle, found_attr, &attr);
 100de78:	f01a fb81 	bl	102857e <bt_gatt_foreach_attr>
	return attr;
 100de7c:	687b      	ldr	r3, [r7, #4]
		} else if (find_attr(attrs->handle)) {
 100de7e:	4a29      	ldr	r2, [pc, #164]	; (100df24 <bt_gatt_service_register+0x210>)
 100de80:	b1ab      	cbz	r3, 100deae <bt_gatt_service_register+0x19a>
			LOG_ERR("Unable to register handle 0x%04x", attrs->handle);
 100de82:	466c      	mov	r4, sp
 100de84:	b088      	sub	sp, #32
 100de86:	466a      	mov	r2, sp
 100de88:	f8b8 3010 	ldrh.w	r3, [r8, #16]
 100de8c:	4926      	ldr	r1, [pc, #152]	; (100df28 <bt_gatt_service_register+0x214>)
 100de8e:	4827      	ldr	r0, [pc, #156]	; (100df2c <bt_gatt_service_register+0x218>)
 100de90:	e9c2 1305 	strd	r1, r3, [r2, #20]
 100de94:	2303      	movs	r3, #3
 100de96:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100de9a:	f842 3f10 	str.w	r3, [r2, #16]!
 100de9e:	f01a fa3f 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100dea2:	46a5      	mov	sp, r4
		k_sched_unlock();
 100dea4:	f014 fcc0 	bl	1022828 <k_sched_unlock>
		return err;
 100dea8:	f06f 0015 	mvn.w	r0, #21
 100deac:	e774      	b.n	100dd98 <bt_gatt_service_register+0x84>
 100deae:	4631      	mov	r1, r6
 100deb0:	e7d0      	b.n	100de54 <bt_gatt_service_register+0x140>
		last_handle = 0;
 100deb2:	4699      	mov	r9, r3
	const struct bt_gatt_attr *attr = NULL;
 100deb4:	f04f 0b00 	mov.w	fp, #0
	bt_gatt_foreach_attr(handle, handle, found_attr, &attr);
 100deb8:	4a1a      	ldr	r2, [pc, #104]	; (100df24 <bt_gatt_service_register+0x210>)
 100deba:	e7d2      	b.n	100de62 <bt_gatt_service_register+0x14e>
	handle = last->attrs[last->attr_count - 1].handle;
 100debc:	46b1      	mov	r9, r6
 100debe:	e7f9      	b.n	100deb4 <bt_gatt_service_register+0x1a0>
 100dec0:	6013      	str	r3, [r2, #0]
	list->tail = node;
 100dec2:	606b      	str	r3, [r5, #4]
	if (err < 0) {
 100dec4:	e78e      	b.n	100dde4 <bt_gatt_service_register+0xd0>
Z_GENLIST_PREPEND(slist, snode)
 100dec6:	686a      	ldr	r2, [r5, #4]
	parent->next = child;
 100dec8:	60a1      	str	r1, [r4, #8]
	list->head = node;
 100deca:	602b      	str	r3, [r5, #0]
Z_GENLIST_PREPEND(slist, snode)
 100decc:	2a00      	cmp	r2, #0
 100dece:	d189      	bne.n	100dde4 <bt_gatt_service_register+0xd0>
 100ded0:	e7f7      	b.n	100dec2 <bt_gatt_service_register+0x1ae>
	return node->next;
 100ded2:	6898      	ldr	r0, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&db, tmp, node) {
 100ded4:	2800      	cmp	r0, #0
 100ded6:	d085      	beq.n	100dde4 <bt_gatt_service_register+0xd0>
 100ded8:	461a      	mov	r2, r3
 100deda:	f1a0 0308 	sub.w	r3, r0, #8
 100dede:	e7a4      	b.n	100de2a <bt_gatt_service_register+0x116>
	sc_indicate(svc->attrs[0].handle,
 100dee0:	2114      	movs	r1, #20
		    svc->attrs[svc->attr_count - 1].handle);
 100dee2:	e9d4 2300 	ldrd	r2, r3, [r4]
	sc_indicate(svc->attrs[0].handle,
 100dee6:	fb01 2303 	mla	r3, r1, r3, r2
 100deea:	8a10      	ldrh	r0, [r2, #16]
 100deec:	f833 1c04 	ldrh.w	r1, [r3, #-4]
 100def0:	f7ff fc0c 	bl	100d70c <sc_indicate>
	db_changed();
 100def4:	f7ff fb66 	bl	100d5c4 <db_changed>
 100def8:	e779      	b.n	100ddee <bt_gatt_service_register+0xda>
	handle = last->attrs[last->attr_count - 1].handle;
 100defa:	681b      	ldr	r3, [r3, #0]
 100defc:	deff      	udf	#255	; 0xff
 100defe:	bf00      	nop
 100df00:	0102e643 	.word	0x0102e643
 100df04:	0102e3f4 	.word	0x0102e3f4
 100df08:	0102b695 	.word	0x0102b695
 100df0c:	0102e647 	.word	0x0102e647
 100df10:	0102e65d 	.word	0x0102e65d
 100df14:	0102e668 	.word	0x0102e668
 100df18:	2100497c 	.word	0x2100497c
 100df1c:	210081d0 	.word	0x210081d0
 100df20:	21004978 	.word	0x21004978
 100df24:	01028149 	.word	0x01028149
 100df28:	0102e678 	.word	0x0102e678
 100df2c:	0102999c 	.word	0x0102999c

0100df30 <ccc_set_direct>:
{
 100df30:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100df34:	b0b8      	sub	sp, #224	; 0xe0
 100df36:	af00      	add	r7, sp, #0
 100df38:	460c      	mov	r4, r1
 100df3a:	4690      	mov	r8, r2
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
 100df3c:	493f      	ldr	r1, [pc, #252]	; (100e03c <ccc_set_direct+0x10c>)
 100df3e:	463a      	mov	r2, r7
 100df40:	f8d7 0100 	ldr.w	r0, [r7, #256]	; 0x100
{
 100df44:	4699      	mov	r9, r3
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
 100df46:	f017 fa19 	bl	102537c <settings_name_steq>
 100df4a:	b938      	cbnz	r0, 100df5c <ccc_set_direct+0x2c>
 100df4c:	f7ff f84a 	bl	100cfe4 <ccc_set_direct.part.0>
 100df50:	4605      	mov	r5, r0
}
 100df52:	4628      	mov	r0, r5
 100df54:	37e0      	adds	r7, #224	; 0xe0
 100df56:	46bd      	mov	sp, r7
 100df58:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return ccc_set(name, len, read_cb, cb_arg);
 100df5c:	683e      	ldr	r6, [r7, #0]
		settings_name_next(name, &next);
 100df5e:	1d39      	adds	r1, r7, #4
 100df60:	4630      	mov	r0, r6
 100df62:	f017 fa2f 	bl	10253c4 <settings_name_next>
		if (!name) {
 100df66:	b96e      	cbnz	r6, 100df84 <ccc_set_direct+0x54>
			LOG_ERR("Insufficient number of arguments");
 100df68:	4b35      	ldr	r3, [pc, #212]	; (100e040 <ccc_set_direct+0x110>)
 100df6a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100df6e:	637b      	str	r3, [r7, #52]	; 0x34
 100df70:	2302      	movs	r3, #2
 100df72:	4834      	ldr	r0, [pc, #208]	; (100e044 <ccc_set_direct+0x114>)
 100df74:	633b      	str	r3, [r7, #48]	; 0x30
 100df76:	f107 0230 	add.w	r2, r7, #48	; 0x30
 100df7a:	f01a f9d1 	bl	1028320 <z_log_msg_static_create.constprop.0>
			return -EINVAL;
 100df7e:	f06f 0415 	mvn.w	r4, #21
 100df82:	e049      	b.n	100e018 <ccc_set_direct+0xe8>
		} else if (!next) {
 100df84:	6878      	ldr	r0, [r7, #4]
 100df86:	b9c0      	cbnz	r0, 100dfba <ccc_set_direct+0x8a>
			load.addr_with_id.id = BT_ID_DEFAULT;
 100df88:	2300      	movs	r3, #0
		err = bt_settings_decode_key(name, &addr);
 100df8a:	f107 0a08 	add.w	sl, r7, #8
 100df8e:	4651      	mov	r1, sl
 100df90:	4630      	mov	r0, r6
			load.addr_with_id.id = BT_ID_DEFAULT;
 100df92:	753b      	strb	r3, [r7, #20]
		err = bt_settings_decode_key(name, &addr);
 100df94:	f018 fd70 	bl	1026a78 <bt_settings_decode_key>
		if (err) {
 100df98:	4605      	mov	r5, r0
 100df9a:	b320      	cbz	r0, 100dfe6 <ccc_set_direct+0xb6>
			LOG_ERR("Unable to decode address %s", name);
 100df9c:	466c      	mov	r4, sp
 100df9e:	b088      	sub	sp, #32
 100dfa0:	466a      	mov	r2, sp
 100dfa2:	4b29      	ldr	r3, [pc, #164]	; (100e048 <ccc_set_direct+0x118>)
 100dfa4:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 100dfa8:	e9c2 3605 	strd	r3, r6, [r2, #20]
 100dfac:	f44f 7300 	mov.w	r3, #512	; 0x200
 100dfb0:	8393      	strh	r3, [r2, #28]
 100dfb2:	4b26      	ldr	r3, [pc, #152]	; (100e04c <ccc_set_direct+0x11c>)
 100dfb4:	f842 3f10 	str.w	r3, [r2, #16]!
 100dfb8:	e010      	b.n	100dfdc <ccc_set_direct+0xac>
			unsigned long next_id = strtoul(next, NULL, 10);
 100dfba:	220a      	movs	r2, #10
 100dfbc:	2100      	movs	r1, #0
 100dfbe:	f018 fc19 	bl	10267f4 <strtoul>
			if (next_id >= CONFIG_BT_ID_MAX) {
 100dfc2:	2800      	cmp	r0, #0
 100dfc4:	d0e0      	beq.n	100df88 <ccc_set_direct+0x58>
				LOG_ERR("Invalid local identity %lu", next_id);
 100dfc6:	466c      	mov	r4, sp
 100dfc8:	b088      	sub	sp, #32
 100dfca:	466a      	mov	r2, sp
 100dfcc:	4b20      	ldr	r3, [pc, #128]	; (100e050 <ccc_set_direct+0x120>)
 100dfce:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100dfd2:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100dfd6:	2303      	movs	r3, #3
 100dfd8:	f842 3f10 	str.w	r3, [r2, #16]!
			LOG_ERR("Unable to decode address %s", name);
 100dfdc:	4819      	ldr	r0, [pc, #100]	; (100e044 <ccc_set_direct+0x114>)
 100dfde:	f01a f99f 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100dfe2:	46a5      	mov	sp, r4
			return -EINVAL;
 100dfe4:	e7cb      	b.n	100df7e <ccc_set_direct+0x4e>
		load.addr_with_id.addr = &addr;
 100dfe6:	f8c7 a010 	str.w	sl, [r7, #16]
		if (len_rd) {
 100dfea:	b32c      	cbz	r4, 100e038 <ccc_set_direct+0x108>
			len = read_cb(cb_arg, ccc_store, sizeof(ccc_store));
 100dfec:	22c0      	movs	r2, #192	; 0xc0
 100dfee:	4648      	mov	r0, r9
 100dff0:	f107 0120 	add.w	r1, r7, #32
 100dff4:	47c0      	blx	r8
			if (len < 0) {
 100dff6:	1e04      	subs	r4, r0, #0
 100dff8:	da10      	bge.n	100e01c <ccc_set_direct+0xec>
				LOG_ERR("Failed to decode value (err %zd)", len);
 100dffa:	466d      	mov	r5, sp
 100dffc:	b088      	sub	sp, #32
 100dffe:	466a      	mov	r2, sp
 100e000:	4b14      	ldr	r3, [pc, #80]	; (100e054 <ccc_set_direct+0x124>)
 100e002:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100e006:	e9c2 3405 	strd	r3, r4, [r2, #20]
 100e00a:	2303      	movs	r3, #3
 100e00c:	480d      	ldr	r0, [pc, #52]	; (100e044 <ccc_set_direct+0x114>)
 100e00e:	f842 3f10 	str.w	r3, [r2, #16]!
 100e012:	f01a f985 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100e016:	46ad      	mov	sp, r5
			return -EINVAL;
 100e018:	4625      	mov	r5, r4
 100e01a:	e79a      	b.n	100df52 <ccc_set_direct+0x22>
			load.count = len / sizeof(*ccc_store);
 100e01c:	08a4      	lsrs	r4, r4, #2
			for (size_t i = 0; i < load.count; i++) {
 100e01e:	f107 0320 	add.w	r3, r7, #32
			load.count = len / sizeof(*ccc_store);
 100e022:	e9c7 3406 	strd	r3, r4, [r7, #24]
		bt_gatt_foreach_attr(0x0001, 0xffff, ccc_load, &load);
 100e026:	f64f 71ff 	movw	r1, #65535	; 0xffff
 100e02a:	2001      	movs	r0, #1
 100e02c:	4a0a      	ldr	r2, [pc, #40]	; (100e058 <ccc_set_direct+0x128>)
 100e02e:	f107 0310 	add.w	r3, r7, #16
 100e032:	f01a faa4 	bl	102857e <bt_gatt_foreach_attr>
	return 0;
 100e036:	e78c      	b.n	100df52 <ccc_set_direct+0x22>
 100e038:	4623      	mov	r3, r4
 100e03a:	e7f2      	b.n	100e022 <ccc_set_direct+0xf2>
 100e03c:	0102e699 	.word	0x0102e699
 100e040:	0102cd4a 	.word	0x0102cd4a
 100e044:	0102999c 	.word	0x0102999c
 100e048:	0102e430 	.word	0x0102e430
 100e04c:	01000003 	.word	0x01000003
 100e050:	0102e44c 	.word	0x0102e44c
 100e054:	0102e489 	.word	0x0102e489
 100e058:	0100ce95 	.word	0x0100ce95

0100e05c <bt_gatt_attr_next>:
	struct bt_gatt_attr *next = NULL;
 100e05c:	2300      	movs	r3, #0
{
 100e05e:	b507      	push	{r0, r1, r2, lr}
	struct bt_gatt_attr *next = NULL;
 100e060:	9301      	str	r3, [sp, #4]
	uint16_t handle = bt_gatt_attr_get_handle(attr);
 100e062:	f7ff fcc1 	bl	100d9e8 <bt_gatt_attr_get_handle>
	bt_gatt_foreach_attr(handle + 1, handle + 1, find_next, &next);
 100e066:	1c41      	adds	r1, r0, #1
 100e068:	b289      	uxth	r1, r1
 100e06a:	4608      	mov	r0, r1
 100e06c:	4a03      	ldr	r2, [pc, #12]	; (100e07c <bt_gatt_attr_next+0x20>)
 100e06e:	ab01      	add	r3, sp, #4
 100e070:	f01a fa85 	bl	102857e <bt_gatt_foreach_attr>
}
 100e074:	9801      	ldr	r0, [sp, #4]
 100e076:	b003      	add	sp, #12
 100e078:	f85d fb04 	ldr.w	pc, [sp], #4
 100e07c:	01028327 	.word	0x01028327

0100e080 <bt_gatt_is_subscribed>:
{
 100e080:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 100e084:	460c      	mov	r4, r1
 100e086:	4617      	mov	r7, r2
	__ASSERT(conn, "invalid parameter\n");
 100e088:	4605      	mov	r5, r0
 100e08a:	b970      	cbnz	r0, 100e0aa <bt_gatt_is_subscribed+0x2a>
 100e08c:	495d      	ldr	r1, [pc, #372]	; (100e204 <bt_gatt_is_subscribed+0x184>)
 100e08e:	f640 434d 	movw	r3, #3149	; 0xc4d
 100e092:	4a5d      	ldr	r2, [pc, #372]	; (100e208 <bt_gatt_is_subscribed+0x188>)
 100e094:	485d      	ldr	r0, [pc, #372]	; (100e20c <bt_gatt_is_subscribed+0x18c>)
 100e096:	f016 fd9e 	bl	1024bd6 <assert_print>
 100e09a:	485d      	ldr	r0, [pc, #372]	; (100e210 <bt_gatt_is_subscribed+0x190>)
 100e09c:	f016 fd9b 	bl	1024bd6 <assert_print>
 100e0a0:	f640 414d 	movw	r1, #3149	; 0xc4d
	__ASSERT(attr, "invalid parameter\n");
 100e0a4:	4858      	ldr	r0, [pc, #352]	; (100e208 <bt_gatt_is_subscribed+0x188>)
 100e0a6:	f016 fd8f 	bl	1024bc8 <assert_post_action>
 100e0aa:	b961      	cbnz	r1, 100e0c6 <bt_gatt_is_subscribed+0x46>
 100e0ac:	4959      	ldr	r1, [pc, #356]	; (100e214 <bt_gatt_is_subscribed+0x194>)
 100e0ae:	f640 434e 	movw	r3, #3150	; 0xc4e
 100e0b2:	4a55      	ldr	r2, [pc, #340]	; (100e208 <bt_gatt_is_subscribed+0x188>)
 100e0b4:	4855      	ldr	r0, [pc, #340]	; (100e20c <bt_gatt_is_subscribed+0x18c>)
 100e0b6:	f016 fd8e 	bl	1024bd6 <assert_print>
 100e0ba:	4855      	ldr	r0, [pc, #340]	; (100e210 <bt_gatt_is_subscribed+0x190>)
 100e0bc:	f016 fd8b 	bl	1024bd6 <assert_print>
 100e0c0:	f640 414e 	movw	r1, #3150	; 0xc4e
 100e0c4:	e7ee      	b.n	100e0a4 <bt_gatt_is_subscribed+0x24>
	if (conn->state != BT_CONN_CONNECTED) {
 100e0c6:	7b43      	ldrb	r3, [r0, #13]
 100e0c8:	2b07      	cmp	r3, #7
 100e0ca:	d110      	bne.n	100e0ee <bt_gatt_is_subscribed+0x6e>
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC)) {
 100e0cc:	2300      	movs	r3, #0
 100e0ce:	f88d 300c 	strb.w	r3, [sp, #12]
 100e0d2:	f642 0303 	movw	r3, #10243	; 0x2803
 100e0d6:	6820      	ldr	r0, [r4, #0]
 100e0d8:	a903      	add	r1, sp, #12
 100e0da:	f8ad 300e 	strh.w	r3, [sp, #14]
 100e0de:	f018 fcef 	bl	1026ac0 <bt_uuid_cmp>
 100e0e2:	b9d0      	cbnz	r0, 100e11a <bt_gatt_is_subscribed+0x9a>
		if (!(chrc->properties &
 100e0e4:	68e3      	ldr	r3, [r4, #12]
 100e0e6:	799b      	ldrb	r3, [r3, #6]
 100e0e8:	f013 0f30 	tst.w	r3, #48	; 0x30
 100e0ec:	d103      	bne.n	100e0f6 <bt_gatt_is_subscribed+0x76>
		return false;
 100e0ee:	2000      	movs	r0, #0
}
 100e0f0:	b004      	add	sp, #16
 100e0f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		attr = bt_gatt_attr_next(attr);
 100e0f6:	4620      	mov	r0, r4
 100e0f8:	f7ff ffb0 	bl	100e05c <bt_gatt_attr_next>
		__ASSERT(attr, "No more attributes\n");
 100e0fc:	4604      	mov	r4, r0
 100e0fe:	b960      	cbnz	r0, 100e11a <bt_gatt_is_subscribed+0x9a>
 100e100:	4944      	ldr	r1, [pc, #272]	; (100e214 <bt_gatt_is_subscribed+0x194>)
 100e102:	f640 435f 	movw	r3, #3167	; 0xc5f
 100e106:	4a40      	ldr	r2, [pc, #256]	; (100e208 <bt_gatt_is_subscribed+0x188>)
 100e108:	4840      	ldr	r0, [pc, #256]	; (100e20c <bt_gatt_is_subscribed+0x18c>)
 100e10a:	f016 fd64 	bl	1024bd6 <assert_print>
 100e10e:	4842      	ldr	r0, [pc, #264]	; (100e218 <bt_gatt_is_subscribed+0x198>)
 100e110:	f016 fd61 	bl	1024bd6 <assert_print>
 100e114:	f640 415f 	movw	r1, #3167	; 0xc5f
 100e118:	e7c4      	b.n	100e0a4 <bt_gatt_is_subscribed+0x24>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) != 0) {
 100e11a:	2300      	movs	r3, #0
 100e11c:	6820      	ldr	r0, [r4, #0]
 100e11e:	f88d 300c 	strb.w	r3, [sp, #12]
 100e122:	f642 1302 	movw	r3, #10498	; 0x2902
 100e126:	a903      	add	r1, sp, #12
 100e128:	f8ad 300e 	strh.w	r3, [sp, #14]
 100e12c:	f018 fcc8 	bl	1026ac0 <bt_uuid_cmp>
 100e130:	b188      	cbz	r0, 100e156 <bt_gatt_is_subscribed+0xd6>
		attr = bt_gatt_attr_next(attr);
 100e132:	4620      	mov	r0, r4
 100e134:	f7ff ff92 	bl	100e05c <bt_gatt_attr_next>
		__ASSERT(attr, "No more attributes\n");
 100e138:	4604      	mov	r4, r0
 100e13a:	b960      	cbnz	r0, 100e156 <bt_gatt_is_subscribed+0xd6>
 100e13c:	4935      	ldr	r1, [pc, #212]	; (100e214 <bt_gatt_is_subscribed+0x194>)
 100e13e:	f640 4365 	movw	r3, #3173	; 0xc65
 100e142:	4a31      	ldr	r2, [pc, #196]	; (100e208 <bt_gatt_is_subscribed+0x188>)
 100e144:	4831      	ldr	r0, [pc, #196]	; (100e20c <bt_gatt_is_subscribed+0x18c>)
 100e146:	f016 fd46 	bl	1024bd6 <assert_print>
 100e14a:	4833      	ldr	r0, [pc, #204]	; (100e218 <bt_gatt_is_subscribed+0x198>)
 100e14c:	f016 fd43 	bl	1024bd6 <assert_print>
 100e150:	f640 4165 	movw	r1, #3173	; 0xc65
 100e154:	e7a6      	b.n	100e0a4 <bt_gatt_is_subscribed+0x24>
	while (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) &&
 100e156:	2600      	movs	r6, #0
 100e158:	f642 1802 	movw	r8, #10498	; 0x2902
 100e15c:	6820      	ldr	r0, [r4, #0]
 100e15e:	4669      	mov	r1, sp
 100e160:	f88d 6000 	strb.w	r6, [sp]
 100e164:	f8ad 8002 	strh.w	r8, [sp, #2]
 100e168:	f018 fcaa 	bl	1026ac0 <bt_uuid_cmp>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
 100e16c:	b9f0      	cbnz	r0, 100e1ac <bt_gatt_is_subscribed+0x12c>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) != 0) {
 100e16e:	2300      	movs	r3, #0
 100e170:	6820      	ldr	r0, [r4, #0]
 100e172:	f88d 300c 	strb.w	r3, [sp, #12]
 100e176:	f642 1302 	movw	r3, #10498	; 0x2902
 100e17a:	a903      	add	r1, sp, #12
 100e17c:	f8ad 300e 	strh.w	r3, [sp, #14]
 100e180:	f018 fc9e 	bl	1026ac0 <bt_uuid_cmp>
 100e184:	2800      	cmp	r0, #0
 100e186:	d1b2      	bne.n	100e0ee <bt_gatt_is_subscribed+0x6e>
	ccc = attr->user_data;
 100e188:	68e6      	ldr	r6, [r4, #12]
	for (size_t i = 0; i < BT_GATT_CCC_MAX; i++) {
 100e18a:	1c74      	adds	r4, r6, #1
 100e18c:	3651      	adds	r6, #81	; 0x51
		if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer) &&
 100e18e:	4622      	mov	r2, r4
 100e190:	4628      	mov	r0, r5
 100e192:	f814 1c01 	ldrb.w	r1, [r4, #-1]
 100e196:	f019 f87b 	bl	1027290 <bt_conn_is_peer_addr_le>
 100e19a:	b118      	cbz	r0, 100e1a4 <bt_gatt_is_subscribed+0x124>
 100e19c:	f8b4 3007 	ldrh.w	r3, [r4, #7]
 100e1a0:	421f      	tst	r7, r3
 100e1a2:	d1a5      	bne.n	100e0f0 <bt_gatt_is_subscribed+0x70>
	for (size_t i = 0; i < BT_GATT_CCC_MAX; i++) {
 100e1a4:	340a      	adds	r4, #10
 100e1a6:	42b4      	cmp	r4, r6
 100e1a8:	d1f1      	bne.n	100e18e <bt_gatt_is_subscribed+0x10e>
 100e1aa:	e7a0      	b.n	100e0ee <bt_gatt_is_subscribed+0x6e>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) &&
 100e1ac:	f642 0303 	movw	r3, #10243	; 0x2803
 100e1b0:	6820      	ldr	r0, [r4, #0]
 100e1b2:	a901      	add	r1, sp, #4
 100e1b4:	f88d 6004 	strb.w	r6, [sp, #4]
 100e1b8:	f8ad 3006 	strh.w	r3, [sp, #6]
 100e1bc:	f018 fc80 	bl	1026ac0 <bt_uuid_cmp>
	while (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) &&
 100e1c0:	2800      	cmp	r0, #0
 100e1c2:	d0d4      	beq.n	100e16e <bt_gatt_is_subscribed+0xee>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
 100e1c4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 100e1c8:	6820      	ldr	r0, [r4, #0]
 100e1ca:	a902      	add	r1, sp, #8
 100e1cc:	f88d 6008 	strb.w	r6, [sp, #8]
 100e1d0:	f8ad 300a 	strh.w	r3, [sp, #10]
 100e1d4:	f018 fc74 	bl	1026ac0 <bt_uuid_cmp>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) &&
 100e1d8:	2800      	cmp	r0, #0
 100e1da:	d0c8      	beq.n	100e16e <bt_gatt_is_subscribed+0xee>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
 100e1dc:	f642 0301 	movw	r3, #10241	; 0x2801
 100e1e0:	6820      	ldr	r0, [r4, #0]
 100e1e2:	a903      	add	r1, sp, #12
 100e1e4:	f88d 600c 	strb.w	r6, [sp, #12]
 100e1e8:	f8ad 300e 	strh.w	r3, [sp, #14]
 100e1ec:	f018 fc68 	bl	1026ac0 <bt_uuid_cmp>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
 100e1f0:	2800      	cmp	r0, #0
 100e1f2:	d0bc      	beq.n	100e16e <bt_gatt_is_subscribed+0xee>
		attr = bt_gatt_attr_next(attr);
 100e1f4:	4620      	mov	r0, r4
 100e1f6:	f7ff ff31 	bl	100e05c <bt_gatt_attr_next>
		if (!attr) {
 100e1fa:	4604      	mov	r4, r0
 100e1fc:	2800      	cmp	r0, #0
 100e1fe:	d1ad      	bne.n	100e15c <bt_gatt_is_subscribed+0xdc>
 100e200:	e775      	b.n	100e0ee <bt_gatt_is_subscribed+0x6e>
 100e202:	bf00      	nop
 100e204:	0102dca4 	.word	0x0102dca4
 100e208:	0102e3f4 	.word	0x0102e3f4
 100e20c:	0102b695 	.word	0x0102b695
 100e210:	0102e6a0 	.word	0x0102e6a0
 100e214:	0102e6b5 	.word	0x0102e6b5
 100e218:	0102e6ba 	.word	0x0102e6ba

0100e21c <gatt_indicate>:
{
 100e21c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100e220:	4615      	mov	r5, r2
 100e222:	4689      	mov	r9, r1
	if (bt_gatt_check_perm(conn, params->attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
 100e224:	2294      	movs	r2, #148	; 0x94
 100e226:	6869      	ldr	r1, [r5, #4]
{
 100e228:	b086      	sub	sp, #24
 100e22a:	4606      	mov	r6, r0
	if (bt_gatt_check_perm(conn, params->attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
 100e22c:	f01a f9b4 	bl	1028598 <bt_gatt_check_perm>
 100e230:	4680      	mov	r8, r0
 100e232:	b178      	cbz	r0, 100e254 <gatt_indicate+0x38>
		LOG_WRN("Link is not encrypted");
 100e234:	4b36      	ldr	r3, [pc, #216]	; (100e310 <gatt_indicate+0xf4>)
		return -EPERM;
 100e236:	f04f 35ff 	mov.w	r5, #4294967295
		LOG_WRN("Link is not encrypted");
 100e23a:	9305      	str	r3, [sp, #20]
 100e23c:	2302      	movs	r3, #2
 100e23e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100e242:	4834      	ldr	r0, [pc, #208]	; (100e314 <gatt_indicate+0xf8>)
 100e244:	aa04      	add	r2, sp, #16
 100e246:	9304      	str	r3, [sp, #16]
 100e248:	f01a f86a 	bl	1028320 <z_log_msg_static_create.constprop.0>
}
 100e24c:	4628      	mov	r0, r5
 100e24e:	b006      	add	sp, #24
 100e250:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (!bt_gatt_is_subscribed(conn, params->attr, BT_GATT_CCC_INDICATE)) {
 100e254:	2202      	movs	r2, #2
 100e256:	4630      	mov	r0, r6
 100e258:	6869      	ldr	r1, [r5, #4]
 100e25a:	f7ff ff11 	bl	100e080 <bt_gatt_is_subscribed>
 100e25e:	b960      	cbnz	r0, 100e27a <gatt_indicate+0x5e>
			LOG_WRN("Device is not subscribed to characteristic");
 100e260:	4b2d      	ldr	r3, [pc, #180]	; (100e318 <gatt_indicate+0xfc>)
 100e262:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100e266:	9305      	str	r3, [sp, #20]
 100e268:	2302      	movs	r3, #2
 100e26a:	482a      	ldr	r0, [pc, #168]	; (100e314 <gatt_indicate+0xf8>)
 100e26c:	aa04      	add	r2, sp, #16
 100e26e:	9304      	str	r3, [sp, #16]
			return -EINVAL;
 100e270:	f06f 0515 	mvn.w	r5, #21
			LOG_WRN("Device is not subscribed to characteristic");
 100e274:	f01a f854 	bl	1028320 <z_log_msg_static_create.constprop.0>
			return -EINVAL;
 100e278:	e7e8      	b.n	100e24c <gatt_indicate+0x30>
	req = bt_att_req_alloc(BT_ATT_TIMEOUT);
 100e27a:	f44f 2070 	mov.w	r0, #983040	; 0xf0000
 100e27e:	2100      	movs	r1, #0
	len = sizeof(*ind) + params->len;
 100e280:	8aaf      	ldrh	r7, [r5, #20]
	req = bt_att_req_alloc(BT_ATT_TIMEOUT);
 100e282:	f7fe fbfb 	bl	100ca7c <bt_att_req_alloc>
	len = sizeof(*ind) + params->len;
 100e286:	3702      	adds	r7, #2
	if (!req) {
 100e288:	4604      	mov	r4, r0
 100e28a:	b1d0      	cbz	r0, 100e2c2 <gatt_indicate+0xa6>
	req->att_op = op;
 100e28c:	211d      	movs	r1, #29
	req->func = func;
 100e28e:	4b23      	ldr	r3, [pc, #140]	; (100e31c <gatt_indicate+0x100>)
	req->len = len;
 100e290:	6147      	str	r7, [r0, #20]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE, len);
 100e292:	463a      	mov	r2, r7
	req->att_op = op;
 100e294:	7441      	strb	r1, [r0, #17]
	req->encode = encode;
 100e296:	f8c0 800c 	str.w	r8, [r0, #12]
	req->func = func;
 100e29a:	6043      	str	r3, [r0, #4]
	req->user_data = params;
 100e29c:	6185      	str	r5, [r0, #24]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE, len);
 100e29e:	4630      	mov	r0, r6
 100e2a0:	f7fe f916 	bl	100c4d0 <bt_att_create_pdu>
	if (!buf) {
 100e2a4:	4607      	mov	r7, r0
 100e2a6:	b978      	cbnz	r0, 100e2c8 <gatt_indicate+0xac>
		LOG_WRN("No buffer available to send indication");
 100e2a8:	4b1d      	ldr	r3, [pc, #116]	; (100e320 <gatt_indicate+0x104>)
 100e2aa:	481a      	ldr	r0, [pc, #104]	; (100e314 <gatt_indicate+0xf8>)
 100e2ac:	9305      	str	r3, [sp, #20]
 100e2ae:	2302      	movs	r3, #2
 100e2b0:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100e2b4:	aa04      	add	r2, sp, #16
 100e2b6:	9304      	str	r3, [sp, #16]
 100e2b8:	f01a f832 	bl	1028320 <z_log_msg_static_create.constprop.0>
		bt_att_req_free(req);
 100e2bc:	4620      	mov	r0, r4
 100e2be:	f7fe fbff 	bl	100cac0 <bt_att_req_free>
		return -ENOMEM;
 100e2c2:	f06f 050b 	mvn.w	r5, #11
 100e2c6:	e7c1      	b.n	100e24c <gatt_indicate+0x30>
	bt_att_set_tx_meta_data(buf, NULL, NULL, BT_ATT_CHAN_OPT(params));
 100e2c8:	2301      	movs	r3, #1
 100e2ca:	4642      	mov	r2, r8
 100e2cc:	4641      	mov	r1, r8
	return net_buf_simple_add(&buf->b, len);
 100e2ce:	f107 0a0c 	add.w	sl, r7, #12
 100e2d2:	f019 ff32 	bl	102813a <bt_att_set_tx_meta_data>
 100e2d6:	2102      	movs	r1, #2
 100e2d8:	4650      	mov	r0, sl
 100e2da:	f00f ffdd 	bl	101e298 <net_buf_simple_add>
	ind->handle = sys_cpu_to_le16(handle);
 100e2de:	4680      	mov	r8, r0
 100e2e0:	f828 9b02 	strh.w	r9, [r8], #2
 100e2e4:	8aa9      	ldrh	r1, [r5, #20]
 100e2e6:	4650      	mov	r0, sl
 100e2e8:	f00f ffd6 	bl	101e298 <net_buf_simple_add>
	memcpy(ind->value, params->data, params->len);
 100e2ec:	8aaa      	ldrh	r2, [r5, #20]
 100e2ee:	6929      	ldr	r1, [r5, #16]
 100e2f0:	4640      	mov	r0, r8
 100e2f2:	f018 fb3f 	bl	1026974 <memcpy>
	err = bt_att_req_send(conn, req);
 100e2f6:	4621      	mov	r1, r4
 100e2f8:	4630      	mov	r0, r6
	req->buf = buf;
 100e2fa:	60a7      	str	r7, [r4, #8]
	err = bt_att_req_send(conn, req);
 100e2fc:	f7fe fd1e 	bl	100cd3c <bt_att_req_send>
	if (err) {
 100e300:	4605      	mov	r5, r0
 100e302:	2800      	cmp	r0, #0
 100e304:	d0a2      	beq.n	100e24c <gatt_indicate+0x30>
		bt_att_req_free(req);
 100e306:	4620      	mov	r0, r4
 100e308:	f7fe fbda 	bl	100cac0 <bt_att_req_free>
 100e30c:	e79e      	b.n	100e24c <gatt_indicate+0x30>
 100e30e:	bf00      	nop
 100e310:	0102e6d0 	.word	0x0102e6d0
 100e314:	0102999c 	.word	0x0102999c
 100e318:	0102e6e6 	.word	0x0102e6e6
 100e31c:	01028181 	.word	0x01028181
 100e320:	0102e711 	.word	0x0102e711

0100e324 <bt_gatt_indicate>:
{
 100e324:	b530      	push	{r4, r5, lr}
 100e326:	4605      	mov	r5, r0
	__ASSERT(params, "invalid parameters\n");
 100e328:	460c      	mov	r4, r1
{
 100e32a:	b08b      	sub	sp, #44	; 0x2c
	__ASSERT(params, "invalid parameters\n");
 100e32c:	b971      	cbnz	r1, 100e34c <bt_gatt_indicate+0x28>
 100e32e:	4946      	ldr	r1, [pc, #280]	; (100e448 <bt_gatt_indicate+0x124>)
 100e330:	f640 330d 	movw	r3, #2829	; 0xb0d
 100e334:	4a45      	ldr	r2, [pc, #276]	; (100e44c <bt_gatt_indicate+0x128>)
 100e336:	4846      	ldr	r0, [pc, #280]	; (100e450 <bt_gatt_indicate+0x12c>)
 100e338:	f016 fc4d 	bl	1024bd6 <assert_print>
 100e33c:	4845      	ldr	r0, [pc, #276]	; (100e454 <bt_gatt_indicate+0x130>)
 100e33e:	f016 fc4a 	bl	1024bd6 <assert_print>
 100e342:	f640 310d 	movw	r1, #2829	; 0xb0d
	__ASSERT(params->attr || params->uuid, "invalid parameters\n");
 100e346:	4841      	ldr	r0, [pc, #260]	; (100e44c <bt_gatt_indicate+0x128>)
 100e348:	f016 fc3e 	bl	1024bc8 <assert_post_action>
 100e34c:	684b      	ldr	r3, [r1, #4]
 100e34e:	b973      	cbnz	r3, 100e36e <bt_gatt_indicate+0x4a>
 100e350:	680b      	ldr	r3, [r1, #0]
 100e352:	b963      	cbnz	r3, 100e36e <bt_gatt_indicate+0x4a>
 100e354:	4940      	ldr	r1, [pc, #256]	; (100e458 <bt_gatt_indicate+0x134>)
 100e356:	f640 330e 	movw	r3, #2830	; 0xb0e
 100e35a:	4a3c      	ldr	r2, [pc, #240]	; (100e44c <bt_gatt_indicate+0x128>)
 100e35c:	483c      	ldr	r0, [pc, #240]	; (100e450 <bt_gatt_indicate+0x12c>)
 100e35e:	f016 fc3a 	bl	1024bd6 <assert_print>
 100e362:	483c      	ldr	r0, [pc, #240]	; (100e454 <bt_gatt_indicate+0x130>)
 100e364:	f016 fc37 	bl	1024bd6 <assert_print>
 100e368:	f640 310e 	movw	r1, #2830	; 0xb0e
 100e36c:	e7eb      	b.n	100e346 <bt_gatt_indicate+0x22>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
 100e36e:	483b      	ldr	r0, [pc, #236]	; (100e45c <bt_gatt_indicate+0x138>)
 100e370:	f019 ff94 	bl	102829c <atomic_get>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
 100e374:	0742      	lsls	r2, r0, #29
 100e376:	d561      	bpl.n	100e43c <bt_gatt_indicate+0x118>
	if (conn && conn->state != BT_CONN_CONNECTED) {
 100e378:	b115      	cbz	r5, 100e380 <bt_gatt_indicate+0x5c>
 100e37a:	7b6b      	ldrb	r3, [r5, #13]
 100e37c:	2b07      	cmp	r3, #7
 100e37e:	d160      	bne.n	100e442 <bt_gatt_indicate+0x11e>
	data.attr = params->attr;
 100e380:	6860      	ldr	r0, [r4, #4]
 100e382:	9005      	str	r0, [sp, #20]
	data.handle = bt_gatt_attr_get_handle(data.attr);
 100e384:	f7ff fb30 	bl	100d9e8 <bt_gatt_attr_get_handle>
	if (params->uuid) {
 100e388:	6822      	ldr	r2, [r4, #0]
	data.handle = bt_gatt_attr_get_handle(data.attr);
 100e38a:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (params->uuid) {
 100e38e:	b33a      	cbz	r2, 100e3e0 <bt_gatt_indicate+0xbc>
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
 100e390:	a905      	add	r1, sp, #20
 100e392:	9102      	str	r1, [sp, #8]
 100e394:	4932      	ldr	r1, [pc, #200]	; (100e460 <bt_gatt_indicate+0x13c>)
	found->attr = NULL;
 100e396:	2300      	movs	r3, #0
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
 100e398:	9101      	str	r1, [sp, #4]
 100e39a:	2101      	movs	r1, #1
 100e39c:	9100      	str	r1, [sp, #0]
 100e39e:	f64f 71ff 	movw	r1, #65535	; 0xffff
	found->attr = NULL;
 100e3a2:	9305      	str	r3, [sp, #20]
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
 100e3a4:	f7ff fb68 	bl	100da78 <bt_gatt_foreach_attr_type>
	return found->attr ? true : false;
 100e3a8:	9b05      	ldr	r3, [sp, #20]
		if (!gatt_find_by_uuid(&data, params->uuid)) {
 100e3aa:	b91b      	cbnz	r3, 100e3b4 <bt_gatt_indicate+0x90>
			return -ENOENT;
 100e3ac:	f06f 0001 	mvn.w	r0, #1
}
 100e3b0:	b00b      	add	sp, #44	; 0x2c
 100e3b2:	bd30      	pop	{r4, r5, pc}
		params->attr = data.attr;
 100e3b4:	6063      	str	r3, [r4, #4]
	if (!bt_uuid_cmp(data.attr->uuid, BT_UUID_GATT_CHRC)) {
 100e3b6:	9b05      	ldr	r3, [sp, #20]
 100e3b8:	a904      	add	r1, sp, #16
 100e3ba:	6818      	ldr	r0, [r3, #0]
 100e3bc:	2300      	movs	r3, #0
 100e3be:	f88d 3010 	strb.w	r3, [sp, #16]
 100e3c2:	f642 0303 	movw	r3, #10243	; 0x2803
 100e3c6:	f8ad 3012 	strh.w	r3, [sp, #18]
 100e3ca:	f018 fb79 	bl	1026ac0 <bt_uuid_cmp>
 100e3ce:	b970      	cbnz	r0, 100e3ee <bt_gatt_indicate+0xca>
		struct bt_gatt_chrc *chrc = data.attr->user_data;
 100e3d0:	9805      	ldr	r0, [sp, #20]
		if (!(chrc->properties & BT_GATT_CHRC_INDICATE)) {
 100e3d2:	68c3      	ldr	r3, [r0, #12]
 100e3d4:	799b      	ldrb	r3, [r3, #6]
 100e3d6:	069b      	lsls	r3, r3, #26
 100e3d8:	d405      	bmi.n	100e3e6 <bt_gatt_indicate+0xc2>
			return -EINVAL;
 100e3da:	f06f 0015 	mvn.w	r0, #21
 100e3de:	e7e7      	b.n	100e3b0 <bt_gatt_indicate+0x8c>
		if (!data.handle) {
 100e3e0:	2800      	cmp	r0, #0
 100e3e2:	d1e8      	bne.n	100e3b6 <bt_gatt_indicate+0x92>
 100e3e4:	e7e2      	b.n	100e3ac <bt_gatt_indicate+0x88>
		data.handle = bt_gatt_attr_value_handle(data.attr);
 100e3e6:	f01a f87c 	bl	10284e2 <bt_gatt_attr_value_handle>
 100e3ea:	f8ad 0018 	strh.w	r0, [sp, #24]
		return gatt_indicate(conn, data.handle, params);
 100e3ee:	f8bd 0018 	ldrh.w	r0, [sp, #24]
	if (conn) {
 100e3f2:	b13d      	cbz	r5, 100e404 <bt_gatt_indicate+0xe0>
		params->_ref = 1;
 100e3f4:	2301      	movs	r3, #1
		return gatt_indicate(conn, data.handle, params);
 100e3f6:	4601      	mov	r1, r0
 100e3f8:	4622      	mov	r2, r4
 100e3fa:	4628      	mov	r0, r5
		params->_ref = 1;
 100e3fc:	75a3      	strb	r3, [r4, #22]
		return gatt_indicate(conn, data.handle, params);
 100e3fe:	f7ff ff0d 	bl	100e21c <gatt_indicate>
 100e402:	e7d5      	b.n	100e3b0 <bt_gatt_indicate+0x8c>
	data.err = -ENOTCONN;
 100e404:	f06f 037f 	mvn.w	r3, #127	; 0x7f
 100e408:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_INDICATE;
 100e40a:	2302      	movs	r3, #2
 100e40c:	f8ad 3020 	strh.w	r3, [sp, #32]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
 100e410:	f642 1302 	movw	r3, #10498	; 0x2902
 100e414:	f8ad 3012 	strh.w	r3, [sp, #18]
 100e418:	ab05      	add	r3, sp, #20
	params->_ref = 0;
 100e41a:	75a5      	strb	r5, [r4, #22]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
 100e41c:	9302      	str	r3, [sp, #8]
 100e41e:	4b11      	ldr	r3, [pc, #68]	; (100e464 <bt_gatt_indicate+0x140>)
 100e420:	f64f 71ff 	movw	r1, #65535	; 0xffff
 100e424:	9301      	str	r3, [sp, #4]
 100e426:	2301      	movs	r3, #1
 100e428:	aa04      	add	r2, sp, #16
 100e42a:	9300      	str	r3, [sp, #0]
 100e42c:	462b      	mov	r3, r5
	data.ind_params = params;
 100e42e:	9409      	str	r4, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
 100e430:	f88d 5010 	strb.w	r5, [sp, #16]
 100e434:	f7ff fb20 	bl	100da78 <bt_gatt_foreach_attr_type>
	return data.err;
 100e438:	9807      	ldr	r0, [sp, #28]
 100e43a:	e7b9      	b.n	100e3b0 <bt_gatt_indicate+0x8c>
		return -EAGAIN;
 100e43c:	f06f 000a 	mvn.w	r0, #10
 100e440:	e7b6      	b.n	100e3b0 <bt_gatt_indicate+0x8c>
		return -ENOTCONN;
 100e442:	f06f 007f 	mvn.w	r0, #127	; 0x7f
 100e446:	e7b3      	b.n	100e3b0 <bt_gatt_indicate+0x8c>
 100e448:	0102e04a 	.word	0x0102e04a
 100e44c:	0102e3f4 	.word	0x0102e3f4
 100e450:	0102b695 	.word	0x0102b695
 100e454:	0102e647 	.word	0x0102e647
 100e458:	0102e738 	.word	0x0102e738
 100e45c:	210000cc 	.word	0x210000cc
 100e460:	010281a7 	.word	0x010281a7
 100e464:	0100e831 	.word	0x0100e831

0100e468 <sc_process>:
{
 100e468:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	__ASSERT(!atomic_test_bit(sc->flags, SC_INDICATE_PENDING),
 100e46a:	f100 0530 	add.w	r5, r0, #48	; 0x30
{
 100e46e:	4604      	mov	r4, r0
	__ASSERT(!atomic_test_bit(sc->flags, SC_INDICATE_PENDING),
 100e470:	f1a0 0720 	sub.w	r7, r0, #32
 100e474:	4628      	mov	r0, r5
 100e476:	f019 ff11 	bl	102829c <atomic_get>
 100e47a:	0783      	lsls	r3, r0, #30
 100e47c:	f3c0 0640 	ubfx	r6, r0, #1, #1
 100e480:	d50e      	bpl.n	100e4a0 <sc_process+0x38>
 100e482:	4919      	ldr	r1, [pc, #100]	; (100e4e8 <sc_process+0x80>)
 100e484:	f240 439a 	movw	r3, #1178	; 0x49a
 100e488:	4a18      	ldr	r2, [pc, #96]	; (100e4ec <sc_process+0x84>)
 100e48a:	4819      	ldr	r0, [pc, #100]	; (100e4f0 <sc_process+0x88>)
 100e48c:	f016 fba3 	bl	1024bd6 <assert_print>
 100e490:	4818      	ldr	r0, [pc, #96]	; (100e4f4 <sc_process+0x8c>)
 100e492:	f016 fba0 	bl	1024bd6 <assert_print>
 100e496:	f240 419a 	movw	r1, #1178	; 0x49a
 100e49a:	4814      	ldr	r0, [pc, #80]	; (100e4ec <sc_process+0x84>)
 100e49c:	f016 fb94 	bl	1024bc8 <assert_post_action>
	sc_range[0] = sys_cpu_to_le16(sc->start);
 100e4a0:	f854 3c08 	ldr.w	r3, [r4, #-8]
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 100e4a4:	f06f 0101 	mvn.w	r1, #1
 100e4a8:	4628      	mov	r0, r5
 100e4aa:	9301      	str	r3, [sp, #4]
 100e4ac:	f019 ff07 	bl	10282be <atomic_and>
	sc->params.attr = &_1_gatt_svc.attrs[2];
 100e4b0:	4b11      	ldr	r3, [pc, #68]	; (100e4f8 <sc_process+0x90>)
	if (bt_gatt_indicate(NULL, &sc->params)) {
 100e4b2:	4639      	mov	r1, r7
	sc->params.attr = &_1_gatt_svc.attrs[2];
 100e4b4:	f844 3c1c 	str.w	r3, [r4, #-28]
	sc->params.func = sc_indicate_rsp;
 100e4b8:	4b10      	ldr	r3, [pc, #64]	; (100e4fc <sc_process+0x94>)
	if (bt_gatt_indicate(NULL, &sc->params)) {
 100e4ba:	4630      	mov	r0, r6
	sc->params.func = sc_indicate_rsp;
 100e4bc:	f844 3c18 	str.w	r3, [r4, #-24]
	sc->params.data = &sc_range[0];
 100e4c0:	ab01      	add	r3, sp, #4
 100e4c2:	f844 3c10 	str.w	r3, [r4, #-16]
	sc->params.len = sizeof(sc_range);
 100e4c6:	2304      	movs	r3, #4
	sc->start = 0U;
 100e4c8:	f824 6c08 	strh.w	r6, [r4, #-8]
	sc->end = 0U;
 100e4cc:	f824 6c06 	strh.w	r6, [r4, #-6]
	sc->params.len = sizeof(sc_range);
 100e4d0:	f824 3c0c 	strh.w	r3, [r4, #-12]
	if (bt_gatt_indicate(NULL, &sc->params)) {
 100e4d4:	f7ff ff26 	bl	100e324 <bt_gatt_indicate>
 100e4d8:	b918      	cbnz	r0, 100e4e2 <sc_process+0x7a>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
 100e4da:	2102      	movs	r1, #2
 100e4dc:	4628      	mov	r0, r5
 100e4de:	f019 fee0 	bl	10282a2 <atomic_or>
}
 100e4e2:	b003      	add	sp, #12
 100e4e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 100e4e6:	bf00      	nop
 100e4e8:	0102e755 	.word	0x0102e755
 100e4ec:	0102e3f4 	.word	0x0102e3f4
 100e4f0:	0102b695 	.word	0x0102b695
 100e4f4:	0102e786 	.word	0x0102e786
 100e4f8:	0102a094 	.word	0x0102a094
 100e4fc:	0100d91d 	.word	0x0100d91d

0100e500 <update_ccc>:
{
 100e500:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100e504:	b089      	sub	sp, #36	; 0x24
 100e506:	4690      	mov	r8, r2
	struct bt_conn *conn = data->conn;
 100e508:	6814      	ldr	r4, [r2, #0]
	if (attr->write != bt_gatt_attr_write_ccc) {
 100e50a:	4b3d      	ldr	r3, [pc, #244]	; (100e600 <update_ccc+0x100>)
 100e50c:	6882      	ldr	r2, [r0, #8]
{
 100e50e:	4605      	mov	r5, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
 100e510:	429a      	cmp	r2, r3
{
 100e512:	af00      	add	r7, sp, #0
	if (attr->write != bt_gatt_attr_write_ccc) {
 100e514:	d16e      	bne.n	100e5f4 <update_ccc+0xf4>
	ccc = attr->user_data;
 100e516:	f8d0 900c 	ldr.w	r9, [r0, #12]
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
 100e51a:	f109 0601 	add.w	r6, r9, #1
 100e51e:	f109 0a51 	add.w	sl, r9, #81	; 0x51
		if (!cfg->value ||
 100e522:	f8b6 3007 	ldrh.w	r3, [r6, #7]
 100e526:	b1eb      	cbz	r3, 100e564 <update_ccc+0x64>
		    !bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
 100e528:	4632      	mov	r2, r6
 100e52a:	4620      	mov	r0, r4
 100e52c:	f816 1c01 	ldrb.w	r1, [r6, #-1]
 100e530:	f018 feae 	bl	1027290 <bt_conn_is_peer_addr_le>
		if (!cfg->value ||
 100e534:	b1b0      	cbz	r0, 100e564 <update_ccc+0x64>
		err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_WRITE_MASK);
 100e536:	f44f 7295 	mov.w	r2, #298	; 0x12a
 100e53a:	4629      	mov	r1, r5
 100e53c:	4620      	mov	r0, r4
 100e53e:	f01a f82b 	bl	1028598 <bt_gatt_check_perm>
		if (err) {
 100e542:	b328      	cbz	r0, 100e590 <update_ccc+0x90>
			if (err == BT_ATT_ERR_WRITE_NOT_PERMITTED) {
 100e544:	2803      	cmp	r0, #3
 100e546:	d111      	bne.n	100e56c <update_ccc+0x6c>
				LOG_WRN("CCC %p not writable", attr);
 100e548:	46eb      	mov	fp, sp
 100e54a:	b088      	sub	sp, #32
 100e54c:	466a      	mov	r2, sp
 100e54e:	4b2d      	ldr	r3, [pc, #180]	; (100e604 <update_ccc+0x104>)
 100e550:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100e554:	e9c2 3505 	strd	r3, r5, [r2, #20]
 100e558:	f842 0f10 	str.w	r0, [r2, #16]!
 100e55c:	482a      	ldr	r0, [pc, #168]	; (100e608 <update_ccc+0x108>)
 100e55e:	f019 fedf 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100e562:	46dd      	mov	sp, fp
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
 100e564:	360a      	adds	r6, #10
 100e566:	4556      	cmp	r6, sl
 100e568:	d1db      	bne.n	100e522 <update_ccc+0x22>
 100e56a:	e043      	b.n	100e5f4 <update_ccc+0xf4>
			sec = BT_SECURITY_L2;
 100e56c:	2805      	cmp	r0, #5
			    bt_conn_get_security(conn) < sec) {
 100e56e:	4620      	mov	r0, r4
			sec = BT_SECURITY_L2;
 100e570:	bf0c      	ite	eq
 100e572:	f04f 0b03 	moveq.w	fp, #3
 100e576:	f04f 0b02 	movne.w	fp, #2
			    bt_conn_get_security(conn) < sec) {
 100e57a:	f018 fe87 	bl	102728c <bt_conn_get_security>
			if (IS_ENABLED(CONFIG_BT_SMP) &&
 100e57e:	4583      	cmp	fp, r0
 100e580:	d906      	bls.n	100e590 <update_ccc+0x90>
				if (data->sec < sec) {
 100e582:	f898 3004 	ldrb.w	r3, [r8, #4]
 100e586:	455b      	cmp	r3, fp
 100e588:	d2ec      	bcs.n	100e564 <update_ccc+0x64>
					data->sec = sec;
 100e58a:	f888 b004 	strb.w	fp, [r8, #4]
 100e58e:	e7e9      	b.n	100e564 <update_ccc+0x64>
		gatt_ccc_changed(attr, ccc);
 100e590:	4649      	mov	r1, r9
 100e592:	4628      	mov	r0, r5
 100e594:	f019 fddb 	bl	102814e <gatt_ccc_changed>
		if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) &&
 100e598:	4b1c      	ldr	r3, [pc, #112]	; (100e60c <update_ccc+0x10c>)
 100e59a:	4599      	cmp	r9, r3
 100e59c:	d12a      	bne.n	100e5f4 <update_ccc+0xf4>
	cfg = find_sc_cfg(conn->id, &conn->le.dst);
 100e59e:	7a20      	ldrb	r0, [r4, #8]
 100e5a0:	f104 0190 	add.w	r1, r4, #144	; 0x90
 100e5a4:	f7fe fc22 	bl	100cdec <find_sc_cfg>
	if (!cfg) {
 100e5a8:	b320      	cbz	r0, 100e5f4 <update_ccc+0xf4>
	if (!(cfg->data.start || cfg->data.end)) {
 100e5aa:	8902      	ldrh	r2, [r0, #8]
 100e5ac:	8943      	ldrh	r3, [r0, #10]
 100e5ae:	ea53 0102 	orrs.w	r1, r3, r2
 100e5b2:	d01f      	beq.n	100e5f4 <update_ccc+0xf4>
	sc_range[1] = sys_cpu_to_le16(cfg->data.end);
 100e5b4:	80fb      	strh	r3, [r7, #6]
	index = bt_conn_index(conn);
 100e5b6:	4620      	mov	r0, r4
	sc_range[0] = sys_cpu_to_le16(cfg->data.start);
 100e5b8:	80ba      	strh	r2, [r7, #4]
	index = bt_conn_index(conn);
 100e5ba:	f7fb febb 	bl	100a334 <bt_conn_index>
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
 100e5be:	2318      	movs	r3, #24
 100e5c0:	4913      	ldr	r1, [pc, #76]	; (100e610 <update_ccc+0x110>)
 100e5c2:	fb03 1100 	mla	r1, r3, r0, r1
 100e5c6:	4b13      	ldr	r3, [pc, #76]	; (100e614 <update_ccc+0x114>)
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
 100e5c8:	4620      	mov	r0, r4
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
 100e5ca:	604b      	str	r3, [r1, #4]
	sc_restore_params[index].func = sc_restore_rsp;
 100e5cc:	4b12      	ldr	r3, [pc, #72]	; (100e618 <update_ccc+0x118>)
 100e5ce:	608b      	str	r3, [r1, #8]
	sc_restore_params[index].data = &sc_range[0];
 100e5d0:	1d3b      	adds	r3, r7, #4
 100e5d2:	610b      	str	r3, [r1, #16]
	sc_restore_params[index].len = sizeof(sc_range);
 100e5d4:	2304      	movs	r3, #4
 100e5d6:	828b      	strh	r3, [r1, #20]
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
 100e5d8:	f7ff fea4 	bl	100e324 <bt_gatt_indicate>
 100e5dc:	b150      	cbz	r0, 100e5f4 <update_ccc+0xf4>
		LOG_ERR("SC restore indication failed");
 100e5de:	4b0f      	ldr	r3, [pc, #60]	; (100e61c <update_ccc+0x11c>)
 100e5e0:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100e5e4:	61fb      	str	r3, [r7, #28]
 100e5e6:	2302      	movs	r3, #2
 100e5e8:	4807      	ldr	r0, [pc, #28]	; (100e608 <update_ccc+0x108>)
 100e5ea:	61bb      	str	r3, [r7, #24]
 100e5ec:	f107 0218 	add.w	r2, r7, #24
 100e5f0:	f019 fe96 	bl	1028320 <z_log_msg_static_create.constprop.0>
}
 100e5f4:	2001      	movs	r0, #1
 100e5f6:	3724      	adds	r7, #36	; 0x24
 100e5f8:	46bd      	mov	sp, r7
 100e5fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 100e5fe:	bf00      	nop
 100e600:	0100d791 	.word	0x0100d791
 100e604:	0102e7a1 	.word	0x0102e7a1
 100e608:	0102999c 	.word	0x0102999c
 100e60c:	21000440 	.word	0x21000440
 100e610:	210047e4 	.word	0x210047e4
 100e614:	0102a094 	.word	0x0102a094
 100e618:	0102849b 	.word	0x0102849b
 100e61c:	0102e7b5 	.word	0x0102e7b5

0100e620 <gatt_notify>:
{
 100e620:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100e624:	4614      	mov	r4, r2
 100e626:	4688      	mov	r8, r1
 100e628:	b087      	sub	sp, #28
	if (bt_gatt_check_perm(conn, params->attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
 100e62a:	2294      	movs	r2, #148	; 0x94
 100e62c:	6861      	ldr	r1, [r4, #4]
{
 100e62e:	4606      	mov	r6, r0
	if (bt_gatt_check_perm(conn, params->attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
 100e630:	f019 ffb2 	bl	1028598 <bt_gatt_check_perm>
 100e634:	b170      	cbz	r0, 100e654 <gatt_notify+0x34>
		LOG_WRN("Link is not encrypted");
 100e636:	4b2b      	ldr	r3, [pc, #172]	; (100e6e4 <gatt_notify+0xc4>)
 100e638:	482b      	ldr	r0, [pc, #172]	; (100e6e8 <gatt_notify+0xc8>)
 100e63a:	9305      	str	r3, [sp, #20]
 100e63c:	2302      	movs	r3, #2
 100e63e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100e642:	aa04      	add	r2, sp, #16
 100e644:	9304      	str	r3, [sp, #16]
 100e646:	f019 fe6b 	bl	1028320 <z_log_msg_static_create.constprop.0>
		return -EPERM;
 100e64a:	f04f 30ff 	mov.w	r0, #4294967295
}
 100e64e:	b007      	add	sp, #28
 100e650:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (!bt_gatt_is_subscribed(conn, params->attr, BT_GATT_CCC_NOTIFY)) {
 100e654:	2201      	movs	r2, #1
 100e656:	4630      	mov	r0, r6
 100e658:	6861      	ldr	r1, [r4, #4]
 100e65a:	f7ff fd11 	bl	100e080 <bt_gatt_is_subscribed>
 100e65e:	b960      	cbnz	r0, 100e67a <gatt_notify+0x5a>
			LOG_WRN("Device is not subscribed to characteristic");
 100e660:	4b22      	ldr	r3, [pc, #136]	; (100e6ec <gatt_notify+0xcc>)
 100e662:	4821      	ldr	r0, [pc, #132]	; (100e6e8 <gatt_notify+0xc8>)
 100e664:	9305      	str	r3, [sp, #20]
 100e666:	2302      	movs	r3, #2
 100e668:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100e66c:	aa04      	add	r2, sp, #16
 100e66e:	9304      	str	r3, [sp, #16]
 100e670:	f019 fe56 	bl	1028320 <z_log_msg_static_create.constprop.0>
			return -EINVAL;
 100e674:	f06f 0015 	mvn.w	r0, #21
 100e678:	e7e9      	b.n	100e64e <gatt_notify+0x2e>
				sizeof(*nfy) + params->len);
 100e67a:	89a2      	ldrh	r2, [r4, #12]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
 100e67c:	211b      	movs	r1, #27
 100e67e:	4630      	mov	r0, r6
 100e680:	3202      	adds	r2, #2
 100e682:	f7fd ff25 	bl	100c4d0 <bt_att_create_pdu>
	if (!buf) {
 100e686:	4605      	mov	r5, r0
 100e688:	b960      	cbnz	r0, 100e6a4 <gatt_notify+0x84>
		LOG_WRN("No buffer available to send notification");
 100e68a:	4b19      	ldr	r3, [pc, #100]	; (100e6f0 <gatt_notify+0xd0>)
 100e68c:	4816      	ldr	r0, [pc, #88]	; (100e6e8 <gatt_notify+0xc8>)
 100e68e:	9305      	str	r3, [sp, #20]
 100e690:	2302      	movs	r3, #2
 100e692:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100e696:	aa04      	add	r2, sp, #16
 100e698:	9304      	str	r3, [sp, #16]
 100e69a:	f019 fe41 	bl	1028320 <z_log_msg_static_create.constprop.0>
		return -ENOMEM;
 100e69e:	f06f 000b 	mvn.w	r0, #11
 100e6a2:	e7d4      	b.n	100e64e <gatt_notify+0x2e>
 100e6a4:	f100 090c 	add.w	r9, r0, #12
 100e6a8:	2102      	movs	r1, #2
 100e6aa:	4648      	mov	r0, r9
 100e6ac:	f00f fdf4 	bl	101e298 <net_buf_simple_add>
	nfy->handle = sys_cpu_to_le16(handle);
 100e6b0:	4607      	mov	r7, r0
 100e6b2:	f827 8b02 	strh.w	r8, [r7], #2
 100e6b6:	89a1      	ldrh	r1, [r4, #12]
 100e6b8:	4648      	mov	r0, r9
 100e6ba:	f00f fded 	bl	101e298 <net_buf_simple_add>
	memcpy(nfy->value, params->data, params->len);
 100e6be:	89a2      	ldrh	r2, [r4, #12]
 100e6c0:	68a1      	ldr	r1, [r4, #8]
 100e6c2:	4638      	mov	r0, r7
 100e6c4:	f018 f956 	bl	1026974 <memcpy>
	bt_att_set_tx_meta_data(buf, params->func, params->user_data, BT_ATT_CHAN_OPT(params));
 100e6c8:	e9d4 1204 	ldrd	r1, r2, [r4, #16]
 100e6cc:	4628      	mov	r0, r5
 100e6ce:	2301      	movs	r3, #1
 100e6d0:	f019 fd33 	bl	102813a <bt_att_set_tx_meta_data>
	return bt_att_send(conn, buf);
 100e6d4:	4629      	mov	r1, r5
 100e6d6:	4630      	mov	r0, r6
}
 100e6d8:	b007      	add	sp, #28
 100e6da:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return bt_att_send(conn, buf);
 100e6de:	f7fe bacb 	b.w	100cc78 <bt_att_send>
 100e6e2:	bf00      	nop
 100e6e4:	0102e6d0 	.word	0x0102e6d0
 100e6e8:	0102999c 	.word	0x0102999c
 100e6ec:	0102e6e6 	.word	0x0102e6e6
 100e6f0:	0102e7d2 	.word	0x0102e7d2

0100e6f4 <bt_gatt_notify_cb>:
{
 100e6f4:	b530      	push	{r4, r5, lr}
 100e6f6:	4605      	mov	r5, r0
	__ASSERT(params, "invalid parameters\n");
 100e6f8:	460c      	mov	r4, r1
{
 100e6fa:	b08b      	sub	sp, #44	; 0x2c
	__ASSERT(params, "invalid parameters\n");
 100e6fc:	b971      	cbnz	r1, 100e71c <bt_gatt_notify_cb+0x28>
 100e6fe:	4944      	ldr	r1, [pc, #272]	; (100e810 <bt_gatt_notify_cb+0x11c>)
 100e700:	f640 232d 	movw	r3, #2605	; 0xa2d
 100e704:	4a43      	ldr	r2, [pc, #268]	; (100e814 <bt_gatt_notify_cb+0x120>)
 100e706:	4844      	ldr	r0, [pc, #272]	; (100e818 <bt_gatt_notify_cb+0x124>)
 100e708:	f016 fa65 	bl	1024bd6 <assert_print>
 100e70c:	4843      	ldr	r0, [pc, #268]	; (100e81c <bt_gatt_notify_cb+0x128>)
 100e70e:	f016 fa62 	bl	1024bd6 <assert_print>
 100e712:	f640 212d 	movw	r1, #2605	; 0xa2d
	__ASSERT(params->attr || params->uuid, "invalid parameters\n");
 100e716:	483f      	ldr	r0, [pc, #252]	; (100e814 <bt_gatt_notify_cb+0x120>)
 100e718:	f016 fa56 	bl	1024bc8 <assert_post_action>
 100e71c:	684b      	ldr	r3, [r1, #4]
 100e71e:	b973      	cbnz	r3, 100e73e <bt_gatt_notify_cb+0x4a>
 100e720:	680b      	ldr	r3, [r1, #0]
 100e722:	b963      	cbnz	r3, 100e73e <bt_gatt_notify_cb+0x4a>
 100e724:	493e      	ldr	r1, [pc, #248]	; (100e820 <bt_gatt_notify_cb+0x12c>)
 100e726:	f640 232e 	movw	r3, #2606	; 0xa2e
 100e72a:	4a3a      	ldr	r2, [pc, #232]	; (100e814 <bt_gatt_notify_cb+0x120>)
 100e72c:	483a      	ldr	r0, [pc, #232]	; (100e818 <bt_gatt_notify_cb+0x124>)
 100e72e:	f016 fa52 	bl	1024bd6 <assert_print>
 100e732:	483a      	ldr	r0, [pc, #232]	; (100e81c <bt_gatt_notify_cb+0x128>)
 100e734:	f016 fa4f 	bl	1024bd6 <assert_print>
 100e738:	f640 212e 	movw	r1, #2606	; 0xa2e
 100e73c:	e7eb      	b.n	100e716 <bt_gatt_notify_cb+0x22>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
 100e73e:	4839      	ldr	r0, [pc, #228]	; (100e824 <bt_gatt_notify_cb+0x130>)
 100e740:	f019 fdac 	bl	102829c <atomic_get>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
 100e744:	0742      	lsls	r2, r0, #29
 100e746:	d55d      	bpl.n	100e804 <bt_gatt_notify_cb+0x110>
	if (conn && conn->state != BT_CONN_CONNECTED) {
 100e748:	b115      	cbz	r5, 100e750 <bt_gatt_notify_cb+0x5c>
 100e74a:	7b6b      	ldrb	r3, [r5, #13]
 100e74c:	2b07      	cmp	r3, #7
 100e74e:	d15c      	bne.n	100e80a <bt_gatt_notify_cb+0x116>
	data.attr = params->attr;
 100e750:	6860      	ldr	r0, [r4, #4]
 100e752:	9005      	str	r0, [sp, #20]
	data.handle = bt_gatt_attr_get_handle(data.attr);
 100e754:	f7ff f948 	bl	100d9e8 <bt_gatt_attr_get_handle>
	if (params->uuid) {
 100e758:	6822      	ldr	r2, [r4, #0]
	data.handle = bt_gatt_attr_get_handle(data.attr);
 100e75a:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (params->uuid) {
 100e75e:	b33a      	cbz	r2, 100e7b0 <bt_gatt_notify_cb+0xbc>
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
 100e760:	a905      	add	r1, sp, #20
 100e762:	9102      	str	r1, [sp, #8]
 100e764:	4930      	ldr	r1, [pc, #192]	; (100e828 <bt_gatt_notify_cb+0x134>)
	found->attr = NULL;
 100e766:	2300      	movs	r3, #0
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
 100e768:	9101      	str	r1, [sp, #4]
 100e76a:	2101      	movs	r1, #1
 100e76c:	9100      	str	r1, [sp, #0]
 100e76e:	f64f 71ff 	movw	r1, #65535	; 0xffff
	found->attr = NULL;
 100e772:	9305      	str	r3, [sp, #20]
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
 100e774:	f7ff f980 	bl	100da78 <bt_gatt_foreach_attr_type>
	return found->attr ? true : false;
 100e778:	9b05      	ldr	r3, [sp, #20]
		if (!gatt_find_by_uuid(&data, params->uuid)) {
 100e77a:	b91b      	cbnz	r3, 100e784 <bt_gatt_notify_cb+0x90>
			return -ENOENT;
 100e77c:	f06f 0001 	mvn.w	r0, #1
}
 100e780:	b00b      	add	sp, #44	; 0x2c
 100e782:	bd30      	pop	{r4, r5, pc}
		params->attr = data.attr;
 100e784:	6063      	str	r3, [r4, #4]
	if (!bt_uuid_cmp(data.attr->uuid, BT_UUID_GATT_CHRC)) {
 100e786:	9b05      	ldr	r3, [sp, #20]
 100e788:	a904      	add	r1, sp, #16
 100e78a:	6818      	ldr	r0, [r3, #0]
 100e78c:	2300      	movs	r3, #0
 100e78e:	f88d 3010 	strb.w	r3, [sp, #16]
 100e792:	f642 0303 	movw	r3, #10243	; 0x2803
 100e796:	f8ad 3012 	strh.w	r3, [sp, #18]
 100e79a:	f018 f991 	bl	1026ac0 <bt_uuid_cmp>
 100e79e:	b970      	cbnz	r0, 100e7be <bt_gatt_notify_cb+0xca>
		struct bt_gatt_chrc *chrc = data.attr->user_data;
 100e7a0:	9805      	ldr	r0, [sp, #20]
		if (!(chrc->properties & BT_GATT_CHRC_NOTIFY)) {
 100e7a2:	68c3      	ldr	r3, [r0, #12]
 100e7a4:	799b      	ldrb	r3, [r3, #6]
 100e7a6:	06db      	lsls	r3, r3, #27
 100e7a8:	d405      	bmi.n	100e7b6 <bt_gatt_notify_cb+0xc2>
			return -EINVAL;
 100e7aa:	f06f 0015 	mvn.w	r0, #21
 100e7ae:	e7e7      	b.n	100e780 <bt_gatt_notify_cb+0x8c>
		if (!data.handle) {
 100e7b0:	2800      	cmp	r0, #0
 100e7b2:	d1e8      	bne.n	100e786 <bt_gatt_notify_cb+0x92>
 100e7b4:	e7e2      	b.n	100e77c <bt_gatt_notify_cb+0x88>
		data.handle = bt_gatt_attr_value_handle(data.attr);
 100e7b6:	f019 fe94 	bl	10284e2 <bt_gatt_attr_value_handle>
 100e7ba:	f8ad 0018 	strh.w	r0, [sp, #24]
		return gatt_notify(conn, data.handle, params);
 100e7be:	f8bd 0018 	ldrh.w	r0, [sp, #24]
	if (conn) {
 100e7c2:	b12d      	cbz	r5, 100e7d0 <bt_gatt_notify_cb+0xdc>
		return gatt_notify(conn, data.handle, params);
 100e7c4:	4601      	mov	r1, r0
 100e7c6:	4622      	mov	r2, r4
 100e7c8:	4628      	mov	r0, r5
 100e7ca:	f7ff ff29 	bl	100e620 <gatt_notify>
 100e7ce:	e7d7      	b.n	100e780 <bt_gatt_notify_cb+0x8c>
	data.err = -ENOTCONN;
 100e7d0:	f06f 037f 	mvn.w	r3, #127	; 0x7f
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
 100e7d4:	f642 1202 	movw	r2, #10498	; 0x2902
	data.err = -ENOTCONN;
 100e7d8:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_NOTIFY;
 100e7da:	2301      	movs	r3, #1
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
 100e7dc:	f8ad 2012 	strh.w	r2, [sp, #18]
 100e7e0:	aa05      	add	r2, sp, #20
 100e7e2:	9202      	str	r2, [sp, #8]
 100e7e4:	4a11      	ldr	r2, [pc, #68]	; (100e82c <bt_gatt_notify_cb+0x138>)
	data.type = BT_GATT_CCC_NOTIFY;
 100e7e6:	f8ad 3020 	strh.w	r3, [sp, #32]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
 100e7ea:	e9cd 3200 	strd	r3, r2, [sp]
 100e7ee:	f64f 71ff 	movw	r1, #65535	; 0xffff
 100e7f2:	462b      	mov	r3, r5
 100e7f4:	aa04      	add	r2, sp, #16
	data.nfy_params = params;
 100e7f6:	9409      	str	r4, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
 100e7f8:	f88d 5010 	strb.w	r5, [sp, #16]
 100e7fc:	f7ff f93c 	bl	100da78 <bt_gatt_foreach_attr_type>
	return data.err;
 100e800:	9807      	ldr	r0, [sp, #28]
 100e802:	e7bd      	b.n	100e780 <bt_gatt_notify_cb+0x8c>
		return -EAGAIN;
 100e804:	f06f 000a 	mvn.w	r0, #10
 100e808:	e7ba      	b.n	100e780 <bt_gatt_notify_cb+0x8c>
		return -ENOTCONN;
 100e80a:	f06f 007f 	mvn.w	r0, #127	; 0x7f
 100e80e:	e7b7      	b.n	100e780 <bt_gatt_notify_cb+0x8c>
 100e810:	0102e04a 	.word	0x0102e04a
 100e814:	0102e3f4 	.word	0x0102e3f4
 100e818:	0102b695 	.word	0x0102b695
 100e81c:	0102e647 	.word	0x0102e647
 100e820:	0102e738 	.word	0x0102e738
 100e824:	210000cc 	.word	0x210000cc
 100e828:	010281a7 	.word	0x010281a7
 100e82c:	0100e831 	.word	0x0100e831

0100e830 <notify_cb>:
{
 100e830:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
 100e834:	4b47      	ldr	r3, [pc, #284]	; (100e954 <notify_cb+0x124>)
{
 100e836:	4615      	mov	r5, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
 100e838:	6882      	ldr	r2, [r0, #8]
{
 100e83a:	4680      	mov	r8, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
 100e83c:	429a      	cmp	r2, r3
{
 100e83e:	b087      	sub	sp, #28
	if (attr->write != bt_gatt_attr_write_ccc) {
 100e840:	d139      	bne.n	100e8b6 <notify_cb+0x86>
	ccc = attr->user_data;
 100e842:	f8d0 a00c 	ldr.w	sl, [r0, #12]
	if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) && ccc == &sc_ccc) {
 100e846:	4b44      	ldr	r3, [pc, #272]	; (100e958 <notify_cb+0x128>)
 100e848:	459a      	cmp	sl, r3
 100e84a:	d11c      	bne.n	100e886 <notify_cb+0x56>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
 100e84c:	2600      	movs	r6, #0
 100e84e:	4c43      	ldr	r4, [pc, #268]	; (100e95c <notify_cb+0x12c>)
			if (bt_addr_le_eq(&cfg->peer, BT_ADDR_LE_ANY)) {
 100e850:	4f43      	ldr	r7, [pc, #268]	; (100e960 <notify_cb+0x130>)
 100e852:	4639      	mov	r1, r7
 100e854:	4620      	mov	r0, r4
 100e856:	f019 fcff 	bl	1028258 <bt_addr_le_eq>
 100e85a:	b978      	cbnz	r0, 100e87c <notify_cb+0x4c>
			conn = bt_conn_lookup_state_le(cfg->id, &cfg->peer,
 100e85c:	2207      	movs	r2, #7
 100e85e:	4621      	mov	r1, r4
 100e860:	f814 0c01 	ldrb.w	r0, [r4, #-1]
 100e864:	f7fb ff6a 	bl	100a73c <bt_conn_lookup_state_le>
			if (!conn) {
 100e868:	bb40      	cbnz	r0, 100e8bc <notify_cb+0x8c>
				sc = (struct sc_data *)data->ind_params->data;
 100e86a:	692b      	ldr	r3, [r5, #16]
				sc_save(cfg->id, &cfg->peer,
 100e86c:	4621      	mov	r1, r4
				sc = (struct sc_data *)data->ind_params->data;
 100e86e:	691a      	ldr	r2, [r3, #16]
				sc_save(cfg->id, &cfg->peer,
 100e870:	f814 0c01 	ldrb.w	r0, [r4, #-1]
 100e874:	8853      	ldrh	r3, [r2, #2]
 100e876:	8812      	ldrh	r2, [r2, #0]
 100e878:	f7fe fcc8 	bl	100d20c <sc_save>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
 100e87c:	3601      	adds	r6, #1
 100e87e:	2e0d      	cmp	r6, #13
 100e880:	f104 040c 	add.w	r4, r4, #12
 100e884:	d1e5      	bne.n	100e852 <notify_cb+0x22>
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
 100e886:	f10a 0601 	add.w	r6, sl, #1
 100e88a:	f10a 0b51 	add.w	fp, sl, #81	; 0x51
		if (cfg->value != data->type) {
 100e88e:	f8b6 2007 	ldrh.w	r2, [r6, #7]
 100e892:	89ab      	ldrh	r3, [r5, #12]
 100e894:	429a      	cmp	r2, r3
 100e896:	d10b      	bne.n	100e8b0 <notify_cb+0x80>
		conn = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
 100e898:	4631      	mov	r1, r6
 100e89a:	f816 0c01 	ldrb.w	r0, [r6, #-1]
 100e89e:	f7fb fef9 	bl	100a694 <bt_conn_lookup_addr_le>
		if (!conn) {
 100e8a2:	4604      	mov	r4, r0
 100e8a4:	b120      	cbz	r0, 100e8b0 <notify_cb+0x80>
		if (conn->state != BT_CONN_CONNECTED) {
 100e8a6:	7b43      	ldrb	r3, [r0, #13]
 100e8a8:	2b07      	cmp	r3, #7
 100e8aa:	d00a      	beq.n	100e8c2 <notify_cb+0x92>
			bt_conn_unref(conn);
 100e8ac:	f7fb fbf6 	bl	100a09c <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
 100e8b0:	360a      	adds	r6, #10
 100e8b2:	45b3      	cmp	fp, r6
 100e8b4:	d1eb      	bne.n	100e88e <notify_cb+0x5e>
		return BT_GATT_ITER_CONTINUE;
 100e8b6:	f04f 0901 	mov.w	r9, #1
 100e8ba:	e046      	b.n	100e94a <notify_cb+0x11a>
			bt_conn_unref(conn);
 100e8bc:	f7fb fbee 	bl	100a09c <bt_conn_unref>
 100e8c0:	e7dc      	b.n	100e87c <notify_cb+0x4c>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
 100e8c2:	f8da 305c 	ldr.w	r3, [sl, #92]	; 0x5c
 100e8c6:	b123      	cbz	r3, 100e8d2 <notify_cb+0xa2>
 100e8c8:	4641      	mov	r1, r8
 100e8ca:	4798      	blx	r3
 100e8cc:	b908      	cbnz	r0, 100e8d2 <notify_cb+0xa2>
			bt_conn_unref(conn);
 100e8ce:	4620      	mov	r0, r4
 100e8d0:	e7ec      	b.n	100e8ac <notify_cb+0x7c>
		if (bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
 100e8d2:	2294      	movs	r2, #148	; 0x94
 100e8d4:	4641      	mov	r1, r8
 100e8d6:	4620      	mov	r0, r4
 100e8d8:	f019 fe5e 	bl	1028598 <bt_gatt_check_perm>
 100e8dc:	4681      	mov	r9, r0
 100e8de:	b150      	cbz	r0, 100e8f6 <notify_cb+0xc6>
			LOG_WRN("Link is not encrypted");
 100e8e0:	4b20      	ldr	r3, [pc, #128]	; (100e964 <notify_cb+0x134>)
 100e8e2:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100e8e6:	9305      	str	r3, [sp, #20]
 100e8e8:	2302      	movs	r3, #2
 100e8ea:	481f      	ldr	r0, [pc, #124]	; (100e968 <notify_cb+0x138>)
 100e8ec:	aa04      	add	r2, sp, #16
 100e8ee:	9304      	str	r3, [sp, #16]
 100e8f0:	f019 fd16 	bl	1028320 <z_log_msg_static_create.constprop.0>
			bt_conn_unref(conn);
 100e8f4:	e7eb      	b.n	100e8ce <notify_cb+0x9e>
		if ((data->type == BT_GATT_CCC_INDICATE) &&
 100e8f6:	89ab      	ldrh	r3, [r5, #12]
 100e8f8:	2b02      	cmp	r3, #2
 100e8fa:	d115      	bne.n	100e928 <notify_cb+0xf8>
 100e8fc:	f8b6 3007 	ldrh.w	r3, [r6, #7]
 100e900:	079a      	lsls	r2, r3, #30
 100e902:	d405      	bmi.n	100e910 <notify_cb+0xe0>
		bt_conn_unref(conn);
 100e904:	4620      	mov	r0, r4
 100e906:	f7fb fbc9 	bl	100a09c <bt_conn_unref>
		data->err = 0;
 100e90a:	2300      	movs	r3, #0
 100e90c:	60ab      	str	r3, [r5, #8]
 100e90e:	e7cf      	b.n	100e8b0 <notify_cb+0x80>
			err = gatt_indicate(conn, data->handle, data->ind_params);
 100e910:	4620      	mov	r0, r4
 100e912:	692a      	ldr	r2, [r5, #16]
 100e914:	88a9      	ldrh	r1, [r5, #4]
 100e916:	f7ff fc81 	bl	100e21c <gatt_indicate>
			if (err == 0) {
 100e91a:	4607      	mov	r7, r0
 100e91c:	b980      	cbnz	r0, 100e940 <notify_cb+0x110>
				data->ind_params->_ref++;
 100e91e:	692a      	ldr	r2, [r5, #16]
 100e920:	7d93      	ldrb	r3, [r2, #22]
 100e922:	3301      	adds	r3, #1
 100e924:	7593      	strb	r3, [r2, #22]
		bt_conn_unref(conn);
 100e926:	e7ed      	b.n	100e904 <notify_cb+0xd4>
		} else if ((data->type == BT_GATT_CCC_NOTIFY) &&
 100e928:	2b01      	cmp	r3, #1
 100e92a:	d1eb      	bne.n	100e904 <notify_cb+0xd4>
 100e92c:	f8b6 3007 	ldrh.w	r3, [r6, #7]
 100e930:	07db      	lsls	r3, r3, #31
 100e932:	d5e7      	bpl.n	100e904 <notify_cb+0xd4>
			err = gatt_notify(conn, data->handle, data->nfy_params);
 100e934:	4620      	mov	r0, r4
 100e936:	692a      	ldr	r2, [r5, #16]
 100e938:	88a9      	ldrh	r1, [r5, #4]
 100e93a:	f7ff fe71 	bl	100e620 <gatt_notify>
 100e93e:	4607      	mov	r7, r0
		bt_conn_unref(conn);
 100e940:	4620      	mov	r0, r4
 100e942:	f7fb fbab 	bl	100a09c <bt_conn_unref>
		if (err < 0) {
 100e946:	2f00      	cmp	r7, #0
 100e948:	dadf      	bge.n	100e90a <notify_cb+0xda>
}
 100e94a:	4648      	mov	r0, r9
 100e94c:	b007      	add	sp, #28
 100e94e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 100e952:	bf00      	nop
 100e954:	0100d791 	.word	0x0100d791
 100e958:	21000440 	.word	0x21000440
 100e95c:	21008135 	.word	0x21008135
 100e960:	0102cb79 	.word	0x0102cb79
 100e964:	0102e6d0 	.word	0x0102e6d0
 100e968:	0102999c 	.word	0x0102999c

0100e96c <bt_gatt_connected>:
{
 100e96c:	b5b0      	push	{r4, r5, r7, lr}
 100e96e:	b08e      	sub	sp, #56	; 0x38
	data.sec = BT_SECURITY_L1;
 100e970:	2301      	movs	r3, #1
{
 100e972:	af02      	add	r7, sp, #8
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 100e974:	f100 0590 	add.w	r5, r0, #144	; 0x90
{
 100e978:	4604      	mov	r4, r0
	data.conn = conn;
 100e97a:	6078      	str	r0, [r7, #4]
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 100e97c:	4629      	mov	r1, r5
 100e97e:	7a00      	ldrb	r0, [r0, #8]
	data.sec = BT_SECURITY_L1;
 100e980:	723b      	strb	r3, [r7, #8]
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 100e982:	f018 f9ec 	bl	1026d5e <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
 100e986:	b198      	cbz	r0, 100e9b0 <bt_gatt_connected+0x44>
		if (conn->id) {
 100e988:	7a22      	ldrb	r2, [r4, #8]
 100e98a:	b3a2      	cbz	r2, 100e9f6 <bt_gatt_connected+0x8a>
			u8_to_dec(id_str, sizeof(id_str), conn->id);
 100e98c:	2104      	movs	r1, #4
 100e98e:	4638      	mov	r0, r7
 100e990:	f015 fe89 	bl	10246a6 <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "ccc",
 100e994:	9700      	str	r7, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "ccc",
 100e996:	2124      	movs	r1, #36	; 0x24
 100e998:	4a18      	ldr	r2, [pc, #96]	; (100e9fc <bt_gatt_connected+0x90>)
 100e99a:	f107 000c 	add.w	r0, r7, #12
 100e99e:	462b      	mov	r3, r5
 100e9a0:	f7f8 fbee 	bl	1007180 <bt_settings_encode_key>
		settings_load_subtree_direct(key, ccc_set_direct, (void *)key);
 100e9a4:	f107 020c 	add.w	r2, r7, #12
 100e9a8:	4610      	mov	r0, r2
 100e9aa:	4915      	ldr	r1, [pc, #84]	; (100ea00 <bt_gatt_connected+0x94>)
 100e9ac:	f7f6 fe32 	bl	1005614 <settings_load_subtree_direct>
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
 100e9b0:	f64f 71ff 	movw	r1, #65535	; 0xffff
 100e9b4:	2001      	movs	r0, #1
 100e9b6:	4a13      	ldr	r2, [pc, #76]	; (100ea04 <bt_gatt_connected+0x98>)
 100e9b8:	1d3b      	adds	r3, r7, #4
 100e9ba:	f019 fde0 	bl	102857e <bt_gatt_foreach_attr>
	    bt_conn_get_security(conn) < data.sec) {
 100e9be:	4620      	mov	r0, r4
 100e9c0:	f018 fc64 	bl	102728c <bt_conn_get_security>
 100e9c4:	7a39      	ldrb	r1, [r7, #8]
	if (IS_ENABLED(CONFIG_BT_SMP) &&
 100e9c6:	4288      	cmp	r0, r1
 100e9c8:	d212      	bcs.n	100e9f0 <bt_gatt_connected+0x84>
		int err = bt_conn_set_security(conn, data.sec);
 100e9ca:	4620      	mov	r0, r4
 100e9cc:	f018 fc32 	bl	1027234 <bt_conn_set_security>
		if (err) {
 100e9d0:	b170      	cbz	r0, 100e9f0 <bt_gatt_connected+0x84>
			LOG_WRN("Failed to set security for bonded peer (%d)", err);
 100e9d2:	466c      	mov	r4, sp
 100e9d4:	b088      	sub	sp, #32
 100e9d6:	aa02      	add	r2, sp, #8
 100e9d8:	4b0b      	ldr	r3, [pc, #44]	; (100ea08 <bt_gatt_connected+0x9c>)
 100e9da:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100e9de:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100e9e2:	2303      	movs	r3, #3
 100e9e4:	4809      	ldr	r0, [pc, #36]	; (100ea0c <bt_gatt_connected+0xa0>)
 100e9e6:	f842 3f10 	str.w	r3, [r2, #16]!
 100e9ea:	f019 fc99 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100e9ee:	46a5      	mov	sp, r4
}
 100e9f0:	3730      	adds	r7, #48	; 0x30
 100e9f2:	46bd      	mov	sp, r7
 100e9f4:	bdb0      	pop	{r4, r5, r7, pc}
			bt_settings_encode_key(key, sizeof(key), "ccc",
 100e9f6:	9200      	str	r2, [sp, #0]
 100e9f8:	e7cd      	b.n	100e996 <bt_gatt_connected+0x2a>
 100e9fa:	bf00      	nop
 100e9fc:	0102e69c 	.word	0x0102e69c
 100ea00:	0100df31 	.word	0x0100df31
 100ea04:	0100e501 	.word	0x0100e501
 100ea08:	0102e7fb 	.word	0x0102e7fb
 100ea0c:	0102999c 	.word	0x0102999c

0100ea10 <bt_gatt_att_max_mtu_changed>:
{
 100ea10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100ea12:	4605      	mov	r5, r0
 100ea14:	460e      	mov	r6, r1
 100ea16:	4617      	mov	r7, r2
	return list->head;
 100ea18:	4b06      	ldr	r3, [pc, #24]	; (100ea34 <bt_gatt_att_max_mtu_changed+0x24>)
 100ea1a:	681c      	ldr	r4, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&callback_list, cb, node) {
 100ea1c:	b14c      	cbz	r4, 100ea32 <bt_gatt_att_max_mtu_changed+0x22>
		if (cb->att_mtu_updated) {
 100ea1e:	f854 3c04 	ldr.w	r3, [r4, #-4]
	SYS_SLIST_FOR_EACH_CONTAINER(&callback_list, cb, node) {
 100ea22:	3c04      	subs	r4, #4
		if (cb->att_mtu_updated) {
 100ea24:	b11b      	cbz	r3, 100ea2e <bt_gatt_att_max_mtu_changed+0x1e>
			cb->att_mtu_updated(conn, tx, rx);
 100ea26:	463a      	mov	r2, r7
 100ea28:	4631      	mov	r1, r6
 100ea2a:	4628      	mov	r0, r5
 100ea2c:	4798      	blx	r3
	return node->next;
 100ea2e:	6864      	ldr	r4, [r4, #4]
 100ea30:	e7f4      	b.n	100ea1c <bt_gatt_att_max_mtu_changed+0xc>
}
 100ea32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 100ea34:	21004984 	.word	0x21004984

0100ea38 <bt_gatt_encrypt_change>:
{
 100ea38:	b507      	push	{r0, r1, r2, lr}
	data.conn = conn;
 100ea3a:	9000      	str	r0, [sp, #0]
	data.sec = BT_SECURITY_L1;
 100ea3c:	2001      	movs	r0, #1
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
 100ea3e:	466b      	mov	r3, sp
 100ea40:	f64f 71ff 	movw	r1, #65535	; 0xffff
 100ea44:	4a03      	ldr	r2, [pc, #12]	; (100ea54 <bt_gatt_encrypt_change+0x1c>)
	data.sec = BT_SECURITY_L1;
 100ea46:	f88d 0004 	strb.w	r0, [sp, #4]
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
 100ea4a:	f019 fd98 	bl	102857e <bt_gatt_foreach_attr>
}
 100ea4e:	b003      	add	sp, #12
 100ea50:	f85d fb04 	ldr.w	pc, [sp], #4
 100ea54:	0100e501 	.word	0x0100e501

0100ea58 <bt_gatt_store_ccc>:
	save.count = 0;
 100ea58:	2300      	movs	r3, #0
{
 100ea5a:	b5f0      	push	{r4, r5, r6, r7, lr}
 100ea5c:	4604      	mov	r4, r0
 100ea5e:	b0c1      	sub	sp, #260	; 0x104
 100ea60:	af02      	add	r7, sp, #8
 100ea62:	460d      	mov	r5, r1
	save.addr_with_id.addr = addr;
 100ea64:	62f9      	str	r1, [r7, #44]	; 0x2c
	save.addr_with_id.id = id;
 100ea66:	f887 0030 	strb.w	r0, [r7, #48]	; 0x30
	save.count = 0;
 100ea6a:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
	bt_gatt_foreach_attr(0x0001, 0xffff, ccc_save, &save);
 100ea6e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 100ea72:	2001      	movs	r0, #1
 100ea74:	4a1b      	ldr	r2, [pc, #108]	; (100eae4 <bt_gatt_store_ccc+0x8c>)
 100ea76:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 100ea7a:	f019 fd80 	bl	102857e <bt_gatt_foreach_attr>
	if (id) {
 100ea7e:	b364      	cbz	r4, 100eada <bt_gatt_store_ccc+0x82>
		u8_to_dec(id_str, sizeof(id_str), id);
 100ea80:	1d3e      	adds	r6, r7, #4
 100ea82:	4622      	mov	r2, r4
 100ea84:	2104      	movs	r1, #4
 100ea86:	4630      	mov	r0, r6
 100ea88:	f015 fe0d 	bl	10246a6 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, id_str);
 100ea8c:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, NULL);
 100ea8e:	4a16      	ldr	r2, [pc, #88]	; (100eae8 <bt_gatt_store_ccc+0x90>)
 100ea90:	462b      	mov	r3, r5
 100ea92:	2124      	movs	r1, #36	; 0x24
 100ea94:	f107 0008 	add.w	r0, r7, #8
 100ea98:	f7f8 fb72 	bl	1007180 <bt_settings_encode_key>
	if (save.count) {
 100ea9c:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 100eaa0:	b1ea      	cbz	r2, 100eade <bt_gatt_store_ccc+0x86>
		len = save.count * sizeof(*save.store);
 100eaa2:	0092      	lsls	r2, r2, #2
		str = (char *)save.store;
 100eaa4:	f107 0134 	add.w	r1, r7, #52	; 0x34
	err = settings_save_one(key, str, len);
 100eaa8:	f107 0008 	add.w	r0, r7, #8
 100eaac:	f7f6 fd52 	bl	1005554 <settings_save_one>
	if (err) {
 100eab0:	4604      	mov	r4, r0
 100eab2:	b170      	cbz	r0, 100ead2 <bt_gatt_store_ccc+0x7a>
		LOG_ERR("Failed to store CCCs (err %d)", err);
 100eab4:	466d      	mov	r5, sp
 100eab6:	b088      	sub	sp, #32
 100eab8:	aa02      	add	r2, sp, #8
 100eaba:	4b0c      	ldr	r3, [pc, #48]	; (100eaec <bt_gatt_store_ccc+0x94>)
 100eabc:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100eac0:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100eac4:	2303      	movs	r3, #3
 100eac6:	480a      	ldr	r0, [pc, #40]	; (100eaf0 <bt_gatt_store_ccc+0x98>)
 100eac8:	f842 3f10 	str.w	r3, [r2, #16]!
 100eacc:	f019 fc28 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100ead0:	46ad      	mov	sp, r5
}
 100ead2:	4620      	mov	r0, r4
 100ead4:	37fc      	adds	r7, #252	; 0xfc
 100ead6:	46bd      	mov	sp, r7
 100ead8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, NULL);
 100eada:	9400      	str	r4, [sp, #0]
 100eadc:	e7d7      	b.n	100ea8e <bt_gatt_store_ccc+0x36>
		str = NULL;
 100eade:	4611      	mov	r1, r2
 100eae0:	e7e2      	b.n	100eaa8 <bt_gatt_store_ccc+0x50>
 100eae2:	bf00      	nop
 100eae4:	0100d559 	.word	0x0100d559
 100eae8:	0102e69c 	.word	0x0102e69c
 100eaec:	0102e827 	.word	0x0102e827
 100eaf0:	0102999c 	.word	0x0102999c

0100eaf4 <bt_gatt_disconnected>:

	return 0;
}

void bt_gatt_disconnected(struct bt_conn *conn)
{
 100eaf4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100eaf8:	4604      	mov	r4, r0
 100eafa:	b08c      	sub	sp, #48	; 0x30
	LOG_DBG("conn %p", conn);
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
 100eafc:	4603      	mov	r3, r0
 100eafe:	f64f 71ff 	movw	r1, #65535	; 0xffff
 100eb02:	2001      	movs	r0, #1
 100eb04:	4a41      	ldr	r2, [pc, #260]	; (100ec0c <bt_gatt_disconnected+0x118>)
{
 100eb06:	af02      	add	r7, sp, #8
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
 100eb08:	f019 fd39 	bl	102857e <bt_gatt_foreach_attr>
	uint8_t index = bt_conn_index(conn);
 100eb0c:	4620      	mov	r0, r4
 100eb0e:	f7fb fc11 	bl	100a334 <bt_conn_index>
	if (gatt_ccc_store.conn_list[index] != NULL) {
 100eb12:	4e3f      	ldr	r6, [pc, #252]	; (100ec10 <bt_gatt_disconnected+0x11c>)
	uint8_t index = bt_conn_index(conn);
 100eb14:	4605      	mov	r5, r0
	if (gatt_ccc_store.conn_list[index] != NULL) {
 100eb16:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 100eb1a:	b120      	cbz	r0, 100eb26 <bt_gatt_disconnected+0x32>
		bt_conn_unref(gatt_ccc_store.conn_list[index]);
 100eb1c:	f7fb fabe 	bl	100a09c <bt_conn_unref>
		gatt_ccc_store.conn_list[index] = NULL;
 100eb20:	2300      	movs	r3, #0
 100eb22:	f846 3025 	str.w	r3, [r6, r5, lsl #2]
	for (size_t i = 0; i < CONFIG_BT_MAX_CONN; i++) {
 100eb26:	2300      	movs	r3, #0
 100eb28:	4a39      	ldr	r2, [pc, #228]	; (100ec10 <bt_gatt_disconnected+0x11c>)
		if (gatt_ccc_store.conn_list[i]) {
 100eb2a:	f852 1b04 	ldr.w	r1, [r2], #4
 100eb2e:	b929      	cbnz	r1, 100eb3c <bt_gatt_disconnected+0x48>
	for (size_t i = 0; i < CONFIG_BT_MAX_CONN; i++) {
 100eb30:	3301      	adds	r3, #1
 100eb32:	2b08      	cmp	r3, #8
 100eb34:	d1f9      	bne.n	100eb2a <bt_gatt_disconnected+0x36>

#if defined(CONFIG_BT_SETTINGS_CCC_STORE_ON_WRITE)
	gatt_ccc_conn_unqueue(conn);

	if (gatt_ccc_conn_queue_is_empty()) {
		k_work_cancel_delayable(&gatt_ccc_store.work);
 100eb36:	4837      	ldr	r0, [pc, #220]	; (100ec14 <bt_gatt_disconnected+0x120>)
 100eb38:	f013 fb0a 	bl	1022150 <k_work_cancel_delayable>
	}
#endif

	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 100eb3c:	f104 0590 	add.w	r5, r4, #144	; 0x90
 100eb40:	4629      	mov	r1, r5
 100eb42:	7a20      	ldrb	r0, [r4, #8]
 100eb44:	f018 f90b 	bl	1026d5e <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
 100eb48:	2800      	cmp	r0, #0
 100eb4a:	d038      	beq.n	100ebbe <bt_gatt_disconnected+0xca>
		bt_gatt_store_ccc(conn->id, &conn->le.dst);
 100eb4c:	4629      	mov	r1, r5
 100eb4e:	7a20      	ldrb	r0, [r4, #8]
 100eb50:	f7ff ff82 	bl	100ea58 <bt_gatt_store_ccc>
	cfg = find_cf_cfg(conn);
 100eb54:	4620      	mov	r0, r4
 100eb56:	f7fe f927 	bl	100cda8 <find_cf_cfg>
	if (!cfg) {
 100eb5a:	4606      	mov	r6, r0
 100eb5c:	2800      	cmp	r0, #0
 100eb5e:	d04e      	beq.n	100ebfe <bt_gatt_disconnected+0x10a>
		if (conn->id) {
 100eb60:	7a22      	ldrb	r2, [r4, #8]
		len = 0;
 100eb62:	f04f 0801 	mov.w	r8, #1
		str = (char *)cfg->data;
 100eb66:	3608      	adds	r6, #8
		if (conn->id) {
 100eb68:	b162      	cbz	r2, 100eb84 <bt_gatt_disconnected+0x90>
			u8_to_dec(id_str, sizeof(id_str), conn->id);
 100eb6a:	2104      	movs	r1, #4
 100eb6c:	4638      	mov	r0, r7
 100eb6e:	f015 fd9a 	bl	10246a6 <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "cf",
 100eb72:	462b      	mov	r3, r5
 100eb74:	2124      	movs	r1, #36	; 0x24
 100eb76:	4a28      	ldr	r2, [pc, #160]	; (100ec18 <bt_gatt_disconnected+0x124>)
 100eb78:	9700      	str	r7, [sp, #0]
 100eb7a:	1d38      	adds	r0, r7, #4
 100eb7c:	f7f8 fb00 	bl	1007180 <bt_settings_encode_key>
	if (!cfg || !conn->id) {
 100eb80:	7a23      	ldrb	r3, [r4, #8]
 100eb82:	b93b      	cbnz	r3, 100eb94 <bt_gatt_disconnected+0xa0>
		bt_settings_encode_key(key, sizeof(key), "cf",
 100eb84:	2300      	movs	r3, #0
 100eb86:	2124      	movs	r1, #36	; 0x24
 100eb88:	9300      	str	r3, [sp, #0]
 100eb8a:	4a23      	ldr	r2, [pc, #140]	; (100ec18 <bt_gatt_disconnected+0x124>)
 100eb8c:	462b      	mov	r3, r5
 100eb8e:	1d38      	adds	r0, r7, #4
 100eb90:	f7f8 faf6 	bl	1007180 <bt_settings_encode_key>
	err = settings_save_one(key, str, len);
 100eb94:	4642      	mov	r2, r8
 100eb96:	4631      	mov	r1, r6
 100eb98:	1d38      	adds	r0, r7, #4
 100eb9a:	f7f6 fcdb 	bl	1005554 <settings_save_one>
	if (err) {
 100eb9e:	b170      	cbz	r0, 100ebbe <bt_gatt_disconnected+0xca>
		LOG_ERR("Failed to store Client Features (err %d)", err);
 100eba0:	466e      	mov	r6, sp
 100eba2:	b088      	sub	sp, #32
 100eba4:	aa02      	add	r2, sp, #8
 100eba6:	4b1d      	ldr	r3, [pc, #116]	; (100ec1c <bt_gatt_disconnected+0x128>)
 100eba8:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100ebac:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100ebb0:	2303      	movs	r3, #3
 100ebb2:	481b      	ldr	r0, [pc, #108]	; (100ec20 <bt_gatt_disconnected+0x12c>)
 100ebb4:	f842 3f10 	str.w	r3, [r2, #16]!
 100ebb8:	f019 fbb2 	bl	1028320 <z_log_msg_static_create.constprop.0>
 100ebbc:	46b5      	mov	sp, r6
		bt_gatt_store_cf(conn);
	}

	/* Make sure to clear the CCC entry when using lazy loading */
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 100ebbe:	4629      	mov	r1, r5
 100ebc0:	7a20      	ldrb	r0, [r4, #8]
 100ebc2:	f018 f8cc 	bl	1026d5e <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
 100ebc6:	b148      	cbz	r0, 100ebdc <bt_gatt_disconnected+0xe8>
		struct addr_with_id addr_with_id = {
 100ebc8:	7a23      	ldrb	r3, [r4, #8]
			.addr = &conn->le.dst,
			.id = conn->id,
		};
		bt_gatt_foreach_attr(0x0001, 0xffff,
 100ebca:	f64f 71ff 	movw	r1, #65535	; 0xffff
		struct addr_with_id addr_with_id = {
 100ebce:	723b      	strb	r3, [r7, #8]
		bt_gatt_foreach_attr(0x0001, 0xffff,
 100ebd0:	2001      	movs	r0, #1
 100ebd2:	4a14      	ldr	r2, [pc, #80]	; (100ec24 <bt_gatt_disconnected+0x130>)
		struct addr_with_id addr_with_id = {
 100ebd4:	607d      	str	r5, [r7, #4]
		bt_gatt_foreach_attr(0x0001, 0xffff,
 100ebd6:	1d3b      	adds	r3, r7, #4
 100ebd8:	f019 fcd1 	bl	102857e <bt_gatt_foreach_attr>
	cfg = find_cf_cfg(conn);
 100ebdc:	4620      	mov	r0, r4
 100ebde:	f7fe f8e3 	bl	100cda8 <find_cf_cfg>
	if (!cfg) {
 100ebe2:	4606      	mov	r6, r0
 100ebe4:	b138      	cbz	r0, 100ebf6 <bt_gatt_disconnected+0x102>
	if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 100ebe6:	4629      	mov	r1, r5
 100ebe8:	7a20      	ldrb	r0, [r4, #8]
 100ebea:	f018 f8b8 	bl	1026d5e <bt_addr_le_is_bonded>
 100ebee:	b940      	cbnz	r0, 100ec02 <bt_gatt_disconnected+0x10e>
		clear_cf_cfg(cfg);
 100ebf0:	4630      	mov	r0, r6
 100ebf2:	f7fe fbe9 	bl	100d3c8 <clear_cf_cfg>
#endif /* CONFIG_BT_GATT_CLIENT */

#if defined(CONFIG_BT_GATT_CACHING)
	remove_cf_cfg(conn);
#endif
}
 100ebf6:	3728      	adds	r7, #40	; 0x28
 100ebf8:	46bd      	mov	sp, r7
 100ebfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		len = 0;
 100ebfe:	4680      	mov	r8, r0
 100ec00:	e7c0      	b.n	100eb84 <bt_gatt_disconnected+0x90>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
 100ec02:	4629      	mov	r1, r5
 100ec04:	1c70      	adds	r0, r6, #1
 100ec06:	f019 fb57 	bl	10282b8 <bt_addr_le_copy>
}
 100ec0a:	e7f4      	b.n	100ebf6 <bt_gatt_disconnected+0x102>
 100ec0c:	0100d865 	.word	0x0100d865
 100ec10:	210023c8 	.word	0x210023c8
 100ec14:	210023e8 	.word	0x210023e8
 100ec18:	0102e871 	.word	0x0102e871
 100ec1c:	0102e845 	.word	0x0102e845
 100ec20:	0102999c 	.word	0x0102999c
 100ec24:	0100d531 	.word	0x0100d531

0100ec28 <smp_find>:

	return 0;
}

static struct bt_smp *smp_find(int flag)
{
 100ec28:	4601      	mov	r1, r0
 100ec2a:	2300      	movs	r3, #0
	for (int i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
		if (atomic_test_bit(bt_smp_pool[i].flags, flag)) {
 100ec2c:	4a07      	ldr	r2, [pc, #28]	; (100ec4c <smp_find+0x24>)
{
 100ec2e:	b510      	push	{r4, lr}
		if (atomic_test_bit(bt_smp_pool[i].flags, flag)) {
 100ec30:	1d14      	adds	r4, r2, #4
 100ec32:	18e0      	adds	r0, r4, r3
 100ec34:	f019 fd38 	bl	10286a8 <atomic_test_bit>
 100ec38:	b108      	cbz	r0, 100ec3e <smp_find+0x16>
			return &bt_smp_pool[i];
 100ec3a:	1898      	adds	r0, r3, r2
		}
	}

	return NULL;
}
 100ec3c:	bd10      	pop	{r4, pc}
	for (int i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
 100ec3e:	f503 7308 	add.w	r3, r3, #544	; 0x220
 100ec42:	f5b3 5f88 	cmp.w	r3, #4352	; 0x1100
 100ec46:	d1f4      	bne.n	100ec32 <smp_find+0xa>
 100ec48:	e7f8      	b.n	100ec3c <smp_find+0x14>
 100ec4a:	bf00      	nop
 100ec4c:	210024e8 	.word	0x210024e8

0100ec50 <latch_auth_cb>:
	atomic_ptr_cas(&smp->auth_cb, BT_SMP_AUTH_CB_UNINITIALIZED, (atomic_ptr_val_t)bt_auth);
 100ec50:	4b08      	ldr	r3, [pc, #32]	; (100ec74 <latch_auth_cb+0x24>)
 100ec52:	f500 7006 	add.w	r0, r0, #536	; 0x218
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 100ec56:	681a      	ldr	r2, [r3, #0]
 100ec58:	4b07      	ldr	r3, [pc, #28]	; (100ec78 <latch_auth_cb+0x28>)
 100ec5a:	e8d0 1fef 	ldaex	r1, [r0]
 100ec5e:	4299      	cmp	r1, r3
 100ec60:	d104      	bne.n	100ec6c <latch_auth_cb+0x1c>
 100ec62:	e8c0 2fec 	stlex	ip, r2, [r0]
 100ec66:	f1bc 0f00 	cmp.w	ip, #0
 100ec6a:	d1f6      	bne.n	100ec5a <latch_auth_cb+0xa>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 100ec6c:	e8d0 0faf 	lda	r0, [r0]
}
 100ec70:	4770      	bx	lr
 100ec72:	bf00      	nop
 100ec74:	2100474c 	.word	0x2100474c
 100ec78:	210024e8 	.word	0x210024e8

0100ec7c <get_io_capa>:
{
 100ec7c:	b508      	push	{r3, lr}
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100ec7e:	f7ff ffe7 	bl	100ec50 <latch_auth_cb>
	if (!smp_auth_cb) {
 100ec82:	4603      	mov	r3, r0
 100ec84:	b1c8      	cbz	r0, 100ecba <get_io_capa+0x3e>
	if (smp_auth_cb->passkey_display && smp_auth_cb->passkey_entry &&
 100ec86:	e9d0 1200 	ldrd	r1, r2, [r0]
 100ec8a:	b921      	cbnz	r1, 100ec96 <get_io_capa+0x1a>
			return BT_SMP_IO_KEYBOARD_ONLY;
 100ec8c:	2a00      	cmp	r2, #0
 100ec8e:	bf0c      	ite	eq
 100ec90:	2003      	moveq	r0, #3
 100ec92:	2002      	movne	r0, #2
 100ec94:	e010      	b.n	100ecb8 <get_io_capa+0x3c>
	if (smp_auth_cb->passkey_display && smp_auth_cb->passkey_entry &&
 100ec96:	b132      	cbz	r2, 100eca6 <get_io_capa+0x2a>
 100ec98:	6883      	ldr	r3, [r0, #8]
 100ec9a:	b913      	cbnz	r3, 100eca2 <get_io_capa+0x26>
	    (smp_auth_cb->passkey_confirm || !sc_supported)) {
 100ec9c:	4b09      	ldr	r3, [pc, #36]	; (100ecc4 <get_io_capa+0x48>)
 100ec9e:	781b      	ldrb	r3, [r3, #0]
 100eca0:	b933      	cbnz	r3, 100ecb0 <get_io_capa+0x34>
		return BT_SMP_IO_KEYBOARD_DISPLAY;
 100eca2:	2004      	movs	r0, #4
 100eca4:	e008      	b.n	100ecb8 <get_io_capa+0x3c>
	if (sc_supported && smp_auth_cb->passkey_display &&
 100eca6:	4907      	ldr	r1, [pc, #28]	; (100ecc4 <get_io_capa+0x48>)
 100eca8:	7808      	ldrb	r0, [r1, #0]
 100ecaa:	b128      	cbz	r0, 100ecb8 <get_io_capa+0x3c>
 100ecac:	689b      	ldr	r3, [r3, #8]
 100ecae:	b933      	cbnz	r3, 100ecbe <get_io_capa+0x42>
	if (smp_auth_cb->passkey_entry) {
 100ecb0:	3a00      	subs	r2, #0
 100ecb2:	bf18      	it	ne
 100ecb4:	2201      	movne	r2, #1
 100ecb6:	0050      	lsls	r0, r2, #1
}
 100ecb8:	bd08      	pop	{r3, pc}
		return BT_SMP_IO_NO_INPUT_OUTPUT;
 100ecba:	2003      	movs	r0, #3
 100ecbc:	e7fc      	b.n	100ecb8 <get_io_capa+0x3c>
		return BT_SMP_IO_DISPLAY_YESNO;
 100ecbe:	2001      	movs	r0, #1
 100ecc0:	e7fa      	b.n	100ecb8 <get_io_capa+0x3c>
 100ecc2:	bf00      	nop
 100ecc4:	21008346 	.word	0x21008346

0100ecc8 <get_auth>:
{
 100ecc8:	b510      	push	{r4, lr}
	if (sc_supported) {
 100ecca:	4b0c      	ldr	r3, [pc, #48]	; (100ecfc <get_auth+0x34>)
 100eccc:	781b      	ldrb	r3, [r3, #0]
 100ecce:	b17b      	cbz	r3, 100ecf0 <get_auth+0x28>
		auth &= BT_SMP_AUTH_MASK_SC;
 100ecd0:	f001 040f 	and.w	r4, r1, #15
	if ((get_io_capa(smp) == BT_SMP_IO_NO_INPUT_OUTPUT) ||
 100ecd4:	f7ff ffd2 	bl	100ec7c <get_io_capa>
	if (bondable) {
 100ecd8:	4b09      	ldr	r3, [pc, #36]	; (100ed00 <get_auth+0x38>)
	if ((get_io_capa(smp) == BT_SMP_IO_NO_INPUT_OUTPUT) ||
 100ecda:	2803      	cmp	r0, #3
	if (bondable) {
 100ecdc:	781b      	ldrb	r3, [r3, #0]
		auth &= ~(BT_SMP_AUTH_MITM);
 100ecde:	bf0c      	ite	eq
 100ece0:	f004 040b 	andeq.w	r4, r4, #11
		auth |= BT_SMP_AUTH_MITM;
 100ece4:	f044 0404 	orrne.w	r4, r4, #4
	if (bondable) {
 100ece8:	b12b      	cbz	r3, 100ecf6 <get_auth+0x2e>
		auth |= BT_SMP_AUTH_BONDING;
 100ecea:	f044 0001 	orr.w	r0, r4, #1
}
 100ecee:	bd10      	pop	{r4, pc}
		auth &= BT_SMP_AUTH_MASK;
 100ecf0:	f001 0407 	and.w	r4, r1, #7
 100ecf4:	e7ee      	b.n	100ecd4 <get_auth+0xc>
		auth &= ~BT_SMP_AUTH_BONDING;
 100ecf6:	f004 00fe 	and.w	r0, r4, #254	; 0xfe
 100ecfa:	e7f8      	b.n	100ecee <get_auth+0x26>
 100ecfc:	21008346 	.word	0x21008346
 100ed00:	21000bb8 	.word	0x21000bb8

0100ed04 <bt_smp_pkey_ready.part.0>:
	}

	return 0;
}

static void bt_smp_pkey_ready(const uint8_t *pkey)
 100ed04:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	LOG_DBG("");

	sc_public_key = pkey;

	if (!pkey) {
		LOG_WRN("Public key not available");
 100ed06:	4b06      	ldr	r3, [pc, #24]	; (100ed20 <bt_smp_pkey_ready.part.0+0x1c>)
 100ed08:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100ed0c:	9305      	str	r3, [sp, #20]
 100ed0e:	2302      	movs	r3, #2
 100ed10:	4804      	ldr	r0, [pc, #16]	; (100ed24 <bt_smp_pkey_ready.part.0+0x20>)
 100ed12:	aa04      	add	r2, sp, #16
 100ed14:	9304      	str	r3, [sp, #16]
 100ed16:	f019 fd18 	bl	102874a <z_log_msg_static_create.constprop.0>
		if (err) {
			smp_error(smp, err);
		}
#endif /* CONFIG_BT_PERIPHERAL */
	}
}
 100ed1a:	b007      	add	sp, #28
 100ed1c:	f85d fb04 	ldr.w	pc, [sp], #4
 100ed20:	0102e882 	.word	0x0102e882
 100ed24:	010299e4 	.word	0x010299e4

0100ed28 <bt_smp_accept.part.0>:
	} else {
		conn->le.keys->flags &= ~BT_KEYS_SC;
	}
}

static int bt_smp_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
 100ed28:	b580      	push	{r7, lr}
 100ed2a:	af00      	add	r7, sp, #0
		*chan = &smp->chan.chan;

		return 0;
	}

	LOG_ERR("No available SMP context for conn %p", conn);
 100ed2c:	b088      	sub	sp, #32
 100ed2e:	466a      	mov	r2, sp
 100ed30:	4b07      	ldr	r3, [pc, #28]	; (100ed50 <bt_smp_accept.part.0+0x28>)
 100ed32:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100ed36:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100ed3a:	2303      	movs	r3, #3
 100ed3c:	4805      	ldr	r0, [pc, #20]	; (100ed54 <bt_smp_accept.part.0+0x2c>)
 100ed3e:	f842 3f10 	str.w	r3, [r2, #16]!
 100ed42:	f019 fd02 	bl	102874a <z_log_msg_static_create.constprop.0>

	return -ENOMEM;
}
 100ed46:	f06f 000b 	mvn.w	r0, #11
 100ed4a:	46bd      	mov	sp, r7
 100ed4c:	bd80      	pop	{r7, pc}
 100ed4e:	bf00      	nop
 100ed50:	0102e89b 	.word	0x0102e89b
 100ed54:	010299e4 	.word	0x010299e4

0100ed58 <bt_smp_accept>:
{
 100ed58:	b430      	push	{r4, r5}
 100ed5a:	4c0d      	ldr	r4, [pc, #52]	; (100ed90 <bt_smp_accept+0x38>)
	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
 100ed5c:	2300      	movs	r3, #0
 100ed5e:	4622      	mov	r2, r4
		if (smp->chan.chan.conn) {
 100ed60:	f8d4 50f0 	ldr.w	r5, [r4, #240]	; 0xf0
 100ed64:	b13d      	cbz	r5, 100ed76 <bt_smp_accept+0x1e>
	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
 100ed66:	3301      	adds	r3, #1
 100ed68:	2b08      	cmp	r3, #8
 100ed6a:	f504 7408 	add.w	r4, r4, #544	; 0x220
 100ed6e:	d1f7      	bne.n	100ed60 <bt_smp_accept+0x8>
}
 100ed70:	bc30      	pop	{r4, r5}
 100ed72:	f7ff bfd9 	b.w	100ed28 <bt_smp_accept.part.0>
		smp->chan.chan.ops = &ops;
 100ed76:	f44f 7008 	mov.w	r0, #544	; 0x220
 100ed7a:	4343      	muls	r3, r0
 100ed7c:	4c05      	ldr	r4, [pc, #20]	; (100ed94 <bt_smp_accept+0x3c>)
 100ed7e:	18d0      	adds	r0, r2, r3
		*chan = &smp->chan.chan;
 100ed80:	33f0      	adds	r3, #240	; 0xf0
		smp->chan.chan.ops = &ops;
 100ed82:	f8c0 40f4 	str.w	r4, [r0, #244]	; 0xf4
		*chan = &smp->chan.chan;
 100ed86:	441a      	add	r2, r3
}
 100ed88:	4628      	mov	r0, r5
 100ed8a:	bc30      	pop	{r4, r5}
		*chan = &smp->chan.chan;
 100ed8c:	600a      	str	r2, [r1, #0]
}
 100ed8e:	4770      	bx	lr
 100ed90:	210024e8 	.word	0x210024e8
 100ed94:	0102a198 	.word	0x0102a198

0100ed98 <smp_chan_get.part.0>:
static struct bt_smp *smp_chan_get(struct bt_conn *conn)
 100ed98:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
		LOG_ERR("Unable to find SMP channel");
 100ed9a:	4b07      	ldr	r3, [pc, #28]	; (100edb8 <smp_chan_get.part.0+0x20>)
 100ed9c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100eda0:	9305      	str	r3, [sp, #20]
 100eda2:	2302      	movs	r3, #2
 100eda4:	4805      	ldr	r0, [pc, #20]	; (100edbc <smp_chan_get.part.0+0x24>)
 100eda6:	aa04      	add	r2, sp, #16
 100eda8:	9304      	str	r3, [sp, #16]
 100edaa:	f019 fcce 	bl	102874a <z_log_msg_static_create.constprop.0>
}
 100edae:	2000      	movs	r0, #0
 100edb0:	b007      	add	sp, #28
 100edb2:	f85d fb04 	ldr.w	pc, [sp], #4
 100edb6:	bf00      	nop
 100edb8:	0102e8c0 	.word	0x0102e8c0
 100edbc:	010299e4 	.word	0x010299e4

0100edc0 <smp_init>:
{
 100edc0:	b538      	push	{r3, r4, r5, lr}
 100edc2:	4605      	mov	r5, r0
	(void)memset(smp, 0, offsetof(struct bt_smp, chan));
 100edc4:	22f0      	movs	r2, #240	; 0xf0
 100edc6:	2100      	movs	r1, #0
 100edc8:	f017 fddf 	bl	102698a <memset>
	if (bt_rand(smp->prnd, 16)) {
 100edcc:	2110      	movs	r1, #16
 100edce:	f105 0027 	add.w	r0, r5, #39	; 0x27
 100edd2:	f004 fdad 	bl	1013930 <bt_rand>
 100edd6:	4604      	mov	r4, r0
 100edd8:	b948      	cbnz	r0, 100edee <smp_init+0x2e>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_FAIL);
 100edda:	2105      	movs	r1, #5
 100eddc:	4628      	mov	r0, r5
 100edde:	f019 fcc2 	bl	1028766 <atomic_set_bit>
	sc_public_key = bt_pub_key_get();
 100ede2:	f7fa fd8d 	bl	1009900 <bt_pub_key_get>
 100ede6:	4b03      	ldr	r3, [pc, #12]	; (100edf4 <smp_init+0x34>)
 100ede8:	6018      	str	r0, [r3, #0]
}
 100edea:	4620      	mov	r0, r4
 100edec:	bd38      	pop	{r3, r4, r5, pc}
		return BT_SMP_ERR_UNSPECIFIED;
 100edee:	2408      	movs	r4, #8
 100edf0:	e7fb      	b.n	100edea <smp_init+0x2a>
 100edf2:	bf00      	nop
 100edf4:	2100498c 	.word	0x2100498c

0100edf8 <smp_dhkey_generate>:
{
 100edf8:	b530      	push	{r4, r5, lr}
 100edfa:	4604      	mov	r4, r0
	atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_GEN);
 100edfc:	1d05      	adds	r5, r0, #4
 100edfe:	2108      	movs	r1, #8
 100ee00:	4628      	mov	r0, r5
{
 100ee02:	b087      	sub	sp, #28
	atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_GEN);
 100ee04:	f019 fcaf 	bl	1028766 <atomic_set_bit>
	err = bt_dh_key_gen(smp->pkey, bt_smp_dhkey_ready);
 100ee08:	490b      	ldr	r1, [pc, #44]	; (100ee38 <smp_dhkey_generate+0x40>)
 100ee0a:	f104 0057 	add.w	r0, r4, #87	; 0x57
 100ee0e:	f7fa fd85 	bl	100991c <bt_dh_key_gen>
	if (err) {
 100ee12:	b170      	cbz	r0, 100ee32 <smp_dhkey_generate+0x3a>
		atomic_clear_bit(smp->flags, SMP_FLAG_DHKEY_GEN);
 100ee14:	2108      	movs	r1, #8
 100ee16:	4628      	mov	r0, r5
 100ee18:	f019 fc6d 	bl	10286f6 <atomic_clear_bit>
		LOG_ERR("Failed to generate DHKey");
 100ee1c:	4b07      	ldr	r3, [pc, #28]	; (100ee3c <smp_dhkey_generate+0x44>)
 100ee1e:	4808      	ldr	r0, [pc, #32]	; (100ee40 <smp_dhkey_generate+0x48>)
 100ee20:	9305      	str	r3, [sp, #20]
 100ee22:	2302      	movs	r3, #2
 100ee24:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100ee28:	aa04      	add	r2, sp, #16
 100ee2a:	9304      	str	r3, [sp, #16]
 100ee2c:	f019 fc8d 	bl	102874a <z_log_msg_static_create.constprop.0>
		return BT_SMP_ERR_UNSPECIFIED;
 100ee30:	2008      	movs	r0, #8
}
 100ee32:	b007      	add	sp, #28
 100ee34:	bd30      	pop	{r4, r5, pc}
 100ee36:	bf00      	nop
 100ee38:	01028b27 	.word	0x01028b27
 100ee3c:	0102e8db 	.word	0x0102e8db
 100ee40:	010299e4 	.word	0x010299e4

0100ee44 <smp_ident_info>:
{
 100ee44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100ee46:	4604      	mov	r4, r0
 100ee48:	460b      	mov	r3, r1
 100ee4a:	af00      	add	r7, sp, #0
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
 100ee4c:	210d      	movs	r1, #13
 100ee4e:	3004      	adds	r0, #4
 100ee50:	f019 fc2a 	bl	10286a8 <atomic_test_bit>
 100ee54:	b338      	cbz	r0, 100eea6 <smp_ident_info+0x62>
		struct bt_smp_ident_info *req = (void *)buf->data;
 100ee56:	68de      	ldr	r6, [r3, #12]
		struct bt_conn *conn = smp->chan.chan.conn;
 100ee58:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
		keys = bt_keys_get_type(BT_KEYS_IRK, conn->id, &conn->le.dst);
 100ee5c:	2002      	movs	r0, #2
 100ee5e:	f103 0590 	add.w	r5, r3, #144	; 0x90
 100ee62:	462a      	mov	r2, r5
 100ee64:	7a19      	ldrb	r1, [r3, #8]
 100ee66:	f001 fd65 	bl	1010934 <bt_keys_get_type>
		if (!keys) {
 100ee6a:	b9b8      	cbnz	r0, 100ee9c <smp_ident_info+0x58>
			LOG_ERR("Unable to get keys for %s", bt_addr_le_str(&conn->le.dst));
 100ee6c:	4628      	mov	r0, r5
 100ee6e:	f7f7 feed 	bl	1006c4c <bt_addr_le_str>
 100ee72:	466c      	mov	r4, sp
 100ee74:	b088      	sub	sp, #32
 100ee76:	466a      	mov	r2, sp
 100ee78:	4b0e      	ldr	r3, [pc, #56]	; (100eeb4 <smp_ident_info+0x70>)
 100ee7a:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 100ee7e:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100ee82:	f44f 7300 	mov.w	r3, #512	; 0x200
 100ee86:	8393      	strh	r3, [r2, #28]
 100ee88:	4b0b      	ldr	r3, [pc, #44]	; (100eeb8 <smp_ident_info+0x74>)
 100ee8a:	480c      	ldr	r0, [pc, #48]	; (100eebc <smp_ident_info+0x78>)
 100ee8c:	f842 3f10 	str.w	r3, [r2, #16]!
 100ee90:	f019 fc5b 	bl	102874a <z_log_msg_static_create.constprop.0>
			return BT_SMP_ERR_UNSPECIFIED;
 100ee94:	2008      	movs	r0, #8
 100ee96:	46a5      	mov	sp, r4
}
 100ee98:	46bd      	mov	sp, r7
 100ee9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		memcpy(keys->irk.val, req->irk, 16);
 100ee9c:	2210      	movs	r2, #16
 100ee9e:	4631      	mov	r1, r6
 100eea0:	302a      	adds	r0, #42	; 0x2a
 100eea2:	f017 fd67 	bl	1026974 <memcpy>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_IDENT_ADDR_INFO);
 100eea6:	4620      	mov	r0, r4
 100eea8:	2109      	movs	r1, #9
 100eeaa:	f019 fc5c 	bl	1028766 <atomic_set_bit>
	return 0;
 100eeae:	2000      	movs	r0, #0
 100eeb0:	e7f2      	b.n	100ee98 <smp_ident_info+0x54>
 100eeb2:	bf00      	nop
 100eeb4:	0102e8f4 	.word	0x0102e8f4
 100eeb8:	01000003 	.word	0x01000003
 100eebc:	010299e4 	.word	0x010299e4

0100eec0 <smp_encrypt_info>:
{
 100eec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100eec2:	4604      	mov	r4, r0
 100eec4:	460b      	mov	r3, r1
 100eec6:	af00      	add	r7, sp, #0
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
 100eec8:	210d      	movs	r1, #13
 100eeca:	3004      	adds	r0, #4
 100eecc:	f019 fbec 	bl	10286a8 <atomic_test_bit>
 100eed0:	b338      	cbz	r0, 100ef22 <smp_encrypt_info+0x62>
		struct bt_smp_encrypt_info *req = (void *)buf->data;
 100eed2:	68de      	ldr	r6, [r3, #12]
		struct bt_conn *conn = smp->chan.chan.conn;
 100eed4:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
		keys = bt_keys_get_type(BT_KEYS_LTK, conn->id, &conn->le.dst);
 100eed8:	2004      	movs	r0, #4
 100eeda:	f103 0590 	add.w	r5, r3, #144	; 0x90
 100eede:	462a      	mov	r2, r5
 100eee0:	7a19      	ldrb	r1, [r3, #8]
 100eee2:	f001 fd27 	bl	1010934 <bt_keys_get_type>
		if (!keys) {
 100eee6:	b9b8      	cbnz	r0, 100ef18 <smp_encrypt_info+0x58>
			LOG_ERR("Unable to get keys for %s", bt_addr_le_str(&conn->le.dst));
 100eee8:	4628      	mov	r0, r5
 100eeea:	f7f7 feaf 	bl	1006c4c <bt_addr_le_str>
 100eeee:	466c      	mov	r4, sp
 100eef0:	b088      	sub	sp, #32
 100eef2:	466a      	mov	r2, sp
 100eef4:	4b0e      	ldr	r3, [pc, #56]	; (100ef30 <smp_encrypt_info+0x70>)
 100eef6:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 100eefa:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100eefe:	f44f 7300 	mov.w	r3, #512	; 0x200
 100ef02:	8393      	strh	r3, [r2, #28]
 100ef04:	4b0b      	ldr	r3, [pc, #44]	; (100ef34 <smp_encrypt_info+0x74>)
 100ef06:	480c      	ldr	r0, [pc, #48]	; (100ef38 <smp_encrypt_info+0x78>)
 100ef08:	f842 3f10 	str.w	r3, [r2, #16]!
 100ef0c:	f019 fc1d 	bl	102874a <z_log_msg_static_create.constprop.0>
			return BT_SMP_ERR_UNSPECIFIED;
 100ef10:	2008      	movs	r0, #8
 100ef12:	46a5      	mov	sp, r4
}
 100ef14:	46bd      	mov	sp, r7
 100ef16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		memcpy(keys->ltk.val, req->ltk, 16);
 100ef18:	2210      	movs	r2, #16
 100ef1a:	4631      	mov	r1, r6
 100ef1c:	301a      	adds	r0, #26
 100ef1e:	f017 fd29 	bl	1026974 <memcpy>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_CENTRAL_IDENT);
 100ef22:	4620      	mov	r0, r4
 100ef24:	2107      	movs	r1, #7
 100ef26:	f019 fc1e 	bl	1028766 <atomic_set_bit>
	return 0;
 100ef2a:	2000      	movs	r0, #0
 100ef2c:	e7f2      	b.n	100ef14 <smp_encrypt_info+0x54>
 100ef2e:	bf00      	nop
 100ef30:	0102e8f4 	.word	0x0102e8f4
 100ef34:	01000003 	.word	0x01000003
 100ef38:	010299e4 	.word	0x010299e4

0100ef3c <smp_send_pairing_confirm>:
{
 100ef3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 100ef3e:	b083      	sub	sp, #12
	switch (smp->method) {
 100ef40:	7a04      	ldrb	r4, [r0, #8]
{
 100ef42:	4605      	mov	r5, r0
	switch (smp->method) {
 100ef44:	2c02      	cmp	r4, #2
{
 100ef46:	af02      	add	r7, sp, #8
	switch (smp->method) {
 100ef48:	d823      	bhi.n	100ef92 <smp_send_pairing_confirm+0x56>
 100ef4a:	b144      	cbz	r4, 100ef5e <smp_send_pairing_confirm+0x22>
		r = (smp->passkey >> smp->passkey_round) & 0x01;
 100ef4c:	f890 30dc 	ldrb.w	r3, [r0, #220]	; 0xdc
 100ef50:	f8d0 40d8 	ldr.w	r4, [r0, #216]	; 0xd8
 100ef54:	40dc      	lsrs	r4, r3
 100ef56:	f004 0401 	and.w	r4, r4, #1
		r |= 0x80;
 100ef5a:	f044 0480 	orr.w	r4, r4, #128	; 0x80
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_CONFIRM, sizeof(*req));
 100ef5e:	2103      	movs	r1, #3
 100ef60:	4628      	mov	r0, r5
 100ef62:	f019 fc10 	bl	1028786 <smp_create_pdu.constprop.0>
	if (!buf) {
 100ef66:	4606      	mov	r6, r0
 100ef68:	b320      	cbz	r0, 100efb4 <smp_send_pairing_confirm+0x78>
 100ef6a:	2110      	movs	r1, #16
 100ef6c:	300c      	adds	r0, #12
 100ef6e:	f00f f993 	bl	101e298 <net_buf_simple_add>
	if (bt_crypto_f4(sc_public_key, smp->pkey, smp->prnd, r, req->val)) {
 100ef72:	9000      	str	r0, [sp, #0]
 100ef74:	4818      	ldr	r0, [pc, #96]	; (100efd8 <smp_send_pairing_confirm+0x9c>)
 100ef76:	4623      	mov	r3, r4
 100ef78:	6800      	ldr	r0, [r0, #0]
 100ef7a:	f105 0227 	add.w	r2, r5, #39	; 0x27
 100ef7e:	f105 0157 	add.w	r1, r5, #87	; 0x57
 100ef82:	f019 fe6f 	bl	1028c64 <bt_crypto_f4>
 100ef86:	4604      	mov	r4, r0
 100ef88:	b1d0      	cbz	r0, 100efc0 <smp_send_pairing_confirm+0x84>
		net_buf_unref(buf);
 100ef8a:	4630      	mov	r0, r6
 100ef8c:	f00f f828 	bl	101dfe0 <net_buf_unref>
		return BT_SMP_ERR_UNSPECIFIED;
 100ef90:	e010      	b.n	100efb4 <smp_send_pairing_confirm+0x78>
	switch (smp->method) {
 100ef92:	2c03      	cmp	r4, #3
 100ef94:	d012      	beq.n	100efbc <smp_send_pairing_confirm+0x80>
		LOG_ERR("Unknown pairing method (%u)", smp->method);
 100ef96:	466d      	mov	r5, sp
 100ef98:	b088      	sub	sp, #32
 100ef9a:	aa02      	add	r2, sp, #8
 100ef9c:	4b0f      	ldr	r3, [pc, #60]	; (100efdc <smp_send_pairing_confirm+0xa0>)
 100ef9e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
	switch (smp->method) {
 100efa2:	e9c2 3405 	strd	r3, r4, [r2, #20]
		LOG_ERR("Unknown pairing method (%u)", smp->method);
 100efa6:	2303      	movs	r3, #3
 100efa8:	480d      	ldr	r0, [pc, #52]	; (100efe0 <smp_send_pairing_confirm+0xa4>)
 100efaa:	f842 3f10 	str.w	r3, [r2, #16]!
 100efae:	f019 fbcc 	bl	102874a <z_log_msg_static_create.constprop.0>
 100efb2:	46ad      	mov	sp, r5
		return BT_SMP_ERR_UNSPECIFIED;
 100efb4:	2008      	movs	r0, #8
}
 100efb6:	3704      	adds	r7, #4
 100efb8:	46bd      	mov	sp, r7
 100efba:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (smp->method) {
 100efbc:	2400      	movs	r4, #0
 100efbe:	e7ce      	b.n	100ef5e <smp_send_pairing_confirm+0x22>
	smp_send(smp, buf, NULL, NULL);
 100efc0:	4602      	mov	r2, r0
 100efc2:	4631      	mov	r1, r6
 100efc4:	4628      	mov	r0, r5
 100efc6:	f019 fba3 	bl	1028710 <smp_send.constprop.0>
	atomic_clear_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
 100efca:	1d28      	adds	r0, r5, #4
 100efcc:	4621      	mov	r1, r4
 100efce:	f019 fb92 	bl	10286f6 <atomic_clear_bit>
	return 0;
 100efd2:	4620      	mov	r0, r4
 100efd4:	e7ef      	b.n	100efb6 <smp_send_pairing_confirm+0x7a>
 100efd6:	bf00      	nop
 100efd8:	2100498c 	.word	0x2100498c
 100efdc:	0102e90e 	.word	0x0102e90e
 100efe0:	010299e4 	.word	0x010299e4

0100efe4 <smp_public_key_periph>:
{
 100efe4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100efe8:	b086      	sub	sp, #24
 100efea:	4604      	mov	r4, r0
 100efec:	af00      	add	r7, sp, #0
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100efee:	f7ff fe2f 	bl	100ec50 <latch_auth_cb>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY) &&
 100eff2:	1d26      	adds	r6, r4, #4
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100eff4:	4680      	mov	r8, r0
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY) &&
 100eff6:	210e      	movs	r1, #14
 100eff8:	4630      	mov	r0, r6
 100effa:	f019 fb55 	bl	10286a8 <atomic_test_bit>
 100effe:	b9a0      	cbnz	r0, 100f02a <smp_public_key_periph+0x46>
	    memcmp(smp->pkey, sc_public_key, BT_PUB_KEY_COORD_LEN) == 0) {
 100f000:	4b52      	ldr	r3, [pc, #328]	; (100f14c <smp_public_key_periph+0x168>)
 100f002:	2220      	movs	r2, #32
 100f004:	6819      	ldr	r1, [r3, #0]
 100f006:	f104 0057 	add.w	r0, r4, #87	; 0x57
 100f00a:	f017 fca3 	bl	1026954 <memcmp>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY) &&
 100f00e:	b960      	cbnz	r0, 100f02a <smp_public_key_periph+0x46>
		LOG_WRN("Remote public key rejected");
 100f010:	4b4f      	ldr	r3, [pc, #316]	; (100f150 <smp_public_key_periph+0x16c>)
 100f012:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100f016:	617b      	str	r3, [r7, #20]
 100f018:	2302      	movs	r3, #2
 100f01a:	484e      	ldr	r0, [pc, #312]	; (100f154 <smp_public_key_periph+0x170>)
 100f01c:	613b      	str	r3, [r7, #16]
 100f01e:	f107 0210 	add.w	r2, r7, #16
 100f022:	f019 fb92 	bl	102874a <z_log_msg_static_create.constprop.0>
		return BT_SMP_ERR_UNSPECIFIED;
 100f026:	2008      	movs	r0, #8
 100f028:	e02f      	b.n	100f08a <smp_public_key_periph+0xa6>
	req_buf = smp_create_pdu(smp, BT_SMP_CMD_PUBLIC_KEY, sizeof(*req));
 100f02a:	210c      	movs	r1, #12
 100f02c:	4620      	mov	r0, r4
 100f02e:	f019 fbaa 	bl	1028786 <smp_create_pdu.constprop.0>
	if (!req_buf) {
 100f032:	4605      	mov	r5, r0
 100f034:	2800      	cmp	r0, #0
 100f036:	d0f6      	beq.n	100f026 <smp_public_key_periph+0x42>
 100f038:	2140      	movs	r1, #64	; 0x40
 100f03a:	300c      	adds	r0, #12
 100f03c:	f00f f92c 	bl	101e298 <net_buf_simple_add>
	memcpy(req->x, sc_public_key, sizeof(req->x));
 100f040:	f8df a108 	ldr.w	sl, [pc, #264]	; 100f14c <smp_public_key_periph+0x168>
 100f044:	2220      	movs	r2, #32
 100f046:	f8da 1000 	ldr.w	r1, [sl]
 100f04a:	4681      	mov	r9, r0
 100f04c:	f017 fc92 	bl	1026974 <memcpy>
	memcpy(req->y, &sc_public_key[32], sizeof(req->y));
 100f050:	2220      	movs	r2, #32
 100f052:	f8da 1000 	ldr.w	r1, [sl]
 100f056:	eb09 0002 	add.w	r0, r9, r2
 100f05a:	4411      	add	r1, r2
 100f05c:	f017 fc8a 	bl	1026974 <memcpy>
	smp_send(smp, req_buf, NULL, NULL);
 100f060:	2200      	movs	r2, #0
 100f062:	4629      	mov	r1, r5
 100f064:	4620      	mov	r0, r4
 100f066:	f019 fb53 	bl	1028710 <smp_send.constprop.0>
	switch (smp->method) {
 100f06a:	7a23      	ldrb	r3, [r4, #8]
 100f06c:	2b05      	cmp	r3, #5
 100f06e:	d85b      	bhi.n	100f128 <smp_public_key_periph+0x144>
 100f070:	e8df f003 	tbb	[pc, r3]
 100f074:	030f3b03 	.word	0x030f3b03
 100f078:	575a      	.short	0x575a
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
 100f07a:	2104      	movs	r1, #4
 100f07c:	4620      	mov	r0, r4
 100f07e:	f019 fb72 	bl	1028766 <atomic_set_bit>
		err = smp_send_pairing_confirm(smp);
 100f082:	f7ff ff5b 	bl	100ef3c <smp_send_pairing_confirm>
		if (err) {
 100f086:	2800      	cmp	r0, #0
 100f088:	d03f      	beq.n	100f10a <smp_public_key_periph+0x126>
}
 100f08a:	3718      	adds	r7, #24
 100f08c:	46bd      	mov	sp, r7
 100f08e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100f092:	4620      	mov	r0, r4
	struct bt_conn *conn = smp->chan.chan.conn;
 100f094:	f8d4 80f0 	ldr.w	r8, [r4, #240]	; 0xf0
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100f098:	f7ff fdda 	bl	100ec50 <latch_auth_cb>
		if (bt_rand(&smp->passkey, sizeof(smp->passkey))) {
 100f09c:	2104      	movs	r1, #4
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100f09e:	4605      	mov	r5, r0
		if (bt_rand(&smp->passkey, sizeof(smp->passkey))) {
 100f0a0:	f104 00d8 	add.w	r0, r4, #216	; 0xd8
 100f0a4:	f004 fc44 	bl	1013930 <bt_rand>
 100f0a8:	2800      	cmp	r0, #0
 100f0aa:	d1bc      	bne.n	100f026 <smp_public_key_periph+0x42>
		smp->passkey %= 1000000;
 100f0ac:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
 100f0b0:	4a29      	ldr	r2, [pc, #164]	; (100f158 <smp_public_key_periph+0x174>)
	smp->passkey_round = 0U;
 100f0b2:	f884 00dc 	strb.w	r0, [r4, #220]	; 0xdc
		smp->passkey %= 1000000;
 100f0b6:	fbb3 f1f2 	udiv	r1, r3, r2
 100f0ba:	fb02 3311 	mls	r3, r2, r1, r3
 100f0be:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
	if (smp_auth_cb && smp_auth_cb->passkey_display) {
 100f0c2:	b155      	cbz	r5, 100f0da <smp_public_key_periph+0xf6>
 100f0c4:	682b      	ldr	r3, [r5, #0]
 100f0c6:	b143      	cbz	r3, 100f0da <smp_public_key_periph+0xf6>
		atomic_set_bit(smp->flags, SMP_FLAG_DISPLAY);
 100f0c8:	210b      	movs	r1, #11
 100f0ca:	4630      	mov	r0, r6
 100f0cc:	f019 fb4b 	bl	1028766 <atomic_set_bit>
		smp_auth_cb->passkey_display(conn, smp->passkey);
 100f0d0:	4640      	mov	r0, r8
 100f0d2:	682b      	ldr	r3, [r5, #0]
 100f0d4:	f8d4 10d8 	ldr.w	r1, [r4, #216]	; 0xd8
 100f0d8:	4798      	blx	r3
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
 100f0da:	2103      	movs	r1, #3
 100f0dc:	4620      	mov	r0, r4
 100f0de:	f019 fb42 	bl	1028766 <atomic_set_bit>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_KEYPRESS_NOTIFICATION);
 100f0e2:	210e      	movs	r1, #14
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
 100f0e4:	f019 fb3f 	bl	1028766 <atomic_set_bit>
		break;
 100f0e8:	e00f      	b.n	100f10a <smp_public_key_periph+0x126>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
 100f0ea:	4620      	mov	r0, r4
 100f0ec:	2103      	movs	r1, #3
 100f0ee:	f019 fb3a 	bl	1028766 <atomic_set_bit>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_KEYPRESS_NOTIFICATION);
 100f0f2:	210e      	movs	r1, #14
 100f0f4:	f019 fb37 	bl	1028766 <atomic_set_bit>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
 100f0f8:	4630      	mov	r0, r6
 100f0fa:	210a      	movs	r1, #10
 100f0fc:	f019 fb33 	bl	1028766 <atomic_set_bit>
		smp_auth_cb->passkey_entry(smp->chan.chan.conn);
 100f100:	f8d8 3004 	ldr.w	r3, [r8, #4]
 100f104:	f8d4 00f0 	ldr.w	r0, [r4, #240]	; 0xf0
 100f108:	4798      	blx	r3
	atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_PENDING);
 100f10a:	4630      	mov	r0, r6
 100f10c:	2107      	movs	r1, #7
 100f10e:	f019 fb2a 	bl	1028766 <atomic_set_bit>
	if (!smp_find(SMP_FLAG_DHKEY_GEN)) {
 100f112:	2008      	movs	r0, #8
 100f114:	f7ff fd88 	bl	100ec28 <smp_find>
 100f118:	b9b0      	cbnz	r0, 100f148 <smp_public_key_periph+0x164>
		return smp_dhkey_generate(smp);
 100f11a:	4620      	mov	r0, r4
 100f11c:	f7ff fe6c 	bl	100edf8 <smp_dhkey_generate>
 100f120:	e7b3      	b.n	100f08a <smp_public_key_periph+0xa6>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
 100f122:	2104      	movs	r1, #4
 100f124:	4620      	mov	r0, r4
 100f126:	e7dd      	b.n	100f0e4 <smp_public_key_periph+0x100>
		LOG_ERR("Unknown pairing method (%u)", smp->method);
 100f128:	466c      	mov	r4, sp
 100f12a:	b088      	sub	sp, #32
 100f12c:	466a      	mov	r2, sp
 100f12e:	490b      	ldr	r1, [pc, #44]	; (100f15c <smp_public_key_periph+0x178>)
 100f130:	4808      	ldr	r0, [pc, #32]	; (100f154 <smp_public_key_periph+0x170>)
	switch (smp->method) {
 100f132:	e9c2 1305 	strd	r1, r3, [r2, #20]
		LOG_ERR("Unknown pairing method (%u)", smp->method);
 100f136:	2303      	movs	r3, #3
 100f138:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100f13c:	f842 3f10 	str.w	r3, [r2, #16]!
 100f140:	f019 fb03 	bl	102874a <z_log_msg_static_create.constprop.0>
 100f144:	46a5      	mov	sp, r4
		return BT_SMP_ERR_UNSPECIFIED;
 100f146:	e76e      	b.n	100f026 <smp_public_key_periph+0x42>
	return 0;
 100f148:	2000      	movs	r0, #0
 100f14a:	e79e      	b.n	100f08a <smp_public_key_periph+0xa6>
 100f14c:	2100498c 	.word	0x2100498c
 100f150:	0102e92a 	.word	0x0102e92a
 100f154:	010299e4 	.word	0x010299e4
 100f158:	000f4240 	.word	0x000f4240
 100f15c:	0102e90e 	.word	0x0102e90e

0100f160 <smp_public_key>:
{
 100f160:	b570      	push	{r4, r5, r6, lr}
 100f162:	460d      	mov	r5, r1
 100f164:	4604      	mov	r4, r0
 100f166:	b086      	sub	sp, #24
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100f168:	f7ff fd72 	bl	100ec50 <latch_auth_cb>
	struct bt_smp_public_key *req = (void *)buf->data;
 100f16c:	68ee      	ldr	r6, [r5, #12]
	memcpy(smp->pkey, req->x, BT_PUB_KEY_COORD_LEN);
 100f16e:	f104 0557 	add.w	r5, r4, #87	; 0x57
 100f172:	2220      	movs	r2, #32
 100f174:	4631      	mov	r1, r6
 100f176:	4628      	mov	r0, r5
 100f178:	f017 fbfc 	bl	1026974 <memcpy>
	memcpy(&smp->pkey[BT_PUB_KEY_COORD_LEN], req->y, BT_PUB_KEY_COORD_LEN);
 100f17c:	2220      	movs	r2, #32
 100f17e:	f104 0077 	add.w	r0, r4, #119	; 0x77
 100f182:	18b1      	adds	r1, r6, r2
 100f184:	f017 fbf6 	bl	1026974 <memcpy>
	if (bt_pub_key_is_debug(smp->pkey)) {
 100f188:	4628      	mov	r0, r5
 100f18a:	f7fa fb23 	bl	10097d4 <bt_pub_key_is_debug>
 100f18e:	b940      	cbnz	r0, 100f1a2 <smp_public_key+0x42>
	if (!sc_public_key) {
 100f190:	4b1b      	ldr	r3, [pc, #108]	; (100f200 <smp_public_key+0xa0>)
 100f192:	681d      	ldr	r5, [r3, #0]
 100f194:	bb75      	cbnz	r5, 100f1f4 <smp_public_key+0x94>
		atomic_set_bit(smp->flags, SMP_FLAG_PKEY_SEND);
 100f196:	1d20      	adds	r0, r4, #4
 100f198:	2106      	movs	r1, #6
 100f19a:	f019 fae4 	bl	1028766 <atomic_set_bit>
	return 0;
 100f19e:	4628      	mov	r0, r5
		return 0;
 100f1a0:	e026      	b.n	100f1f0 <smp_public_key+0x90>
		LOG_INF("Remote is using Debug Public key");
 100f1a2:	4b18      	ldr	r3, [pc, #96]	; (100f204 <smp_public_key+0xa4>)
 100f1a4:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
 100f1a8:	9305      	str	r3, [sp, #20]
 100f1aa:	2302      	movs	r3, #2
 100f1ac:	4816      	ldr	r0, [pc, #88]	; (100f208 <smp_public_key+0xa8>)
 100f1ae:	aa04      	add	r2, sp, #16
 100f1b0:	9304      	str	r3, [sp, #16]
 100f1b2:	f019 faca 	bl	102874a <z_log_msg_static_create.constprop.0>
		atomic_set_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY);
 100f1b6:	210e      	movs	r1, #14
 100f1b8:	1d20      	adds	r0, r4, #4
 100f1ba:	f019 fad4 	bl	1028766 <atomic_set_bit>
		if (!update_debug_keys_check(smp)) {
 100f1be:	f8d4 50f0 	ldr.w	r5, [r4, #240]	; 0xf0
	if (!conn->le.keys) {
 100f1c2:	f8d5 30c0 	ldr.w	r3, [r5, #192]	; 0xc0
 100f1c6:	b933      	cbnz	r3, 100f1d6 <smp_public_key+0x76>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
 100f1c8:	7a28      	ldrb	r0, [r5, #8]
 100f1ca:	f105 0190 	add.w	r1, r5, #144	; 0x90
 100f1ce:	f001 fa89 	bl	10106e4 <bt_keys_get_addr>
 100f1d2:	f8c5 00c0 	str.w	r0, [r5, #192]	; 0xc0
	if (!conn->le.keys ||
 100f1d6:	f8d5 30c0 	ldr.w	r3, [r5, #192]	; 0xc0
 100f1da:	2b00      	cmp	r3, #0
 100f1dc:	d0d8      	beq.n	100f190 <smp_public_key+0x30>
 100f1de:	89da      	ldrh	r2, [r3, #14]
 100f1e0:	f002 0224 	and.w	r2, r2, #36	; 0x24
 100f1e4:	2a00      	cmp	r2, #0
 100f1e6:	d0d3      	beq.n	100f190 <smp_public_key+0x30>
	if (conn->le.keys->flags & BT_KEYS_DEBUG) {
 100f1e8:	7b5b      	ldrb	r3, [r3, #13]
 100f1ea:	079b      	lsls	r3, r3, #30
 100f1ec:	d4d0      	bmi.n	100f190 <smp_public_key+0x30>
			return BT_SMP_ERR_AUTH_REQUIREMENTS;
 100f1ee:	2003      	movs	r0, #3
}
 100f1f0:	b006      	add	sp, #24
 100f1f2:	bd70      	pop	{r4, r5, r6, pc}
	err = smp_public_key_periph(smp);
 100f1f4:	4620      	mov	r0, r4
}
 100f1f6:	b006      	add	sp, #24
 100f1f8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	err = smp_public_key_periph(smp);
 100f1fc:	f7ff bef2 	b.w	100efe4 <smp_public_key_periph>
 100f200:	2100498c 	.word	0x2100498c
 100f204:	0102e945 	.word	0x0102e945
 100f208:	010299e4 	.word	0x010299e4

0100f20c <smp_pairing_req>:
{
 100f20c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100f210:	b087      	sub	sp, #28
 100f212:	460d      	mov	r5, r1
 100f214:	af00      	add	r7, sp, #0
 100f216:	4604      	mov	r4, r0
	struct bt_conn *conn = smp->chan.chan.conn;
 100f218:	f8d0 60f0 	ldr.w	r6, [r0, #240]	; 0xf0
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100f21c:	f7ff fd18 	bl	100ec50 <latch_auth_cb>
	struct bt_smp_pairing *req = (void *)buf->data;
 100f220:	f8d5 900c 	ldr.w	r9, [r5, #12]
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100f224:	4680      	mov	r8, r0
	if ((req->max_key_size > BT_SMP_MAX_ENC_KEY_SIZE) ||
 100f226:	f899 3003 	ldrb.w	r3, [r9, #3]
 100f22a:	3b07      	subs	r3, #7
 100f22c:	2b09      	cmp	r3, #9
 100f22e:	d904      	bls.n	100f23a <smp_pairing_req+0x2e>
		return BT_SMP_ERR_ENC_KEY_SIZE;
 100f230:	2006      	movs	r0, #6
}
 100f232:	371c      	adds	r7, #28
 100f234:	46bd      	mov	sp, r7
 100f236:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (!conn->le.keys) {
 100f23a:	f8d6 30c0 	ldr.w	r3, [r6, #192]	; 0xc0
 100f23e:	b15b      	cbz	r3, 100f258 <smp_pairing_req+0x4c>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ)) {
 100f240:	1d25      	adds	r5, r4, #4
 100f242:	210f      	movs	r1, #15
 100f244:	4628      	mov	r0, r5
 100f246:	f019 fa2f 	bl	10286a8 <atomic_test_bit>
 100f24a:	b980      	cbnz	r0, 100f26e <smp_pairing_req+0x62>
		int ret = smp_init(smp);
 100f24c:	4620      	mov	r0, r4
 100f24e:	f7ff fdb7 	bl	100edc0 <smp_init>
		if (ret) {
 100f252:	b160      	cbz	r0, 100f26e <smp_pairing_req+0x62>
			return ret;
 100f254:	b2c0      	uxtb	r0, r0
 100f256:	e7ec      	b.n	100f232 <smp_pairing_req+0x26>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
 100f258:	7a30      	ldrb	r0, [r6, #8]
 100f25a:	f106 0190 	add.w	r1, r6, #144	; 0x90
 100f25e:	f001 fa41 	bl	10106e4 <bt_keys_get_addr>
 100f262:	f8c6 00c0 	str.w	r0, [r6, #192]	; 0xc0
		if (!conn->le.keys) {
 100f266:	2800      	cmp	r0, #0
 100f268:	d1ea      	bne.n	100f240 <smp_pairing_req+0x34>
			return BT_SMP_ERR_UNSPECIFIED;
 100f26a:	2008      	movs	r0, #8
 100f26c:	e7e1      	b.n	100f232 <smp_pairing_req+0x26>
	smp->preq[0] = BT_SMP_CMD_PAIRING_REQ;
 100f26e:	2301      	movs	r3, #1
	memcpy(smp->preq + 1, req, sizeof(*req));
 100f270:	2206      	movs	r2, #6
 100f272:	4649      	mov	r1, r9
	smp->preq[0] = BT_SMP_CMD_PAIRING_REQ;
 100f274:	7263      	strb	r3, [r4, #9]
	memcpy(smp->preq + 1, req, sizeof(*req));
 100f276:	f104 000a 	add.w	r0, r4, #10
 100f27a:	f017 fb7b 	bl	1026974 <memcpy>
	smp->prsp[0] = BT_SMP_CMD_PAIRING_RSP;
 100f27e:	2302      	movs	r3, #2
 100f280:	7423      	strb	r3, [r4, #16]
	rsp->auth_req = get_auth(smp, req->auth_req);
 100f282:	f899 1002 	ldrb.w	r1, [r9, #2]
 100f286:	4620      	mov	r0, r4
 100f288:	f7ff fd1e 	bl	100ecc8 <get_auth>
 100f28c:	74e0      	strb	r0, [r4, #19]
	rsp->io_capability = get_io_capa(smp);
 100f28e:	4620      	mov	r0, r4
 100f290:	f7ff fcf4 	bl	100ec7c <get_io_capa>
	rsp->oob_flag = oobd_present ? BT_SMP_OOB_PRESENT :
 100f294:	4bab      	ldr	r3, [pc, #684]	; (100f544 <smp_pairing_req+0x338>)
	rsp->io_capability = get_io_capa(smp);
 100f296:	7460      	strb	r0, [r4, #17]
	rsp->oob_flag = oobd_present ? BT_SMP_OOB_PRESENT :
 100f298:	781b      	ldrb	r3, [r3, #0]
 100f29a:	74a3      	strb	r3, [r4, #18]
	rsp->max_key_size = BT_SMP_MAX_ENC_KEY_SIZE;
 100f29c:	2310      	movs	r3, #16
 100f29e:	7523      	strb	r3, [r4, #20]
	rsp->init_key_dist = (req->init_key_dist & RECV_KEYS);
 100f2a0:	f899 3004 	ldrb.w	r3, [r9, #4]
 100f2a4:	f003 0303 	and.w	r3, r3, #3
 100f2a8:	7563      	strb	r3, [r4, #21]
	rsp->resp_key_dist = (req->resp_key_dist & SEND_KEYS);
 100f2aa:	f899 3005 	ldrb.w	r3, [r9, #5]
 100f2ae:	f003 0301 	and.w	r3, r3, #1
 100f2b2:	75a3      	strb	r3, [r4, #22]
	if ((rsp->auth_req & BT_SMP_AUTH_SC) &&
 100f2b4:	7ce3      	ldrb	r3, [r4, #19]
 100f2b6:	071b      	lsls	r3, r3, #28
 100f2b8:	d50d      	bpl.n	100f2d6 <smp_pairing_req+0xca>
 100f2ba:	f899 3002 	ldrb.w	r3, [r9, #2]
 100f2be:	0718      	lsls	r0, r3, #28
 100f2c0:	d509      	bpl.n	100f2d6 <smp_pairing_req+0xca>
		atomic_set_bit(smp->flags, SMP_FLAG_SC);
 100f2c2:	2105      	movs	r1, #5
 100f2c4:	4628      	mov	r0, r5
 100f2c6:	f019 fa4e 	bl	1028766 <atomic_set_bit>
		rsp->init_key_dist &= RECV_KEYS_SC;
 100f2ca:	7d63      	ldrb	r3, [r4, #21]
 100f2cc:	f003 0302 	and.w	r3, r3, #2
 100f2d0:	7563      	strb	r3, [r4, #21]
		rsp->resp_key_dist &= SEND_KEYS_SC;
 100f2d2:	2300      	movs	r3, #0
 100f2d4:	75a3      	strb	r3, [r4, #22]
	if ((rsp->auth_req & BT_SMP_AUTH_CT2) &&
 100f2d6:	7ce3      	ldrb	r3, [r4, #19]
 100f2d8:	0699      	lsls	r1, r3, #26
 100f2da:	d507      	bpl.n	100f2ec <smp_pairing_req+0xe0>
 100f2dc:	f899 3002 	ldrb.w	r3, [r9, #2]
 100f2e0:	069a      	lsls	r2, r3, #26
 100f2e2:	d503      	bpl.n	100f2ec <smp_pairing_req+0xe0>
		atomic_set_bit(smp->flags, SMP_FLAG_CT2);
 100f2e4:	2114      	movs	r1, #20
 100f2e6:	4628      	mov	r0, r5
 100f2e8:	f019 fa3d 	bl	1028766 <atomic_set_bit>
	smp->local_dist = rsp->resp_key_dist;
 100f2ec:	7da3      	ldrb	r3, [r4, #22]
 100f2ee:	f884 30e8 	strb.w	r3, [r4, #232]	; 0xe8
	smp->remote_dist = rsp->init_key_dist;
 100f2f2:	7d63      	ldrb	r3, [r4, #21]
 100f2f4:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
	if ((rsp->auth_req & BT_SMP_AUTH_BONDING) &&
 100f2f8:	7ce3      	ldrb	r3, [r4, #19]
 100f2fa:	07db      	lsls	r3, r3, #31
 100f2fc:	d507      	bpl.n	100f30e <smp_pairing_req+0x102>
 100f2fe:	f899 3002 	ldrb.w	r3, [r9, #2]
 100f302:	07d8      	lsls	r0, r3, #31
 100f304:	d503      	bpl.n	100f30e <smp_pairing_req+0x102>
		atomic_set_bit(smp->flags, SMP_FLAG_BOND);
 100f306:	210d      	movs	r1, #13
 100f308:	4628      	mov	r0, r5
 100f30a:	f019 fa2c 	bl	1028766 <atomic_set_bit>
	atomic_set_bit(smp->flags, SMP_FLAG_PAIRING);
 100f30e:	2103      	movs	r1, #3
 100f310:	4628      	mov	r0, r5
 100f312:	f019 fa28 	bl	1028766 <atomic_set_bit>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 100f316:	2105      	movs	r1, #5
	smp->method = get_pair_method(smp, req->io_capability);
 100f318:	f899 9000 	ldrb.w	r9, [r9]
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 100f31c:	f019 f9c4 	bl	10286a8 <atomic_test_bit>
 100f320:	bb40      	cbnz	r0, 100f374 <smp_pairing_req+0x168>
	if (remote_io > BT_SMP_IO_KEYBOARD_DISPLAY) {
 100f322:	f1b9 0f04 	cmp.w	r9, #4
 100f326:	d845      	bhi.n	100f3b4 <smp_pairing_req+0x1a8>
	if ((req->oob_flag & rsp->oob_flag) & BT_SMP_OOB_DATA_MASK) {
 100f328:	7ae3      	ldrb	r3, [r4, #11]
 100f32a:	7ca2      	ldrb	r2, [r4, #18]
 100f32c:	4013      	ands	r3, r2
 100f32e:	07d9      	lsls	r1, r3, #31
 100f330:	d43e      	bmi.n	100f3b0 <smp_pairing_req+0x1a4>
	if (!((req->auth_req | rsp->auth_req) & BT_SMP_AUTH_MITM)) {
 100f332:	7b21      	ldrb	r1, [r4, #12]
 100f334:	7ce3      	ldrb	r3, [r4, #19]
 100f336:	4319      	orrs	r1, r3
 100f338:	f011 0104 	ands.w	r1, r1, #4
 100f33c:	d011      	beq.n	100f362 <smp_pairing_req+0x156>
	method = gen_method_legacy[remote_io][get_io_capa(smp)];
 100f33e:	4620      	mov	r0, r4
 100f340:	f7ff fc9c 	bl	100ec7c <get_io_capa>
 100f344:	4b80      	ldr	r3, [pc, #512]	; (100f548 <smp_pairing_req+0x33c>)
 100f346:	eb09 0989 	add.w	r9, r9, r9, lsl #2
 100f34a:	4499      	add	r9, r3
 100f34c:	f819 1000 	ldrb.w	r1, [r9, r0]
	if (method == PASSKEY_ROLE) {
 100f350:	2904      	cmp	r1, #4
 100f352:	d106      	bne.n	100f362 <smp_pairing_req+0x156>
		if (smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
 100f354:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 100f358:	78db      	ldrb	r3, [r3, #3]
			method = PASSKEY_DISPLAY;
 100f35a:	2b00      	cmp	r3, #0
 100f35c:	bf14      	ite	ne
 100f35e:	2101      	movne	r1, #1
 100f360:	2102      	moveq	r1, #2
	smp->method = get_pair_method(smp, req->io_capability);
 100f362:	7221      	strb	r1, [r4, #8]
	if (!update_keys_check(smp, conn->le.keys)) {
 100f364:	4620      	mov	r0, r4
 100f366:	f8d6 10c0 	ldr.w	r1, [r6, #192]	; 0xc0
 100f36a:	f019 f9a3 	bl	10286b4 <update_keys_check>
 100f36e:	bb18      	cbnz	r0, 100f3b8 <smp_pairing_req+0x1ac>
		return BT_SMP_ERR_AUTH_REQUIREMENTS;
 100f370:	2003      	movs	r0, #3
 100f372:	e75e      	b.n	100f232 <smp_pairing_req+0x26>
	if ((req->auth_req & rsp->auth_req) & BT_SMP_AUTH_SC) {
 100f374:	7b23      	ldrb	r3, [r4, #12]
 100f376:	7ce0      	ldrb	r0, [r4, #19]
 100f378:	ea03 0200 	and.w	r2, r3, r0
 100f37c:	0712      	lsls	r2, r2, #28
 100f37e:	d506      	bpl.n	100f38e <smp_pairing_req+0x182>
		if ((req->oob_flag | rsp->oob_flag) & BT_SMP_OOB_DATA_MASK) {
 100f380:	7ae2      	ldrb	r2, [r4, #11]
 100f382:	f894 c012 	ldrb.w	ip, [r4, #18]
 100f386:	ea42 020c 	orr.w	r2, r2, ip
 100f38a:	07d2      	lsls	r2, r2, #31
 100f38c:	d4e9      	bmi.n	100f362 <smp_pairing_req+0x156>
	if (remote_io > BT_SMP_IO_KEYBOARD_DISPLAY) {
 100f38e:	f1b9 0f04 	cmp.w	r9, #4
 100f392:	d80f      	bhi.n	100f3b4 <smp_pairing_req+0x1a8>
	if (!((req->auth_req | rsp->auth_req) & BT_SMP_AUTH_MITM)) {
 100f394:	ea43 0100 	orr.w	r1, r3, r0
 100f398:	f011 0104 	ands.w	r1, r1, #4
 100f39c:	d0e1      	beq.n	100f362 <smp_pairing_req+0x156>
	return gen_method_sc[remote_io][get_io_capa(smp)];
 100f39e:	4620      	mov	r0, r4
 100f3a0:	f7ff fc6c 	bl	100ec7c <get_io_capa>
 100f3a4:	4b69      	ldr	r3, [pc, #420]	; (100f54c <smp_pairing_req+0x340>)
 100f3a6:	eb09 0989 	add.w	r9, r9, r9, lsl #2
 100f3aa:	444b      	add	r3, r9
 100f3ac:	5c19      	ldrb	r1, [r3, r0]
 100f3ae:	e7d8      	b.n	100f362 <smp_pairing_req+0x156>
		return LEGACY_OOB;
 100f3b0:	2106      	movs	r1, #6
 100f3b2:	e7d6      	b.n	100f362 <smp_pairing_req+0x156>
		return JUST_WORKS;
 100f3b4:	2100      	movs	r1, #0
 100f3b6:	e7d4      	b.n	100f362 <smp_pairing_req+0x156>
	bt_security_t sec = smp->chan.chan.conn->required_sec_level;
 100f3b8:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 100f3bc:	7a9b      	ldrb	r3, [r3, #10]
	switch (sec) {
 100f3be:	2b03      	cmp	r3, #3
 100f3c0:	d03e      	beq.n	100f440 <smp_pairing_req+0x234>
 100f3c2:	d82c      	bhi.n	100f41e <smp_pairing_req+0x212>
 100f3c4:	3b01      	subs	r3, #1
 100f3c6:	2b01      	cmp	r3, #1
 100f3c8:	f63f af4f 	bhi.w	100f26a <smp_pairing_req+0x5e>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 100f3cc:	2105      	movs	r1, #5
 100f3ce:	4628      	mov	r0, r5
 100f3d0:	f019 f96a 	bl	10286a8 <atomic_test_bit>
 100f3d4:	2800      	cmp	r0, #0
 100f3d6:	f040 80c3 	bne.w	100f560 <smp_pairing_req+0x354>
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100f3da:	4620      	mov	r0, r4
 100f3dc:	f7ff fc38 	bl	100ec50 <latch_auth_cb>
 100f3e0:	4680      	mov	r8, r0
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100f3e2:	4620      	mov	r0, r4
	struct bt_conn *conn = smp->chan.chan.conn;
 100f3e4:	f8d4 90f0 	ldr.w	r9, [r4, #240]	; 0xf0
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100f3e8:	f7ff fc32 	bl	100ec50 <latch_auth_cb>
	keys = bt_keys_find_addr(conn->id, &conn->le.dst);
 100f3ec:	f109 0190 	add.w	r1, r9, #144	; 0x90
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100f3f0:	4606      	mov	r6, r0
	keys = bt_keys_find_addr(conn->id, &conn->le.dst);
 100f3f2:	f899 0008 	ldrb.w	r0, [r9, #8]
 100f3f6:	f001 fa53 	bl	10108a0 <bt_keys_find_addr>
	if (keys && (keys->flags & BT_KEYS_AUTHENTICATED) &&
 100f3fa:	7a23      	ldrb	r3, [r4, #8]
 100f3fc:	b320      	cbz	r0, 100f448 <smp_pairing_req+0x23c>
 100f3fe:	7b42      	ldrb	r2, [r0, #13]
 100f400:	07d2      	lsls	r2, r2, #31
 100f402:	d521      	bpl.n	100f448 <smp_pairing_req+0x23c>
 100f404:	bb03      	cbnz	r3, 100f448 <smp_pairing_req+0x23c>
		LOG_ERR("JustWorks failed, authenticated keys present");
 100f406:	4b52      	ldr	r3, [pc, #328]	; (100f550 <smp_pairing_req+0x344>)
 100f408:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100f40c:	617b      	str	r3, [r7, #20]
 100f40e:	2302      	movs	r3, #2
 100f410:	4850      	ldr	r0, [pc, #320]	; (100f554 <smp_pairing_req+0x348>)
 100f412:	613b      	str	r3, [r7, #16]
 100f414:	f107 0210 	add.w	r2, r7, #16
 100f418:	f019 f997 	bl	102874a <z_log_msg_static_create.constprop.0>
	if (ret) {
 100f41c:	e725      	b.n	100f26a <smp_pairing_req+0x5e>
	switch (sec) {
 100f41e:	2b04      	cmp	r3, #4
 100f420:	f47f af23 	bne.w	100f26a <smp_pairing_req+0x5e>
	return MIN(req->max_key_size, rsp->max_key_size);
 100f424:	7d23      	ldrb	r3, [r4, #20]
 100f426:	7b62      	ldrb	r2, [r4, #13]
		if (get_encryption_key_size(smp) != BT_SMP_MAX_ENC_KEY_SIZE) {
 100f428:	4293      	cmp	r3, r2
 100f42a:	bf28      	it	cs
 100f42c:	4613      	movcs	r3, r2
 100f42e:	2b10      	cmp	r3, #16
 100f430:	f47f aefe 	bne.w	100f230 <smp_pairing_req+0x24>
		if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 100f434:	2105      	movs	r1, #5
 100f436:	4628      	mov	r0, r5
 100f438:	f019 f936 	bl	10286a8 <atomic_test_bit>
 100f43c:	2800      	cmp	r0, #0
 100f43e:	d097      	beq.n	100f370 <smp_pairing_req+0x164>
		if (smp->method == JUST_WORKS) {
 100f440:	7a23      	ldrb	r3, [r4, #8]
 100f442:	2b00      	cmp	r3, #0
 100f444:	d1c2      	bne.n	100f3cc <smp_pairing_req+0x1c0>
 100f446:	e793      	b.n	100f370 <smp_pairing_req+0x164>
	switch (smp->method) {
 100f448:	2b06      	cmp	r3, #6
 100f44a:	d85f      	bhi.n	100f50c <smp_pairing_req+0x300>
 100f44c:	e8df f003 	tbb	[pc, r3]
 100f450:	5e2f5617 	.word	0x5e2f5617
 100f454:	5e5e      	.short	0x5e5e
 100f456:	04          	.byte	0x04
 100f457:	00          	.byte	0x00
		if (smp_auth_cb && smp_auth_cb->oob_data_request) {
 100f458:	2e00      	cmp	r6, #0
 100f45a:	d067      	beq.n	100f52c <smp_pairing_req+0x320>
 100f45c:	68f3      	ldr	r3, [r6, #12]
 100f45e:	2b00      	cmp	r3, #0
 100f460:	d064      	beq.n	100f52c <smp_pairing_req+0x320>
			struct bt_conn_oob_info info = {
 100f462:	2300      	movs	r3, #0
			atomic_set_bit(smp->flags, SMP_FLAG_USER);
 100f464:	210a      	movs	r1, #10
 100f466:	4628      	mov	r0, r5
			struct bt_conn_oob_info info = {
 100f468:	803b      	strh	r3, [r7, #0]
			atomic_set_bit(smp->flags, SMP_FLAG_USER);
 100f46a:	f019 f97c 	bl	1028766 <atomic_set_bit>
			smp_auth_cb->oob_data_request(smp->chan.chan.conn, &info);
 100f46e:	4639      	mov	r1, r7
 100f470:	68f3      	ldr	r3, [r6, #12]
 100f472:	f8d4 00f0 	ldr.w	r0, [r4, #240]	; 0xf0
 100f476:	4798      	blx	r3
	if ((DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
 100f478:	7a23      	ldrb	r3, [r4, #8]
 100f47a:	2b00      	cmp	r3, #0
 100f47c:	d158      	bne.n	100f530 <smp_pairing_req+0x324>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
 100f47e:	210f      	movs	r1, #15
 100f480:	4628      	mov	r0, r5
 100f482:	f019 f911 	bl	10286a8 <atomic_test_bit>
	if ((DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
 100f486:	2800      	cmp	r0, #0
 100f488:	d152      	bne.n	100f530 <smp_pairing_req+0x324>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
 100f48a:	f1b8 0f00 	cmp.w	r8, #0
 100f48e:	d04f      	beq.n	100f530 <smp_pairing_req+0x324>
	    smp_auth_cb && smp_auth_cb->pairing_confirm) {
 100f490:	f8d8 3014 	ldr.w	r3, [r8, #20]
 100f494:	2b00      	cmp	r3, #0
 100f496:	d04b      	beq.n	100f530 <smp_pairing_req+0x324>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
 100f498:	4628      	mov	r0, r5
 100f49a:	210a      	movs	r1, #10
 100f49c:	f019 f963 	bl	1028766 <atomic_set_bit>
		smp_auth_cb->pairing_confirm(smp->chan.chan.conn);
 100f4a0:	f8d8 3014 	ldr.w	r3, [r8, #20]
 100f4a4:	f8d4 00f0 	ldr.w	r0, [r4, #240]	; 0xf0
		smp_auth_cb->pairing_confirm(conn);
 100f4a8:	4798      	blx	r3
		return 0;
 100f4aa:	2000      	movs	r0, #0
 100f4ac:	e6c1      	b.n	100f232 <smp_pairing_req+0x26>
			if (bt_rand(&passkey, sizeof(passkey))) {
 100f4ae:	2104      	movs	r1, #4
 100f4b0:	4638      	mov	r0, r7
 100f4b2:	f004 fa3d 	bl	1013930 <bt_rand>
 100f4b6:	2800      	cmp	r0, #0
 100f4b8:	f47f aed7 	bne.w	100f26a <smp_pairing_req+0x5e>
			passkey %= 1000000;
 100f4bc:	683b      	ldr	r3, [r7, #0]
 100f4be:	4a26      	ldr	r2, [pc, #152]	; (100f558 <smp_pairing_req+0x34c>)
 100f4c0:	fbb3 f1f2 	udiv	r1, r3, r2
 100f4c4:	fb02 3311 	mls	r3, r2, r1, r3
 100f4c8:	603b      	str	r3, [r7, #0]
		if (smp_auth_cb && smp_auth_cb->passkey_display) {
 100f4ca:	b14e      	cbz	r6, 100f4e0 <smp_pairing_req+0x2d4>
 100f4cc:	6833      	ldr	r3, [r6, #0]
 100f4ce:	b13b      	cbz	r3, 100f4e0 <smp_pairing_req+0x2d4>
			atomic_set_bit(smp->flags, SMP_FLAG_DISPLAY);
 100f4d0:	210b      	movs	r1, #11
 100f4d2:	4628      	mov	r0, r5
 100f4d4:	f019 f947 	bl	1028766 <atomic_set_bit>
			smp_auth_cb->passkey_display(conn, passkey);
 100f4d8:	4648      	mov	r0, r9
 100f4da:	6833      	ldr	r3, [r6, #0]
 100f4dc:	6839      	ldr	r1, [r7, #0]
 100f4de:	4798      	blx	r3
		sys_put_le32(passkey, smp->tk);
 100f4e0:	683b      	ldr	r3, [r7, #0]
	dst[1] = val >> 8;
 100f4e2:	f3c3 2207 	ubfx	r2, r3, #8, #8
	dst[0] = val;
 100f4e6:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
	sys_put_le16(val >> 16, &dst[2]);
 100f4ea:	0c1b      	lsrs	r3, r3, #16
	dst[0] = val;
 100f4ec:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
	dst[1] = val >> 8;
 100f4f0:	0a1b      	lsrs	r3, r3, #8
 100f4f2:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
 100f4f6:	f884 304a 	strb.w	r3, [r4, #74]	; 0x4a
	if (ret) {
 100f4fa:	e7bd      	b.n	100f478 <smp_pairing_req+0x26c>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
 100f4fc:	4628      	mov	r0, r5
 100f4fe:	210a      	movs	r1, #10
 100f500:	f019 f931 	bl	1028766 <atomic_set_bit>
		smp_auth_cb->passkey_entry(conn);
 100f504:	4648      	mov	r0, r9
 100f506:	6873      	ldr	r3, [r6, #4]
 100f508:	4798      	blx	r3
	if (ret) {
 100f50a:	e7b5      	b.n	100f478 <smp_pairing_req+0x26c>
		LOG_ERR("Unknown pairing method (%u)", smp->method);
 100f50c:	466c      	mov	r4, sp
 100f50e:	b088      	sub	sp, #32
 100f510:	466a      	mov	r2, sp
 100f512:	4912      	ldr	r1, [pc, #72]	; (100f55c <smp_pairing_req+0x350>)
 100f514:	480f      	ldr	r0, [pc, #60]	; (100f554 <smp_pairing_req+0x348>)
	switch (smp->method) {
 100f516:	e9c2 1305 	strd	r1, r3, [r2, #20]
		LOG_ERR("Unknown pairing method (%u)", smp->method);
 100f51a:	2303      	movs	r3, #3
 100f51c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100f520:	f842 3f10 	str.w	r3, [r2, #16]!
 100f524:	f019 f911 	bl	102874a <z_log_msg_static_create.constprop.0>
 100f528:	46a5      	mov	sp, r4
	if (ret) {
 100f52a:	e69e      	b.n	100f26a <smp_pairing_req+0x5e>
			return BT_SMP_ERR_OOB_NOT_AVAIL;
 100f52c:	2002      	movs	r0, #2
 100f52e:	e680      	b.n	100f232 <smp_pairing_req+0x26>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
 100f530:	2103      	movs	r1, #3
 100f532:	4620      	mov	r0, r4
 100f534:	f019 f917 	bl	1028766 <atomic_set_bit>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_KEYPRESS_NOTIFICATION);
 100f538:	210e      	movs	r1, #14
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PUBLIC_KEY);
 100f53a:	f019 f914 	bl	1028766 <atomic_set_bit>
	return send_pairing_rsp(smp);
 100f53e:	f019 f941 	bl	10287c4 <send_pairing_rsp>
 100f542:	e676      	b.n	100f232 <smp_pairing_req+0x26>
 100f544:	21008347 	.word	0x21008347
 100f548:	0102eccd 	.word	0x0102eccd
 100f54c:	0102ecb4 	.word	0x0102ecb4
 100f550:	0102e966 	.word	0x0102e966
 100f554:	010299e4 	.word	0x010299e4
 100f558:	000f4240 	.word	0x000f4240
 100f55c:	0102e90e 	.word	0x0102e90e
	if (!IS_ENABLED(CONFIG_BT_SMP_SC_PAIR_ONLY) &&
 100f560:	7a23      	ldrb	r3, [r4, #8]
 100f562:	b993      	cbnz	r3, 100f58a <smp_pairing_req+0x37e>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
 100f564:	210f      	movs	r1, #15
 100f566:	4628      	mov	r0, r5
 100f568:	f019 f89e 	bl	10286a8 <atomic_test_bit>
	    (DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
 100f56c:	b968      	cbnz	r0, 100f58a <smp_pairing_req+0x37e>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
 100f56e:	f1b8 0f00 	cmp.w	r8, #0
 100f572:	d00a      	beq.n	100f58a <smp_pairing_req+0x37e>
	    smp_auth_cb && smp_auth_cb->pairing_confirm) {
 100f574:	f8d8 3014 	ldr.w	r3, [r8, #20]
 100f578:	b13b      	cbz	r3, 100f58a <smp_pairing_req+0x37e>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
 100f57a:	4628      	mov	r0, r5
 100f57c:	210a      	movs	r1, #10
 100f57e:	f019 f8f2 	bl	1028766 <atomic_set_bit>
		smp_auth_cb->pairing_confirm(conn);
 100f582:	4630      	mov	r0, r6
 100f584:	f8d8 3014 	ldr.w	r3, [r8, #20]
 100f588:	e78e      	b.n	100f4a8 <smp_pairing_req+0x29c>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PUBLIC_KEY);
 100f58a:	210c      	movs	r1, #12
 100f58c:	4620      	mov	r0, r4
 100f58e:	e7d4      	b.n	100f53a <smp_pairing_req+0x32e>

0100f590 <compute_and_check_and_send_periph_dhcheck>:
{
 100f590:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100f594:	4604      	mov	r4, r0
 100f596:	b097      	sub	sp, #92	; 0x5c
 100f598:	af04      	add	r7, sp, #16
	(void)memset(r, 0, sizeof(r));
 100f59a:	2210      	movs	r2, #16
 100f59c:	2100      	movs	r1, #0
 100f59e:	f107 0020 	add.w	r0, r7, #32
 100f5a2:	f017 f9f2 	bl	102698a <memset>
	switch (smp->method) {
 100f5a6:	7a23      	ldrb	r3, [r4, #8]
 100f5a8:	2b05      	cmp	r3, #5
 100f5aa:	d834      	bhi.n	100f616 <compute_and_check_and_send_periph_dhcheck+0x86>
 100f5ac:	e8df f003 	tbb	[pc, r3]
 100f5b0:	0a03030a 	.word	0x0a03030a
 100f5b4:	2d33      	.short	0x2d33
		memcpy(r, &smp->passkey, sizeof(smp->passkey));
 100f5b6:	2204      	movs	r2, #4
 100f5b8:	f104 01d8 	add.w	r1, r4, #216	; 0xd8
			memcpy(r, smp->oobd_remote->r, sizeof(r));
 100f5bc:	f107 0020 	add.w	r0, r7, #32
 100f5c0:	f017 f9d8 	bl	1026974 <memcpy>
	if (bt_crypto_f5(smp->dhkey, smp->rrnd, smp->prnd, &smp->chan.chan.conn->le.init_addr,
 100f5c4:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
			 &smp->chan.chan.conn->le.resp_addr, smp->mackey, smp->tk)) {
 100f5c8:	f104 0247 	add.w	r2, r4, #71	; 0x47
 100f5cc:	f104 05c7 	add.w	r5, r4, #199	; 0xc7
	if (bt_crypto_f5(smp->dhkey, smp->rrnd, smp->prnd, &smp->chan.chan.conn->le.init_addr,
 100f5d0:	e9cd 5201 	strd	r5, r2, [sp, #4]
 100f5d4:	f104 0637 	add.w	r6, r4, #55	; 0x37
			 &smp->chan.chan.conn->le.resp_addr, smp->mackey, smp->tk)) {
 100f5d8:	f103 029e 	add.w	r2, r3, #158	; 0x9e
	if (bt_crypto_f5(smp->dhkey, smp->rrnd, smp->prnd, &smp->chan.chan.conn->le.init_addr,
 100f5dc:	f104 0927 	add.w	r9, r4, #39	; 0x27
 100f5e0:	9200      	str	r2, [sp, #0]
 100f5e2:	4631      	mov	r1, r6
 100f5e4:	464a      	mov	r2, r9
 100f5e6:	3397      	adds	r3, #151	; 0x97
 100f5e8:	f104 0097 	add.w	r0, r4, #151	; 0x97
 100f5ec:	f001 fb50 	bl	1010c90 <bt_crypto_f5>
 100f5f0:	b328      	cbz	r0, 100f63e <compute_and_check_and_send_periph_dhcheck+0xae>
		LOG_ERR("Calculate LTK failed");
 100f5f2:	4b42      	ldr	r3, [pc, #264]	; (100f6fc <compute_and_check_and_send_periph_dhcheck+0x16c>)
 100f5f4:	647b      	str	r3, [r7, #68]	; 0x44
 100f5f6:	2302      	movs	r3, #2
 100f5f8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100f5fc:	4840      	ldr	r0, [pc, #256]	; (100f700 <compute_and_check_and_send_periph_dhcheck+0x170>)
 100f5fe:	643b      	str	r3, [r7, #64]	; 0x40
 100f600:	f107 0240 	add.w	r2, r7, #64	; 0x40
 100f604:	f019 f8a1 	bl	102874a <z_log_msg_static_create.constprop.0>
		return BT_SMP_ERR_UNSPECIFIED;
 100f608:	e014      	b.n	100f634 <compute_and_check_and_send_periph_dhcheck+0xa4>
		if (smp->oobd_remote) {
 100f60a:	f8d4 10e4 	ldr.w	r1, [r4, #228]	; 0xe4
 100f60e:	2900      	cmp	r1, #0
 100f610:	d0d8      	beq.n	100f5c4 <compute_and_check_and_send_periph_dhcheck+0x34>
			memcpy(r, smp->oobd_remote->r, sizeof(r));
 100f612:	2210      	movs	r2, #16
 100f614:	e7d2      	b.n	100f5bc <compute_and_check_and_send_periph_dhcheck+0x2c>
		LOG_ERR("Unknown pairing method (%u)", smp->method);
 100f616:	466c      	mov	r4, sp
 100f618:	b088      	sub	sp, #32
 100f61a:	aa04      	add	r2, sp, #16
 100f61c:	4939      	ldr	r1, [pc, #228]	; (100f704 <compute_and_check_and_send_periph_dhcheck+0x174>)
 100f61e:	4838      	ldr	r0, [pc, #224]	; (100f700 <compute_and_check_and_send_periph_dhcheck+0x170>)
	switch (smp->method) {
 100f620:	e9c2 1305 	strd	r1, r3, [r2, #20]
		LOG_ERR("Unknown pairing method (%u)", smp->method);
 100f624:	2303      	movs	r3, #3
 100f626:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100f62a:	f842 3f10 	str.w	r3, [r2, #16]!
 100f62e:	f019 f88c 	bl	102874a <z_log_msg_static_create.constprop.0>
 100f632:	46a5      	mov	sp, r4
		return BT_SMP_ERR_UNSPECIFIED;
 100f634:	2008      	movs	r0, #8
}
 100f636:	374c      	adds	r7, #76	; 0x4c
 100f638:	46bd      	mov	sp, r7
 100f63a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			 &smp->chan.chan.conn->le.resp_addr, &smp->chan.chan.conn->le.init_addr,
 100f63e:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
	if (bt_crypto_f6(smp->mackey, smp->prnd, smp->rrnd, r, &smp->prsp[1],
 100f642:	f107 0810 	add.w	r8, r7, #16
			 &smp->chan.chan.conn->le.resp_addr, &smp->chan.chan.conn->le.init_addr,
 100f646:	f103 0297 	add.w	r2, r3, #151	; 0x97
 100f64a:	339e      	adds	r3, #158	; 0x9e
	if (bt_crypto_f6(smp->mackey, smp->prnd, smp->rrnd, r, &smp->prsp[1],
 100f64c:	9301      	str	r3, [sp, #4]
 100f64e:	f104 0311 	add.w	r3, r4, #17
 100f652:	9202      	str	r2, [sp, #8]
 100f654:	9300      	str	r3, [sp, #0]
 100f656:	4632      	mov	r2, r6
 100f658:	4649      	mov	r1, r9
 100f65a:	4628      	mov	r0, r5
 100f65c:	f8cd 800c 	str.w	r8, [sp, #12]
 100f660:	f107 0320 	add.w	r3, r7, #32
 100f664:	f019 fb23 	bl	1028cae <bt_crypto_f6>
 100f668:	b108      	cbz	r0, 100f66e <compute_and_check_and_send_periph_dhcheck+0xde>
		LOG_ERR("Calculate local DHKey check failed");
 100f66a:	4b27      	ldr	r3, [pc, #156]	; (100f708 <compute_and_check_and_send_periph_dhcheck+0x178>)
 100f66c:	e7c2      	b.n	100f5f4 <compute_and_check_and_send_periph_dhcheck+0x64>
	if (smp->method == LE_SC_OOB) {
 100f66e:	7a23      	ldrb	r3, [r4, #8]
 100f670:	2b05      	cmp	r3, #5
 100f672:	d107      	bne.n	100f684 <compute_and_check_and_send_periph_dhcheck+0xf4>
		if (smp->oobd_local) {
 100f674:	f8d4 10e0 	ldr.w	r1, [r4, #224]	; 0xe0
			memcpy(r, smp->oobd_local->r, sizeof(r));
 100f678:	2210      	movs	r2, #16
 100f67a:	f107 0020 	add.w	r0, r7, #32
		if (smp->oobd_local) {
 100f67e:	b1b1      	cbz	r1, 100f6ae <compute_and_check_and_send_periph_dhcheck+0x11e>
			memcpy(r, smp->oobd_local->r, sizeof(r));
 100f680:	f017 f978 	bl	1026974 <memcpy>
			 &smp->chan.chan.conn->le.init_addr, &smp->chan.chan.conn->le.resp_addr,
 100f684:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
	if (bt_crypto_f6(smp->mackey, smp->rrnd, smp->prnd, r, &smp->preq[1],
 100f688:	4631      	mov	r1, r6
			 &smp->chan.chan.conn->le.init_addr, &smp->chan.chan.conn->le.resp_addr,
 100f68a:	f103 029e 	add.w	r2, r3, #158	; 0x9e
 100f68e:	3397      	adds	r3, #151	; 0x97
	if (bt_crypto_f6(smp->mackey, smp->rrnd, smp->prnd, r, &smp->preq[1],
 100f690:	9301      	str	r3, [sp, #4]
 100f692:	f104 030a 	add.w	r3, r4, #10
 100f696:	9202      	str	r2, [sp, #8]
 100f698:	9300      	str	r3, [sp, #0]
 100f69a:	464a      	mov	r2, r9
 100f69c:	4628      	mov	r0, r5
 100f69e:	9703      	str	r7, [sp, #12]
 100f6a0:	f107 0320 	add.w	r3, r7, #32
 100f6a4:	f019 fb03 	bl	1028cae <bt_crypto_f6>
 100f6a8:	b120      	cbz	r0, 100f6b4 <compute_and_check_and_send_periph_dhcheck+0x124>
		LOG_ERR("Calculate remote DHKey check failed");
 100f6aa:	4b18      	ldr	r3, [pc, #96]	; (100f70c <compute_and_check_and_send_periph_dhcheck+0x17c>)
 100f6ac:	e7a2      	b.n	100f5f4 <compute_and_check_and_send_periph_dhcheck+0x64>
			memset(r, 0, sizeof(r));
 100f6ae:	f017 f96c 	bl	102698a <memset>
 100f6b2:	e7e7      	b.n	100f684 <compute_and_check_and_send_periph_dhcheck+0xf4>
	if (memcmp(smp->e, re, 16)) {
 100f6b4:	2210      	movs	r2, #16
 100f6b6:	4639      	mov	r1, r7
 100f6b8:	f104 00b7 	add.w	r0, r4, #183	; 0xb7
 100f6bc:	f017 f94a 	bl	1026954 <memcmp>
 100f6c0:	4605      	mov	r5, r0
 100f6c2:	b9c8      	cbnz	r0, 100f6f8 <compute_and_check_and_send_periph_dhcheck+0x168>
	buf = smp_create_pdu(smp, BT_SMP_DHKEY_CHECK, sizeof(*req));
 100f6c4:	210d      	movs	r1, #13
 100f6c6:	4620      	mov	r0, r4
 100f6c8:	f019 f85d 	bl	1028786 <smp_create_pdu.constprop.0>
	if (!buf) {
 100f6cc:	4606      	mov	r6, r0
 100f6ce:	2800      	cmp	r0, #0
 100f6d0:	d0b0      	beq.n	100f634 <compute_and_check_and_send_periph_dhcheck+0xa4>
 100f6d2:	2110      	movs	r1, #16
 100f6d4:	300c      	adds	r0, #12
 100f6d6:	f00e fddf 	bl	101e298 <net_buf_simple_add>
	memcpy(req->e, e, sizeof(req->e));
 100f6da:	2210      	movs	r2, #16
 100f6dc:	4641      	mov	r1, r8
 100f6de:	f017 f949 	bl	1026974 <memcpy>
	smp_send(smp, buf, NULL, NULL);
 100f6e2:	462a      	mov	r2, r5
 100f6e4:	4631      	mov	r1, r6
 100f6e6:	4620      	mov	r0, r4
 100f6e8:	f019 f812 	bl	1028710 <smp_send.constprop.0>
	atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
 100f6ec:	1d20      	adds	r0, r4, #4
 100f6ee:	2101      	movs	r1, #1
 100f6f0:	f019 f839 	bl	1028766 <atomic_set_bit>
	return 0;
 100f6f4:	4628      	mov	r0, r5
 100f6f6:	e79e      	b.n	100f636 <compute_and_check_and_send_periph_dhcheck+0xa6>
		return BT_SMP_ERR_DHKEY_CHECK_FAILED;
 100f6f8:	200b      	movs	r0, #11
 100f6fa:	e79c      	b.n	100f636 <compute_and_check_and_send_periph_dhcheck+0xa6>
 100f6fc:	0102e993 	.word	0x0102e993
 100f700:	010299e4 	.word	0x010299e4
 100f704:	0102e90e 	.word	0x0102e90e
 100f708:	0102e9a8 	.word	0x0102e9a8
 100f70c:	0102e9cb 	.word	0x0102e9cb

0100f710 <bt_smp_connected>:
{
 100f710:	b538      	push	{r3, r4, r5, lr}
 100f712:	4604      	mov	r4, r0
	k_work_init_delayable(&smp->work, smp_timeout);
 100f714:	4909      	ldr	r1, [pc, #36]	; (100f73c <bt_smp_connected+0x2c>)
 100f716:	f1a0 05f0 	sub.w	r5, r0, #240	; 0xf0
 100f71a:	30f8      	adds	r0, #248	; 0xf8
 100f71c:	f012 fbf6 	bl	1021f0c <k_work_init_delayable>
	smp_reset(smp);
 100f720:	4628      	mov	r0, r5
 100f722:	f019 f8be 	bl	10288a2 <smp_reset>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 100f726:	4b06      	ldr	r3, [pc, #24]	; (100f740 <bt_smp_connected+0x30>)
 100f728:	f504 7494 	add.w	r4, r4, #296	; 0x128
 100f72c:	e8d4 2fef 	ldaex	r2, [r4]
 100f730:	e8c4 3fe1 	stlex	r1, r3, [r4]
 100f734:	2900      	cmp	r1, #0
 100f736:	d1f9      	bne.n	100f72c <bt_smp_connected+0x1c>
}
 100f738:	bd38      	pop	{r3, r4, r5, pc}
 100f73a:	bf00      	nop
 100f73c:	0101042d 	.word	0x0101042d
 100f740:	210024e8 	.word	0x210024e8

0100f744 <smp_pairing_confirm>:
{
 100f744:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100f746:	4604      	mov	r4, r0
	struct bt_smp_pairing_confirm *req = (void *)buf->data;
 100f748:	68ce      	ldr	r6, [r1, #12]
	atomic_clear_bit(smp->flags, SMP_FLAG_DISPLAY);
 100f74a:	1d05      	adds	r5, r0, #4
{
 100f74c:	af00      	add	r7, sp, #0
	atomic_clear_bit(smp->flags, SMP_FLAG_DISPLAY);
 100f74e:	210b      	movs	r1, #11
 100f750:	4628      	mov	r0, r5
 100f752:	f018 ffd0 	bl	10286f6 <atomic_clear_bit>
	memcpy(smp->pcnf, req->val, sizeof(smp->pcnf));
 100f756:	4631      	mov	r1, r6
 100f758:	2210      	movs	r2, #16
 100f75a:	f104 0017 	add.w	r0, r4, #23
 100f75e:	f017 f909 	bl	1026974 <memcpy>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 100f762:	2105      	movs	r1, #5
 100f764:	4628      	mov	r0, r5
 100f766:	f018 ff9f 	bl	10286a8 <atomic_test_bit>
 100f76a:	b920      	cbnz	r0, 100f776 <smp_pairing_confirm+0x32>
		return legacy_pairing_confirm(smp);
 100f76c:	4620      	mov	r0, r4
 100f76e:	f019 f90d 	bl	102898c <legacy_pairing_confirm>
}
 100f772:	46bd      	mov	sp, r7
 100f774:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	switch (smp->method) {
 100f776:	7a23      	ldrb	r3, [r4, #8]
 100f778:	2b01      	cmp	r3, #1
 100f77a:	d008      	beq.n	100f78e <smp_pairing_confirm+0x4a>
 100f77c:	2b02      	cmp	r3, #2
 100f77e:	d112      	bne.n	100f7a6 <smp_pairing_confirm+0x62>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
 100f780:	2104      	movs	r1, #4
 100f782:	4620      	mov	r0, r4
 100f784:	f018 ffef 	bl	1028766 <atomic_set_bit>
		return smp_send_pairing_confirm(smp);
 100f788:	f7ff fbd8 	bl	100ef3c <smp_send_pairing_confirm>
 100f78c:	e7f1      	b.n	100f772 <smp_pairing_confirm+0x2e>
		if (atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
 100f78e:	210a      	movs	r1, #10
 100f790:	4628      	mov	r0, r5
 100f792:	f018 ff89 	bl	10286a8 <atomic_test_bit>
 100f796:	2800      	cmp	r0, #0
 100f798:	d0f2      	beq.n	100f780 <smp_pairing_confirm+0x3c>
			atomic_set_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
 100f79a:	4628      	mov	r0, r5
 100f79c:	2100      	movs	r1, #0
 100f79e:	f018 ffe2 	bl	1028766 <atomic_set_bit>
			return 0;
 100f7a2:	2000      	movs	r0, #0
 100f7a4:	e7e5      	b.n	100f772 <smp_pairing_confirm+0x2e>
		LOG_ERR("Unknown pairing method (%u)", smp->method);
 100f7a6:	466c      	mov	r4, sp
 100f7a8:	b088      	sub	sp, #32
 100f7aa:	466a      	mov	r2, sp
 100f7ac:	4906      	ldr	r1, [pc, #24]	; (100f7c8 <smp_pairing_confirm+0x84>)
 100f7ae:	4807      	ldr	r0, [pc, #28]	; (100f7cc <smp_pairing_confirm+0x88>)
	switch (smp->method) {
 100f7b0:	e9c2 1305 	strd	r1, r3, [r2, #20]
		LOG_ERR("Unknown pairing method (%u)", smp->method);
 100f7b4:	2303      	movs	r3, #3
 100f7b6:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100f7ba:	f842 3f10 	str.w	r3, [r2, #16]!
 100f7be:	f018 ffc4 	bl	102874a <z_log_msg_static_create.constprop.0>
		return BT_SMP_ERR_UNSPECIFIED;
 100f7c2:	2008      	movs	r0, #8
 100f7c4:	46a5      	mov	sp, r4
 100f7c6:	e7d4      	b.n	100f772 <smp_pairing_confirm+0x2e>
 100f7c8:	0102e90e 	.word	0x0102e90e
 100f7cc:	010299e4 	.word	0x010299e4

0100f7d0 <smp_pairing_random>:
{
 100f7d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100f7d4:	b08e      	sub	sp, #56	; 0x38
 100f7d6:	4604      	mov	r4, r0
 100f7d8:	af04      	add	r7, sp, #16
 100f7da:	460d      	mov	r5, r1
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100f7dc:	f7ff fa38 	bl	100ec50 <latch_auth_cb>
	memcpy(smp->rrnd, req->val, sizeof(smp->rrnd));
 100f7e0:	f104 0837 	add.w	r8, r4, #55	; 0x37
 100f7e4:	68e9      	ldr	r1, [r5, #12]
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100f7e6:	4606      	mov	r6, r0
	memcpy(smp->rrnd, req->val, sizeof(smp->rrnd));
 100f7e8:	2210      	movs	r2, #16
 100f7ea:	4640      	mov	r0, r8
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 100f7ec:	1d25      	adds	r5, r4, #4
	memcpy(smp->rrnd, req->val, sizeof(smp->rrnd));
 100f7ee:	f017 f8c1 	bl	1026974 <memcpy>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 100f7f2:	2105      	movs	r1, #5
 100f7f4:	4628      	mov	r0, r5
 100f7f6:	f018 ff57 	bl	10286a8 <atomic_test_bit>
 100f7fa:	2800      	cmp	r0, #0
 100f7fc:	d148      	bne.n	100f890 <smp_pairing_random+0xc0>
	struct bt_conn *conn = smp->chan.chan.conn;
 100f7fe:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
	err = smp_c1(smp->tk, smp->rrnd, smp->preq, smp->prsp,
 100f802:	f104 0647 	add.w	r6, r4, #71	; 0x47
		     &conn->le.init_addr, &conn->le.resp_addr, tmp);
 100f806:	f103 029e 	add.w	r2, r3, #158	; 0x9e
 100f80a:	3397      	adds	r3, #151	; 0x97
	err = smp_c1(smp->tk, smp->rrnd, smp->preq, smp->prsp,
 100f80c:	9201      	str	r2, [sp, #4]
 100f80e:	9300      	str	r3, [sp, #0]
 100f810:	4641      	mov	r1, r8
 100f812:	4630      	mov	r0, r6
 100f814:	9702      	str	r7, [sp, #8]
 100f816:	f104 0310 	add.w	r3, r4, #16
 100f81a:	f104 0209 	add.w	r2, r4, #9
 100f81e:	f019 f85b 	bl	10288d8 <smp_c1>
	if (err) {
 100f822:	bb18      	cbnz	r0, 100f86c <smp_pairing_random+0x9c>
	if (memcmp(smp->pcnf, tmp, sizeof(smp->pcnf))) {
 100f824:	2210      	movs	r2, #16
 100f826:	4639      	mov	r1, r7
 100f828:	f104 0017 	add.w	r0, r4, #23
 100f82c:	f017 f892 	bl	1026954 <memcmp>
 100f830:	2800      	cmp	r0, #0
 100f832:	d16e      	bne.n	100f912 <smp_pairing_random+0x142>
	memcpy(out, r2, 8);
 100f834:	2208      	movs	r2, #8
 100f836:	4641      	mov	r1, r8
 100f838:	4638      	mov	r0, r7
 100f83a:	f017 f89b 	bl	1026974 <memcpy>
	memcpy(out + 8, r1, 8);
 100f83e:	2208      	movs	r2, #8
 100f840:	f104 0127 	add.w	r1, r4, #39	; 0x27
 100f844:	18b8      	adds	r0, r7, r2
 100f846:	f017 f895 	bl	1026974 <memcpy>
	return bt_encrypt_le(k, out, out);
 100f84a:	463a      	mov	r2, r7
 100f84c:	4639      	mov	r1, r7
 100f84e:	4630      	mov	r0, r6
 100f850:	f004 f870 	bl	1013934 <bt_encrypt_le>
		if (err) {
 100f854:	b178      	cbz	r0, 100f876 <smp_pairing_random+0xa6>
			LOG_ERR("Calculate STK failed");
 100f856:	4b5f      	ldr	r3, [pc, #380]	; (100f9d4 <smp_pairing_random+0x204>)
		LOG_ERR("Calculate confirm failed");
 100f858:	627b      	str	r3, [r7, #36]	; 0x24
 100f85a:	2302      	movs	r3, #2
 100f85c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100f860:	485d      	ldr	r0, [pc, #372]	; (100f9d8 <smp_pairing_random+0x208>)
 100f862:	623b      	str	r3, [r7, #32]
 100f864:	f107 0220 	add.w	r2, r7, #32
 100f868:	f018 ff6f 	bl	102874a <z_log_msg_static_create.constprop.0>
		return BT_SMP_ERR_UNSPECIFIED;
 100f86c:	2008      	movs	r0, #8
}
 100f86e:	3728      	adds	r7, #40	; 0x28
 100f870:	46bd      	mov	sp, r7
 100f872:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		memcpy(smp->tk, tmp, sizeof(smp->tk));
 100f876:	4639      	mov	r1, r7
 100f878:	2210      	movs	r2, #16
 100f87a:	4630      	mov	r0, r6
 100f87c:	f017 f87a 	bl	1026974 <memcpy>
		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
 100f880:	2101      	movs	r1, #1
	atomic_set_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
 100f882:	4628      	mov	r0, r5
 100f884:	f018 ff6f 	bl	1028766 <atomic_set_bit>
	return smp_send_pairing_random(smp);
 100f888:	4620      	mov	r0, r4
 100f88a:	f018 ffb4 	bl	10287f6 <smp_send_pairing_random>
 100f88e:	e7ee      	b.n	100f86e <smp_pairing_random+0x9e>
	switch (smp->method) {
 100f890:	7a23      	ldrb	r3, [r4, #8]
 100f892:	2b05      	cmp	r3, #5
 100f894:	f200 808c 	bhi.w	100f9b0 <smp_pairing_random+0x1e0>
 100f898:	e8df f003 	tbb	[pc, r3]
 100f89c:	0320201a 	.word	0x0320201a
 100f8a0:	618a      	.short	0x618a
		if (bt_crypto_g2(smp->pkey, sc_public_key, smp->rrnd, smp->prnd, &passkey)) {
 100f8a2:	f107 0310 	add.w	r3, r7, #16
 100f8a6:	494d      	ldr	r1, [pc, #308]	; (100f9dc <smp_pairing_random+0x20c>)
 100f8a8:	9300      	str	r3, [sp, #0]
 100f8aa:	4642      	mov	r2, r8
 100f8ac:	6809      	ldr	r1, [r1, #0]
 100f8ae:	f104 0327 	add.w	r3, r4, #39	; 0x27
 100f8b2:	f104 0057 	add.w	r0, r4, #87	; 0x57
 100f8b6:	f001 fa53 	bl	1010d60 <bt_crypto_g2>
 100f8ba:	2800      	cmp	r0, #0
 100f8bc:	d1d6      	bne.n	100f86c <smp_pairing_random+0x9c>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
 100f8be:	210a      	movs	r1, #10
 100f8c0:	4628      	mov	r0, r5
 100f8c2:	f018 ff50 	bl	1028766 <atomic_set_bit>
		smp_auth_cb->passkey_confirm(smp->chan.chan.conn, passkey);
 100f8c6:	68b3      	ldr	r3, [r6, #8]
 100f8c8:	6939      	ldr	r1, [r7, #16]
 100f8ca:	f8d4 00f0 	ldr.w	r0, [r4, #240]	; 0xf0
 100f8ce:	4798      	blx	r3
	atomic_set_bit(smp->allowed_cmds, BT_SMP_DHKEY_CHECK);
 100f8d0:	210d      	movs	r1, #13
 100f8d2:	4620      	mov	r0, r4
 100f8d4:	f018 ff47 	bl	1028766 <atomic_set_bit>
	atomic_set_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
 100f8d8:	2110      	movs	r1, #16
 100f8da:	e7d2      	b.n	100f882 <smp_pairing_random+0xb2>
		r = (smp->passkey >> smp->passkey_round) & 0x01;
 100f8dc:	f894 20dc 	ldrb.w	r2, [r4, #220]	; 0xdc
 100f8e0:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
	if (bt_crypto_f4(smp->pkey, sc_public_key, smp->rrnd, r, cfm)) {
 100f8e4:	493d      	ldr	r1, [pc, #244]	; (100f9dc <smp_pairing_random+0x20c>)
		r = (smp->passkey >> smp->passkey_round) & 0x01;
 100f8e6:	40d3      	lsrs	r3, r2
 100f8e8:	f003 0301 	and.w	r3, r3, #1
	if (bt_crypto_f4(smp->pkey, sc_public_key, smp->rrnd, r, cfm)) {
 100f8ec:	9700      	str	r7, [sp, #0]
 100f8ee:	4642      	mov	r2, r8
 100f8f0:	6809      	ldr	r1, [r1, #0]
 100f8f2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 100f8f6:	f104 0057 	add.w	r0, r4, #87	; 0x57
 100f8fa:	f019 f9b3 	bl	1028c64 <bt_crypto_f4>
 100f8fe:	b108      	cbz	r0, 100f904 <smp_pairing_random+0x134>
		LOG_ERR("Calculate confirm failed");
 100f900:	4b37      	ldr	r3, [pc, #220]	; (100f9e0 <smp_pairing_random+0x210>)
 100f902:	e7a9      	b.n	100f858 <smp_pairing_random+0x88>
	if (memcmp(smp->pcnf, cfm, 16)) {
 100f904:	2210      	movs	r2, #16
 100f906:	4639      	mov	r1, r7
 100f908:	f104 0017 	add.w	r0, r4, #23
 100f90c:	f017 f822 	bl	1026954 <memcmp>
 100f910:	b108      	cbz	r0, 100f916 <smp_pairing_random+0x146>
		return BT_SMP_ERR_CONFIRM_FAILED;
 100f912:	2004      	movs	r0, #4
 100f914:	e7ab      	b.n	100f86e <smp_pairing_random+0x9e>
		atomic_set_bit(smp->allowed_cmds,
 100f916:	2103      	movs	r1, #3
 100f918:	4620      	mov	r0, r4
 100f91a:	f018 ff24 	bl	1028766 <atomic_set_bit>
		err = smp_send_pairing_random(smp);
 100f91e:	f018 ff6a 	bl	10287f6 <smp_send_pairing_random>
		if (err) {
 100f922:	2800      	cmp	r0, #0
 100f924:	d1a3      	bne.n	100f86e <smp_pairing_random+0x9e>
		smp->passkey_round++;
 100f926:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
 100f92a:	3301      	adds	r3, #1
 100f92c:	b2db      	uxtb	r3, r3
		if (smp->passkey_round == 20U) {
 100f92e:	2b14      	cmp	r3, #20
		smp->passkey_round++;
 100f930:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
		if (smp->passkey_round == 20U) {
 100f934:	d109      	bne.n	100f94a <smp_pairing_random+0x17a>
			atomic_set_bit(smp->allowed_cmds, BT_SMP_DHKEY_CHECK);
 100f936:	210d      	movs	r1, #13
 100f938:	4620      	mov	r0, r4
 100f93a:	f018 ff14 	bl	1028766 <atomic_set_bit>
			atomic_set_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
 100f93e:	2110      	movs	r1, #16
 100f940:	4628      	mov	r0, r5
 100f942:	f018 ff10 	bl	1028766 <atomic_set_bit>
			return 0;
 100f946:	2000      	movs	r0, #0
 100f948:	e791      	b.n	100f86e <smp_pairing_random+0x9e>
		if (bt_rand(smp->prnd, 16)) {
 100f94a:	2110      	movs	r1, #16
 100f94c:	f104 0027 	add.w	r0, r4, #39	; 0x27
 100f950:	f003 ffee 	bl	1013930 <bt_rand>
 100f954:	3800      	subs	r0, #0
 100f956:	bf18      	it	ne
 100f958:	2001      	movne	r0, #1
 100f95a:	00c0      	lsls	r0, r0, #3
 100f95c:	e787      	b.n	100f86e <smp_pairing_random+0x9e>
		if (bt_rand(smp->prnd, 16)) {
 100f95e:	2110      	movs	r1, #16
 100f960:	f104 0027 	add.w	r0, r4, #39	; 0x27
 100f964:	f003 ffe4 	bl	1013930 <bt_rand>
 100f968:	2800      	cmp	r0, #0
 100f96a:	f47f af7f 	bne.w	100f86c <smp_pairing_random+0x9c>
		if (smp_auth_cb && smp_auth_cb->oob_data_request) {
 100f96e:	b37e      	cbz	r6, 100f9d0 <smp_pairing_random+0x200>
 100f970:	68f3      	ldr	r3, [r6, #12]
 100f972:	b36b      	cbz	r3, 100f9d0 <smp_pairing_random+0x200>
			struct bt_conn_oob_info info = {
 100f974:	4b1b      	ldr	r3, [pc, #108]	; (100f9e4 <smp_pairing_random+0x214>)
	return ((req->oob_flag & BT_SMP_OOB_DATA_MASK) == BT_SMP_OOB_PRESENT);
 100f976:	7ae2      	ldrb	r2, [r4, #11]
			struct bt_conn_oob_info info = {
 100f978:	881b      	ldrh	r3, [r3, #0]
		oob_config = req_oob_present ? BT_CONN_OOB_LOCAL_ONLY :
 100f97a:	07d2      	lsls	r2, r2, #31
			struct bt_conn_oob_info info = {
 100f97c:	823b      	strh	r3, [r7, #16]
	return ((rsp->oob_flag & BT_SMP_OOB_DATA_MASK) == BT_SMP_OOB_PRESENT);
 100f97e:	7ca3      	ldrb	r3, [r4, #18]
 100f980:	f003 0301 	and.w	r3, r3, #1
		oob_config = req_oob_present ? BT_CONN_OOB_LOCAL_ONLY :
 100f984:	d412      	bmi.n	100f9ac <smp_pairing_random+0x1dc>
 100f986:	2b00      	cmp	r3, #0
 100f988:	bf14      	ite	ne
 100f98a:	2301      	movne	r3, #1
 100f98c:	2303      	moveq	r3, #3
	info->lesc.oob_config = oob_config;
 100f98e:	747b      	strb	r3, [r7, #17]
			smp->oobd_local = NULL;
 100f990:	2300      	movs	r3, #0
			atomic_set_bit(smp->flags, SMP_FLAG_OOB_PENDING);
 100f992:	4628      	mov	r0, r5
			smp->oobd_remote = NULL;
 100f994:	e9c4 3338 	strd	r3, r3, [r4, #224]	; 0xe0
			atomic_set_bit(smp->flags, SMP_FLAG_OOB_PENDING);
 100f998:	210c      	movs	r1, #12
 100f99a:	f018 fee4 	bl	1028766 <atomic_set_bit>
			smp_auth_cb->oob_data_request(smp->chan.chan.conn, &info);
 100f99e:	68f3      	ldr	r3, [r6, #12]
 100f9a0:	f8d4 00f0 	ldr.w	r0, [r4, #240]	; 0xf0
 100f9a4:	f107 0110 	add.w	r1, r7, #16
 100f9a8:	4798      	blx	r3
			return 0;
 100f9aa:	e7cc      	b.n	100f946 <smp_pairing_random+0x176>
		if (rsp_oob_present) {
 100f9ac:	005b      	lsls	r3, r3, #1
 100f9ae:	e7ee      	b.n	100f98e <smp_pairing_random+0x1be>
		LOG_ERR("Unknown pairing method (%u)", smp->method);
 100f9b0:	466c      	mov	r4, sp
 100f9b2:	b088      	sub	sp, #32
 100f9b4:	aa04      	add	r2, sp, #16
 100f9b6:	490c      	ldr	r1, [pc, #48]	; (100f9e8 <smp_pairing_random+0x218>)
 100f9b8:	4807      	ldr	r0, [pc, #28]	; (100f9d8 <smp_pairing_random+0x208>)
	switch (smp->method) {
 100f9ba:	e9c2 1305 	strd	r1, r3, [r2, #20]
		LOG_ERR("Unknown pairing method (%u)", smp->method);
 100f9be:	2303      	movs	r3, #3
 100f9c0:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 100f9c4:	f842 3f10 	str.w	r3, [r2, #16]!
 100f9c8:	f018 febf 	bl	102874a <z_log_msg_static_create.constprop.0>
 100f9cc:	46a5      	mov	sp, r4
		return BT_SMP_ERR_UNSPECIFIED;
 100f9ce:	e74d      	b.n	100f86c <smp_pairing_random+0x9c>
			return BT_SMP_ERR_OOB_NOT_AVAIL;
 100f9d0:	2002      	movs	r0, #2
 100f9d2:	e74c      	b.n	100f86e <smp_pairing_random+0x9e>
 100f9d4:	0102e9ef 	.word	0x0102e9ef
 100f9d8:	010299e4 	.word	0x010299e4
 100f9dc:	2100498c 	.word	0x2100498c
 100f9e0:	0102ea04 	.word	0x0102ea04
 100f9e4:	01029b50 	.word	0x01029b50
 100f9e8:	0102e90e 	.word	0x0102e90e

0100f9ec <bt_smp_start_security>:
{
 100f9ec:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	switch (conn->role) {
 100f9f0:	78c6      	ldrb	r6, [r0, #3]
{
 100f9f2:	4604      	mov	r4, r0
	switch (conn->role) {
 100f9f4:	2e01      	cmp	r6, #1
 100f9f6:	d005      	beq.n	100fa04 <bt_smp_start_security+0x18>
		return -EINVAL;
 100f9f8:	f06f 0415 	mvn.w	r4, #21
}
 100f9fc:	4620      	mov	r0, r4
 100f9fe:	b003      	add	sp, #12
 100fa00:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	smp = smp_chan_get(conn);
 100fa04:	f018 fea4 	bl	1028750 <smp_chan_get>
	if (!smp) {
 100fa08:	4605      	mov	r5, r0
 100fa0a:	2800      	cmp	r0, #0
 100fa0c:	f000 80ac 	beq.w	100fb68 <bt_smp_start_security+0x17c>
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
 100fa10:	1d07      	adds	r7, r0, #4
 100fa12:	2104      	movs	r1, #4
 100fa14:	4638      	mov	r0, r7
 100fa16:	f018 fe47 	bl	10286a8 <atomic_test_bit>
 100fa1a:	2800      	cmp	r0, #0
 100fa1c:	f040 80a7 	bne.w	100fb6e <bt_smp_start_security+0x182>
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
 100fa20:	2103      	movs	r1, #3
 100fa22:	4638      	mov	r0, r7
 100fa24:	f018 fe40 	bl	10286a8 <atomic_test_bit>
 100fa28:	b110      	cbz	r0, 100fa30 <bt_smp_start_security+0x44>
		return -EBUSY;
 100fa2a:	f06f 040f 	mvn.w	r4, #15
 100fa2e:	e7e5      	b.n	100f9fc <bt_smp_start_security+0x10>
	if (atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
 100fa30:	4631      	mov	r1, r6
 100fa32:	4638      	mov	r0, r7
 100fa34:	f018 fe38 	bl	10286a8 <atomic_test_bit>
 100fa38:	2800      	cmp	r0, #0
 100fa3a:	d1f6      	bne.n	100fa2a <bt_smp_start_security+0x3e>
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100fa3c:	4628      	mov	r0, r5
 100fa3e:	f7ff f907 	bl	100ec50 <latch_auth_cb>
	switch (smp->chan.chan.conn->required_sec_level) {
 100fa42:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 100fa46:	4606      	mov	r6, r0
	switch (smp->chan.chan.conn->required_sec_level) {
 100fa48:	7a9b      	ldrb	r3, [r3, #10]
 100fa4a:	2b03      	cmp	r3, #3
 100fa4c:	d042      	beq.n	100fad4 <bt_smp_start_security+0xe8>
 100fa4e:	d832      	bhi.n	100fab6 <bt_smp_start_security+0xca>
 100fa50:	3b01      	subs	r3, #1
 100fa52:	2b01      	cmp	r3, #1
 100fa54:	d948      	bls.n	100fae8 <bt_smp_start_security+0xfc>
	if (atomic_test_bit(conn->flags, BT_CONN_FORCE_PAIR)) {
 100fa56:	210b      	movs	r1, #11
 100fa58:	1d20      	adds	r0, r4, #4
 100fa5a:	f018 fe25 	bl	10286a8 <atomic_test_bit>
 100fa5e:	2800      	cmp	r0, #0
 100fa60:	d1ca      	bne.n	100f9f8 <bt_smp_start_security+0xc>
	if (!conn->le.keys) {
 100fa62:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 100fa66:	b983      	cbnz	r3, 100fa8a <bt_smp_start_security+0x9e>
						     conn->id, &conn->le.dst);
 100fa68:	f104 0690 	add.w	r6, r4, #144	; 0x90
		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256,
 100fa6c:	4632      	mov	r2, r6
 100fa6e:	2020      	movs	r0, #32
 100fa70:	7a21      	ldrb	r1, [r4, #8]
 100fa72:	f000 fe7d 	bl	1010770 <bt_keys_find>
 100fa76:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
		if (!conn->le.keys) {
 100fa7a:	b930      	cbnz	r0, 100fa8a <bt_smp_start_security+0x9e>
			conn->le.keys = bt_keys_find(BT_KEYS_LTK,
 100fa7c:	4632      	mov	r2, r6
 100fa7e:	2004      	movs	r0, #4
 100fa80:	7a21      	ldrb	r1, [r4, #8]
 100fa82:	f000 fe75 	bl	1010770 <bt_keys_find>
 100fa86:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
	if (!conn->le.keys ||
 100fa8a:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 100fa8e:	2b00      	cmp	r3, #0
 100fa90:	d0b2      	beq.n	100f9f8 <bt_smp_start_security+0xc>
	    !(conn->le.keys->keys & (BT_KEYS_LTK | BT_KEYS_LTK_P256))) {
 100fa92:	89da      	ldrh	r2, [r3, #14]
	if (!conn->le.keys ||
 100fa94:	f012 0f24 	tst.w	r2, #36	; 0x24
 100fa98:	d0ae      	beq.n	100f9f8 <bt_smp_start_security+0xc>
	if (conn->required_sec_level >= BT_SECURITY_L3 &&
 100fa9a:	7aa1      	ldrb	r1, [r4, #10]
 100fa9c:	2902      	cmp	r1, #2
 100fa9e:	d923      	bls.n	100fae8 <bt_smp_start_security+0xfc>
 100faa0:	7b58      	ldrb	r0, [r3, #13]
 100faa2:	07c0      	lsls	r0, r0, #31
 100faa4:	d5a8      	bpl.n	100f9f8 <bt_smp_start_security+0xc>
	if (conn->required_sec_level >= BT_SECURITY_L4 &&
 100faa6:	2903      	cmp	r1, #3
 100faa8:	d01e      	beq.n	100fae8 <bt_smp_start_security+0xfc>
	    !((conn->le.keys->flags & BT_KEYS_AUTHENTICATED) &&
 100faaa:	0692      	lsls	r2, r2, #26
 100faac:	d5a4      	bpl.n	100f9f8 <bt_smp_start_security+0xc>
 100faae:	7b1b      	ldrb	r3, [r3, #12]
 100fab0:	2b10      	cmp	r3, #16
 100fab2:	d1a1      	bne.n	100f9f8 <bt_smp_start_security+0xc>
 100fab4:	e018      	b.n	100fae8 <bt_smp_start_security+0xfc>
	switch (smp->chan.chan.conn->required_sec_level) {
 100fab6:	2b04      	cmp	r3, #4
 100fab8:	d1cd      	bne.n	100fa56 <bt_smp_start_security+0x6a>
		return (get_io_capa(smp) != BT_SMP_IO_NO_INPUT_OUTPUT ||
 100faba:	4628      	mov	r0, r5
 100fabc:	f7ff f8de 	bl	100ec7c <get_io_capa>
		       (smp_auth_cb && smp_auth_cb->oob_data_request)) && sc_supported;
 100fac0:	2803      	cmp	r0, #3
 100fac2:	d104      	bne.n	100face <bt_smp_start_security+0xe2>
		return (get_io_capa(smp) != BT_SMP_IO_NO_INPUT_OUTPUT ||
 100fac4:	2e00      	cmp	r6, #0
 100fac6:	d0c6      	beq.n	100fa56 <bt_smp_start_security+0x6a>
		       (smp_auth_cb && smp_auth_cb->oob_data_request)) && sc_supported;
 100fac8:	68f3      	ldr	r3, [r6, #12]
 100faca:	2b00      	cmp	r3, #0
 100facc:	d0c3      	beq.n	100fa56 <bt_smp_start_security+0x6a>
 100face:	4b29      	ldr	r3, [pc, #164]	; (100fb74 <bt_smp_start_security+0x188>)
 100fad0:	781b      	ldrb	r3, [r3, #0]
 100fad2:	e007      	b.n	100fae4 <bt_smp_start_security+0xf8>
		return get_io_capa(smp) != BT_SMP_IO_NO_INPUT_OUTPUT ||
 100fad4:	4628      	mov	r0, r5
 100fad6:	f7ff f8d1 	bl	100ec7c <get_io_capa>
 100fada:	2803      	cmp	r0, #3
 100fadc:	d104      	bne.n	100fae8 <bt_smp_start_security+0xfc>
 100fade:	2e00      	cmp	r6, #0
 100fae0:	d0b9      	beq.n	100fa56 <bt_smp_start_security+0x6a>
		       (smp_auth_cb && smp_auth_cb->oob_data_request);
 100fae2:	68f3      	ldr	r3, [r6, #12]
		       (smp_auth_cb && smp_auth_cb->oob_data_request)) && sc_supported;
 100fae4:	2b00      	cmp	r3, #0
 100fae6:	d0b6      	beq.n	100fa56 <bt_smp_start_security+0x6a>
	if (!conn->le.keys) {
 100fae8:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 100faec:	b13b      	cbz	r3, 100fafe <bt_smp_start_security+0x112>
	if (smp_init(smp) != 0) {
 100faee:	4628      	mov	r0, r5
 100faf0:	f7ff f966 	bl	100edc0 <smp_init>
 100faf4:	4680      	mov	r8, r0
 100faf6:	b170      	cbz	r0, 100fb16 <bt_smp_start_security+0x12a>
		return -ENOBUFS;
 100faf8:	f06f 0468 	mvn.w	r4, #104	; 0x68
 100fafc:	e77e      	b.n	100f9fc <bt_smp_start_security+0x10>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
 100fafe:	7a20      	ldrb	r0, [r4, #8]
 100fb00:	f104 0190 	add.w	r1, r4, #144	; 0x90
 100fb04:	f000 fdee 	bl	10106e4 <bt_keys_get_addr>
 100fb08:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
		if (!conn->le.keys) {
 100fb0c:	2800      	cmp	r0, #0
 100fb0e:	d1ee      	bne.n	100faee <bt_smp_start_security+0x102>
			return -ENOMEM;
 100fb10:	f06f 040b 	mvn.w	r4, #11
 100fb14:	e772      	b.n	100f9fc <bt_smp_start_security+0x10>
	req_buf = smp_create_pdu(smp, BT_SMP_CMD_SECURITY_REQUEST,
 100fb16:	210b      	movs	r1, #11
 100fb18:	4628      	mov	r0, r5
 100fb1a:	f018 fe34 	bl	1028786 <smp_create_pdu.constprop.0>
	if (!req_buf) {
 100fb1e:	4606      	mov	r6, r0
 100fb20:	2800      	cmp	r0, #0
 100fb22:	d0e9      	beq.n	100faf8 <bt_smp_start_security+0x10c>
 100fb24:	2101      	movs	r1, #1
 100fb26:	300c      	adds	r0, #12
 100fb28:	f00e fbb6 	bl	101e298 <net_buf_simple_add>
	req->auth_req = get_auth(smp, BT_SMP_AUTH_DEFAULT);
 100fb2c:	2109      	movs	r1, #9
 100fb2e:	4681      	mov	r9, r0
 100fb30:	4628      	mov	r0, r5
 100fb32:	f7ff f8c9 	bl	100ecc8 <get_auth>
		     bt_conn_tx_cb_t cb, void *user_data);

static inline int bt_l2cap_send(struct bt_conn *conn, uint16_t cid,
				struct net_buf *buf)
{
	return bt_l2cap_send_cb(conn, cid, buf, NULL, NULL);
 100fb36:	4643      	mov	r3, r8
 100fb38:	f889 0000 	strb.w	r0, [r9]
 100fb3c:	4632      	mov	r2, r6
 100fb3e:	4620      	mov	r0, r4
 100fb40:	2106      	movs	r1, #6
 100fb42:	f8cd 8000 	str.w	r8, [sp]
 100fb46:	f017 fd09 	bl	102755c <bt_l2cap_send_cb>
	if (err) {
 100fb4a:	4604      	mov	r4, r0
 100fb4c:	b118      	cbz	r0, 100fb56 <bt_smp_start_security+0x16a>
		net_buf_unref(req_buf);
 100fb4e:	4630      	mov	r0, r6
 100fb50:	f00e fa46 	bl	101dfe0 <net_buf_unref>
		return err;
 100fb54:	e752      	b.n	100f9fc <bt_smp_start_security+0x10>
	atomic_set_bit(smp->flags, SMP_FLAG_SEC_REQ);
 100fb56:	4638      	mov	r0, r7
 100fb58:	210f      	movs	r1, #15
 100fb5a:	f018 fe04 	bl	1028766 <atomic_set_bit>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
 100fb5e:	2101      	movs	r1, #1
 100fb60:	4628      	mov	r0, r5
 100fb62:	f018 fe00 	bl	1028766 <atomic_set_bit>
	return 0;
 100fb66:	e749      	b.n	100f9fc <bt_smp_start_security+0x10>
		return -ENOTCONN;
 100fb68:	f06f 047f 	mvn.w	r4, #127	; 0x7f
 100fb6c:	e746      	b.n	100f9fc <bt_smp_start_security+0x10>
		return -EIO;
 100fb6e:	f06f 0404 	mvn.w	r4, #4
 100fb72:	e743      	b.n	100f9fc <bt_smp_start_security+0x10>
 100fb74:	21008346 	.word	0x21008346

0100fb78 <smp_pairing_complete>:
{
 100fb78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100fb7a:	4606      	mov	r6, r0
	struct bt_conn *conn = smp->chan.chan.conn;
 100fb7c:	f8d0 50f0 	ldr.w	r5, [r0, #240]	; 0xf0
		bool bond_flag = atomic_test_bit(smp->flags, SMP_FLAG_BOND);
 100fb80:	1d04      	adds	r4, r0, #4
	if (!status) {
 100fb82:	bb61      	cbnz	r1, 100fbde <smp_pairing_complete+0x66>
		bool bond_flag = atomic_test_bit(smp->flags, SMP_FLAG_BOND);
 100fb84:	210d      	movs	r1, #13
 100fb86:	4620      	mov	r0, r4
 100fb88:	f018 fd8e 	bl	10286a8 <atomic_test_bit>
		if (bond_flag) {
 100fb8c:	4607      	mov	r7, r0
 100fb8e:	b118      	cbz	r0, 100fb98 <smp_pairing_complete+0x20>
			bt_keys_store(conn->le.keys);
 100fb90:	f8d5 00c0 	ldr.w	r0, [r5, #192]	; 0xc0
 100fb94:	f001 f806 	bl	1010ba4 <bt_keys_store>
	return list->head;
 100fb98:	4b36      	ldr	r3, [pc, #216]	; (100fc74 <smp_pairing_complete+0xfc>)
 100fb9a:	681b      	ldr	r3, [r3, #0]
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener,
 100fb9c:	b19b      	cbz	r3, 100fbc6 <smp_pairing_complete+0x4e>
	return node->next;
 100fb9e:	681c      	ldr	r4, [r3, #0]
 100fba0:	b104      	cbz	r4, 100fba4 <smp_pairing_complete+0x2c>
 100fba2:	3c0c      	subs	r4, #12
			if (listener->pairing_complete) {
 100fba4:	f853 3c0c 	ldr.w	r3, [r3, #-12]
 100fba8:	b113      	cbz	r3, 100fbb0 <smp_pairing_complete+0x38>
				listener->pairing_complete(conn, bond_flag);
 100fbaa:	4639      	mov	r1, r7
 100fbac:	4628      	mov	r0, r5
 100fbae:	4798      	blx	r3
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener,
 100fbb0:	b14c      	cbz	r4, 100fbc6 <smp_pairing_complete+0x4e>
 100fbb2:	4623      	mov	r3, r4
 100fbb4:	68e4      	ldr	r4, [r4, #12]
 100fbb6:	681b      	ldr	r3, [r3, #0]
 100fbb8:	b11c      	cbz	r4, 100fbc2 <smp_pairing_complete+0x4a>
 100fbba:	3c0c      	subs	r4, #12
			if (listener->pairing_complete) {
 100fbbc:	2b00      	cmp	r3, #0
 100fbbe:	d1f4      	bne.n	100fbaa <smp_pairing_complete+0x32>
 100fbc0:	e7f7      	b.n	100fbb2 <smp_pairing_complete+0x3a>
 100fbc2:	2b00      	cmp	r3, #0
 100fbc4:	d1f1      	bne.n	100fbaa <smp_pairing_complete+0x32>
	smp_reset(smp);
 100fbc6:	4630      	mov	r0, r6
 100fbc8:	f018 fe6b 	bl	10288a2 <smp_reset>
	if (conn->sec_level != conn->required_sec_level) {
 100fbcc:	7a6a      	ldrb	r2, [r5, #9]
 100fbce:	7aab      	ldrb	r3, [r5, #10]
 100fbd0:	429a      	cmp	r2, r3
 100fbd2:	d04d      	beq.n	100fc70 <smp_pairing_complete+0xf8>
		bt_smp_start_security(conn);
 100fbd4:	4628      	mov	r0, r5
}
 100fbd6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		bt_smp_start_security(conn);
 100fbda:	f7ff bf07 	b.w	100f9ec <bt_smp_start_security>
	switch (smp_err) {
 100fbde:	3901      	subs	r1, #1
 100fbe0:	b2c9      	uxtb	r1, r1
 100fbe2:	290e      	cmp	r1, #14
 100fbe4:	bf96      	itet	ls
 100fbe6:	4b24      	ldrls	r3, [pc, #144]	; (100fc78 <smp_pairing_complete+0x100>)
	if (!status) {
 100fbe8:	2709      	movhi	r7, #9
 100fbea:	5c5f      	ldrbls	r7, [r3, r1]
		if (conn->le.keys &&
 100fbec:	f8d5 30c0 	ldr.w	r3, [r5, #192]	; 0xc0
 100fbf0:	b143      	cbz	r3, 100fc04 <smp_pairing_complete+0x8c>
 100fbf2:	7b1b      	ldrb	r3, [r3, #12]
 100fbf4:	bb33      	cbnz	r3, 100fc44 <smp_pairing_complete+0xcc>
			bt_keys_clear(conn->le.keys);
 100fbf6:	f8d5 00c0 	ldr.w	r0, [r5, #192]	; 0xc0
 100fbfa:	f000 febf 	bl	101097c <bt_keys_clear>
			conn->le.keys = NULL;
 100fbfe:	2300      	movs	r3, #0
 100fc00:	f8c5 30c0 	str.w	r3, [r5, #192]	; 0xc0
		if (!atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR)) {
 100fc04:	2102      	movs	r1, #2
 100fc06:	4620      	mov	r0, r4
 100fc08:	f018 fd4e 	bl	10286a8 <atomic_test_bit>
 100fc0c:	b948      	cbnz	r0, 100fc22 <smp_pairing_complete+0xaa>
	switch (err) {
 100fc0e:	2f07      	cmp	r7, #7
 100fc10:	bf94      	ite	ls
 100fc12:	4b1a      	ldrls	r3, [pc, #104]	; (100fc7c <smp_pairing_complete+0x104>)
		if (!atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR)) {
 100fc14:	211f      	movhi	r1, #31
			bt_conn_security_changed(conn,
 100fc16:	463a      	mov	r2, r7
 100fc18:	4628      	mov	r0, r5
 100fc1a:	bf98      	it	ls
 100fc1c:	5dd9      	ldrbls	r1, [r3, r7]
 100fc1e:	f7fa fcdf 	bl	100a5e0 <bt_conn_security_changed>
		if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
 100fc22:	2103      	movs	r1, #3
 100fc24:	4620      	mov	r0, r4
 100fc26:	f018 fd3f 	bl	10286a8 <atomic_test_bit>
 100fc2a:	2800      	cmp	r0, #0
 100fc2c:	d0cb      	beq.n	100fbc6 <smp_pairing_complete+0x4e>
	return list->head;
 100fc2e:	4b11      	ldr	r3, [pc, #68]	; (100fc74 <smp_pairing_complete+0xfc>)
 100fc30:	681b      	ldr	r3, [r3, #0]
			SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs,
 100fc32:	2b00      	cmp	r3, #0
 100fc34:	d0c7      	beq.n	100fbc6 <smp_pairing_complete+0x4e>
	return node->next;
 100fc36:	681c      	ldr	r4, [r3, #0]
 100fc38:	b104      	cbz	r4, 100fc3c <smp_pairing_complete+0xc4>
 100fc3a:	3c0c      	subs	r4, #12
				if (listener->pairing_failed) {
 100fc3c:	f853 3c08 	ldr.w	r3, [r3, #-8]
 100fc40:	b94b      	cbnz	r3, 100fc56 <smp_pairing_complete+0xde>
 100fc42:	e00b      	b.n	100fc5c <smp_pairing_complete+0xe4>
		     atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR))) {
 100fc44:	2102      	movs	r1, #2
 100fc46:	4620      	mov	r0, r4
 100fc48:	f018 fd2e 	bl	10286a8 <atomic_test_bit>
		    (!conn->le.keys->enc_size ||
 100fc4c:	2800      	cmp	r0, #0
 100fc4e:	d1d2      	bne.n	100fbf6 <smp_pairing_complete+0x7e>
 100fc50:	e7d8      	b.n	100fc04 <smp_pairing_complete+0x8c>
			SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs,
 100fc52:	3c0c      	subs	r4, #12
				if (listener->pairing_failed) {
 100fc54:	b123      	cbz	r3, 100fc60 <smp_pairing_complete+0xe8>
					listener->pairing_failed(conn, security_err);
 100fc56:	4639      	mov	r1, r7
 100fc58:	4628      	mov	r0, r5
 100fc5a:	4798      	blx	r3
			SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs,
 100fc5c:	2c00      	cmp	r4, #0
 100fc5e:	d0b2      	beq.n	100fbc6 <smp_pairing_complete+0x4e>
 100fc60:	4623      	mov	r3, r4
 100fc62:	68e4      	ldr	r4, [r4, #12]
 100fc64:	685b      	ldr	r3, [r3, #4]
 100fc66:	2c00      	cmp	r4, #0
 100fc68:	d1f3      	bne.n	100fc52 <smp_pairing_complete+0xda>
				if (listener->pairing_failed) {
 100fc6a:	2b00      	cmp	r3, #0
 100fc6c:	d1f3      	bne.n	100fc56 <smp_pairing_complete+0xde>
 100fc6e:	e7aa      	b.n	100fbc6 <smp_pairing_complete+0x4e>
}
 100fc70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 100fc72:	bf00      	nop
 100fc74:	21004744 	.word	0x21004744
 100fc78:	0102eca5 	.word	0x0102eca5
 100fc7c:	0102ec94 	.word	0x0102ec94

0100fc80 <smp_error>:
{
 100fc80:	b5f0      	push	{r4, r5, r6, r7, lr}
	remote_already_completed = (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR) &&
 100fc82:	1d03      	adds	r3, r0, #4
{
 100fc84:	4606      	mov	r6, r0
 100fc86:	460f      	mov	r7, r1
	remote_already_completed = (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR) &&
 100fc88:	4618      	mov	r0, r3
 100fc8a:	2102      	movs	r1, #2
{
 100fc8c:	b089      	sub	sp, #36	; 0x24
	remote_already_completed = (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR) &&
 100fc8e:	f018 fd0b 	bl	10286a8 <atomic_test_bit>
				    !smp->local_dist && !smp->remote_dist);
 100fc92:	4604      	mov	r4, r0
 100fc94:	b120      	cbz	r0, 100fca0 <smp_error+0x20>
 100fc96:	f8b6 40e8 	ldrh.w	r4, [r6, #232]	; 0xe8
 100fc9a:	fab4 f484 	clz	r4, r4
 100fc9e:	0964      	lsrs	r4, r4, #5
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) ||
 100fca0:	2103      	movs	r1, #3
 100fca2:	4618      	mov	r0, r3
 100fca4:	f018 fd00 	bl	10286a8 <atomic_test_bit>
 100fca8:	b1b0      	cbz	r0, 100fcd8 <smp_error+0x58>
		smp_pairing_complete(smp, reason);
 100fcaa:	4639      	mov	r1, r7
 100fcac:	4630      	mov	r0, r6
 100fcae:	f7ff ff63 	bl	100fb78 <smp_pairing_complete>
	if (remote_already_completed) {
 100fcb2:	b1f4      	cbz	r4, 100fcf2 <smp_error+0x72>
		LOG_WRN("SMP does not allow a pairing failure at this point. Known issue. "
 100fcb4:	4b1d      	ldr	r3, [pc, #116]	; (100fd2c <smp_error+0xac>)
 100fcb6:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100fcba:	9307      	str	r3, [sp, #28]
 100fcbc:	2302      	movs	r3, #2
 100fcbe:	481c      	ldr	r0, [pc, #112]	; (100fd30 <smp_error+0xb0>)
 100fcc0:	aa06      	add	r2, sp, #24
 100fcc2:	9306      	str	r3, [sp, #24]
 100fcc4:	f018 fd41 	bl	102874a <z_log_msg_static_create.constprop.0>
		bt_conn_disconnect(smp->chan.chan.conn, BT_HCI_ERR_AUTH_FAIL);
 100fcc8:	2105      	movs	r1, #5
 100fcca:	f8d6 00f0 	ldr.w	r0, [r6, #240]	; 0xf0
 100fcce:	f017 fa91 	bl	10271f4 <bt_conn_disconnect>
		return 0;
 100fcd2:	2000      	movs	r0, #0
}
 100fcd4:	b009      	add	sp, #36	; 0x24
 100fcd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	    atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING) ||
 100fcd8:	2101      	movs	r1, #1
 100fcda:	4618      	mov	r0, r3
 100fcdc:	f018 fce4 	bl	10286a8 <atomic_test_bit>
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) ||
 100fce0:	2800      	cmp	r0, #0
 100fce2:	d1e2      	bne.n	100fcaa <smp_error+0x2a>
	    atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ)) {
 100fce4:	210f      	movs	r1, #15
 100fce6:	4618      	mov	r0, r3
 100fce8:	f018 fcde 	bl	10286a8 <atomic_test_bit>
	    atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING) ||
 100fcec:	2800      	cmp	r0, #0
 100fcee:	d1dc      	bne.n	100fcaa <smp_error+0x2a>
 100fcf0:	e7df      	b.n	100fcb2 <smp_error+0x32>
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_FAIL, sizeof(*rsp));
 100fcf2:	2105      	movs	r1, #5
 100fcf4:	4630      	mov	r0, r6
 100fcf6:	f018 fd46 	bl	1028786 <smp_create_pdu.constprop.0>
	if (!buf) {
 100fcfa:	4605      	mov	r5, r0
 100fcfc:	b190      	cbz	r0, 100fd24 <smp_error+0xa4>
 100fcfe:	2101      	movs	r1, #1
 100fd00:	300c      	adds	r0, #12
 100fd02:	f00e fac9 	bl	101e298 <net_buf_simple_add>
	rsp->reason = reason;
 100fd06:	7007      	strb	r7, [r0, #0]
 100fd08:	9400      	str	r4, [sp, #0]
 100fd0a:	4623      	mov	r3, r4
 100fd0c:	462a      	mov	r2, r5
 100fd0e:	2106      	movs	r1, #6
 100fd10:	f8d6 00f0 	ldr.w	r0, [r6, #240]	; 0xf0
 100fd14:	f017 fc22 	bl	102755c <bt_l2cap_send_cb>
	if (bt_l2cap_send(smp->chan.chan.conn, BT_L2CAP_CID_SMP, buf)) {
 100fd18:	2800      	cmp	r0, #0
 100fd1a:	d0da      	beq.n	100fcd2 <smp_error+0x52>
		net_buf_unref(buf);
 100fd1c:	4628      	mov	r0, r5
 100fd1e:	f00e f95f 	bl	101dfe0 <net_buf_unref>
 100fd22:	e7d6      	b.n	100fcd2 <smp_error+0x52>
		return -ENOBUFS;
 100fd24:	f06f 0068 	mvn.w	r0, #104	; 0x68
 100fd28:	e7d4      	b.n	100fcd4 <smp_error+0x54>
 100fd2a:	bf00      	nop
 100fd2c:	0102ea1d 	.word	0x0102ea1d
 100fd30:	010299e4 	.word	0x010299e4

0100fd34 <bt_smp_recv>:
{
 100fd34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100fd38:	b086      	sub	sp, #24
	if (buf->len < sizeof(*hdr)) {
 100fd3a:	8a0b      	ldrh	r3, [r1, #16]
{
 100fd3c:	4680      	mov	r8, r0
 100fd3e:	460d      	mov	r5, r1
 100fd40:	af00      	add	r7, sp, #0
	if (buf->len < sizeof(*hdr)) {
 100fd42:	b97b      	cbnz	r3, 100fd64 <bt_smp_recv+0x30>
		LOG_ERR("Too small SMP PDU received");
 100fd44:	4b44      	ldr	r3, [pc, #272]	; (100fe58 <bt_smp_recv+0x124>)
 100fd46:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 100fd4a:	617b      	str	r3, [r7, #20]
 100fd4c:	2302      	movs	r3, #2
 100fd4e:	4843      	ldr	r0, [pc, #268]	; (100fe5c <bt_smp_recv+0x128>)
 100fd50:	613b      	str	r3, [r7, #16]
 100fd52:	f107 0210 	add.w	r2, r7, #16
 100fd56:	f018 fcf8 	bl	102874a <z_log_msg_static_create.constprop.0>
}
 100fd5a:	2000      	movs	r0, #0
 100fd5c:	3718      	adds	r7, #24
 100fd5e:	46bd      	mov	sp, r7
 100fd60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return net_buf_simple_pull_mem(&buf->b, len);
 100fd64:	2101      	movs	r1, #1
 100fd66:	f105 000c 	add.w	r0, r5, #12
 100fd6a:	f00e fa77 	bl	101e25c <net_buf_simple_pull_mem>
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
 100fd6e:	2104      	movs	r1, #4
 100fd70:	4606      	mov	r6, r0
 100fd72:	f1a8 00ec 	sub.w	r0, r8, #236	; 0xec
 100fd76:	f018 fc97 	bl	10286a8 <atomic_test_bit>
 100fd7a:	f1a8 04f0 	sub.w	r4, r8, #240	; 0xf0
 100fd7e:	7831      	ldrb	r1, [r6, #0]
 100fd80:	b178      	cbz	r0, 100fda2 <bt_smp_recv+0x6e>
		LOG_WRN("SMP command (code 0x%02x) received after timeout", hdr->code);
 100fd82:	466c      	mov	r4, sp
 100fd84:	b088      	sub	sp, #32
 100fd86:	466a      	mov	r2, sp
 100fd88:	4b35      	ldr	r3, [pc, #212]	; (100fe60 <bt_smp_recv+0x12c>)
		LOG_WRN("Received reserved SMP code 0x%02x", hdr->code);
 100fd8a:	e9c2 3105 	strd	r3, r1, [r2, #20]
 100fd8e:	2303      	movs	r3, #3
 100fd90:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100fd94:	4831      	ldr	r0, [pc, #196]	; (100fe5c <bt_smp_recv+0x128>)
 100fd96:	f842 3f10 	str.w	r3, [r2, #16]!
 100fd9a:	f018 fcd6 	bl	102874a <z_log_msg_static_create.constprop.0>
 100fd9e:	46a5      	mov	sp, r4
		return 0;
 100fda0:	e7db      	b.n	100fd5a <bt_smp_recv+0x26>
	if (hdr->code >= ARRAY_SIZE(handlers)) {
 100fda2:	290e      	cmp	r1, #14
 100fda4:	d904      	bls.n	100fdb0 <bt_smp_recv+0x7c>
		LOG_WRN("Received reserved SMP code 0x%02x", hdr->code);
 100fda6:	466c      	mov	r4, sp
 100fda8:	b088      	sub	sp, #32
 100fdaa:	466a      	mov	r2, sp
 100fdac:	4b2d      	ldr	r3, [pc, #180]	; (100fe64 <bt_smp_recv+0x130>)
 100fdae:	e7ec      	b.n	100fd8a <bt_smp_recv+0x56>
	if (!handlers[hdr->code].func) {
 100fdb0:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 100fe68 <bt_smp_recv+0x134>
 100fdb4:	f858 3031 	ldr.w	r3, [r8, r1, lsl #3]
 100fdb8:	b99b      	cbnz	r3, 100fde2 <bt_smp_recv+0xae>
		LOG_WRN("Unhandled SMP code 0x%02x", hdr->code);
 100fdba:	466d      	mov	r5, sp
 100fdbc:	b088      	sub	sp, #32
 100fdbe:	466a      	mov	r2, sp
 100fdc0:	4b2a      	ldr	r3, [pc, #168]	; (100fe6c <bt_smp_recv+0x138>)
 100fdc2:	4826      	ldr	r0, [pc, #152]	; (100fe5c <bt_smp_recv+0x128>)
 100fdc4:	e9c2 3105 	strd	r3, r1, [r2, #20]
 100fdc8:	2303      	movs	r3, #3
 100fdca:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100fdce:	f842 3f10 	str.w	r3, [r2, #16]!
 100fdd2:	f018 fcba 	bl	102874a <z_log_msg_static_create.constprop.0>
		smp_error(smp, BT_SMP_ERR_CMD_NOTSUPP);
 100fdd6:	2107      	movs	r1, #7
 100fdd8:	46ad      	mov	sp, r5
		smp_error(smp, err);
 100fdda:	4620      	mov	r0, r4
 100fddc:	f7ff ff50 	bl	100fc80 <smp_error>
 100fde0:	e7bb      	b.n	100fd5a <bt_smp_recv+0x26>
	if (!atomic_test_and_clear_bit(smp->allowed_cmds, hdr->code)) {
 100fde2:	4620      	mov	r0, r4
 100fde4:	f018 fd4b 	bl	102887e <atomic_test_and_clear_bit>
 100fde8:	7833      	ldrb	r3, [r6, #0]
 100fdea:	b998      	cbnz	r0, 100fe14 <bt_smp_recv+0xe0>
		LOG_WRN("Unexpected SMP code 0x%02x", hdr->code);
 100fdec:	466d      	mov	r5, sp
 100fdee:	b088      	sub	sp, #32
 100fdf0:	466a      	mov	r2, sp
 100fdf2:	491f      	ldr	r1, [pc, #124]	; (100fe70 <bt_smp_recv+0x13c>)
 100fdf4:	4819      	ldr	r0, [pc, #100]	; (100fe5c <bt_smp_recv+0x128>)
 100fdf6:	e9c2 1305 	strd	r1, r3, [r2, #20]
 100fdfa:	2303      	movs	r3, #3
 100fdfc:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 100fe00:	f842 3f10 	str.w	r3, [r2, #16]!
 100fe04:	f018 fca1 	bl	102874a <z_log_msg_static_create.constprop.0>
		if (hdr->code != BT_SMP_CMD_PAIRING_FAIL) {
 100fe08:	7833      	ldrb	r3, [r6, #0]
 100fe0a:	46ad      	mov	sp, r5
 100fe0c:	2b05      	cmp	r3, #5
 100fe0e:	d0a4      	beq.n	100fd5a <bt_smp_recv+0x26>
			smp_error(smp, BT_SMP_ERR_UNSPECIFIED);
 100fe10:	2108      	movs	r1, #8
 100fe12:	e7e2      	b.n	100fdda <bt_smp_recv+0xa6>
	if (buf->len != handlers[hdr->code].expect_len) {
 100fe14:	eb08 02c3 	add.w	r2, r8, r3, lsl #3
 100fe18:	8a29      	ldrh	r1, [r5, #16]
 100fe1a:	7912      	ldrb	r2, [r2, #4]
 100fe1c:	428a      	cmp	r2, r1
 100fe1e:	d011      	beq.n	100fe44 <bt_smp_recv+0x110>
		LOG_ERR("Invalid len %u for code 0x%02x", buf->len, hdr->code);
 100fe20:	466d      	mov	r5, sp
 100fe22:	b088      	sub	sp, #32
 100fe24:	466a      	mov	r2, sp
 100fe26:	61d3      	str	r3, [r2, #28]
 100fe28:	2304      	movs	r3, #4
 100fe2a:	4812      	ldr	r0, [pc, #72]	; (100fe74 <bt_smp_recv+0x140>)
 100fe2c:	e9c2 0105 	strd	r0, r1, [r2, #20]
 100fe30:	f44f 5101 	mov.w	r1, #8256	; 0x2040
 100fe34:	4809      	ldr	r0, [pc, #36]	; (100fe5c <bt_smp_recv+0x128>)
 100fe36:	f842 3f10 	str.w	r3, [r2, #16]!
 100fe3a:	f018 fc86 	bl	102874a <z_log_msg_static_create.constprop.0>
		smp_error(smp, BT_SMP_ERR_INVALID_PARAMS);
 100fe3e:	210a      	movs	r1, #10
 100fe40:	46ad      	mov	sp, r5
 100fe42:	e7ca      	b.n	100fdda <bt_smp_recv+0xa6>
	err = handlers[hdr->code].func(smp, buf);
 100fe44:	4629      	mov	r1, r5
 100fe46:	4620      	mov	r0, r4
 100fe48:	f858 3033 	ldr.w	r3, [r8, r3, lsl #3]
 100fe4c:	4798      	blx	r3
	if (err) {
 100fe4e:	4601      	mov	r1, r0
 100fe50:	2800      	cmp	r0, #0
 100fe52:	d082      	beq.n	100fd5a <bt_smp_recv+0x26>
 100fe54:	e7c1      	b.n	100fdda <bt_smp_recv+0xa6>
 100fe56:	bf00      	nop
 100fe58:	0102ea75 	.word	0x0102ea75
 100fe5c:	010299e4 	.word	0x010299e4
 100fe60:	0102ea90 	.word	0x0102ea90
 100fe64:	0102eac1 	.word	0x0102eac1
 100fe68:	0102a1c0 	.word	0x0102a1c0
 100fe6c:	0102eae3 	.word	0x0102eae3
 100fe70:	0102eafd 	.word	0x0102eafd
 100fe74:	0102e390 	.word	0x0102e390

0100fe78 <bt_smp_pkey_ready>:
{
 100fe78:	b538      	push	{r3, r4, r5, lr}
	sc_public_key = pkey;
 100fe7a:	4b0f      	ldr	r3, [pc, #60]	; (100feb8 <bt_smp_pkey_ready+0x40>)
 100fe7c:	6018      	str	r0, [r3, #0]
	if (!pkey) {
 100fe7e:	b918      	cbnz	r0, 100fe88 <bt_smp_pkey_ready+0x10>
}
 100fe80:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 100fe84:	f7fe bf3e 	b.w	100ed04 <bt_smp_pkey_ready.part.0>
	z_impl_k_sem_give(sem);
 100fe88:	480c      	ldr	r0, [pc, #48]	; (100febc <bt_smp_pkey_ready+0x44>)
 100fe8a:	f011 fc09 	bl	10216a0 <z_impl_k_sem_give>
	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
 100fe8e:	2500      	movs	r5, #0
 100fe90:	4c0b      	ldr	r4, [pc, #44]	; (100fec0 <bt_smp_pkey_ready+0x48>)
		if (!atomic_test_bit(smp->flags, SMP_FLAG_PKEY_SEND)) {
 100fe92:	2106      	movs	r1, #6
 100fe94:	1d20      	adds	r0, r4, #4
 100fe96:	f018 fc07 	bl	10286a8 <atomic_test_bit>
 100fe9a:	b138      	cbz	r0, 100feac <bt_smp_pkey_ready+0x34>
		err = smp_public_key_periph(smp);
 100fe9c:	4620      	mov	r0, r4
 100fe9e:	f7ff f8a1 	bl	100efe4 <smp_public_key_periph>
		if (err) {
 100fea2:	4601      	mov	r1, r0
 100fea4:	b110      	cbz	r0, 100feac <bt_smp_pkey_ready+0x34>
			smp_error(smp, err);
 100fea6:	4620      	mov	r0, r4
 100fea8:	f7ff feea 	bl	100fc80 <smp_error>
	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
 100feac:	3501      	adds	r5, #1
 100feae:	2d08      	cmp	r5, #8
 100feb0:	f504 7408 	add.w	r4, r4, #544	; 0x220
 100feb4:	d1ed      	bne.n	100fe92 <bt_smp_pkey_ready+0x1a>
}
 100feb6:	bd38      	pop	{r3, r4, r5, pc}
 100feb8:	2100498c 	.word	0x2100498c
 100febc:	21000cc8 	.word	0x21000cc8
 100fec0:	210024e8 	.word	0x210024e8

0100fec4 <smp_ident_addr_info>:
{
 100fec4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100fec8:	b086      	sub	sp, #24
	smp->remote_dist &= ~BT_SMP_DIST_ID_KEY;
 100feca:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
	struct bt_smp_ident_addr_info *req = (void *)buf->data;
 100fece:	f8d1 800c 	ldr.w	r8, [r1, #12]
	smp->remote_dist &= ~BT_SMP_DIST_ID_KEY;
 100fed2:	f023 0302 	bic.w	r3, r3, #2
 100fed6:	f880 30e9 	strb.w	r3, [r0, #233]	; 0xe9
	struct bt_conn *conn = smp->chan.chan.conn;
 100feda:	f8d0 50f0 	ldr.w	r5, [r0, #240]	; 0xf0
	if (addr->type == BT_ADDR_LE_PUBLIC) {
 100fede:	f898 3000 	ldrb.w	r3, [r8]
{
 100fee2:	4604      	mov	r4, r0
 100fee4:	af00      	add	r7, sp, #0
		LOG_ERR(" for %s", bt_addr_le_str(&conn->le.dst));
 100fee6:	f105 0990 	add.w	r9, r5, #144	; 0x90
 100feea:	b3ab      	cbz	r3, 100ff58 <smp_ident_addr_info+0x94>
	if (!bt_addr_le_is_identity(&req->addr)) {
 100feec:	f898 3006 	ldrb.w	r3, [r8, #6]
 100fef0:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 100fef4:	2bc0      	cmp	r3, #192	; 0xc0
 100fef6:	d02f      	beq.n	100ff58 <smp_ident_addr_info+0x94>
		LOG_ERR("Invalid identity %s", bt_addr_le_str(&req->addr));
 100fef8:	4640      	mov	r0, r8
 100fefa:	f7f6 fea7 	bl	1006c4c <bt_addr_le_str>
 100fefe:	466e      	mov	r6, sp
 100ff00:	b088      	sub	sp, #32
 100ff02:	466c      	mov	r4, sp
 100ff04:	f44f 7a00 	mov.w	sl, #512	; 0x200
 100ff08:	4625      	mov	r5, r4
 100ff0a:	4b66      	ldr	r3, [pc, #408]	; (10100a4 <smp_ident_addr_info+0x1e0>)
 100ff0c:	f8df 8198 	ldr.w	r8, [pc, #408]	; 10100a8 <smp_ident_addr_info+0x1e4>
 100ff10:	e9c4 3005 	strd	r3, r0, [r4, #20]
 100ff14:	f8a4 a01c 	strh.w	sl, [r4, #28]
 100ff18:	f845 8f10 	str.w	r8, [r5, #16]!
 100ff1c:	462a      	mov	r2, r5
 100ff1e:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 100ff22:	4862      	ldr	r0, [pc, #392]	; (10100ac <smp_ident_addr_info+0x1e8>)
 100ff24:	f018 fc11 	bl	102874a <z_log_msg_static_create.constprop.0>
		LOG_ERR(" for %s", bt_addr_le_str(&conn->le.dst));
 100ff28:	4648      	mov	r0, r9
 100ff2a:	46b5      	mov	sp, r6
 100ff2c:	f7f6 fe8e 	bl	1006c4c <bt_addr_le_str>
 100ff30:	46a5      	mov	sp, r4
 100ff32:	4b5f      	ldr	r3, [pc, #380]	; (10100b0 <smp_ident_addr_info+0x1ec>)
 100ff34:	462a      	mov	r2, r5
 100ff36:	e9c4 3005 	strd	r3, r0, [r4, #20]
 100ff3a:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 100ff3e:	485b      	ldr	r0, [pc, #364]	; (10100ac <smp_ident_addr_info+0x1e8>)
 100ff40:	f8a4 a01c 	strh.w	sl, [r4, #28]
 100ff44:	f8c4 8010 	str.w	r8, [r4, #16]
 100ff48:	f018 fbff 	bl	102874a <z_log_msg_static_create.constprop.0>
		return BT_SMP_ERR_INVALID_PARAMS;
 100ff4c:	200a      	movs	r0, #10
 100ff4e:	46b5      	mov	sp, r6
}
 100ff50:	3718      	adds	r7, #24
 100ff52:	46bd      	mov	sp, r7
 100ff54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	return memcmp(a, b, sizeof(*a));
 100ff58:	2207      	movs	r2, #7
 100ff5a:	4641      	mov	r1, r8
 100ff5c:	4648      	mov	r0, r9
 100ff5e:	f016 fcf9 	bl	1026954 <memcmp>
	if (!bt_addr_le_eq(&conn->le.dst, &req->addr)) {
 100ff62:	b168      	cbz	r0, 100ff80 <smp_ident_addr_info+0xbc>
		struct bt_keys *keys = bt_keys_find_addr(conn->id, &req->addr);
 100ff64:	4641      	mov	r1, r8
 100ff66:	7a28      	ldrb	r0, [r5, #8]
 100ff68:	f000 fc9a 	bl	10108a0 <bt_keys_find_addr>
		if (keys) {
 100ff6c:	4606      	mov	r6, r0
 100ff6e:	b138      	cbz	r0, 100ff80 <smp_ident_addr_info+0xbc>
			if (!update_keys_check(smp, keys)) {
 100ff70:	4601      	mov	r1, r0
 100ff72:	4620      	mov	r0, r4
 100ff74:	f018 fb9e 	bl	10286b4 <update_keys_check>
 100ff78:	b320      	cbz	r0, 100ffc4 <smp_ident_addr_info+0x100>
			bt_keys_clear(keys);
 100ff7a:	4630      	mov	r0, r6
 100ff7c:	f000 fcfe 	bl	101097c <bt_keys_clear>
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
 100ff80:	210d      	movs	r1, #13
 100ff82:	1d20      	adds	r0, r4, #4
 100ff84:	f018 fb90 	bl	10286a8 <atomic_test_bit>
 100ff88:	2800      	cmp	r0, #0
 100ff8a:	d07a      	beq.n	1010082 <smp_ident_addr_info+0x1be>
		keys = bt_keys_get_type(BT_KEYS_IRK, conn->id, &conn->le.dst);
 100ff8c:	464a      	mov	r2, r9
 100ff8e:	2002      	movs	r0, #2
 100ff90:	7a29      	ldrb	r1, [r5, #8]
 100ff92:	f000 fccf 	bl	1010934 <bt_keys_get_type>
		if (!keys) {
 100ff96:	4606      	mov	r6, r0
 100ff98:	b9b0      	cbnz	r0, 100ffc8 <smp_ident_addr_info+0x104>
			LOG_ERR("Unable to get keys for %s", bt_addr_le_str(&conn->le.dst));
 100ff9a:	4648      	mov	r0, r9
 100ff9c:	f7f6 fe56 	bl	1006c4c <bt_addr_le_str>
 100ffa0:	466c      	mov	r4, sp
 100ffa2:	b088      	sub	sp, #32
 100ffa4:	466a      	mov	r2, sp
 100ffa6:	4b43      	ldr	r3, [pc, #268]	; (10100b4 <smp_ident_addr_info+0x1f0>)
 100ffa8:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 100ffac:	e9c2 3005 	strd	r3, r0, [r2, #20]
 100ffb0:	f44f 7300 	mov.w	r3, #512	; 0x200
 100ffb4:	8393      	strh	r3, [r2, #28]
 100ffb6:	4b3c      	ldr	r3, [pc, #240]	; (10100a8 <smp_ident_addr_info+0x1e4>)
 100ffb8:	483c      	ldr	r0, [pc, #240]	; (10100ac <smp_ident_addr_info+0x1e8>)
 100ffba:	f842 3f10 	str.w	r3, [r2, #16]!
 100ffbe:	f018 fbc4 	bl	102874a <z_log_msg_static_create.constprop.0>
 100ffc2:	46a5      	mov	sp, r4
				return BT_SMP_ERR_UNSPECIFIED;
 100ffc4:	2008      	movs	r0, #8
 100ffc6:	e7c3      	b.n	100ff50 <smp_ident_addr_info+0x8c>
		if (conn->role == BT_HCI_ROLE_CENTRAL) {
 100ffc8:	78eb      	ldrb	r3, [r5, #3]
 100ffca:	bbab      	cbnz	r3, 1010038 <smp_ident_addr_info+0x174>
			dst = &conn->le.resp_addr;
 100ffcc:	f105 019e 	add.w	r1, r5, #158	; 0x9e
	if (addr->type != BT_ADDR_LE_RANDOM) {
 100ffd0:	780b      	ldrb	r3, [r1, #0]
 100ffd2:	2b01      	cmp	r3, #1
 100ffd4:	d120      	bne.n	1010018 <smp_ident_addr_info+0x154>
		if (bt_addr_le_is_rpa(dst)) {
 100ffd6:	798b      	ldrb	r3, [r1, #6]
 100ffd8:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 100ffdc:	2b40      	cmp	r3, #64	; 0x40
 100ffde:	d11b      	bne.n	1010018 <smp_ident_addr_info+0x154>
	memcpy(dst, src, sizeof(*dst));
 100ffe0:	2206      	movs	r2, #6
 100ffe2:	3101      	adds	r1, #1
 100ffe4:	f106 003a 	add.w	r0, r6, #58	; 0x3a
 100ffe8:	f016 fcc4 	bl	1026974 <memcpy>
	if (addr->type == BT_ADDR_LE_PUBLIC) {
 100ffec:	f895 3090 	ldrb.w	r3, [r5, #144]	; 0x90
 100fff0:	b193      	cbz	r3, 1010018 <smp_ident_addr_info+0x154>
			if (!bt_addr_le_is_identity(&conn->le.dst)) {
 100fff2:	f895 3096 	ldrb.w	r3, [r5, #150]	; 0x96
 100fff6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 100fffa:	2bc0      	cmp	r3, #192	; 0xc0
 100fffc:	d00c      	beq.n	1010018 <smp_ident_addr_info+0x154>
	memcpy(dst, src, sizeof(*dst));
 100fffe:	2207      	movs	r2, #7
 1010000:	4641      	mov	r1, r8
 1010002:	1c70      	adds	r0, r6, #1
 1010004:	f016 fcb6 	bl	1026974 <memcpy>
 1010008:	2207      	movs	r2, #7
 101000a:	4641      	mov	r1, r8
 101000c:	4648      	mov	r0, r9
 101000e:	f016 fcb1 	bl	1026974 <memcpy>
				bt_conn_identity_resolved(conn);
 1010012:	4628      	mov	r0, r5
 1010014:	f7fa fa9e 	bl	100a554 <bt_conn_identity_resolved>
	__ASSERT_NO_MSG(!(smp->remote_dist & BT_SMP_DIST_ID_KEY));
 1010018:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
 101001c:	079a      	lsls	r2, r3, #30
 101001e:	d50e      	bpl.n	101003e <smp_ident_addr_info+0x17a>
 1010020:	4925      	ldr	r1, [pc, #148]	; (10100b8 <smp_ident_addr_info+0x1f4>)
 1010022:	f640 6363 	movw	r3, #3683	; 0xe63
 1010026:	4a25      	ldr	r2, [pc, #148]	; (10100bc <smp_ident_addr_info+0x1f8>)
 1010028:	4825      	ldr	r0, [pc, #148]	; (10100c0 <smp_ident_addr_info+0x1fc>)
 101002a:	f014 fdd4 	bl	1024bd6 <assert_print>
 101002e:	f640 6163 	movw	r1, #3683	; 0xe63
	__ASSERT_NO_MSG(!bt_id_find_conflict(new_bond));
 1010032:	4822      	ldr	r0, [pc, #136]	; (10100bc <smp_ident_addr_info+0x1f8>)
 1010034:	f014 fdc8 	bl	1024bc8 <assert_post_action>
			dst = &conn->le.init_addr;
 1010038:	f105 0197 	add.w	r1, r5, #151	; 0x97
 101003c:	e7c8      	b.n	100ffd0 <smp_ident_addr_info+0x10c>
	conflict = bt_id_find_conflict(new_bond);
 101003e:	4630      	mov	r0, r6
 1010040:	f7f8 fe5e 	bl	1008d00 <bt_id_find_conflict>
	if (conflict && !IS_ENABLED(CONFIG_BT_ID_UNPAIR_MATCHING_BONDS)) {
 1010044:	b160      	cbz	r0, 1010060 <smp_ident_addr_info+0x19c>
		LOG_WRN("Refusing new pairing. The old bond must be unpaired first.");
 1010046:	4b1f      	ldr	r3, [pc, #124]	; (10100c4 <smp_ident_addr_info+0x200>)
 1010048:	4818      	ldr	r0, [pc, #96]	; (10100ac <smp_ident_addr_info+0x1e8>)
 101004a:	617b      	str	r3, [r7, #20]
 101004c:	2302      	movs	r3, #2
 101004e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 1010052:	613b      	str	r3, [r7, #16]
 1010054:	f107 0210 	add.w	r2, r7, #16
 1010058:	f018 fb77 	bl	102874a <z_log_msg_static_create.constprop.0>
		return BT_SMP_ERR_AUTH_REQUIREMENTS;
 101005c:	2003      	movs	r0, #3
 101005e:	e777      	b.n	100ff50 <smp_ident_addr_info+0x8c>
	__ASSERT_NO_MSG(!bt_id_find_conflict(new_bond));
 1010060:	4630      	mov	r0, r6
 1010062:	f7f8 fe4d 	bl	1008d00 <bt_id_find_conflict>
 1010066:	b148      	cbz	r0, 101007c <smp_ident_addr_info+0x1b8>
 1010068:	4917      	ldr	r1, [pc, #92]	; (10100c8 <smp_ident_addr_info+0x204>)
 101006a:	f640 637f 	movw	r3, #3711	; 0xe7f
 101006e:	4a13      	ldr	r2, [pc, #76]	; (10100bc <smp_ident_addr_info+0x1f8>)
 1010070:	4813      	ldr	r0, [pc, #76]	; (10100c0 <smp_ident_addr_info+0x1fc>)
 1010072:	f014 fdb0 	bl	1024bd6 <assert_print>
 1010076:	f640 617f 	movw	r1, #3711	; 0xe7f
 101007a:	e7da      	b.n	1010032 <smp_ident_addr_info+0x16e>
	bt_id_add(new_bond);
 101007c:	4630      	mov	r0, r6
 101007e:	f7f8 fe4f 	bl	1008d20 <bt_id_add>
	if (smp->remote_dist & BT_SMP_DIST_SIGN) {
 1010082:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
 1010086:	075b      	lsls	r3, r3, #29
 1010088:	d503      	bpl.n	1010092 <smp_ident_addr_info+0x1ce>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
 101008a:	210a      	movs	r1, #10
 101008c:	4620      	mov	r0, r4
 101008e:	f018 fb6a 	bl	1028766 <atomic_set_bit>
	if (!smp->local_dist && !smp->remote_dist) {
 1010092:	f8b4 10e8 	ldrh.w	r1, [r4, #232]	; 0xe8
 1010096:	b109      	cbz	r1, 101009c <smp_ident_addr_info+0x1d8>
	return 0;
 1010098:	2000      	movs	r0, #0
 101009a:	e759      	b.n	100ff50 <smp_ident_addr_info+0x8c>
		smp_pairing_complete(smp, 0);
 101009c:	4620      	mov	r0, r4
 101009e:	f7ff fd6b 	bl	100fb78 <smp_pairing_complete>
 10100a2:	e7f9      	b.n	1010098 <smp_ident_addr_info+0x1d4>
 10100a4:	0102eb18 	.word	0x0102eb18
 10100a8:	01000003 	.word	0x01000003
 10100ac:	010299e4 	.word	0x010299e4
 10100b0:	0102ebff 	.word	0x0102ebff
 10100b4:	0102e8f4 	.word	0x0102e8f4
 10100b8:	0102eb5b 	.word	0x0102eb5b
 10100bc:	0102eb2c 	.word	0x0102eb2c
 10100c0:	0102b695 	.word	0x0102b695
 10100c4:	0102eb76 	.word	0x0102eb76
 10100c8:	0102ebb1 	.word	0x0102ebb1

010100cc <smp_central_ident>:
{
 10100cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10100d0:	460b      	mov	r3, r1
 10100d2:	4604      	mov	r4, r0
	struct bt_conn *conn = smp->chan.chan.conn;
 10100d4:	f8d0 50f0 	ldr.w	r5, [r0, #240]	; 0xf0
{
 10100d8:	af00      	add	r7, sp, #0
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
 10100da:	210d      	movs	r1, #13
 10100dc:	3004      	adds	r0, #4
 10100de:	f018 fae3 	bl	10286a8 <atomic_test_bit>
 10100e2:	b368      	cbz	r0, 1010140 <smp_central_ident+0x74>
		keys = bt_keys_get_type(BT_KEYS_LTK, conn->id, &conn->le.dst);
 10100e4:	f105 0890 	add.w	r8, r5, #144	; 0x90
 10100e8:	7a29      	ldrb	r1, [r5, #8]
 10100ea:	4642      	mov	r2, r8
 10100ec:	2004      	movs	r0, #4
		struct bt_smp_central_ident *req = (void *)buf->data;
 10100ee:	68de      	ldr	r6, [r3, #12]
		keys = bt_keys_get_type(BT_KEYS_LTK, conn->id, &conn->le.dst);
 10100f0:	f000 fc20 	bl	1010934 <bt_keys_get_type>
		if (!keys) {
 10100f4:	4605      	mov	r5, r0
 10100f6:	b9c0      	cbnz	r0, 101012a <smp_central_ident+0x5e>
			LOG_ERR("Unable to get keys for %s", bt_addr_le_str(&conn->le.dst));
 10100f8:	4640      	mov	r0, r8
 10100fa:	f7f6 fda7 	bl	1006c4c <bt_addr_le_str>
 10100fe:	466c      	mov	r4, sp
 1010100:	b088      	sub	sp, #32
 1010102:	466a      	mov	r2, sp
 1010104:	4b1b      	ldr	r3, [pc, #108]	; (1010174 <smp_central_ident+0xa8>)
 1010106:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 101010a:	e9c2 3005 	strd	r3, r0, [r2, #20]
 101010e:	f44f 7300 	mov.w	r3, #512	; 0x200
 1010112:	8393      	strh	r3, [r2, #28]
 1010114:	4b18      	ldr	r3, [pc, #96]	; (1010178 <smp_central_ident+0xac>)
 1010116:	4819      	ldr	r0, [pc, #100]	; (101017c <smp_central_ident+0xb0>)
 1010118:	f842 3f10 	str.w	r3, [r2, #16]!
 101011c:	f018 fb15 	bl	102874a <z_log_msg_static_create.constprop.0>
			return BT_SMP_ERR_UNSPECIFIED;
 1010120:	2008      	movs	r0, #8
 1010122:	46a5      	mov	sp, r4
}
 1010124:	46bd      	mov	sp, r7
 1010126:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		memcpy(keys->ltk.ediv, req->ediv, sizeof(keys->ltk.ediv));
 101012a:	2202      	movs	r2, #2
 101012c:	4631      	mov	r1, r6
 101012e:	3018      	adds	r0, #24
 1010130:	f016 fc20 	bl	1026974 <memcpy>
		memcpy(keys->ltk.rand, req->rand, sizeof(req->rand));
 1010134:	2208      	movs	r2, #8
 1010136:	1cb1      	adds	r1, r6, #2
 1010138:	f105 0010 	add.w	r0, r5, #16
 101013c:	f016 fc1a 	bl	1026974 <memcpy>
	smp->remote_dist &= ~BT_SMP_DIST_ENC_KEY;
 1010140:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
 1010144:	f023 0201 	bic.w	r2, r3, #1
 1010148:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
	if (smp->remote_dist & BT_SMP_DIST_ID_KEY) {
 101014c:	079a      	lsls	r2, r3, #30
 101014e:	d508      	bpl.n	1010162 <smp_central_ident+0x96>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_IDENT_INFO);
 1010150:	2108      	movs	r1, #8
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
 1010152:	4620      	mov	r0, r4
 1010154:	f018 fb07 	bl	1028766 <atomic_set_bit>
	if (!smp->local_dist && !smp->remote_dist) {
 1010158:	f8b4 10e8 	ldrh.w	r1, [r4, #232]	; 0xe8
 101015c:	b129      	cbz	r1, 101016a <smp_central_ident+0x9e>
	return 0;
 101015e:	2000      	movs	r0, #0
 1010160:	e7e0      	b.n	1010124 <smp_central_ident+0x58>
	} else if (smp->remote_dist & BT_SMP_DIST_SIGN) {
 1010162:	075b      	lsls	r3, r3, #29
 1010164:	d5f8      	bpl.n	1010158 <smp_central_ident+0x8c>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
 1010166:	210a      	movs	r1, #10
 1010168:	e7f3      	b.n	1010152 <smp_central_ident+0x86>
		smp_pairing_complete(smp, 0);
 101016a:	4620      	mov	r0, r4
 101016c:	f7ff fd04 	bl	100fb78 <smp_pairing_complete>
 1010170:	e7f5      	b.n	101015e <smp_central_ident+0x92>
 1010172:	bf00      	nop
 1010174:	0102e8f4 	.word	0x0102e8f4
 1010178:	01000003 	.word	0x01000003
 101017c:	010299e4 	.word	0x010299e4

01010180 <smp_pairing_failed>:
{
 1010180:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1010184:	460e      	mov	r6, r1
 1010186:	af00      	add	r7, sp, #0
 1010188:	4604      	mov	r4, r0
	struct bt_conn *conn = smp->chan.chan.conn;
 101018a:	f8d0 80f0 	ldr.w	r8, [r0, #240]	; 0xf0
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 101018e:	f7fe fd5f 	bl	100ec50 <latch_auth_cb>
	struct bt_smp_pairing_fail *req = (void *)buf->data;
 1010192:	68f6      	ldr	r6, [r6, #12]
	LOG_ERR("pairing failed (peer reason 0x%x)", req->reason);
 1010194:	46e9      	mov	r9, sp
 1010196:	b088      	sub	sp, #32
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 1010198:	4605      	mov	r5, r0
	LOG_ERR("pairing failed (peer reason 0x%x)", req->reason);
 101019a:	466a      	mov	r2, sp
 101019c:	7833      	ldrb	r3, [r6, #0]
 101019e:	4914      	ldr	r1, [pc, #80]	; (10101f0 <smp_pairing_failed+0x70>)
 10101a0:	4814      	ldr	r0, [pc, #80]	; (10101f4 <smp_pairing_failed+0x74>)
 10101a2:	e9c2 1305 	strd	r1, r3, [r2, #20]
 10101a6:	2303      	movs	r3, #3
 10101a8:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 10101ac:	f842 3f10 	str.w	r3, [r2, #16]!
 10101b0:	f018 facb 	bl	102874a <z_log_msg_static_create.constprop.0>
 10101b4:	46cd      	mov	sp, r9
	if (atomic_test_and_clear_bit(smp->flags, SMP_FLAG_USER) ||
 10101b6:	f104 0904 	add.w	r9, r4, #4
 10101ba:	210a      	movs	r1, #10
 10101bc:	4648      	mov	r0, r9
 10101be:	f018 fb5e 	bl	102887e <atomic_test_and_clear_bit>
 10101c2:	b140      	cbz	r0, 10101d6 <smp_pairing_failed+0x56>
		if (smp_auth_cb && smp_auth_cb->cancel) {
 10101c4:	b975      	cbnz	r5, 10101e4 <smp_pairing_failed+0x64>
	smp_pairing_complete(smp, req->reason);
 10101c6:	4620      	mov	r0, r4
 10101c8:	7831      	ldrb	r1, [r6, #0]
 10101ca:	f7ff fcd5 	bl	100fb78 <smp_pairing_complete>
}
 10101ce:	2000      	movs	r0, #0
 10101d0:	46bd      	mov	sp, r7
 10101d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	    atomic_test_and_clear_bit(smp->flags, SMP_FLAG_DISPLAY)) {
 10101d6:	210b      	movs	r1, #11
 10101d8:	4648      	mov	r0, r9
 10101da:	f018 fb50 	bl	102887e <atomic_test_and_clear_bit>
	if (atomic_test_and_clear_bit(smp->flags, SMP_FLAG_USER) ||
 10101de:	2800      	cmp	r0, #0
 10101e0:	d1f0      	bne.n	10101c4 <smp_pairing_failed+0x44>
 10101e2:	e7f0      	b.n	10101c6 <smp_pairing_failed+0x46>
		if (smp_auth_cb && smp_auth_cb->cancel) {
 10101e4:	692b      	ldr	r3, [r5, #16]
 10101e6:	2b00      	cmp	r3, #0
 10101e8:	d0ed      	beq.n	10101c6 <smp_pairing_failed+0x46>
			smp_auth_cb->cancel(conn);
 10101ea:	4640      	mov	r0, r8
 10101ec:	4798      	blx	r3
 10101ee:	e7ea      	b.n	10101c6 <smp_pairing_failed+0x46>
 10101f0:	0102ebd0 	.word	0x0102ebd0
 10101f4:	010299e4 	.word	0x010299e4

010101f8 <bt_smp_encrypt_change>:
{
 10101f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10101fc:	b08f      	sub	sp, #60	; 0x3c
	struct bt_conn *conn = chan->conn;
 10101fe:	4605      	mov	r5, r0
	if (!atomic_test_and_clear_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
 1010200:	f1a0 06ec 	sub.w	r6, r0, #236	; 0xec
{
 1010204:	4604      	mov	r4, r0
 1010206:	4688      	mov	r8, r1
 1010208:	af00      	add	r7, sp, #0
	if (!atomic_test_and_clear_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
 101020a:	2101      	movs	r1, #1
 101020c:	4630      	mov	r0, r6
	struct bt_conn *conn = chan->conn;
 101020e:	f855 99f0 	ldr.w	r9, [r5], #-240
	if (!atomic_test_and_clear_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
 1010212:	f018 fb34 	bl	102887e <atomic_test_and_clear_bit>
 1010216:	b338      	cbz	r0, 1010268 <bt_smp_encrypt_change+0x70>
	if (hci_status) {
 1010218:	f1b8 0f00 	cmp.w	r8, #0
 101021c:	d019      	beq.n	1010252 <bt_smp_encrypt_change+0x5a>
		if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
 101021e:	2103      	movs	r1, #3
 1010220:	4630      	mov	r0, r6
 1010222:	f018 fa41 	bl	10286a8 <atomic_test_bit>
 1010226:	b1f8      	cbz	r0, 1010268 <bt_smp_encrypt_change+0x70>
			uint8_t smp_err = smp_err_get(
 1010228:	4640      	mov	r0, r8
 101022a:	f7f8 f90b 	bl	1008444 <bt_security_err_get>
	switch (auth_err) {
 101022e:	3801      	subs	r0, #1
 1010230:	b2c0      	uxtb	r0, r0
 1010232:	2808      	cmp	r0, #8
			uint8_t smp_err = smp_err_get(
 1010234:	bf8c      	ite	hi
 1010236:	2400      	movhi	r4, #0
 1010238:	4b74      	ldrls	r3, [pc, #464]	; (101040c <bt_smp_encrypt_change+0x214>)
			atomic_set_bit(smp->flags, SMP_FLAG_KEYS_DISTR);
 101023a:	f04f 0102 	mov.w	r1, #2
 101023e:	bf98      	it	ls
 1010240:	5c1c      	ldrbls	r4, [r3, r0]
 1010242:	4630      	mov	r0, r6
 1010244:	f018 fa8f 	bl	1028766 <atomic_set_bit>
			smp_pairing_complete(smp, smp_err);
 1010248:	4621      	mov	r1, r4
		smp_pairing_complete(smp, 0);
 101024a:	4628      	mov	r0, r5
 101024c:	f7ff fc94 	bl	100fb78 <smp_pairing_complete>
 1010250:	e00a      	b.n	1010268 <bt_smp_encrypt_change+0x70>
	if (!conn->encrypt) {
 1010252:	f899 300b 	ldrb.w	r3, [r9, #11]
 1010256:	b13b      	cbz	r3, 1010268 <bt_smp_encrypt_change+0x70>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
 1010258:	2103      	movs	r1, #3
 101025a:	4630      	mov	r0, r6
 101025c:	f018 fa24 	bl	10286a8 <atomic_test_bit>
 1010260:	b930      	cbnz	r0, 1010270 <bt_smp_encrypt_change+0x78>
		smp_reset(smp);
 1010262:	4628      	mov	r0, r5
 1010264:	f018 fb1d 	bl	10288a2 <smp_reset>
}
 1010268:	373c      	adds	r7, #60	; 0x3c
 101026a:	46bd      	mov	sp, r7
 101026c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 1010270:	2105      	movs	r1, #5
 1010272:	4630      	mov	r0, r6
 1010274:	f018 fa18 	bl	10286a8 <atomic_test_bit>
 1010278:	b1b8      	cbz	r0, 10102aa <bt_smp_encrypt_change+0xb2>
		if ((smp->local_dist & BT_SMP_DIST_LINK_KEY) &&
 101027a:	f814 3c08 	ldrb.w	r3, [r4, #-8]
 101027e:	071a      	lsls	r2, r3, #28
 1010280:	d507      	bpl.n	1010292 <bt_smp_encrypt_change+0x9a>
 1010282:	f814 3c07 	ldrb.w	r3, [r4, #-7]
 1010286:	071b      	lsls	r3, r3, #28
 1010288:	d503      	bpl.n	1010292 <bt_smp_encrypt_change+0x9a>
			atomic_set_bit(smp->flags, SMP_FLAG_DERIVE_LK);
 101028a:	2111      	movs	r1, #17
 101028c:	4630      	mov	r0, r6
 101028e:	f018 fa6a 	bl	1028766 <atomic_set_bit>
		smp->local_dist &= ~BT_SMP_DIST_LINK_KEY;
 1010292:	f814 3c08 	ldrb.w	r3, [r4, #-8]
 1010296:	f023 0308 	bic.w	r3, r3, #8
 101029a:	f804 3c08 	strb.w	r3, [r4, #-8]
		smp->remote_dist &= ~BT_SMP_DIST_LINK_KEY;
 101029e:	f814 3c07 	ldrb.w	r3, [r4, #-7]
 10102a2:	f023 0308 	bic.w	r3, r3, #8
 10102a6:	f804 3c07 	strb.w	r3, [r4, #-7]
	if (smp->remote_dist & BT_SMP_DIST_ENC_KEY) {
 10102aa:	f814 3c07 	ldrb.w	r3, [r4, #-7]
 10102ae:	07d8      	lsls	r0, r3, #31
 10102b0:	d522      	bpl.n	10102f8 <bt_smp_encrypt_change+0x100>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_ENCRYPT_INFO);
 10102b2:	2106      	movs	r1, #6
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
 10102b4:	4628      	mov	r0, r5
 10102b6:	f018 fa56 	bl	1028766 <atomic_set_bit>
	atomic_set_bit(smp->flags, SMP_FLAG_KEYS_DISTR);
 10102ba:	2102      	movs	r1, #2
 10102bc:	4630      	mov	r0, r6
 10102be:	f018 fa52 	bl	1028766 <atomic_set_bit>
	struct bt_conn *conn = smp->chan.chan.conn;
 10102c2:	6823      	ldr	r3, [r4, #0]
	if (!keys) {
 10102c4:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 10102c8:	b9f2      	cbnz	r2, 1010308 <bt_smp_encrypt_change+0x110>
		LOG_ERR("No keys space for %s", bt_addr_le_str(&conn->le.dst));
 10102ca:	f103 0090 	add.w	r0, r3, #144	; 0x90
 10102ce:	f7f6 fcbd 	bl	1006c4c <bt_addr_le_str>
 10102d2:	466c      	mov	r4, sp
 10102d4:	b088      	sub	sp, #32
 10102d6:	466a      	mov	r2, sp
 10102d8:	4b4d      	ldr	r3, [pc, #308]	; (1010410 <bt_smp_encrypt_change+0x218>)
 10102da:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 10102de:	e9c2 3005 	strd	r3, r0, [r2, #20]
 10102e2:	f44f 7300 	mov.w	r3, #512	; 0x200
 10102e6:	8393      	strh	r3, [r2, #28]
 10102e8:	4b4a      	ldr	r3, [pc, #296]	; (1010414 <bt_smp_encrypt_change+0x21c>)
 10102ea:	484b      	ldr	r0, [pc, #300]	; (1010418 <bt_smp_encrypt_change+0x220>)
 10102ec:	f842 3f10 	str.w	r3, [r2, #16]!
 10102f0:	f018 fa2b 	bl	102874a <z_log_msg_static_create.constprop.0>
 10102f4:	46a5      	mov	sp, r4
		return BT_SMP_ERR_UNSPECIFIED;
 10102f6:	e7b7      	b.n	1010268 <bt_smp_encrypt_change+0x70>
	} else if (smp->remote_dist & BT_SMP_DIST_ID_KEY) {
 10102f8:	0799      	lsls	r1, r3, #30
 10102fa:	d501      	bpl.n	1010300 <bt_smp_encrypt_change+0x108>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_IDENT_INFO);
 10102fc:	2108      	movs	r1, #8
 10102fe:	e7d9      	b.n	10102b4 <bt_smp_encrypt_change+0xbc>
	} else if (smp->remote_dist & BT_SMP_DIST_SIGN) {
 1010300:	075a      	lsls	r2, r3, #29
 1010302:	d5da      	bpl.n	10102ba <bt_smp_encrypt_change+0xc2>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
 1010304:	210a      	movs	r1, #10
 1010306:	e7d5      	b.n	10102b4 <bt_smp_encrypt_change+0xbc>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 1010308:	2105      	movs	r1, #5
 101030a:	f018 f9cd 	bl	10286a8 <atomic_test_bit>
 101030e:	b9c0      	cbnz	r0, 1010342 <bt_smp_encrypt_change+0x14a>
	if (smp->local_dist & BT_SMP_DIST_ENC_KEY) {
 1010310:	f814 3c08 	ldrb.w	r3, [r4, #-8]
 1010314:	07db      	lsls	r3, r3, #31
 1010316:	d514      	bpl.n	1010342 <bt_smp_encrypt_change+0x14a>
	struct bt_keys *keys = conn->le.keys;
 1010318:	6823      	ldr	r3, [r4, #0]
		if (bt_rand((void *)&rand, sizeof(rand))) {
 101031a:	211a      	movs	r1, #26
 101031c:	f107 001c 	add.w	r0, r7, #28
	struct bt_keys *keys = conn->le.keys;
 1010320:	f8d3 80c0 	ldr.w	r8, [r3, #192]	; 0xc0
		if (bt_rand((void *)&rand, sizeof(rand))) {
 1010324:	f003 fb04 	bl	1013930 <bt_rand>
 1010328:	4682      	mov	sl, r0
 101032a:	b178      	cbz	r0, 101034c <bt_smp_encrypt_change+0x154>
			LOG_ERR("Unable to get random bytes");
 101032c:	4b3b      	ldr	r3, [pc, #236]	; (101041c <bt_smp_encrypt_change+0x224>)
			LOG_ERR("Unable to allocate Encrypt Info buffer");
 101032e:	617b      	str	r3, [r7, #20]
 1010330:	2302      	movs	r3, #2
 1010332:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1010336:	4838      	ldr	r0, [pc, #224]	; (1010418 <bt_smp_encrypt_change+0x220>)
 1010338:	613b      	str	r3, [r7, #16]
 101033a:	f107 0210 	add.w	r2, r7, #16
 101033e:	f018 fa04 	bl	102874a <z_log_msg_static_create.constprop.0>
	if (!smp->local_dist && !smp->remote_dist) {
 1010342:	f834 1c08 	ldrh.w	r1, [r4, #-8]
 1010346:	2900      	cmp	r1, #0
 1010348:	d18e      	bne.n	1010268 <bt_smp_encrypt_change+0x70>
 101034a:	e77e      	b.n	101024a <bt_smp_encrypt_change+0x52>
		buf = smp_create_pdu(smp, BT_SMP_CMD_ENCRYPT_INFO,
 101034c:	2106      	movs	r1, #6
 101034e:	4628      	mov	r0, r5
 1010350:	f018 fa19 	bl	1028786 <smp_create_pdu.constprop.0>
		if (!buf) {
 1010354:	4681      	mov	r9, r0
 1010356:	b908      	cbnz	r0, 101035c <bt_smp_encrypt_change+0x164>
			LOG_ERR("Unable to allocate Encrypt Info buffer");
 1010358:	4b31      	ldr	r3, [pc, #196]	; (1010420 <bt_smp_encrypt_change+0x228>)
 101035a:	e7e8      	b.n	101032e <bt_smp_encrypt_change+0x136>
	return net_buf_simple_add(&buf->b, len);
 101035c:	2110      	movs	r1, #16
 101035e:	300c      	adds	r0, #12
 1010360:	f00d ff9a 	bl	101e298 <net_buf_simple_add>
		memcpy(info->ltk, rand.key, keys->enc_size);
 1010364:	f898 200c 	ldrb.w	r2, [r8, #12]
 1010368:	f107 011c 	add.w	r1, r7, #28
 101036c:	4683      	mov	fp, r0
 101036e:	f016 fb01 	bl	1026974 <memcpy>
		if (keys->enc_size < sizeof(info->ltk)) {
 1010372:	f898 000c 	ldrb.w	r0, [r8, #12]
 1010376:	280f      	cmp	r0, #15
 1010378:	d805      	bhi.n	1010386 <bt_smp_encrypt_change+0x18e>
			(void)memset(info->ltk + keys->enc_size, 0,
 101037a:	f1c0 0210 	rsb	r2, r0, #16
 101037e:	4651      	mov	r1, sl
 1010380:	4458      	add	r0, fp
 1010382:	f016 fb02 	bl	102698a <memset>
		smp_send(smp, buf, NULL, NULL);
 1010386:	4649      	mov	r1, r9
 1010388:	2200      	movs	r2, #0
 101038a:	4628      	mov	r0, r5
 101038c:	f018 f9c0 	bl	1028710 <smp_send.constprop.0>
		buf = smp_create_pdu(smp, BT_SMP_CMD_CENTRAL_IDENT,
 1010390:	2107      	movs	r1, #7
 1010392:	4628      	mov	r0, r5
 1010394:	f018 f9f7 	bl	1028786 <smp_create_pdu.constprop.0>
		if (!buf) {
 1010398:	4681      	mov	r9, r0
 101039a:	b908      	cbnz	r0, 10103a0 <bt_smp_encrypt_change+0x1a8>
			LOG_ERR("Unable to allocate Central Ident buffer");
 101039c:	4b21      	ldr	r3, [pc, #132]	; (1010424 <bt_smp_encrypt_change+0x22c>)
 101039e:	e7c6      	b.n	101032e <bt_smp_encrypt_change+0x136>
 10103a0:	210a      	movs	r1, #10
 10103a2:	300c      	adds	r0, #12
 10103a4:	f00d ff78 	bl	101e298 <net_buf_simple_add>
 10103a8:	4682      	mov	sl, r0
		memcpy(ident->rand, rand.rand, sizeof(ident->rand));
 10103aa:	2208      	movs	r2, #8
 10103ac:	f107 012c 	add.w	r1, r7, #44	; 0x2c
 10103b0:	3002      	adds	r0, #2
 10103b2:	f016 fadf 	bl	1026974 <memcpy>
		memcpy(ident->ediv, rand.ediv, sizeof(ident->ediv));
 10103b6:	2202      	movs	r2, #2
 10103b8:	f107 0134 	add.w	r1, r7, #52	; 0x34
 10103bc:	4650      	mov	r0, sl
 10103be:	f016 fad9 	bl	1026974 <memcpy>
		smp_send(smp, buf, smp_ident_sent, NULL);
 10103c2:	4649      	mov	r1, r9
 10103c4:	4628      	mov	r0, r5
 10103c6:	4a18      	ldr	r2, [pc, #96]	; (1010428 <bt_smp_encrypt_change+0x230>)
 10103c8:	f018 f9a2 	bl	1028710 <smp_send.constprop.0>
		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
 10103cc:	210d      	movs	r1, #13
 10103ce:	4630      	mov	r0, r6
 10103d0:	f018 f96a 	bl	10286a8 <atomic_test_bit>
 10103d4:	2800      	cmp	r0, #0
 10103d6:	d0b4      	beq.n	1010342 <bt_smp_encrypt_change+0x14a>
			bt_keys_add_type(keys, BT_KEYS_PERIPH_LTK);
 10103d8:	4640      	mov	r0, r8
 10103da:	2101      	movs	r1, #1
 10103dc:	f000 fa92 	bl	1010904 <bt_keys_add_type>
			memcpy(keys->periph_ltk.val, rand.key,
 10103e0:	f107 011c 	add.w	r1, r7, #28
 10103e4:	2210      	movs	r2, #16
 10103e6:	f108 004a 	add.w	r0, r8, #74	; 0x4a
 10103ea:	f016 fac3 	bl	1026974 <memcpy>
			memcpy(keys->periph_ltk.rand, rand.rand,
 10103ee:	f107 012c 	add.w	r1, r7, #44	; 0x2c
 10103f2:	2208      	movs	r2, #8
 10103f4:	f108 0040 	add.w	r0, r8, #64	; 0x40
 10103f8:	f016 fabc 	bl	1026974 <memcpy>
			memcpy(keys->periph_ltk.ediv, rand.ediv,
 10103fc:	2202      	movs	r2, #2
 10103fe:	f107 0134 	add.w	r1, r7, #52	; 0x34
 1010402:	f108 0048 	add.w	r0, r8, #72	; 0x48
 1010406:	f016 fab5 	bl	1026974 <memcpy>
 101040a:	e79a      	b.n	1010342 <bt_smp_encrypt_change+0x14a>
 101040c:	0102ec9c 	.word	0x0102ec9c
 1010410:	0102ebf2 	.word	0x0102ebf2
 1010414:	01000003 	.word	0x01000003
 1010418:	010299e4 	.word	0x010299e4
 101041c:	0102ec07 	.word	0x0102ec07
 1010420:	0102ec22 	.word	0x0102ec22
 1010424:	0102ec49 	.word	0x0102ec49
 1010428:	01010469 	.word	0x01010469

0101042c <smp_timeout>:
{
 101042c:	b510      	push	{r4, lr}
 101042e:	4604      	mov	r4, r0
 1010430:	b086      	sub	sp, #24
	LOG_ERR("SMP Timeout");
 1010432:	4b0b      	ldr	r3, [pc, #44]	; (1010460 <smp_timeout+0x34>)
 1010434:	aa04      	add	r2, sp, #16
 1010436:	9305      	str	r3, [sp, #20]
 1010438:	2302      	movs	r3, #2
 101043a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 101043e:	4809      	ldr	r0, [pc, #36]	; (1010464 <smp_timeout+0x38>)
 1010440:	9304      	str	r3, [sp, #16]
 1010442:	f018 f982 	bl	102874a <z_log_msg_static_create.constprop.0>
	smp_pairing_complete(smp, BT_SMP_ERR_UNSPECIFIED);
 1010446:	f5a4 70f4 	sub.w	r0, r4, #488	; 0x1e8
 101044a:	2108      	movs	r1, #8
 101044c:	f7ff fb94 	bl	100fb78 <smp_pairing_complete>
	atomic_set_bit(smp->flags, SMP_FLAG_TIMEOUT);
 1010450:	2104      	movs	r1, #4
 1010452:	f5a4 70f2 	sub.w	r0, r4, #484	; 0x1e4
}
 1010456:	b006      	add	sp, #24
 1010458:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	atomic_set_bit(smp->flags, SMP_FLAG_TIMEOUT);
 101045c:	f018 b983 	b.w	1028766 <atomic_set_bit>
 1010460:	0102ec71 	.word	0x0102ec71
 1010464:	010299e4 	.word	0x010299e4

01010468 <smp_ident_sent>:
{
 1010468:	b508      	push	{r3, lr}
	if (!err) {
 101046a:	bb1a      	cbnz	r2, 10104b4 <smp_ident_sent+0x4c>
	if (conn->type == BT_CONN_TYPE_LE) {
 101046c:	7883      	ldrb	r3, [r0, #2]
 101046e:	2b01      	cmp	r3, #1
 1010470:	d120      	bne.n	10104b4 <smp_ident_sent+0x4c>
		chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_SMP);
 1010472:	2106      	movs	r1, #6
 1010474:	f017 f97d 	bl	1027772 <bt_l2cap_le_lookup_tx_cid>
		__ASSERT(chan, "No SMP channel found");
 1010478:	b970      	cbnz	r0, 1010498 <smp_ident_sent+0x30>
 101047a:	490f      	ldr	r1, [pc, #60]	; (10104b8 <smp_ident_sent+0x50>)
 101047c:	f240 2365 	movw	r3, #613	; 0x265
 1010480:	4a0e      	ldr	r2, [pc, #56]	; (10104bc <smp_ident_sent+0x54>)
 1010482:	480f      	ldr	r0, [pc, #60]	; (10104c0 <smp_ident_sent+0x58>)
 1010484:	f014 fba7 	bl	1024bd6 <assert_print>
 1010488:	480e      	ldr	r0, [pc, #56]	; (10104c4 <smp_ident_sent+0x5c>)
 101048a:	f014 fba4 	bl	1024bd6 <assert_print>
 101048e:	f240 2165 	movw	r1, #613	; 0x265
 1010492:	480a      	ldr	r0, [pc, #40]	; (10104bc <smp_ident_sent+0x54>)
 1010494:	f014 fb98 	bl	1024bc8 <assert_post_action>
		smp->local_dist &= ~dist_complete;
 1010498:	f810 3c08 	ldrb.w	r3, [r0, #-8]
 101049c:	f023 0301 	bic.w	r3, r3, #1
 10104a0:	f800 3c08 	strb.w	r3, [r0, #-8]
		if (!smp->local_dist && !smp->remote_dist) {
 10104a4:	f830 1c08 	ldrh.w	r1, [r0, #-8]
 10104a8:	b921      	cbnz	r1, 10104b4 <smp_ident_sent+0x4c>
}
 10104aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			smp_pairing_complete(smp, 0);
 10104ae:	38f0      	subs	r0, #240	; 0xf0
 10104b0:	f7ff bb62 	b.w	100fb78 <smp_pairing_complete>
}
 10104b4:	bd08      	pop	{r3, pc}
 10104b6:	bf00      	nop
 10104b8:	0102e203 	.word	0x0102e203
 10104bc:	0102eb2c 	.word	0x0102eb2c
 10104c0:	0102b695 	.word	0x0102b695
 10104c4:	0102ec7d 	.word	0x0102ec7d

010104c8 <bt_smp_update_keys>:
{
 10104c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10104cc:	af00      	add	r7, sp, #0
 10104ce:	4604      	mov	r4, r0
	smp = smp_chan_get(conn);
 10104d0:	f018 f93e 	bl	1028750 <smp_chan_get>
	if (!smp) {
 10104d4:	4605      	mov	r5, r0
 10104d6:	b360      	cbz	r0, 1010532 <bt_smp_update_keys+0x6a>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
 10104d8:	1d06      	adds	r6, r0, #4
 10104da:	2103      	movs	r1, #3
 10104dc:	4630      	mov	r0, r6
 10104de:	f018 f8e3 	bl	10286a8 <atomic_test_bit>
 10104e2:	b330      	cbz	r0, 1010532 <bt_smp_update_keys+0x6a>
	if (conn->le.keys) {
 10104e4:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
 10104e8:	b108      	cbz	r0, 10104ee <bt_smp_update_keys+0x26>
		bt_keys_clear(conn->le.keys);
 10104ea:	f000 fa47 	bl	101097c <bt_keys_clear>
	conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
 10104ee:	f104 0890 	add.w	r8, r4, #144	; 0x90
 10104f2:	4641      	mov	r1, r8
 10104f4:	7a20      	ldrb	r0, [r4, #8]
 10104f6:	f000 f8f5 	bl	10106e4 <bt_keys_get_addr>
 10104fa:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
	if (!conn->le.keys) {
 10104fe:	b9d8      	cbnz	r0, 1010538 <bt_smp_update_keys+0x70>
		LOG_ERR("Unable to get keys for %s", bt_addr_le_str(&conn->le.dst));
 1010500:	4640      	mov	r0, r8
 1010502:	f7f6 fba3 	bl	1006c4c <bt_addr_le_str>
 1010506:	466c      	mov	r4, sp
 1010508:	b088      	sub	sp, #32
 101050a:	466a      	mov	r2, sp
 101050c:	4b3b      	ldr	r3, [pc, #236]	; (10105fc <bt_smp_update_keys+0x134>)
 101050e:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 1010512:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1010516:	f44f 7300 	mov.w	r3, #512	; 0x200
 101051a:	8393      	strh	r3, [r2, #28]
 101051c:	4b38      	ldr	r3, [pc, #224]	; (1010600 <bt_smp_update_keys+0x138>)
 101051e:	4839      	ldr	r0, [pc, #228]	; (1010604 <bt_smp_update_keys+0x13c>)
 1010520:	f842 3f10 	str.w	r3, [r2, #16]!
 1010524:	f018 f911 	bl	102874a <z_log_msg_static_create.constprop.0>
		smp_error(smp, BT_SMP_ERR_UNSPECIFIED);
 1010528:	2108      	movs	r1, #8
 101052a:	46a5      	mov	sp, r4
 101052c:	4628      	mov	r0, r5
 101052e:	f7ff fba7 	bl	100fc80 <smp_error>
}
 1010532:	46bd      	mov	sp, r7
 1010534:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY)) {
 1010538:	210e      	movs	r1, #14
 101053a:	4630      	mov	r0, r6
 101053c:	f018 f8b4 	bl	10286a8 <atomic_test_bit>
 1010540:	b128      	cbz	r0, 101054e <bt_smp_update_keys+0x86>
		conn->le.keys->flags |= BT_KEYS_DEBUG;
 1010542:	f8d4 20c0 	ldr.w	r2, [r4, #192]	; 0xc0
 1010546:	7b53      	ldrb	r3, [r2, #13]
 1010548:	f043 0302 	orr.w	r3, r3, #2
 101054c:	7353      	strb	r3, [r2, #13]
	switch (smp->method) {
 101054e:	7a2a      	ldrb	r2, [r5, #8]
		conn->le.keys->flags |= BT_KEYS_OOB;
 1010550:	f8d4 10c0 	ldr.w	r1, [r4, #192]	; 0xc0
	switch (smp->method) {
 1010554:	2a03      	cmp	r2, #3
		conn->le.keys->flags |= BT_KEYS_OOB;
 1010556:	7b4b      	ldrb	r3, [r1, #13]
	switch (smp->method) {
 1010558:	d83c      	bhi.n	10105d4 <bt_smp_update_keys+0x10c>
 101055a:	2a00      	cmp	r2, #0
 101055c:	d041      	beq.n	10105e2 <bt_smp_update_keys+0x11a>
		conn->le.keys->flags |= BT_KEYS_AUTHENTICATED;
 101055e:	f8d4 20c0 	ldr.w	r2, [r4, #192]	; 0xc0
 1010562:	7b53      	ldrb	r3, [r2, #13]
 1010564:	f043 0301 	orr.w	r3, r3, #1
		conn->le.keys->flags &= ~BT_KEYS_AUTHENTICATED;
 1010568:	7353      	strb	r3, [r2, #13]
	return MIN(req->max_key_size, rsp->max_key_size);
 101056a:	7b6b      	ldrb	r3, [r5, #13]
 101056c:	7d29      	ldrb	r1, [r5, #20]
	conn->le.keys->enc_size = get_encryption_key_size(smp);
 101056e:	f8d4 20c0 	ldr.w	r2, [r4, #192]	; 0xc0
	return MIN(req->max_key_size, rsp->max_key_size);
 1010572:	428b      	cmp	r3, r1
 1010574:	bf28      	it	cs
 1010576:	460b      	movcs	r3, r1
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 1010578:	4630      	mov	r0, r6
	conn->le.keys->enc_size = get_encryption_key_size(smp);
 101057a:	7313      	strb	r3, [r2, #12]
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 101057c:	2105      	movs	r1, #5
 101057e:	f018 f893 	bl	10286a8 <atomic_test_bit>
 1010582:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
		conn->le.keys->flags |= BT_KEYS_SC;
 1010586:	7b5a      	ldrb	r2, [r3, #13]
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 1010588:	b3a0      	cbz	r0, 10105f4 <bt_smp_update_keys+0x12c>
		conn->le.keys->flags |= BT_KEYS_SC;
 101058a:	f042 0210 	orr.w	r2, r2, #16
		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
 101058e:	210d      	movs	r1, #13
 1010590:	4630      	mov	r0, r6
		conn->le.keys->flags |= BT_KEYS_SC;
 1010592:	735a      	strb	r2, [r3, #13]
		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
 1010594:	f018 f888 	bl	10286a8 <atomic_test_bit>
 1010598:	2800      	cmp	r0, #0
 101059a:	d0ca      	beq.n	1010532 <bt_smp_update_keys+0x6a>
			bt_keys_add_type(conn->le.keys, BT_KEYS_LTK_P256);
 101059c:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
 10105a0:	2120      	movs	r1, #32
 10105a2:	f000 f9af 	bl	1010904 <bt_keys_add_type>
			memcpy(conn->le.keys->ltk.val, smp->tk,
 10105a6:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
 10105aa:	f105 0147 	add.w	r1, r5, #71	; 0x47
 10105ae:	2210      	movs	r2, #16
 10105b0:	301a      	adds	r0, #26
 10105b2:	f016 f9df 	bl	1026974 <memcpy>
			(void)memset(conn->le.keys->ltk.rand, 0,
 10105b6:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
 10105ba:	2208      	movs	r2, #8
 10105bc:	2100      	movs	r1, #0
 10105be:	3010      	adds	r0, #16
 10105c0:	f016 f9e3 	bl	102698a <memset>
			(void)memset(conn->le.keys->ltk.ediv, 0,
 10105c4:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
 10105c8:	2202      	movs	r2, #2
 10105ca:	2100      	movs	r1, #0
 10105cc:	3018      	adds	r0, #24
 10105ce:	f016 f9dc 	bl	102698a <memset>
 10105d2:	e7ae      	b.n	1010532 <bt_smp_update_keys+0x6a>
	switch (smp->method) {
 10105d4:	3a05      	subs	r2, #5
 10105d6:	2a01      	cmp	r2, #1
 10105d8:	d803      	bhi.n	10105e2 <bt_smp_update_keys+0x11a>
		conn->le.keys->flags |= BT_KEYS_OOB;
 10105da:	f043 0320 	orr.w	r3, r3, #32
 10105de:	734b      	strb	r3, [r1, #13]
 10105e0:	e7bd      	b.n	101055e <bt_smp_update_keys+0x96>
		conn->le.keys->flags &= ~BT_KEYS_OOB;
 10105e2:	f023 0320 	bic.w	r3, r3, #32
 10105e6:	734b      	strb	r3, [r1, #13]
		conn->le.keys->flags &= ~BT_KEYS_AUTHENTICATED;
 10105e8:	f8d4 20c0 	ldr.w	r2, [r4, #192]	; 0xc0
 10105ec:	7b53      	ldrb	r3, [r2, #13]
 10105ee:	f023 0301 	bic.w	r3, r3, #1
 10105f2:	e7b9      	b.n	1010568 <bt_smp_update_keys+0xa0>
		conn->le.keys->flags &= ~BT_KEYS_SC;
 10105f4:	f022 0210 	bic.w	r2, r2, #16
 10105f8:	735a      	strb	r2, [r3, #13]
 10105fa:	e79a      	b.n	1010532 <bt_smp_update_keys+0x6a>
 10105fc:	0102e8f4 	.word	0x0102e8f4
 1010600:	01000003 	.word	0x01000003
 1010604:	010299e4 	.word	0x010299e4

01010608 <bt_smp_init>:
BT_L2CAP_CHANNEL_DEFINE(smp_br_fixed_chan, BT_L2CAP_CID_BR_SMP,
			bt_smp_br_accept, NULL);
#endif /* CONFIG_BT_BREDR */

int bt_smp_init(void)
{
 1010608:	b508      	push	{r3, lr}
	return BT_CMD_TEST(bt_dev.supported_commands, 34, 1) &&
 101060a:	4b07      	ldr	r3, [pc, #28]	; (1010628 <bt_smp_init+0x20>)
	}

	LOG_DBG("LE SC %s", sc_supported ? "enabled" : "disabled");

	if (!IS_ENABLED(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY)) {
		bt_pub_key_gen(&pub_key_cb);
 101060c:	4807      	ldr	r0, [pc, #28]	; (101062c <bt_smp_init+0x24>)
	return BT_CMD_TEST(bt_dev.supported_commands, 34, 1) &&
 101060e:	f893 309a 	ldrb.w	r3, [r3, #154]	; 0x9a
 1010612:	f003 0306 	and.w	r3, r3, #6
 1010616:	1f9a      	subs	r2, r3, #6
 1010618:	4253      	negs	r3, r2
 101061a:	4153      	adcs	r3, r2
 101061c:	4a04      	ldr	r2, [pc, #16]	; (1010630 <bt_smp_init+0x28>)
 101061e:	7013      	strb	r3, [r2, #0]
		bt_pub_key_gen(&pub_key_cb);
 1010620:	f7f9 f8e4 	bl	10097ec <bt_pub_key_gen>
	}

	return smp_self_test();
}
 1010624:	2000      	movs	r0, #0
 1010626:	bd08      	pop	{r3, pc}
 1010628:	21000000 	.word	0x21000000
 101062c:	210004b8 	.word	0x210004b8
 1010630:	21008346 	.word	0x21008346

01010634 <id_add>:
#endif  /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
	return 0;
}

static void id_add(struct bt_keys *keys, void *user_data)
{
 1010634:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(keys != NULL);
 1010636:	b958      	cbnz	r0, 1010650 <id_add+0x1c>
 1010638:	4907      	ldr	r1, [pc, #28]	; (1010658 <id_add+0x24>)
 101063a:	4808      	ldr	r0, [pc, #32]	; (101065c <id_add+0x28>)
 101063c:	f44f 73e4 	mov.w	r3, #456	; 0x1c8
 1010640:	4a07      	ldr	r2, [pc, #28]	; (1010660 <id_add+0x2c>)
 1010642:	f014 fac8 	bl	1024bd6 <assert_print>
 1010646:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 101064a:	4805      	ldr	r0, [pc, #20]	; (1010660 <id_add+0x2c>)
 101064c:	f014 fabc 	bl	1024bc8 <assert_post_action>

	bt_id_add(keys);
}
 1010650:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	bt_id_add(keys);
 1010654:	f7f8 bb64 	b.w	1008d20 <bt_id_add>
 1010658:	0102ed1d 	.word	0x0102ed1d
 101065c:	0102b695 	.word	0x0102b695
 1010660:	0102eced 	.word	0x0102eced

01010664 <bt_keys_get_addr.part.0>:
struct bt_keys *bt_keys_get_addr(uint8_t id, const bt_addr_le_t *addr)
 1010664:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1010668:	4680      	mov	r8, r0
 101066a:	460f      	mov	r7, r1
	size_t first_free_slot = ARRAY_SIZE(key_pool);
 101066c:	2405      	movs	r4, #5
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
 101066e:	2600      	movs	r6, #0
 1010670:	4d19      	ldr	r5, [pc, #100]	; (10106d8 <bt_keys_get_addr.part.0+0x74>)
		if (keys->id == id && bt_addr_le_eq(&keys->addr, addr)) {
 1010672:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 1010676:	4543      	cmp	r3, r8
 1010678:	d01d      	beq.n	10106b6 <bt_keys_get_addr.part.0+0x52>
		if (first_free_slot == ARRAY_SIZE(key_pool) &&
 101067a:	2c05      	cmp	r4, #5
 101067c:	d107      	bne.n	101068e <bt_keys_get_addr.part.0+0x2a>
	return memcmp(a, b, sizeof(*a));
 101067e:	2207      	movs	r2, #7
 1010680:	4628      	mov	r0, r5
 1010682:	4916      	ldr	r1, [pc, #88]	; (10106dc <bt_keys_get_addr.part.0+0x78>)
 1010684:	f016 f966 	bl	1026954 <memcmp>
 1010688:	2800      	cmp	r0, #0
 101068a:	bf08      	it	eq
 101068c:	4634      	moveq	r4, r6
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
 101068e:	3601      	adds	r6, #1
 1010690:	2e05      	cmp	r6, #5
 1010692:	f105 055c 	add.w	r5, r5, #92	; 0x5c
 1010696:	d1ec      	bne.n	1010672 <bt_keys_get_addr.part.0+0xe>
	if (first_free_slot < ARRAY_SIZE(key_pool)) {
 1010698:	2c05      	cmp	r4, #5
 101069a:	d01a      	beq.n	10106d2 <bt_keys_get_addr.part.0+0x6e>
		keys = &key_pool[first_free_slot];
 101069c:	235c      	movs	r3, #92	; 0x5c
 101069e:	435c      	muls	r4, r3
 10106a0:	480f      	ldr	r0, [pc, #60]	; (10106e0 <bt_keys_get_addr.part.0+0x7c>)
	memcpy(dst, src, sizeof(*dst));
 10106a2:	2207      	movs	r2, #7
 10106a4:	1825      	adds	r5, r4, r0
		keys->id = id;
 10106a6:	f800 8004 	strb.w	r8, [r0, r4]
		bt_addr_le_copy(&keys->addr, addr);
 10106aa:	3401      	adds	r4, #1
 10106ac:	4639      	mov	r1, r7
 10106ae:	4420      	add	r0, r4
 10106b0:	f016 f960 	bl	1026974 <memcpy>
		return keys;
 10106b4:	e00a      	b.n	10106cc <bt_keys_get_addr.part.0+0x68>
	return memcmp(a, b, sizeof(*a));
 10106b6:	2207      	movs	r2, #7
 10106b8:	4639      	mov	r1, r7
 10106ba:	4628      	mov	r0, r5
 10106bc:	f016 f94a 	bl	1026954 <memcmp>
		if (keys->id == id && bt_addr_le_eq(&keys->addr, addr)) {
 10106c0:	2800      	cmp	r0, #0
 10106c2:	d1da      	bne.n	101067a <bt_keys_get_addr.part.0+0x16>
		keys = &key_pool[i];
 10106c4:	235c      	movs	r3, #92	; 0x5c
 10106c6:	4d06      	ldr	r5, [pc, #24]	; (10106e0 <bt_keys_get_addr.part.0+0x7c>)
 10106c8:	fb03 5506 	mla	r5, r3, r6, r5
}
 10106cc:	4628      	mov	r0, r5
 10106ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return NULL;
 10106d2:	2500      	movs	r5, #0
 10106d4:	e7fa      	b.n	10106cc <bt_keys_get_addr.part.0+0x68>
 10106d6:	bf00      	nop
 10106d8:	21004991 	.word	0x21004991
 10106dc:	0102cb79 	.word	0x0102cb79
 10106e0:	21004990 	.word	0x21004990

010106e4 <bt_keys_get_addr>:
{
 10106e4:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(addr != NULL);
 10106e6:	b949      	cbnz	r1, 10106fc <bt_keys_get_addr+0x18>
 10106e8:	4906      	ldr	r1, [pc, #24]	; (1010704 <bt_keys_get_addr+0x20>)
 10106ea:	4807      	ldr	r0, [pc, #28]	; (1010708 <bt_keys_get_addr+0x24>)
 10106ec:	2359      	movs	r3, #89	; 0x59
 10106ee:	4a07      	ldr	r2, [pc, #28]	; (101070c <bt_keys_get_addr+0x28>)
 10106f0:	f014 fa71 	bl	1024bd6 <assert_print>
 10106f4:	2159      	movs	r1, #89	; 0x59
 10106f6:	4805      	ldr	r0, [pc, #20]	; (101070c <bt_keys_get_addr+0x28>)
 10106f8:	f014 fa66 	bl	1024bc8 <assert_post_action>
}
 10106fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 1010700:	f7ff bfb0 	b.w	1010664 <bt_keys_get_addr.part.0>
 1010704:	0102ed31 	.word	0x0102ed31
 1010708:	0102b695 	.word	0x0102b695
 101070c:	0102eced 	.word	0x0102eced

01010710 <bt_keys_foreach_type>:
{
 1010710:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1010714:	4606      	mov	r6, r0
 1010716:	4617      	mov	r7, r2
	__ASSERT_NO_MSG(func != NULL);
 1010718:	460d      	mov	r5, r1
 101071a:	b949      	cbnz	r1, 1010730 <bt_keys_foreach_type+0x20>
 101071c:	490b      	ldr	r1, [pc, #44]	; (101074c <bt_keys_foreach_type+0x3c>)
 101071e:	480c      	ldr	r0, [pc, #48]	; (1010750 <bt_keys_foreach_type+0x40>)
 1010720:	23b3      	movs	r3, #179	; 0xb3
 1010722:	4a0c      	ldr	r2, [pc, #48]	; (1010754 <bt_keys_foreach_type+0x44>)
 1010724:	f014 fa57 	bl	1024bd6 <assert_print>
 1010728:	21b3      	movs	r1, #179	; 0xb3
 101072a:	480a      	ldr	r0, [pc, #40]	; (1010754 <bt_keys_foreach_type+0x44>)
 101072c:	f014 fa4c 	bl	1024bc8 <assert_post_action>
 1010730:	4c09      	ldr	r4, [pc, #36]	; (1010758 <bt_keys_foreach_type+0x48>)
 1010732:	f504 78e6 	add.w	r8, r4, #460	; 0x1cc
		if ((key_pool[i].keys & type)) {
 1010736:	89e3      	ldrh	r3, [r4, #14]
 1010738:	4233      	tst	r3, r6
 101073a:	d002      	beq.n	1010742 <bt_keys_foreach_type+0x32>
			func(&key_pool[i], data);
 101073c:	4639      	mov	r1, r7
 101073e:	4620      	mov	r0, r4
 1010740:	47a8      	blx	r5
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
 1010742:	345c      	adds	r4, #92	; 0x5c
 1010744:	4544      	cmp	r4, r8
 1010746:	d1f6      	bne.n	1010736 <bt_keys_foreach_type+0x26>
}
 1010748:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 101074c:	0102ed45 	.word	0x0102ed45
 1010750:	0102b695 	.word	0x0102b695
 1010754:	0102eced 	.word	0x0102eced
 1010758:	21004990 	.word	0x21004990

0101075c <keys_commit>:

static int keys_commit(void)
{
 101075c:	b508      	push	{r3, lr}
	 * the keys were already removed.
	 */
	if (IS_ENABLED(CONFIG_BT_CENTRAL) && IS_ENABLED(CONFIG_BT_PRIVACY)) {
		bt_keys_foreach_type(BT_KEYS_ALL, id_add, NULL);
	} else {
		bt_keys_foreach_type(BT_KEYS_IRK, id_add, NULL);
 101075e:	2200      	movs	r2, #0
 1010760:	2002      	movs	r0, #2
 1010762:	4902      	ldr	r1, [pc, #8]	; (101076c <keys_commit+0x10>)
 1010764:	f7ff ffd4 	bl	1010710 <bt_keys_foreach_type>
	}

	return 0;
}
 1010768:	2000      	movs	r0, #0
 101076a:	bd08      	pop	{r3, pc}
 101076c:	01010635 	.word	0x01010635

01010770 <bt_keys_find>:
{
 1010770:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1010774:	4607      	mov	r7, r0
 1010776:	4688      	mov	r8, r1
	__ASSERT_NO_MSG(addr != NULL);
 1010778:	4616      	mov	r6, r2
 101077a:	b94a      	cbnz	r2, 1010790 <bt_keys_find+0x20>
 101077c:	4912      	ldr	r1, [pc, #72]	; (10107c8 <bt_keys_find+0x58>)
 101077e:	4813      	ldr	r0, [pc, #76]	; (10107cc <bt_keys_find+0x5c>)
 1010780:	23c0      	movs	r3, #192	; 0xc0
 1010782:	4a13      	ldr	r2, [pc, #76]	; (10107d0 <bt_keys_find+0x60>)
 1010784:	f014 fa27 	bl	1024bd6 <assert_print>
 1010788:	21c0      	movs	r1, #192	; 0xc0
 101078a:	4811      	ldr	r0, [pc, #68]	; (10107d0 <bt_keys_find+0x60>)
 101078c:	f014 fa1c 	bl	1024bc8 <assert_post_action>
 1010790:	2400      	movs	r4, #0
 1010792:	4d10      	ldr	r5, [pc, #64]	; (10107d4 <bt_keys_find+0x64>)
		if ((key_pool[i].keys & type) && key_pool[i].id == id &&
 1010794:	f8b5 300d 	ldrh.w	r3, [r5, #13]
 1010798:	423b      	tst	r3, r7
 101079a:	d00d      	beq.n	10107b8 <bt_keys_find+0x48>
 101079c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 10107a0:	4543      	cmp	r3, r8
 10107a2:	d109      	bne.n	10107b8 <bt_keys_find+0x48>
 10107a4:	2207      	movs	r2, #7
 10107a6:	4631      	mov	r1, r6
 10107a8:	4628      	mov	r0, r5
 10107aa:	f016 f8d3 	bl	1026954 <memcmp>
 10107ae:	b918      	cbnz	r0, 10107b8 <bt_keys_find+0x48>
			return &key_pool[i];
 10107b0:	4809      	ldr	r0, [pc, #36]	; (10107d8 <bt_keys_find+0x68>)
 10107b2:	4420      	add	r0, r4
}
 10107b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
 10107b8:	345c      	adds	r4, #92	; 0x5c
 10107ba:	f5b4 7fe6 	cmp.w	r4, #460	; 0x1cc
 10107be:	f105 055c 	add.w	r5, r5, #92	; 0x5c
 10107c2:	d1e7      	bne.n	1010794 <bt_keys_find+0x24>
	return NULL;
 10107c4:	2000      	movs	r0, #0
 10107c6:	e7f5      	b.n	10107b4 <bt_keys_find+0x44>
 10107c8:	0102ed31 	.word	0x0102ed31
 10107cc:	0102b695 	.word	0x0102b695
 10107d0:	0102eced 	.word	0x0102eced
 10107d4:	21004991 	.word	0x21004991
 10107d8:	21004990 	.word	0x21004990

010107dc <bt_keys_find_irk>:
{
 10107dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10107e0:	4607      	mov	r7, r0
	__ASSERT_NO_MSG(addr != NULL);
 10107e2:	460d      	mov	r5, r1
 10107e4:	b949      	cbnz	r1, 10107fa <bt_keys_find_irk+0x1e>
 10107e6:	4928      	ldr	r1, [pc, #160]	; (1010888 <bt_keys_find_irk+0xac>)
 10107e8:	4828      	ldr	r0, [pc, #160]	; (101088c <bt_keys_find_irk+0xb0>)
 10107ea:	23e9      	movs	r3, #233	; 0xe9
 10107ec:	4a28      	ldr	r2, [pc, #160]	; (1010890 <bt_keys_find_irk+0xb4>)
 10107ee:	f014 f9f2 	bl	1024bd6 <assert_print>
 10107f2:	21e9      	movs	r1, #233	; 0xe9
 10107f4:	4826      	ldr	r0, [pc, #152]	; (1010890 <bt_keys_find_irk+0xb4>)
 10107f6:	f014 f9e7 	bl	1024bc8 <assert_post_action>
	if (addr->type != BT_ADDR_LE_RANDOM) {
 10107fa:	780b      	ldrb	r3, [r1, #0]
 10107fc:	2b01      	cmp	r3, #1
 10107fe:	d002      	beq.n	1010806 <bt_keys_find_irk+0x2a>
		return NULL;
 1010800:	2000      	movs	r0, #0
}
 1010802:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!bt_addr_le_is_rpa(addr)) {
 1010806:	798b      	ldrb	r3, [r1, #6]
 1010808:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 101080c:	2b40      	cmp	r3, #64	; 0x40
 101080e:	d1f7      	bne.n	1010800 <bt_keys_find_irk+0x24>
 1010810:	2400      	movs	r4, #0
 1010812:	4e20      	ldr	r6, [pc, #128]	; (1010894 <bt_keys_find_irk+0xb8>)
		    !bt_addr_cmp(&addr->a, &key_pool[i].irk.rpa)) {
 1010814:	f101 0801 	add.w	r8, r1, #1
		if (!(key_pool[i].keys & BT_KEYS_IRK)) {
 1010818:	f836 3c2c 	ldrh.w	r3, [r6, #-44]
 101081c:	079a      	lsls	r2, r3, #30
 101081e:	d50c      	bpl.n	101083a <bt_keys_find_irk+0x5e>
		if (key_pool[i].id == id &&
 1010820:	f816 3c3a 	ldrb.w	r3, [r6, #-58]
 1010824:	42bb      	cmp	r3, r7
 1010826:	d108      	bne.n	101083a <bt_keys_find_irk+0x5e>
	return memcmp(a, b, sizeof(*a));
 1010828:	2206      	movs	r2, #6
 101082a:	4631      	mov	r1, r6
 101082c:	4640      	mov	r0, r8
 101082e:	f016 f891 	bl	1026954 <memcmp>
 1010832:	b910      	cbnz	r0, 101083a <bt_keys_find_irk+0x5e>
			return &key_pool[i];
 1010834:	4818      	ldr	r0, [pc, #96]	; (1010898 <bt_keys_find_irk+0xbc>)
 1010836:	4420      	add	r0, r4
 1010838:	e7e3      	b.n	1010802 <bt_keys_find_irk+0x26>
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
 101083a:	345c      	adds	r4, #92	; 0x5c
 101083c:	f5b4 7fe6 	cmp.w	r4, #460	; 0x1cc
 1010840:	f106 065c 	add.w	r6, r6, #92	; 0x5c
 1010844:	d1e8      	bne.n	1010818 <bt_keys_find_irk+0x3c>
 1010846:	2400      	movs	r4, #0
 1010848:	4e14      	ldr	r6, [pc, #80]	; (101089c <bt_keys_find_irk+0xc0>)
		if (bt_rpa_irk_matches(key_pool[i].irk.val, &addr->a)) {
 101084a:	3501      	adds	r5, #1
		if (!(key_pool[i].keys & BT_KEYS_IRK)) {
 101084c:	f836 3c1c 	ldrh.w	r3, [r6, #-28]
 1010850:	079b      	lsls	r3, r3, #30
 1010852:	d512      	bpl.n	101087a <bt_keys_find_irk+0x9e>
		if (key_pool[i].id != id) {
 1010854:	f816 3c2a 	ldrb.w	r3, [r6, #-42]
 1010858:	42bb      	cmp	r3, r7
 101085a:	d10e      	bne.n	101087a <bt_keys_find_irk+0x9e>
		if (bt_rpa_irk_matches(key_pool[i].irk.val, &addr->a)) {
 101085c:	4629      	mov	r1, r5
 101085e:	4630      	mov	r0, r6
 1010860:	f016 f8ac 	bl	10269bc <bt_rpa_irk_matches>
 1010864:	b148      	cbz	r0, 101087a <bt_keys_find_irk+0x9e>
			bt_addr_copy(&key_pool[i].irk.rpa, &addr->a);
 1010866:	4e0c      	ldr	r6, [pc, #48]	; (1010898 <bt_keys_find_irk+0xbc>)
 1010868:	f104 003a 	add.w	r0, r4, #58	; 0x3a
	memcpy(dst, src, sizeof(*dst));
 101086c:	2206      	movs	r2, #6
 101086e:	4629      	mov	r1, r5
 1010870:	4430      	add	r0, r6
 1010872:	f016 f87f 	bl	1026974 <memcpy>
			return &key_pool[i];
 1010876:	19a0      	adds	r0, r4, r6
 1010878:	e7c3      	b.n	1010802 <bt_keys_find_irk+0x26>
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
 101087a:	345c      	adds	r4, #92	; 0x5c
 101087c:	f5b4 7fe6 	cmp.w	r4, #460	; 0x1cc
 1010880:	f106 065c 	add.w	r6, r6, #92	; 0x5c
 1010884:	d1e2      	bne.n	101084c <bt_keys_find_irk+0x70>
 1010886:	e7bb      	b.n	1010800 <bt_keys_find_irk+0x24>
 1010888:	0102ed31 	.word	0x0102ed31
 101088c:	0102b695 	.word	0x0102b695
 1010890:	0102eced 	.word	0x0102eced
 1010894:	210049ca 	.word	0x210049ca
 1010898:	21004990 	.word	0x21004990
 101089c:	210049ba 	.word	0x210049ba

010108a0 <bt_keys_find_addr>:
{
 10108a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10108a2:	4607      	mov	r7, r0
	__ASSERT_NO_MSG(addr != NULL);
 10108a4:	460e      	mov	r6, r1
 10108a6:	b959      	cbnz	r1, 10108c0 <bt_keys_find_addr+0x20>
 10108a8:	4911      	ldr	r1, [pc, #68]	; (10108f0 <bt_keys_find_addr+0x50>)
 10108aa:	4812      	ldr	r0, [pc, #72]	; (10108f4 <bt_keys_find_addr+0x54>)
 10108ac:	f44f 738d 	mov.w	r3, #282	; 0x11a
 10108b0:	4a11      	ldr	r2, [pc, #68]	; (10108f8 <bt_keys_find_addr+0x58>)
 10108b2:	f014 f990 	bl	1024bd6 <assert_print>
 10108b6:	f44f 718d 	mov.w	r1, #282	; 0x11a
 10108ba:	480f      	ldr	r0, [pc, #60]	; (10108f8 <bt_keys_find_addr+0x58>)
 10108bc:	f014 f984 	bl	1024bc8 <assert_post_action>
 10108c0:	2400      	movs	r4, #0
 10108c2:	4d0e      	ldr	r5, [pc, #56]	; (10108fc <bt_keys_find_addr+0x5c>)
		if (key_pool[i].id == id &&
 10108c4:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 10108c8:	42bb      	cmp	r3, r7
 10108ca:	d108      	bne.n	10108de <bt_keys_find_addr+0x3e>
	return memcmp(a, b, sizeof(*a));
 10108cc:	2207      	movs	r2, #7
 10108ce:	4631      	mov	r1, r6
 10108d0:	4628      	mov	r0, r5
 10108d2:	f016 f83f 	bl	1026954 <memcmp>
 10108d6:	b910      	cbnz	r0, 10108de <bt_keys_find_addr+0x3e>
			return &key_pool[i];
 10108d8:	4809      	ldr	r0, [pc, #36]	; (1010900 <bt_keys_find_addr+0x60>)
 10108da:	4420      	add	r0, r4
}
 10108dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
 10108de:	345c      	adds	r4, #92	; 0x5c
 10108e0:	f5b4 7fe6 	cmp.w	r4, #460	; 0x1cc
 10108e4:	f105 055c 	add.w	r5, r5, #92	; 0x5c
 10108e8:	d1ec      	bne.n	10108c4 <bt_keys_find_addr+0x24>
	return NULL;
 10108ea:	2000      	movs	r0, #0
 10108ec:	e7f6      	b.n	10108dc <bt_keys_find_addr+0x3c>
 10108ee:	bf00      	nop
 10108f0:	0102ed31 	.word	0x0102ed31
 10108f4:	0102b695 	.word	0x0102b695
 10108f8:	0102eced 	.word	0x0102eced
 10108fc:	21004991 	.word	0x21004991
 1010900:	21004990 	.word	0x21004990

01010904 <bt_keys_add_type>:
{
 1010904:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(keys != NULL);
 1010906:	b958      	cbnz	r0, 1010920 <bt_keys_add_type+0x1c>
 1010908:	4907      	ldr	r1, [pc, #28]	; (1010928 <bt_keys_add_type+0x24>)
 101090a:	4808      	ldr	r0, [pc, #32]	; (101092c <bt_keys_add_type+0x28>)
 101090c:	f44f 7395 	mov.w	r3, #298	; 0x12a
 1010910:	4a07      	ldr	r2, [pc, #28]	; (1010930 <bt_keys_add_type+0x2c>)
 1010912:	f014 f960 	bl	1024bd6 <assert_print>
 1010916:	f44f 7195 	mov.w	r1, #298	; 0x12a
 101091a:	4805      	ldr	r0, [pc, #20]	; (1010930 <bt_keys_add_type+0x2c>)
 101091c:	f014 f954 	bl	1024bc8 <assert_post_action>
	keys->keys |= type;
 1010920:	89c3      	ldrh	r3, [r0, #14]
 1010922:	4319      	orrs	r1, r3
 1010924:	81c1      	strh	r1, [r0, #14]
}
 1010926:	bd08      	pop	{r3, pc}
 1010928:	0102ed1d 	.word	0x0102ed1d
 101092c:	0102b695 	.word	0x0102b695
 1010930:	0102eced 	.word	0x0102eced

01010934 <bt_keys_get_type>:
{
 1010934:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1010936:	4606      	mov	r6, r0
 1010938:	460f      	mov	r7, r1
	__ASSERT_NO_MSG(addr != NULL);
 101093a:	4615      	mov	r5, r2
 101093c:	b94a      	cbnz	r2, 1010952 <bt_keys_get_type+0x1e>
 101093e:	490c      	ldr	r1, [pc, #48]	; (1010970 <bt_keys_get_type+0x3c>)
 1010940:	480c      	ldr	r0, [pc, #48]	; (1010974 <bt_keys_get_type+0x40>)
 1010942:	23d2      	movs	r3, #210	; 0xd2
 1010944:	4a0c      	ldr	r2, [pc, #48]	; (1010978 <bt_keys_get_type+0x44>)
 1010946:	f014 f946 	bl	1024bd6 <assert_print>
 101094a:	21d2      	movs	r1, #210	; 0xd2
 101094c:	480a      	ldr	r0, [pc, #40]	; (1010978 <bt_keys_get_type+0x44>)
 101094e:	f014 f93b 	bl	1024bc8 <assert_post_action>
	keys = bt_keys_find(type, id, addr);
 1010952:	f7ff ff0d 	bl	1010770 <bt_keys_find>
	if (keys) {
 1010956:	4604      	mov	r4, r0
 1010958:	b940      	cbnz	r0, 101096c <bt_keys_get_type+0x38>
	keys = bt_keys_get_addr(id, addr);
 101095a:	4629      	mov	r1, r5
 101095c:	4638      	mov	r0, r7
 101095e:	f7ff fec1 	bl	10106e4 <bt_keys_get_addr>
	if (!keys) {
 1010962:	4604      	mov	r4, r0
 1010964:	b110      	cbz	r0, 101096c <bt_keys_get_type+0x38>
	bt_keys_add_type(keys, type);
 1010966:	4631      	mov	r1, r6
 1010968:	f7ff ffcc 	bl	1010904 <bt_keys_add_type>
}
 101096c:	4620      	mov	r0, r4
 101096e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1010970:	0102ed31 	.word	0x0102ed31
 1010974:	0102b695 	.word	0x0102b695
 1010978:	0102eced 	.word	0x0102eced

0101097c <bt_keys_clear>:
{
 101097c:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(keys != NULL);
 101097e:	4604      	mov	r4, r0
{
 1010980:	b08c      	sub	sp, #48	; 0x30
	__ASSERT_NO_MSG(keys != NULL);
 1010982:	b958      	cbnz	r0, 101099c <bt_keys_clear+0x20>
 1010984:	4916      	ldr	r1, [pc, #88]	; (10109e0 <bt_keys_clear+0x64>)
 1010986:	4817      	ldr	r0, [pc, #92]	; (10109e4 <bt_keys_clear+0x68>)
 1010988:	f240 1331 	movw	r3, #305	; 0x131
 101098c:	4a16      	ldr	r2, [pc, #88]	; (10109e8 <bt_keys_clear+0x6c>)
 101098e:	f014 f922 	bl	1024bd6 <assert_print>
 1010992:	f240 1131 	movw	r1, #305	; 0x131
 1010996:	4814      	ldr	r0, [pc, #80]	; (10109e8 <bt_keys_clear+0x6c>)
 1010998:	f014 f916 	bl	1024bc8 <assert_post_action>
	if (keys->state & BT_KEYS_ID_ADDED) {
 101099c:	7a03      	ldrb	r3, [r0, #8]
 101099e:	075b      	lsls	r3, r3, #29
 10109a0:	d501      	bpl.n	10109a6 <bt_keys_clear+0x2a>
		bt_id_del(keys);
 10109a2:	f7f8 f9d7 	bl	1008d54 <bt_id_del>
		if (keys->id) {
 10109a6:	4625      	mov	r5, r4
 10109a8:	f815 2b01 	ldrb.w	r2, [r5], #1
 10109ac:	b1b2      	cbz	r2, 10109dc <bt_keys_clear+0x60>
			u8_to_dec(id, sizeof(id), keys->id);
 10109ae:	ae02      	add	r6, sp, #8
 10109b0:	2104      	movs	r1, #4
 10109b2:	4630      	mov	r0, r6
 10109b4:	f013 fe77 	bl	10246a6 <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "keys",
 10109b8:	9600      	str	r6, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "keys",
 10109ba:	462b      	mov	r3, r5
 10109bc:	2124      	movs	r1, #36	; 0x24
 10109be:	4a0b      	ldr	r2, [pc, #44]	; (10109ec <bt_keys_clear+0x70>)
 10109c0:	a803      	add	r0, sp, #12
 10109c2:	f7f6 fbdd 	bl	1007180 <bt_settings_encode_key>
		settings_delete(key);
 10109c6:	a803      	add	r0, sp, #12
 10109c8:	f014 fcd4 	bl	1025374 <settings_delete>
	(void)memset(keys, 0, sizeof(*keys));
 10109cc:	225c      	movs	r2, #92	; 0x5c
 10109ce:	2100      	movs	r1, #0
 10109d0:	4620      	mov	r0, r4
}
 10109d2:	b00c      	add	sp, #48	; 0x30
 10109d4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	(void)memset(keys, 0, sizeof(*keys));
 10109d8:	f015 bfd7 	b.w	102698a <memset>
			bt_settings_encode_key(key, sizeof(key), "keys",
 10109dc:	9200      	str	r2, [sp, #0]
 10109de:	e7ec      	b.n	10109ba <bt_keys_clear+0x3e>
 10109e0:	0102ed1d 	.word	0x0102ed1d
 10109e4:	0102b695 	.word	0x0102b695
 10109e8:	0102eced 	.word	0x0102eced
 10109ec:	0102edf8 	.word	0x0102edf8

010109f0 <keys_set>:
{
 10109f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 10109f2:	b099      	sub	sp, #100	; 0x64
 10109f4:	4614      	mov	r4, r2
	if (!name) {
 10109f6:	4606      	mov	r6, r0
{
 10109f8:	af00      	add	r7, sp, #0
	if (!name) {
 10109fa:	b988      	cbnz	r0, 1010a20 <keys_set+0x30>
		LOG_ERR("Insufficient number of arguments");
 10109fc:	4b60      	ldr	r3, [pc, #384]	; (1010b80 <keys_set+0x190>)
 10109fe:	627b      	str	r3, [r7, #36]	; 0x24
 1010a00:	2302      	movs	r3, #2
 1010a02:	623b      	str	r3, [r7, #32]
 1010a04:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1010a08:	4603      	mov	r3, r0
 1010a0a:	f107 0220 	add.w	r2, r7, #32
 1010a0e:	485d      	ldr	r0, [pc, #372]	; (1010b84 <keys_set+0x194>)
 1010a10:	f7f3 fe7a 	bl	1004708 <z_impl_z_log_msg_static_create>
		return -EINVAL;
 1010a14:	f06f 0515 	mvn.w	r5, #21
}
 1010a18:	4628      	mov	r0, r5
 1010a1a:	3764      	adds	r7, #100	; 0x64
 1010a1c:	46bd      	mov	sp, r7
 1010a1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	len = read_cb(cb_arg, val, sizeof(val));
 1010a20:	2250      	movs	r2, #80	; 0x50
 1010a22:	4618      	mov	r0, r3
 1010a24:	f107 0110 	add.w	r1, r7, #16
 1010a28:	47a0      	blx	r4
	if (len < 0) {
 1010a2a:	1e04      	subs	r4, r0, #0
 1010a2c:	da10      	bge.n	1010a50 <keys_set+0x60>
		LOG_ERR("Failed to read value (err %zd)", len);
 1010a2e:	466d      	mov	r5, sp
 1010a30:	b088      	sub	sp, #32
 1010a32:	466a      	mov	r2, sp
 1010a34:	4b54      	ldr	r3, [pc, #336]	; (1010b88 <keys_set+0x198>)
 1010a36:	e9c2 3405 	strd	r3, r4, [r2, #20]
 1010a3a:	2303      	movs	r3, #3
 1010a3c:	f842 3f10 	str.w	r3, [r2, #16]!
 1010a40:	2300      	movs	r3, #0
 1010a42:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1010a46:	484f      	ldr	r0, [pc, #316]	; (1010b84 <keys_set+0x194>)
 1010a48:	f7f3 fe5e 	bl	1004708 <z_impl_z_log_msg_static_create>
 1010a4c:	46ad      	mov	sp, r5
		return -EINVAL;
 1010a4e:	e7e1      	b.n	1010a14 <keys_set+0x24>
	err = bt_settings_decode_key(name, &addr);
 1010a50:	4630      	mov	r0, r6
 1010a52:	f107 0108 	add.w	r1, r7, #8
 1010a56:	f016 f80f 	bl	1026a78 <bt_settings_decode_key>
	if (err) {
 1010a5a:	4605      	mov	r5, r0
 1010a5c:	b198      	cbz	r0, 1010a86 <keys_set+0x96>
		LOG_ERR("Unable to decode address %s", name);
 1010a5e:	466c      	mov	r4, sp
 1010a60:	b088      	sub	sp, #32
 1010a62:	466a      	mov	r2, sp
 1010a64:	4b49      	ldr	r3, [pc, #292]	; (1010b8c <keys_set+0x19c>)
 1010a66:	e9c2 3605 	strd	r3, r6, [r2, #20]
 1010a6a:	f44f 7300 	mov.w	r3, #512	; 0x200
 1010a6e:	8393      	strh	r3, [r2, #28]
 1010a70:	4b47      	ldr	r3, [pc, #284]	; (1010b90 <keys_set+0x1a0>)
 1010a72:	f842 3f10 	str.w	r3, [r2, #16]!
 1010a76:	2300      	movs	r3, #0
 1010a78:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 1010a7c:	4841      	ldr	r0, [pc, #260]	; (1010b84 <keys_set+0x194>)
 1010a7e:	f7f3 fe43 	bl	1004708 <z_impl_z_log_msg_static_create>
 1010a82:	46a5      	mov	sp, r4
			return -EINVAL;
 1010a84:	e7c6      	b.n	1010a14 <keys_set+0x24>
	settings_name_next(name, &next);
 1010a86:	4630      	mov	r0, r6
 1010a88:	1d39      	adds	r1, r7, #4
 1010a8a:	f014 fc9b 	bl	10253c4 <settings_name_next>
	if (!next) {
 1010a8e:	6878      	ldr	r0, [r7, #4]
 1010a90:	b188      	cbz	r0, 1010ab6 <keys_set+0xc6>
		unsigned long next_id = strtoul(next, NULL, 10);
 1010a92:	220a      	movs	r2, #10
 1010a94:	4629      	mov	r1, r5
 1010a96:	f015 fead 	bl	10267f4 <strtoul>
		if (next_id >= CONFIG_BT_ID_MAX) {
 1010a9a:	b160      	cbz	r0, 1010ab6 <keys_set+0xc6>
			LOG_ERR("Invalid local identity %lu", next_id);
 1010a9c:	466c      	mov	r4, sp
 1010a9e:	b088      	sub	sp, #32
 1010aa0:	466a      	mov	r2, sp
 1010aa2:	4b3c      	ldr	r3, [pc, #240]	; (1010b94 <keys_set+0x1a4>)
 1010aa4:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1010aa8:	2303      	movs	r3, #3
 1010aaa:	f842 3f10 	str.w	r3, [r2, #16]!
 1010aae:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1010ab2:	462b      	mov	r3, r5
 1010ab4:	e7e2      	b.n	1010a7c <keys_set+0x8c>
	if (!len) {
 1010ab6:	bb1c      	cbnz	r4, 1010b00 <keys_set+0x110>
		keys = bt_keys_find(BT_KEYS_ALL, id, &addr);
 1010ab8:	4621      	mov	r1, r4
 1010aba:	203f      	movs	r0, #63	; 0x3f
 1010abc:	f107 0208 	add.w	r2, r7, #8
 1010ac0:	f7ff fe56 	bl	1010770 <bt_keys_find>
		if (keys) {
 1010ac4:	b120      	cbz	r0, 1010ad0 <keys_set+0xe0>
			(void)memset(keys, 0, sizeof(*keys));
 1010ac6:	225c      	movs	r2, #92	; 0x5c
 1010ac8:	4621      	mov	r1, r4
 1010aca:	f015 ff5e 	bl	102698a <memset>
			LOG_DBG("Cleared keys for %s", bt_addr_le_str(&addr));
 1010ace:	e7a3      	b.n	1010a18 <keys_set+0x28>
			LOG_WRN("Unable to find deleted keys for %s", bt_addr_le_str(&addr));
 1010ad0:	f107 0008 	add.w	r0, r7, #8
 1010ad4:	f7f6 f8ba 	bl	1006c4c <bt_addr_le_str>
 1010ad8:	466e      	mov	r6, sp
 1010ada:	b088      	sub	sp, #32
 1010adc:	466a      	mov	r2, sp
 1010ade:	4b2e      	ldr	r3, [pc, #184]	; (1010b98 <keys_set+0x1a8>)
 1010ae0:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1010ae4:	f44f 7300 	mov.w	r3, #512	; 0x200
 1010ae8:	8393      	strh	r3, [r2, #28]
 1010aea:	4b29      	ldr	r3, [pc, #164]	; (1010b90 <keys_set+0x1a0>)
 1010aec:	f842 3f10 	str.w	r3, [r2, #16]!
 1010af0:	f44f 51e4 	mov.w	r1, #7296	; 0x1c80
 1010af4:	4623      	mov	r3, r4
 1010af6:	4823      	ldr	r0, [pc, #140]	; (1010b84 <keys_set+0x194>)
 1010af8:	f7f3 fe06 	bl	1004708 <z_impl_z_log_msg_static_create>
 1010afc:	46b5      	mov	sp, r6
 1010afe:	e78b      	b.n	1010a18 <keys_set+0x28>
	__ASSERT_NO_MSG(addr != NULL);
 1010b00:	2000      	movs	r0, #0
 1010b02:	f107 0108 	add.w	r1, r7, #8
 1010b06:	f7ff fdad 	bl	1010664 <bt_keys_get_addr.part.0>
	if (!keys) {
 1010b0a:	4606      	mov	r6, r0
 1010b0c:	b9c8      	cbnz	r0, 1010b42 <keys_set+0x152>
		LOG_ERR("Failed to allocate keys for %s", bt_addr_le_str(&addr));
 1010b0e:	f107 0008 	add.w	r0, r7, #8
 1010b12:	f7f6 f89b 	bl	1006c4c <bt_addr_le_str>
 1010b16:	466c      	mov	r4, sp
 1010b18:	b088      	sub	sp, #32
 1010b1a:	466a      	mov	r2, sp
 1010b1c:	4b1f      	ldr	r3, [pc, #124]	; (1010b9c <keys_set+0x1ac>)
 1010b1e:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1010b22:	f44f 7300 	mov.w	r3, #512	; 0x200
 1010b26:	8393      	strh	r3, [r2, #28]
 1010b28:	4b19      	ldr	r3, [pc, #100]	; (1010b90 <keys_set+0x1a0>)
 1010b2a:	f842 3f10 	str.w	r3, [r2, #16]!
 1010b2e:	f44f 51e2 	mov.w	r1, #7232	; 0x1c40
 1010b32:	4633      	mov	r3, r6
 1010b34:	4813      	ldr	r0, [pc, #76]	; (1010b84 <keys_set+0x194>)
 1010b36:	f7f3 fde7 	bl	1004708 <z_impl_z_log_msg_static_create>
		return -ENOMEM;
 1010b3a:	f06f 050b 	mvn.w	r5, #11
 1010b3e:	46a5      	mov	sp, r4
 1010b40:	e76a      	b.n	1010a18 <keys_set+0x28>
	if (len != BT_KEYS_STORAGE_LEN) {
 1010b42:	2c50      	cmp	r4, #80	; 0x50
 1010b44:	d015      	beq.n	1010b72 <keys_set+0x182>
			LOG_ERR("Invalid key length %zd != %zu", len, BT_KEYS_STORAGE_LEN);
 1010b46:	466d      	mov	r5, sp
 1010b48:	b088      	sub	sp, #32
 1010b4a:	466a      	mov	r2, sp
 1010b4c:	4b14      	ldr	r3, [pc, #80]	; (1010ba0 <keys_set+0x1b0>)
 1010b4e:	e9c2 3405 	strd	r3, r4, [r2, #20]
 1010b52:	2350      	movs	r3, #80	; 0x50
 1010b54:	61d3      	str	r3, [r2, #28]
 1010b56:	2304      	movs	r3, #4
 1010b58:	f842 3f10 	str.w	r3, [r2, #16]!
 1010b5c:	2300      	movs	r3, #0
 1010b5e:	f44f 5101 	mov.w	r1, #8256	; 0x2040
 1010b62:	4808      	ldr	r0, [pc, #32]	; (1010b84 <keys_set+0x194>)
 1010b64:	f7f3 fdd0 	bl	1004708 <z_impl_z_log_msg_static_create>
			bt_keys_clear(keys);
 1010b68:	4630      	mov	r0, r6
 1010b6a:	46ad      	mov	sp, r5
 1010b6c:	f7ff ff06 	bl	101097c <bt_keys_clear>
			return -EINVAL;
 1010b70:	e750      	b.n	1010a14 <keys_set+0x24>
		memcpy(keys->storage_start, val, len);
 1010b72:	4622      	mov	r2, r4
 1010b74:	f107 0110 	add.w	r1, r7, #16
 1010b78:	300c      	adds	r0, #12
 1010b7a:	f015 fefb 	bl	1026974 <memcpy>
	return 0;
 1010b7e:	e74b      	b.n	1010a18 <keys_set+0x28>
 1010b80:	0102cd4a 	.word	0x0102cd4a
 1010b84:	010299bc 	.word	0x010299bc
 1010b88:	0102ed59 	.word	0x0102ed59
 1010b8c:	0102e430 	.word	0x0102e430
 1010b90:	01000003 	.word	0x01000003
 1010b94:	0102e44c 	.word	0x0102e44c
 1010b98:	0102ed78 	.word	0x0102ed78
 1010b9c:	0102ed9b 	.word	0x0102ed9b
 1010ba0:	0102edba 	.word	0x0102edba

01010ba4 <bt_keys_store>:
{
 1010ba4:	b5b0      	push	{r4, r5, r7, lr}
 1010ba6:	b08c      	sub	sp, #48	; 0x30
	__ASSERT_NO_MSG(keys != NULL);
 1010ba8:	4604      	mov	r4, r0
{
 1010baa:	af02      	add	r7, sp, #8
	__ASSERT_NO_MSG(keys != NULL);
 1010bac:	b958      	cbnz	r0, 1010bc6 <bt_keys_store+0x22>
 1010bae:	491c      	ldr	r1, [pc, #112]	; (1010c20 <bt_keys_store+0x7c>)
 1010bb0:	481c      	ldr	r0, [pc, #112]	; (1010c24 <bt_keys_store+0x80>)
 1010bb2:	f240 1355 	movw	r3, #341	; 0x155
 1010bb6:	4a1c      	ldr	r2, [pc, #112]	; (1010c28 <bt_keys_store+0x84>)
 1010bb8:	f014 f80d 	bl	1024bd6 <assert_print>
 1010bbc:	f240 1155 	movw	r1, #341	; 0x155
 1010bc0:	4819      	ldr	r0, [pc, #100]	; (1010c28 <bt_keys_store+0x84>)
 1010bc2:	f014 f801 	bl	1024bc8 <assert_post_action>
	if (keys->id) {
 1010bc6:	4605      	mov	r5, r0
 1010bc8:	f815 2b01 	ldrb.w	r2, [r5], #1
 1010bcc:	b332      	cbz	r2, 1010c1c <bt_keys_store+0x78>
		u8_to_dec(id, sizeof(id), keys->id);
 1010bce:	2104      	movs	r1, #4
 1010bd0:	4638      	mov	r0, r7
 1010bd2:	f013 fd68 	bl	10246a6 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "keys", &keys->addr,
 1010bd6:	9700      	str	r7, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "keys", &keys->addr,
 1010bd8:	462b      	mov	r3, r5
 1010bda:	2124      	movs	r1, #36	; 0x24
 1010bdc:	4a13      	ldr	r2, [pc, #76]	; (1010c2c <bt_keys_store+0x88>)
 1010bde:	1d38      	adds	r0, r7, #4
 1010be0:	f7f6 face 	bl	1007180 <bt_settings_encode_key>
	err = settings_save_one(key, keys->storage_start, BT_KEYS_STORAGE_LEN);
 1010be4:	f104 010c 	add.w	r1, r4, #12
 1010be8:	2250      	movs	r2, #80	; 0x50
 1010bea:	1d38      	adds	r0, r7, #4
 1010bec:	f7f4 fcb2 	bl	1005554 <settings_save_one>
	if (err) {
 1010bf0:	4604      	mov	r4, r0
 1010bf2:	b178      	cbz	r0, 1010c14 <bt_keys_store+0x70>
		LOG_ERR("Failed to save keys (err %d)", err);
 1010bf4:	466d      	mov	r5, sp
 1010bf6:	b088      	sub	sp, #32
 1010bf8:	aa02      	add	r2, sp, #8
 1010bfa:	4b0d      	ldr	r3, [pc, #52]	; (1010c30 <bt_keys_store+0x8c>)
 1010bfc:	e9c2 3005 	strd	r3, r0, [r2, #20]
 1010c00:	2303      	movs	r3, #3
 1010c02:	f842 3f10 	str.w	r3, [r2, #16]!
 1010c06:	2300      	movs	r3, #0
 1010c08:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1010c0c:	4809      	ldr	r0, [pc, #36]	; (1010c34 <bt_keys_store+0x90>)
 1010c0e:	f7f3 fd7b 	bl	1004708 <z_impl_z_log_msg_static_create>
 1010c12:	46ad      	mov	sp, r5
}
 1010c14:	4620      	mov	r0, r4
 1010c16:	3728      	adds	r7, #40	; 0x28
 1010c18:	46bd      	mov	sp, r7
 1010c1a:	bdb0      	pop	{r4, r5, r7, pc}
		bt_settings_encode_key(key, sizeof(key), "keys", &keys->addr,
 1010c1c:	9200      	str	r2, [sp, #0]
 1010c1e:	e7db      	b.n	1010bd8 <bt_keys_store+0x34>
 1010c20:	0102ed1d 	.word	0x0102ed1d
 1010c24:	0102b695 	.word	0x0102b695
 1010c28:	0102eced 	.word	0x0102eced
 1010c2c:	0102edf8 	.word	0x0102edf8
 1010c30:	0102edd8 	.word	0x0102edd8
 1010c34:	010299bc 	.word	0x010299bc

01010c38 <sys_memcpy_swap>:
	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
 1010c38:	4288      	cmp	r0, r1
{
 1010c3a:	b510      	push	{r4, lr}
 1010c3c:	eb00 0302 	add.w	r3, r0, r2
	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
 1010c40:	d911      	bls.n	1010c66 <sys_memcpy_swap+0x2e>
 1010c42:	188c      	adds	r4, r1, r2
 1010c44:	42a0      	cmp	r0, r4
 1010c46:	d211      	bcs.n	1010c6c <sys_memcpy_swap+0x34>
 1010c48:	490d      	ldr	r1, [pc, #52]	; (1010c80 <sys_memcpy_swap+0x48>)
 1010c4a:	f240 2315 	movw	r3, #533	; 0x215
 1010c4e:	4a0d      	ldr	r2, [pc, #52]	; (1010c84 <sys_memcpy_swap+0x4c>)
 1010c50:	480d      	ldr	r0, [pc, #52]	; (1010c88 <sys_memcpy_swap+0x50>)
 1010c52:	f013 ffc0 	bl	1024bd6 <assert_print>
 1010c56:	480d      	ldr	r0, [pc, #52]	; (1010c8c <sys_memcpy_swap+0x54>)
 1010c58:	f013 ffbd 	bl	1024bd6 <assert_print>
 1010c5c:	f240 2115 	movw	r1, #533	; 0x215
 1010c60:	4808      	ldr	r0, [pc, #32]	; (1010c84 <sys_memcpy_swap+0x4c>)
 1010c62:	f013 ffb1 	bl	1024bc8 <assert_post_action>
 1010c66:	d0ef      	beq.n	1010c48 <sys_memcpy_swap+0x10>
 1010c68:	4299      	cmp	r1, r3
 1010c6a:	e7ec      	b.n	1010c46 <sys_memcpy_swap+0xe>
	psrc += length - 1;
 1010c6c:	3a01      	subs	r2, #1
 1010c6e:	4411      	add	r1, r2
		*pdst++ = *psrc--;
 1010c70:	f811 2901 	ldrb.w	r2, [r1], #-1
 1010c74:	f800 2b01 	strb.w	r2, [r0], #1
	for (; length > 0; length--) {
 1010c78:	4283      	cmp	r3, r0
 1010c7a:	d1f9      	bne.n	1010c70 <sys_memcpy_swap+0x38>
}
 1010c7c:	bd10      	pop	{r4, pc}
 1010c7e:	bf00      	nop
 1010c80:	0102cbd6 	.word	0x0102cbd6
 1010c84:	0102cba4 	.word	0x0102cba4
 1010c88:	0102b695 	.word	0x0102b695
 1010c8c:	0102cc2d 	.word	0x0102cc2d

01010c90 <bt_crypto_f5>:
	return err;
}

int bt_crypto_f5(const uint8_t *w, const uint8_t *n1, const uint8_t *n2, const bt_addr_le_t *a1,
		 const bt_addr_le_t *a2, uint8_t *mackey, uint8_t *ltk)
{
 1010c90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1010c94:	b09a      	sub	sp, #104	; 0x68
 1010c96:	4616      	mov	r6, r2
 1010c98:	e9dd 9723 	ldrd	r9, r7, [sp, #140]	; 0x8c
	static const uint8_t salt[16] = {0x6c, 0x88, 0x83, 0x91, 0xaa, 0xf5, 0xa5, 0x38,
					 0x60, 0x37, 0x0b, 0xdb, 0x5a, 0x60, 0x83, 0xbe};
	uint8_t m[53] = {0x00,						 /* counter */
 1010c9c:	aa0c      	add	r2, sp, #48	; 0x30
{
 1010c9e:	4684      	mov	ip, r0
 1010ca0:	468a      	mov	sl, r1
 1010ca2:	4690      	mov	r8, r2
 1010ca4:	461d      	mov	r5, r3
	uint8_t m[53] = {0x00,						 /* counter */
 1010ca6:	4b2c      	ldr	r3, [pc, #176]	; (1010d58 <bt_crypto_f5+0xc8>)
 1010ca8:	f103 0e30 	add.w	lr, r3, #48	; 0x30
 1010cac:	4614      	mov	r4, r2
 1010cae:	6818      	ldr	r0, [r3, #0]
 1010cb0:	6859      	ldr	r1, [r3, #4]
 1010cb2:	3308      	adds	r3, #8
 1010cb4:	c403      	stmia	r4!, {r0, r1}
 1010cb6:	4573      	cmp	r3, lr
 1010cb8:	4622      	mov	r2, r4
 1010cba:	d1f7      	bne.n	1010cac <bt_crypto_f5+0x1c>
 1010cbc:	6818      	ldr	r0, [r3, #0]
 1010cbe:	791b      	ldrb	r3, [r3, #4]

	LOG_DBG("w %s", bt_hex(w, 32));
	LOG_DBG("n1 %s", bt_hex(n1, 16));
	LOG_DBG("n2 %s", bt_hex(n2, 16));

	sys_memcpy_swap(ws, w, 32);
 1010cc0:	4661      	mov	r1, ip
	uint8_t m[53] = {0x00,						 /* counter */
 1010cc2:	6020      	str	r0, [r4, #0]
 1010cc4:	7123      	strb	r3, [r4, #4]
	sys_memcpy_swap(ws, w, 32);
 1010cc6:	2220      	movs	r2, #32
 1010cc8:	a804      	add	r0, sp, #16
 1010cca:	f7ff ffb5 	bl	1010c38 <sys_memcpy_swap>

	err = bt_crypto_aes_cmac(salt, ws, 32, t);
 1010cce:	466b      	mov	r3, sp
 1010cd0:	2220      	movs	r2, #32
 1010cd2:	4822      	ldr	r0, [pc, #136]	; (1010d5c <bt_crypto_f5+0xcc>)
 1010cd4:	a904      	add	r1, sp, #16
 1010cd6:	f017 ffa7 	bl	1028c28 <bt_crypto_aes_cmac>
	if (err) {
 1010cda:	4604      	mov	r4, r0
 1010cdc:	bbc0      	cbnz	r0, 1010d50 <bt_crypto_f5+0xc0>
		return err;
	}

	LOG_DBG("t %s", bt_hex(t, 16));

	sys_memcpy_swap(m + 5, n1, 16);
 1010cde:	2210      	movs	r2, #16
 1010ce0:	4651      	mov	r1, sl
 1010ce2:	f10d 0035 	add.w	r0, sp, #53	; 0x35
 1010ce6:	f7ff ffa7 	bl	1010c38 <sys_memcpy_swap>
	sys_memcpy_swap(m + 21, n2, 16);
 1010cea:	2210      	movs	r2, #16
 1010cec:	4631      	mov	r1, r6
 1010cee:	f10d 0045 	add.w	r0, sp, #69	; 0x45
 1010cf2:	f7ff ffa1 	bl	1010c38 <sys_memcpy_swap>
	m[37] = a1->type;
 1010cf6:	4629      	mov	r1, r5
 1010cf8:	f811 3b01 	ldrb.w	r3, [r1], #1
	sys_memcpy_swap(m + 38, a1->a.val, 6);
 1010cfc:	2206      	movs	r2, #6
 1010cfe:	f10d 0056 	add.w	r0, sp, #86	; 0x56
	m[37] = a1->type;
 1010d02:	f88d 3055 	strb.w	r3, [sp, #85]	; 0x55
	sys_memcpy_swap(m + 38, a1->a.val, 6);
 1010d06:	f7ff ff97 	bl	1010c38 <sys_memcpy_swap>
	m[44] = a2->type;
 1010d0a:	9922      	ldr	r1, [sp, #136]	; 0x88
	sys_memcpy_swap(m + 45, a2->a.val, 6);
 1010d0c:	2206      	movs	r2, #6
	m[44] = a2->type;
 1010d0e:	f811 3b01 	ldrb.w	r3, [r1], #1
	sys_memcpy_swap(m + 45, a2->a.val, 6);
 1010d12:	f10d 005d 	add.w	r0, sp, #93	; 0x5d
	m[44] = a2->type;
 1010d16:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
	sys_memcpy_swap(m + 45, a2->a.val, 6);
 1010d1a:	f7ff ff8d 	bl	1010c38 <sys_memcpy_swap>

	err = bt_crypto_aes_cmac(t, m, sizeof(m), mackey);
 1010d1e:	464b      	mov	r3, r9
 1010d20:	2235      	movs	r2, #53	; 0x35
 1010d22:	4641      	mov	r1, r8
 1010d24:	4668      	mov	r0, sp
 1010d26:	f017 ff7f 	bl	1028c28 <bt_crypto_aes_cmac>
	if (err) {
 1010d2a:	4604      	mov	r4, r0
 1010d2c:	b980      	cbnz	r0, 1010d50 <bt_crypto_f5+0xc0>
		return err;
	}

	LOG_DBG("mackey %1s", bt_hex(mackey, 16));

	sys_mem_swap(mackey, 16);
 1010d2e:	4648      	mov	r0, r9
 1010d30:	f017 ff6c 	bl	1028c0c <sys_mem_swap.constprop.0>

	/* counter for ltk is 1 */
	m[0] = 0x01;
 1010d34:	2301      	movs	r3, #1

	err = bt_crypto_aes_cmac(t, m, sizeof(m), ltk);
 1010d36:	2235      	movs	r2, #53	; 0x35
	m[0] = 0x01;
 1010d38:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	err = bt_crypto_aes_cmac(t, m, sizeof(m), ltk);
 1010d3c:	4641      	mov	r1, r8
 1010d3e:	463b      	mov	r3, r7
 1010d40:	4668      	mov	r0, sp
 1010d42:	f017 ff71 	bl	1028c28 <bt_crypto_aes_cmac>
	if (err) {
 1010d46:	4604      	mov	r4, r0
 1010d48:	b910      	cbnz	r0, 1010d50 <bt_crypto_f5+0xc0>
		return err;
	}

	LOG_DBG("ltk %s", bt_hex(ltk, 16));

	sys_mem_swap(ltk, 16);
 1010d4a:	4638      	mov	r0, r7
 1010d4c:	f017 ff5e 	bl	1028c0c <sys_mem_swap.constprop.0>

	return 0;
}
 1010d50:	4620      	mov	r0, r4
 1010d52:	b01a      	add	sp, #104	; 0x68
 1010d54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1010d58:	01029b52 	.word	0x01029b52
 1010d5c:	0102ee05 	.word	0x0102ee05

01010d60 <bt_crypto_g2>:
	return 0;
}

int bt_crypto_g2(const uint8_t u[32], const uint8_t v[32], const uint8_t x[16], const uint8_t y[16],
		 uint32_t *passkey)
{
 1010d60:	b5f0      	push	{r4, r5, r6, r7, lr}
 1010d62:	460f      	mov	r7, r1
 1010d64:	461e      	mov	r6, r3
 1010d66:	4614      	mov	r4, r2
 1010d68:	b099      	sub	sp, #100	; 0x64
	LOG_DBG("u %s", bt_hex(u, 32));
	LOG_DBG("v %s", bt_hex(v, 32));
	LOG_DBG("x %s", bt_hex(x, 16));
	LOG_DBG("y %s", bt_hex(y, 16));

	sys_memcpy_swap(m, u, 32);
 1010d6a:	4601      	mov	r1, r0
 1010d6c:	2220      	movs	r2, #32
 1010d6e:	a804      	add	r0, sp, #16
{
 1010d70:	9d1e      	ldr	r5, [sp, #120]	; 0x78
	sys_memcpy_swap(m, u, 32);
 1010d72:	f7ff ff61 	bl	1010c38 <sys_memcpy_swap>
	sys_memcpy_swap(m + 32, v, 32);
 1010d76:	2220      	movs	r2, #32
 1010d78:	4639      	mov	r1, r7
 1010d7a:	a80c      	add	r0, sp, #48	; 0x30
 1010d7c:	f7ff ff5c 	bl	1010c38 <sys_memcpy_swap>
	sys_memcpy_swap(m + 64, y, 16);
 1010d80:	2210      	movs	r2, #16
 1010d82:	4631      	mov	r1, r6
 1010d84:	a814      	add	r0, sp, #80	; 0x50
 1010d86:	f7ff ff57 	bl	1010c38 <sys_memcpy_swap>

	sys_memcpy_swap(xs, x, 16);
 1010d8a:	4621      	mov	r1, r4
 1010d8c:	2210      	movs	r2, #16
 1010d8e:	4668      	mov	r0, sp
 1010d90:	f7ff ff52 	bl	1010c38 <sys_memcpy_swap>

	/* reuse xs (key) as buffer for result */
	err = bt_crypto_aes_cmac(xs, m, sizeof(m), xs);
 1010d94:	466b      	mov	r3, sp
 1010d96:	2250      	movs	r2, #80	; 0x50
 1010d98:	4618      	mov	r0, r3
 1010d9a:	a904      	add	r1, sp, #16
 1010d9c:	f017 ff44 	bl	1028c28 <bt_crypto_aes_cmac>
	if (err) {
 1010da0:	4604      	mov	r4, r0
 1010da2:	b960      	cbnz	r0, 1010dbe <bt_crypto_g2+0x5e>
		return err;
	}
	LOG_DBG("res %s", bt_hex(xs, 16));

	memcpy(passkey, xs + 12, 4);
 1010da4:	2204      	movs	r2, #4
 1010da6:	a903      	add	r1, sp, #12
 1010da8:	4628      	mov	r0, r5
 1010daa:	f015 fde3 	bl	1026974 <memcpy>
	*passkey = sys_be32_to_cpu(*passkey) % 1000000;
 1010dae:	682b      	ldr	r3, [r5, #0]
 1010db0:	4a04      	ldr	r2, [pc, #16]	; (1010dc4 <bt_crypto_g2+0x64>)
 1010db2:	ba1b      	rev	r3, r3
 1010db4:	fbb3 f1f2 	udiv	r1, r3, r2
 1010db8:	fb02 3311 	mls	r3, r2, r1, r3
 1010dbc:	602b      	str	r3, [r5, #0]

	LOG_DBG("passkey %u", *passkey);

	return 0;
}
 1010dbe:	4620      	mov	r0, r4
 1010dc0:	b019      	add	sp, #100	; 0x64
 1010dc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1010dc4:	000f4240 	.word	0x000f4240

01010dc8 <mem_init>:

#include "mem.h"

void mem_init(void *mem_pool, uint16_t mem_size, uint16_t mem_count,
	      void **mem_head)
{
 1010dc8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1010dcc:	4616      	mov	r6, r2
 1010dce:	4604      	mov	r4, r0
 1010dd0:	460f      	mov	r7, r1
	*mem_head = mem_pool;

	/* Store free mem_count after the list's next pointer at an 32-bit
	 * aligned memory location to ensure atomic read/write (in ARM for now).
	 */
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
 1010dd2:	3007      	adds	r0, #7

	/* Initialize next pointers to form a free list,
	 * next pointer is stored in the first 32-bit of each block
	 */
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
 1010dd4:	1e75      	subs	r5, r6, #1
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
 1010dd6:	f020 0003 	bic.w	r0, r0, #3
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
 1010dda:	b2ad      	uxth	r5, r5
{
 1010ddc:	b082      	sub	sp, #8
	*mem_head = mem_pool;
 1010dde:	601c      	str	r4, [r3, #0]
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
 1010de0:	2204      	movs	r2, #4
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
 1010de2:	8006      	strh	r6, [r0, #0]
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
 1010de4:	2100      	movs	r1, #0
 1010de6:	fb07 4005 	mla	r0, r7, r5, r4
 1010dea:	f015 fdce 	bl	102698a <memset>
		     sizeof(mem_pool));
	while (mem_count--) {
 1010dee:	b1bd      	cbz	r5, 1010e20 <mem_init+0x58>
 1010df0:	2500      	movs	r5, #0
 1010df2:	3e02      	subs	r6, #2
 1010df4:	b2b6      	uxth	r6, r6
 1010df6:	fb06 7307 	mla	r3, r6, r7, r7
 1010dfa:	fb06 f807 	mul.w	r8, r6, r7
 1010dfe:	441c      	add	r4, r3
 1010e00:	eba8 0803 	sub.w	r8, r8, r3
		uint32_t next;

		next = (uint32_t)((uint8_t *) mem_pool +
			       (mem_size * (mem_count + 1)));
		memcpy(((uint8_t *)mem_pool + (mem_size * mem_count)),
 1010e04:	2204      	movs	r2, #4
 1010e06:	eb04 0008 	add.w	r0, r4, r8
 1010e0a:	eb0d 0102 	add.w	r1, sp, r2
		next = (uint32_t)((uint8_t *) mem_pool +
 1010e0e:	9401      	str	r4, [sp, #4]
		memcpy(((uint8_t *)mem_pool + (mem_size * mem_count)),
 1010e10:	f015 fdb0 	bl	1026974 <memcpy>
	while (mem_count--) {
 1010e14:	42b5      	cmp	r5, r6
 1010e16:	eba4 0407 	sub.w	r4, r4, r7
 1010e1a:	f105 0501 	add.w	r5, r5, #1
 1010e1e:	d1f1      	bne.n	1010e04 <mem_init+0x3c>
		       (void *)&next, sizeof(next));
	}
}
 1010e20:	b002      	add	sp, #8
 1010e22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 1010e26:	bf00      	nop

01010e28 <mem_acquire>:

void *mem_acquire(void **mem_head)
{
 1010e28:	b570      	push	{r4, r5, r6, lr}
	if (*mem_head) {
 1010e2a:	6805      	ldr	r5, [r0, #0]
{
 1010e2c:	b082      	sub	sp, #8
	if (*mem_head) {
 1010e2e:	b19d      	cbz	r5, 1010e58 <mem_acquire+0x30>
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
					       sizeof(mem_head)));
		free_count--;

		mem = *mem_head;
		memcpy(&head, mem, sizeof(head));
 1010e30:	2204      	movs	r2, #4
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
 1010e32:	1deb      	adds	r3, r5, #7
 1010e34:	f023 0303 	bic.w	r3, r3, #3
 1010e38:	4604      	mov	r4, r0
		memcpy(&head, mem, sizeof(head));
 1010e3a:	4629      	mov	r1, r5
 1010e3c:	eb0d 0002 	add.w	r0, sp, r2
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
 1010e40:	881e      	ldrh	r6, [r3, #0]
		memcpy(&head, mem, sizeof(head));
 1010e42:	f015 fd97 	bl	1026974 <memcpy>

		/* Store free mem_count after the list's next pointer */
		if (head) {
 1010e46:	9b01      	ldr	r3, [sp, #4]
 1010e48:	b12b      	cbz	r3, 1010e56 <mem_acquire+0x2e>
			*((uint16_t *)MROUND((uint8_t *)head + sizeof(head))) =
 1010e4a:	3307      	adds	r3, #7
 1010e4c:	f023 0303 	bic.w	r3, r3, #3
		free_count--;
 1010e50:	3e01      	subs	r6, #1
			*((uint16_t *)MROUND((uint8_t *)head + sizeof(head))) =
 1010e52:	801e      	strh	r6, [r3, #0]
				free_count;
		}

		*mem_head = head;
 1010e54:	9b01      	ldr	r3, [sp, #4]
 1010e56:	6023      	str	r3, [r4, #0]
		return mem;
	}

	return NULL;
}
 1010e58:	4628      	mov	r0, r5
 1010e5a:	b002      	add	sp, #8
 1010e5c:	bd70      	pop	{r4, r5, r6, pc}
 1010e5e:	bf00      	nop

01010e60 <mem_release>:

void mem_release(void *mem, void **mem_head)
{
 1010e60:	b570      	push	{r4, r5, r6, lr}
	uint16_t free_count = 0U;

	/* Get the free count from the list and increment it */
	if (*mem_head) {
 1010e62:	680b      	ldr	r3, [r1, #0]
{
 1010e64:	460c      	mov	r4, r1
 1010e66:	4605      	mov	r5, r0
	if (*mem_head) {
 1010e68:	b183      	cbz	r3, 1010e8c <mem_release+0x2c>
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
 1010e6a:	3307      	adds	r3, #7
 1010e6c:	f023 0303 	bic.w	r3, r3, #3
					       sizeof(mem_head)));
	}
	free_count++;
 1010e70:	881e      	ldrh	r6, [r3, #0]
 1010e72:	3601      	adds	r6, #1
 1010e74:	b2b6      	uxth	r6, r6

	memcpy(mem, mem_head, sizeof(mem));
 1010e76:	2204      	movs	r2, #4
 1010e78:	4621      	mov	r1, r4
 1010e7a:	4628      	mov	r0, r5
 1010e7c:	f015 fd7a 	bl	1026974 <memcpy>

	/* Store free mem_count after the list's next pointer */
	*((uint16_t *)MROUND((uint8_t *)mem + sizeof(mem))) = free_count;
 1010e80:	1deb      	adds	r3, r5, #7
 1010e82:	f023 0303 	bic.w	r3, r3, #3
 1010e86:	801e      	strh	r6, [r3, #0]

	*mem_head = mem;
 1010e88:	6025      	str	r5, [r4, #0]
}
 1010e8a:	bd70      	pop	{r4, r5, r6, pc}
 1010e8c:	2601      	movs	r6, #1
 1010e8e:	e7f2      	b.n	1010e76 <mem_release+0x16>

01010e90 <mem_get>:
}

void *mem_get(void *mem_pool, uint16_t mem_size, uint16_t index)
{
	return ((void *)((uint8_t *)mem_pool + (mem_size * index)));
}
 1010e90:	fb02 0001 	mla	r0, r2, r1, r0
 1010e94:	4770      	bx	lr
 1010e96:	bf00      	nop

01010e98 <mem_index_get>:

uint16_t mem_index_get(void *mem, void *mem_pool, uint16_t mem_size)
{
	return ((uint8_t *)mem - (uint8_t *)mem_pool) / mem_size;
 1010e98:	1a40      	subs	r0, r0, r1
 1010e9a:	fb90 f0f2 	sdiv	r0, r0, r2
}
 1010e9e:	b280      	uxth	r0, r0
 1010ea0:	4770      	bx	lr
 1010ea2:	bf00      	nop

01010ea4 <mem_rcopy>:
 * @details Example: [ 0x11 0x22 0x33 ] -> [ 0x33 0x22 0x11 ]
 */
void mem_rcopy(uint8_t *dst, uint8_t const *src, uint16_t len)
{
	src += len;
	while (len--) {
 1010ea4:	1e53      	subs	r3, r2, #1
	src += len;
 1010ea6:	4411      	add	r1, r2
	while (len--) {
 1010ea8:	b29b      	uxth	r3, r3
 1010eaa:	b142      	cbz	r2, 1010ebe <mem_rcopy+0x1a>
 1010eac:	43db      	mvns	r3, r3
 1010eae:	3801      	subs	r0, #1
 1010eb0:	18ca      	adds	r2, r1, r3
		*dst++ = *--src;
 1010eb2:	f811 3d01 	ldrb.w	r3, [r1, #-1]!
	while (len--) {
 1010eb6:	4291      	cmp	r1, r2
		*dst++ = *--src;
 1010eb8:	f800 3f01 	strb.w	r3, [r0, #1]!
	while (len--) {
 1010ebc:	d1f9      	bne.n	1010eb2 <mem_rcopy+0xe>
	}
}
 1010ebe:	4770      	bx	lr

01010ec0 <mem_nz>:
 * @brief Determine if src[0..len-1] contains one or more non-zero bytes
 * @return 0 if all bytes are zero; otherwise 1
 */
uint8_t mem_nz(uint8_t *src, uint16_t len)
{
	while (len--) {
 1010ec0:	4401      	add	r1, r0
 1010ec2:	e002      	b.n	1010eca <mem_nz+0xa>
		if (*src++) {
 1010ec4:	f810 3b01 	ldrb.w	r3, [r0], #1
 1010ec8:	b91b      	cbnz	r3, 1010ed2 <mem_nz+0x12>
	while (len--) {
 1010eca:	4288      	cmp	r0, r1
 1010ecc:	d1fa      	bne.n	1010ec4 <mem_nz+0x4>
			return 1;
		}
	}

	return 0;
 1010ece:	2000      	movs	r0, #0
 1010ed0:	4770      	bx	lr
			return 1;
 1010ed2:	2001      	movs	r0, #1
}
 1010ed4:	4770      	bx	lr
 1010ed6:	bf00      	nop

01010ed8 <memq_init>:
 * @return          Initial link-element
 */
memq_link_t *memq_init(memq_link_t *link, memq_link_t **head, memq_link_t **tail)
{
	/* Head and tail pointer to the initial link - forms an empty queue */
	*head = *tail = link;
 1010ed8:	6010      	str	r0, [r2, #0]
 1010eda:	6008      	str	r0, [r1, #0]

	return link;
}
 1010edc:	4770      	bx	lr
 1010ede:	bf00      	nop

01010ee0 <memq_deinit>:
memq_link_t *memq_deinit(memq_link_t **head, memq_link_t **tail)
{
	memq_link_t *old_head;

	/* If head and tail are not equal, then queue is not empty */
	if (*head != *tail) {
 1010ee0:	680a      	ldr	r2, [r1, #0]
{
 1010ee2:	4603      	mov	r3, r0
	if (*head != *tail) {
 1010ee4:	6800      	ldr	r0, [r0, #0]
 1010ee6:	4290      	cmp	r0, r2
		return NULL;
	}

	old_head = *head;
	*head = *tail = NULL;
 1010ee8:	bf09      	itett	eq
 1010eea:	2200      	moveq	r2, #0
		return NULL;
 1010eec:	2000      	movne	r0, #0
	*head = *tail = NULL;
 1010eee:	600a      	streq	r2, [r1, #0]
 1010ef0:	601a      	streq	r2, [r3, #0]

	return old_head;
}
 1010ef2:	4770      	bx	lr

01010ef4 <memq_enqueue>:
 * @return             New tail. Note: Does not point to the new mem
 */
memq_link_t *memq_enqueue(memq_link_t *link, void *mem, memq_link_t **tail)
{
	/* Let the old tail element point to the new tail element */
	(*tail)->next = link;
 1010ef4:	f8d2 c000 	ldr.w	ip, [r2]
 1010ef8:	f8cc 0000 	str.w	r0, [ip]

	/* Let the old tail element point the the new memory */
	(*tail)->mem = mem;
 1010efc:	f8d2 c000 	ldr.w	ip, [r2]
 1010f00:	f8cc 1004 	str.w	r1, [ip, #4]

	/* Update the tail-pointer to point to the new tail element.
	 * The new tail-element is not expected to point to anything sensible
	 */
	cpu_dmb(); /* Ensure data accesses are synchronized */
	*tail = link; /* Commit: enqueue of memq node */
 1010f04:	6010      	str	r0, [r2, #0]

	return link;
}
 1010f06:	4770      	bx	lr

01010f08 <memq_peek>:
 * @return         head or NULL if queue is empty
 */
memq_link_t *memq_peek(memq_link_t *head, memq_link_t *tail, void **mem)
{
	/* If head and tail are equal, then queue empty */
	if (head == tail) {
 1010f08:	4288      	cmp	r0, r1
 1010f0a:	d003      	beq.n	1010f14 <memq_peek+0xc>
		return NULL;
	}

	/* Extract the head link-element's memory */
	if (mem) {
 1010f0c:	b11a      	cbz	r2, 1010f16 <memq_peek+0xe>
		*mem = head->mem;
 1010f0e:	6843      	ldr	r3, [r0, #4]
 1010f10:	6013      	str	r3, [r2, #0]
 1010f12:	4770      	bx	lr
		return NULL;
 1010f14:	2000      	movs	r0, #0
	}

	return head; /* queue was not empty */
}
 1010f16:	4770      	bx	lr

01010f18 <memq_dequeue>:
memq_link_t *memq_dequeue(memq_link_t *tail, memq_link_t **head, void **mem)
{
	memq_link_t *old_head;

	/* Use memq peek to get the old head and its mem */
	old_head = memq_peek(*head, tail, mem);
 1010f18:	680b      	ldr	r3, [r1, #0]
	if (head == tail) {
 1010f1a:	4283      	cmp	r3, r0
 1010f1c:	d009      	beq.n	1010f32 <memq_dequeue+0x1a>
	if (mem) {
 1010f1e:	b12a      	cbz	r2, 1010f2c <memq_dequeue+0x14>
		*mem = head->mem;
 1010f20:	6858      	ldr	r0, [r3, #4]
 1010f22:	6010      	str	r0, [r2, #0]
	if (old_head == NULL) {
		return NULL; /* queue is empty */
	}

	/* Update the head-pointer to point to the new head element */
	*head = old_head->next;
 1010f24:	681a      	ldr	r2, [r3, #0]
 1010f26:	600a      	str	r2, [r1, #0]

	return old_head;
}
 1010f28:	4618      	mov	r0, r3
 1010f2a:	4770      	bx	lr
	if (old_head == NULL) {
 1010f2c:	2b00      	cmp	r3, #0
 1010f2e:	d1f9      	bne.n	1010f24 <memq_dequeue+0xc>
 1010f30:	e7fa      	b.n	1010f28 <memq_dequeue+0x10>
		return NULL; /* queue is empty */
 1010f32:	2300      	movs	r3, #0
 1010f34:	e7f8      	b.n	1010f28 <memq_dequeue+0x10>
 1010f36:	bf00      	nop

01010f38 <mayfly_init>:
#if defined(MAYFLY_UT)
static uint8_t _state;
#endif /* MAYFLY_UT */

void mayfly_init(void)
{
 1010f38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1010f3c:	f04f 080c 	mov.w	r8, #12
 1010f40:	4f0c      	ldr	r7, [pc, #48]	; (1010f74 <mayfly_init+0x3c>)
 1010f42:	4e0d      	ldr	r6, [pc, #52]	; (1010f78 <mayfly_init+0x40>)
 1010f44:	463d      	mov	r5, r7
 1010f46:	f106 0430 	add.w	r4, r6, #48	; 0x30
	while (callee_id--) {
		uint8_t caller_id;

		caller_id = MAYFLY_CALLER_COUNT;
		while (caller_id--) {
			memq_init(&mfl[callee_id][caller_id],
 1010f4a:	4621      	mov	r1, r4
 1010f4c:	4628      	mov	r0, r5
 1010f4e:	1d22      	adds	r2, r4, #4
		while (caller_id--) {
 1010f50:	3c0c      	subs	r4, #12
			memq_init(&mfl[callee_id][caller_id],
 1010f52:	f7ff ffc1 	bl	1010ed8 <memq_init>
		while (caller_id--) {
 1010f56:	42a6      	cmp	r6, r4
 1010f58:	f1a5 0508 	sub.w	r5, r5, #8
 1010f5c:	d1f5      	bne.n	1010f4a <mayfly_init+0x12>
	while (callee_id--) {
 1010f5e:	f1a8 0804 	sub.w	r8, r8, #4
 1010f62:	f118 0f04 	cmn.w	r8, #4
 1010f66:	f1a7 0720 	sub.w	r7, r7, #32
 1010f6a:	f1a6 0630 	sub.w	r6, r6, #48	; 0x30
 1010f6e:	d1e9      	bne.n	1010f44 <mayfly_init+0xc>
				  &mft[callee_id][caller_id].head,
				  &mft[callee_id][caller_id].tail);
		}
	}
}
 1010f70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 1010f74:	21004bd8 	.word	0x21004bd8
 1010f78:	21004c64 	.word	0x21004c64

01010f7c <mayfly_enable>:

void mayfly_enable(uint8_t caller_id, uint8_t callee_id, uint8_t enable)
{
 1010f7c:	4603      	mov	r3, r0
 1010f7e:	468c      	mov	ip, r1
 1010f80:	b410      	push	{r4}
	if (enable) {
 1010f82:	b19a      	cbz	r2, 1010fac <mayfly_enable+0x30>
		if (mft[callee_id][caller_id].enable_req ==
 1010f84:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 1010f88:	4814      	ldr	r0, [pc, #80]	; (1010fdc <mayfly_enable+0x60>)
 1010f8a:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 1010f8e:	0109      	lsls	r1, r1, #4
 1010f90:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 1010f94:	4401      	add	r1, r0
 1010f96:	7a48      	ldrb	r0, [r1, #9]
 1010f98:	7a0c      	ldrb	r4, [r1, #8]
 1010f9a:	42a0      	cmp	r0, r4
		    mft[callee_id][caller_id].enable_ack) {
			mft[callee_id][caller_id].enable_req++;
 1010f9c:	bf04      	itt	eq
 1010f9e:	3001      	addeq	r0, #1
 1010fa0:	7208      	strbeq	r0, [r1, #8]

			/* pend the callee for execution */
			mayfly_pend(caller_id, callee_id);
		}
	}
}
 1010fa2:	bc10      	pop	{r4}
		mayfly_enable_cb(caller_id, callee_id, enable);
 1010fa4:	4661      	mov	r1, ip
 1010fa6:	4618      	mov	r0, r3
 1010fa8:	f00c bd02 	b.w	101d9b0 <mayfly_enable_cb>
		if (mft[callee_id][caller_id].disable_req ==
 1010fac:	eb01 0241 	add.w	r2, r1, r1, lsl #1
 1010fb0:	4c0a      	ldr	r4, [pc, #40]	; (1010fdc <mayfly_enable+0x60>)
 1010fb2:	0112      	lsls	r2, r2, #4
 1010fb4:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 1010fb8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 1010fbc:	4423      	add	r3, r4
 1010fbe:	7a9c      	ldrb	r4, [r3, #10]
 1010fc0:	7ada      	ldrb	r2, [r3, #11]
 1010fc2:	42a2      	cmp	r2, r4
 1010fc4:	d001      	beq.n	1010fca <mayfly_enable+0x4e>
}
 1010fc6:	bc10      	pop	{r4}
 1010fc8:	4770      	bx	lr
			mft[callee_id][caller_id].disable_req++;
 1010fca:	3201      	adds	r2, #1
 1010fcc:	729a      	strb	r2, [r3, #10]
			mfp[callee_id] = 1U;
 1010fce:	2201      	movs	r2, #1
 1010fd0:	4b03      	ldr	r3, [pc, #12]	; (1010fe0 <mayfly_enable+0x64>)
 1010fd2:	545a      	strb	r2, [r3, r1]
}
 1010fd4:	bc10      	pop	{r4}
			mayfly_pend(caller_id, callee_id);
 1010fd6:	f00c bd3f 	b.w	101da58 <mayfly_pend>
 1010fda:	bf00      	nop
 1010fdc:	21004be0 	.word	0x21004be0
 1010fe0:	21004b5c 	.word	0x21004b5c

01010fe4 <mayfly_enqueue>:

uint32_t mayfly_enqueue(uint8_t caller_id, uint8_t callee_id, uint8_t chain,
			struct mayfly *m)
{
 1010fe4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1010fe6:	4606      	mov	r6, r0
 1010fe8:	461c      	mov	r4, r3
 1010fea:	460d      	mov	r5, r1
	uint8_t state;
	uint8_t ack;

	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
		!mayfly_is_enabled(caller_id, callee_id) ||
 1010fec:	b302      	cbz	r2, 1011030 <mayfly_enqueue+0x4c>

	/* shadow the ack */
	ack = m->_ack;

	/* already in queue */
	state = (m->_req - ack) & 0x03;
 1010fee:	7822      	ldrb	r2, [r4, #0]
	ack = m->_ack;
 1010ff0:	7863      	ldrb	r3, [r4, #1]
	state = (m->_req - ack) & 0x03;
 1010ff2:	1ad2      	subs	r2, r2, r3
	if (state != 0U) {
 1010ff4:	f012 0203 	ands.w	r2, r2, #3
 1010ff8:	d13b      	bne.n	1011072 <mayfly_enqueue+0x8e>
 1010ffa:	4f27      	ldr	r7, [pc, #156]	; (1011098 <mayfly_enqueue+0xb4>)
 1010ffc:	0071      	lsls	r1, r6, #1
 1010ffe:	ea4f 0c45 	mov.w	ip, r5, lsl #1
		return 0;
	}

	/* new, add as ready in the queue */
	m->_req = ack + 1;
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
 1011002:	4431      	add	r1, r6
 1011004:	44ac      	add	ip, r5
 1011006:	0089      	lsls	r1, r1, #2
 1011008:	eb01 110c 	add.w	r1, r1, ip, lsl #4
	m->_req = ack + 1;
 101100c:	3301      	adds	r3, #1
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
 101100e:	3104      	adds	r1, #4
	m->_req = ack + 1;
 1011010:	b2db      	uxtb	r3, r3
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
 1011012:	187a      	adds	r2, r7, r1
 1011014:	6860      	ldr	r0, [r4, #4]
 1011016:	4621      	mov	r1, r4
	m->_req = ack + 1;
 1011018:	7023      	strb	r3, [r4, #0]
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
 101101a:	f7ff ff6b 	bl	1010ef4 <memq_enqueue>

mayfly_enqueue_pend:
	/* set mayfly callee pending */
	mfp[callee_id] = 1U;
 101101e:	2201      	movs	r2, #1
 1011020:	4b1e      	ldr	r3, [pc, #120]	; (101109c <mayfly_enqueue+0xb8>)

	/* pend the callee for execution */
	mayfly_pend(caller_id, callee_id);
 1011022:	4629      	mov	r1, r5
 1011024:	4630      	mov	r0, r6
	mfp[callee_id] = 1U;
 1011026:	555a      	strb	r2, [r3, r5]
	mayfly_pend(caller_id, callee_id);
 1011028:	f00c fd16 	bl	101da58 <mayfly_pend>
		return 0;
 101102c:	2000      	movs	r0, #0

	return 0;
}
 101102e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
 1011030:	f00c fcfc 	bl	101da2c <mayfly_prio_is_equal>
 1011034:	2800      	cmp	r0, #0
 1011036:	d0da      	beq.n	1010fee <mayfly_enqueue+0xa>
		!mayfly_is_enabled(caller_id, callee_id) ||
 1011038:	4629      	mov	r1, r5
 101103a:	4630      	mov	r0, r6
 101103c:	f00c fcd6 	bl	101d9ec <mayfly_is_enabled>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
 1011040:	2800      	cmp	r0, #0
 1011042:	d0d4      	beq.n	1010fee <mayfly_enqueue+0xa>
		(mft[callee_id][caller_id].disable_req !=
 1011044:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 1011048:	eb06 0146 	add.w	r1, r6, r6, lsl #1
 101104c:	4f12      	ldr	r7, [pc, #72]	; (1011098 <mayfly_enqueue+0xb4>)
 101104e:	0112      	lsls	r2, r2, #4
 1011050:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 1011054:	443a      	add	r2, r7
		!mayfly_is_enabled(caller_id, callee_id) ||
 1011056:	7a90      	ldrb	r0, [r2, #10]
 1011058:	7ad2      	ldrb	r2, [r2, #11]
	ack = m->_ack;
 101105a:	7863      	ldrb	r3, [r4, #1]
		!mayfly_is_enabled(caller_id, callee_id) ||
 101105c:	4290      	cmp	r0, r2
		(mft[callee_id][caller_id].disable_req !=
 101105e:	ea4f 0146 	mov.w	r1, r6, lsl #1
 1011062:	ea4f 0c45 	mov.w	ip, r5, lsl #1
		!mayfly_is_enabled(caller_id, callee_id) ||
 1011066:	d00c      	beq.n	1011082 <mayfly_enqueue+0x9e>
	state = (m->_req - ack) & 0x03;
 1011068:	7820      	ldrb	r0, [r4, #0]
 101106a:	1ac0      	subs	r0, r0, r3
	if (state != 0U) {
 101106c:	f010 0203 	ands.w	r2, r0, #3
 1011070:	d0c7      	beq.n	1011002 <mayfly_enqueue+0x1e>
			if (state != 1U) {
 1011072:	2a01      	cmp	r2, #1
 1011074:	d003      	beq.n	101107e <mayfly_enqueue+0x9a>
				m->_req = ack + 1;
 1011076:	3301      	adds	r3, #1
 1011078:	b2db      	uxtb	r3, r3
 101107a:	7023      	strb	r3, [r4, #0]
				goto mayfly_enqueue_pend;
 101107c:	e7cf      	b.n	101101e <mayfly_enqueue+0x3a>
			return 1;
 101107e:	4610      	mov	r0, r2
}
 1011080:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	state = (m->_req - ack) & 0x03;
 1011082:	7822      	ldrb	r2, [r4, #0]
 1011084:	1ad2      	subs	r2, r2, r3
	if (state != 0U) {
 1011086:	0792      	lsls	r2, r2, #30
 1011088:	d002      	beq.n	1011090 <mayfly_enqueue+0xac>
		m->_req = ack + 2;
 101108a:	3302      	adds	r3, #2
 101108c:	b2db      	uxtb	r3, r3
 101108e:	7023      	strb	r3, [r4, #0]
		m->fp(m->param);
 1011090:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
 1011094:	4798      	blx	r3
		return 0;
 1011096:	e7c9      	b.n	101102c <mayfly_enqueue+0x48>
 1011098:	21004be0 	.word	0x21004be0
 101109c:	21004b5c 	.word	0x21004b5c

010110a0 <mayfly_run>:
		}
	}
}

void mayfly_run(uint8_t callee_id)
{
 10110a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t disable = 0U;
	uint8_t enable = 0U;
	uint8_t caller_id;

	if (!mfp[callee_id]) {
 10110a4:	f8df 913c 	ldr.w	r9, [pc, #316]	; 10111e4 <mayfly_run+0x144>
{
 10110a8:	b089      	sub	sp, #36	; 0x24
	if (!mfp[callee_id]) {
 10110aa:	f819 3000 	ldrb.w	r3, [r9, r0]
 10110ae:	2b00      	cmp	r3, #0
 10110b0:	d05e      	beq.n	1011170 <mayfly_run+0xd0>
	}
	mfp[callee_id] = 0U;

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
	while (caller_id--) {
 10110b2:	2403      	movs	r4, #3
	mfp[callee_id] = 0U;
 10110b4:	2700      	movs	r7, #0
	uint8_t disable = 0U;
 10110b6:	4625      	mov	r5, r4
 10110b8:	f8df a12c 	ldr.w	sl, [pc, #300]	; 10111e8 <mayfly_run+0x148>
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
 10110bc:	ebc0 1300 	rsb	r3, r0, r0, lsl #4
 10110c0:	eb00 0b40 	add.w	fp, r0, r0, lsl #1
 10110c4:	009b      	lsls	r3, r3, #2
 10110c6:	eb0a 1b0b 	add.w	fp, sl, fp, lsl #4
 10110ca:	9302      	str	r3, [sp, #8]
	mfp[callee_id] = 0U;
 10110cc:	f809 7000 	strb.w	r7, [r9, r0]
	uint8_t disable = 0U;
 10110d0:	9704      	str	r7, [sp, #16]
 10110d2:	9705      	str	r7, [sp, #20]
 10110d4:	9003      	str	r0, [sp, #12]
		memq_link_t *link;
		struct mayfly *m = 0;

		/* fetch mayfly in callee queue, if any */
		link = memq_peek(mft[callee_id][caller_id].head,
 10110d6:	465c      	mov	r4, fp
		struct mayfly *m = 0;
 10110d8:	2300      	movs	r3, #0
		link = memq_peek(mft[callee_id][caller_id].head,
 10110da:	f8db 1028 	ldr.w	r1, [fp, #40]	; 0x28
 10110de:	f854 0f24 	ldr.w	r0, [r4, #36]!
 10110e2:	aa07      	add	r2, sp, #28
		struct mayfly *m = 0;
 10110e4:	9307      	str	r3, [sp, #28]
		link = memq_peek(mft[callee_id][caller_id].head,
 10110e6:	f7ff ff0f 	bl	1010f08 <memq_peek>
 10110ea:	4607      	mov	r7, r0
				 mft[callee_id][caller_id].tail,
				 (void **)&m);
		while (link) {
 10110ec:	9501      	str	r5, [sp, #4]
 10110ee:	2f00      	cmp	r7, #0
 10110f0:	d04a      	beq.n	1011188 <mayfly_run+0xe8>
#if defined(MAYFLY_UT)
			_state = 0U;
#endif /* MAYFLY_UT */

			/* execute work if ready */
			state = (m->_req - m->_ack) & 0x03;
 10110f2:	9d07      	ldr	r5, [sp, #28]
 10110f4:	786a      	ldrb	r2, [r5, #1]
 10110f6:	782e      	ldrb	r6, [r5, #0]
 10110f8:	1ab6      	subs	r6, r6, r2
 10110fa:	f006 0603 	and.w	r6, r6, #3
			if (state == 1U) {
 10110fe:	2e01      	cmp	r6, #1
 1011100:	d107      	bne.n	1011112 <mayfly_run+0x72>
#if defined(MAYFLY_UT)
				_state = 1U;
#endif /* MAYFLY_UT */

				/* mark mayfly as ran */
				m->_ack--;
 1011102:	3a01      	subs	r2, #1
 1011104:	706a      	strb	r2, [r5, #1]

				/* call the mayfly function */
				m->fp(m->param);
 1011106:	9b07      	ldr	r3, [sp, #28]
 1011108:	e9d3 0302 	ldrd	r0, r3, [r3, #8]
 101110c:	4798      	blx	r3
			}

			/* dequeue if not re-pended */
			dequeue(callee_id, caller_id, link, m);
 101110e:	9d07      	ldr	r5, [sp, #28]
	if (((req - m->_ack) & 0x03) != 1U) {
 1011110:	786a      	ldrb	r2, [r5, #1]
	req = m->_req;
 1011112:	782b      	ldrb	r3, [r5, #0]
		memq_dequeue(mft[callee_id][caller_id].tail,
 1011114:	f8db 0028 	ldr.w	r0, [fp, #40]	; 0x28
	if (((req - m->_ack) & 0x03) != 1U) {
 1011118:	1a9a      	subs	r2, r3, r2
 101111a:	f002 0203 	and.w	r2, r2, #3
 101111e:	2a01      	cmp	r2, #1
	req = m->_req;
 1011120:	fa5f f883 	uxtb.w	r8, r3
	if (((req - m->_ack) & 0x03) != 1U) {
 1011124:	d00f      	beq.n	1011146 <mayfly_run+0xa6>
		memq_dequeue(mft[callee_id][caller_id].tail,
 1011126:	2200      	movs	r2, #0
 1011128:	4621      	mov	r1, r4
 101112a:	f7ff fef5 	bl	1010f18 <memq_dequeue>
		ack = m->_ack;
 101112e:	7869      	ldrb	r1, [r5, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
 1011130:	782a      	ldrb	r2, [r5, #0]
		m->_link = link;
 1011132:	606f      	str	r7, [r5, #4]
		if (((m->_req - ack) & 0x03) == 1U) {
 1011134:	1a52      	subs	r2, r2, r1
 1011136:	f002 0203 	and.w	r2, r2, #3
 101113a:	2a01      	cmp	r2, #1
		m->_ack = req;
 101113c:	f885 8001 	strb.w	r8, [r5, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
 1011140:	d019      	beq.n	1011176 <mayfly_run+0xd6>
 1011142:	f8db 0028 	ldr.w	r0, [fp, #40]	; 0x28

			/* fetch next mayfly in callee queue, if any */
			link = memq_peek(mft[callee_id][caller_id].head,
 1011146:	4601      	mov	r1, r0
 1011148:	aa07      	add	r2, sp, #28
 101114a:	f8db 0024 	ldr.w	r0, [fp, #36]	; 0x24
 101114e:	f7ff fedb 	bl	1010f08 <memq_peek>
 */
#if defined(CONFIG_BT_MAYFLY_YIELD_AFTER_CALL)
			/* yield out of mayfly_run if a mayfly function was
			 * called.
			 */
			if (state == 1U) {
 1011152:	2e01      	cmp	r6, #1
			link = memq_peek(mft[callee_id][caller_id].head,
 1011154:	4607      	mov	r7, r0
			if (state == 1U) {
 1011156:	d1ca      	bne.n	10110ee <mayfly_run+0x4e>
				/* pend callee (tailchain) if mayfly queue is
				 * not empty or all caller queues are not
				 * processed.
				 */
				if (caller_id || link) {
 1011158:	9d01      	ldr	r5, [sp, #4]
 101115a:	2d00      	cmp	r5, #0
 101115c:	d03f      	beq.n	10111de <mayfly_run+0x13e>
					/* set mayfly callee pending */
					mfp[callee_id] = 1U;
 101115e:	2301      	movs	r3, #1
 1011160:	f8dd 800c 	ldr.w	r8, [sp, #12]

					/* pend the callee for execution */
					mayfly_pend(callee_id, callee_id);
 1011164:	4641      	mov	r1, r8
 1011166:	4640      	mov	r0, r8
					mfp[callee_id] = 1U;
 1011168:	f809 3008 	strb.w	r3, [r9, r8]
					mayfly_pend(callee_id, callee_id);
 101116c:	f00c fc74 	bl	101da58 <mayfly_pend>
	}

	if (disable && !enable) {
		mayfly_enable_cb(callee_id, callee_id, 0);
	}
}
 1011170:	b009      	add	sp, #36	; 0x24
 1011172:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
 1011176:	9b02      	ldr	r3, [sp, #8]
			m->_ack = ack;
 1011178:	7069      	strb	r1, [r5, #1]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
 101117a:	1d1a      	adds	r2, r3, #4
 101117c:	4629      	mov	r1, r5
 101117e:	4638      	mov	r0, r7
 1011180:	4452      	add	r2, sl
 1011182:	f7ff feb7 	bl	1010ef4 <memq_enqueue>
 1011186:	e7dc      	b.n	1011142 <mayfly_run+0xa2>
 1011188:	9d01      	ldr	r5, [sp, #4]
		if (mft[callee_id][caller_id].disable_req !=
 101118a:	f89b 302e 	ldrb.w	r3, [fp, #46]	; 0x2e
 101118e:	f89b 202f 	ldrb.w	r2, [fp, #47]	; 0x2f
 1011192:	429a      	cmp	r2, r3
 1011194:	d003      	beq.n	101119e <mayfly_run+0xfe>
			mft[callee_id][caller_id].disable_ack =
 1011196:	f88b 302f 	strb.w	r3, [fp, #47]	; 0x2f
			disable = 1U;
 101119a:	2301      	movs	r3, #1
 101119c:	9304      	str	r3, [sp, #16]
		if (mft[callee_id][caller_id].enable_req !=
 101119e:	f89b 302c 	ldrb.w	r3, [fp, #44]	; 0x2c
 10111a2:	f89b 202d 	ldrb.w	r2, [fp, #45]	; 0x2d
 10111a6:	429a      	cmp	r2, r3
 10111a8:	d003      	beq.n	10111b2 <mayfly_run+0x112>
			mft[callee_id][caller_id].enable_ack =
 10111aa:	f88b 302d 	strb.w	r3, [fp, #45]	; 0x2d
			enable = 1U;
 10111ae:	2301      	movs	r3, #1
 10111b0:	9305      	str	r3, [sp, #20]
	while (caller_id--) {
 10111b2:	3d01      	subs	r5, #1
 10111b4:	b2ed      	uxtb	r5, r5
 10111b6:	2dff      	cmp	r5, #255	; 0xff
 10111b8:	f1ab 0b0c 	sub.w	fp, fp, #12
 10111bc:	d18b      	bne.n	10110d6 <mayfly_run+0x36>
	if (disable && !enable) {
 10111be:	e9dd 5704 	ldrd	r5, r7, [sp, #16]
 10111c2:	f8dd 800c 	ldr.w	r8, [sp, #12]
 10111c6:	2d00      	cmp	r5, #0
 10111c8:	d0d2      	beq.n	1011170 <mayfly_run+0xd0>
 10111ca:	2f00      	cmp	r7, #0
 10111cc:	d1d0      	bne.n	1011170 <mayfly_run+0xd0>
		mayfly_enable_cb(callee_id, callee_id, 0);
 10111ce:	463a      	mov	r2, r7
 10111d0:	4641      	mov	r1, r8
 10111d2:	4640      	mov	r0, r8
}
 10111d4:	b009      	add	sp, #36	; 0x24
 10111d6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		mayfly_enable_cb(callee_id, callee_id, 0);
 10111da:	f00c bbe9 	b.w	101d9b0 <mayfly_enable_cb>
				if (caller_id || link) {
 10111de:	2800      	cmp	r0, #0
 10111e0:	d0d3      	beq.n	101118a <mayfly_run+0xea>
 10111e2:	e7bc      	b.n	101115e <mayfly_run+0xbe>
 10111e4:	21004b5c 	.word	0x21004b5c
 10111e8:	21004be0 	.word	0x21004be0

010111ec <util_ones_count_get>:
 */
uint8_t util_ones_count_get(const uint8_t *octets, uint8_t octets_len)
{
	uint8_t one_count = 0U;

	while (octets_len--) {
 10111ec:	1e4b      	subs	r3, r1, #1
{
 10111ee:	4684      	mov	ip, r0
	while (octets_len--) {
 10111f0:	b2db      	uxtb	r3, r3
 10111f2:	b171      	cbz	r1, 1011212 <util_ones_count_get+0x26>
	uint8_t one_count = 0U;
 10111f4:	2000      	movs	r0, #0
 10111f6:	f10c 31ff 	add.w	r1, ip, #4294967295
 10111fa:	449c      	add	ip, r3
		uint8_t bite;

		bite = *octets;
 10111fc:	f811 3f01 	ldrb.w	r3, [r1, #1]!
		while (bite) {
 1011200:	b123      	cbz	r3, 101120c <util_ones_count_get+0x20>
			bite &= (bite - 1);
 1011202:	1e5a      	subs	r2, r3, #1
			one_count++;
 1011204:	3001      	adds	r0, #1
		while (bite) {
 1011206:	4013      	ands	r3, r2
			one_count++;
 1011208:	b2c0      	uxtb	r0, r0
		while (bite) {
 101120a:	d1fa      	bne.n	1011202 <util_ones_count_get+0x16>
	while (octets_len--) {
 101120c:	4561      	cmp	r1, ip
 101120e:	d1f5      	bne.n	10111fc <util_ones_count_get+0x10>
 1011210:	4770      	bx	lr
	uint8_t one_count = 0U;
 1011212:	4608      	mov	r0, r1
		}
		octets++;
	}

	return one_count;
}
 1011214:	4770      	bx	lr
 1011216:	bf00      	nop

01011218 <ticker_dequeue>:
 * @return Total ticks until expiration for dequeued ticker node, or 0 if
 * node was not found
 * @internal
 */
static uint32_t ticker_dequeue(struct ticker_instance *instance, uint8_t id)
{
 1011218:	b530      	push	{r4, r5, lr}

	/* Find the ticker's position in ticker node list while accumulating
	 * ticks_to_expire
	 */
	node = &instance->nodes[0];
	previous = instance->ticker_id_head;
 101121a:	7e03      	ldrb	r3, [r0, #24]
	node = &instance->nodes[0];
 101121c:	6805      	ldr	r5, [r0, #0]
	current = previous;
	total = 0U;
	ticker_current = 0;
	while (current != TICKER_NULL) {
 101121e:	2bff      	cmp	r3, #255	; 0xff
 1011220:	d014      	beq.n	101124c <ticker_dequeue+0x34>
		ticker_current = &node[current];
 1011222:	eb03 0243 	add.w	r2, r3, r3, lsl #1

		if (current == id) {
 1011226:	428b      	cmp	r3, r1
		ticker_current = &node[current];
 1011228:	eb05 1202 	add.w	r2, r5, r2, lsl #4
		if (current == id) {
 101122c:	d025      	beq.n	101127a <ticker_dequeue+0x62>
	total = 0U;
 101122e:	f04f 0c00 	mov.w	ip, #0
 1011232:	e001      	b.n	1011238 <ticker_dequeue+0x20>
		if (current == id) {
 1011234:	4299      	cmp	r1, r3
 1011236:	d00b      	beq.n	1011250 <ticker_dequeue+0x38>
			break;
		}

		total += ticker_current->ticks_to_expire;
 1011238:	469e      	mov	lr, r3
		previous = current;
		current = ticker_current->next;
 101123a:	7813      	ldrb	r3, [r2, #0]
		total += ticker_current->ticks_to_expire;
 101123c:	6894      	ldr	r4, [r2, #8]
	while (current != TICKER_NULL) {
 101123e:	2bff      	cmp	r3, #255	; 0xff
		ticker_current = &node[current];
 1011240:	eb03 0243 	add.w	r2, r3, r3, lsl #1
		total += ticker_current->ticks_to_expire;
 1011244:	44a4      	add	ip, r4
		ticker_current = &node[current];
 1011246:	eb05 1202 	add.w	r2, r5, r2, lsl #4
	while (current != TICKER_NULL) {
 101124a:	d1f3      	bne.n	1011234 <ticker_dequeue+0x1c>
	}

	if (current == TICKER_NULL) {
		/* Ticker not in active list */
		return 0;
 101124c:	2000      	movs	r0, #0
	if (ticker_current->next != TICKER_NULL) {
		node[ticker_current->next].ticks_to_expire += timeout;
	}

	return (total + timeout);
}
 101124e:	bd30      	pop	{r4, r5, pc}
	if (previous == current) {
 1011250:	4571      	cmp	r1, lr
 1011252:	d015      	beq.n	1011280 <ticker_dequeue+0x68>
	node[previous].next = ticker_current->next;
 1011254:	7813      	ldrb	r3, [r2, #0]
 1011256:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
 101125a:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
	if (ticker_current->next != TICKER_NULL) {
 101125e:	2bff      	cmp	r3, #255	; 0xff
	timeout = ticker_current->ticks_to_expire;
 1011260:	6890      	ldr	r0, [r2, #8]
	node[previous].next = ticker_current->next;
 1011262:	f805 300e 	strb.w	r3, [r5, lr]
	if (ticker_current->next != TICKER_NULL) {
 1011266:	d006      	beq.n	1011276 <ticker_dequeue+0x5e>
		node[ticker_current->next].ticks_to_expire += timeout;
 1011268:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 101126c:	eb05 1303 	add.w	r3, r5, r3, lsl #4
 1011270:	689a      	ldr	r2, [r3, #8]
 1011272:	4402      	add	r2, r0
 1011274:	609a      	str	r2, [r3, #8]
	return (total + timeout);
 1011276:	4460      	add	r0, ip
}
 1011278:	bd30      	pop	{r4, r5, pc}
	previous = instance->ticker_id_head;
 101127a:	469e      	mov	lr, r3
	total = 0U;
 101127c:	f04f 0c00 	mov.w	ip, #0
		instance->ticker_id_head = ticker_current->next;
 1011280:	7813      	ldrb	r3, [r2, #0]
 1011282:	7603      	strb	r3, [r0, #24]
 1011284:	e7e6      	b.n	1011254 <ticker_dequeue+0x3c>
 1011286:	bf00      	nop

01011288 <ticks_to_expire_prep>:
{
	uint32_t ticks_to_expire = ticker->ticks_to_expire;
	uint32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;

	/* Calculate ticks to expire for this new node */
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 1011288:	eba2 0c01 	sub.w	ip, r2, r1
 101128c:	f41c 0f00 	tst.w	ip, #8388608	; 0x800000
{
 1011290:	b410      	push	{r4}
	uint32_t ticks_to_expire = ticker->ticks_to_expire;
 1011292:	6883      	ldr	r3, [r0, #8]
	uint32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;
 1011294:	6944      	ldr	r4, [r0, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 1011296:	d10a      	bne.n	10112ae <ticks_to_expire_prep+0x26>
 * @param ticks_now Highest tick count (now)
 * @param ticks_old Tick count to subtract from ticks_now
 */
uint32_t ticker_ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
{
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1011298:	f02c 4c7f 	bic.w	ip, ip, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
 101129c:	4463      	add	r3, ip
	if (ticks_to_expire > ticks_to_expire_minus) {
 101129e:	42a3      	cmp	r3, r4
 10112a0:	d80d      	bhi.n	10112be <ticks_to_expire_prep+0x36>
		ticks_to_expire_minus -= ticks_to_expire;
 10112a2:	1ae2      	subs	r2, r4, r3
		ticks_to_expire = 0U;
 10112a4:	2300      	movs	r3, #0
}
 10112a6:	bc10      	pop	{r4}
	ticker->ticks_to_expire = ticks_to_expire;
 10112a8:	6083      	str	r3, [r0, #8]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
 10112aa:	6142      	str	r2, [r0, #20]
}
 10112ac:	4770      	bx	lr
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10112ae:	1a89      	subs	r1, r1, r2
 10112b0:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
 10112b4:	428b      	cmp	r3, r1
 10112b6:	d908      	bls.n	10112ca <ticks_to_expire_prep+0x42>
			ticks_to_expire -= delta_current_start;
 10112b8:	1a5b      	subs	r3, r3, r1
	if (ticks_to_expire > ticks_to_expire_minus) {
 10112ba:	42a3      	cmp	r3, r4
 10112bc:	d9f1      	bls.n	10112a2 <ticks_to_expire_prep+0x1a>
		ticks_to_expire_minus = 0U;
 10112be:	2200      	movs	r2, #0
		ticks_to_expire -= ticks_to_expire_minus;
 10112c0:	1b1b      	subs	r3, r3, r4
	ticker->ticks_to_expire = ticks_to_expire;
 10112c2:	6083      	str	r3, [r0, #8]
}
 10112c4:	bc10      	pop	{r4}
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
 10112c6:	6142      	str	r2, [r0, #20]
}
 10112c8:	4770      	bx	lr
			ticks_to_expire_minus +=
 10112ca:	440c      	add	r4, r1
 10112cc:	1ae2      	subs	r2, r4, r3
	if (ticks_to_expire > ticks_to_expire_minus) {
 10112ce:	e7e9      	b.n	10112a4 <ticks_to_expire_prep+0x1c>

010112d0 <ticker_job_list_insert>:
{
 10112d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10112d4:	4607      	mov	r7, r0
 10112d6:	460b      	mov	r3, r1
	count_user = instance->count_user;
 10112d8:	7a41      	ldrb	r1, [r0, #9]
	users = &instance->users[0];
 10112da:	687d      	ldr	r5, [r7, #4]
	node = &instance->nodes[0];
 10112dc:	6800      	ldr	r0, [r0, #0]
{
 10112de:	b087      	sub	sp, #28
	while (count_user--) {
 10112e0:	2900      	cmp	r1, #0
 10112e2:	f000 80f3 	beq.w	10114cc <ticker_job_list_insert+0x1fc>
 10112e6:	46bb      	mov	fp, r7
 10112e8:	461f      	mov	r7, r3
 10112ea:	4603      	mov	r3, r0
 10112ec:	1e4a      	subs	r2, r1, #1
 10112ee:	b2d2      	uxtb	r2, r2
 10112f0:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
 10112f4:	9202      	str	r2, [sp, #8]
 10112f6:	9505      	str	r5, [sp, #20]
		user_ops = (void *)&user->user_op[0];
 10112f8:	469a      	mov	sl, r3
 10112fa:	9a02      	ldr	r2, [sp, #8]
 10112fc:	6851      	ldr	r1, [r2, #4]
		user_ops_first = user->first;
 10112fe:	f892 8001 	ldrb.w	r8, [r2, #1]
		user_ops = (void *)&user->user_op[0];
 1011302:	9104      	str	r1, [sp, #16]
		while ((insert_head != TICKER_NULL) ||
 1011304:	f8cd 800c 	str.w	r8, [sp, #12]
 1011308:	2fff      	cmp	r7, #255	; 0xff
 101130a:	d05f      	beq.n	10113cc <ticker_job_list_insert+0xfc>
				user_op = NULL;
 101130c:	2500      	movs	r5, #0
				ticker = &node[id_insert];
 101130e:	eb07 0447 	add.w	r4, r7, r7, lsl #1
 1011312:	0126      	lsls	r6, r4, #4
 1011314:	463b      	mov	r3, r7
				insert_head = ticker->next;
 1011316:	f81a 7006 	ldrb.w	r7, [sl, r6]
				ticker = &node[id_insert];
 101131a:	eb0a 1404 	add.w	r4, sl, r4, lsl #4
	ticker->next = TICKER_NULL;
 101131e:	f04f 0eff 	mov.w	lr, #255	; 0xff
 1011322:	f884 e000 	strb.w	lr, [r4]
	node = &instance->nodes[0];
 1011326:	f8db c000 	ldr.w	ip, [fp]
	current = instance->ticker_id_head;
 101132a:	f89b 2018 	ldrb.w	r2, [fp, #24]
	ticker_new = &node[id];
 101132e:	eb0c 0906 	add.w	r9, ip, r6
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1011332:	4572      	cmp	r2, lr
	ticks_to_expire = ticker_new->ticks_to_expire;
 1011334:	f8d9 1008 	ldr.w	r1, [r9, #8]
	previous = TICKER_NULL;
 1011338:	bf18      	it	ne
 101133a:	9501      	strne	r5, [sp, #4]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 101133c:	d10d      	bne.n	101135a <ticker_job_list_insert+0x8a>
 101133e:	e0c0      	b.n	10114c2 <ticker_job_list_insert+0x1f2>
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
 1011340:	1a09      	subs	r1, r1, r0
 1011342:	d104      	bne.n	101134e <ticker_job_list_insert+0x7e>
 1011344:	f8b9 801e 	ldrh.w	r8, [r9, #30]
 1011348:	8bf6      	ldrh	r6, [r6, #30]
 101134a:	45b0      	cmp	r8, r6
 101134c:	d87f      	bhi.n	101144e <ticker_job_list_insert+0x17e>
		current = ticker_current->next;
 101134e:	f81c 0005 	ldrb.w	r0, [ip, r5]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1011352:	4696      	mov	lr, r2
 1011354:	28ff      	cmp	r0, #255	; 0xff
 1011356:	d077      	beq.n	1011448 <ticker_job_list_insert+0x178>
		current = ticker_current->next;
 1011358:	4602      	mov	r2, r0
		(ticker_current = &node[current])->ticks_to_expire))) {
 101135a:	eb02 0542 	add.w	r5, r2, r2, lsl #1
 101135e:	eb0c 1605 	add.w	r6, ip, r5, lsl #4
		(ticks_to_expire_current =
 1011362:	68b0      	ldr	r0, [r6, #8]
		(ticker_current = &node[current])->ticks_to_expire))) {
 1011364:	012d      	lsls	r5, r5, #4
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1011366:	4288      	cmp	r0, r1
 1011368:	d9ea      	bls.n	1011340 <ticker_job_list_insert+0x70>
 101136a:	9d01      	ldr	r5, [sp, #4]
	if (previous == TICKER_NULL) {
 101136c:	f1be 0fff 	cmp.w	lr, #255	; 0xff
		node[previous].next = id;
 1011370:	bf1c      	itt	ne
 1011372:	eb0e 0e4e 	addne.w	lr, lr, lr, lsl #1
 1011376:	ea4f 1e0e 	movne.w	lr, lr, lsl #4
	ticker_new->ticks_to_expire = ticks_to_expire;
 101137a:	f8c9 1008 	str.w	r1, [r9, #8]
	ticker_new->next = current;
 101137e:	f889 2000 	strb.w	r2, [r9]
		instance->ticker_id_head = id;
 1011382:	bf0c      	ite	eq
 1011384:	f88b 3018 	strbeq.w	r3, [fp, #24]
		node[previous].next = id;
 1011388:	f80c 300e 	strbne.w	r3, [ip, lr]
	if (current != TICKER_NULL) {
 101138c:	2aff      	cmp	r2, #255	; 0xff
 101138e:	d008      	beq.n	10113a2 <ticker_job_list_insert+0xd2>
		node[current].ticks_to_expire -= ticks_to_expire;
 1011390:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 1011394:	eb0c 1c02 	add.w	ip, ip, r2, lsl #4
 1011398:	f8dc 3008 	ldr.w	r3, [ip, #8]
 101139c:	1a5b      	subs	r3, r3, r1
 101139e:	f8cc 3008 	str.w	r3, [ip, #8]
	ticker->req = ticker->ack + 1;
 10113a2:	78a3      	ldrb	r3, [r4, #2]
 10113a4:	3301      	adds	r3, #1
 10113a6:	7063      	strb	r3, [r4, #1]
			if (user_op) {
 10113a8:	2d00      	cmp	r5, #0
 10113aa:	d0ad      	beq.n	1011308 <ticker_job_list_insert+0x38>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 10113ac:	2000      	movs	r0, #0
	if (user_op->fp_op_func) {
 10113ae:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 10113b0:	7028      	strb	r0, [r5, #0]
	user_op->status = status;
 10113b2:	62a8      	str	r0, [r5, #40]	; 0x28
	if (user_op->fp_op_func) {
 10113b4:	b10b      	cbz	r3, 10113ba <ticker_job_list_insert+0xea>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 10113b6:	6b29      	ldr	r1, [r5, #48]	; 0x30
 10113b8:	4798      	blx	r3
				if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
 10113ba:	6863      	ldr	r3, [r4, #4]
 10113bc:	2b00      	cmp	r3, #0
 10113be:	d1a3      	bne.n	1011308 <ticker_job_list_insert+0x38>
						user_op->fp_op_func;
 10113c0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
		while ((insert_head != TICKER_NULL) ||
 10113c2:	2fff      	cmp	r7, #255	; 0xff
					ticker->fp_op_func =
 10113c4:	6223      	str	r3, [r4, #32]
						user_op->op_context;
 10113c6:	6b2b      	ldr	r3, [r5, #48]	; 0x30
					ticker->op_context =
 10113c8:	6263      	str	r3, [r4, #36]	; 0x24
		while ((insert_head != TICKER_NULL) ||
 10113ca:	d19f      	bne.n	101130c <ticker_job_list_insert+0x3c>
 10113cc:	e9dd 8903 	ldrd	r8, r9, [sp, #12]
 10113d0:	9b02      	ldr	r3, [sp, #8]
 10113d2:	7899      	ldrb	r1, [r3, #2]
 10113d4:	4541      	cmp	r1, r8
				first = user_ops_first + 1;
 10113d6:	f108 0301 	add.w	r3, r8, #1
		while ((insert_head != TICKER_NULL) ||
 10113da:	d02a      	beq.n	1011432 <ticker_job_list_insert+0x162>
				user_op = &user_ops[user_ops_first];
 10113dc:	2234      	movs	r2, #52	; 0x34
 10113de:	fb02 f208 	mul.w	r2, r2, r8
				if (first == user->count_user_op) {
 10113e2:	9802      	ldr	r0, [sp, #8]
				first = user_ops_first + 1;
 10113e4:	fa5f f883 	uxtb.w	r8, r3
				if (first == user->count_user_op) {
 10113e8:	7800      	ldrb	r0, [r0, #0]
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 10113ea:	f819 3002 	ldrb.w	r3, [r9, r2]
					first = 0U;
 10113ee:	4540      	cmp	r0, r8
 10113f0:	bf08      	it	eq
 10113f2:	f04f 0800 	moveq.w	r8, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 10113f6:	2b04      	cmp	r3, #4
				user_op = &user_ops[user_ops_first];
 10113f8:	eb09 0502 	add.w	r5, r9, r2
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 10113fc:	d1ea      	bne.n	10113d4 <ticker_job_list_insert+0x104>
				id_insert = user_op->id;
 10113fe:	786b      	ldrb	r3, [r5, #1]
				ticker = &node[id_insert];
 1011400:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 1011404:	eb0a 1401 	add.w	r4, sl, r1, lsl #4
				if (((ticker->req -
 1011408:	f894 c001 	ldrb.w	ip, [r4, #1]
 101140c:	78a0      	ldrb	r0, [r4, #2]
				ticker = &node[id_insert];
 101140e:	010e      	lsls	r6, r1, #4
				if (((ticker->req -
 1011410:	4584      	cmp	ip, r0
 1011412:	d01f      	beq.n	1011454 <ticker_job_list_insert+0x184>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 1011414:	2300      	movs	r3, #0
	user_op->status = status;
 1011416:	2001      	movs	r0, #1
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 1011418:	f809 3002 	strb.w	r3, [r9, r2]
	if (user_op->fp_op_func) {
 101141c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
	user_op->status = status;
 101141e:	62a8      	str	r0, [r5, #40]	; 0x28
	if (user_op->fp_op_func) {
 1011420:	b10b      	cbz	r3, 1011426 <ticker_job_list_insert+0x156>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 1011422:	6b29      	ldr	r1, [r5, #48]	; 0x30
 1011424:	4798      	blx	r3
 1011426:	9b02      	ldr	r3, [sp, #8]
 1011428:	7899      	ldrb	r1, [r3, #2]
				first = user_ops_first + 1;
 101142a:	f108 0301 	add.w	r3, r8, #1
		while ((insert_head != TICKER_NULL) ||
 101142e:	4541      	cmp	r1, r8
 1011430:	d1d4      	bne.n	10113dc <ticker_job_list_insert+0x10c>
		user->first = user_ops_first;
 1011432:	9a02      	ldr	r2, [sp, #8]
	while (count_user--) {
 1011434:	9805      	ldr	r0, [sp, #20]
		user->first = user_ops_first;
 1011436:	7051      	strb	r1, [r2, #1]
	while (count_user--) {
 1011438:	4611      	mov	r1, r2
 101143a:	4288      	cmp	r0, r1
		user->first = user_ops_first;
 101143c:	4653      	mov	r3, sl
	while (count_user--) {
 101143e:	f1a2 0208 	sub.w	r2, r2, #8
 1011442:	d043      	beq.n	10114cc <ticker_job_list_insert+0x1fc>
 1011444:	9202      	str	r2, [sp, #8]
 1011446:	e757      	b.n	10112f8 <ticker_job_list_insert+0x28>
 1011448:	4602      	mov	r2, r0
 101144a:	9d01      	ldr	r5, [sp, #4]
 101144c:	e78e      	b.n	101136c <ticker_job_list_insert+0x9c>
		(ticks_to_expire_current =
 101144e:	4601      	mov	r1, r0
 1011450:	9d01      	ldr	r5, [sp, #4]
 1011452:	e78b      	b.n	101136c <ticker_job_list_insert+0x9c>
	if (start->lazy != TICKER_LAZY_MUST_EXPIRE_KEEP) {
 1011454:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 1011458:	8aaa      	ldrh	r2, [r5, #20]
				ticker_job_op_start(ticker, user_op,
 101145a:	f8db 1014 	ldr.w	r1, [fp, #20]
	if (start->lazy != TICKER_LAZY_MUST_EXPIRE_KEEP) {
 101145e:	4282      	cmp	r2, r0
 1011460:	f8cd 800c 	str.w	r8, [sp, #12]
 1011464:	d007      	beq.n	1011476 <ticker_job_list_insert+0x1a6>
		ticker->must_expire =
 1011466:	f64f 70ff 	movw	r0, #65535	; 0xffff
 101146a:	1a12      	subs	r2, r2, r0
 101146c:	fab2 f282 	clz	r2, r2
 1011470:	0952      	lsrs	r2, r2, #5
 1011472:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
 1011476:	9301      	str	r3, [sp, #4]
	ticker->lazy_periodic =
 1011478:	f64f 73fd 	movw	r3, #65533	; 0xfffd
	ticker->ext_data = start->ext_data;
 101147c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
	ticker->ticks_to_expire_minus = 0U;
 101147e:	f04f 0900 	mov.w	r9, #0
	ticker->ext_data = start->ext_data;
 1011482:	62a2      	str	r2, [r4, #40]	; 0x28
	ticker->ticks_periodic = start->ticks_periodic;
 1011484:	68ea      	ldr	r2, [r5, #12]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
 1011486:	4620      	mov	r0, r4
	ticker->ticks_periodic = start->ticks_periodic;
 1011488:	6062      	str	r2, [r4, #4]
	ticker->remainder_periodic = start->remainder_periodic;
 101148a:	692a      	ldr	r2, [r5, #16]
 101148c:	6222      	str	r2, [r4, #32]
		(start->lazy < TICKER_LAZY_MUST_EXPIRE_KEEP) ? start->lazy :
 101148e:	8aaa      	ldrh	r2, [r5, #20]
	ticker->lazy_periodic =
 1011490:	429a      	cmp	r2, r3
 1011492:	bf88      	it	hi
 1011494:	2200      	movhi	r2, #0
 1011496:	83a2      	strh	r2, [r4, #28]
	ticker->ticks_slot = start->ticks_slot;
 1011498:	69aa      	ldr	r2, [r5, #24]
 101149a:	61a2      	str	r2, [r4, #24]
	ticker->timeout_func = start->fp_timeout_func;
 101149c:	69ea      	ldr	r2, [r5, #28]
 101149e:	60e2      	str	r2, [r4, #12]
	ticker->context = start->context;
 10114a0:	6a2a      	ldr	r2, [r5, #32]
 10114a2:	6122      	str	r2, [r4, #16]
	ticker->ticks_to_expire = start->ticks_first;
 10114a4:	68aa      	ldr	r2, [r5, #8]
	ticker->ticks_to_expire_minus = 0U;
 10114a6:	f8c4 9014 	str.w	r9, [r4, #20]
	ticker->ticks_to_expire = start->ticks_first;
 10114aa:	60a2      	str	r2, [r4, #8]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
 10114ac:	686a      	ldr	r2, [r5, #4]
 10114ae:	f7ff feeb 	bl	1011288 <ticks_to_expire_prep>
	ticker->force = 1U;
 10114b2:	2201      	movs	r2, #1
 10114b4:	9b01      	ldr	r3, [sp, #4]
	ticker->remainder_current = 0U;
 10114b6:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
	ticker->lazy_current = 0U;
 10114ba:	f8a4 901e 	strh.w	r9, [r4, #30]
	ticker->force = 1U;
 10114be:	70e2      	strb	r2, [r4, #3]
}
 10114c0:	e72d      	b.n	101131e <ticker_job_list_insert+0x4e>
	ticker_new->next = current;
 10114c2:	f80c 2006 	strb.w	r2, [ip, r6]
		instance->ticker_id_head = id;
 10114c6:	f88b 3018 	strb.w	r3, [fp, #24]
	if (current != TICKER_NULL) {
 10114ca:	e76a      	b.n	10113a2 <ticker_job_list_insert+0xd2>
}
 10114cc:	b007      	add	sp, #28
 10114ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 10114d2:	bf00      	nop

010114d4 <ticker_worker>:
	instance->worker_trigger = 1U;
 10114d4:	2301      	movs	r3, #1
{
 10114d6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (instance->job_guard) {
 10114da:	7e47      	ldrb	r7, [r0, #25]
{
 10114dc:	b089      	sub	sp, #36	; 0x24
	instance->worker_trigger = 1U;
 10114de:	7683      	strb	r3, [r0, #26]
	if (instance->job_guard) {
 10114e0:	2f00      	cmp	r7, #0
 10114e2:	f040 809a 	bne.w	101161a <ticker_worker+0x146>
	if (instance->ticker_id_head == TICKER_NULL) {
 10114e6:	7e03      	ldrb	r3, [r0, #24]
 10114e8:	4606      	mov	r6, r0
 10114ea:	2bff      	cmp	r3, #255	; 0xff
 10114ec:	f000 8094 	beq.w	1011618 <ticker_worker+0x144>
	ticks_elapsed = ticker_ticks_diff_get(cntr_cnt_get(),
 10114f0:	f00b fdb4 	bl	101d05c <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10114f4:	6972      	ldr	r2, [r6, #20]
	if (instance->ticks_slot_previous > ticks_elapsed) {
 10114f6:	69f3      	ldr	r3, [r6, #28]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10114f8:	1a80      	subs	r0, r0, r2
 10114fa:	f020 4a7f 	bic.w	sl, r0, #4278190080	; 0xff000000
	if (instance->ticks_slot_previous > ticks_elapsed) {
 10114fe:	4553      	cmp	r3, sl
 1011500:	bf94      	ite	ls
 1011502:	2300      	movls	r3, #0
 1011504:	2301      	movhi	r3, #1
	ticker_id_head = instance->ticker_id_head;
 1011506:	7e34      	ldrb	r4, [r6, #24]
	ticks_expired = 0U;
 1011508:	46bb      	mov	fp, r7
	while (ticker_id_head != TICKER_NULL) {
 101150a:	2cff      	cmp	r4, #255	; 0xff
	node = &instance->nodes[0];
 101150c:	f8d6 9000 	ldr.w	r9, [r6]
	if (instance->ticks_slot_previous > ticks_elapsed) {
 1011510:	9303      	str	r3, [sp, #12]
	while (ticker_id_head != TICKER_NULL) {
 1011512:	d065      	beq.n	10115e0 <ticker_worker+0x10c>
			ticker->ext_data->ticks_drift = 0U;
 1011514:	46b0      	mov	r8, r6
 1011516:	9704      	str	r7, [sp, #16]
		ticker = &node[ticker_id_head];
 1011518:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 101151c:	eb09 1504 	add.w	r5, r9, r4, lsl #4
		ticks_to_expire = ticker->ticks_to_expire;
 1011520:	68ab      	ldr	r3, [r5, #8]
		ticker = &node[ticker_id_head];
 1011522:	0124      	lsls	r4, r4, #4
		if (ticks_elapsed < ticks_to_expire) {
 1011524:	4553      	cmp	r3, sl
 1011526:	d859      	bhi.n	10115dc <ticker_worker+0x108>
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
 1011528:	78aa      	ldrb	r2, [r5, #2]
		ticks_elapsed -= ticks_to_expire;
 101152a:	ebaa 0a03 	sub.w	sl, sl, r3
		ticks_expired += ticks_to_expire;
 101152e:	449b      	add	fp, r3
		ticker_id_head = ticker->next;
 1011530:	786b      	ldrb	r3, [r5, #1]
 1011532:	f819 4004 	ldrb.w	r4, [r9, r4]
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
 1011536:	1a9b      	subs	r3, r3, r2
 1011538:	b2db      	uxtb	r3, r3
 101153a:	2b01      	cmp	r3, #1
 101153c:	d14c      	bne.n	10115d8 <ticker_worker+0x104>
		if (ticker->ticks_slot != 0U &&
 101153e:	69a9      	ldr	r1, [r5, #24]
 1011540:	2900      	cmp	r1, #0
 1011542:	d06f      	beq.n	1011624 <ticker_worker+0x150>
 1011544:	9b03      	ldr	r3, [sp, #12]
 1011546:	b923      	cbnz	r3, 1011552 <ticker_worker+0x7e>
		   (slot_reserved ||
 1011548:	f8d8 301c 	ldr.w	r3, [r8, #28]
 101154c:	455b      	cmp	r3, fp
 101154e:	f240 8081 	bls.w	1011654 <ticker_worker+0x180>
			struct ticker_ext *ext_data = ticker->ext_data;
 1011552:	6aab      	ldr	r3, [r5, #40]	; 0x28
			if (ext_data &&
 1011554:	b13b      	cbz	r3, 1011566 <ticker_worker+0x92>
 1011556:	681a      	ldr	r2, [r3, #0]
 1011558:	b112      	cbz	r2, 1011560 <ticker_worker+0x8c>
			    ext_data->ticks_slot_window != 0U &&
 101155a:	7a1a      	ldrb	r2, [r3, #8]
 101155c:	2a00      	cmp	r2, #0
 101155e:	d072      	beq.n	1011646 <ticker_worker+0x172>
				ext_data->reschedule_state =
 1011560:	f04f 0200 	mov.w	r2, #0
 1011564:	721a      	strb	r2, [r3, #8]
			ticker->lazy_current++;
 1011566:	8beb      	ldrh	r3, [r5, #30]
			if ((ticker->must_expire == 0U) ||
 1011568:	f895 202c 	ldrb.w	r2, [r5, #44]	; 0x2c
			ticker->lazy_current++;
 101156c:	3301      	adds	r3, #1
 101156e:	b29b      	uxth	r3, r3
 1011570:	83eb      	strh	r3, [r5, #30]
			if ((ticker->must_expire == 0U) ||
 1011572:	2a00      	cmp	r2, #0
 1011574:	d05a      	beq.n	101162c <ticker_worker+0x158>
 1011576:	8baa      	ldrh	r2, [r5, #28]
 1011578:	429a      	cmp	r2, r3
 101157a:	d257      	bcs.n	101162c <ticker_worker+0x158>
			    TICKER_RESCHEDULE_PENDING(ticker)) {
 101157c:	6aab      	ldr	r3, [r5, #40]	; 0x28
			    (ticker->lazy_periodic >= ticker->lazy_current) ||
 101157e:	2b00      	cmp	r3, #0
 1011580:	f000 80b9 	beq.w	10116f6 <ticker_worker+0x222>
			    TICKER_RESCHEDULE_PENDING(ticker)) {
 1011584:	7a1a      	ldrb	r2, [r3, #8]
 1011586:	2a01      	cmp	r2, #1
 1011588:	d050      	beq.n	101162c <ticker_worker+0x158>
			must_expire_skip = 1U;
 101158a:	2601      	movs	r6, #1
			ticker->ext_data->ticks_drift = 0U;
 101158c:	2200      	movs	r2, #0
			ticks_drift = ticker->ext_data->ticks_drift;
 101158e:	6859      	ldr	r1, [r3, #4]
			ticker->ext_data->ticks_drift = 0U;
 1011590:	605a      	str	r2, [r3, #4]
			ticker->ext_data->reschedule_state =
 1011592:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1011594:	721a      	strb	r2, [r3, #8]
		ticker->ack--;
 1011596:	78aa      	ldrb	r2, [r5, #2]
		if (ticker->timeout_func) {
 1011598:	68ef      	ldr	r7, [r5, #12]
		ticker->ack--;
 101159a:	3a01      	subs	r2, #1
 101159c:	70aa      	strb	r2, [r5, #2]
		if (ticker->timeout_func) {
 101159e:	b1df      	cbz	r7, 10115d8 <ticker_worker+0x104>
					   ticks_expired -
 10115a0:	696b      	ldr	r3, [r5, #20]
 10115a2:	f8d8 2014 	ldr.w	r2, [r8, #20]
 10115a6:	ebab 0303 	sub.w	r3, fp, r3
 10115aa:	4413      	add	r3, r2
			ticks_at_expire = (instance->ticks_current +
 10115ac:	f023 407f 	bic.w	r0, r3, #4278190080	; 0xff000000
			ticker->timeout_func(ticks_at_expire,
 10115b0:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 10115b2:	692b      	ldr	r3, [r5, #16]
 10115b4:	f895 c003 	ldrb.w	ip, [r5, #3]
 10115b8:	2e00      	cmp	r6, #0
 10115ba:	d13b      	bne.n	1011634 <ticker_worker+0x160>
 10115bc:	f8b5 e01e 	ldrh.w	lr, [r5, #30]
 10115c0:	e9cd c300 	strd	ip, r3, [sp]
 10115c4:	4673      	mov	r3, lr
 10115c6:	47b8      	blx	r7
				if (ticker->ticks_slot != 0U) {
 10115c8:	69ab      	ldr	r3, [r5, #24]
				ticker->lazy_current = 0U;
 10115ca:	83ee      	strh	r6, [r5, #30]
					slot_reserved = 1U;
 10115cc:	2b00      	cmp	r3, #0
 10115ce:	9b03      	ldr	r3, [sp, #12]
 10115d0:	bf18      	it	ne
 10115d2:	2301      	movne	r3, #1
				ticker->force = 0U;
 10115d4:	70ee      	strb	r6, [r5, #3]
					slot_reserved = 1U;
 10115d6:	9303      	str	r3, [sp, #12]
	while (ticker_id_head != TICKER_NULL) {
 10115d8:	2cff      	cmp	r4, #255	; 0xff
 10115da:	d19d      	bne.n	1011518 <ticker_worker+0x44>
 10115dc:	4646      	mov	r6, r8
 10115de:	9f04      	ldr	r7, [sp, #16]
	if (instance->ticks_elapsed_first == instance->ticks_elapsed_last) {
 10115e0:	7af3      	ldrb	r3, [r6, #11]
 10115e2:	7ab2      	ldrb	r2, [r6, #10]
 10115e4:	429a      	cmp	r2, r3
 10115e6:	d107      	bne.n	10115f8 <ticker_worker+0x124>
	uint8_t idx = *ticks_elapsed_index + 1;
 10115e8:	3201      	adds	r2, #1
 10115ea:	b2d2      	uxtb	r2, r2
	if (idx == DOUBLE_BUFFER_SIZE) {
 10115ec:	2a02      	cmp	r2, #2
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
 10115ee:	bf16      	itet	ne
 10115f0:	4617      	movne	r7, r2
 10115f2:	2300      	moveq	r3, #0
 10115f4:	463b      	movne	r3, r7
	*ticks_elapsed_index = idx;
 10115f6:	72f7      	strb	r7, [r6, #11]
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
 10115f8:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 10115fc:	f8c3 b00c 	str.w	fp, [r3, #12]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
 1011600:	6a74      	ldr	r4, [r6, #36]	; 0x24
	instance->worker_trigger = 0U;
 1011602:	2500      	movs	r5, #0
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
 1011604:	4633      	mov	r3, r6
 1011606:	2201      	movs	r2, #1
 1011608:	2104      	movs	r1, #4
 101160a:	2003      	movs	r0, #3
 101160c:	46a4      	mov	ip, r4
	instance->worker_trigger = 0U;
 101160e:	76b5      	strb	r5, [r6, #26]
}
 1011610:	b009      	add	sp, #36	; 0x24
 1011612:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
 1011616:	4760      	bx	ip
		instance->worker_trigger = 0U;
 1011618:	7687      	strb	r7, [r0, #26]
}
 101161a:	b009      	add	sp, #36	; 0x24
 101161c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1011620:	e9dd 4205 	ldrd	r4, r2, [sp, #20]
		if (ticker->ext_data) {
 1011624:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1011626:	b15b      	cbz	r3, 1011640 <ticker_worker+0x16c>
 1011628:	2600      	movs	r6, #0
 101162a:	e7af      	b.n	101158c <ticker_worker+0xb8>
				ticker->ack--;
 101162c:	78ab      	ldrb	r3, [r5, #2]
 101162e:	3b01      	subs	r3, #1
 1011630:	70ab      	strb	r3, [r5, #2]
				continue;
 1011632:	e7d1      	b.n	10115d8 <ticker_worker+0x104>
			ticker->timeout_func(ticks_at_expire,
 1011634:	e9cd c300 	strd	ip, r3, [sp]
 1011638:	f64f 73ff 	movw	r3, #65535	; 0xffff
 101163c:	47b8      	blx	r7
			if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
 101163e:	e7cb      	b.n	10115d8 <ticker_worker+0x104>
 1011640:	461e      	mov	r6, r3
			ticks_drift = 0U;
 1011642:	4619      	mov	r1, r3
 1011644:	e7a8      	b.n	1011598 <ticker_worker+0xc4>
			    TICKER_RESCHEDULE_STATE_NONE &&
 1011646:	8ba9      	ldrh	r1, [r5, #28]
 1011648:	8bea      	ldrh	r2, [r5, #30]
 101164a:	4291      	cmp	r1, r2
 101164c:	d888      	bhi.n	1011560 <ticker_worker+0x8c>
				ext_data->reschedule_state =
 101164e:	2201      	movs	r2, #1
 1011650:	721a      	strb	r2, [r3, #8]
 1011652:	e788      	b.n	1011566 <ticker_worker+0x92>
	if (ticker->next != TICKER_NULL) {
 1011654:	2cff      	cmp	r4, #255	; 0xff
 1011656:	d0e5      	beq.n	1011624 <ticker_worker+0x150>
		uint16_t lazy_current = ticker->lazy_current;
 1011658:	8be8      	ldrh	r0, [r5, #30]
		if (lazy_current >= ticker->lazy_periodic) {
 101165a:	8bab      	ldrh	r3, [r5, #28]
		uint32_t current_age = ticker->ticks_periodic +
 101165c:	f8d5 e004 	ldr.w	lr, [r5, #4]
		if (lazy_current >= ticker->lazy_periodic) {
 1011660:	4298      	cmp	r0, r3
			lazy_current -= ticker->lazy_periodic;
 1011662:	bf24      	itt	cs
 1011664:	1ac3      	subcs	r3, r0, r3
 1011666:	b298      	uxthcs	r0, r3
			struct ticker_node *ticker_next = &nodes[id_head];
 1011668:	eb04 0344 	add.w	r3, r4, r4, lsl #1
		uint32_t current_age = ticker->ticks_periodic +
 101166c:	fb00 e00e 	mla	r0, r0, lr, lr
			struct ticker_node *ticker_next = &nodes[id_head];
 1011670:	eb09 1303 	add.w	r3, r9, r3, lsl #4
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
 1011674:	689f      	ldr	r7, [r3, #8]
		uint32_t current_age = ticker->ticks_periodic +
 1011676:	9007      	str	r0, [sp, #28]
			if (acc_ticks_to_expire > ticker->ticks_slot) {
 1011678:	428f      	cmp	r7, r1
 101167a:	d8d3      	bhi.n	1011624 <ticker_worker+0x150>
 101167c:	9405      	str	r4, [sp, #20]
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
 101167e:	463e      	mov	r6, r7
 1011680:	468c      	mov	ip, r1
 1011682:	4674      	mov	r4, lr
 1011684:	9206      	str	r2, [sp, #24]
 1011686:	e00f      	b.n	10116a8 <ticker_worker+0x1d4>
					  0U :
 1011688:	bb51      	cbnz	r1, 10116e0 <ticker_worker+0x20c>
			     (next_is_critical ||
 101168a:	78d9      	ldrb	r1, [r3, #3]
 101168c:	78ea      	ldrb	r2, [r5, #3]
 101168e:	4291      	cmp	r1, r2
 1011690:	d824      	bhi.n	10116dc <ticker_worker+0x208>
			id_head = ticker_next->next;
 1011692:	781b      	ldrb	r3, [r3, #0]
		while (id_head != TICKER_NULL) {
 1011694:	2bff      	cmp	r3, #255	; 0xff
 1011696:	d0c3      	beq.n	1011620 <ticker_worker+0x14c>
			struct ticker_node *ticker_next = &nodes[id_head];
 1011698:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 101169c:	eb09 1303 	add.w	r3, r9, r3, lsl #4
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
 10116a0:	689f      	ldr	r7, [r3, #8]
 10116a2:	443e      	add	r6, r7
			if (acc_ticks_to_expire > ticker->ticks_slot) {
 10116a4:	45b4      	cmp	ip, r6
 10116a6:	d3bb      	bcc.n	1011620 <ticker_worker+0x14c>
			if (ticker_next->ticks_slot == 0U) {
 10116a8:	699a      	ldr	r2, [r3, #24]
 10116aa:	2a00      	cmp	r2, #0
 10116ac:	d0f1      	beq.n	1011692 <ticker_worker+0x1be>
			uint16_t lazy_next = ticker_next->lazy_current;
 10116ae:	8bda      	ldrh	r2, [r3, #30]
				ticker_next->lazy_periodic > lazy_next;
 10116b0:	8b98      	ldrh	r0, [r3, #28]
			uint32_t next_age = (ticker_next->ticks_periodic == 0U ?
 10116b2:	6859      	ldr	r1, [r3, #4]
			if (!lazy_next_periodic_skip) {
 10116b4:	4282      	cmp	r2, r0
 10116b6:	d2e7      	bcs.n	1011688 <ticker_worker+0x1b4>
					  0U :
 10116b8:	2900      	cmp	r1, #0
 10116ba:	d0ea      	beq.n	1011692 <ticker_worker+0x1be>
				(ticker->ticks_periodic != 0U) &&
 10116bc:	2c00      	cmp	r4, #0
 10116be:	d0e8      	beq.n	1011692 <ticker_worker+0x1be>
 10116c0:	4696      	mov	lr, r2
			if (curr_has_ticks_slot_window ||
 10116c2:	4282      	cmp	r2, r0
 10116c4:	d3e5      	bcc.n	1011692 <ticker_worker+0x1be>
				(ticker->force == ticker_next->force);
 10116c6:	78e8      	ldrb	r0, [r5, #3]
 10116c8:	78da      	ldrb	r2, [r3, #3]
			     (next_is_critical ||
 10116ca:	4290      	cmp	r0, r2
 10116cc:	d306      	bcc.n	10116dc <ticker_worker+0x208>
			      (equal_priority && equal_force && next_is_older &&
 10116ce:	d1e0      	bne.n	1011692 <ticker_worker+0x1be>
			uint32_t next_age = (ticker_next->ticks_periodic == 0U ?
 10116d0:	fb0e 1201 	mla	r2, lr, r1, r1
			      (equal_priority && equal_force && next_is_older &&
 10116d4:	9907      	ldr	r1, [sp, #28]
			uint32_t next_age = (ticker_next->ticks_periodic == 0U ?
 10116d6:	1bd2      	subs	r2, r2, r7
			      (equal_priority && equal_force && next_is_older &&
 10116d8:	4291      	cmp	r1, r2
 10116da:	d2da      	bcs.n	1011692 <ticker_worker+0x1be>
 10116dc:	9c05      	ldr	r4, [sp, #20]
 10116de:	e738      	b.n	1011552 <ticker_worker+0x7e>
				(ticker->ticks_periodic != 0U) &&
 10116e0:	b124      	cbz	r4, 10116ec <ticker_worker+0x218>
				lazy_next -= ticker_next->lazy_periodic;
 10116e2:	eba2 0e00 	sub.w	lr, r2, r0
 10116e6:	fa1f fe8e 	uxth.w	lr, lr
 10116ea:	e7ea      	b.n	10116c2 <ticker_worker+0x1ee>
			     (next_is_critical ||
 10116ec:	78e9      	ldrb	r1, [r5, #3]
 10116ee:	78da      	ldrb	r2, [r3, #3]
 10116f0:	4291      	cmp	r1, r2
 10116f2:	d2ce      	bcs.n	1011692 <ticker_worker+0x1be>
 10116f4:	e7f2      	b.n	10116dc <ticker_worker+0x208>
			ticks_drift = 0U;
 10116f6:	4619      	mov	r1, r3
			must_expire_skip = 1U;
 10116f8:	2601      	movs	r6, #1
				ticker->ack--;
 10116fa:	78aa      	ldrb	r2, [r5, #2]
 10116fc:	e74c      	b.n	1011598 <ticker_worker+0xc4>
 10116fe:	bf00      	nop

01011700 <ticker_job>:
	if (instance->worker_trigger) {
 1011700:	7e83      	ldrb	r3, [r0, #26]
 1011702:	2b00      	cmp	r3, #0
 1011704:	f040 83f2 	bne.w	1011eec <ticker_job+0x7ec>
{
 1011708:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (instance->job_guard) {
 101170c:	7e43      	ldrb	r3, [r0, #25]
{
 101170e:	b08d      	sub	sp, #52	; 0x34
 1011710:	4682      	mov	sl, r0
	if (instance->job_guard) {
 1011712:	9305      	str	r3, [sp, #20]
 1011714:	2b00      	cmp	r3, #0
 1011716:	f040 8123 	bne.w	1011960 <ticker_job+0x260>
	instance->job_guard = 1U;
 101171a:	2101      	movs	r1, #1
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
 101171c:	7a83      	ldrb	r3, [r0, #10]
 101171e:	7ac2      	ldrb	r2, [r0, #11]
	ticks_previous = instance->ticks_current;
 1011720:	6940      	ldr	r0, [r0, #20]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
 1011722:	429a      	cmp	r2, r3
	ticks_previous = instance->ticks_current;
 1011724:	9006      	str	r0, [sp, #24]
	instance->job_guard = 1U;
 1011726:	f88a 1019 	strb.w	r1, [sl, #25]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
 101172a:	f000 83e0 	beq.w	1011eee <ticker_job+0x7ee>
	uint8_t idx = *ticks_elapsed_index + 1;
 101172e:	440b      	add	r3, r1
 1011730:	b2db      	uxtb	r3, r3
	if (idx == DOUBLE_BUFFER_SIZE) {
 1011732:	2b02      	cmp	r3, #2
		idx = 0U;
 1011734:	bf0a      	itet	eq
 1011736:	9a05      	ldreq	r2, [sp, #20]
		    instance->ticks_elapsed[instance->ticks_elapsed_first];
 1011738:	461a      	movne	r2, r3
		idx = 0U;
 101173a:	4613      	moveq	r3, r2
	*ticks_elapsed_index = idx;
 101173c:	f88a 300a 	strb.w	r3, [sl, #10]
		ticks_elapsed =
 1011740:	eb0a 0382 	add.w	r3, sl, r2, lsl #2
 1011744:	68da      	ldr	r2, [r3, #12]
		instance->ticks_current += ticks_elapsed;
 1011746:	9b06      	ldr	r3, [sp, #24]
		ticks_elapsed =
 1011748:	9202      	str	r2, [sp, #8]
		instance->ticks_current += ticks_elapsed;
 101174a:	4413      	add	r3, r2
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
 101174c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 1011750:	f8ca 3014 	str.w	r3, [sl, #20]
		flag_elapsed = 1U;
 1011754:	2301      	movs	r3, #1
 1011756:	9309      	str	r3, [sp, #36]	; 0x24
	ticker_id_old_head = instance->ticker_id_head;
 1011758:	f89a 6018 	ldrb.w	r6, [sl, #24]
	ticks_now = cntr_cnt_get();
 101175c:	f00b fc7e 	bl	101d05c <cntr_cnt_get>
	node = &instance->nodes[0];
 1011760:	f8da 3000 	ldr.w	r3, [sl]
	count_user = instance->count_user;
 1011764:	f89a 2009 	ldrb.w	r2, [sl, #9]
	node = &instance->nodes[0];
 1011768:	9300      	str	r3, [sp, #0]
	while (count_user--) {
 101176a:	1e53      	subs	r3, r2, #1
	users = &instance->users[0];
 101176c:	f8da 5004 	ldr.w	r5, [sl, #4]
	while (count_user--) {
 1011770:	b2db      	uxtb	r3, r3
	ticks_now = cntr_cnt_get();
 1011772:	9003      	str	r0, [sp, #12]
	while (count_user--) {
 1011774:	2a00      	cmp	r2, #0
 1011776:	f000 83de 	beq.w	1011f36 <ticker_job+0x836>
 101177a:	eb05 08c3 	add.w	r8, r5, r3, lsl #3
	insert_head = TICKER_NULL;
 101177e:	23ff      	movs	r3, #255	; 0xff
 1011780:	46d3      	mov	fp, sl
 1011782:	9304      	str	r3, [sp, #16]
 1011784:	960a      	str	r6, [sp, #40]	; 0x28
		user_ops = &user->user_op[0];
 1011786:	46a9      	mov	r9, r5
 1011788:	f8d8 7004 	ldr.w	r7, [r8, #4]
		while (user->middle != user->last) {
 101178c:	f898 0003 	ldrb.w	r0, [r8, #3]
 1011790:	f898 a002 	ldrb.w	sl, [r8, #2]
			middle = user->middle + 1;
 1011794:	f10a 0301 	add.w	r3, sl, #1
		while (user->middle != user->last) {
 1011798:	4550      	cmp	r0, sl
			middle = user->middle + 1;
 101179a:	b2db      	uxtb	r3, r3
		while (user->middle != user->last) {
 101179c:	d03d      	beq.n	101181a <ticker_job+0x11a>
			user_op = &user_ops[user->middle];
 101179e:	2134      	movs	r1, #52	; 0x34
			if (middle == user->count_user_op) {
 10117a0:	f898 2000 	ldrb.w	r2, [r8]
			user_op = &user_ops[user->middle];
 10117a4:	fb01 f60a 	mul.w	r6, r1, sl
				middle = 0U;
 10117a8:	429a      	cmp	r2, r3
 10117aa:	bf08      	it	eq
 10117ac:	2300      	moveq	r3, #0
			user->middle = middle;
 10117ae:	f888 3002 	strb.w	r3, [r8, #2]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
 10117b2:	5dba      	ldrb	r2, [r7, r6]
			user_op = &user_ops[user->middle];
 10117b4:	19bc      	adds	r4, r7, r6
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
 10117b6:	2a04      	cmp	r2, #4
			ticker = &node[user_op->id];
 10117b8:	7861      	ldrb	r1, [r4, #1]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
 10117ba:	f240 80e7 	bls.w	101198c <ticker_job+0x28c>
			ticker = &node[user_op->id];
 10117be:	9800      	ldr	r0, [sp, #0]
 10117c0:	eb01 0341 	add.w	r3, r1, r1, lsl #1
 10117c4:	eb00 1503 	add.w	r5, r0, r3, lsl #4
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
 10117c8:	2a08      	cmp	r2, #8
			ticker = &node[user_op->id];
 10117ca:	ea4f 1303 	mov.w	r3, r3, lsl #4
 10117ce:	9301      	str	r3, [sp, #4]
			state = (ticker->req - ticker->ack) & 0xff;
 10117d0:	78a8      	ldrb	r0, [r5, #2]
 10117d2:	786b      	ldrb	r3, [r5, #1]
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
 10117d4:	f200 80ce 	bhi.w	1011974 <ticker_job+0x274>
			state = (ticker->req - ticker->ack) & 0xff;
 10117d8:	1a1b      	subs	r3, r3, r0
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
 10117da:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 10117de:	f040 80d7 	bne.w	1011990 <ticker_job+0x290>
			    ((state == 0U) &&
 10117e2:	2a06      	cmp	r2, #6
 10117e4:	f040 80c6 	bne.w	1011974 <ticker_job+0x274>
		if (instance->ticker_id_slot_previous == user_op->id) {
 10117e8:	f89b 301b 	ldrb.w	r3, [fp, #27]
 10117ec:	428b      	cmp	r3, r1
 10117ee:	f000 80fa 	beq.w	10119e6 <ticker_job+0x2e6>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 10117f2:	f04f 0300 	mov.w	r3, #0
 10117f6:	55bb      	strb	r3, [r7, r6]
	user_op->status = status;
 10117f8:	2300      	movs	r3, #0
 10117fa:	62a3      	str	r3, [r4, #40]	; 0x28
	if (user_op->fp_op_func) {
 10117fc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 10117fe:	2b00      	cmp	r3, #0
 1011800:	d0c4      	beq.n	101178c <ticker_job+0x8c>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 1011802:	2000      	movs	r0, #0
 1011804:	6b21      	ldr	r1, [r4, #48]	; 0x30
 1011806:	4798      	blx	r3
		while (user->middle != user->last) {
 1011808:	f898 a002 	ldrb.w	sl, [r8, #2]
 101180c:	f898 0003 	ldrb.w	r0, [r8, #3]
			middle = user->middle + 1;
 1011810:	f10a 0301 	add.w	r3, sl, #1
		while (user->middle != user->last) {
 1011814:	4550      	cmp	r0, sl
			middle = user->middle + 1;
 1011816:	b2db      	uxtb	r3, r3
		while (user->middle != user->last) {
 1011818:	d1c1      	bne.n	101179e <ticker_job+0x9e>
 101181a:	464d      	mov	r5, r9
	while (count_user--) {
 101181c:	4545      	cmp	r5, r8
 101181e:	f1a8 0308 	sub.w	r3, r8, #8
 1011822:	f040 80d4 	bne.w	10119ce <ticker_job+0x2ce>
 1011826:	46da      	mov	sl, fp
 1011828:	9e0a      	ldr	r6, [sp, #40]	; 0x28
	if (flag_elapsed) {
 101182a:	9b09      	ldr	r3, [sp, #36]	; 0x24
	if (instance->ticker_id_head != ticker_id_old_head) {
 101182c:	f89a 5018 	ldrb.w	r5, [sl, #24]
	if (flag_elapsed) {
 1011830:	2b00      	cmp	r3, #0
 1011832:	f000 8221 	beq.w	1011c78 <ticker_job+0x578>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1011836:	9a06      	ldr	r2, [sp, #24]
 1011838:	9b03      	ldr	r3, [sp, #12]
	while (instance->ticker_id_head != TICKER_NULL) {
 101183a:	2dff      	cmp	r5, #255	; 0xff
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 101183c:	eba3 0302 	sub.w	r3, r3, r2
	node = &instance->nodes[0];
 1011840:	f8da 2000 	ldr.w	r2, [sl]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1011844:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	node = &instance->nodes[0];
 1011848:	9201      	str	r2, [sp, #4]
	while (instance->ticker_id_head != TICKER_NULL) {
 101184a:	f000 8377 	beq.w	1011f3c <ticker_job+0x83c>
			instance->ticks_slot_previous = 0U;
 101184e:	e9cd 5607 	strd	r5, r6, [sp, #28]
	ticks_expired = 0U;
 1011852:	f04f 0900 	mov.w	r9, #0
	while (instance->ticker_id_head != TICKER_NULL) {
 1011856:	46ab      	mov	fp, r5
			instance->ticks_slot_previous = 0U;
 1011858:	461e      	mov	r6, r3
	while (instance->ticker_id_head != TICKER_NULL) {
 101185a:	9f02      	ldr	r7, [sp, #8]
			instance->ticks_slot_previous = 0U;
 101185c:	9c04      	ldr	r4, [sp, #16]
		ticker = &node[id_expired];
 101185e:	9a01      	ldr	r2, [sp, #4]
 1011860:	eb0b 034b 	add.w	r3, fp, fp, lsl #1
 1011864:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 1011868:	9200      	str	r2, [sp, #0]
		ticks_to_expire = ticker->ticks_to_expire;
 101186a:	6892      	ldr	r2, [r2, #8]
		ticker = &node[id_expired];
 101186c:	ea4f 1803 	mov.w	r8, r3, lsl #4
		if (ticks_elapsed < ticks_to_expire) {
 1011870:	42ba      	cmp	r2, r7
 1011872:	f200 8340 	bhi.w	1011ef6 <ticker_job+0x7f6>
		state = (ticker->req - ticker->ack) & 0xff;
 1011876:	9800      	ldr	r0, [sp, #0]
		ticks_elapsed -= ticks_to_expire;
 1011878:	1abf      	subs	r7, r7, r2
		state = (ticker->req - ticker->ack) & 0xff;
 101187a:	7881      	ldrb	r1, [r0, #2]
 101187c:	7843      	ldrb	r3, [r0, #1]
		ticks_expired += ticks_to_expire;
 101187e:	4491      	add	r9, r2
		state = (ticker->req - ticker->ack) & 0xff;
 1011880:	1a5b      	subs	r3, r3, r1
		if (instance->ticks_slot_previous > ticks_to_expire) {
 1011882:	f8da 101c 	ldr.w	r1, [sl, #28]
		ticks_latency -= ticks_to_expire;
 1011886:	1ab6      	subs	r6, r6, r2
		if (instance->ticks_slot_previous > ticks_to_expire) {
 1011888:	428a      	cmp	r2, r1
			instance->ticker_id_slot_previous = TICKER_NULL;
 101188a:	bf24      	itt	cs
 101188c:	f04f 32ff 	movcs.w	r2, #4294967295
			instance->ticks_slot_previous = 0U;
 1011890:	2100      	movcs	r1, #0
		skip_collision = (ticker->lazy_current != 0U);
 1011892:	8bc0      	ldrh	r0, [r0, #30]
			instance->ticks_slot_previous -= ticks_to_expire;
 1011894:	bf34      	ite	cc
 1011896:	1a89      	subcc	r1, r1, r2
			instance->ticker_id_slot_previous = TICKER_NULL;
 1011898:	f88a 201b 	strbcs.w	r2, [sl, #27]
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
 101189c:	9a00      	ldr	r2, [sp, #0]
 101189e:	f8ca 101c 	str.w	r1, [sl, #28]
 10118a2:	6992      	ldr	r2, [r2, #24]
		state = (ticker->req - ticker->ack) & 0xff;
 10118a4:	b2db      	uxtb	r3, r3
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
 10118a6:	b112      	cbz	r2, 10118ae <ticker_job+0x1ae>
 10118a8:	2b02      	cmp	r3, #2
 10118aa:	f000 81cf 	beq.w	1011c4c <ticker_job+0x54c>
		ticker->ticks_to_expire = 0U;
 10118ae:	2200      	movs	r2, #0
 10118b0:	9900      	ldr	r1, [sp, #0]
 10118b2:	608a      	str	r2, [r1, #8]
		instance->ticker_id_head = ticker->next;
 10118b4:	9a01      	ldr	r2, [sp, #4]
 10118b6:	f812 2008 	ldrb.w	r2, [r2, r8]
 10118ba:	f88a 2018 	strb.w	r2, [sl, #24]
		if ((ticker->ticks_periodic != 0U) ||
 10118be:	460a      	mov	r2, r1
 10118c0:	6849      	ldr	r1, [r1, #4]
 10118c2:	2900      	cmp	r1, #0
 10118c4:	f040 8183 	bne.w	1011bce <ticker_job+0x4ce>
		    TICKER_RESCHEDULE_PENDING(ticker)) {
 10118c8:	6a92      	ldr	r2, [r2, #40]	; 0x28
		if ((ticker->ticks_periodic != 0U) ||
 10118ca:	b11a      	cbz	r2, 10118d4 <ticker_job+0x1d4>
		    TICKER_RESCHEDULE_PENDING(ticker)) {
 10118cc:	7a12      	ldrb	r2, [r2, #8]
 10118ce:	2a01      	cmp	r2, #1
 10118d0:	f000 8161 	beq.w	1011b96 <ticker_job+0x496>
			if (state && ((state == 1U) || skip_collision) &&
 10118d4:	b143      	cbz	r3, 10118e8 <ticker_job+0x1e8>
 10118d6:	2b01      	cmp	r3, #1
 10118d8:	d000      	beq.n	10118dc <ticker_job+0x1dc>
 10118da:	b128      	cbz	r0, 10118e8 <ticker_job+0x1e8>
			    ticker->fp_op_func) {
 10118dc:	9a00      	ldr	r2, [sp, #0]
 10118de:	6a13      	ldr	r3, [r2, #32]
			if (state && ((state == 1U) || skip_collision) &&
 10118e0:	b113      	cbz	r3, 10118e8 <ticker_job+0x1e8>
				ticker->fp_op_func(TICKER_STATUS_FAILURE,
 10118e2:	2001      	movs	r0, #1
 10118e4:	6a51      	ldr	r1, [r2, #36]	; 0x24
 10118e6:	4798      	blx	r3
			ticker->req = ticker->ack;
 10118e8:	9b00      	ldr	r3, [sp, #0]
 10118ea:	9a00      	ldr	r2, [sp, #0]
 10118ec:	789b      	ldrb	r3, [r3, #2]
 10118ee:	7053      	strb	r3, [r2, #1]
	while (instance->ticker_id_head != TICKER_NULL) {
 10118f0:	f89a b018 	ldrb.w	fp, [sl, #24]
 10118f4:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
 10118f8:	d1b1      	bne.n	101185e <ticker_job+0x15e>
 10118fa:	9404      	str	r4, [sp, #16]
 10118fc:	e9dd 5607 	ldrd	r5, r6, [sp, #28]
		if (instance->ticker_id_head != ticker_id_old_head) {
 1011900:	455e      	cmp	r6, fp
 1011902:	d103      	bne.n	101190c <ticker_job+0x20c>
	if (instance->ticker_id_head != ticker_id_old_head) {
 1011904:	1bab      	subs	r3, r5, r6
 1011906:	bf18      	it	ne
 1011908:	2301      	movne	r3, #1
 101190a:	9309      	str	r3, [sp, #36]	; 0x24
		ticker_job_list_insert(instance, insert_head);
 101190c:	4650      	mov	r0, sl
 101190e:	9904      	ldr	r1, [sp, #16]
 1011910:	f7ff fcde 	bl	10112d0 <ticker_job_list_insert>
		ticker_id_head = instance->ticker_id_head;
 1011914:	f89a 3018 	ldrb.w	r3, [sl, #24]
	nodes = &instance->nodes[0];
 1011918:	f8da b000 	ldr.w	fp, [sl]
		while (ticker_id_head != TICKER_NULL) {
 101191c:	2bff      	cmp	r3, #255	; 0xff
 101191e:	9c05      	ldr	r4, [sp, #20]
 1011920:	9603      	str	r6, [sp, #12]
 1011922:	f000 829e 	beq.w	1011e62 <ticker_job+0x762>
		ticker_id_head = instance->ticker_id_head;
 1011926:	4618      	mov	r0, r3
			ticker = &nodes[ticker_id_head];
 1011928:	eb00 0140 	add.w	r1, r0, r0, lsl #1
 101192c:	eb0b 1601 	add.w	r6, fp, r1, lsl #4
			ext_data = ticker->ext_data;
 1011930:	6ab2      	ldr	r2, [r6, #40]	; 0x28
			ticker = &nodes[ticker_id_head];
 1011932:	0109      	lsls	r1, r1, #4
			if (ext_data && ext_data->reschedule_state ==
 1011934:	b11a      	cbz	r2, 101193e <ticker_job+0x23e>
 1011936:	7a15      	ldrb	r5, [r2, #8]
 1011938:	2d01      	cmp	r5, #1
 101193a:	f000 8207 	beq.w	1011d4c <ticker_job+0x64c>
			ticker_id_head = ticker->next;
 101193e:	f81b 0001 	ldrb.w	r0, [fp, r1]
		while (ticker_id_head != TICKER_NULL) {
 1011942:	28ff      	cmp	r0, #255	; 0xff
 1011944:	d1f0      	bne.n	1011928 <ticker_job+0x228>
	return rescheduled;
 1011946:	9e03      	ldr	r6, [sp, #12]
 1011948:	9405      	str	r4, [sp, #20]
		if (ticker_job_reschedule_in_window(instance, ticks_elapsed)) {
 101194a:	2c00      	cmp	r4, #0
 101194c:	f040 81b9 	bne.w	1011cc2 <ticker_job+0x5c2>
	if (instance->ticker_id_head != ticker_id_old_head) {
 1011950:	429e      	cmp	r6, r3
 1011952:	f040 81b6 	bne.w	1011cc2 <ticker_job+0x5c2>
	if (flag_compare_update) {
 1011956:	9a09      	ldr	r2, [sp, #36]	; 0x24
 1011958:	2a00      	cmp	r2, #0
 101195a:	f000 8197 	beq.w	1011c8c <ticker_job+0x58c>
 101195e:	e1b3      	b.n	1011cc8 <ticker_job+0x5c8>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_JOB, 1,
 1011960:	2104      	movs	r1, #4
 1011962:	6a44      	ldr	r4, [r0, #36]	; 0x24
 1011964:	4603      	mov	r3, r0
 1011966:	2201      	movs	r2, #1
 1011968:	4608      	mov	r0, r1
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
 101196a:	46a4      	mov	ip, r4
}
 101196c:	b00d      	add	sp, #52	; 0x34
 101196e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
 1011972:	4760      	bx	ip
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 1011974:	f04f 0300 	mov.w	r3, #0
	user_op->status = status;
 1011978:	2001      	movs	r0, #1
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 101197a:	55bb      	strb	r3, [r7, r6]
	if (user_op->fp_op_func) {
 101197c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	user_op->status = status;
 101197e:	62a0      	str	r0, [r4, #40]	; 0x28
	if (user_op->fp_op_func) {
 1011980:	2b00      	cmp	r3, #0
 1011982:	f43f af03 	beq.w	101178c <ticker_job+0x8c>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 1011986:	6b21      	ldr	r1, [r4, #48]	; 0x30
 1011988:	4798      	blx	r3
 101198a:	e6ff      	b.n	101178c <ticker_job+0x8c>
 101198c:	469a      	mov	sl, r3
 101198e:	e701      	b.n	1011794 <ticker_job+0x94>
			     (user_op->op != TICKER_USER_OP_TYPE_YIELD_ABS)) ||
 1011990:	2a05      	cmp	r2, #5
 1011992:	d11e      	bne.n	10119d2 <ticker_job+0x2d2>
			    ((user_op->op == TICKER_USER_OP_TYPE_UPDATE) &&
 1011994:	6862      	ldr	r2, [r4, #4]
 1011996:	b94a      	cbnz	r2, 10119ac <ticker_job+0x2ac>
			     (user_op->params.update.ticks_drift_plus == 0U) &&
 1011998:	68a2      	ldr	r2, [r4, #8]
 101199a:	b93a      	cbnz	r2, 10119ac <ticker_job+0x2ac>
			     (user_op->params.update.ticks_drift_minus == 0U) &&
 101199c:	68e2      	ldr	r2, [r4, #12]
 101199e:	b92a      	cbnz	r2, 10119ac <ticker_job+0x2ac>
			     (user_op->params.update.ticks_slot_plus == 0U) &&
 10119a0:	6922      	ldr	r2, [r4, #16]
 10119a2:	b91a      	cbnz	r2, 10119ac <ticker_job+0x2ac>
			     (user_op->params.update.lazy == 0U) &&
 10119a4:	6962      	ldr	r2, [r4, #20]
 10119a6:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 10119aa:	d0e3      	beq.n	1011974 <ticker_job+0x274>
			if ((state == 1U) ||
 10119ac:	2b01      	cmp	r3, #1
 10119ae:	d02a      	beq.n	1011a06 <ticker_job+0x306>
				instance->sched_cb(TICKER_CALL_ID_JOB,
 10119b0:	2104      	movs	r1, #4
 10119b2:	464d      	mov	r5, r9
 10119b4:	465b      	mov	r3, fp
 10119b6:	2201      	movs	r2, #1
 10119b8:	4608      	mov	r0, r1
 10119ba:	f8db 4024 	ldr.w	r4, [fp, #36]	; 0x24
 10119be:	47a0      	blx	r4
	while (count_user--) {
 10119c0:	4545      	cmp	r5, r8
				user->middle = prev;
 10119c2:	f888 a002 	strb.w	sl, [r8, #2]
	while (count_user--) {
 10119c6:	f1a8 0308 	sub.w	r3, r8, #8
 10119ca:	f43f af2c 	beq.w	1011826 <ticker_job+0x126>
 10119ce:	4698      	mov	r8, r3
 10119d0:	e6d9      	b.n	1011786 <ticker_job+0x86>
			if ((state == 1U) ||
 10119d2:	2b01      	cmp	r3, #1
 10119d4:	f000 8088 	beq.w	1011ae8 <ticker_job+0x3e8>
 10119d8:	2a06      	cmp	r2, #6
 10119da:	d1e9      	bne.n	10119b0 <ticker_job+0x2b0>
		if (instance->ticker_id_slot_previous == user_op->id) {
 10119dc:	f89b 301b 	ldrb.w	r3, [fp, #27]
 10119e0:	428b      	cmp	r3, r1
 10119e2:	f47f af06 	bne.w	10117f2 <ticker_job+0xf2>
				ticks_at_yield =
 10119e6:	6861      	ldr	r1, [r4, #4]
			ticks_current = instance->ticks_current;
 10119e8:	f8db 2014 	ldr.w	r2, [fp, #20]
			if (!((ticks_at_yield - ticks_current) &
 10119ec:	1a8b      	subs	r3, r1, r2
 10119ee:	021d      	lsls	r5, r3, #8
 10119f0:	f140 809e 	bpl.w	1011b30 <ticker_job+0x430>
				if (ticks_elapsed > ticks_used) {
 10119f4:	9b02      	ldr	r3, [sp, #8]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10119f6:	1a52      	subs	r2, r2, r1
 10119f8:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
				if (ticks_elapsed > ticks_used) {
 10119fc:	4293      	cmp	r3, r2
					ticks_used = 0;
 10119fe:	bf94      	ite	ls
 1011a00:	2300      	movls	r3, #0
					ticks_used = ticks_elapsed -
 1011a02:	1a9b      	subhi	r3, r3, r2
 1011a04:	e098      	b.n	1011b38 <ticker_job+0x438>
		ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
 1011a06:	4658      	mov	r0, fp
 1011a08:	f7ff fc06 	bl	1011218 <ticker_dequeue>
 1011a0c:	60a8      	str	r0, [r5, #8]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1011a0e:	9b03      	ldr	r3, [sp, #12]
		ticker_job_node_update(ticker, user_op, ticks_now,
 1011a10:	f8db e014 	ldr.w	lr, [fp, #20]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1011a14:	eba3 010e 	sub.w	r1, r3, lr
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
 1011a18:	9b02      	ldr	r3, [sp, #8]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1011a1a:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
 1011a1e:	4419      	add	r1, r3
	if (ticks_to_expire > ticks_elapsed) {
 1011a20:	4288      	cmp	r0, r1
 1011a22:	f240 8090 	bls.w	1011b46 <ticker_job+0x446>
		ticks_to_expire -= ticks_elapsed;
 1011a26:	1a42      	subs	r2, r0, r1
	if ((ticker->ticks_periodic != 0U) &&
 1011a28:	686b      	ldr	r3, [r5, #4]
 1011a2a:	b36b      	cbz	r3, 1011a88 <ticker_job+0x388>
	    (user_op->params.update.lazy != 0U)) {
 1011a2c:	8aa3      	ldrh	r3, [r4, #20]
	if ((ticker->ticks_periodic != 0U) &&
 1011a2e:	b35b      	cbz	r3, 1011a88 <ticker_job+0x388>
		user_op->params.update.lazy--;
 1011a30:	3b01      	subs	r3, #1
 1011a32:	b299      	uxth	r1, r3
 1011a34:	82a1      	strh	r1, [r4, #20]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
 1011a36:	f8d5 c004 	ldr.w	ip, [r5, #4]
		while (ticker->lazy_current < user_op->params.update.lazy) {
 1011a3a:	8beb      	ldrh	r3, [r5, #30]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
 1011a3c:	4562      	cmp	r2, ip
 1011a3e:	f240 8089 	bls.w	1011b54 <ticker_job+0x454>
			ticks_to_expire += ticker->ticks_periodic +
 1011a42:	f10c 0a01 	add.w	sl, ip, #1
 1011a46:	9607      	str	r6, [sp, #28]
 1011a48:	e011      	b.n	1011a6e <ticker_job+0x36e>
 1011a4a:	4650      	mov	r0, sl
		ticker->remainder_current += HAL_TICKER_REMAINDER_RANGE;
 1011a4c:	f101 71e8 	add.w	r1, r1, #30408704	; 0x1d00000
 1011a50:	f501 31d4 	add.w	r1, r1, #108544	; 0x1a800
 1011a54:	f501 71a5 	add.w	r1, r1, #330	; 0x14a
	ticker->remainder_current -= ticker->remainder_periodic;
 1011a58:	6a2e      	ldr	r6, [r5, #32]
			ticker->lazy_current--;
 1011a5a:	3b01      	subs	r3, #1
			ticks_to_expire -= ticker->ticks_periodic +
 1011a5c:	1a12      	subs	r2, r2, r0
	ticker->remainder_current -= ticker->remainder_periodic;
 1011a5e:	1b89      	subs	r1, r1, r6
			ticker->lazy_current--;
 1011a60:	b29b      	uxth	r3, r3
		while ((ticks_to_expire > ticker->ticks_periodic) &&
 1011a62:	4562      	cmp	r2, ip
	ticker->remainder_current -= ticker->remainder_periodic;
 1011a64:	6269      	str	r1, [r5, #36]	; 0x24
			ticker->lazy_current--;
 1011a66:	83eb      	strh	r3, [r5, #30]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
 1011a68:	f240 80ed 	bls.w	1011c46 <ticker_job+0x546>
		while (ticker->lazy_current < user_op->params.update.lazy) {
 1011a6c:	8aa1      	ldrh	r1, [r4, #20]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
 1011a6e:	428b      	cmp	r3, r1
 1011a70:	d96f      	bls.n	1011b52 <ticker_job+0x452>
	if ((ticker->remainder_current >= BIT(31)) ||
 1011a72:	6a69      	ldr	r1, [r5, #36]	; 0x24
 1011a74:	488f      	ldr	r0, [pc, #572]	; (1011cb4 <ticker_job+0x5b4>)
 1011a76:	4e90      	ldr	r6, [pc, #576]	; (1011cb8 <ticker_job+0x5b8>)
 1011a78:	1808      	adds	r0, r1, r0
 1011a7a:	42b0      	cmp	r0, r6
 1011a7c:	d8e5      	bhi.n	1011a4a <ticker_job+0x34a>
 1011a7e:	4660      	mov	r0, ip
 1011a80:	e7ea      	b.n	1011a58 <ticker_job+0x358>
 1011a82:	e9dd 9607 	ldrd	r9, r6, [sp, #28]
		ticker->lazy_periodic = user_op->params.update.lazy;
 1011a86:	83a9      	strh	r1, [r5, #28]
	ticker->ticks_to_expire = ticks_to_expire +
 1011a88:	6863      	ldr	r3, [r4, #4]
	struct ticker_ext *ext_data = ticker->ext_data;
 1011a8a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
	ticker->ticks_to_expire = ticks_to_expire +
 1011a8c:	4413      	add	r3, r2
 1011a8e:	60ab      	str	r3, [r5, #8]
	ticker->ticks_to_expire_minus +=
 1011a90:	68a2      	ldr	r2, [r4, #8]
 1011a92:	696b      	ldr	r3, [r5, #20]
 1011a94:	4413      	add	r3, r2
 1011a96:	616b      	str	r3, [r5, #20]
	if (ext_data && ext_data->ticks_slot_window != 0U) {
 1011a98:	b129      	cbz	r1, 1011aa6 <ticker_job+0x3a6>
 1011a9a:	680b      	ldr	r3, [r1, #0]
 1011a9c:	b11b      	cbz	r3, 1011aa6 <ticker_job+0x3a6>
			user_op->params.update.ticks_drift_plus -
 1011a9e:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
 1011aa2:	1a9b      	subs	r3, r3, r2
		ext_data->ticks_drift =
 1011aa4:	604b      	str	r3, [r1, #4]
	ticks_to_expire_prep(ticker, ticks_current, ticks_now);
 1011aa6:	9a03      	ldr	r2, [sp, #12]
 1011aa8:	4671      	mov	r1, lr
 1011aaa:	4628      	mov	r0, r5
 1011aac:	f7ff fbec 	bl	1011288 <ticks_to_expire_prep>
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
 1011ab0:	68e2      	ldr	r2, [r4, #12]
 1011ab2:	69ab      	ldr	r3, [r5, #24]
 1011ab4:	4413      	add	r3, r2
 1011ab6:	61ab      	str	r3, [r5, #24]
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
 1011ab8:	6922      	ldr	r2, [r4, #16]
 1011aba:	4293      	cmp	r3, r2
		ticker->ticks_slot = 0U;
 1011abc:	bf94      	ite	ls
 1011abe:	2300      	movls	r3, #0
		ticker->ticks_slot -= user_op->params.update.ticks_slot_minus;
 1011ac0:	1a9b      	subhi	r3, r3, r2
 1011ac2:	61ab      	str	r3, [r5, #24]
	if (user_op->params.update.force != 0U) {
 1011ac4:	7da3      	ldrb	r3, [r4, #22]
 1011ac6:	b103      	cbz	r3, 1011aca <ticker_job+0x3ca>
		ticker->force = user_op->params.update.force;
 1011ac8:	70eb      	strb	r3, [r5, #3]
	if (user_op->params.update.must_expire) {
 1011aca:	7de3      	ldrb	r3, [r4, #23]
 1011acc:	b113      	cbz	r3, 1011ad4 <ticker_job+0x3d4>
		ticker->must_expire = (user_op->params.update.must_expire - 1);
 1011ace:	3b01      	subs	r3, #1
 1011ad0:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
	ticker->next = *insert_head;
 1011ad4:	9b04      	ldr	r3, [sp, #16]
 1011ad6:	e9dd 2100 	ldrd	r2, r1, [sp]
 1011ada:	5453      	strb	r3, [r2, r1]
		ticker->req++;
 1011adc:	786b      	ldrb	r3, [r5, #1]
	*insert_head = user_op->id;
 1011ade:	7862      	ldrb	r2, [r4, #1]
		ticker->req++;
 1011ae0:	3301      	adds	r3, #1
	*insert_head = user_op->id;
 1011ae2:	9204      	str	r2, [sp, #16]
		ticker->req++;
 1011ae4:	706b      	strb	r3, [r5, #1]
 1011ae6:	e684      	b.n	10117f2 <ticker_job+0xf2>
		if (user_op->op != TICKER_USER_OP_TYPE_YIELD_ABS) {
 1011ae8:	2a06      	cmp	r2, #6
 1011aea:	f43f ae7d 	beq.w	10117e8 <ticker_job+0xe8>
			ticker->ticks_to_expire = ticker_dequeue(instance,
 1011aee:	4658      	mov	r0, fp
 1011af0:	f7ff fb92 	bl	1011218 <ticker_dequeue>
			ticker->req = ticker->ack;
 1011af4:	78ab      	ldrb	r3, [r5, #2]
			ticker->ticks_to_expire = ticker_dequeue(instance,
 1011af6:	60a8      	str	r0, [r5, #8]
			ticker->req = ticker->ack;
 1011af8:	706b      	strb	r3, [r5, #1]
		if (instance->ticker_id_slot_previous == user_op->id) {
 1011afa:	f89b 201b 	ldrb.w	r2, [fp, #27]
 1011afe:	7863      	ldrb	r3, [r4, #1]
 1011b00:	429a      	cmp	r2, r3
 1011b02:	f47f ae76 	bne.w	10117f2 <ticker_job+0xf2>
			if (user_op->op != TICKER_USER_OP_TYPE_YIELD_ABS) {
 1011b06:	5dbb      	ldrb	r3, [r7, r6]
 1011b08:	2b06      	cmp	r3, #6
 1011b0a:	f43f af6c 	beq.w	10119e6 <ticker_job+0x2e6>
				instance->ticker_id_slot_previous = TICKER_NULL;
 1011b0e:	23ff      	movs	r3, #255	; 0xff
 1011b10:	f88b 301b 	strb.w	r3, [fp, #27]
			if ((user_op->op == TICKER_USER_OP_TYPE_YIELD_ABS) ||
 1011b14:	5dbb      	ldrb	r3, [r7, r6]
 1011b16:	2b06      	cmp	r3, #6
 1011b18:	f43f af65 	beq.w	10119e6 <ticker_job+0x2e6>
 1011b1c:	2b08      	cmp	r3, #8
 1011b1e:	f43f af62 	beq.w	10119e6 <ticker_job+0x2e6>
				ticks_at_yield = ticks_now;
 1011b22:	9903      	ldr	r1, [sp, #12]
			ticks_current = instance->ticks_current;
 1011b24:	f8db 2014 	ldr.w	r2, [fp, #20]
			if (!((ticks_at_yield - ticks_current) &
 1011b28:	1a8b      	subs	r3, r1, r2
 1011b2a:	021d      	lsls	r5, r3, #8
 1011b2c:	f53f af62 	bmi.w	10119f4 <ticker_job+0x2f4>
				ticks_used = ticks_elapsed +
 1011b30:	9a02      	ldr	r2, [sp, #8]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1011b32:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
				ticks_used = ticks_elapsed +
 1011b36:	4413      	add	r3, r2
			if (instance->ticks_slot_previous > ticks_used) {
 1011b38:	f8db 201c 	ldr.w	r2, [fp, #28]
 1011b3c:	429a      	cmp	r2, r3
				instance->ticks_slot_previous = ticks_used;
 1011b3e:	bf88      	it	hi
 1011b40:	f8cb 301c 	strhi.w	r3, [fp, #28]
 1011b44:	e655      	b.n	10117f2 <ticker_job+0xf2>
		ticker->ticks_to_expire_minus += ticks_elapsed -
 1011b46:	696b      	ldr	r3, [r5, #20]
		ticks_to_expire = 0U;
 1011b48:	2200      	movs	r2, #0
		ticker->ticks_to_expire_minus += ticks_elapsed -
 1011b4a:	4419      	add	r1, r3
 1011b4c:	1a09      	subs	r1, r1, r0
 1011b4e:	6169      	str	r1, [r5, #20]
		ticks_to_expire = 0U;
 1011b50:	e76a      	b.n	1011a28 <ticker_job+0x328>
 1011b52:	9e07      	ldr	r6, [sp, #28]
		while (ticker->lazy_current < user_op->params.update.lazy) {
 1011b54:	4299      	cmp	r1, r3
 1011b56:	d996      	bls.n	1011a86 <ticker_job+0x386>
			ticks_to_expire += ticker->ticks_periodic +
 1011b58:	e9cd 9607 	strd	r9, r6, [sp, #28]
	ticker->remainder_current += ticker->remainder_periodic;
 1011b5c:	6a28      	ldr	r0, [r5, #32]
			ticks_to_expire += ticker->ticks_periodic +
 1011b5e:	f10c 0a01 	add.w	sl, ip, #1
 1011b62:	e008      	b.n	1011b76 <ticker_job+0x476>
	if ((ticker->remainder_current < BIT(31)) &&
 1011b64:	46e1      	mov	r9, ip
			ticker->lazy_current++;
 1011b66:	3301      	adds	r3, #1
 1011b68:	b29b      	uxth	r3, r3
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1011b6a:	6269      	str	r1, [r5, #36]	; 0x24
			ticker->lazy_current++;
 1011b6c:	83eb      	strh	r3, [r5, #30]
		while (ticker->lazy_current < user_op->params.update.lazy) {
 1011b6e:	8aa1      	ldrh	r1, [r4, #20]
			ticks_to_expire += ticker->ticks_periodic +
 1011b70:	444a      	add	r2, r9
		while (ticker->lazy_current < user_op->params.update.lazy) {
 1011b72:	4299      	cmp	r1, r3
 1011b74:	d985      	bls.n	1011a82 <ticker_job+0x382>
	ticker->remainder_current += ticker->remainder_periodic;
 1011b76:	6a69      	ldr	r1, [r5, #36]	; 0x24
	if ((ticker->remainder_current < BIT(31)) &&
 1011b78:	f8df 9138 	ldr.w	r9, [pc, #312]	; 1011cb4 <ticker_job+0x5b4>
 1011b7c:	4e4e      	ldr	r6, [pc, #312]	; (1011cb8 <ticker_job+0x5b8>)
	ticker->remainder_current += ticker->remainder_periodic;
 1011b7e:	4401      	add	r1, r0
	if ((ticker->remainder_current < BIT(31)) &&
 1011b80:	4489      	add	r9, r1
 1011b82:	45b1      	cmp	r9, r6
 1011b84:	d8ee      	bhi.n	1011b64 <ticker_job+0x464>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1011b86:	f1a1 71e8 	sub.w	r1, r1, #30408704	; 0x1d00000
 1011b8a:	f5a1 31d4 	sub.w	r1, r1, #108544	; 0x1a800
			ticks_to_expire += ticker->ticks_periodic +
 1011b8e:	46d1      	mov	r9, sl
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1011b90:	f5a1 71a5 	sub.w	r1, r1, #330	; 0x14a
		return 1;
 1011b94:	e7e7      	b.n	1011b66 <ticker_job+0x466>
				ticker->ticks_to_expire = ticks_elapsed;
 1011b96:	9a00      	ldr	r2, [sp, #0]
				ticker->req = ticker->ack;
 1011b98:	7893      	ldrb	r3, [r2, #2]
				ticker->ticks_to_expire = ticks_elapsed;
 1011b9a:	6097      	str	r7, [r2, #8]
				ticker->req = ticker->ack;
 1011b9c:	7053      	strb	r3, [r2, #1]
			ticks_to_expire_prep(ticker, instance->ticks_current,
 1011b9e:	9b06      	ldr	r3, [sp, #24]
 1011ba0:	9800      	ldr	r0, [sp, #0]
 1011ba2:	eb03 0209 	add.w	r2, r3, r9
 1011ba6:	f8da 1014 	ldr.w	r1, [sl, #20]
 1011baa:	f7ff fb6d 	bl	1011288 <ticks_to_expire_prep>
			ticker->next = *insert_head;
 1011bae:	9b01      	ldr	r3, [sp, #4]
			ticker->req = ticker->ack;
 1011bb0:	9a00      	ldr	r2, [sp, #0]
			ticker->next = *insert_head;
 1011bb2:	f803 4008 	strb.w	r4, [r3, r8]
			ticker->req++;
 1011bb6:	7843      	ldrb	r3, [r0, #1]
 1011bb8:	465c      	mov	r4, fp
 1011bba:	3301      	adds	r3, #1
 1011bbc:	b2db      	uxtb	r3, r3
			ticker->req = ticker->ack;
 1011bbe:	7053      	strb	r3, [r2, #1]
	while (instance->ticker_id_head != TICKER_NULL) {
 1011bc0:	f89a b018 	ldrb.w	fp, [sl, #24]
 1011bc4:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
 1011bc8:	f47f ae49 	bne.w	101185e <ticker_job+0x15e>
 1011bcc:	e695      	b.n	10118fa <ticker_job+0x1fa>
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
 1011bce:	9b00      	ldr	r3, [sp, #0]
 1011bd0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 1011bd2:	b113      	cbz	r3, 1011bda <ticker_job+0x4da>
 1011bd4:	7a1b      	ldrb	r3, [r3, #8]
 1011bd6:	2b01      	cmp	r3, #1
 1011bd8:	d0dd      	beq.n	1011b96 <ticker_job+0x496>
				if (!ticker->lazy_current) {
 1011bda:	9b00      	ldr	r3, [sp, #0]
 1011bdc:	f8b3 c01e 	ldrh.w	ip, [r3, #30]
 1011be0:	f1bc 0f00 	cmp.w	ip, #0
 1011be4:	d143      	bne.n	1011c6e <ticker_job+0x56e>
					lazy_periodic = ticker->lazy_periodic;
 1011be6:	f8b3 c01c 	ldrh.w	ip, [r3, #28]
				while (count--) {
 1011bea:	4660      	mov	r0, ip
 1011bec:	9d00      	ldr	r5, [sp, #0]
				ticks_to_expire = 0U;
 1011bee:	2200      	movs	r2, #0
	ticker->remainder_current += ticker->remainder_periodic;
 1011bf0:	e9d5 5308 	ldrd	r5, r3, [r5, #32]
 1011bf4:	e9cd 4603 	strd	r4, r6, [sp, #12]
 1011bf8:	f101 0e01 	add.w	lr, r1, #1
 1011bfc:	e004      	b.n	1011c08 <ticker_job+0x508>
	if ((ticker->remainder_current < BIT(31)) &&
 1011bfe:	460c      	mov	r4, r1
				while (count--) {
 1011c00:	3801      	subs	r0, #1
					ticks_to_expire +=
 1011c02:	4422      	add	r2, r4
				while (count--) {
 1011c04:	1c44      	adds	r4, r0, #1
 1011c06:	d010      	beq.n	1011c2a <ticker_job+0x52a>
	if ((ticker->remainder_current < BIT(31)) &&
 1011c08:	4c2a      	ldr	r4, [pc, #168]	; (1011cb4 <ticker_job+0x5b4>)
 1011c0a:	4e2b      	ldr	r6, [pc, #172]	; (1011cb8 <ticker_job+0x5b8>)
	ticker->remainder_current += ticker->remainder_periodic;
 1011c0c:	442b      	add	r3, r5
	if ((ticker->remainder_current < BIT(31)) &&
 1011c0e:	191c      	adds	r4, r3, r4
 1011c10:	42b4      	cmp	r4, r6
 1011c12:	d8f4      	bhi.n	1011bfe <ticker_job+0x4fe>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1011c14:	4674      	mov	r4, lr
 1011c16:	f1a3 73e8 	sub.w	r3, r3, #30408704	; 0x1d00000
				while (count--) {
 1011c1a:	3801      	subs	r0, #1
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1011c1c:	f5a3 33d4 	sub.w	r3, r3, #108544	; 0x1a800
					ticks_to_expire +=
 1011c20:	4422      	add	r2, r4
				while (count--) {
 1011c22:	1c44      	adds	r4, r0, #1
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1011c24:	f5a3 73a5 	sub.w	r3, r3, #330	; 0x14a
				while (count--) {
 1011c28:	d1ee      	bne.n	1011c08 <ticker_job+0x508>
 1011c2a:	e9dd 4603 	ldrd	r4, r6, [sp, #12]
 1011c2e:	9800      	ldr	r0, [sp, #0]
 1011c30:	6243      	str	r3, [r0, #36]	; 0x24
				} else if (!ticker->must_expire) {
 1011c32:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 1011c36:	2800      	cmp	r0, #0
 1011c38:	f000 812c 	beq.w	1011e94 <ticker_job+0x794>
				ticker->ticks_to_expire = ticks_to_expire;
 1011c3c:	9b00      	ldr	r3, [sp, #0]
 1011c3e:	609a      	str	r2, [r3, #8]
				ticker->lazy_current += (lazy_periodic + lazy);
 1011c40:	f8a3 c01e 	strh.w	ip, [r3, #30]
 1011c44:	e7ab      	b.n	1011b9e <ticker_job+0x49e>
		while (ticker->lazy_current < user_op->params.update.lazy) {
 1011c46:	9e07      	ldr	r6, [sp, #28]
 1011c48:	8aa1      	ldrh	r1, [r4, #20]
 1011c4a:	e783      	b.n	1011b54 <ticker_job+0x454>
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
 1011c4c:	2800      	cmp	r0, #0
 1011c4e:	f47f ae2e 	bne.w	10118ae <ticker_job+0x1ae>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
 1011c52:	9a00      	ldr	r2, [sp, #0]
 1011c54:	6a92      	ldr	r2, [r2, #40]	; 0x28
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
 1011c56:	b11a      	cbz	r2, 1011c60 <ticker_job+0x560>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
 1011c58:	7a12      	ldrb	r2, [r2, #8]
 1011c5a:	2a01      	cmp	r2, #1
 1011c5c:	f43f ae27 	beq.w	10118ae <ticker_job+0x1ae>
			instance->ticks_slot_previous = ticker->ticks_slot;
 1011c60:	9a00      	ldr	r2, [sp, #0]
			instance->ticker_id_slot_previous = id_expired;
 1011c62:	f88a b01b 	strb.w	fp, [sl, #27]
			instance->ticks_slot_previous = ticker->ticks_slot;
 1011c66:	6992      	ldr	r2, [r2, #24]
 1011c68:	f8ca 201c 	str.w	r2, [sl, #28]
 1011c6c:	e61f      	b.n	10118ae <ticker_job+0x1ae>
					ticker->req = ticker->ack;
 1011c6e:	9a00      	ldr	r2, [sp, #0]
				while (count--) {
 1011c70:	2000      	movs	r0, #0
					ticker->req = ticker->ack;
 1011c72:	7893      	ldrb	r3, [r2, #2]
 1011c74:	7053      	strb	r3, [r2, #1]
				while (count--) {
 1011c76:	e7b9      	b.n	1011bec <ticker_job+0x4ec>
		ticker_job_list_insert(instance, insert_head);
 1011c78:	4650      	mov	r0, sl
 1011c7a:	9904      	ldr	r1, [sp, #16]
 1011c7c:	f7ff fb28 	bl	10112d0 <ticker_job_list_insert>
	if (instance->ticker_id_head != ticker_id_old_head) {
 1011c80:	f89a 3018 	ldrb.w	r3, [sl, #24]
 1011c84:	429e      	cmp	r6, r3
 1011c86:	d119      	bne.n	1011cbc <ticker_job+0x5bc>
	if (flag_compare_update) {
 1011c88:	42b5      	cmp	r5, r6
 1011c8a:	d117      	bne.n	1011cbc <ticker_job+0x5bc>
	instance->job_guard = 0U;
 1011c8c:	2200      	movs	r2, #0
	if (instance->worker_trigger || compare_trigger) {
 1011c8e:	f89a 301a 	ldrb.w	r3, [sl, #26]
	instance->job_guard = 0U;
 1011c92:	f88a 2019 	strb.w	r2, [sl, #25]
	if (instance->worker_trigger || compare_trigger) {
 1011c96:	2b00      	cmp	r3, #0
 1011c98:	f000 80f9 	beq.w	1011e8e <ticker_job+0x78e>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
 1011c9c:	f8da 4024 	ldr.w	r4, [sl, #36]	; 0x24
 1011ca0:	4653      	mov	r3, sl
 1011ca2:	2201      	movs	r2, #1
 1011ca4:	2103      	movs	r1, #3
 1011ca6:	2004      	movs	r0, #4
 1011ca8:	46a4      	mov	ip, r4
}
 1011caa:	b00d      	add	sp, #52	; 0x34
 1011cac:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
 1011cb0:	4760      	bx	ip
 1011cb2:	bf00      	nop
 1011cb4:	ff172b5a 	.word	0xff172b5a
 1011cb8:	7f172b59 	.word	0x7f172b59
	if (instance->ticker_id_head == TICKER_NULL) {
 1011cbc:	2bff      	cmp	r3, #255	; 0xff
 1011cbe:	f000 80d3 	beq.w	1011e68 <ticker_job+0x768>
	if (ticker_id_old_head == TICKER_NULL) {
 1011cc2:	2eff      	cmp	r6, #255	; 0xff
 1011cc4:	f000 812a 	beq.w	1011f1c <ticker_job+0x81c>
	ticks_to_expire = ticker->ticks_to_expire;
 1011cc8:	f8da 2000 	ldr.w	r2, [sl]
 1011ccc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 1011cd0:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 1011cd4:	6896      	ldr	r6, [r2, #8]
	if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) && !ticks_to_expire) {
 1011cd6:	2e00      	cmp	r6, #0
 1011cd8:	f000 8116 	beq.w	1011f08 <ticker_job+0x808>
	i = 10U;
 1011cdc:	250a      	movs	r5, #10
		LL_ASSERT(i);
 1011cde:	f8df 926c 	ldr.w	r9, [pc, #620]	; 1011f4c <ticker_job+0x84c>
 1011ce2:	f8df 826c 	ldr.w	r8, [pc, #620]	; 1011f50 <ticker_job+0x850>
 1011ce6:	4f9b      	ldr	r7, [pc, #620]	; (1011f54 <ticker_job+0x854>)
		ctr = cntr_cnt_get();
 1011ce8:	f00b f9b8 	bl	101d05c <cntr_cnt_get>
		cc = instance->ticks_current;
 1011cec:	f8da 4014 	ldr.w	r4, [sl, #20]
		ctr = cntr_cnt_get();
 1011cf0:	4683      	mov	fp, r0
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1011cf2:	1b02      	subs	r2, r0, r4
 1011cf4:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
		ticks_elapsed = ticker_ticks_diff_get(ctr, cc) +
 1011cf8:	3203      	adds	r2, #3
		cc += MAX(ticks_elapsed, ticks_to_expire);
 1011cfa:	42b2      	cmp	r2, r6
 1011cfc:	bf2c      	ite	cs
 1011cfe:	18a4      	addcs	r4, r4, r2
 1011d00:	19a4      	addcc	r4, r4, r6
		cc &= HAL_TICKER_CNTR_MASK;
 1011d02:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
		instance->trigger_set_cb(cc);
 1011d06:	4620      	mov	r0, r4
 1011d08:	f8da 3028 	ldr.w	r3, [sl, #40]	; 0x28
 1011d0c:	4798      	blx	r3
		ctr_post = cntr_cnt_get();
 1011d0e:	f00b f9a5 	bl	101d05c <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1011d12:	eba0 030b 	sub.w	r3, r0, fp
 1011d16:	eba4 040b 	sub.w	r4, r4, fp
 1011d1a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 1011d1e:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
	} while ((ticker_ticks_diff_get(ctr_post, ctr) +
 1011d22:	3303      	adds	r3, #3
		  HAL_TICKER_CNTR_CMP_OFFSET_MIN) >
 1011d24:	42a3      	cmp	r3, r4
		i--;
 1011d26:	f105 35ff 	add.w	r5, r5, #4294967295
		  HAL_TICKER_CNTR_CMP_OFFSET_MIN) >
 1011d2a:	d9af      	bls.n	1011c8c <ticker_job+0x58c>
		LL_ASSERT(i);
 1011d2c:	2d00      	cmp	r5, #0
 1011d2e:	d1db      	bne.n	1011ce8 <ticker_job+0x5e8>
 1011d30:	f640 13cc 	movw	r3, #2508	; 0x9cc
 1011d34:	464a      	mov	r2, r9
 1011d36:	4641      	mov	r1, r8
 1011d38:	4638      	mov	r0, r7
 1011d3a:	f012 ff4c 	bl	1024bd6 <assert_print>
 1011d3e:	4040      	eors	r0, r0
 1011d40:	f380 8811 	msr	BASEPRI, r0
 1011d44:	f04f 0003 	mov.w	r0, #3
 1011d48:	df02      	svc	2
 1011d4a:	e7cd      	b.n	1011ce8 <ticker_job+0x5e8>
		if (instance->ticks_slot_previous > ticks_elapsed) {
 1011d4c:	f8da 701c 	ldr.w	r7, [sl, #28]
 1011d50:	9b02      	ldr	r3, [sp, #8]
		ticker_id_iter = nodes[ticker_id_head].next;
 1011d52:	f81b 4001 	ldrb.w	r4, [fp, r1]
		if (instance->ticks_slot_previous > ticks_elapsed) {
 1011d56:	42bb      	cmp	r3, r7
			window_start_ticks = instance->ticks_slot_previous -
 1011d58:	bf34      	ite	cc
 1011d5a:	1aff      	subcc	r7, r7, r3
		window_start_ticks = 0U;
 1011d5c:	2700      	movcs	r7, #0
		if (ext_data->ticks_drift < ext_data->ticks_slot_window) {
 1011d5e:	e9d2 3900 	ldrd	r3, r9, [r2]
 1011d62:	4599      	cmp	r9, r3
 1011d64:	d26b      	bcs.n	1011e3e <ticker_job+0x73e>
		while (ticker_id_iter != TICKER_NULL &&
 1011d66:	2cff      	cmp	r4, #255	; 0xff
			ticks_slot_window = ext_data->ticks_slot_window -
 1011d68:	eba3 0e09 	sub.w	lr, r3, r9
		while (ticker_id_iter != TICKER_NULL &&
 1011d6c:	d067      	beq.n	1011e3e <ticker_job+0x73e>
		       ticks_start_offset + ticker->ticks_slot <=
 1011d6e:	f8d6 c018 	ldr.w	ip, [r6, #24]
		while (ticker_id_iter != TICKER_NULL &&
 1011d72:	45e6      	cmp	lr, ip
 1011d74:	d363      	bcc.n	1011e3e <ticker_job+0x73e>
 1011d76:	2300      	movs	r3, #0
		       ticks_start_offset + ticker->ticks_slot <=
 1011d78:	46e0      	mov	r8, ip
		while (ticker_id_iter != TICKER_NULL &&
 1011d7a:	461d      	mov	r5, r3
 1011d7c:	e9cd 6200 	strd	r6, r2, [sp]
 1011d80:	e01b      	b.n	1011dba <ticker_job+0x6ba>
			if (node->ticks_to_expire >
 1011d82:	6896      	ldr	r6, [r2, #8]
					MIN(ticks_slot_window,
 1011d84:	1f33      	subs	r3, r6, #4
			if (node->ticks_to_expire >
 1011d86:	2e04      	cmp	r6, #4
					MIN(ticks_slot_window,
 1011d88:	442b      	add	r3, r5
			if (node->ticks_to_expire >
 1011d8a:	d909      	bls.n	1011da0 <ticker_job+0x6a0>
				window_end_ticks =
 1011d8c:	4573      	cmp	r3, lr
 1011d8e:	bf28      	it	cs
 1011d90:	4673      	movcs	r3, lr
			if (window_end_ticks > ticks_start_offset +
 1011d92:	4543      	cmp	r3, r8
 1011d94:	d904      	bls.n	1011da0 <ticker_job+0x6a0>
			if (ticks_to_expire != 0U &&
 1011d96:	ebb3 030c 	subs.w	r3, r3, ip
 1011d9a:	d001      	beq.n	1011da0 <ticker_job+0x6a0>
 1011d9c:	42bb      	cmp	r3, r7
 1011d9e:	d21d      	bcs.n	1011ddc <ticker_job+0x6dc>
			ticker_id_iter = node->next;
 1011da0:	f81b 4004 	ldrb.w	r4, [fp, r4]
			window_start_ticks  = node->ticks_to_expire +
 1011da4:	6997      	ldr	r7, [r2, #24]
			ticks_start_offset += node->ticks_to_expire;
 1011da6:	4435      	add	r5, r6
		while (ticker_id_iter != TICKER_NULL &&
 1011da8:	2cff      	cmp	r4, #255	; 0xff
			window_start_ticks  = node->ticks_to_expire +
 1011daa:	4437      	add	r7, r6
			ticks_to_expire     = ticks_slot_window -
 1011dac:	ebae 030c 	sub.w	r3, lr, ip
		       ticks_start_offset + ticker->ticks_slot <=
 1011db0:	eb05 080c 	add.w	r8, r5, ip
		while (ticker_id_iter != TICKER_NULL &&
 1011db4:	d012      	beq.n	1011ddc <ticker_job+0x6dc>
 1011db6:	45c6      	cmp	lr, r8
 1011db8:	d310      	bcc.n	1011ddc <ticker_job+0x6dc>
			node = &nodes[ticker_id_iter];
 1011dba:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 1011dbe:	eb0b 1204 	add.w	r2, fp, r4, lsl #4
			if (node->ext_data &&
 1011dc2:	6a96      	ldr	r6, [r2, #40]	; 0x28
			node = &nodes[ticker_id_iter];
 1011dc4:	0124      	lsls	r4, r4, #4
			if (node->ext_data &&
 1011dc6:	2e00      	cmp	r6, #0
 1011dc8:	d0db      	beq.n	1011d82 <ticker_job+0x682>
 1011dca:	7a36      	ldrb	r6, [r6, #8]
 1011dcc:	2e01      	cmp	r6, #1
 1011dce:	d1d8      	bne.n	1011d82 <ticker_job+0x682>
				ticker_id_iter = node->next;
 1011dd0:	f81b 4004 	ldrb.w	r4, [fp, r4]
		       ticks_start_offset + ticker->ticks_slot <=
 1011dd4:	eb05 080c 	add.w	r8, r5, ip
		while (ticker_id_iter != TICKER_NULL &&
 1011dd8:	2cff      	cmp	r4, #255	; 0xff
 1011dda:	d1ec      	bne.n	1011db6 <ticker_job+0x6b6>
		ticker->ext_data->ticks_drift += ticks_to_expire -
 1011ddc:	e9dd 6200 	ldrd	r6, r2, [sp]
 1011de0:	68b4      	ldr	r4, [r6, #8]
 1011de2:	eba9 0404 	sub.w	r4, r9, r4
 1011de6:	441c      	add	r4, r3
 1011de8:	6054      	str	r4, [r2, #4]
		ticker->ticks_to_expire = ticks_to_expire;
 1011dea:	60b3      	str	r3, [r6, #8]
		ticker_id_iter = nodes[ticker_id_head].next;
 1011dec:	f81b 5001 	ldrb.w	r5, [fp, r1]
		while (ticker_id_iter != TICKER_NULL) {
 1011df0:	2dff      	cmp	r5, #255	; 0xff
 1011df2:	d02a      	beq.n	1011e4a <ticker_job+0x74a>
		ticker_id_prev = TICKER_NULL;
 1011df4:	f04f 0eff 	mov.w	lr, #255	; 0xff
 1011df8:	e000      	b.n	1011dfc <ticker_job+0x6fc>
			ticker_id_iter = node->next;
 1011dfa:	4625      	mov	r5, r4
			node = &nodes[ticker_id_iter];
 1011dfc:	eb05 0445 	add.w	r4, r5, r5, lsl #1
 1011e00:	eb0b 1c04 	add.w	ip, fp, r4, lsl #4
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
 1011e04:	f8dc 7008 	ldr.w	r7, [ip, #8]
			node = &nodes[ticker_id_iter];
 1011e08:	0124      	lsls	r4, r4, #4
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
 1011e0a:	429f      	cmp	r7, r3
 1011e0c:	f080 8098 	bcs.w	1011f40 <ticker_job+0x840>
				ticker->ticks_to_expire -=
 1011e10:	1bdb      	subs	r3, r3, r7
 1011e12:	60b3      	str	r3, [r6, #8]
			ticker_id_iter = node->next;
 1011e14:	f81b 4004 	ldrb.w	r4, [fp, r4]
		while (ticker_id_iter != TICKER_NULL) {
 1011e18:	46ae      	mov	lr, r5
 1011e1a:	2cff      	cmp	r4, #255	; 0xff
 1011e1c:	d1ed      	bne.n	1011dfa <ticker_job+0x6fa>
		if (ticker_id_prev != TICKER_NULL) {
 1011e1e:	2dff      	cmp	r5, #255	; 0xff
 1011e20:	d013      	beq.n	1011e4a <ticker_job+0x74a>
			instance->ticker_id_head = nodes[ticker_id_head].next;
 1011e22:	f81b 3001 	ldrb.w	r3, [fp, r1]
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
 1011e26:	eb05 0545 	add.w	r5, r5, r5, lsl #1
			instance->ticker_id_head = nodes[ticker_id_head].next;
 1011e2a:	f88a 3018 	strb.w	r3, [sl, #24]
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
 1011e2e:	012d      	lsls	r5, r5, #4
 1011e30:	f81b 3005 	ldrb.w	r3, [fp, r5]
 1011e34:	f80b 3001 	strb.w	r3, [fp, r1]
			nodes[ticker_id_prev].next = ticker_id_head;
 1011e38:	f80b 0005 	strb.w	r0, [fp, r5]
 1011e3c:	e005      	b.n	1011e4a <ticker_job+0x74a>
		ticker->ext_data->ticks_drift += ticks_to_expire -
 1011e3e:	68b3      	ldr	r3, [r6, #8]
 1011e40:	eba9 0303 	sub.w	r3, r9, r3
 1011e44:	6053      	str	r3, [r2, #4]
		ticker->ticks_to_expire = ticks_to_expire;
 1011e46:	2300      	movs	r3, #0
 1011e48:	60b3      	str	r3, [r6, #8]
		ticker->lazy_current--;
 1011e4a:	8bf3      	ldrh	r3, [r6, #30]
		rescheduled  = 1U;
 1011e4c:	2401      	movs	r4, #1
		ticker->lazy_current--;
 1011e4e:	3b01      	subs	r3, #1
 1011e50:	83f3      	strh	r3, [r6, #30]
		ext_data->reschedule_state =
 1011e52:	f04f 0302 	mov.w	r3, #2
 1011e56:	7213      	strb	r3, [r2, #8]
		ticker_id_head = instance->ticker_id_head;
 1011e58:	f89a 3018 	ldrb.w	r3, [sl, #24]
		while (ticker_id_head != TICKER_NULL) {
 1011e5c:	2bff      	cmp	r3, #255	; 0xff
 1011e5e:	f47f ad62 	bne.w	1011926 <ticker_job+0x226>
		if (ticker_job_reschedule_in_window(instance, ticks_elapsed)) {
 1011e62:	9e03      	ldr	r6, [sp, #12]
 1011e64:	2c00      	cmp	r4, #0
 1011e66:	d052      	beq.n	1011f0e <ticker_job+0x80e>
		if (cntr_stop() == 0) {
 1011e68:	f00b f8d2 	bl	101d010 <cntr_stop>
 1011e6c:	4604      	mov	r4, r0
 1011e6e:	2800      	cmp	r0, #0
 1011e70:	f47f af0c 	bne.w	1011c8c <ticker_job+0x58c>
			instance->ticks_slot_previous = 0U;
 1011e74:	f8ca 001c 	str.w	r0, [sl, #28]
			instance->ticks_current = cntr_cnt_get();
 1011e78:	f00b f8f0 	bl	101d05c <cntr_cnt_get>
	if (instance->worker_trigger || compare_trigger) {
 1011e7c:	f89a 301a 	ldrb.w	r3, [sl, #26]
	instance->job_guard = 0U;
 1011e80:	f88a 4019 	strb.w	r4, [sl, #25]
			instance->ticks_current = cntr_cnt_get();
 1011e84:	f8ca 0014 	str.w	r0, [sl, #20]
	if (instance->worker_trigger || compare_trigger) {
 1011e88:	2b00      	cmp	r3, #0
 1011e8a:	f47f af07 	bne.w	1011c9c <ticker_job+0x59c>
}
 1011e8e:	b00d      	add	sp, #52	; 0x34
 1011e90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					while (ticks_to_expire <
 1011e94:	4296      	cmp	r6, r2
 1011e96:	f67f aed1 	bls.w	1011c3c <ticker_job+0x53c>
				lazy = 0U;
 1011e9a:	9003      	str	r0, [sp, #12]
 1011e9c:	1c48      	adds	r0, r1, #1
 1011e9e:	9004      	str	r0, [sp, #16]
 1011ea0:	e9cd 470a 	strd	r4, r7, [sp, #40]	; 0x28
 1011ea4:	e9dd 0703 	ldrd	r0, r7, [sp, #12]
	if ((ticker->remainder_current < BIT(31)) &&
 1011ea8:	f8df e0ac 	ldr.w	lr, [pc, #172]	; 1011f58 <ticker_job+0x858>
 1011eac:	e005      	b.n	1011eba <ticker_job+0x7ba>
 1011eae:	460c      	mov	r4, r1
						ticks_to_expire +=
 1011eb0:	4422      	add	r2, r4
						lazy++;
 1011eb2:	3001      	adds	r0, #1
					while (ticks_to_expire <
 1011eb4:	4296      	cmp	r6, r2
						lazy++;
 1011eb6:	b280      	uxth	r0, r0
					while (ticks_to_expire <
 1011eb8:	d910      	bls.n	1011edc <ticker_job+0x7dc>
	if ((ticker->remainder_current < BIT(31)) &&
 1011eba:	4c28      	ldr	r4, [pc, #160]	; (1011f5c <ticker_job+0x85c>)
	ticker->remainder_current += ticker->remainder_periodic;
 1011ebc:	442b      	add	r3, r5
	if ((ticker->remainder_current < BIT(31)) &&
 1011ebe:	191c      	adds	r4, r3, r4
 1011ec0:	4574      	cmp	r4, lr
 1011ec2:	d8f4      	bhi.n	1011eae <ticker_job+0x7ae>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1011ec4:	463c      	mov	r4, r7
 1011ec6:	f1a3 73e8 	sub.w	r3, r3, #30408704	; 0x1d00000
						ticks_to_expire +=
 1011eca:	4422      	add	r2, r4
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1011ecc:	f5a3 33d4 	sub.w	r3, r3, #108544	; 0x1a800
						lazy++;
 1011ed0:	3001      	adds	r0, #1
					while (ticks_to_expire <
 1011ed2:	4296      	cmp	r6, r2
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1011ed4:	f5a3 73a5 	sub.w	r3, r3, #330	; 0x14a
						lazy++;
 1011ed8:	b280      	uxth	r0, r0
					while (ticks_to_expire <
 1011eda:	d8ee      	bhi.n	1011eba <ticker_job+0x7ba>
				ticker->lazy_current += (lazy_periodic + lazy);
 1011edc:	e9dd 470a 	ldrd	r4, r7, [sp, #40]	; 0x28
 1011ee0:	9900      	ldr	r1, [sp, #0]
 1011ee2:	4460      	add	r0, ip
 1011ee4:	624b      	str	r3, [r1, #36]	; 0x24
 1011ee6:	fa1f fc80 	uxth.w	ip, r0
 1011eea:	e6a7      	b.n	1011c3c <ticker_job+0x53c>
 1011eec:	4770      	bx	lr
		flag_elapsed = 0U;
 1011eee:	9b05      	ldr	r3, [sp, #20]
 1011ef0:	9309      	str	r3, [sp, #36]	; 0x24
		ticks_elapsed = 0U;
 1011ef2:	9302      	str	r3, [sp, #8]
 1011ef4:	e430      	b.n	1011758 <ticker_job+0x58>
			ticker->ticks_to_expire -= ticks_elapsed;
 1011ef6:	9404      	str	r4, [sp, #16]
 1011ef8:	9c00      	ldr	r4, [sp, #0]
 1011efa:	1bd2      	subs	r2, r2, r7
 1011efc:	60a2      	str	r2, [r4, #8]
		if (instance->ticker_id_head != ticker_id_old_head) {
 1011efe:	f89a b018 	ldrb.w	fp, [sl, #24]
			ticker->ticks_to_expire -= ticks_elapsed;
 1011f02:	e9dd 5607 	ldrd	r5, r6, [sp, #28]
			break;
 1011f06:	e4fb      	b.n	1011900 <ticker_job+0x200>
	instance->job_guard = 0U;
 1011f08:	f88a 6019 	strb.w	r6, [sl, #25]
	if (instance->worker_trigger || compare_trigger) {
 1011f0c:	e6c6      	b.n	1011c9c <ticker_job+0x59c>
	if (instance->ticker_id_head != ticker_id_old_head) {
 1011f0e:	2eff      	cmp	r6, #255	; 0xff
 1011f10:	d1aa      	bne.n	1011e68 <ticker_job+0x768>
	if (flag_compare_update) {
 1011f12:	9b09      	ldr	r3, [sp, #36]	; 0x24
 1011f14:	2b00      	cmp	r3, #0
 1011f16:	f43f aeb9 	beq.w	1011c8c <ticker_job+0x58c>
 1011f1a:	e7a5      	b.n	1011e68 <ticker_job+0x768>
		ticks_current = cntr_cnt_get();
 1011f1c:	f00b f89e 	bl	101d05c <cntr_cnt_get>
 1011f20:	4604      	mov	r4, r0
		if (cntr_start() == 0) {
 1011f22:	f00b f865 	bl	101cff0 <cntr_start>
 1011f26:	f89a 3018 	ldrb.w	r3, [sl, #24]
 1011f2a:	2800      	cmp	r0, #0
 1011f2c:	f47f aecc 	bne.w	1011cc8 <ticker_job+0x5c8>
			instance->ticks_current = ticks_current;
 1011f30:	f8ca 4014 	str.w	r4, [sl, #20]
 1011f34:	e6c8      	b.n	1011cc8 <ticker_job+0x5c8>
	insert_head = TICKER_NULL;
 1011f36:	23ff      	movs	r3, #255	; 0xff
 1011f38:	9304      	str	r3, [sp, #16]
 1011f3a:	e476      	b.n	101182a <ticker_job+0x12a>
	while (instance->ticker_id_head != TICKER_NULL) {
 1011f3c:	46ab      	mov	fp, r5
 1011f3e:	e4df      	b.n	1011900 <ticker_job+0x200>
				node->ticks_to_expire -=
 1011f40:	1aff      	subs	r7, r7, r3
				break;
 1011f42:	4675      	mov	r5, lr
				node->ticks_to_expire -=
 1011f44:	f8cc 7008 	str.w	r7, [ip, #8]
				break;
 1011f48:	e769      	b.n	1011e1e <ticker_job+0x71e>
 1011f4a:	bf00      	nop
 1011f4c:	0102a238 	.word	0x0102a238
 1011f50:	0102a32c 	.word	0x0102a32c
 1011f54:	0102a278 	.word	0x0102a278
 1011f58:	7f172b59 	.word	0x7f172b59
 1011f5c:	ff172b5a 	.word	0xff172b5a

01011f60 <ticker_init>:
{
 1011f60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1011f62:	9e06      	ldr	r6, [sp, #24]
 1011f64:	f89d 401c 	ldrb.w	r4, [sp, #28]
 1011f68:	9d08      	ldr	r5, [sp, #32]
	if (instance_index >= TICKER_INSTANCE_MAX) {
 1011f6a:	b9b0      	cbnz	r0, 1011f9a <ticker_init+0x3a>
	instance->count_node = count_node;
 1011f6c:	4f14      	ldr	r7, [pc, #80]	; (1011fc0 <ticker_init+0x60>)
	instance->nodes = node;
 1011f6e:	603a      	str	r2, [r7, #0]
	while (count_user--) {
 1011f70:	1e5a      	subs	r2, r3, #1
	instance->count_node = count_node;
 1011f72:	7239      	strb	r1, [r7, #8]
	instance->count_user = count_user;
 1011f74:	727b      	strb	r3, [r7, #9]
	instance->users = user;
 1011f76:	607e      	str	r6, [r7, #4]
	while (count_user--) {
 1011f78:	b2d2      	uxtb	r2, r2
 1011f7a:	b16b      	cbz	r3, 1011f98 <ticker_init+0x38>
		user_op_ += users[count_user].count_user_op;
 1011f7c:	2034      	movs	r0, #52	; 0x34
 1011f7e:	eb06 03c2 	add.w	r3, r6, r2, lsl #3
		users[count_user].user_op = user_op_;
 1011f82:	4619      	mov	r1, r3
 1011f84:	605d      	str	r5, [r3, #4]
		user_op_ += users[count_user].count_user_op;
 1011f86:	f813 2908 	ldrb.w	r2, [r3], #-8
	while (count_user--) {
 1011f8a:	428e      	cmp	r6, r1
		count_op -= users[count_user].count_user_op;
 1011f8c:	eba4 0402 	sub.w	r4, r4, r2
		user_op_ += users[count_user].count_user_op;
 1011f90:	fb00 5502 	mla	r5, r0, r2, r5
		count_op -= users[count_user].count_user_op;
 1011f94:	b2e4      	uxtb	r4, r4
	while (count_user--) {
 1011f96:	d1f4      	bne.n	1011f82 <ticker_init+0x22>
	if (count_op) {
 1011f98:	b10c      	cbz	r4, 1011f9e <ticker_init+0x3e>
		return TICKER_STATUS_FAILURE;
 1011f9a:	2001      	movs	r0, #1
}
 1011f9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	instance->ticker_id_head = TICKER_NULL;
 1011f9e:	25ff      	movs	r5, #255	; 0xff
	instance->caller_id_get_cb = caller_id_get_cb;
 1011fa0:	9b09      	ldr	r3, [sp, #36]	; 0x24
	instance->ticker_id_head = TICKER_NULL;
 1011fa2:	763d      	strb	r5, [r7, #24]
	instance->caller_id_get_cb = caller_id_get_cb;
 1011fa4:	623b      	str	r3, [r7, #32]
	instance->sched_cb = sched_cb;
 1011fa6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 1011fa8:	627b      	str	r3, [r7, #36]	; 0x24
	instance->trigger_set_cb = trigger_set_cb;
 1011faa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 1011fac:	62bb      	str	r3, [r7, #40]	; 0x28
	instance->ticks_current = cntr_cnt_get();
 1011fae:	f00b f855 	bl	101d05c <cntr_cnt_get>
 1011fb2:	4603      	mov	r3, r0
	instance->ticks_elapsed_first = 0U;
 1011fb4:	817c      	strh	r4, [r7, #10]
	instance->ticker_id_slot_previous = TICKER_NULL;
 1011fb6:	76fd      	strb	r5, [r7, #27]
	instance->ticks_slot_previous = 0U;
 1011fb8:	61fc      	str	r4, [r7, #28]
	instance->ticks_current = cntr_cnt_get();
 1011fba:	617b      	str	r3, [r7, #20]
	return TICKER_STATUS_SUCCESS;
 1011fbc:	4620      	mov	r0, r4
}
 1011fbe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1011fc0:	21004ca0 	.word	0x21004ca0

01011fc4 <ticker_is_initialized>:
	return !!(_instance[instance_index].count_node);
 1011fc4:	222c      	movs	r2, #44	; 0x2c
 1011fc6:	4b04      	ldr	r3, [pc, #16]	; (1011fd8 <ticker_is_initialized+0x14>)
 1011fc8:	fb02 3300 	mla	r3, r2, r0, r3
 1011fcc:	7a18      	ldrb	r0, [r3, #8]
}
 1011fce:	3800      	subs	r0, #0
 1011fd0:	bf18      	it	ne
 1011fd2:	2001      	movne	r0, #1
 1011fd4:	4770      	bx	lr
 1011fd6:	bf00      	nop
 1011fd8:	21004ca0 	.word	0x21004ca0

01011fdc <ticker_trigger>:
	if (instance->sched_cb) {
 1011fdc:	222c      	movs	r2, #44	; 0x2c
 1011fde:	4b07      	ldr	r3, [pc, #28]	; (1011ffc <ticker_trigger+0x20>)
{
 1011fe0:	b410      	push	{r4}
	if (instance->sched_cb) {
 1011fe2:	fb02 3300 	mla	r3, r2, r0, r3
 1011fe6:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 1011fe8:	b12c      	cbz	r4, 1011ff6 <ticker_trigger+0x1a>
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
 1011fea:	46a4      	mov	ip, r4
 1011fec:	2201      	movs	r2, #1
 1011fee:	2103      	movs	r1, #3
 1011ff0:	2002      	movs	r0, #2
}
 1011ff2:	bc10      	pop	{r4}
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
 1011ff4:	4760      	bx	ip
}
 1011ff6:	bc10      	pop	{r4}
 1011ff8:	4770      	bx	lr
 1011ffa:	bf00      	nop
 1011ffc:	21004ca0 	.word	0x21004ca0

01012000 <ticker_start_ext>:
{
 1012000:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct ticker_instance *instance = &_instance[instance_index];
 1012004:	242c      	movs	r4, #44	; 0x2c
 1012006:	4d24      	ldr	r5, [pc, #144]	; (1012098 <ticker_start_ext+0x98>)
{
 1012008:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
	struct ticker_instance *instance = &_instance[instance_index];
 101200c:	fb04 5500 	mla	r5, r4, r0, r5
	user = &instance->users[user_id];
 1012010:	6868      	ldr	r0, [r5, #4]
 1012012:	eb00 06c1 	add.w	r6, r0, r1, lsl #3
	last = user->last + 1;
 1012016:	78f4      	ldrb	r4, [r6, #3]
	if (last >= user->count_user_op) {
 1012018:	f810 7031 	ldrb.w	r7, [r0, r1, lsl #3]
	last = user->last + 1;
 101201c:	f104 0c01 	add.w	ip, r4, #1
 1012020:	fa5f fc8c 	uxtb.w	ip, ip
		last = 0U;
 1012024:	4567      	cmp	r7, ip
 1012026:	bf98      	it	ls
 1012028:	f04f 0c00 	movls.w	ip, #0
	if (last == user->first) {
 101202c:	7870      	ldrb	r0, [r6, #1]
 101202e:	4560      	cmp	r0, ip
 1012030:	d02f      	beq.n	1012092 <ticker_start_ext+0x92>
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 1012032:	4608      	mov	r0, r1
	user_op = &user->user_op[user->last];
 1012034:	2134      	movs	r1, #52	; 0x34
	user_op->op = TICKER_USER_OP_TYPE_START;
 1012036:	2704      	movs	r7, #4
	user_op->status = TICKER_STATUS_BUSY;
 1012038:	f04f 0902 	mov.w	r9, #2
	user_op = &user->user_op[user->last];
 101203c:	fb01 fe04 	mul.w	lr, r1, r4
 1012040:	6871      	ldr	r1, [r6, #4]
 1012042:	eb01 040e 	add.w	r4, r1, lr
	user_op->op = TICKER_USER_OP_TYPE_START;
 1012046:	f801 700e 	strb.w	r7, [r1, lr]
	user_op->params.start.ticks_at_start = ticks_anchor;
 101204a:	6063      	str	r3, [r4, #4]
	user_op->params.start.ticks_first = ticks_first;
 101204c:	9b08      	ldr	r3, [sp, #32]
	user_op->id = ticker_id;
 101204e:	7062      	strb	r2, [r4, #1]
	user_op->params.start.ticks_first = ticks_first;
 1012050:	60a3      	str	r3, [r4, #8]
	user_op->params.start.ticks_periodic = ticks_periodic;
 1012052:	9b09      	ldr	r3, [sp, #36]	; 0x24
	user_op->params.start.lazy = lazy;
 1012054:	f8a4 8014 	strh.w	r8, [r4, #20]
	user_op->params.start.ticks_periodic = ticks_periodic;
 1012058:	60e3      	str	r3, [r4, #12]
	user_op->params.start.remainder_periodic = remainder_periodic;
 101205a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	user_op->status = TICKER_STATUS_BUSY;
 101205c:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
	user_op->params.start.remainder_periodic = remainder_periodic;
 1012060:	6123      	str	r3, [r4, #16]
	user_op->params.start.ticks_slot = ticks_slot;
 1012062:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 1012064:	61a3      	str	r3, [r4, #24]
	user_op->params.start.ext_data = ext_data;
 1012066:	9b11      	ldr	r3, [sp, #68]	; 0x44
 1012068:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->params.start.fp_timeout_func = fp_timeout_func;
 101206a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 101206c:	61e3      	str	r3, [r4, #28]
	user_op->params.start.context = context;
 101206e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 1012070:	6223      	str	r3, [r4, #32]
	user_op->fp_op_func = fp_op_func;
 1012072:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 1012074:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
 1012076:	9b10      	ldr	r3, [sp, #64]	; 0x40
 1012078:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
 101207a:	f886 c003 	strb.w	ip, [r6, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 101207e:	e9d5 3608 	ldrd	r3, r6, [r5, #32]
 1012082:	4798      	blx	r3
 1012084:	462b      	mov	r3, r5
 1012086:	4639      	mov	r1, r7
 1012088:	2200      	movs	r2, #0
 101208a:	47b0      	blx	r6
	return user_op->status;
 101208c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
 101208e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
 1012092:	2001      	movs	r0, #1
}
 1012094:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 1012098:	21004ca0 	.word	0x21004ca0

0101209c <ticker_start>:
{
 101209c:	b510      	push	{r4, lr}
 101209e:	b08a      	sub	sp, #40	; 0x28
 10120a0:	9c0c      	ldr	r4, [sp, #48]	; 0x30
	return ticker_start_ext(instance_index, user_id, ticker_id,
 10120a2:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
 10120a6:	9400      	str	r4, [sp, #0]
 10120a8:	2400      	movs	r4, #0
 10120aa:	9409      	str	r4, [sp, #36]	; 0x24
{
 10120ac:	f8bd 403c 	ldrh.w	r4, [sp, #60]	; 0x3c
	return ticker_start_ext(instance_index, user_id, ticker_id,
 10120b0:	f8cd c004 	str.w	ip, [sp, #4]
 10120b4:	9403      	str	r4, [sp, #12]
 10120b6:	9c10      	ldr	r4, [sp, #64]	; 0x40
 10120b8:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
 10120bc:	9404      	str	r4, [sp, #16]
 10120be:	9c11      	ldr	r4, [sp, #68]	; 0x44
 10120c0:	f8cd c008 	str.w	ip, [sp, #8]
 10120c4:	9405      	str	r4, [sp, #20]
 10120c6:	9c12      	ldr	r4, [sp, #72]	; 0x48
 10120c8:	9406      	str	r4, [sp, #24]
 10120ca:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 10120cc:	9407      	str	r4, [sp, #28]
 10120ce:	9c14      	ldr	r4, [sp, #80]	; 0x50
 10120d0:	9408      	str	r4, [sp, #32]
 10120d2:	f7ff ff95 	bl	1012000 <ticker_start_ext>
}
 10120d6:	b00a      	add	sp, #40	; 0x28
 10120d8:	bd10      	pop	{r4, pc}
 10120da:	bf00      	nop

010120dc <ticker_update_ext>:
{
 10120dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct ticker_instance *instance = &_instance[instance_index];
 10120e0:	242c      	movs	r4, #44	; 0x2c
 10120e2:	4d25      	ldr	r5, [pc, #148]	; (1012178 <ticker_update_ext+0x9c>)
{
 10120e4:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
	struct ticker_instance *instance = &_instance[instance_index];
 10120e8:	fb04 5500 	mla	r5, r4, r0, r5
{
 10120ec:	4608      	mov	r0, r1
	user = &instance->users[user_id];
 10120ee:	6869      	ldr	r1, [r5, #4]
{
 10120f0:	f89d 7030 	ldrb.w	r7, [sp, #48]	; 0x30
	user = &instance->users[user_id];
 10120f4:	eb01 0ec0 	add.w	lr, r1, r0, lsl #3
	if (last >= user->count_user_op) {
 10120f8:	f811 9030 	ldrb.w	r9, [r1, r0, lsl #3]
	last = user->last + 1;
 10120fc:	f89e 1003 	ldrb.w	r1, [lr, #3]
	if (last == user->first) {
 1012100:	f89e 4001 	ldrb.w	r4, [lr, #1]
	last = user->last + 1;
 1012104:	f101 0c01 	add.w	ip, r1, #1
 1012108:	fa5f fc8c 	uxtb.w	ip, ip
		last = 0U;
 101210c:	45e1      	cmp	r9, ip
 101210e:	bf98      	it	ls
 1012110:	f04f 0c00 	movls.w	ip, #0
	if (last == user->first) {
 1012114:	4564      	cmp	r4, ip
{
 1012116:	f89d 603c 	ldrb.w	r6, [sp, #60]	; 0x3c
	if (last == user->first) {
 101211a:	d029      	beq.n	1012170 <ticker_update_ext+0x94>
	user_op = &user->user_op[user->last];
 101211c:	2434      	movs	r4, #52	; 0x34
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
 101211e:	f04f 0a05 	mov.w	sl, #5
	user_op->status = TICKER_STATUS_BUSY;
 1012122:	f04f 0902 	mov.w	r9, #2
	user_op = &user->user_op[user->last];
 1012126:	fb04 f101 	mul.w	r1, r4, r1
 101212a:	f8de 4004 	ldr.w	r4, [lr, #4]
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
 101212e:	f804 a001 	strb.w	sl, [r4, r1]
	user_op = &user->user_op[user->last];
 1012132:	440c      	add	r4, r1
	user_op->params.update.ticks_drift_plus = ticks_drift_plus;
 1012134:	6063      	str	r3, [r4, #4]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
 1012136:	9b08      	ldr	r3, [sp, #32]
	user_op->id = ticker_id;
 1012138:	7062      	strb	r2, [r4, #1]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
 101213a:	60a3      	str	r3, [r4, #8]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
 101213c:	9b09      	ldr	r3, [sp, #36]	; 0x24
	user_op->params.update.lazy = lazy;
 101213e:	f8a4 8014 	strh.w	r8, [r4, #20]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
 1012142:	60e3      	str	r3, [r4, #12]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
 1012144:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	user_op->params.update.force = force;
 1012146:	75a7      	strb	r7, [r4, #22]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
 1012148:	6123      	str	r3, [r4, #16]
	user_op->fp_op_func = fp_op_func;
 101214a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	user_op->params.update.must_expire = must_expire;
 101214c:	75e6      	strb	r6, [r4, #23]
	user_op->fp_op_func = fp_op_func;
 101214e:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
 1012150:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	user_op->status = TICKER_STATUS_BUSY;
 1012152:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
	user_op->op_context = op_context;
 1012156:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
 1012158:	f88e c003 	strb.w	ip, [lr, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 101215c:	e9d5 3608 	ldrd	r3, r6, [r5, #32]
 1012160:	4798      	blx	r3
 1012162:	462b      	mov	r3, r5
 1012164:	2200      	movs	r2, #0
 1012166:	2104      	movs	r1, #4
 1012168:	47b0      	blx	r6
	return user_op->status;
 101216a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
 101216c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return TICKER_STATUS_FAILURE;
 1012170:	2001      	movs	r0, #1
}
 1012172:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1012176:	bf00      	nop
 1012178:	21004ca0 	.word	0x21004ca0

0101217c <ticker_update>:
{
 101217c:	b510      	push	{r4, lr}
 101217e:	b088      	sub	sp, #32
 1012180:	9c0a      	ldr	r4, [sp, #40]	; 0x28
	return ticker_update_ext(instance_index, user_id, ticker_id,
 1012182:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
 1012186:	9400      	str	r4, [sp, #0]
 1012188:	2400      	movs	r4, #0
 101218a:	9407      	str	r4, [sp, #28]
{
 101218c:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
	return ticker_update_ext(instance_index, user_id, ticker_id,
 1012190:	f8cd c004 	str.w	ip, [sp, #4]
 1012194:	9403      	str	r4, [sp, #12]
{
 1012196:	f89d 4038 	ldrb.w	r4, [sp, #56]	; 0x38
	return ticker_update_ext(instance_index, user_id, ticker_id,
 101219a:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
 101219e:	9404      	str	r4, [sp, #16]
 10121a0:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 10121a2:	f8cd c008 	str.w	ip, [sp, #8]
 10121a6:	9405      	str	r4, [sp, #20]
 10121a8:	9c10      	ldr	r4, [sp, #64]	; 0x40
 10121aa:	9406      	str	r4, [sp, #24]
 10121ac:	f7ff ff96 	bl	10120dc <ticker_update_ext>
}
 10121b0:	b008      	add	sp, #32
 10121b2:	bd10      	pop	{r4, pc}

010121b4 <ticker_stop>:
{
 10121b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct ticker_instance *instance = &_instance[instance_index];
 10121b6:	242c      	movs	r4, #44	; 0x2c
 10121b8:	4d18      	ldr	r5, [pc, #96]	; (101221c <ticker_stop+0x68>)
 10121ba:	fb04 5500 	mla	r5, r4, r0, r5
{
 10121be:	4608      	mov	r0, r1
	user = &instance->users[user_id];
 10121c0:	6869      	ldr	r1, [r5, #4]
 10121c2:	eb01 06c0 	add.w	r6, r1, r0, lsl #3
	if (last >= user->count_user_op) {
 10121c6:	f811 e030 	ldrb.w	lr, [r1, r0, lsl #3]
	last = user->last + 1;
 10121ca:	78f1      	ldrb	r1, [r6, #3]
	if (last == user->first) {
 10121cc:	7874      	ldrb	r4, [r6, #1]
	last = user->last + 1;
 10121ce:	f101 0c01 	add.w	ip, r1, #1
 10121d2:	fa5f fc8c 	uxtb.w	ip, ip
		last = 0U;
 10121d6:	45e6      	cmp	lr, ip
 10121d8:	bf98      	it	ls
 10121da:	f04f 0c00 	movls.w	ip, #0
	if (last == user->first) {
 10121de:	4564      	cmp	r4, ip
 10121e0:	d019      	beq.n	1012216 <ticker_stop+0x62>
	user_op = &user->user_op[user->last];
 10121e2:	2434      	movs	r4, #52	; 0x34
	user_op->op = TICKER_USER_OP_TYPE_STOP;
 10121e4:	f04f 0e07 	mov.w	lr, #7
	user_op->status = TICKER_STATUS_BUSY;
 10121e8:	2702      	movs	r7, #2
	user_op = &user->user_op[user->last];
 10121ea:	fb04 f101 	mul.w	r1, r4, r1
 10121ee:	6874      	ldr	r4, [r6, #4]
	user_op->op = TICKER_USER_OP_TYPE_STOP;
 10121f0:	f804 e001 	strb.w	lr, [r4, r1]
	user_op = &user->user_op[user->last];
 10121f4:	440c      	add	r4, r1
	user_op->fp_op_func = fp_op_func;
 10121f6:	e9c4 730a 	strd	r7, r3, [r4, #40]	; 0x28
	user_op->op_context = op_context;
 10121fa:	9b06      	ldr	r3, [sp, #24]
	user_op->id = ticker_id;
 10121fc:	7062      	strb	r2, [r4, #1]
	user_op->op_context = op_context;
 10121fe:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
 1012200:	f886 c003 	strb.w	ip, [r6, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 1012204:	e9d5 3608 	ldrd	r3, r6, [r5, #32]
 1012208:	4798      	blx	r3
 101220a:	462b      	mov	r3, r5
 101220c:	2200      	movs	r2, #0
 101220e:	2104      	movs	r1, #4
 1012210:	47b0      	blx	r6
	return user_op->status;
 1012212:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
 1012214:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return TICKER_STATUS_FAILURE;
 1012216:	2001      	movs	r0, #1
}
 1012218:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 101221a:	bf00      	nop
 101221c:	21004ca0 	.word	0x21004ca0

01012220 <ticker_stop_abs>:
{
 1012220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct ticker_instance *instance = &_instance[instance_index];
 1012222:	242c      	movs	r4, #44	; 0x2c
 1012224:	4d19      	ldr	r5, [pc, #100]	; (101228c <ticker_stop_abs+0x6c>)
 1012226:	fb04 5500 	mla	r5, r4, r0, r5
{
 101222a:	4608      	mov	r0, r1
	user = &instance->users[user_id];
 101222c:	6869      	ldr	r1, [r5, #4]
 101222e:	eb01 0ec0 	add.w	lr, r1, r0, lsl #3
	if (last >= user->count_user_op) {
 1012232:	f811 6030 	ldrb.w	r6, [r1, r0, lsl #3]
	last = user->last + 1;
 1012236:	f89e 1003 	ldrb.w	r1, [lr, #3]
	if (last == user->first) {
 101223a:	f89e 4001 	ldrb.w	r4, [lr, #1]
	last = user->last + 1;
 101223e:	f101 0c01 	add.w	ip, r1, #1
 1012242:	fa5f fc8c 	uxtb.w	ip, ip
		last = 0U;
 1012246:	4566      	cmp	r6, ip
 1012248:	bf98      	it	ls
 101224a:	f04f 0c00 	movls.w	ip, #0
	if (last == user->first) {
 101224e:	4564      	cmp	r4, ip
 1012250:	d01a      	beq.n	1012288 <ticker_stop_abs+0x68>
	user_op = &user->user_op[user->last];
 1012252:	2434      	movs	r4, #52	; 0x34
	user_op->op = TICKER_USER_OP_TYPE_STOP_ABS;
 1012254:	2708      	movs	r7, #8
	user_op->status = TICKER_STATUS_BUSY;
 1012256:	2602      	movs	r6, #2
	user_op = &user->user_op[user->last];
 1012258:	fb04 f101 	mul.w	r1, r4, r1
 101225c:	f8de 4004 	ldr.w	r4, [lr, #4]
	user_op->op = TICKER_USER_OP_TYPE_STOP_ABS;
 1012260:	5467      	strb	r7, [r4, r1]
	user_op = &user->user_op[user->last];
 1012262:	440c      	add	r4, r1
	user_op->params.yield.ticks_at_yield = ticks_at_stop;
 1012264:	6063      	str	r3, [r4, #4]
	user_op->fp_op_func = fp_op_func;
 1012266:	9b06      	ldr	r3, [sp, #24]
	user_op->id = ticker_id;
 1012268:	7062      	strb	r2, [r4, #1]
	user_op->fp_op_func = fp_op_func;
 101226a:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
 101226c:	9b07      	ldr	r3, [sp, #28]
	user_op->status = TICKER_STATUS_BUSY;
 101226e:	62a6      	str	r6, [r4, #40]	; 0x28
	user_op->op_context = op_context;
 1012270:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
 1012272:	f88e c003 	strb.w	ip, [lr, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 1012276:	e9d5 3608 	ldrd	r3, r6, [r5, #32]
 101227a:	4798      	blx	r3
 101227c:	462b      	mov	r3, r5
 101227e:	2200      	movs	r2, #0
 1012280:	2104      	movs	r1, #4
 1012282:	47b0      	blx	r6
	return user_op->status;
 1012284:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
 1012286:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return TICKER_STATUS_FAILURE;
 1012288:	2001      	movs	r0, #1
}
 101228a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 101228c:	21004ca0 	.word	0x21004ca0

01012290 <ticker_ticks_now_get>:
	return cntr_cnt_get();
 1012290:	f00a bee4 	b.w	101d05c <cntr_cnt_get>

01012294 <ticker_ticks_diff_get>:
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1012294:	1a40      	subs	r0, r0, r1
}
 1012296:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 101229a:	4770      	bx	lr

0101229c <ll_addr_set>:

static uint8_t pub_addr[BDADDR_SIZE];
static uint8_t rnd_addr[BDADDR_SIZE];

uint8_t ll_addr_set(uint8_t addr_type, uint8_t const *const bdaddr)
{
 101229c:	b538      	push	{r3, r4, r5, lr}
 101229e:	4605      	mov	r5, r0
	if (IS_ENABLED(CONFIG_BT_BROADCASTER)) {
#if defined(CONFIG_BT_CTLR_ADV_EXT)
		if (ull_adv_is_enabled(0) && !ll_adv_cmds_is_ext()) {
#else /* !CONFIG_BT_CTLR_ADV_EXT */
		if (ull_adv_is_enabled(0)) {
 10122a0:	2000      	movs	r0, #0
{
 10122a2:	460c      	mov	r4, r1
		if (ull_adv_is_enabled(0)) {
 10122a4:	f003 f946 	bl	1015534 <ull_adv_is_enabled>
 10122a8:	b970      	cbnz	r0, 10122c8 <ll_addr_set+0x2c>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	if (addr_type) {
		if (bdaddr) {
			(void)memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
 10122aa:	2206      	movs	r2, #6
 10122ac:	4621      	mov	r1, r4
	if (addr_type) {
 10122ae:	b92d      	cbnz	r5, 10122bc <ll_addr_set+0x20>
		} else {
			(void)memset(rnd_addr, 0, BDADDR_SIZE);
		}
	} else {
		if (bdaddr) {
			(void)memcpy(pub_addr, bdaddr, BDADDR_SIZE);
 10122b0:	4806      	ldr	r0, [pc, #24]	; (10122cc <ll_addr_set+0x30>)
		if (bdaddr) {
 10122b2:	b134      	cbz	r4, 10122c2 <ll_addr_set+0x26>
			(void)memcpy(pub_addr, bdaddr, BDADDR_SIZE);
 10122b4:	f014 fb5e 	bl	1026974 <memcpy>
		} else {
			(void)memset(pub_addr, 0, BDADDR_SIZE);
		}
	}

	return 0;
 10122b8:	2000      	movs	r0, #0
}
 10122ba:	bd38      	pop	{r3, r4, r5, pc}
			(void)memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
 10122bc:	4804      	ldr	r0, [pc, #16]	; (10122d0 <ll_addr_set+0x34>)
		if (bdaddr) {
 10122be:	2c00      	cmp	r4, #0
 10122c0:	d1f8      	bne.n	10122b4 <ll_addr_set+0x18>
			(void)memset(rnd_addr, 0, BDADDR_SIZE);
 10122c2:	f014 fb62 	bl	102698a <memset>
 10122c6:	e7f7      	b.n	10122b8 <ll_addr_set+0x1c>
			return BT_HCI_ERR_CMD_DISALLOWED;
 10122c8:	200c      	movs	r0, #12
}
 10122ca:	bd38      	pop	{r3, r4, r5, pc}
 10122cc:	21004cd4 	.word	0x21004cd4
 10122d0:	21004ccc 	.word	0x21004ccc

010122d4 <ll_addr_get>:

uint8_t *ll_addr_get(uint8_t addr_type)
{
	if (addr_type > BT_ADDR_LE_RANDOM) {
 10122d4:	2801      	cmp	r0, #1
{
 10122d6:	4603      	mov	r3, r0
	if (addr_type > BT_ADDR_LE_RANDOM) {
 10122d8:	d805      	bhi.n	10122e6 <ll_addr_get+0x12>

	if (addr_type) {
		return rnd_addr;
	}

	return pub_addr;
 10122da:	4a04      	ldr	r2, [pc, #16]	; (10122ec <ll_addr_get+0x18>)
 10122dc:	4804      	ldr	r0, [pc, #16]	; (10122f0 <ll_addr_get+0x1c>)
 10122de:	2b00      	cmp	r3, #0
 10122e0:	bf08      	it	eq
 10122e2:	4610      	moveq	r0, r2
 10122e4:	4770      	bx	lr
		return NULL;
 10122e6:	2000      	movs	r0, #0
}
 10122e8:	4770      	bx	lr
 10122ea:	bf00      	nop
 10122ec:	21004cd4 	.word	0x21004cd4
 10122f0:	21004ccc 	.word	0x21004ccc

010122f4 <ll_addr_read>:
	if (addr_type > BT_ADDR_LE_RANDOM) {
 10122f4:	2801      	cmp	r0, #1

uint8_t *ll_addr_read(uint8_t addr_type, uint8_t *const bdaddr)
{
 10122f6:	4603      	mov	r3, r0
 10122f8:	b510      	push	{r4, lr}
	if (addr_type > BT_ADDR_LE_RANDOM) {
 10122fa:	d80b      	bhi.n	1012314 <ll_addr_read+0x20>
	if (addr_type) {
 10122fc:	4608      	mov	r0, r1
		return rnd_addr;
 10122fe:	4c07      	ldr	r4, [pc, #28]	; (101231c <ll_addr_read+0x28>)
 1012300:	4907      	ldr	r1, [pc, #28]	; (1012320 <ll_addr_read+0x2c>)
	uint8_t *addr;

	addr = ll_addr_get(addr_type);
	if (addr) {
		memcpy(bdaddr, addr, BDADDR_SIZE);
 1012302:	2206      	movs	r2, #6
		return rnd_addr;
 1012304:	2b00      	cmp	r3, #0
 1012306:	bf18      	it	ne
 1012308:	460c      	movne	r4, r1
		memcpy(bdaddr, addr, BDADDR_SIZE);
 101230a:	4621      	mov	r1, r4
 101230c:	f014 fb32 	bl	1026974 <memcpy>
	}

	return addr;
}
 1012310:	4620      	mov	r0, r4
 1012312:	bd10      	pop	{r4, pc}
		return NULL;
 1012314:	2400      	movs	r4, #0
}
 1012316:	4620      	mov	r0, r4
 1012318:	bd10      	pop	{r4, pc}
 101231a:	bf00      	nop
 101231c:	21004cd4 	.word	0x21004cd4
 1012320:	21004ccc 	.word	0x21004ccc

01012324 <ll_tx_pwr_lvl_get>:
#include "ll.h"

uint8_t ll_tx_pwr_lvl_get(uint8_t handle_type,
		       uint16_t handle, uint8_t type, int8_t *tx_pwr_lvl)
{
	switch (handle_type) {
 1012324:	2802      	cmp	r0, #2
 1012326:	d001      	beq.n	101232c <ll_tx_pwr_lvl_get+0x8>
			}
			break;
		}
#endif /* CONFIG_BT_CONN */
		default: {
			return BT_HCI_ERR_UNKNOWN_CMD;
 1012328:	2001      	movs	r0, #1
		}
	}

	return BT_HCI_ERR_SUCCESS;
}
 101232a:	4770      	bx	lr
{
 101232c:	b538      	push	{r3, r4, r5, lr}
 101232e:	4604      	mov	r4, r0
			conn = ll_connected_get(handle);
 1012330:	4608      	mov	r0, r1
 1012332:	461d      	mov	r5, r3
 1012334:	f003 fc06 	bl	1015b44 <ll_connected_get>
			if (!conn) {
 1012338:	b118      	cbz	r0, 1012342 <ll_tx_pwr_lvl_get+0x1e>
				*tx_pwr_lvl = RADIO_TXP_DEFAULT;
 101233a:	2300      	movs	r3, #0
 101233c:	702b      	strb	r3, [r5, #0]
	return BT_HCI_ERR_SUCCESS;
 101233e:	4618      	mov	r0, r3
}
 1012340:	bd38      	pop	{r3, r4, r5, pc}
				return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1012342:	4620      	mov	r0, r4
}
 1012344:	bd38      	pop	{r3, r4, r5, pc}
 1012346:	bf00      	nop

01012348 <ll_tx_pwr_get>:
{
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	*min = lll_radio_tx_pwr_min_get();
	*max = lll_radio_tx_pwr_max_get();
#else
	*min = RADIO_TXP_DEFAULT;
 1012348:	2300      	movs	r3, #0
 101234a:	7003      	strb	r3, [r0, #0]
	*max = RADIO_TXP_DEFAULT;
 101234c:	700b      	strb	r3, [r1, #0]
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
}
 101234e:	4770      	bx	lr

01012350 <hci_driver_init>:
	.close	= hci_driver_close,
	.send	= hci_driver_send,
};

static int hci_driver_init(const struct device *unused)
{
 1012350:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
 1012352:	4802      	ldr	r0, [pc, #8]	; (101235c <hci_driver_init+0xc>)
 1012354:	f7f6 fa52 	bl	10087fc <bt_hci_driver_register>

	return 0;
}
 1012358:	2000      	movs	r0, #0
 101235a:	bd08      	pop	{r3, pc}
 101235c:	0102a358 	.word	0x0102a358

01012360 <hci_driver_send>:
{
 1012360:	b5b0      	push	{r4, r5, r7, lr}
 1012362:	b086      	sub	sp, #24
	if (!buf->len) {
 1012364:	8a03      	ldrh	r3, [r0, #16]
{
 1012366:	af00      	add	r7, sp, #0
	if (!buf->len) {
 1012368:	2b00      	cmp	r3, #0
 101236a:	d043      	beq.n	10123f4 <hci_driver_send+0x94>
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
 101236c:	7e03      	ldrb	r3, [r0, #24]
	switch (type) {
 101236e:	4604      	mov	r4, r0
 1012370:	b35b      	cbz	r3, 10123ca <hci_driver_send+0x6a>
 1012372:	2b02      	cmp	r3, #2
 1012374:	d016      	beq.n	10123a4 <hci_driver_send+0x44>
		LOG_ERR("Unknown HCI type %u", type);
 1012376:	466c      	mov	r4, sp
 1012378:	b088      	sub	sp, #32
 101237a:	4669      	mov	r1, sp
 101237c:	2003      	movs	r0, #3
 101237e:	460a      	mov	r2, r1
 1012380:	4d22      	ldr	r5, [pc, #136]	; (101240c <hci_driver_send+0xac>)
 1012382:	e9c1 5305 	strd	r5, r3, [r1, #20]
 1012386:	f842 0f10 	str.w	r0, [r2, #16]!
 101238a:	2300      	movs	r3, #0
 101238c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 1012390:	481f      	ldr	r0, [pc, #124]	; (1012410 <hci_driver_send+0xb0>)
 1012392:	f7f2 f9b9 	bl	1004708 <z_impl_z_log_msg_static_create>
 1012396:	46a5      	mov	sp, r4
		return -EINVAL;
 1012398:	f06f 0515 	mvn.w	r5, #21
}
 101239c:	4628      	mov	r0, r5
 101239e:	3718      	adds	r7, #24
 10123a0:	46bd      	mov	sp, r7
 10123a2:	bdb0      	pop	{r4, r5, r7, pc}
	err = hci_acl_handle(buf, &evt);
 10123a4:	4639      	mov	r1, r7
 10123a6:	f000 febb 	bl	1013120 <hci_acl_handle>
	if (evt) {
 10123aa:	683b      	ldr	r3, [r7, #0]
	err = hci_acl_handle(buf, &evt);
 10123ac:	4605      	mov	r5, r0
	if (evt) {
 10123ae:	b113      	cbz	r3, 10123b6 <hci_driver_send+0x56>
		bt_recv_prio(evt);
 10123b0:	4618      	mov	r0, r3
 10123b2:	f7f6 fa05 	bl	10087c0 <bt_recv_prio>
	if (!err) {
 10123b6:	2d00      	cmp	r5, #0
 10123b8:	d1f0      	bne.n	101239c <hci_driver_send+0x3c>
		net_buf_unref(buf);
 10123ba:	2500      	movs	r5, #0
 10123bc:	4620      	mov	r0, r4
 10123be:	f00b fe0f 	bl	101dfe0 <net_buf_unref>
}
 10123c2:	4628      	mov	r0, r5
 10123c4:	3718      	adds	r7, #24
 10123c6:	46bd      	mov	sp, r7
 10123c8:	bdb0      	pop	{r4, r5, r7, pc}
	evt = hci_cmd_handle(buf, (void **) &node_rx);
 10123ca:	4639      	mov	r1, r7
	struct node_rx_pdu *node_rx = NULL;
 10123cc:	603b      	str	r3, [r7, #0]
	evt = hci_cmd_handle(buf, (void **) &node_rx);
 10123ce:	f000 faab 	bl	1012928 <hci_cmd_handle>
	if (evt) {
 10123d2:	2800      	cmp	r0, #0
 10123d4:	d0f1      	beq.n	10123ba <hci_driver_send+0x5a>
		bt_recv_prio(evt);
 10123d6:	f7f6 f9f3 	bl	10087c0 <bt_recv_prio>
		if (node_rx) {
 10123da:	683d      	ldr	r5, [r7, #0]
 10123dc:	2d00      	cmp	r5, #0
 10123de:	d0ec      	beq.n	10123ba <hci_driver_send+0x5a>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
 10123e0:	4628      	mov	r0, r5
 10123e2:	f001 fa6f 	bl	10138c4 <hci_get_class>
 10123e6:	4603      	mov	r3, r0
 10123e8:	716b      	strb	r3, [r5, #5]
			k_fifo_put(&recv_fifo, node_rx);
 10123ea:	480a      	ldr	r0, [pc, #40]	; (1012414 <hci_driver_send+0xb4>)
 10123ec:	6839      	ldr	r1, [r7, #0]
 10123ee:	f016 ff7d 	bl	10292ec <k_queue_append>
	if (!err) {
 10123f2:	e7e2      	b.n	10123ba <hci_driver_send+0x5a>
		LOG_ERR("Empty HCI packet");
 10123f4:	2202      	movs	r2, #2
 10123f6:	4908      	ldr	r1, [pc, #32]	; (1012418 <hci_driver_send+0xb8>)
 10123f8:	e9c7 2104 	strd	r2, r1, [r7, #16]
 10123fc:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1012400:	4803      	ldr	r0, [pc, #12]	; (1012410 <hci_driver_send+0xb0>)
 1012402:	f107 0210 	add.w	r2, r7, #16
 1012406:	f7f2 f97f 	bl	1004708 <z_impl_z_log_msg_static_create>
		return -EINVAL;
 101240a:	e7c5      	b.n	1012398 <hci_driver_send+0x38>
 101240c:	0102a2ac 	.word	0x0102a2ac
 1012410:	01029984 	.word	0x01029984
 1012414:	21004cdc 	.word	0x21004cdc
 1012418:	0102a298 	.word	0x0102a298

0101241c <hci_driver_close>:
{
 101241c:	b508      	push	{r3, lr}
	ll_deinit();
 101241e:	f002 fc2f 	bl	1014c80 <ll_deinit>
	z_impl_k_thread_abort(thread);
 1012422:	4804      	ldr	r0, [pc, #16]	; (1012434 <hci_driver_close+0x18>)
 1012424:	f7f4 f99c 	bl	1006760 <z_impl_k_thread_abort>
 1012428:	4803      	ldr	r0, [pc, #12]	; (1012438 <hci_driver_close+0x1c>)
 101242a:	f7f4 f999 	bl	1006760 <z_impl_k_thread_abort>
}
 101242e:	2000      	movs	r0, #0
 1012430:	bd08      	pop	{r3, pc}
 1012432:	bf00      	nop
 1012434:	21003668 	.word	0x21003668
 1012438:	210035e8 	.word	0x210035e8

0101243c <recv_thread>:
{
 101243c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return z_impl_k_queue_get(queue, timeout);
 1012440:	4e42      	ldr	r6, [pc, #264]	; (101254c <recv_thread+0x110>)
		LL_ASSERT(0);
 1012442:	f8df 810c 	ldr.w	r8, [pc, #268]	; 1012550 <recv_thread+0x114>
 1012446:	4f43      	ldr	r7, [pc, #268]	; (1012554 <recv_thread+0x118>)
{
 1012448:	b082      	sub	sp, #8
 101244a:	f04f 32ff 	mov.w	r2, #4294967295
 101244e:	f04f 33ff 	mov.w	r3, #4294967295
 1012452:	4630      	mov	r0, r6
 1012454:	f00f f8ba 	bl	10215cc <z_impl_k_queue_get>
		if (node_rx && !buf) {
 1012458:	2800      	cmp	r0, #0
 101245a:	d0f6      	beq.n	101244a <recv_thread+0xe>
	uint8_t class = node_rx->hdr.user_meta;
 101245c:	7943      	ldrb	r3, [r0, #5]
	buf = encode_node(node_rx, class);
 101245e:	9001      	str	r0, [sp, #4]
	switch (class) {
 1012460:	2b04      	cmp	r3, #4
 1012462:	d821      	bhi.n	10124a8 <recv_thread+0x6c>
 1012464:	2b00      	cmp	r3, #0
 1012466:	d14b      	bne.n	1012500 <recv_thread+0xc4>
		LL_ASSERT(0);
 1012468:	f44f 73e1 	mov.w	r3, #450	; 0x1c2
 101246c:	4642      	mov	r2, r8
 101246e:	4639      	mov	r1, r7
 1012470:	4839      	ldr	r0, [pc, #228]	; (1012558 <recv_thread+0x11c>)
 1012472:	f012 fbb0 	bl	1024bd6 <assert_print>
 1012476:	4040      	eors	r0, r0
 1012478:	f380 8811 	msr	BASEPRI, r0
 101247c:	f04f 0003 	mov.w	r0, #3
 1012480:	df02      	svc	2
	node_rx->hdr.next = NULL;
 1012482:	2200      	movs	r2, #0
 1012484:	9b01      	ldr	r3, [sp, #4]
	ll_rx_mem_release((void **)&node_rx);
 1012486:	a801      	add	r0, sp, #4
	node_rx->hdr.next = NULL;
 1012488:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
 101248a:	f001 fe3d 	bl	1014108 <ll_rx_mem_release>
 101248e:	f04f 32ff 	mov.w	r2, #4294967295
 1012492:	f04f 33ff 	mov.w	r3, #4294967295
 1012496:	4630      	mov	r0, r6
 1012498:	f00f f898 	bl	10215cc <z_impl_k_queue_get>
		if (node_rx && !buf) {
 101249c:	2800      	cmp	r0, #0
 101249e:	d0d4      	beq.n	101244a <recv_thread+0xe>
	uint8_t class = node_rx->hdr.user_meta;
 10124a0:	7943      	ldrb	r3, [r0, #5]
	buf = encode_node(node_rx, class);
 10124a2:	9001      	str	r0, [sp, #4]
	switch (class) {
 10124a4:	2b04      	cmp	r3, #4
 10124a6:	d9dd      	bls.n	1012464 <recv_thread+0x28>
 10124a8:	2b05      	cmp	r3, #5
 10124aa:	d1dd      	bne.n	1012468 <recv_thread+0x2c>
		buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
 10124ac:	f04f 32ff 	mov.w	r2, #4294967295
 10124b0:	f04f 33ff 	mov.w	r3, #4294967295
 10124b4:	2003      	movs	r0, #3
 10124b6:	f7f4 ff5f 	bl	1007378 <bt_buf_get_rx>
 10124ba:	4604      	mov	r4, r0
		hci_acl_encode(node_rx, buf);
 10124bc:	9801      	ldr	r0, [sp, #4]
 10124be:	4621      	mov	r1, r4
 10124c0:	f000 feea 	bl	1013298 <hci_acl_encode>
	node_rx->hdr.next = NULL;
 10124c4:	2200      	movs	r2, #0
 10124c6:	9b01      	ldr	r3, [sp, #4]
	ll_rx_mem_release((void **)&node_rx);
 10124c8:	a801      	add	r0, sp, #4
	node_rx->hdr.next = NULL;
 10124ca:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
 10124cc:	f001 fe1c 	bl	1014108 <ll_rx_mem_release>
		while (buf) {
 10124d0:	2c00      	cmp	r4, #0
 10124d2:	d0ba      	beq.n	101244a <recv_thread+0xe>
			frag = net_buf_ref(buf);
 10124d4:	4620      	mov	r0, r4
 10124d6:	f00b fdc5 	bl	101e064 <net_buf_ref>
 10124da:	4605      	mov	r5, r0
			buf = net_buf_frag_del(NULL, buf);
 10124dc:	4621      	mov	r1, r4
 10124de:	2000      	movs	r0, #0
 10124e0:	f00b fe42 	bl	101e168 <net_buf_frag_del>
			if (frag->len) {
 10124e4:	8a2b      	ldrh	r3, [r5, #16]
			buf = net_buf_frag_del(NULL, buf);
 10124e6:	4604      	mov	r4, r0
				bt_recv(frag);
 10124e8:	4628      	mov	r0, r5
			if (frag->len) {
 10124ea:	b133      	cbz	r3, 10124fa <recv_thread+0xbe>
				bt_recv(frag);
 10124ec:	f7f6 f8b6 	bl	100865c <bt_recv>
	z_impl_k_yield();
 10124f0:	f010 fe42 	bl	1023178 <z_impl_k_yield>
		while (buf) {
 10124f4:	2c00      	cmp	r4, #0
 10124f6:	d1ed      	bne.n	10124d4 <recv_thread+0x98>
 10124f8:	e7a7      	b.n	101244a <recv_thread+0xe>
				net_buf_unref(frag);
 10124fa:	f00b fd71 	bl	101dfe0 <net_buf_unref>
 10124fe:	e7f7      	b.n	10124f0 <recv_thread+0xb4>
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
 1012500:	2b02      	cmp	r3, #2
 1012502:	d014      	beq.n	101252e <recv_thread+0xf2>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 1012504:	f04f 33ff 	mov.w	r3, #4294967295
 1012508:	f04f 32ff 	mov.w	r2, #4294967295
 101250c:	2001      	movs	r0, #1
 101250e:	f7f4 ff33 	bl	1007378 <bt_buf_get_rx>
 1012512:	4604      	mov	r4, r0
			hci_evt_encode(node_rx, buf);
 1012514:	9b01      	ldr	r3, [sp, #4]
		if (buf) {
 1012516:	b1a4      	cbz	r4, 1012542 <recv_thread+0x106>
			hci_evt_encode(node_rx, buf);
 1012518:	4618      	mov	r0, r3
 101251a:	4621      	mov	r1, r4
 101251c:	f000 fef8 	bl	1013310 <hci_evt_encode>
	node_rx->hdr.next = NULL;
 1012520:	2200      	movs	r2, #0
 1012522:	9b01      	ldr	r3, [sp, #4]
	ll_rx_mem_release((void **)&node_rx);
 1012524:	a801      	add	r0, sp, #4
	node_rx->hdr.next = NULL;
 1012526:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
 1012528:	f001 fdee 	bl	1014108 <ll_rx_mem_release>
		while (buf) {
 101252c:	e7d2      	b.n	10124d4 <recv_thread+0x98>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
 101252e:	2300      	movs	r3, #0
 1012530:	2200      	movs	r2, #0
 1012532:	2101      	movs	r1, #1
 1012534:	2000      	movs	r0, #0
 1012536:	f7f4 ff65 	bl	1007404 <bt_buf_get_evt>
 101253a:	4604      	mov	r4, r0
			hci_evt_encode(node_rx, buf);
 101253c:	9b01      	ldr	r3, [sp, #4]
		if (buf) {
 101253e:	2c00      	cmp	r4, #0
 1012540:	d1ea      	bne.n	1012518 <recv_thread+0xdc>
	ll_rx_mem_release((void **)&node_rx);
 1012542:	a801      	add	r0, sp, #4
	node_rx->hdr.next = NULL;
 1012544:	601c      	str	r4, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
 1012546:	f001 fddf 	bl	1014108 <ll_rx_mem_release>
		while (buf) {
 101254a:	e77e      	b.n	101244a <recv_thread+0xe>
 101254c:	21004cdc 	.word	0x21004cdc
 1012550:	0102a2c0 	.word	0x0102a2c0
 1012554:	0102a300 	.word	0x0102a300
 1012558:	0102a278 	.word	0x0102a278

0101255c <prio_recv_thread>:
{
 101255c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return z_impl_k_sem_take(sem, timeout);
 1012560:	4f2e      	ldr	r7, [pc, #184]	; (101261c <prio_recv_thread+0xc0>)
				k_fifo_put(&recv_fifo, node_rx);
 1012562:	4e2f      	ldr	r6, [pc, #188]	; (1012620 <prio_recv_thread+0xc4>)
{
 1012564:	b082      	sub	sp, #8
 1012566:	e012      	b.n	101258e <prio_recv_thread+0x32>
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
 1012568:	f04f 33ff 	mov.w	r3, #4294967295
 101256c:	f04f 32ff 	mov.w	r2, #4294967295
 1012570:	2100      	movs	r1, #0
 1012572:	2013      	movs	r0, #19
 1012574:	f7f4 ff46 	bl	1007404 <bt_buf_get_evt>
			hci_num_cmplt_encode(buf, handle, num_cmplt);
 1012578:	4622      	mov	r2, r4
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
 101257a:	4604      	mov	r4, r0
			hci_num_cmplt_encode(buf, handle, num_cmplt);
 101257c:	f8bd 1002 	ldrh.w	r1, [sp, #2]
 1012580:	f001 f988 	bl	1013894 <hci_num_cmplt_encode>
			bt_recv_prio(buf);
 1012584:	4620      	mov	r0, r4
 1012586:	f7f6 f91b 	bl	10087c0 <bt_recv_prio>
	z_impl_k_yield();
 101258a:	f010 fdf5 	bl	1023178 <z_impl_k_yield>
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
 101258e:	f10d 0102 	add.w	r1, sp, #2
 1012592:	a801      	add	r0, sp, #4
 1012594:	f001 fc80 	bl	1013e98 <ll_rx_get>
 1012598:	4604      	mov	r4, r0
 101259a:	2800      	cmp	r0, #0
 101259c:	d1e4      	bne.n	1012568 <prio_recv_thread+0xc>
		if (node_rx) {
 101259e:	9b01      	ldr	r3, [sp, #4]
 10125a0:	b1b3      	cbz	r3, 10125d0 <prio_recv_thread+0x74>
			ll_rx_dequeue();
 10125a2:	f001 fcf3 	bl	1013f8c <ll_rx_dequeue>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
 10125a6:	f8dd 8004 	ldr.w	r8, [sp, #4]
 10125aa:	4640      	mov	r0, r8
 10125ac:	f001 f98a 	bl	10138c4 <hci_get_class>
			buf = process_prio_evt(node_rx, &evt_flags);
 10125b0:	9d01      	ldr	r5, [sp, #4]
			node_rx->hdr.user_meta = hci_get_class(node_rx);
 10125b2:	f888 0005 	strb.w	r0, [r8, #5]
	if (node_rx->hdr.user_meta == HCI_CLASS_EVT_CONNECTION) {
 10125b6:	796b      	ldrb	r3, [r5, #5]
 10125b8:	2b03      	cmp	r3, #3
 10125ba:	d102      	bne.n	10125c2 <prio_recv_thread+0x66>
		if (node_rx->hdr.type == NODE_RX_TYPE_TERMINATE) {
 10125bc:	792b      	ldrb	r3, [r5, #4]
 10125be:	2b18      	cmp	r3, #24
 10125c0:	d00e      	beq.n	10125e0 <prio_recv_thread+0x84>
				k_fifo_put(&recv_fifo, node_rx);
 10125c2:	4629      	mov	r1, r5
 10125c4:	4630      	mov	r0, r6
 10125c6:	f016 fe91 	bl	10292ec <k_queue_append>
		if (iso_received || node_rx) {
 10125ca:	9b01      	ldr	r3, [sp, #4]
 10125cc:	2b00      	cmp	r3, #0
 10125ce:	d1de      	bne.n	101258e <prio_recv_thread+0x32>
	return z_impl_k_sem_take(sem, timeout);
 10125d0:	f04f 32ff 	mov.w	r2, #4294967295
 10125d4:	f04f 33ff 	mov.w	r3, #4294967295
 10125d8:	4638      	mov	r0, r7
 10125da:	f00f f8a5 	bl	1021728 <z_impl_k_sem_take>
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
 10125de:	e7d6      	b.n	101258e <prio_recv_thread+0x32>
			buf = bt_buf_get_evt(BT_HCI_EVT_DISCONN_COMPLETE, false,
 10125e0:	4621      	mov	r1, r4
 10125e2:	f04f 32ff 	mov.w	r2, #4294967295
 10125e6:	f04f 33ff 	mov.w	r3, #4294967295
 10125ea:	2005      	movs	r0, #5
		handle = node_rx->hdr.handle;
 10125ec:	f8b5 8006 	ldrh.w	r8, [r5, #6]
			buf = bt_buf_get_evt(BT_HCI_EVT_DISCONN_COMPLETE, false,
 10125f0:	f7f4 ff08 	bl	1007404 <bt_buf_get_evt>
 10125f4:	4604      	mov	r4, r0
			hci_disconn_complete_encode(pdu_data, handle, buf);
 10125f6:	4641      	mov	r1, r8
 10125f8:	f105 001c 	add.w	r0, r5, #28
 10125fc:	4622      	mov	r2, r4
 10125fe:	f000 fe23 	bl	1013248 <hci_disconn_complete_encode>
			hci_disconn_complete_process(handle);
 1012602:	4640      	mov	r0, r8
 1012604:	f000 fe40 	bl	1013288 <hci_disconn_complete_process>
			if (buf) {
 1012608:	b12c      	cbz	r4, 1012616 <prio_recv_thread+0xba>
				bt_recv_prio(buf);
 101260a:	4620      	mov	r0, r4
 101260c:	f7f6 f8d8 	bl	10087c0 <bt_recv_prio>
					net_buf_unref(buf);
 1012610:	4620      	mov	r0, r4
 1012612:	f00b fce5 	bl	101dfe0 <net_buf_unref>
				k_fifo_put(&recv_fifo, node_rx);
 1012616:	9d01      	ldr	r5, [sp, #4]
 1012618:	e7d3      	b.n	10125c2 <prio_recv_thread+0x66>
 101261a:	bf00      	nop
 101261c:	21004cf8 	.word	0x21004cf8
 1012620:	21004cdc 	.word	0x21004cdc

01012624 <hci_driver_open>:
{
 1012624:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 1012628:	b088      	sub	sp, #32
 101262a:	af08      	add	r7, sp, #32
	z_impl_k_queue_init(queue);
 101262c:	482a      	ldr	r0, [pc, #168]	; (10126d8 <hci_driver_open+0xb4>)
 101262e:	f016 fe50 	bl	10292d2 <z_impl_k_queue_init>
	return z_impl_k_sem_init(sem, initial_count, limit);
 1012632:	f04f 32ff 	mov.w	r2, #4294967295
 1012636:	2100      	movs	r1, #0
 1012638:	4828      	ldr	r0, [pc, #160]	; (10126dc <hci_driver_open+0xb8>)
 101263a:	f016 fe6c 	bl	1029316 <z_impl_k_sem_init>
	err = ll_init(&sem_prio_recv);
 101263e:	4827      	ldr	r0, [pc, #156]	; (10126dc <hci_driver_open+0xb8>)
 1012640:	f002 fa20 	bl	1014a84 <ll_init>
	if (err) {
 1012644:	4604      	mov	r4, r0
 1012646:	2800      	cmp	r0, #0
 1012648:	d131      	bne.n	10126ae <hci_driver_open+0x8a>
	hci_init(NULL);
 101264a:	f001 f951 	bl	10138f0 <hci_init>
	k_thread_create(&prio_recv_thread_data, prio_recv_thread_stack,
 101264e:	f04f 0800 	mov.w	r8, #0
 1012652:	f04f 0900 	mov.w	r9, #0
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 1012656:	f06f 0509 	mvn.w	r5, #9
 101265a:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
 101265e:	e9cd 8906 	strd	r8, r9, [sp, #24]
 1012662:	e9cd 4401 	strd	r4, r4, [sp, #4]
 1012666:	4b1e      	ldr	r3, [pc, #120]	; (10126e0 <hci_driver_open+0xbc>)
 1012668:	491e      	ldr	r1, [pc, #120]	; (10126e4 <hci_driver_open+0xc0>)
 101266a:	9404      	str	r4, [sp, #16]
 101266c:	9400      	str	r4, [sp, #0]
 101266e:	9503      	str	r5, [sp, #12]
 1012670:	481d      	ldr	r0, [pc, #116]	; (10126e8 <hci_driver_open+0xc4>)
 1012672:	f00e fc63 	bl	1020f3c <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
 1012676:	491d      	ldr	r1, [pc, #116]	; (10126ec <hci_driver_open+0xc8>)
 1012678:	481b      	ldr	r0, [pc, #108]	; (10126e8 <hci_driver_open+0xc4>)
 101267a:	f016 fe08 	bl	102928e <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 101267e:	f06f 0507 	mvn.w	r5, #7
 1012682:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 1012686:	e9cd 8906 	strd	r8, r9, [sp, #24]
 101268a:	e9cd 4401 	strd	r4, r4, [sp, #4]
 101268e:	4b18      	ldr	r3, [pc, #96]	; (10126f0 <hci_driver_open+0xcc>)
 1012690:	4918      	ldr	r1, [pc, #96]	; (10126f4 <hci_driver_open+0xd0>)
 1012692:	9404      	str	r4, [sp, #16]
 1012694:	9400      	str	r4, [sp, #0]
 1012696:	9503      	str	r5, [sp, #12]
 1012698:	4817      	ldr	r0, [pc, #92]	; (10126f8 <hci_driver_open+0xd4>)
 101269a:	f00e fc4f 	bl	1020f3c <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
 101269e:	4917      	ldr	r1, [pc, #92]	; (10126fc <hci_driver_open+0xd8>)
 10126a0:	4815      	ldr	r0, [pc, #84]	; (10126f8 <hci_driver_open+0xd4>)
 10126a2:	f016 fdf4 	bl	102928e <z_impl_k_thread_name_set>
}
 10126a6:	4620      	mov	r0, r4
 10126a8:	46bd      	mov	sp, r7
 10126aa:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
		LOG_ERR("LL initialization failed: %d", err);
 10126ae:	466d      	mov	r5, sp
 10126b0:	b088      	sub	sp, #32
 10126b2:	2103      	movs	r1, #3
 10126b4:	462a      	mov	r2, r5
 10126b6:	4812      	ldr	r0, [pc, #72]	; (1012700 <hci_driver_open+0xdc>)
 10126b8:	e9c5 0405 	strd	r0, r4, [r5, #20]
 10126bc:	f842 1f10 	str.w	r1, [r2, #16]!
 10126c0:	2300      	movs	r3, #0
 10126c2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
 10126c6:	480f      	ldr	r0, [pc, #60]	; (1012704 <hci_driver_open+0xe0>)
 10126c8:	f7f2 f81e 	bl	1004708 <z_impl_z_log_msg_static_create>
}
 10126cc:	4620      	mov	r0, r4
 10126ce:	46ad      	mov	sp, r5
 10126d0:	46bd      	mov	sp, r7
 10126d2:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 10126d6:	bf00      	nop
 10126d8:	21004cdc 	.word	0x21004cdc
 10126dc:	21004cf8 	.word	0x21004cf8
 10126e0:	0101255d 	.word	0x0101255d
 10126e4:	2100ba88 	.word	0x2100ba88
 10126e8:	21003668 	.word	0x21003668
 10126ec:	0102a324 	.word	0x0102a324
 10126f0:	0101243d 	.word	0x0101243d
 10126f4:	2100aa88 	.word	0x2100aa88
 10126f8:	210035e8 	.word	0x210035e8
 10126fc:	0102a330 	.word	0x0102a330
 1012700:	0102a304 	.word	0x0102a304
 1012704:	01029984 	.word	0x01029984

01012708 <hci_recv_fifo_reset>:
{
 1012708:	b510      	push	{r4, lr}
	k_sched_lock();
 101270a:	f010 f821 	bl	1022750 <k_sched_lock>
	z_impl_k_queue_cancel_wait(queue);
 101270e:	4c05      	ldr	r4, [pc, #20]	; (1012724 <hci_recv_fifo_reset+0x1c>)
 1012710:	4620      	mov	r0, r4
 1012712:	f00e ff1d 	bl	1021550 <z_impl_k_queue_cancel_wait>
	z_impl_k_queue_init(queue);
 1012716:	4620      	mov	r0, r4
 1012718:	f016 fddb 	bl	10292d2 <z_impl_k_queue_init>
}
 101271c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_sched_unlock();
 1012720:	f010 b882 	b.w	1022828 <k_sched_unlock>
 1012724:	21004cdc 	.word	0x21004cdc

01012728 <le_remote_feat_complete>:
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

static void le_remote_feat_complete(uint8_t status, struct pdu_data *pdu_data,
				    uint16_t handle, struct net_buf *buf)
{
 1012728:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_remote_feat_complete *sep;

	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 101272a:	4c18      	ldr	r4, [pc, #96]	; (101278c <le_remote_feat_complete+0x64>)
 101272c:	6864      	ldr	r4, [r4, #4]
 101272e:	00a4      	lsls	r4, r4, #2
 1012730:	d504      	bpl.n	101273c <le_remote_feat_complete+0x14>
 1012732:	4615      	mov	r5, r2
	    !(le_event_mask & BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE)) {
 1012734:	4a16      	ldr	r2, [pc, #88]	; (1012790 <le_remote_feat_complete+0x68>)
 1012736:	6812      	ldr	r2, [r2, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1012738:	0712      	lsls	r2, r2, #28
 101273a:	d400      	bmi.n	101273e <le_remote_feat_complete+0x16>
		       &pdu_data->llctrl.feature_rsp.features[0],
		       sizeof(sep->features));
	} else {
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
	}
}
 101273c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 101273e:	f103 040c 	add.w	r4, r3, #12
 1012742:	4607      	mov	r7, r0
 1012744:	460e      	mov	r6, r1
 1012746:	4620      	mov	r0, r4
 1012748:	2102      	movs	r1, #2
 101274a:	f00b fda5 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 101274e:	f640 433e 	movw	r3, #3134	; 0xc3e
 1012752:	2101      	movs	r1, #1
 1012754:	8003      	strh	r3, [r0, #0]
 1012756:	4620      	mov	r0, r4
 1012758:	f00b fd9e 	bl	101e298 <net_buf_simple_add>
	me->subevent = subevt;
 101275c:	2204      	movs	r2, #4
 101275e:	4603      	mov	r3, r0
 1012760:	210b      	movs	r1, #11
 1012762:	701a      	strb	r2, [r3, #0]
 1012764:	4620      	mov	r0, r4
 1012766:	f00b fd97 	bl	101e298 <net_buf_simple_add>
		memcpy(&sep->features[0],
 101276a:	2208      	movs	r2, #8
	sep->status = status;
 101276c:	7007      	strb	r7, [r0, #0]
	sep->handle = sys_cpu_to_le16(handle);
 101276e:	f8a0 5001 	strh.w	r5, [r0, #1]
	if (!status) {
 1012772:	b92f      	cbnz	r7, 1012780 <le_remote_feat_complete+0x58>
		memcpy(&sep->features[0],
 1012774:	1d31      	adds	r1, r6, #4
 1012776:	3003      	adds	r0, #3
}
 1012778:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		memcpy(&sep->features[0],
 101277c:	f014 b8fa 	b.w	1026974 <memcpy>
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
 1012780:	2100      	movs	r1, #0
}
 1012782:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
 1012786:	3003      	adds	r0, #3
 1012788:	f014 b8ff 	b.w	102698a <memset>
 101278c:	21000168 	.word	0x21000168
 1012790:	21000160 	.word	0x21000160

01012794 <hci_vendor_cmd_handle_common>:
{
 1012794:	b570      	push	{r4, r5, r6, lr}
	switch (ocf) {
 1012796:	3801      	subs	r0, #1
{
 1012798:	4614      	mov	r4, r2
 101279a:	b086      	sub	sp, #24
	switch (ocf) {
 101279c:	2811      	cmp	r0, #17
 101279e:	d80a      	bhi.n	10127b6 <hci_vendor_cmd_handle_common+0x22>
 10127a0:	e8df f000 	tbb	[pc, r0]
 10127a4:	09593f23 	.word	0x09593f23
 10127a8:	7c096a09 	.word	0x7c096a09
 10127ac:	0909aa97 	.word	0x0909aa97
 10127b0:	09090909 	.word	0x09090909
 10127b4:	0d09      	.short	0x0d09
 10127b6:	f06f 0015 	mvn.w	r0, #21
}
 10127ba:	b006      	add	sp, #24
 10127bc:	bd70      	pop	{r4, r5, r6, pc}
	struct bt_hci_cp_vs_set_min_num_used_chans *cmd = (void *)buf->data;
 10127be:	68cb      	ldr	r3, [r1, #12]
	status = ll_set_min_used_chans(handle, cmd->phys, cmd->min_used_chans);
 10127c0:	78da      	ldrb	r2, [r3, #3]
 10127c2:	7899      	ldrb	r1, [r3, #2]
 10127c4:	8818      	ldrh	r0, [r3, #0]
 10127c6:	f008 fb79 	bl	101aebc <ll_set_min_used_chans>
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
 10127ca:	4b54      	ldr	r3, [pc, #336]	; (101291c <hci_vendor_cmd_handle_common+0x188>)
	status = ll_set_min_used_chans(handle, cmd->phys, cmd->min_used_chans);
 10127cc:	4606      	mov	r6, r0
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
 10127ce:	2101      	movs	r1, #1
 10127d0:	8818      	ldrh	r0, [r3, #0]
 10127d2:	f014 fae0 	bl	1026d96 <bt_hci_cmd_complete_create>
 10127d6:	2101      	movs	r1, #1
 10127d8:	4605      	mov	r5, r0
 10127da:	300c      	adds	r0, #12
 10127dc:	f00b fd5c 	bl	101e298 <net_buf_simple_add>
	ccst->status = status;
 10127e0:	7006      	strb	r6, [r0, #0]
	*evt = cmd_complete_status(status);
 10127e2:	6025      	str	r5, [r4, #0]
	return 0;
 10127e4:	2000      	movs	r0, #0
}
 10127e6:	b006      	add	sp, #24
 10127e8:	bd70      	pop	{r4, r5, r6, pc}
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 10127ea:	4b4c      	ldr	r3, [pc, #304]	; (101291c <hci_vendor_cmd_handle_common+0x188>)
 10127ec:	210d      	movs	r1, #13
 10127ee:	8818      	ldrh	r0, [r3, #0]
 10127f0:	f014 fad1 	bl	1026d96 <bt_hci_cmd_complete_create>
 10127f4:	210d      	movs	r1, #13
 10127f6:	6020      	str	r0, [r4, #0]
 10127f8:	300c      	adds	r0, #12
 10127fa:	f00b fd4d 	bl	101e298 <net_buf_simple_add>
	rp->fw_variant = 0U;
 10127fe:	f44f 7440 	mov.w	r4, #768	; 0x300
	rp->status = 0x00;
 1012802:	2300      	movs	r3, #0
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
 1012804:	2102      	movs	r1, #2
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
 1012806:	2263      	movs	r2, #99	; 0x63
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
 1012808:	4d45      	ldr	r5, [pc, #276]	; (1012920 <hci_vendor_cmd_handle_common+0x18c>)
	rp->status = 0x00;
 101280a:	7003      	strb	r3, [r0, #0]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
 101280c:	f8c0 5001 	str.w	r5, [r0, #1]
	rp->fw_variant = 0U;
 1012810:	f8a0 4005 	strh.w	r4, [r0, #5]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
 1012814:	71c1      	strb	r1, [r0, #7]
 1012816:	7203      	strb	r3, [r0, #8]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
 1012818:	7242      	strb	r2, [r0, #9]
 101281a:	7283      	strb	r3, [r0, #10]
 101281c:	72c3      	strb	r3, [r0, #11]
 101281e:	7303      	strb	r3, [r0, #12]
}
 1012820:	e7e0      	b.n	10127e4 <hci_vendor_cmd_handle_common+0x50>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012822:	4b3e      	ldr	r3, [pc, #248]	; (101291c <hci_vendor_cmd_handle_common+0x188>)
 1012824:	2141      	movs	r1, #65	; 0x41
 1012826:	8818      	ldrh	r0, [r3, #0]
 1012828:	f014 fab5 	bl	1026d96 <bt_hci_cmd_complete_create>
 101282c:	2141      	movs	r1, #65	; 0x41
 101282e:	6020      	str	r0, [r4, #0]
 1012830:	300c      	adds	r0, #12
 1012832:	f00b fd31 	bl	101e298 <net_buf_simple_add>
	rp->status = 0x00;
 1012836:	2100      	movs	r1, #0
 1012838:	4604      	mov	r4, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
 101283a:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
 101283c:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
 1012840:	f014 f8a3 	bl	102698a <memset>
	rp->commands[0] |= BIT(5) | BIT(7);
 1012844:	7862      	ldrb	r2, [r4, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
 1012846:	78a3      	ldrb	r3, [r4, #2]
	rp->commands[0] |= BIT(5) | BIT(7);
 1012848:	f062 0258 	orn	r2, r2, #88	; 0x58
	rp->commands[1] |= BIT(0) | BIT(1);
 101284c:	f043 0303 	orr.w	r3, r3, #3
	rp->commands[0] |= BIT(5) | BIT(7);
 1012850:	7062      	strb	r2, [r4, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
 1012852:	70a3      	strb	r3, [r4, #2]
}
 1012854:	e7c6      	b.n	10127e4 <hci_vendor_cmd_handle_common+0x50>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012856:	4b31      	ldr	r3, [pc, #196]	; (101291c <hci_vendor_cmd_handle_common+0x188>)
 1012858:	2109      	movs	r1, #9
 101285a:	8818      	ldrh	r0, [r3, #0]
 101285c:	f014 fa9b 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012860:	2109      	movs	r1, #9
 1012862:	6020      	str	r0, [r4, #0]
 1012864:	300c      	adds	r0, #12
 1012866:	f00b fd17 	bl	101e298 <net_buf_simple_add>
	rp->status = 0x00;
 101286a:	2100      	movs	r1, #0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 101286c:	2208      	movs	r2, #8
	rp->status = 0x00;
 101286e:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1012872:	f014 f88a 	bl	102698a <memset>
}
 1012876:	e7b5      	b.n	10127e4 <hci_vendor_cmd_handle_common+0x50>
	ll_addr_set(0, &cmd->bdaddr.val[0]);
 1012878:	68c9      	ldr	r1, [r1, #12]
 101287a:	2000      	movs	r0, #0
 101287c:	f7ff fd0e 	bl	101229c <ll_addr_set>
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
 1012880:	4b26      	ldr	r3, [pc, #152]	; (101291c <hci_vendor_cmd_handle_common+0x188>)
 1012882:	2101      	movs	r1, #1
 1012884:	8818      	ldrh	r0, [r3, #0]
 1012886:	f014 fa86 	bl	1026d96 <bt_hci_cmd_complete_create>
 101288a:	2101      	movs	r1, #1
 101288c:	4605      	mov	r5, r0
 101288e:	300c      	adds	r0, #12
 1012890:	f00b fd02 	bl	101e298 <net_buf_simple_add>
	ccst->status = status;
 1012894:	2300      	movs	r3, #0
 1012896:	7003      	strb	r3, [r0, #0]
	*evt = cmd_complete_status(0x00);
 1012898:	6025      	str	r5, [r4, #0]
}
 101289a:	e7a3      	b.n	10127e4 <hci_vendor_cmd_handle_common+0x50>
	const char build_info[] = HCI_VS_BUILD_INFO;
 101289c:	4d21      	ldr	r5, [pc, #132]	; (1012924 <hci_vendor_cmd_handle_common+0x190>)
 101289e:	f10d 0c04 	add.w	ip, sp, #4
 10128a2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 10128a4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 10128a8:	4e1c      	ldr	r6, [pc, #112]	; (101291c <hci_vendor_cmd_handle_common+0x188>)
	const char build_info[] = HCI_VS_BUILD_INFO;
 10128aa:	682b      	ldr	r3, [r5, #0]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 10128ac:	2113      	movs	r1, #19
 10128ae:	8830      	ldrh	r0, [r6, #0]
	const char build_info[] = HCI_VS_BUILD_INFO;
 10128b0:	f8ac 3000 	strh.w	r3, [ip]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 10128b4:	f014 fa6f 	bl	1026d96 <bt_hci_cmd_complete_create>
 10128b8:	2113      	movs	r1, #19
 10128ba:	6020      	str	r0, [r4, #0]
 10128bc:	300c      	adds	r0, #12
 10128be:	f00b fceb 	bl	101e298 <net_buf_simple_add>
	rp->status = 0x00;
 10128c2:	2300      	movs	r3, #0
	memcpy(rp->info, build_info, sizeof(build_info));
 10128c4:	2212      	movs	r2, #18
 10128c6:	a901      	add	r1, sp, #4
	rp->status = 0x00;
 10128c8:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(rp->info, build_info, sizeof(build_info));
 10128cc:	f014 f852 	bl	1026974 <memcpy>
}
 10128d0:	e788      	b.n	10127e4 <hci_vendor_cmd_handle_common+0x50>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 10128d2:	4b12      	ldr	r3, [pc, #72]	; (101291c <hci_vendor_cmd_handle_common+0x188>)
 10128d4:	2118      	movs	r1, #24
 10128d6:	8818      	ldrh	r0, [r3, #0]
 10128d8:	f014 fa5d 	bl	1026d96 <bt_hci_cmd_complete_create>
 10128dc:	2118      	movs	r1, #24
 10128de:	6020      	str	r0, [r4, #0]
 10128e0:	300c      	adds	r0, #12
 10128e2:	f00b fcd9 	bl	101e298 <net_buf_simple_add>
	rp->status = 0x00;
 10128e6:	2300      	movs	r3, #0
 10128e8:	4604      	mov	r4, r0
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
 10128ea:	2101      	movs	r1, #1
	rp->status = 0x00;
 10128ec:	f800 3b02 	strb.w	r3, [r0], #2
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
 10128f0:	f00b f984 	bl	101dbfc <hci_vendor_read_static_addr>
 10128f4:	7060      	strb	r0, [r4, #1]
}
 10128f6:	e775      	b.n	10127e4 <hci_vendor_cmd_handle_common+0x50>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 10128f8:	4b08      	ldr	r3, [pc, #32]	; (101291c <hci_vendor_cmd_handle_common+0x188>)
 10128fa:	2121      	movs	r1, #33	; 0x21
 10128fc:	8818      	ldrh	r0, [r3, #0]
 10128fe:	f014 fa4a 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012902:	2121      	movs	r1, #33	; 0x21
 1012904:	6020      	str	r0, [r4, #0]
 1012906:	300c      	adds	r0, #12
 1012908:	f00b fcc6 	bl	101e298 <net_buf_simple_add>
	rp->status = 0x00;
 101290c:	2300      	movs	r3, #0
 101290e:	4601      	mov	r1, r0
	hci_vendor_read_key_hierarchy_roots(rp->ir, rp->er);
 1012910:	3001      	adds	r0, #1
	rp->status = 0x00;
 1012912:	f801 3b11 	strb.w	r3, [r1], #17
	hci_vendor_read_key_hierarchy_roots(rp->ir, rp->er);
 1012916:	f00b f9c1 	bl	101dc9c <hci_vendor_read_key_hierarchy_roots>
}
 101291a:	e763      	b.n	10127e4 <hci_vendor_cmd_handle_common+0x50>
 101291c:	210081d2 	.word	0x210081d2
 1012920:	00030002 	.word	0x00030002
 1012924:	0102a370 	.word	0x0102a370

01012928 <hci_cmd_handle>:
{
 1012928:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct net_buf *evt = NULL;
 101292c:	2400      	movs	r4, #0
	if (cmd->len < sizeof(*chdr)) {
 101292e:	8a02      	ldrh	r2, [r0, #16]
{
 1012930:	b08e      	sub	sp, #56	; 0x38
	if (cmd->len < sizeof(*chdr)) {
 1012932:	2a02      	cmp	r2, #2
	struct net_buf *evt = NULL;
 1012934:	9407      	str	r4, [sp, #28]
	if (cmd->len < sizeof(*chdr)) {
 1012936:	f240 8115 	bls.w	1012b64 <hci_cmd_handle+0x23c>
	return net_buf_simple_pull_mem(&buf->b, len);
 101293a:	4605      	mov	r5, r0
 101293c:	2103      	movs	r1, #3
 101293e:	300c      	adds	r0, #12
 1012940:	f00b fc8c 	bl	101e25c <net_buf_simple_pull_mem>
	if (cmd->len < chdr->param_len) {
 1012944:	8a29      	ldrh	r1, [r5, #16]
 1012946:	7882      	ldrb	r2, [r0, #2]
 1012948:	4291      	cmp	r1, r2
 101294a:	f0c0 8149 	bcc.w	1012be0 <hci_cmd_handle+0x2b8>
	_opcode = sys_le16_to_cpu(chdr->opcode);
 101294e:	8802      	ldrh	r2, [r0, #0]
 1012950:	4ed2      	ldr	r6, [pc, #840]	; (1012c9c <hci_cmd_handle+0x374>)
	switch (BT_OGF(_opcode)) {
 1012952:	f3c2 2385 	ubfx	r3, r2, #10, #6
 1012956:	2b08      	cmp	r3, #8
	_opcode = sys_le16_to_cpu(chdr->opcode);
 1012958:	8032      	strh	r2, [r6, #0]
 101295a:	b290      	uxth	r0, r2
	ocf = BT_OCF(_opcode);
 101295c:	f3c2 0409 	ubfx	r4, r2, #0, #10
	switch (BT_OGF(_opcode)) {
 1012960:	d809      	bhi.n	1012976 <hci_cmd_handle+0x4e>
 1012962:	b19b      	cbz	r3, 101298c <hci_cmd_handle+0x64>
 1012964:	3b01      	subs	r3, #1
 1012966:	2b07      	cmp	r3, #7
 1012968:	d810      	bhi.n	101298c <hci_cmd_handle+0x64>
 101296a:	e8df f003 	tbb	[pc, r3]
 101296e:	0f15      	.short	0x0f15
 1012970:	0f0fe1bd 	.word	0x0f0fe1bd
 1012974:	210f      	.short	0x210f
 1012976:	2b3f      	cmp	r3, #63	; 0x3f
 1012978:	d108      	bne.n	101298c <hci_cmd_handle+0x64>

/* Map vendor command handler directly to common implementation */
inline int hci_vendor_cmd_handle(uint16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
	return hci_vendor_cmd_handle_common(ocf, cmd, evt);
 101297a:	4629      	mov	r1, r5
 101297c:	4620      	mov	r0, r4
 101297e:	aa07      	add	r2, sp, #28
 1012980:	f7ff ff08 	bl	1012794 <hci_vendor_cmd_handle_common>
	if (err == -EINVAL) {
 1012984:	3016      	adds	r0, #22
 1012986:	f040 83bd 	bne.w	1013104 <hci_cmd_handle+0x7dc>
	return bt_hci_cmd_status_create(_opcode, status);
 101298a:	8830      	ldrh	r0, [r6, #0]
 101298c:	2101      	movs	r1, #1
}
 101298e:	b00e      	add	sp, #56	; 0x38
 1012990:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_hci_cmd_status_create(_opcode, status);
 1012994:	f014 ba11 	b.w	1026dba <bt_hci_cmd_status_create>
	switch (ocf) {
 1012998:	2c06      	cmp	r4, #6
 101299a:	f000 836d 	beq.w	1013078 <hci_cmd_handle+0x750>
 101299e:	2c1d      	cmp	r4, #29
 10129a0:	d1f4      	bne.n	101298c <hci_cmd_handle+0x64>
	handle = sys_le16_to_cpu(cmd->handle);
 10129a2:	68eb      	ldr	r3, [r5, #12]
	status = ll_version_ind_send(handle);
 10129a4:	8818      	ldrh	r0, [r3, #0]
 10129a6:	f003 fa03 	bl	1015db0 <ll_version_ind_send>
 10129aa:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 10129ac:	8830      	ldrh	r0, [r6, #0]
 10129ae:	e7ee      	b.n	101298e <hci_cmd_handle+0x66>
	switch (ocf) {
 10129b0:	1e62      	subs	r2, r4, #1
 10129b2:	2a4a      	cmp	r2, #74	; 0x4a
 10129b4:	d8ea      	bhi.n	101298c <hci_cmd_handle+0x64>
 10129b6:	a301      	add	r3, pc, #4	; (adr r3, 10129bc <hci_cmd_handle+0x94>)
 10129b8:	f853 f022 	ldr.w	pc, [r3, r2, lsl #2]
 10129bc:	01012d6b 	.word	0x01012d6b
 10129c0:	01012d49 	.word	0x01012d49
 10129c4:	01012d01 	.word	0x01012d01
 10129c8:	0101298d 	.word	0x0101298d
 10129cc:	01012ce1 	.word	0x01012ce1
 10129d0:	01012e09 	.word	0x01012e09
 10129d4:	01012df1 	.word	0x01012df1
 10129d8:	01012de5 	.word	0x01012de5
 10129dc:	01012dd9 	.word	0x01012dd9
 10129e0:	01012dcf 	.word	0x01012dcf
 10129e4:	0101298d 	.word	0x0101298d
 10129e8:	0101298d 	.word	0x0101298d
 10129ec:	0101298d 	.word	0x0101298d
 10129f0:	0101298d 	.word	0x0101298d
 10129f4:	0101298d 	.word	0x0101298d
 10129f8:	0101298d 	.word	0x0101298d
 10129fc:	0101298d 	.word	0x0101298d
 1012a00:	0101298d 	.word	0x0101298d
 1012a04:	01012dad 	.word	0x01012dad
 1012a08:	0101298d 	.word	0x0101298d
 1012a0c:	01012d85 	.word	0x01012d85
 1012a10:	01012d77 	.word	0x01012d77
 1012a14:	01013049 	.word	0x01013049
 1012a18:	0101302b 	.word	0x0101302b
 1012a1c:	0101298d 	.word	0x0101298d
 1012a20:	01013021 	.word	0x01013021
 1012a24:	01013011 	.word	0x01013011
 1012a28:	01012fe3 	.word	0x01012fe3
 1012a2c:	0101298d 	.word	0x0101298d
 1012a30:	0101298d 	.word	0x0101298d
 1012a34:	0101298d 	.word	0x0101298d
 1012a38:	01012fc3 	.word	0x01012fc3
 1012a3c:	01012fa9 	.word	0x01012fa9
 1012a40:	01012f99 	.word	0x01012f99
 1012a44:	01012f67 	.word	0x01012f67
 1012a48:	01012f5b 	.word	0x01012f5b
 1012a4c:	0101298d 	.word	0x0101298d
 1012a50:	0101298d 	.word	0x0101298d
 1012a54:	0101298d 	.word	0x0101298d
 1012a58:	0101298d 	.word	0x0101298d
 1012a5c:	0101298d 	.word	0x0101298d
 1012a60:	0101298d 	.word	0x0101298d
 1012a64:	0101298d 	.word	0x0101298d
 1012a68:	0101298d 	.word	0x0101298d
 1012a6c:	0101298d 	.word	0x0101298d
 1012a70:	0101298d 	.word	0x0101298d
 1012a74:	01012f13 	.word	0x01012f13
 1012a78:	01012ebd 	.word	0x01012ebd
 1012a7c:	01012e9b 	.word	0x01012e9b
 1012a80:	01012e45 	.word	0x01012e45
 1012a84:	0101298d 	.word	0x0101298d
 1012a88:	0101298d 	.word	0x0101298d
 1012a8c:	0101298d 	.word	0x0101298d
 1012a90:	0101298d 	.word	0x0101298d
 1012a94:	0101298d 	.word	0x0101298d
 1012a98:	0101298d 	.word	0x0101298d
 1012a9c:	0101298d 	.word	0x0101298d
 1012aa0:	0101298d 	.word	0x0101298d
 1012aa4:	0101298d 	.word	0x0101298d
 1012aa8:	0101298d 	.word	0x0101298d
 1012aac:	0101298d 	.word	0x0101298d
 1012ab0:	0101298d 	.word	0x0101298d
 1012ab4:	0101298d 	.word	0x0101298d
 1012ab8:	0101298d 	.word	0x0101298d
 1012abc:	0101298d 	.word	0x0101298d
 1012ac0:	0101298d 	.word	0x0101298d
 1012ac4:	0101298d 	.word	0x0101298d
 1012ac8:	0101298d 	.word	0x0101298d
 1012acc:	0101298d 	.word	0x0101298d
 1012ad0:	0101298d 	.word	0x0101298d
 1012ad4:	0101298d 	.word	0x0101298d
 1012ad8:	0101298d 	.word	0x0101298d
 1012adc:	0101298d 	.word	0x0101298d
 1012ae0:	0101298d 	.word	0x0101298d
 1012ae4:	01012e25 	.word	0x01012e25
	switch (ocf) {
 1012ae8:	2c63      	cmp	r4, #99	; 0x63
 1012aea:	f000 82cd 	beq.w	1013088 <hci_cmd_handle+0x760>
 1012aee:	d85d      	bhi.n	1012bac <hci_cmd_handle+0x284>
 1012af0:	2c03      	cmp	r4, #3
 1012af2:	f000 82cc 	beq.w	101308e <hci_cmd_handle+0x766>
 1012af6:	2c2d      	cmp	r4, #45	; 0x2d
 1012af8:	d144      	bne.n	1012b84 <hci_cmd_handle+0x25c>
	struct bt_hci_cp_read_tx_power_level *cmd = (void *)buf->data;
 1012afa:	68eb      	ldr	r3, [r5, #12]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012afc:	2104      	movs	r1, #4
	handle = sys_le16_to_cpu(cmd->handle);
 1012afe:	881e      	ldrh	r6, [r3, #0]
	type = cmd->type;
 1012b00:	f893 8002 	ldrb.w	r8, [r3, #2]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012b04:	f014 f947 	bl	1026d96 <bt_hci_cmd_complete_create>
	return net_buf_simple_add(&buf->b, len);
 1012b08:	2104      	movs	r1, #4
 1012b0a:	4604      	mov	r4, r0
 1012b0c:	300c      	adds	r0, #12
 1012b0e:	f00b fbc3 	bl	101e298 <net_buf_simple_add>
 1012b12:	4605      	mov	r5, r0
	handle = sys_le16_to_cpu(cmd->handle);
 1012b14:	b2b7      	uxth	r7, r6
	status = ll_tx_pwr_lvl_get(BT_HCI_VS_LL_HANDLE_TYPE_CONN,
 1012b16:	4642      	mov	r2, r8
 1012b18:	4639      	mov	r1, r7
 1012b1a:	2002      	movs	r0, #2
 1012b1c:	1ceb      	adds	r3, r5, #3
 1012b1e:	f7ff fc01 	bl	1012324 <ll_tx_pwr_lvl_get>
	rp->handle = sys_cpu_to_le16(handle);
 1012b22:	f8a5 6001 	strh.w	r6, [r5, #1]
	rp->status = status;
 1012b26:	7028      	strb	r0, [r5, #0]
}
 1012b28:	4620      	mov	r0, r4
 1012b2a:	b00e      	add	sp, #56	; 0x38
 1012b2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (ocf) {
 1012b30:	1e62      	subs	r2, r4, #1
 1012b32:	2a08      	cmp	r2, #8
 1012b34:	f63f af2a 	bhi.w	101298c <hci_cmd_handle+0x64>
 1012b38:	a301      	add	r3, pc, #4	; (adr r3, 1012b40 <hci_cmd_handle+0x218>)
 1012b3a:	f853 f022 	ldr.w	pc, [r3, r2, lsl #2]
 1012b3e:	bf00      	nop
 1012b40:	01012cb9 	.word	0x01012cb9
 1012b44:	01012c29 	.word	0x01012c29
 1012b48:	01012c05 	.word	0x01012c05
 1012b4c:	0101298d 	.word	0x0101298d
 1012b50:	0101298d 	.word	0x0101298d
 1012b54:	0101298d 	.word	0x0101298d
 1012b58:	0101298d 	.word	0x0101298d
 1012b5c:	0101298d 	.word	0x0101298d
 1012b60:	01012be7 	.word	0x01012be7
		LOG_ERR("No HCI Command header");
 1012b64:	2302      	movs	r3, #2
 1012b66:	4a4e      	ldr	r2, [pc, #312]	; (1012ca0 <hci_cmd_handle+0x378>)
		LOG_ERR("Invalid HCI CMD packet length");
 1012b68:	e9cd 320c 	strd	r3, r2, [sp, #48]	; 0x30
 1012b6c:	4623      	mov	r3, r4
		return NULL;
 1012b6e:	2400      	movs	r4, #0
 1012b70:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 1012b74:	484b      	ldr	r0, [pc, #300]	; (1012ca4 <hci_cmd_handle+0x37c>)
 1012b76:	aa0c      	add	r2, sp, #48	; 0x30
 1012b78:	f7f1 fdc6 	bl	1004708 <z_impl_z_log_msg_static_create>
}
 1012b7c:	4620      	mov	r0, r4
 1012b7e:	b00e      	add	sp, #56	; 0x38
 1012b80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (ocf) {
 1012b84:	2c01      	cmp	r4, #1
 1012b86:	f47f af01 	bne.w	101298c <hci_cmd_handle+0x64>
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
 1012b8a:	68ea      	ldr	r2, [r5, #12]
	event_mask = sys_get_le64(cmd->events);
 1012b8c:	4b46      	ldr	r3, [pc, #280]	; (1012ca8 <hci_cmd_handle+0x380>)
 1012b8e:	6811      	ldr	r1, [r2, #0]
 1012b90:	6852      	ldr	r2, [r2, #4]
 1012b92:	6019      	str	r1, [r3, #0]
	event_mask_page_2 = sys_get_le64(cmd->events_page_2);
 1012b94:	605a      	str	r2, [r3, #4]
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
 1012b96:	2101      	movs	r1, #1
 1012b98:	f014 f8fd 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012b9c:	2101      	movs	r1, #1
 1012b9e:	4604      	mov	r4, r0
 1012ba0:	300c      	adds	r0, #12
 1012ba2:	f00b fb79 	bl	101e298 <net_buf_simple_add>
	ccst->status = status;
 1012ba6:	2300      	movs	r3, #0
 1012ba8:	7003      	strb	r3, [r0, #0]
	if (err == -EINVAL) {
 1012baa:	e7bd      	b.n	1012b28 <hci_cmd_handle+0x200>
	switch (ocf) {
 1012bac:	2c7b      	cmp	r4, #123	; 0x7b
 1012bae:	f000 8291 	beq.w	10130d4 <hci_cmd_handle+0x7ac>
 1012bb2:	2c7c      	cmp	r4, #124	; 0x7c
 1012bb4:	f47f aeea 	bne.w	101298c <hci_cmd_handle+0x64>
	struct bt_hci_cp_write_auth_payload_timeout *cmd = (void *)buf->data;
 1012bb8:	68eb      	ldr	r3, [r5, #12]
	handle = sys_le16_to_cpu(cmd->handle);
 1012bba:	881f      	ldrh	r7, [r3, #0]
	status = ll_apto_set(handle, auth_payload_timeout);
 1012bbc:	8859      	ldrh	r1, [r3, #2]
 1012bbe:	b2b8      	uxth	r0, r7
 1012bc0:	f003 f9fe 	bl	1015fc0 <ll_apto_set>
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
 1012bc4:	4605      	mov	r5, r0
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012bc6:	2103      	movs	r1, #3
 1012bc8:	8830      	ldrh	r0, [r6, #0]
 1012bca:	f014 f8e4 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012bce:	2103      	movs	r1, #3
 1012bd0:	4604      	mov	r4, r0
 1012bd2:	300c      	adds	r0, #12
 1012bd4:	f00b fb60 	bl	101e298 <net_buf_simple_add>
	rp->status = status;
 1012bd8:	7005      	strb	r5, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
 1012bda:	f8a0 7001 	strh.w	r7, [r0, #1]
	if (err == -EINVAL) {
 1012bde:	e7a3      	b.n	1012b28 <hci_cmd_handle+0x200>
		LOG_ERR("Invalid HCI CMD packet length");
 1012be0:	2302      	movs	r3, #2
 1012be2:	4a32      	ldr	r2, [pc, #200]	; (1012cac <hci_cmd_handle+0x384>)
 1012be4:	e7c0      	b.n	1012b68 <hci_cmd_handle+0x240>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012be6:	2107      	movs	r1, #7
 1012be8:	f014 f8d5 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012bec:	2107      	movs	r1, #7
 1012bee:	4604      	mov	r4, r0
 1012bf0:	300c      	adds	r0, #12
 1012bf2:	f00b fb51 	bl	101e298 <net_buf_simple_add>
 1012bf6:	4601      	mov	r1, r0
	rp->status = 0x00;
 1012bf8:	2000      	movs	r0, #0
 1012bfa:	f801 0b01 	strb.w	r0, [r1], #1
	(void)ll_addr_read(0, &rp->bdaddr.val[0]);
 1012bfe:	f7ff fb79 	bl	10122f4 <ll_addr_read>
	if (err == -EINVAL) {
 1012c02:	e791      	b.n	1012b28 <hci_cmd_handle+0x200>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012c04:	2109      	movs	r1, #9
 1012c06:	f014 f8c6 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012c0a:	2109      	movs	r1, #9
 1012c0c:	4604      	mov	r4, r0
 1012c0e:	300c      	adds	r0, #12
 1012c10:	f00b fb42 	bl	101e298 <net_buf_simple_add>
	rp->status = 0x00;
 1012c14:	2100      	movs	r1, #0
 1012c16:	4605      	mov	r5, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1012c18:	2208      	movs	r2, #8
	rp->status = 0x00;
 1012c1a:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1012c1e:	f013 feb4 	bl	102698a <memset>
	rp->features[4] = (1 << 5) | (1 << 6);
 1012c22:	2360      	movs	r3, #96	; 0x60
 1012c24:	716b      	strb	r3, [r5, #5]
	if (err == -EINVAL) {
 1012c26:	e77f      	b.n	1012b28 <hci_cmd_handle+0x200>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012c28:	2141      	movs	r1, #65	; 0x41
 1012c2a:	f014 f8b4 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012c2e:	2141      	movs	r1, #65	; 0x41
 1012c30:	4604      	mov	r4, r0
 1012c32:	300c      	adds	r0, #12
 1012c34:	f00b fb30 	bl	101e298 <net_buf_simple_add>
	rp->status = 0x00;
 1012c38:	2100      	movs	r1, #0
 1012c3a:	4605      	mov	r5, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
 1012c3c:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
 1012c3e:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
 1012c42:	f013 fea2 	bl	102698a <memset>
	rp->commands[10] |= BIT(2);
 1012c46:	7aeb      	ldrb	r3, [r5, #11]
	rp->commands[5] |= BIT(6) | BIT(7);
 1012c48:	79a9      	ldrb	r1, [r5, #6]
	rp->commands[10] |= BIT(2);
 1012c4a:	f043 0304 	orr.w	r3, r3, #4
	rp->commands[14] |= BIT(3) | BIT(5);
 1012c4e:	7bea      	ldrb	r2, [r5, #15]
	rp->commands[10] |= BIT(2);
 1012c50:	72eb      	strb	r3, [r5, #11]
	rp->commands[15] |= BIT(1);
 1012c52:	7c2b      	ldrb	r3, [r5, #16]
	rp->commands[5] |= BIT(6) | BIT(7);
 1012c54:	f061 013f 	orn	r1, r1, #63	; 0x3f
	rp->commands[14] |= BIT(3) | BIT(5);
 1012c58:	f042 0228 	orr.w	r2, r2, #40	; 0x28
	rp->commands[15] |= BIT(1);
 1012c5c:	f043 0302 	orr.w	r3, r3, #2
	rp->commands[25] |= BIT(0) | BIT(1) | BIT(2) | BIT(4);
 1012c60:	f8d5 001a 	ldr.w	r0, [r5, #26]
	rp->commands[5] |= BIT(6) | BIT(7);
 1012c64:	71a9      	strb	r1, [r5, #6]
	rp->commands[14] |= BIT(3) | BIT(5);
 1012c66:	73ea      	strb	r2, [r5, #15]
	rp->commands[22] |= BIT(2);
 1012c68:	7de9      	ldrb	r1, [r5, #23]
	rp->commands[0] |= BIT(5);
 1012c6a:	786a      	ldrb	r2, [r5, #1]
	rp->commands[15] |= BIT(1);
 1012c6c:	742b      	strb	r3, [r5, #16]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
 1012c6e:	4b10      	ldr	r3, [pc, #64]	; (1012cb0 <hci_cmd_handle+0x388>)
	rp->commands[22] |= BIT(2);
 1012c70:	f041 0104 	orr.w	r1, r1, #4
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
 1012c74:	4303      	orrs	r3, r0
	rp->commands[0] |= BIT(5);
 1012c76:	f042 0220 	orr.w	r2, r2, #32
	rp->commands[22] |= BIT(2);
 1012c7a:	75e9      	strb	r1, [r5, #23]
	rp->commands[0] |= BIT(5);
 1012c7c:	706a      	strb	r2, [r5, #1]
	rp->commands[32] |= BIT(4) | BIT(5);
 1012c7e:	f8d5 1021 	ldr.w	r1, [r5, #33]	; 0x21
 1012c82:	4a0c      	ldr	r2, [pc, #48]	; (1012cb4 <hci_cmd_handle+0x38c>)
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
 1012c84:	f8c5 301a 	str.w	r3, [r5, #26]
	rp->commands[38] |= BIT(7);
 1012c88:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
	rp->commands[32] |= BIT(4) | BIT(5);
 1012c8c:	430a      	orrs	r2, r1
	rp->commands[38] |= BIT(7);
 1012c8e:	f063 037f 	orn	r3, r3, #127	; 0x7f
	rp->commands[32] |= BIT(4) | BIT(5);
 1012c92:	f8c5 2021 	str.w	r2, [r5, #33]	; 0x21
	rp->commands[38] |= BIT(7);
 1012c96:	f885 3027 	strb.w	r3, [r5, #39]	; 0x27
	if (err == -EINVAL) {
 1012c9a:	e745      	b.n	1012b28 <hci_cmd_handle+0x200>
 1012c9c:	210081d2 	.word	0x210081d2
 1012ca0:	0102a384 	.word	0x0102a384
 1012ca4:	0102997c 	.word	0x0102997c
 1012ca8:	21000168 	.word	0x21000168
 1012cac:	0102a39c 	.word	0x0102a39c
 1012cb0:	0ef403f7 	.word	0x0ef403f7
 1012cb4:	7801f030 	.word	0x7801f030
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012cb8:	2109      	movs	r1, #9
 1012cba:	f014 f86c 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012cbe:	2109      	movs	r1, #9
 1012cc0:	4604      	mov	r4, r0
 1012cc2:	300c      	adds	r0, #12
 1012cc4:	f00b fae8 	bl	101e298 <net_buf_simple_add>
	rp->hci_revision = sys_cpu_to_le16(0);
 1012cc8:	2300      	movs	r3, #0
	rp->status = 0x00;
 1012cca:	f44f 6140 	mov.w	r1, #3072	; 0xc00
	rp->lmp_version = LL_VERSION_NUMBER;
 1012cce:	220c      	movs	r2, #12
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
 1012cd0:	4dcb      	ldr	r5, [pc, #812]	; (1013000 <hci_cmd_handle+0x6d8>)
	rp->status = 0x00;
 1012cd2:	8001      	strh	r1, [r0, #0]
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
 1012cd4:	f8c0 5005 	str.w	r5, [r0, #5]
	rp->hci_revision = sys_cpu_to_le16(0);
 1012cd8:	7083      	strb	r3, [r0, #2]
 1012cda:	70c3      	strb	r3, [r0, #3]
	rp->lmp_version = LL_VERSION_NUMBER;
 1012cdc:	7102      	strb	r2, [r0, #4]
	if (err == -EINVAL) {
 1012cde:	e723      	b.n	1012b28 <hci_cmd_handle+0x200>
	status = ll_addr_set(1, &cmd->bdaddr.val[0]);
 1012ce0:	2001      	movs	r0, #1
 1012ce2:	68e9      	ldr	r1, [r5, #12]
 1012ce4:	f7ff fada 	bl	101229c <ll_addr_set>
	status = ll_phy_default_set(cmd->tx_phys, cmd->rx_phys);
 1012ce8:	4605      	mov	r5, r0
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
 1012cea:	2101      	movs	r1, #1
 1012cec:	8830      	ldrh	r0, [r6, #0]
 1012cee:	f014 f852 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012cf2:	2101      	movs	r1, #1
 1012cf4:	4604      	mov	r4, r0
 1012cf6:	300c      	adds	r0, #12
 1012cf8:	f00b face 	bl	101e298 <net_buf_simple_add>
	ccst->status = status;
 1012cfc:	7005      	strb	r5, [r0, #0]
	if (err == -EINVAL) {
 1012cfe:	e713      	b.n	1012b28 <hci_cmd_handle+0x200>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012d00:	2109      	movs	r1, #9
 1012d02:	f014 f848 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012d06:	2109      	movs	r1, #9
 1012d08:	4604      	mov	r4, r0
 1012d0a:	300c      	adds	r0, #12
 1012d0c:	f00b fac4 	bl	101e298 <net_buf_simple_add>
	rp->status = 0x00;
 1012d10:	2500      	movs	r5, #0
 1012d12:	4606      	mov	r6, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1012d14:	2208      	movs	r2, #8
 1012d16:	4629      	mov	r1, r5
	rp->status = 0x00;
 1012d18:	f800 5b01 	strb.w	r5, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1012d1c:	f013 fe35 	bl	102698a <memset>
	sys_put_le64(ll_feat_get(), rp->features);
 1012d20:	f000 fe0e 	bl	1013940 <ll_feat_get>
	dst[0] = val;
 1012d24:	462b      	mov	r3, r5
	dst[1] = val >> 8;
 1012d26:	f3c1 2207 	ubfx	r2, r1, #8, #8
	dst[0] = val;
 1012d2a:	f361 0307 	bfi	r3, r1, #0, #8
 1012d2e:	f362 230f 	bfi	r3, r2, #8, #8
	sys_put_le16(val >> 16, &dst[2]);
 1012d32:	0c09      	lsrs	r1, r1, #16
	dst[0] = val;
 1012d34:	f361 4317 	bfi	r3, r1, #16, #8
	dst[1] = val >> 8;
 1012d38:	0a09      	lsrs	r1, r1, #8
	dst[0] = val;
 1012d3a:	f361 631f 	bfi	r3, r1, #24, #8
 1012d3e:	f8c6 0001 	str.w	r0, [r6, #1]
 1012d42:	f8c6 3005 	str.w	r3, [r6, #5]
	if (err == -EINVAL) {
 1012d46:	e6ef      	b.n	1012b28 <hci_cmd_handle+0x200>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012d48:	2104      	movs	r1, #4
 1012d4a:	f014 f824 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012d4e:	2104      	movs	r1, #4
 1012d50:	4604      	mov	r4, r0
 1012d52:	300c      	adds	r0, #12
 1012d54:	f00b faa0 	bl	101e298 <net_buf_simple_add>
	rp->status = 0x00;
 1012d58:	2300      	movs	r3, #0
	rp->le_max_len = sys_cpu_to_le16(LL_LENGTH_OCTETS_TX_MAX);
 1012d5a:	f06f 0104 	mvn.w	r1, #4
	rp->le_max_num = CONFIG_BT_BUF_ACL_TX_COUNT;
 1012d5e:	2203      	movs	r2, #3
	rp->status = 0x00;
 1012d60:	7003      	strb	r3, [r0, #0]
	rp->le_max_len = sys_cpu_to_le16(LL_LENGTH_OCTETS_TX_MAX);
 1012d62:	7041      	strb	r1, [r0, #1]
 1012d64:	7083      	strb	r3, [r0, #2]
	rp->le_max_num = CONFIG_BT_BUF_ACL_TX_COUNT;
 1012d66:	70c2      	strb	r2, [r0, #3]
	if (err == -EINVAL) {
 1012d68:	e6de      	b.n	1012b28 <hci_cmd_handle+0x200>
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
 1012d6a:	68ea      	ldr	r2, [r5, #12]
	le_event_mask = sys_get_le64(cmd->events);
 1012d6c:	4ba5      	ldr	r3, [pc, #660]	; (1013004 <hci_cmd_handle+0x6dc>)
 1012d6e:	6811      	ldr	r1, [r2, #0]
 1012d70:	6852      	ldr	r2, [r2, #4]
	event_mask_page_2 = sys_get_le64(cmd->events_page_2);
 1012d72:	6019      	str	r1, [r3, #0]
 1012d74:	e70e      	b.n	1012b94 <hci_cmd_handle+0x26c>
	handle = sys_le16_to_cpu(cmd->handle);
 1012d76:	68eb      	ldr	r3, [r5, #12]
	status = ll_feature_req_send(handle);
 1012d78:	8818      	ldrh	r0, [r3, #0]
 1012d7a:	f002 fff5 	bl	1015d68 <ll_feature_req_send>
 1012d7e:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 1012d80:	8830      	ldrh	r0, [r6, #0]
 1012d82:	e604      	b.n	101298e <hci_cmd_handle+0x66>
	handle = sys_le16_to_cpu(cmd->handle);
 1012d84:	68eb      	ldr	r3, [r5, #12]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012d86:	2108      	movs	r1, #8
	handle = sys_le16_to_cpu(cmd->handle);
 1012d88:	881e      	ldrh	r6, [r3, #0]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012d8a:	f014 f804 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012d8e:	2108      	movs	r1, #8
 1012d90:	4604      	mov	r4, r0
 1012d92:	300c      	adds	r0, #12
 1012d94:	f00b fa80 	bl	101e298 <net_buf_simple_add>
 1012d98:	4605      	mov	r5, r0
	handle = sys_le16_to_cpu(cmd->handle);
 1012d9a:	b2b7      	uxth	r7, r6
	status = ll_chm_get(handle, rp->ch_map);
 1012d9c:	4638      	mov	r0, r7
 1012d9e:	1ce9      	adds	r1, r5, #3
 1012da0:	f002 ff86 	bl	1015cb0 <ll_chm_get>
	rp->handle = sys_le16_to_cpu(handle);
 1012da4:	f8a5 6001 	strh.w	r6, [r5, #1]
	rp->status = status;
 1012da8:	7028      	strb	r0, [r5, #0]
	if (err == -EINVAL) {
 1012daa:	e6bd      	b.n	1012b28 <hci_cmd_handle+0x200>
	status = ll_conn_update(handle, 0, 0, conn_interval_min,
 1012dac:	2200      	movs	r2, #0
	struct hci_cp_le_conn_update *cmd = (void *)buf->data;
 1012dae:	68e9      	ldr	r1, [r5, #12]
	status = ll_conn_update(handle, 0, 0, conn_interval_min,
 1012db0:	884b      	ldrh	r3, [r1, #2]
 1012db2:	8808      	ldrh	r0, [r1, #0]
 1012db4:	9203      	str	r2, [sp, #12]
 1012db6:	890c      	ldrh	r4, [r1, #8]
 1012db8:	9402      	str	r4, [sp, #8]
 1012dba:	88cc      	ldrh	r4, [r1, #6]
 1012dbc:	9401      	str	r4, [sp, #4]
 1012dbe:	8889      	ldrh	r1, [r1, #4]
 1012dc0:	9100      	str	r1, [sp, #0]
 1012dc2:	4611      	mov	r1, r2
 1012dc4:	f002 ff2c 	bl	1015c20 <ll_conn_update>
 1012dc8:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 1012dca:	8830      	ldrh	r0, [r6, #0]
 1012dcc:	e5df      	b.n	101298e <hci_cmd_handle+0x66>
	status = ll_adv_enable(cmd->enable);
 1012dce:	68eb      	ldr	r3, [r5, #12]
 1012dd0:	7818      	ldrb	r0, [r3, #0]
 1012dd2:	f7ed fd4d 	bl	1000870 <ll_adv_enable>
 1012dd6:	e787      	b.n	1012ce8 <hci_cmd_handle+0x3c0>
	status = ll_adv_scan_rsp_set(cmd->len, &cmd->data[0]);
 1012dd8:	68e9      	ldr	r1, [r5, #12]
 1012dda:	f811 0b01 	ldrb.w	r0, [r1], #1
 1012dde:	f002 fcad 	bl	101573c <ll_adv_scan_rsp_set>
 1012de2:	e781      	b.n	1012ce8 <hci_cmd_handle+0x3c0>
	status = ll_adv_data_set(cmd->len, &cmd->data[0]);
 1012de4:	68e9      	ldr	r1, [r5, #12]
 1012de6:	f811 0b01 	ldrb.w	r0, [r1], #1
 1012dea:	f002 fc39 	bl	1015660 <ll_adv_data_set>
 1012dee:	e77b      	b.n	1012ce8 <hci_cmd_handle+0x3c0>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012df0:	2102      	movs	r1, #2
 1012df2:	f013 ffd0 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012df6:	2102      	movs	r1, #2
 1012df8:	4604      	mov	r4, r0
 1012dfa:	300c      	adds	r0, #12
 1012dfc:	f00b fa4c 	bl	101e298 <net_buf_simple_add>
	rp->status = 0x00;
 1012e00:	2300      	movs	r3, #0
 1012e02:	7003      	strb	r3, [r0, #0]
	rp->tx_power_level = 0;
 1012e04:	7043      	strb	r3, [r0, #1]
	if (err == -EINVAL) {
 1012e06:	e68f      	b.n	1012b28 <hci_cmd_handle+0x200>
	struct bt_hci_cp_le_set_adv_param *cmd = (void *)buf->data;
 1012e08:	68ec      	ldr	r4, [r5, #12]
	status = ll_adv_params_set(min_interval, cmd->type,
 1012e0a:	7ba5      	ldrb	r5, [r4, #14]
 1012e0c:	79a3      	ldrb	r3, [r4, #6]
 1012e0e:	7962      	ldrb	r2, [r4, #5]
 1012e10:	7921      	ldrb	r1, [r4, #4]
 1012e12:	8820      	ldrh	r0, [r4, #0]
 1012e14:	9502      	str	r5, [sp, #8]
 1012e16:	7b65      	ldrb	r5, [r4, #13]
				   &cmd->direct_addr.a.val[0], cmd->channel_map,
 1012e18:	3407      	adds	r4, #7
	status = ll_adv_params_set(min_interval, cmd->type,
 1012e1a:	9501      	str	r5, [sp, #4]
 1012e1c:	9400      	str	r4, [sp, #0]
 1012e1e:	f002 fa59 	bl	10152d4 <ll_adv_params_set>
 1012e22:	e761      	b.n	1012ce8 <hci_cmd_handle+0x3c0>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012e24:	2103      	movs	r1, #3
 1012e26:	f013 ffb6 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012e2a:	2103      	movs	r1, #3
 1012e2c:	4604      	mov	r4, r0
 1012e2e:	300c      	adds	r0, #12
 1012e30:	f00b fa32 	bl	101e298 <net_buf_simple_add>
	rp->status = 0x00;
 1012e34:	2300      	movs	r3, #0
 1012e36:	4601      	mov	r1, r0
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
 1012e38:	3001      	adds	r0, #1
	rp->status = 0x00;
 1012e3a:	f801 3b02 	strb.w	r3, [r1], #2
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
 1012e3e:	f7ff fa83 	bl	1012348 <ll_tx_pwr_get>
	if (err == -EINVAL) {
 1012e42:	e671      	b.n	1012b28 <hci_cmd_handle+0x200>
	struct bt_hci_cp_le_set_phy *cmd = (void *)buf->data;
 1012e44:	68ea      	ldr	r2, [r5, #12]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
 1012e46:	7894      	ldrb	r4, [r2, #2]
	return ((uint16_t)src[1] << 8) | src[0];
 1012e48:	78d1      	ldrb	r1, [r2, #3]
 1012e4a:	07e3      	lsls	r3, r4, #31
		cmd->tx_phys |= mask_phys;
 1012e4c:	bf48      	it	mi
 1012e4e:	f041 0103 	orrmi.w	r1, r1, #3
		cmd->rx_phys |= mask_phys;
 1012e52:	7913      	ldrb	r3, [r2, #4]
		cmd->tx_phys |= mask_phys;
 1012e54:	bf48      	it	mi
 1012e56:	70d1      	strbmi	r1, [r2, #3]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
 1012e58:	07a4      	lsls	r4, r4, #30
		cmd->rx_phys |= mask_phys;
 1012e5a:	bf44      	itt	mi
 1012e5c:	f043 0303 	orrmi.w	r3, r3, #3
 1012e60:	7113      	strbmi	r3, [r2, #4]
	handle = sys_le16_to_cpu(cmd->handle);
 1012e62:	8817      	ldrh	r7, [r2, #0]
	phy_opts = sys_le16_to_cpu(cmd->phy_opts);
 1012e64:	f8b2 5005 	ldrh.w	r5, [r2, #5]
	if ((cmd->tx_phys | cmd->rx_phys) & ~mask_phys) {
 1012e68:	ea41 0203 	orr.w	r2, r1, r3
 1012e6c:	2a03      	cmp	r2, #3
 1012e6e:	f200 814d 	bhi.w	101310c <hci_cmd_handle+0x7e4>
	if (!(cmd->tx_phys & 0x07) ||
 1012e72:	074c      	lsls	r4, r1, #29
 1012e74:	f000 8148 	beq.w	1013108 <hci_cmd_handle+0x7e0>
 1012e78:	075a      	lsls	r2, r3, #29
 1012e7a:	f000 8145 	beq.w	1013108 <hci_cmd_handle+0x7e0>
	if (phy_opts & 0x03) {
 1012e7e:	f015 0203 	ands.w	r2, r5, #3
		phy_opts -= 1U;
 1012e82:	bf18      	it	ne
 1012e84:	f105 35ff 	addne.w	r5, r5, #4294967295
	status = ll_phy_req_send(handle, cmd->tx_phys, phy_opts,
 1012e88:	4638      	mov	r0, r7
		phy_opts &= 1;
 1012e8a:	bf18      	it	ne
 1012e8c:	f005 0201 	andne.w	r2, r5, #1
	status = ll_phy_req_send(handle, cmd->tx_phys, phy_opts,
 1012e90:	f003 f83a 	bl	1015f08 <ll_phy_req_send>
 1012e94:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 1012e96:	8830      	ldrh	r0, [r6, #0]
 1012e98:	e579      	b.n	101298e <hci_cmd_handle+0x66>
	struct bt_hci_cp_le_set_default_phy *cmd = (void *)buf->data;
 1012e9a:	68eb      	ldr	r3, [r5, #12]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
 1012e9c:	781a      	ldrb	r2, [r3, #0]
 1012e9e:	07d1      	lsls	r1, r2, #31
		cmd->tx_phys = 0x07;
 1012ea0:	bf44      	itt	mi
 1012ea2:	2107      	movmi	r1, #7
 1012ea4:	7059      	strbmi	r1, [r3, #1]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
 1012ea6:	0792      	lsls	r2, r2, #30
		cmd->rx_phys = 0x07;
 1012ea8:	bf4a      	itet	mi
 1012eaa:	2207      	movmi	r2, #7
	status = ll_phy_default_set(cmd->tx_phys, cmd->rx_phys);
 1012eac:	7899      	ldrbpl	r1, [r3, #2]
		cmd->rx_phys = 0x07;
 1012eae:	4611      	movmi	r1, r2
	status = ll_phy_default_set(cmd->tx_phys, cmd->rx_phys);
 1012eb0:	7858      	ldrb	r0, [r3, #1]
		cmd->rx_phys = 0x07;
 1012eb2:	bf48      	it	mi
 1012eb4:	709a      	strbmi	r2, [r3, #2]
	status = ll_phy_default_set(cmd->tx_phys, cmd->rx_phys);
 1012eb6:	f003 f81b 	bl	1015ef0 <ll_phy_default_set>
 1012eba:	e715      	b.n	1012ce8 <hci_cmd_handle+0x3c0>
	handle = sys_le16_to_cpu(cmd->handle);
 1012ebc:	68eb      	ldr	r3, [r5, #12]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012ebe:	2105      	movs	r1, #5
	handle = sys_le16_to_cpu(cmd->handle);
 1012ec0:	881e      	ldrh	r6, [r3, #0]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012ec2:	f013 ff68 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012ec6:	2105      	movs	r1, #5
 1012ec8:	4604      	mov	r4, r0
 1012eca:	300c      	adds	r0, #12
 1012ecc:	f00b f9e4 	bl	101e298 <net_buf_simple_add>
 1012ed0:	4605      	mov	r5, r0
	handle = sys_le16_to_cpu(cmd->handle);
 1012ed2:	b2b7      	uxth	r7, r6
	status = ll_phy_get(handle, &rp->tx_phy, &rp->rx_phy);
 1012ed4:	1d2a      	adds	r2, r5, #4
 1012ed6:	1ce9      	adds	r1, r5, #3
 1012ed8:	4638      	mov	r0, r7
 1012eda:	f002 ffe7 	bl	1015eac <ll_phy_get>
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
 1012ede:	78eb      	ldrb	r3, [r5, #3]
 1012ee0:	7929      	ldrb	r1, [r5, #4]
 1012ee2:	2b00      	cmp	r3, #0
 1012ee4:	fa93 f3a3 	rbit	r3, r3
 1012ee8:	fa91 f2a1 	rbit	r2, r1
 1012eec:	fab3 f383 	clz	r3, r3
 1012ef0:	bf08      	it	eq
 1012ef2:	f04f 33ff 	moveq.w	r3, #4294967295
 1012ef6:	2900      	cmp	r1, #0
 1012ef8:	fab2 f282 	clz	r2, r2
 1012efc:	bf08      	it	eq
 1012efe:	f04f 32ff 	moveq.w	r2, #4294967295
 1012f02:	3301      	adds	r3, #1
 1012f04:	3201      	adds	r2, #1
	rp->handle = sys_cpu_to_le16(handle);
 1012f06:	f8a5 6001 	strh.w	r6, [r5, #1]
	rp->status = status;
 1012f0a:	7028      	strb	r0, [r5, #0]
	rp->tx_phy = find_lsb_set(rp->tx_phy);
 1012f0c:	70eb      	strb	r3, [r5, #3]
	rp->rx_phy = find_lsb_set(rp->rx_phy);
 1012f0e:	712a      	strb	r2, [r5, #4]
	if (err == -EINVAL) {
 1012f10:	e60a      	b.n	1012b28 <hci_cmd_handle+0x200>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012f12:	2109      	movs	r1, #9
 1012f14:	f013 ff3f 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012f18:	2109      	movs	r1, #9
 1012f1a:	4604      	mov	r4, r0
 1012f1c:	300c      	adds	r0, #12
 1012f1e:	f00b f9bb 	bl	101e298 <net_buf_simple_add>
 1012f22:	4605      	mov	r5, r0
	ll_length_max_get(&max_tx_octets, &max_tx_time,
 1012f24:	ab08      	add	r3, sp, #32
 1012f26:	f10d 021a 	add.w	r2, sp, #26
 1012f2a:	a906      	add	r1, sp, #24
 1012f2c:	f10d 0016 	add.w	r0, sp, #22
 1012f30:	f002 ffac 	bl	1015e8c <ll_length_max_get>
	rp->status = 0x00;
 1012f34:	2200      	movs	r2, #0
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
 1012f36:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 1012f3a:	f8a5 3001 	strh.w	r3, [r5, #1]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
 1012f3e:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 1012f42:	f8a5 3003 	strh.w	r3, [r5, #3]
	rp->max_rx_octets = sys_cpu_to_le16(max_rx_octets);
 1012f46:	f8bd 301a 	ldrh.w	r3, [sp, #26]
 1012f4a:	f8a5 3005 	strh.w	r3, [r5, #5]
	rp->max_rx_time = sys_cpu_to_le16(max_rx_time);
 1012f4e:	f8bd 3020 	ldrh.w	r3, [sp, #32]
	rp->status = 0x00;
 1012f52:	702a      	strb	r2, [r5, #0]
	rp->max_rx_time = sys_cpu_to_le16(max_rx_time);
 1012f54:	f8a5 3007 	strh.w	r3, [r5, #7]
	if (err == -EINVAL) {
 1012f58:	e5e6      	b.n	1012b28 <hci_cmd_handle+0x200>
	struct bt_hci_cp_le_write_default_data_len *cmd = (void *)buf->data;
 1012f5a:	68eb      	ldr	r3, [r5, #12]
	status = ll_length_default_set(max_tx_octets, max_tx_time);
 1012f5c:	8859      	ldrh	r1, [r3, #2]
 1012f5e:	8818      	ldrh	r0, [r3, #0]
 1012f60:	f002 ff88 	bl	1015e74 <ll_length_default_set>
 1012f64:	e6c0      	b.n	1012ce8 <hci_cmd_handle+0x3c0>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012f66:	2105      	movs	r1, #5
 1012f68:	f013 ff15 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012f6c:	2105      	movs	r1, #5
 1012f6e:	4604      	mov	r4, r0
 1012f70:	300c      	adds	r0, #12
 1012f72:	f00b f991 	bl	101e298 <net_buf_simple_add>
 1012f76:	4605      	mov	r5, r0
	ll_length_default_get(&max_tx_octets, &max_tx_time);
 1012f78:	a908      	add	r1, sp, #32
 1012f7a:	f10d 001a 	add.w	r0, sp, #26
 1012f7e:	f002 ff6d 	bl	1015e5c <ll_length_default_get>
	rp->status = 0x00;
 1012f82:	2200      	movs	r2, #0
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
 1012f84:	f8bd 301a 	ldrh.w	r3, [sp, #26]
 1012f88:	f8a5 3001 	strh.w	r3, [r5, #1]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
 1012f8c:	f8bd 3020 	ldrh.w	r3, [sp, #32]
	rp->status = 0x00;
 1012f90:	702a      	strb	r2, [r5, #0]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
 1012f92:	f8a5 3003 	strh.w	r3, [r5, #3]
	if (err == -EINVAL) {
 1012f96:	e5c7      	b.n	1012b28 <hci_cmd_handle+0x200>
	struct bt_hci_cp_le_set_data_len *cmd = (void *)buf->data;
 1012f98:	68eb      	ldr	r3, [r5, #12]
	handle = sys_le16_to_cpu(cmd->handle);
 1012f9a:	881f      	ldrh	r7, [r3, #0]
	status = ll_length_req_send(handle, tx_octets, tx_time);
 1012f9c:	889a      	ldrh	r2, [r3, #4]
 1012f9e:	8859      	ldrh	r1, [r3, #2]
 1012fa0:	b2b8      	uxth	r0, r7
 1012fa2:	f002 ff29 	bl	1015df8 <ll_length_req_send>
 1012fa6:	e60d      	b.n	1012bc4 <hci_cmd_handle+0x29c>
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0, NULL);
 1012fa8:	2300      	movs	r3, #0
	struct bt_hci_cp_le_conn_param_req_neg_reply *cmd = (void *)buf->data;
 1012faa:	68ea      	ldr	r2, [r5, #12]
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0, NULL);
 1012fac:	2102      	movs	r1, #2
	handle = sys_le16_to_cpu(cmd->handle);
 1012fae:	8817      	ldrh	r7, [r2, #0]
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0, NULL);
 1012fb0:	7892      	ldrb	r2, [r2, #2]
 1012fb2:	b2b8      	uxth	r0, r7
 1012fb4:	e9cd 3302 	strd	r3, r3, [sp, #8]
 1012fb8:	e9cd 3300 	strd	r3, r3, [sp]
 1012fbc:	f002 fe30 	bl	1015c20 <ll_conn_update>
 1012fc0:	e600      	b.n	1012bc4 <hci_cmd_handle+0x29c>
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
 1012fc2:	2200      	movs	r2, #0
	struct bt_hci_cp_le_conn_param_req_reply *cmd = (void *)buf->data;
 1012fc4:	68ec      	ldr	r4, [r5, #12]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
 1012fc6:	2102      	movs	r1, #2
	handle = sys_le16_to_cpu(cmd->handle);
 1012fc8:	8827      	ldrh	r7, [r4, #0]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
 1012fca:	8863      	ldrh	r3, [r4, #2]
 1012fcc:	9203      	str	r2, [sp, #12]
 1012fce:	8925      	ldrh	r5, [r4, #8]
 1012fd0:	b2b8      	uxth	r0, r7
 1012fd2:	9502      	str	r5, [sp, #8]
 1012fd4:	88e5      	ldrh	r5, [r4, #6]
 1012fd6:	9501      	str	r5, [sp, #4]
 1012fd8:	88a4      	ldrh	r4, [r4, #4]
 1012fda:	9400      	str	r4, [sp, #0]
 1012fdc:	f002 fe20 	bl	1015c20 <ll_conn_update>
 1012fe0:	e5f0      	b.n	1012bc4 <hci_cmd_handle+0x29c>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1012fe2:	2109      	movs	r1, #9
 1012fe4:	f013 fed7 	bl	1026d96 <bt_hci_cmd_complete_create>
 1012fe8:	2109      	movs	r1, #9
 1012fea:	4604      	mov	r4, r0
 1012fec:	300c      	adds	r0, #12
 1012fee:	f00b f953 	bl	101e298 <net_buf_simple_add>
	dst[1] = val >> 8;
 1012ff2:	2300      	movs	r3, #0
	rp->status = 0x00;
 1012ff4:	4904      	ldr	r1, [pc, #16]	; (1013008 <hci_cmd_handle+0x6e0>)
 1012ff6:	4a05      	ldr	r2, [pc, #20]	; (101300c <hci_cmd_handle+0x6e4>)
 1012ff8:	6001      	str	r1, [r0, #0]
 1012ffa:	6042      	str	r2, [r0, #4]
 1012ffc:	7203      	strb	r3, [r0, #8]
	if (err == -EINVAL) {
 1012ffe:	e593      	b.n	1012b28 <hci_cmd_handle+0x200>
 1013000:	ffff05f1 	.word	0xffff05f1
 1013004:	21000160 	.word	0x21000160
 1013008:	30cc8f00 	.word	0x30cc8f00
 101300c:	0001c0ec 	.word	0x0001c0ec
	status = ll_start_enc_req_send(handle, BT_HCI_ERR_PIN_OR_KEY_MISSING,
 1013010:	2200      	movs	r2, #0
 1013012:	2106      	movs	r1, #6
	handle = sys_le16_to_cpu(cmd->handle);
 1013014:	68eb      	ldr	r3, [r5, #12]
 1013016:	881f      	ldrh	r7, [r3, #0]
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
 1013018:	b2b8      	uxth	r0, r7
 101301a:	f007 ff3d 	bl	101ae98 <ll_start_enc_req_send>
 101301e:	e5d1      	b.n	1012bc4 <hci_cmd_handle+0x29c>
	handle = sys_le16_to_cpu(cmd->handle);
 1013020:	68ea      	ldr	r2, [r5, #12]
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
 1013022:	2100      	movs	r1, #0
	handle = sys_le16_to_cpu(cmd->handle);
 1013024:	f832 7b02 	ldrh.w	r7, [r2], #2
 1013028:	e7f6      	b.n	1013018 <hci_cmd_handle+0x6f0>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 101302a:	2109      	movs	r1, #9
 101302c:	f013 feb3 	bl	1026d96 <bt_hci_cmd_complete_create>
 1013030:	2109      	movs	r1, #9
 1013032:	4604      	mov	r4, r0
 1013034:	300c      	adds	r0, #12
 1013036:	f00b f92f 	bl	101e298 <net_buf_simple_add>
	rp->status = 0x00;
 101303a:	2300      	movs	r3, #0
	lll_csrand_get(rp->rand, count);
 101303c:	2108      	movs	r1, #8
	rp->status = 0x00;
 101303e:	f800 3b01 	strb.w	r3, [r0], #1
	lll_csrand_get(rp->rand, count);
 1013042:	f008 fa95 	bl	101b570 <lll_csrand_get>
	if (err == -EINVAL) {
 1013046:	e56f      	b.n	1012b28 <hci_cmd_handle+0x200>
	struct bt_hci_cp_le_encrypt *cmd = (void *)buf->data;
 1013048:	68e8      	ldr	r0, [r5, #12]
	ecb_encrypt(cmd->key, cmd->plaintext, enc_data, NULL);
 101304a:	aa08      	add	r2, sp, #32
 101304c:	2300      	movs	r3, #0
 101304e:	f100 0110 	add.w	r1, r0, #16
 1013052:	f00a f837 	bl	101d0c4 <ecb_encrypt>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1013056:	2111      	movs	r1, #17
 1013058:	8830      	ldrh	r0, [r6, #0]
 101305a:	f013 fe9c 	bl	1026d96 <bt_hci_cmd_complete_create>
 101305e:	2111      	movs	r1, #17
 1013060:	4604      	mov	r4, r0
 1013062:	300c      	adds	r0, #12
 1013064:	f00b f918 	bl	101e298 <net_buf_simple_add>
	rp->status = 0x00;
 1013068:	2300      	movs	r3, #0
	memcpy(rp->enc_data, enc_data, 16);
 101306a:	2210      	movs	r2, #16
 101306c:	a908      	add	r1, sp, #32
	rp->status = 0x00;
 101306e:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(rp->enc_data, enc_data, 16);
 1013072:	f013 fc7f 	bl	1026974 <memcpy>
	if (err == -EINVAL) {
 1013076:	e557      	b.n	1012b28 <hci_cmd_handle+0x200>
	struct bt_hci_cp_disconnect *cmd = (void *)buf->data;
 1013078:	68eb      	ldr	r3, [r5, #12]
	status = ll_terminate_ind_send(handle, cmd->reason);
 101307a:	7899      	ldrb	r1, [r3, #2]
 101307c:	8818      	ldrh	r0, [r3, #0]
 101307e:	f002 fe3b 	bl	1015cf8 <ll_terminate_ind_send>
 1013082:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 1013084:	8830      	ldrh	r0, [r6, #0]
 1013086:	e482      	b.n	101298e <hci_cmd_handle+0x66>
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
 1013088:	68ea      	ldr	r2, [r5, #12]
	event_mask_page_2 = sys_get_le64(cmd->events_page_2);
 101308a:	4b21      	ldr	r3, [pc, #132]	; (1013110 <hci_cmd_handle+0x7e8>)
 101308c:	e66f      	b.n	1012d6e <hci_cmd_handle+0x446>
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
 101308e:	2000      	movs	r0, #0
 1013090:	2100      	movs	r1, #0
 1013092:	4a1f      	ldr	r2, [pc, #124]	; (1013110 <hci_cmd_handle+0x7e8>)
	event_mask = DEFAULT_EVENT_MASK;
 1013094:	f04f 34ff 	mov.w	r4, #4294967295
 1013098:	f641 75ff 	movw	r5, #8191	; 0x1fff
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
 101309c:	e9c2 0100 	strd	r0, r1, [r2]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
 10130a0:	201f      	movs	r0, #31
 10130a2:	2100      	movs	r1, #0
	event_mask = DEFAULT_EVENT_MASK;
 10130a4:	4b1b      	ldr	r3, [pc, #108]	; (1013114 <hci_cmd_handle+0x7ec>)
 10130a6:	e9c3 4500 	strd	r4, r5, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
 10130aa:	4b1b      	ldr	r3, [pc, #108]	; (1013118 <hci_cmd_handle+0x7f0>)
 10130ac:	e9c3 0100 	strd	r0, r1, [r3]
		ll_reset();
 10130b0:	f001 fd54 	bl	1014b5c <ll_reset>
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
 10130b4:	2101      	movs	r1, #1
 10130b6:	8830      	ldrh	r0, [r6, #0]
 10130b8:	f013 fe6d 	bl	1026d96 <bt_hci_cmd_complete_create>
 10130bc:	2101      	movs	r1, #1
 10130be:	4604      	mov	r4, r0
 10130c0:	300c      	adds	r0, #12
 10130c2:	f00b f8e9 	bl	101e298 <net_buf_simple_add>
	ccst->status = status;
 10130c6:	2300      	movs	r3, #0
	conn_count = 0U;
 10130c8:	4a14      	ldr	r2, [pc, #80]	; (101311c <hci_cmd_handle+0x7f4>)
	ccst->status = status;
 10130ca:	7003      	strb	r3, [r0, #0]
	conn_count = 0U;
 10130cc:	6013      	str	r3, [r2, #0]
	hci_recv_fifo_reset();
 10130ce:	f7ff fb1b 	bl	1012708 <hci_recv_fifo_reset>
	if (err == -EINVAL) {
 10130d2:	e529      	b.n	1012b28 <hci_cmd_handle+0x200>
	handle = sys_le16_to_cpu(cmd->handle);
 10130d4:	68eb      	ldr	r3, [r5, #12]
	status = ll_apto_get(handle, &auth_payload_timeout);
 10130d6:	a908      	add	r1, sp, #32
	handle = sys_le16_to_cpu(cmd->handle);
 10130d8:	881f      	ldrh	r7, [r3, #0]
	status = ll_apto_get(handle, &auth_payload_timeout);
 10130da:	b2b8      	uxth	r0, r7
 10130dc:	f002 ff4a 	bl	1015f74 <ll_apto_get>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 10130e0:	2105      	movs	r1, #5
	status = ll_apto_get(handle, &auth_payload_timeout);
 10130e2:	4605      	mov	r5, r0
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 10130e4:	8830      	ldrh	r0, [r6, #0]
 10130e6:	f013 fe56 	bl	1026d96 <bt_hci_cmd_complete_create>
 10130ea:	2105      	movs	r1, #5
 10130ec:	4604      	mov	r4, r0
 10130ee:	300c      	adds	r0, #12
 10130f0:	f00b f8d2 	bl	101e298 <net_buf_simple_add>
	rp->status = status;
 10130f4:	7005      	strb	r5, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
 10130f6:	f8a0 7001 	strh.w	r7, [r0, #1]
	rp->auth_payload_timeout = sys_cpu_to_le16(auth_payload_timeout);
 10130fa:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 10130fe:	f8a0 3003 	strh.w	r3, [r0, #3]
	if (err == -EINVAL) {
 1013102:	e511      	b.n	1012b28 <hci_cmd_handle+0x200>
	return evt;
 1013104:	9c07      	ldr	r4, [sp, #28]
 1013106:	e50f      	b.n	1012b28 <hci_cmd_handle+0x200>
	return bt_hci_cmd_status_create(_opcode, status);
 1013108:	2112      	movs	r1, #18
 101310a:	e440      	b.n	101298e <hci_cmd_handle+0x66>
 101310c:	2111      	movs	r1, #17
 101310e:	e43e      	b.n	101298e <hci_cmd_handle+0x66>
 1013110:	210036e8 	.word	0x210036e8
 1013114:	21000168 	.word	0x21000168
 1013118:	21000160 	.word	0x21000160
 101311c:	21004d10 	.word	0x21004d10

01013120 <hci_acl_handle>:
{
 1013120:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	*evt = NULL;
 1013124:	2400      	movs	r4, #0
 1013126:	600c      	str	r4, [r1, #0]
	if (buf->len < sizeof(*acl)) {
 1013128:	8a03      	ldrh	r3, [r0, #16]
{
 101312a:	b087      	sub	sp, #28
	if (buf->len < sizeof(*acl)) {
 101312c:	2b03      	cmp	r3, #3
 101312e:	d92f      	bls.n	1013190 <hci_acl_handle+0x70>
	return net_buf_simple_pull_mem(&buf->b, len);
 1013130:	4605      	mov	r5, r0
 1013132:	4688      	mov	r8, r1
 1013134:	300c      	adds	r0, #12
 1013136:	2104      	movs	r1, #4
 1013138:	f00b f890 	bl	101e25c <net_buf_simple_pull_mem>
	if (buf->len < len) {
 101313c:	8a2b      	ldrh	r3, [r5, #16]
	len = sys_le16_to_cpu(acl->len);
 101313e:	8847      	ldrh	r7, [r0, #2]
	handle = sys_le16_to_cpu(acl->handle);
 1013140:	f8b0 9000 	ldrh.w	r9, [r0]
	if (buf->len < len) {
 1013144:	42bb      	cmp	r3, r7
 1013146:	d334      	bcc.n	10131b2 <hci_acl_handle+0x92>
	if (len > LL_LENGTH_OCTETS_TX_MAX) {
 1013148:	2ffb      	cmp	r7, #251	; 0xfb
 101314a:	d82f      	bhi.n	10131ac <hci_acl_handle+0x8c>
	node_tx = ll_tx_mem_acquire();
 101314c:	f002 fd0e 	bl	1015b6c <ll_tx_mem_acquire>
	flags = bt_acl_flags(handle);
 1013150:	ea4f 3619 	mov.w	r6, r9, lsr #12
 1013154:	4633      	mov	r3, r6
	if (!node_tx) {
 1013156:	4604      	mov	r4, r0
 1013158:	2800      	cmp	r0, #0
 101315a:	d03c      	beq.n	10131d6 <hci_acl_handle+0xb6>
	if (bt_acl_flags_bc(flags) != BT_ACL_POINT_TO_POINT) {
 101315c:	089b      	lsrs	r3, r3, #2
 101315e:	d122      	bne.n	10131a6 <hci_acl_handle+0x86>
	switch (bt_acl_flags_pb(flags)) {
 1013160:	b1a6      	cbz	r6, 101318c <hci_acl_handle+0x6c>
 1013162:	2e01      	cmp	r6, #1
 1013164:	d11f      	bne.n	10131a6 <hci_acl_handle+0x86>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_START;
 1013166:	7923      	ldrb	r3, [r4, #4]
	pdu_data->len = len;
 1013168:	7167      	strb	r7, [r4, #5]
		pdu_data->ll_id = PDU_DATA_LLID_DATA_START;
 101316a:	f366 0301 	bfi	r3, r6, #0, #2
 101316e:	7123      	strb	r3, [r4, #4]
	memcpy(&pdu_data->lldata[0], buf->data, len);
 1013170:	68e9      	ldr	r1, [r5, #12]
 1013172:	463a      	mov	r2, r7
 1013174:	1de0      	adds	r0, r4, #7
 1013176:	f013 fbfd 	bl	1026974 <memcpy>
	if (ll_tx_mem_enqueue(handle, node_tx)) {
 101317a:	4621      	mov	r1, r4
 101317c:	f3c9 000b 	ubfx	r0, r9, #0, #12
 1013180:	f002 fd00 	bl	1015b84 <ll_tx_mem_enqueue>
 1013184:	b9c0      	cbnz	r0, 10131b8 <hci_acl_handle+0x98>
}
 1013186:	b007      	add	sp, #28
 1013188:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	switch (bt_acl_flags_pb(flags)) {
 101318c:	2602      	movs	r6, #2
 101318e:	e7ea      	b.n	1013166 <hci_acl_handle+0x46>
		LOG_ERR("No HCI ACL header");
 1013190:	2302      	movs	r3, #2
 1013192:	4a26      	ldr	r2, [pc, #152]	; (101322c <hci_acl_handle+0x10c>)
		LOG_ERR("Invalid HCI ACL packet length");
 1013194:	e9cd 3204 	strd	r3, r2, [sp, #16]
 1013198:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 101319c:	4623      	mov	r3, r4
 101319e:	4824      	ldr	r0, [pc, #144]	; (1013230 <hci_acl_handle+0x110>)
 10131a0:	aa04      	add	r2, sp, #16
 10131a2:	f7f1 fab1 	bl	1004708 <z_impl_z_log_msg_static_create>
		return -EINVAL;
 10131a6:	f06f 0015 	mvn.w	r0, #21
 10131aa:	e7ec      	b.n	1013186 <hci_acl_handle+0x66>
		LOG_ERR("Invalid HCI ACL Data length");
 10131ac:	2302      	movs	r3, #2
 10131ae:	4a21      	ldr	r2, [pc, #132]	; (1013234 <hci_acl_handle+0x114>)
 10131b0:	e7f0      	b.n	1013194 <hci_acl_handle+0x74>
		LOG_ERR("Invalid HCI ACL packet length");
 10131b2:	2302      	movs	r3, #2
 10131b4:	4a20      	ldr	r2, [pc, #128]	; (1013238 <hci_acl_handle+0x118>)
 10131b6:	e7ed      	b.n	1013194 <hci_acl_handle+0x74>
		LOG_ERR("Invalid Tx Enqueue");
 10131b8:	2302      	movs	r3, #2
 10131ba:	4a20      	ldr	r2, [pc, #128]	; (101323c <hci_acl_handle+0x11c>)
 10131bc:	e9cd 3204 	strd	r3, r2, [sp, #16]
 10131c0:	2300      	movs	r3, #0
 10131c2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10131c6:	aa04      	add	r2, sp, #16
 10131c8:	4819      	ldr	r0, [pc, #100]	; (1013230 <hci_acl_handle+0x110>)
 10131ca:	f7f1 fa9d 	bl	1004708 <z_impl_z_log_msg_static_create>
		ll_tx_mem_release(node_tx);
 10131ce:	4620      	mov	r0, r4
 10131d0:	f002 fcd2 	bl	1015b78 <ll_tx_mem_release>
		return -EINVAL;
 10131d4:	e7e7      	b.n	10131a6 <hci_acl_handle+0x86>
		LOG_ERR("Tx Buffer Overflow");
 10131d6:	2502      	movs	r5, #2
 10131d8:	4b19      	ldr	r3, [pc, #100]	; (1013240 <hci_acl_handle+0x120>)
 10131da:	e9cd 5304 	strd	r5, r3, [sp, #16]
 10131de:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10131e2:	4603      	mov	r3, r0
 10131e4:	aa04      	add	r2, sp, #16
 10131e6:	4812      	ldr	r0, [pc, #72]	; (1013230 <hci_acl_handle+0x110>)
 10131e8:	f7f1 fa8e 	bl	1004708 <z_impl_z_log_msg_static_create>
	if (!(event_mask & BT_EVT_MASK_DATA_BUFFER_OVERFLOW)) {
 10131ec:	4b15      	ldr	r3, [pc, #84]	; (1013244 <hci_acl_handle+0x124>)
 10131ee:	681b      	ldr	r3, [r3, #0]
 10131f0:	019b      	lsls	r3, r3, #6
 10131f2:	d517      	bpl.n	1013224 <hci_acl_handle+0x104>
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 10131f4:	f04f 32ff 	mov.w	r2, #4294967295
 10131f8:	f04f 33ff 	mov.w	r3, #4294967295
 10131fc:	2001      	movs	r0, #1
 10131fe:	f7f4 f8bb 	bl	1007378 <bt_buf_get_rx>
	return net_buf_simple_add(&buf->b, len);
 1013202:	4629      	mov	r1, r5
 1013204:	f8c8 0000 	str.w	r0, [r8]
 1013208:	300c      	adds	r0, #12
 101320a:	f00b f845 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 101320e:	f44f 738d 	mov.w	r3, #282	; 0x11a
 1013212:	8003      	strh	r3, [r0, #0]
 1013214:	f8d8 0000 	ldr.w	r0, [r8]
 1013218:	2101      	movs	r1, #1
 101321a:	300c      	adds	r0, #12
 101321c:	f00b f83c 	bl	101e298 <net_buf_simple_add>
	ep->link_type = link_type;
 1013220:	2301      	movs	r3, #1
 1013222:	7003      	strb	r3, [r0, #0]
		return -ENOBUFS;
 1013224:	f06f 0068 	mvn.w	r0, #104	; 0x68
 1013228:	e7ad      	b.n	1013186 <hci_acl_handle+0x66>
 101322a:	bf00      	nop
 101322c:	0102a3bc 	.word	0x0102a3bc
 1013230:	0102997c 	.word	0x0102997c
 1013234:	0102a3f0 	.word	0x0102a3f0
 1013238:	0102a3d0 	.word	0x0102a3d0
 101323c:	0102a420 	.word	0x0102a420
 1013240:	0102a40c 	.word	0x0102a40c
 1013244:	21000168 	.word	0x21000168

01013248 <hci_disconn_complete_encode>:
{
 1013248:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!(event_mask & BT_EVT_MASK_DISCONN_COMPLETE)) {
 101324a:	4b0e      	ldr	r3, [pc, #56]	; (1013284 <hci_disconn_complete_encode+0x3c>)
 101324c:	681b      	ldr	r3, [r3, #0]
 101324e:	06db      	lsls	r3, r3, #27
 1013250:	d400      	bmi.n	1013254 <hci_disconn_complete_encode+0xc>
}
 1013252:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1013254:	f102 040c 	add.w	r4, r2, #12
 1013258:	4607      	mov	r7, r0
 101325a:	460d      	mov	r5, r1
 101325c:	4620      	mov	r0, r4
 101325e:	2102      	movs	r1, #2
 1013260:	f00b f81a 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 1013264:	f240 4205 	movw	r2, #1029	; 0x405
 1013268:	4603      	mov	r3, r0
 101326a:	2104      	movs	r1, #4
 101326c:	801a      	strh	r2, [r3, #0]
 101326e:	4620      	mov	r0, r4
 1013270:	f00b f812 	bl	101e298 <net_buf_simple_add>
	ep->status = 0x00;
 1013274:	2600      	movs	r6, #0
	ep->handle = sys_cpu_to_le16(handle);
 1013276:	f8a0 5001 	strh.w	r5, [r0, #1]
	ep->status = 0x00;
 101327a:	7006      	strb	r6, [r0, #0]
	ep->reason = *((uint8_t *)pdu_data);
 101327c:	783a      	ldrb	r2, [r7, #0]
 101327e:	70c2      	strb	r2, [r0, #3]
}
 1013280:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1013282:	bf00      	nop
 1013284:	21000168 	.word	0x21000168

01013288 <hci_disconn_complete_process>:
	conn_count--;
 1013288:	4a02      	ldr	r2, [pc, #8]	; (1013294 <hci_disconn_complete_process+0xc>)
 101328a:	6813      	ldr	r3, [r2, #0]
 101328c:	3b01      	subs	r3, #1
 101328e:	6013      	str	r3, [r2, #0]
}
 1013290:	4770      	bx	lr
 1013292:	bf00      	nop
 1013294:	21004d10 	.word	0x21004d10

01013298 <hci_acl_encode>:
	}
}

#if defined(CONFIG_BT_CONN)
void hci_acl_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
 1013298:	b570      	push	{r4, r5, r6, lr}
	uint16_t handle;
	uint8_t *data;

	handle = node_rx->hdr.handle;

	switch (pdu_data->ll_id) {
 101329a:	7f03      	ldrb	r3, [r0, #28]
	handle = node_rx->hdr.handle;
 101329c:	88c6      	ldrh	r6, [r0, #6]
	switch (pdu_data->ll_id) {
 101329e:	f003 0303 	and.w	r3, r3, #3
 10132a2:	3b01      	subs	r3, #1
 10132a4:	2b01      	cmp	r3, #1
 10132a6:	d90d      	bls.n	10132c4 <hci_acl_encode+0x2c>
		}
#endif
		break;

	default:
		LL_ASSERT(0);
 10132a8:	f242 138f 	movw	r3, #8591	; 0x218f
 10132ac:	4a15      	ldr	r2, [pc, #84]	; (1013304 <hci_acl_encode+0x6c>)
 10132ae:	4916      	ldr	r1, [pc, #88]	; (1013308 <hci_acl_encode+0x70>)
 10132b0:	4816      	ldr	r0, [pc, #88]	; (101330c <hci_acl_encode+0x74>)
 10132b2:	f011 fc90 	bl	1024bd6 <assert_print>
 10132b6:	4040      	eors	r0, r0
 10132b8:	f380 8811 	msr	BASEPRI, r0
 10132bc:	f04f 0003 	mov.w	r0, #3
 10132c0:	df02      	svc	2
		break;
	}
}
 10132c2:	bd70      	pop	{r4, r5, r6, pc}
 10132c4:	f101 050c 	add.w	r5, r1, #12
 10132c8:	4604      	mov	r4, r0
 10132ca:	2104      	movs	r1, #4
 10132cc:	4628      	mov	r0, r5
 10132ce:	f00a ffe3 	bl	101e298 <net_buf_simple_add>
 10132d2:	4603      	mov	r3, r0
		if (pdu_data->ll_id == PDU_DATA_LLID_DATA_START) {
 10132d4:	7f22      	ldrb	r2, [r4, #28]
 10132d6:	f002 0203 	and.w	r2, r2, #3
 10132da:	2a02      	cmp	r2, #2
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_START);
 10132dc:	bf0c      	ite	eq
 10132de:	f446 5600 	orreq.w	r6, r6, #8192	; 0x2000
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_CONT);
 10132e2:	f446 5680 	orrne.w	r6, r6, #4096	; 0x1000
		acl->handle = sys_cpu_to_le16(handle_flags);
 10132e6:	8006      	strh	r6, [r0, #0]
		acl->len = sys_cpu_to_le16(pdu_data->len);
 10132e8:	7f62      	ldrb	r2, [r4, #29]
 10132ea:	4628      	mov	r0, r5
 10132ec:	805a      	strh	r2, [r3, #2]
 10132ee:	7f61      	ldrb	r1, [r4, #29]
 10132f0:	f00a ffd2 	bl	101e298 <net_buf_simple_add>
		memcpy(data, pdu_data->lldata, pdu_data->len);
 10132f4:	7f62      	ldrb	r2, [r4, #29]
 10132f6:	f104 011f 	add.w	r1, r4, #31
}
 10132fa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		memcpy(data, pdu_data->lldata, pdu_data->len);
 10132fe:	f013 bb39 	b.w	1026974 <memcpy>
 1013302:	bf00      	nop
 1013304:	0102a434 	.word	0x0102a434
 1013308:	0102a300 	.word	0x0102a300
 101330c:	0102a278 	.word	0x0102a278

01013310 <hci_evt_encode>:
#endif /* CONFIG_BT_CONN */

void hci_evt_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
 1013310:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1013314:	b084      	sub	sp, #16
	struct pdu_data *pdu_data = (void *)node_rx->pdu;

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 1013316:	f890 c004 	ldrb.w	ip, [r0, #4]
{
 101331a:	4604      	mov	r4, r0
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 101331c:	f1bc 0f03 	cmp.w	ip, #3
{
 1013320:	460d      	mov	r5, r1
 1013322:	88c6      	ldrh	r6, [r0, #6]
 1013324:	af04      	add	r7, sp, #16
	struct pdu_data *pdu_data = (void *)node_rx->pdu;
 1013326:	f100 081c 	add.w	r8, r0, #28
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 101332a:	d00b      	beq.n	1013344 <hci_evt_encode+0x34>
	switch (node_rx->hdr.type) {
 101332c:	f1ac 0c17 	sub.w	ip, ip, #23
 1013330:	f1bc 0f06 	cmp.w	ip, #6
 1013334:	f200 8297 	bhi.w	1013866 <hci_evt_encode+0x556>
 1013338:	e8df f00c 	tbb	[pc, ip]
 101333c:	83544c1e 	.word	0x83544c1e
 1013340:	ac99      	.short	0xac99
 1013342:	cc          	.byte	0xcc
 1013343:	00          	.byte	0x00
	switch (pdu_data->llctrl.opcode) {
 1013344:	7fc3      	ldrb	r3, [r0, #31]
 1013346:	3b03      	subs	r3, #3
 1013348:	2b12      	cmp	r3, #18
 101334a:	f200 80f6 	bhi.w	101353a <hci_evt_encode+0x22a>
 101334e:	e8df f013 	tbh	[pc, r3, lsl #1]
 1013352:	0159      	.short	0x0159
 1013354:	00f400f4 	.word	0x00f400f4
 1013358:	01b10187 	.word	0x01b10187
 101335c:	01c800f4 	.word	0x01c800f4
 1013360:	00f400f4 	.word	0x00f400f4
 1013364:	020b00f4 	.word	0x020b00f4
 1013368:	01cf00f4 	.word	0x01cf00f4
 101336c:	01f700f4 	.word	0x01f700f4
 1013370:	00f400f4 	.word	0x00f400f4
 1013374:	01020102 	.word	0x01020102
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cc));
 1013378:	f018 0f01 	tst.w	r8, #1
 101337c:	f040 8210 	bne.w	10137a0 <hci_evt_encode+0x490>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1013380:	4bc4      	ldr	r3, [pc, #784]	; (1013694 <hci_evt_encode+0x384>)
	status = cc->status;
 1013382:	f894 801c 	ldrb.w	r8, [r4, #28]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1013386:	685b      	ldr	r3, [r3, #4]
 1013388:	009b      	lsls	r3, r3, #2
 101338a:	d528      	bpl.n	10133de <hci_evt_encode+0xce>
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
 101338c:	4bc2      	ldr	r3, [pc, #776]	; (1013698 <hci_evt_encode+0x388>)
 101338e:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1013390:	07d8      	lsls	r0, r3, #31
 1013392:	d524      	bpl.n	10133de <hci_evt_encode+0xce>
 1013394:	350c      	adds	r5, #12
	if (!status) {
 1013396:	f1b8 0f00 	cmp.w	r8, #0
 101339a:	f000 820f 	beq.w	10137bc <hci_evt_encode+0x4ac>
 101339e:	2102      	movs	r1, #2
 10133a0:	4628      	mov	r0, r5
 10133a2:	f00a ff79 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 10133a6:	f241 323e 	movw	r2, #4926	; 0x133e
 10133aa:	4603      	mov	r3, r0
 10133ac:	2101      	movs	r1, #1
 10133ae:	801a      	strh	r2, [r3, #0]
 10133b0:	4628      	mov	r0, r5
 10133b2:	f00a ff71 	bl	101e298 <net_buf_simple_add>
	me->subevent = subevt;
 10133b6:	2201      	movs	r2, #1
 10133b8:	4603      	mov	r3, r0
 10133ba:	2112      	movs	r1, #18
 10133bc:	701a      	strb	r2, [r3, #0]
 10133be:	4628      	mov	r0, r5
 10133c0:	f00a ff6a 	bl	101e298 <net_buf_simple_add>
 10133c4:	4604      	mov	r4, r0
		(void)memset(lecc, 0x00, sizeof(*lecc));
 10133c6:	2212      	movs	r2, #18
 10133c8:	2100      	movs	r1, #0
 10133ca:	f013 fade 	bl	102698a <memset>
		lecc->status = status;
 10133ce:	f884 8000 	strb.w	r8, [r4]
		return;
 10133d2:	e004      	b.n	10133de <hci_evt_encode+0xce>
		hci_disconn_complete_encode(pdu_data, handle, buf);
 10133d4:	460a      	mov	r2, r1
 10133d6:	4640      	mov	r0, r8
 10133d8:	4631      	mov	r1, r6
 10133da:	f7ff ff35 	bl	1013248 <hci_disconn_complete_encode>
		encode_control(node_rx, pdu_data, buf);
	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
		encode_data_ctrl(node_rx, pdu_data, buf);
	}
}
 10133de:	46bd      	mov	sp, r7
 10133e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10133e4:	4bab      	ldr	r3, [pc, #684]	; (1013694 <hci_evt_encode+0x384>)
 10133e6:	685b      	ldr	r3, [r3, #4]
 10133e8:	0099      	lsls	r1, r3, #2
 10133ea:	d5f8      	bpl.n	10133de <hci_evt_encode+0xce>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_UPDATE_COMPLETE)) {
 10133ec:	4baa      	ldr	r3, [pc, #680]	; (1013698 <hci_evt_encode+0x388>)
 10133ee:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10133f0:	075a      	lsls	r2, r3, #29
 10133f2:	d5f4      	bpl.n	10133de <hci_evt_encode+0xce>
 10133f4:	350c      	adds	r5, #12
 10133f6:	2102      	movs	r1, #2
 10133f8:	4628      	mov	r0, r5
 10133fa:	f00a ff4d 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 10133fe:	f640 223e 	movw	r2, #2622	; 0xa3e
 1013402:	4603      	mov	r3, r0
 1013404:	2101      	movs	r1, #1
 1013406:	801a      	strh	r2, [r3, #0]
 1013408:	4628      	mov	r0, r5
 101340a:	f00a ff45 	bl	101e298 <net_buf_simple_add>
	me->subevent = subevt;
 101340e:	2203      	movs	r2, #3
 1013410:	4603      	mov	r3, r0
 1013412:	2109      	movs	r1, #9
 1013414:	4628      	mov	r0, r5
 1013416:	701a      	strb	r2, [r3, #0]
 1013418:	f00a ff3e 	bl	101e298 <net_buf_simple_add>
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cu));
 101341c:	f018 0f01 	tst.w	r8, #1
 1013420:	4605      	mov	r5, r0
 1013422:	f040 8212 	bne.w	101384a <hci_evt_encode+0x53a>
	sep->status = cu->status;
 1013426:	7f23      	ldrb	r3, [r4, #28]
	sep->handle = sys_cpu_to_le16(handle);
 1013428:	f8a5 6001 	strh.w	r6, [r5, #1]
	sep->status = cu->status;
 101342c:	702b      	strb	r3, [r5, #0]
	sep->interval = sys_cpu_to_le16(cu->interval);
 101342e:	8be3      	ldrh	r3, [r4, #30]
 1013430:	f8a5 3003 	strh.w	r3, [r5, #3]
	sep->latency = sys_cpu_to_le16(cu->latency);
 1013434:	8c23      	ldrh	r3, [r4, #32]
 1013436:	f8a5 3005 	strh.w	r3, [r5, #5]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
 101343a:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 101343c:	f8a5 3007 	strh.w	r3, [r5, #7]
 1013440:	e7cd      	b.n	10133de <hci_evt_encode+0xce>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_KEY_REFRESH_COMPLETE)) {
 1013442:	4b94      	ldr	r3, [pc, #592]	; (1013694 <hci_evt_encode+0x384>)
 1013444:	2400      	movs	r4, #0
 1013446:	685b      	ldr	r3, [r3, #4]
 1013448:	041b      	lsls	r3, r3, #16
 101344a:	d5c8      	bpl.n	10133de <hci_evt_encode+0xce>
 101344c:	350c      	adds	r5, #12
 101344e:	2102      	movs	r1, #2
 1013450:	4628      	mov	r0, r5
 1013452:	f00a ff21 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 1013456:	f44f 724c 	mov.w	r2, #816	; 0x330
 101345a:	4603      	mov	r3, r0
 101345c:	2103      	movs	r1, #3
 101345e:	4628      	mov	r0, r5
 1013460:	801a      	strh	r2, [r3, #0]
 1013462:	f00a ff19 	bl	101e298 <net_buf_simple_add>
	ep->status = 0x00;
 1013466:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
 1013468:	f8a0 6001 	strh.w	r6, [r0, #1]
 101346c:	e7b7      	b.n	10133de <hci_evt_encode+0xce>
	if (!(event_mask_page_2 & BT_EVT_MASK_AUTH_PAYLOAD_TIMEOUT_EXP)) {
 101346e:	4b8b      	ldr	r3, [pc, #556]	; (101369c <hci_evt_encode+0x38c>)
 1013470:	681b      	ldr	r3, [r3, #0]
 1013472:	021c      	lsls	r4, r3, #8
 1013474:	d5b3      	bpl.n	10133de <hci_evt_encode+0xce>
 1013476:	350c      	adds	r5, #12
 1013478:	2102      	movs	r1, #2
 101347a:	4628      	mov	r0, r5
 101347c:	f00a ff0c 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 1013480:	f240 2257 	movw	r2, #599	; 0x257
 1013484:	4603      	mov	r3, r0
 1013486:	2102      	movs	r1, #2
 1013488:	4628      	mov	r0, r5
 101348a:	801a      	strh	r2, [r3, #0]
 101348c:	f00a ff04 	bl	101e298 <net_buf_simple_add>
	ep->handle = sys_cpu_to_le16(handle);
 1013490:	8006      	strh	r6, [r0, #0]
 1013492:	e7a4      	b.n	10133de <hci_evt_encode+0xce>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1013494:	4b7f      	ldr	r3, [pc, #508]	; (1013694 <hci_evt_encode+0x384>)
 1013496:	685b      	ldr	r3, [r3, #4]
 1013498:	0098      	lsls	r0, r3, #2
 101349a:	d5a0      	bpl.n	10133de <hci_evt_encode+0xce>
	    !(le_event_mask & BT_EVT_MASK_LE_CHAN_SEL_ALGO)) {
 101349c:	4b7e      	ldr	r3, [pc, #504]	; (1013698 <hci_evt_encode+0x388>)
 101349e:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10134a0:	0319      	lsls	r1, r3, #12
 10134a2:	d59c      	bpl.n	10133de <hci_evt_encode+0xce>
 10134a4:	350c      	adds	r5, #12
 10134a6:	2102      	movs	r1, #2
 10134a8:	4628      	mov	r0, r5
 10134aa:	f00a fef5 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 10134ae:	f240 423e 	movw	r2, #1086	; 0x43e
 10134b2:	4603      	mov	r3, r0
 10134b4:	2101      	movs	r1, #1
 10134b6:	801a      	strh	r2, [r3, #0]
 10134b8:	4628      	mov	r0, r5
 10134ba:	f00a feed 	bl	101e298 <net_buf_simple_add>
	me->subevent = subevt;
 10134be:	2214      	movs	r2, #20
 10134c0:	4603      	mov	r3, r0
 10134c2:	2103      	movs	r1, #3
 10134c4:	701a      	strb	r2, [r3, #0]
 10134c6:	4628      	mov	r0, r5
 10134c8:	f00a fee6 	bl	101e298 <net_buf_simple_add>
	sep->handle = sys_cpu_to_le16(handle);
 10134cc:	8006      	strh	r6, [r0, #0]
	sep->chan_sel_algo = cs->csa;
 10134ce:	7f23      	ldrb	r3, [r4, #28]
 10134d0:	7083      	strb	r3, [r0, #2]
 10134d2:	e784      	b.n	10133de <hci_evt_encode+0xce>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10134d4:	4b6f      	ldr	r3, [pc, #444]	; (1013694 <hci_evt_encode+0x384>)
 10134d6:	685b      	ldr	r3, [r3, #4]
 10134d8:	009a      	lsls	r2, r3, #2
 10134da:	d503      	bpl.n	10134e4 <hci_evt_encode+0x1d4>
	    !(le_event_mask & BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE)) {
 10134dc:	4b6e      	ldr	r3, [pc, #440]	; (1013698 <hci_evt_encode+0x388>)
 10134de:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10134e0:	051b      	lsls	r3, r3, #20
 10134e2:	d460      	bmi.n	10135a6 <hci_evt_encode+0x296>
 10134e4:	7f63      	ldrb	r3, [r4, #29]
 10134e6:	7fa0      	ldrb	r0, [r4, #30]
 10134e8:	fa93 f1a3 	rbit	r1, r3
 10134ec:	fa90 f2a0 	rbit	r2, r0
 10134f0:	2b00      	cmp	r3, #0
 10134f2:	fab1 f181 	clz	r1, r1
 10134f6:	bf08      	it	eq
 10134f8:	f04f 31ff 	moveq.w	r1, #4294967295
 10134fc:	2800      	cmp	r0, #0
 10134fe:	fab2 f282 	clz	r2, r2
 1013502:	bf08      	it	eq
 1013504:	f04f 32ff 	moveq.w	r2, #4294967295
		LOG_WRN("handle: 0x%04x, status: %x, tx: %x, rx: %x.", handle, pu->status,
 1013508:	f894 c01c 	ldrb.w	ip, [r4, #28]
 101350c:	466c      	mov	r4, sp
 101350e:	b08a      	sub	sp, #40	; 0x28
 1013510:	1c48      	adds	r0, r1, #1
 1013512:	ab04      	add	r3, sp, #16
 1013514:	1c51      	adds	r1, r2, #1
 1013516:	2506      	movs	r5, #6
 1013518:	461a      	mov	r2, r3
 101351a:	6259      	str	r1, [r3, #36]	; 0x24
 101351c:	4960      	ldr	r1, [pc, #384]	; (10136a0 <hci_evt_encode+0x390>)
 101351e:	e9c3 c007 	strd	ip, r0, [r3, #28]
 1013522:	619e      	str	r6, [r3, #24]
 1013524:	6159      	str	r1, [r3, #20]
 1013526:	f842 5f10 	str.w	r5, [r2, #16]!
 101352a:	2300      	movs	r3, #0
 101352c:	f44f 5142 	mov.w	r1, #12416	; 0x3080
 1013530:	485c      	ldr	r0, [pc, #368]	; (10136a4 <hci_evt_encode+0x394>)
 1013532:	f7f1 f8e9 	bl	1004708 <z_impl_z_log_msg_static_create>
 1013536:	46a5      	mov	sp, r4
		return;
 1013538:	e751      	b.n	10133de <hci_evt_encode+0xce>
		LL_ASSERT(0);
 101353a:	f242 1363 	movw	r3, #8547	; 0x2163
 101353e:	4a5a      	ldr	r2, [pc, #360]	; (10136a8 <hci_evt_encode+0x398>)
 1013540:	495a      	ldr	r1, [pc, #360]	; (10136ac <hci_evt_encode+0x39c>)
 1013542:	485b      	ldr	r0, [pc, #364]	; (10136b0 <hci_evt_encode+0x3a0>)
 1013544:	f011 fb47 	bl	1024bd6 <assert_print>
 1013548:	4040      	eors	r0, r0
 101354a:	f380 8811 	msr	BASEPRI, r0
 101354e:	f04f 0003 	mov.w	r0, #3
 1013552:	df02      	svc	2
}
 1013554:	e743      	b.n	10133de <hci_evt_encode+0xce>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1013556:	4b4f      	ldr	r3, [pc, #316]	; (1013694 <hci_evt_encode+0x384>)
 1013558:	685b      	ldr	r3, [r3, #4]
 101355a:	009a      	lsls	r2, r3, #2
 101355c:	f57f af3f 	bpl.w	10133de <hci_evt_encode+0xce>
	    !(le_event_mask & BT_EVT_MASK_LE_DATA_LEN_CHANGE)) {
 1013560:	4b4d      	ldr	r3, [pc, #308]	; (1013698 <hci_evt_encode+0x388>)
 1013562:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1013564:	065b      	lsls	r3, r3, #25
 1013566:	f57f af3a 	bpl.w	10133de <hci_evt_encode+0xce>
 101356a:	350c      	adds	r5, #12
 101356c:	2102      	movs	r1, #2
 101356e:	4628      	mov	r0, r5
 1013570:	f00a fe92 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 1013574:	f640 323e 	movw	r2, #2878	; 0xb3e
 1013578:	4603      	mov	r3, r0
 101357a:	2101      	movs	r1, #1
 101357c:	801a      	strh	r2, [r3, #0]
 101357e:	4628      	mov	r0, r5
 1013580:	f00a fe8a 	bl	101e298 <net_buf_simple_add>
	me->subevent = subevt;
 1013584:	2207      	movs	r2, #7
 1013586:	4603      	mov	r3, r0
 1013588:	210a      	movs	r1, #10
 101358a:	701a      	strb	r2, [r3, #0]
 101358c:	4628      	mov	r0, r5
 101358e:	f00a fe83 	bl	101e298 <net_buf_simple_add>
	sep->handle = sys_cpu_to_le16(handle);
 1013592:	8006      	strh	r6, [r0, #0]
	sep->max_tx_octets = pdu_data->llctrl.length_rsp.max_tx_octets;
 1013594:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
 1013596:	8043      	strh	r3, [r0, #2]
	sep->max_tx_time = pdu_data->llctrl.length_rsp.max_tx_time;
 1013598:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 101359a:	8083      	strh	r3, [r0, #4]
	sep->max_rx_octets = pdu_data->llctrl.length_rsp.max_rx_octets;
 101359c:	8c23      	ldrh	r3, [r4, #32]
 101359e:	80c3      	strh	r3, [r0, #6]
	sep->max_rx_time = pdu_data->llctrl.length_rsp.max_rx_time;
 10135a0:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 10135a2:	8103      	strh	r3, [r0, #8]
 10135a4:	e71b      	b.n	10133de <hci_evt_encode+0xce>
 10135a6:	350c      	adds	r5, #12
 10135a8:	2102      	movs	r1, #2
 10135aa:	4628      	mov	r0, r5
 10135ac:	f00a fe74 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 10135b0:	f240 623e 	movw	r2, #1598	; 0x63e
 10135b4:	4603      	mov	r3, r0
 10135b6:	2101      	movs	r1, #1
 10135b8:	801a      	strh	r2, [r3, #0]
 10135ba:	4628      	mov	r0, r5
 10135bc:	f00a fe6c 	bl	101e298 <net_buf_simple_add>
	me->subevent = subevt;
 10135c0:	220c      	movs	r2, #12
 10135c2:	4603      	mov	r3, r0
 10135c4:	2105      	movs	r1, #5
 10135c6:	701a      	strb	r2, [r3, #0]
 10135c8:	4628      	mov	r0, r5
 10135ca:	f00a fe65 	bl	101e298 <net_buf_simple_add>
	sep->status = pu->status;
 10135ce:	7f23      	ldrb	r3, [r4, #28]
	sep->handle = sys_cpu_to_le16(handle);
 10135d0:	f8a0 6001 	strh.w	r6, [r0, #1]
	sep->status = pu->status;
 10135d4:	7003      	strb	r3, [r0, #0]
 10135d6:	7f62      	ldrb	r2, [r4, #29]
 10135d8:	fa92 f3a2 	rbit	r3, r2
 10135dc:	2a00      	cmp	r2, #0
 10135de:	fab3 f383 	clz	r3, r3
 10135e2:	bf08      	it	eq
 10135e4:	f04f 33ff 	moveq.w	r3, #4294967295
 10135e8:	3301      	adds	r3, #1
	sep->tx_phy = find_lsb_set(pu->tx);
 10135ea:	70c3      	strb	r3, [r0, #3]
 10135ec:	7fa2      	ldrb	r2, [r4, #30]
 10135ee:	fa92 f3a2 	rbit	r3, r2
 10135f2:	2a00      	cmp	r2, #0
 10135f4:	fab3 f383 	clz	r3, r3
 10135f8:	bf08      	it	eq
 10135fa:	f04f 33ff 	moveq.w	r3, #4294967295
 10135fe:	3301      	adds	r3, #1
	sep->rx_phy = find_lsb_set(pu->rx);
 1013600:	7103      	strb	r3, [r0, #4]
 1013602:	e6ec      	b.n	10133de <hci_evt_encode+0xce>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1013604:	4b23      	ldr	r3, [pc, #140]	; (1013694 <hci_evt_encode+0x384>)
 1013606:	685b      	ldr	r3, [r3, #4]
 1013608:	0098      	lsls	r0, r3, #2
 101360a:	f57f aee8 	bpl.w	10133de <hci_evt_encode+0xce>
	    !(le_event_mask & BT_EVT_MASK_LE_LTK_REQUEST)) {
 101360e:	4b22      	ldr	r3, [pc, #136]	; (1013698 <hci_evt_encode+0x388>)
 1013610:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1013612:	06d9      	lsls	r1, r3, #27
 1013614:	f57f aee3 	bpl.w	10133de <hci_evt_encode+0xce>
 1013618:	350c      	adds	r5, #12
 101361a:	2102      	movs	r1, #2
 101361c:	4628      	mov	r0, r5
 101361e:	f00a fe3b 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 1013622:	f640 523e 	movw	r2, #3390	; 0xd3e
 1013626:	4603      	mov	r3, r0
 1013628:	2101      	movs	r1, #1
 101362a:	801a      	strh	r2, [r3, #0]
 101362c:	4628      	mov	r0, r5
 101362e:	f00a fe33 	bl	101e298 <net_buf_simple_add>
	me->subevent = subevt;
 1013632:	2205      	movs	r2, #5
 1013634:	4603      	mov	r3, r0
 1013636:	210c      	movs	r1, #12
 1013638:	701a      	strb	r2, [r3, #0]
 101363a:	4628      	mov	r0, r5
 101363c:	f00a fe2c 	bl	101e298 <net_buf_simple_add>
 1013640:	4605      	mov	r5, r0
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(uint64_t));
 1013642:	f104 0120 	add.w	r1, r4, #32
 1013646:	2208      	movs	r2, #8
	sep->handle = sys_cpu_to_le16(handle);
 1013648:	f820 6b02 	strh.w	r6, [r0], #2
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(uint64_t));
 101364c:	f013 f992 	bl	1026974 <memcpy>
	memcpy(&sep->ediv, pdu_data->llctrl.enc_req.ediv, sizeof(uint16_t));
 1013650:	2202      	movs	r2, #2
 1013652:	f104 0128 	add.w	r1, r4, #40	; 0x28
 1013656:	f105 000a 	add.w	r0, r5, #10
 101365a:	f013 f98b 	bl	1026974 <memcpy>
 101365e:	e6be      	b.n	10133de <hci_evt_encode+0xce>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
 1013660:	4b0c      	ldr	r3, [pc, #48]	; (1013694 <hci_evt_encode+0x384>)
 1013662:	2400      	movs	r4, #0
 1013664:	681b      	ldr	r3, [r3, #0]
 1013666:	061a      	lsls	r2, r3, #24
 1013668:	f57f aeb9 	bpl.w	10133de <hci_evt_encode+0xce>
 101366c:	350c      	adds	r5, #12
 101366e:	2102      	movs	r1, #2
 1013670:	4628      	mov	r0, r5
 1013672:	f00a fe11 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 1013676:	f44f 6281 	mov.w	r2, #1032	; 0x408
 101367a:	4603      	mov	r3, r0
 101367c:	2104      	movs	r1, #4
 101367e:	801a      	strh	r2, [r3, #0]
 1013680:	4628      	mov	r0, r5
 1013682:	f00a fe09 	bl	101e298 <net_buf_simple_add>
	ep->encrypt = !err ? 1 : 0;
 1013686:	2301      	movs	r3, #1
	ep->status = err;
 1013688:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
 101368a:	f8a0 6001 	strh.w	r6, [r0, #1]
	ep->encrypt = !err ? 1 : 0;
 101368e:	70c3      	strb	r3, [r0, #3]
 1013690:	e6a5      	b.n	10133de <hci_evt_encode+0xce>
 1013692:	bf00      	nop
 1013694:	21000168 	.word	0x21000168
 1013698:	21000160 	.word	0x21000160
 101369c:	210036e8 	.word	0x210036e8
 10136a0:	0102a4e8 	.word	0x0102a4e8
 10136a4:	0102997c 	.word	0x0102997c
 10136a8:	0102a434 	.word	0x0102a434
 10136ac:	0102a300 	.word	0x0102a300
 10136b0:	0102a278 	.word	0x0102a278
		le_unknown_rsp(pdu_data, handle, buf);
 10136b4:	f890 3020 	ldrb.w	r3, [r0, #32]
	switch (pdu_data->llctrl.unknown_rsp.type) {
 10136b8:	2b0e      	cmp	r3, #14
 10136ba:	f000 80bf 	beq.w	101383c <hci_evt_encode+0x52c>
		LOG_WRN("type: 0x%02x",	pdu_data->llctrl.unknown_rsp.type);
 10136be:	466c      	mov	r4, sp
 10136c0:	b088      	sub	sp, #32
 10136c2:	a904      	add	r1, sp, #16
 10136c4:	2003      	movs	r0, #3
 10136c6:	460a      	mov	r2, r1
 10136c8:	4d68      	ldr	r5, [pc, #416]	; (101386c <hci_evt_encode+0x55c>)
 10136ca:	e9c1 5305 	strd	r5, r3, [r1, #20]
 10136ce:	f842 0f10 	str.w	r0, [r2, #16]!
 10136d2:	2300      	movs	r3, #0
 10136d4:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 10136d8:	4865      	ldr	r0, [pc, #404]	; (1013870 <hci_evt_encode+0x560>)
 10136da:	f7f1 f815 	bl	1004708 <z_impl_z_log_msg_static_create>
 10136de:	46a5      	mov	sp, r4
 10136e0:	e67d      	b.n	10133de <hci_evt_encode+0xce>
		le_remote_feat_complete(0x00, pdu_data, handle, buf);
 10136e2:	460b      	mov	r3, r1
 10136e4:	4632      	mov	r2, r6
 10136e6:	4641      	mov	r1, r8
 10136e8:	2000      	movs	r0, #0
 10136ea:	f7ff f81d 	bl	1012728 <le_remote_feat_complete>
		break;
 10136ee:	e676      	b.n	10133de <hci_evt_encode+0xce>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10136f0:	4b60      	ldr	r3, [pc, #384]	; (1013874 <hci_evt_encode+0x564>)
 10136f2:	685b      	ldr	r3, [r3, #4]
 10136f4:	0098      	lsls	r0, r3, #2
 10136f6:	f140 8096 	bpl.w	1013826 <hci_evt_encode+0x516>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_PARAM_REQ)) {
 10136fa:	4b5f      	ldr	r3, [pc, #380]	; (1013878 <hci_evt_encode+0x568>)
 10136fc:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10136fe:	0699      	lsls	r1, r3, #26
 1013700:	f140 8091 	bpl.w	1013826 <hci_evt_encode+0x516>
 1013704:	350c      	adds	r5, #12
 1013706:	2102      	movs	r1, #2
 1013708:	4628      	mov	r0, r5
 101370a:	f00a fdc5 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 101370e:	f640 323e 	movw	r2, #2878	; 0xb3e
 1013712:	4603      	mov	r3, r0
 1013714:	2101      	movs	r1, #1
 1013716:	801a      	strh	r2, [r3, #0]
 1013718:	4628      	mov	r0, r5
 101371a:	f00a fdbd 	bl	101e298 <net_buf_simple_add>
	me->subevent = subevt;
 101371e:	2206      	movs	r2, #6
 1013720:	4603      	mov	r3, r0
 1013722:	210a      	movs	r1, #10
 1013724:	701a      	strb	r2, [r3, #0]
 1013726:	4628      	mov	r0, r5
 1013728:	f00a fdb6 	bl	101e298 <net_buf_simple_add>
	sep->handle = sys_cpu_to_le16(handle);
 101372c:	8006      	strh	r6, [r0, #0]
	sep->interval_min = pdu_data->llctrl.conn_param_req.interval_min;
 101372e:	8c23      	ldrh	r3, [r4, #32]
 1013730:	8043      	strh	r3, [r0, #2]
	sep->interval_max = pdu_data->llctrl.conn_param_req.interval_max;
 1013732:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 1013734:	8083      	strh	r3, [r0, #4]
	sep->latency = pdu_data->llctrl.conn_param_req.latency;
 1013736:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
 1013738:	80c3      	strh	r3, [r0, #6]
	sep->timeout = pdu_data->llctrl.conn_param_req.timeout;
 101373a:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 101373c:	8103      	strh	r3, [r0, #8]
 101373e:	e64e      	b.n	10133de <hci_evt_encode+0xce>
		LOG_WRN("reject opcode: 0x%02x", pdu->llctrl.reject_ext_ind.reject_opcode);
 1013740:	466d      	mov	r5, sp
 1013742:	b088      	sub	sp, #32
	switch (pdu->llctrl.reject_ext_ind.reject_opcode) {
 1013744:	f890 4020 	ldrb.w	r4, [r0, #32]
		LOG_WRN("reject opcode: 0x%02x", pdu->llctrl.reject_ext_ind.reject_opcode);
 1013748:	ab04      	add	r3, sp, #16
 101374a:	2103      	movs	r1, #3
 101374c:	461a      	mov	r2, r3
 101374e:	484b      	ldr	r0, [pc, #300]	; (101387c <hci_evt_encode+0x56c>)
 1013750:	e9c3 0405 	strd	r0, r4, [r3, #20]
 1013754:	f842 1f10 	str.w	r1, [r2, #16]!
 1013758:	2300      	movs	r3, #0
 101375a:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
 101375e:	4844      	ldr	r0, [pc, #272]	; (1013870 <hci_evt_encode+0x560>)
 1013760:	f7f0 ffd2 	bl	1004708 <z_impl_z_log_msg_static_create>
 1013764:	46ad      	mov	sp, r5
}
 1013766:	e63a      	b.n	10133de <hci_evt_encode+0xce>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
 1013768:	4b42      	ldr	r3, [pc, #264]	; (1013874 <hci_evt_encode+0x564>)
		encrypt_change(pdu_data->llctrl.reject_ind.error_code, handle,
 101376a:	f890 4020 	ldrb.w	r4, [r0, #32]
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
 101376e:	681b      	ldr	r3, [r3, #0]
 1013770:	061b      	lsls	r3, r3, #24
 1013772:	f57f ae34 	bpl.w	10133de <hci_evt_encode+0xce>
 1013776:	350c      	adds	r5, #12
 1013778:	2102      	movs	r1, #2
 101377a:	4628      	mov	r0, r5
 101377c:	f00a fd8c 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 1013780:	f44f 6281 	mov.w	r2, #1032	; 0x408
 1013784:	4603      	mov	r3, r0
 1013786:	2104      	movs	r1, #4
 1013788:	801a      	strh	r2, [r3, #0]
 101378a:	4628      	mov	r0, r5
 101378c:	f00a fd84 	bl	101e298 <net_buf_simple_add>
	ep->encrypt = !err ? 1 : 0;
 1013790:	fab4 f384 	clz	r3, r4
 1013794:	095b      	lsrs	r3, r3, #5
	ep->status = err;
 1013796:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
 1013798:	f8a0 6001 	strh.w	r6, [r0, #1]
	ep->encrypt = !err ? 1 : 0;
 101379c:	70c3      	strb	r3, [r0, #3]
 101379e:	e61e      	b.n	10133de <hci_evt_encode+0xce>
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cc));
 10137a0:	f641 63a1 	movw	r3, #7841	; 0x1ea1
 10137a4:	4a36      	ldr	r2, [pc, #216]	; (1013880 <hci_evt_encode+0x570>)
 10137a6:	4937      	ldr	r1, [pc, #220]	; (1013884 <hci_evt_encode+0x574>)
 10137a8:	4837      	ldr	r0, [pc, #220]	; (1013888 <hci_evt_encode+0x578>)
 10137aa:	f011 fa14 	bl	1024bd6 <assert_print>
 10137ae:	4040      	eors	r0, r0
 10137b0:	f380 8811 	msr	BASEPRI, r0
 10137b4:	f04f 0003 	mov.w	r0, #3
 10137b8:	df02      	svc	2
 10137ba:	e5e1      	b.n	1013380 <hci_evt_encode+0x70>
		conn_count++;
 10137bc:	4a33      	ldr	r2, [pc, #204]	; (101388c <hci_evt_encode+0x57c>)
 10137be:	2102      	movs	r1, #2
 10137c0:	6813      	ldr	r3, [r2, #0]
 10137c2:	4628      	mov	r0, r5
 10137c4:	3301      	adds	r3, #1
 10137c6:	6013      	str	r3, [r2, #0]
 10137c8:	f00a fd66 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 10137cc:	f241 323e 	movw	r2, #4926	; 0x133e
 10137d0:	4603      	mov	r3, r0
 10137d2:	2101      	movs	r1, #1
 10137d4:	801a      	strh	r2, [r3, #0]
 10137d6:	4628      	mov	r0, r5
 10137d8:	f00a fd5e 	bl	101e298 <net_buf_simple_add>
	me->subevent = subevt;
 10137dc:	2201      	movs	r2, #1
 10137de:	4603      	mov	r3, r0
 10137e0:	2112      	movs	r1, #18
 10137e2:	701a      	strb	r2, [r3, #0]
 10137e4:	4628      	mov	r0, r5
 10137e6:	f00a fd57 	bl	101e298 <net_buf_simple_add>
 10137ea:	4605      	mov	r5, r0
	lecc->status = 0x00;
 10137ec:	f880 8000 	strb.w	r8, [r0]
	lecc->handle = sys_cpu_to_le16(handle);
 10137f0:	f8a0 6001 	strh.w	r6, [r0, #1]
	lecc->role = cc->role;
 10137f4:	7f63      	ldrb	r3, [r4, #29]
	memcpy(&lecc->peer_addr.a.val[0], &cc->peer_addr[0], BDADDR_SIZE);
 10137f6:	2206      	movs	r2, #6
	lecc->role = cc->role;
 10137f8:	70c3      	strb	r3, [r0, #3]
	lecc->peer_addr.type = cc->peer_addr_type & 0x1;
 10137fa:	7fa3      	ldrb	r3, [r4, #30]
	memcpy(&lecc->peer_addr.a.val[0], &cc->peer_addr[0], BDADDR_SIZE);
 10137fc:	f104 011f 	add.w	r1, r4, #31
	lecc->peer_addr.type = cc->peer_addr_type & 0x1;
 1013800:	f003 0301 	and.w	r3, r3, #1
 1013804:	7103      	strb	r3, [r0, #4]
	memcpy(&lecc->peer_addr.a.val[0], &cc->peer_addr[0], BDADDR_SIZE);
 1013806:	3005      	adds	r0, #5
 1013808:	f013 f8b4 	bl	1026974 <memcpy>
	lecc->interval = sys_cpu_to_le16(cc->interval);
 101380c:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 101380e:	f8a5 300b 	strh.w	r3, [r5, #11]
	lecc->latency = sys_cpu_to_le16(cc->latency);
 1013812:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 1013814:	f8a5 300d 	strh.w	r3, [r5, #13]
	lecc->supv_timeout = sys_cpu_to_le16(cc->timeout);
 1013818:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 101381a:	f8a5 300f 	strh.w	r3, [r5, #15]
	lecc->clock_accuracy = cc->sca;
 101381e:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 1013822:	746b      	strb	r3, [r5, #17]
 1013824:	e5db      	b.n	10133de <hci_evt_encode+0xce>
		ll_conn_update(handle, 2, BT_HCI_ERR_UNSUPP_REMOTE_FEATURE, 0,
 1013826:	2300      	movs	r3, #0
 1013828:	221a      	movs	r2, #26
 101382a:	2102      	movs	r1, #2
 101382c:	4630      	mov	r0, r6
 101382e:	e9cd 3302 	strd	r3, r3, [sp, #8]
 1013832:	e9cd 3300 	strd	r3, r3, [sp]
 1013836:	f002 f9f3 	bl	1015c20 <ll_conn_update>
		return;
 101383a:	e5d0      	b.n	10133de <hci_evt_encode+0xce>
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
 101383c:	460b      	mov	r3, r1
 101383e:	4632      	mov	r2, r6
 1013840:	2100      	movs	r1, #0
 1013842:	201a      	movs	r0, #26
 1013844:	f7fe ff70 	bl	1012728 <le_remote_feat_complete>
		break;
 1013848:	e5c9      	b.n	10133de <hci_evt_encode+0xce>
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cu));
 101384a:	f641 7326 	movw	r3, #7974	; 0x1f26
 101384e:	4a0c      	ldr	r2, [pc, #48]	; (1013880 <hci_evt_encode+0x570>)
 1013850:	490f      	ldr	r1, [pc, #60]	; (1013890 <hci_evt_encode+0x580>)
 1013852:	480d      	ldr	r0, [pc, #52]	; (1013888 <hci_evt_encode+0x578>)
 1013854:	f011 f9bf 	bl	1024bd6 <assert_print>
 1013858:	4040      	eors	r0, r0
 101385a:	f380 8811 	msr	BASEPRI, r0
 101385e:	f04f 0003 	mov.w	r0, #3
 1013862:	df02      	svc	2
 1013864:	e5df      	b.n	1013426 <hci_evt_encode+0x116>
		LL_ASSERT(0);
 1013866:	f242 037f 	movw	r3, #8319	; 0x207f
 101386a:	e668      	b.n	101353e <hci_evt_encode+0x22e>
 101386c:	0102a514 	.word	0x0102a514
 1013870:	0102997c 	.word	0x0102997c
 1013874:	21000168 	.word	0x21000168
 1013878:	21000160 	.word	0x21000160
 101387c:	0102a524 	.word	0x0102a524
 1013880:	0102a434 	.word	0x0102a434
 1013884:	0102a470 	.word	0x0102a470
 1013888:	0102a278 	.word	0x0102a278
 101388c:	21004d10 	.word	0x21004d10
 1013890:	0102a4ac 	.word	0x0102a4ac

01013894 <hci_num_cmplt_encode>:

#if defined(CONFIG_BT_CONN) || defined(CONFIG_BT_CTLR_ADV_ISO) || \
	defined(CONFIG_BT_CTLR_CONN_ISO)
void hci_num_cmplt_encode(struct net_buf *buf, uint16_t handle, uint8_t num)
{
 1013894:	b570      	push	{r4, r5, r6, lr}
 1013896:	f100 040c 	add.w	r4, r0, #12
 101389a:	460e      	mov	r6, r1
 101389c:	4620      	mov	r0, r4
 101389e:	2102      	movs	r1, #2
 10138a0:	4615      	mov	r5, r2
 10138a2:	f00a fcf9 	bl	101e298 <net_buf_simple_add>
	hdr->evt = evt;
 10138a6:	f240 5213 	movw	r2, #1299	; 0x513
 10138aa:	4603      	mov	r3, r0
 10138ac:	2105      	movs	r1, #5
 10138ae:	801a      	strh	r2, [r3, #0]
 10138b0:	4620      	mov	r0, r4
 10138b2:	f00a fcf1 	bl	101e298 <net_buf_simple_add>

	len = (sizeof(*ep) + (sizeof(*hc) * num_handles));
	hci_evt_create(buf, BT_HCI_EVT_NUM_COMPLETED_PACKETS, len);

	ep = net_buf_add(buf, len);
	ep->num_handles = num_handles;
 10138b6:	2301      	movs	r3, #1
	hc = &ep->h[0];
	hc->handle = sys_cpu_to_le16(handle);
 10138b8:	f8a0 6001 	strh.w	r6, [r0, #1]
	ep->num_handles = num_handles;
 10138bc:	7003      	strb	r3, [r0, #0]
	hc->count = sys_cpu_to_le16(num);
 10138be:	f8a0 5003 	strh.w	r5, [r0, #3]
}
 10138c2:	bd70      	pop	{r4, r5, r6, pc}

010138c4 <hci_get_class>:
{
#if defined(CONFIG_BT_CONN)
	struct pdu_data *pdu_data = (void *)node_rx->pdu;
#endif

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 10138c4:	7903      	ldrb	r3, [r0, #4]
 10138c6:	2b03      	cmp	r3, #3
 10138c8:	d009      	beq.n	10138de <hci_get_class+0x1a>

		switch (node_rx->hdr.type) {
 10138ca:	2b17      	cmp	r3, #23
 10138cc:	d005      	beq.n	10138da <hci_get_class+0x16>
 10138ce:	3b18      	subs	r3, #24
 10138d0:	2b05      	cmp	r3, #5
 10138d2:	bf8c      	ite	hi
 10138d4:	2000      	movhi	r0, #0
 10138d6:	2003      	movls	r0, #3
 10138d8:	4770      	bx	lr

#if defined(CONFIG_BT_CTLR_DF_CONN_CTE_RX)
		case NODE_RX_TYPE_CONN_IQ_SAMPLE_REPORT:
#endif /* CONFIG_BT_CTLR_DF_CONN_CTE_RX */

			return HCI_CLASS_EVT_REQUIRED;
 10138da:	2001      	movs	r0, #1
#else
	} else {
		return HCI_CLASS_NONE;
	}
#endif
}
 10138dc:	4770      	bx	lr
	} else if (pdu_data->ll_id == PDU_DATA_LLID_CTRL) {
 10138de:	7f03      	ldrb	r3, [r0, #28]
 10138e0:	f003 0303 	and.w	r3, r3, #3
		return HCI_CLASS_EVT_LLCP;
 10138e4:	2b03      	cmp	r3, #3
 10138e6:	bf14      	ite	ne
 10138e8:	2005      	movne	r0, #5
 10138ea:	2004      	moveq	r0, #4
 10138ec:	4770      	bx	lr
 10138ee:	bf00      	nop

010138f0 <hci_init>:

void hci_init(struct k_poll_signal *signal_host_buf)
{
 10138f0:	b4f0      	push	{r4, r5, r6, r7}
	event_mask = DEFAULT_EVENT_MASK;
 10138f2:	f04f 34ff 	mov.w	r4, #4294967295
 10138f6:	f641 75ff 	movw	r5, #8191	; 0x1fff
	conn_count = 0U;
 10138fa:	2100      	movs	r1, #0
	event_mask = DEFAULT_EVENT_MASK;
 10138fc:	4a08      	ldr	r2, [pc, #32]	; (1013920 <hci_init+0x30>)
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
 10138fe:	2600      	movs	r6, #0
	event_mask = DEFAULT_EVENT_MASK;
 1013900:	e9c2 4500 	strd	r4, r5, [r2]
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
 1013904:	2700      	movs	r7, #0
	conn_count = 0U;
 1013906:	4a07      	ldr	r2, [pc, #28]	; (1013924 <hci_init+0x34>)
	le_event_mask = DEFAULT_LE_EVENT_MASK;
 1013908:	201f      	movs	r0, #31
	conn_count = 0U;
 101390a:	6011      	str	r1, [r2, #0]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
 101390c:	2100      	movs	r1, #0
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
 101390e:	4b06      	ldr	r3, [pc, #24]	; (1013928 <hci_init+0x38>)
 1013910:	e9c3 6700 	strd	r6, r7, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
 1013914:	4b05      	ldr	r3, [pc, #20]	; (101392c <hci_init+0x3c>)
 1013916:	e9c3 0100 	strd	r0, r1, [r3]
#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	hbuf_signal = signal_host_buf;
#endif
	reset(NULL, NULL);
}
 101391a:	bcf0      	pop	{r4, r5, r6, r7}
	hci_recv_fifo_reset();
 101391c:	f7fe bef4 	b.w	1012708 <hci_recv_fifo_reset>
 1013920:	21000168 	.word	0x21000168
 1013924:	21004d10 	.word	0x21004d10
 1013928:	210036e8 	.word	0x210036e8
 101392c:	21000160 	.word	0x21000160

01013930 <bt_rand>:
#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_ctlr_crypto);

int bt_rand(void *buf, size_t len)
{
	return lll_csrand_get(buf, len);
 1013930:	f007 be1e 	b.w	101b570 <lll_csrand_get>

01013934 <bt_encrypt_le>:
}

int bt_encrypt_le(const uint8_t key[16], const uint8_t plaintext[16],
		  uint8_t enc_data[16])
{
 1013934:	b508      	push	{r3, lr}
	LOG_DBG("key %s", bt_hex(key, 16));
	LOG_DBG("plaintext %s", bt_hex(plaintext, 16));

	ecb_encrypt(key, plaintext, enc_data, NULL);
 1013936:	2300      	movs	r3, #0
 1013938:	f009 fbc4 	bl	101d0c4 <ecb_encrypt>

	LOG_DBG("enc_data %s", bt_hex(enc_data, 16));

	return 0;
}
 101393c:	2000      	movs	r0, #0
 101393e:	bd08      	pop	{r3, pc}

01013940 <ll_feat_get>:

#else /* !CONFIG_BT_CTLR_SET_HOST_FEATURE */
uint64_t ll_feat_get(void)
{
	return LL_FEAT;
}
 1013940:	2100      	movs	r1, #0
 1013942:	4801      	ldr	r0, [pc, #4]	; (1013948 <ll_feat_get+0x8>)
 1013944:	4770      	bx	lr
 1013946:	bf00      	nop
 1013948:	0001413f 	.word	0x0001413f

0101394c <perform_lll_reset>:

	return 0;
}

static void perform_lll_reset(void *param)
{
 101394c:	b510      	push	{r4, lr}
 101394e:	4604      	mov	r4, r0
	int err;

	/* Reset LLL */
	err = lll_reset();
 1013950:	f007 fe52 	bl	101b5f8 <lll_reset>
	LL_ASSERT(!err);
 1013954:	b950      	cbnz	r0, 101396c <perform_lll_reset+0x20>

#if defined(CONFIG_BT_BROADCASTER)
	/* Reset adv state */
	err = lll_adv_reset();
 1013956:	f008 fa43 	bl	101bde0 <lll_adv_reset>
	LL_ASSERT(!err);
 101395a:	b9c0      	cbnz	r0, 101398e <perform_lll_reset+0x42>
	LL_ASSERT(!err);
#endif /* CONFIG_BT_OBSERVER */

#if defined(CONFIG_BT_CONN)
	/* Reset conn role */
	err = lll_conn_reset();
 101395c:	f008 fe5a 	bl	101c614 <lll_conn_reset>
	LL_ASSERT(!err);
 1013960:	bb30      	cbnz	r0, 10139b0 <perform_lll_reset+0x64>
	z_impl_k_sem_give(sem);
 1013962:	4620      	mov	r0, r4
#endif /* CONFIG_BT_CTLR_DF */

#if !defined(CONFIG_BT_CTLR_ZLI)
	k_sem_give(param);
#endif /* !CONFIG_BT_CTLR_ZLI */
}
 1013964:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 1013968:	f00d be9a 	b.w	10216a0 <z_impl_k_sem_give>
	LL_ASSERT(!err);
 101396c:	f640 03ea 	movw	r3, #2282	; 0x8ea
 1013970:	4a18      	ldr	r2, [pc, #96]	; (10139d4 <perform_lll_reset+0x88>)
 1013972:	4919      	ldr	r1, [pc, #100]	; (10139d8 <perform_lll_reset+0x8c>)
 1013974:	4819      	ldr	r0, [pc, #100]	; (10139dc <perform_lll_reset+0x90>)
 1013976:	f011 f92e 	bl	1024bd6 <assert_print>
 101397a:	4040      	eors	r0, r0
 101397c:	f380 8811 	msr	BASEPRI, r0
 1013980:	f04f 0003 	mov.w	r0, #3
 1013984:	df02      	svc	2
	err = lll_adv_reset();
 1013986:	f008 fa2b 	bl	101bde0 <lll_adv_reset>
	LL_ASSERT(!err);
 101398a:	2800      	cmp	r0, #0
 101398c:	d0e6      	beq.n	101395c <perform_lll_reset+0x10>
 101398e:	f640 03ef 	movw	r3, #2287	; 0x8ef
 1013992:	4a10      	ldr	r2, [pc, #64]	; (10139d4 <perform_lll_reset+0x88>)
 1013994:	4910      	ldr	r1, [pc, #64]	; (10139d8 <perform_lll_reset+0x8c>)
 1013996:	4811      	ldr	r0, [pc, #68]	; (10139dc <perform_lll_reset+0x90>)
 1013998:	f011 f91d 	bl	1024bd6 <assert_print>
 101399c:	4040      	eors	r0, r0
 101399e:	f380 8811 	msr	BASEPRI, r0
 10139a2:	f04f 0003 	mov.w	r0, #3
 10139a6:	df02      	svc	2
	err = lll_conn_reset();
 10139a8:	f008 fe34 	bl	101c614 <lll_conn_reset>
	LL_ASSERT(!err);
 10139ac:	2800      	cmp	r0, #0
 10139ae:	d0d8      	beq.n	1013962 <perform_lll_reset+0x16>
 10139b0:	f640 03fb 	movw	r3, #2299	; 0x8fb
 10139b4:	4a07      	ldr	r2, [pc, #28]	; (10139d4 <perform_lll_reset+0x88>)
 10139b6:	4908      	ldr	r1, [pc, #32]	; (10139d8 <perform_lll_reset+0x8c>)
 10139b8:	4808      	ldr	r0, [pc, #32]	; (10139dc <perform_lll_reset+0x90>)
 10139ba:	f011 f90c 	bl	1024bd6 <assert_print>
 10139be:	4040      	eors	r0, r0
 10139c0:	f380 8811 	msr	BASEPRI, r0
 10139c4:	f04f 0003 	mov.w	r0, #3
 10139c8:	df02      	svc	2
 10139ca:	4620      	mov	r0, r4
}
 10139cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 10139d0:	f00d be66 	b.w	10216a0 <z_impl_k_sem_give>
 10139d4:	0102a558 	.word	0x0102a558
 10139d8:	0102a594 	.word	0x0102a594
 10139dc:	0102a278 	.word	0x0102a278

010139e0 <ull_ticker_status_give>:
	*((uint32_t volatile *)param) = status;
 10139e0:	6008      	str	r0, [r1, #0]
 10139e2:	4801      	ldr	r0, [pc, #4]	; (10139e8 <ull_ticker_status_give+0x8>)
 10139e4:	f00d be5c 	b.w	10216a0 <z_impl_k_sem_give>
 10139e8:	21006700 	.word	0x21006700

010139ec <disabled_cb>:
 10139ec:	f00d be58 	b.w	10216a0 <z_impl_k_sem_give>

010139f0 <tx_cmplt_get>:
}
#endif /* CONFIG_BT_CTLR_LOW_LAT_ULL */

#if defined(CONFIG_BT_CONN) || defined(CONFIG_BT_CTLR_ADV_ISO)
static uint8_t tx_cmplt_get(uint16_t *handle, uint8_t *first, uint8_t last)
{
 10139f0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct lll_tx *tx;
	uint8_t cmplt;
	uint8_t next;

	next = *first;
	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
 10139f4:	4d2b      	ldr	r5, [pc, #172]	; (1013aa4 <tx_cmplt_get+0xb4>)
	next = *first;
 10139f6:	780c      	ldrb	r4, [r1, #0]
	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
 10139f8:	78ae      	ldrb	r6, [r5, #2]
 10139fa:	792f      	ldrb	r7, [r5, #4]
 10139fc:	782b      	ldrb	r3, [r5, #0]
{
	void *p;
	uint8_t i;

	if (*idx >= count) {
		*idx = first;
 10139fe:	42b4      	cmp	r4, r6
 1013a00:	bf28      	it	cs
 1013a02:	463c      	movcs	r4, r7
	}

	if (*idx == last) {
 1013a04:	42a2      	cmp	r2, r4
 1013a06:	d044      	beq.n	1013a92 <tx_cmplt_get+0xa2>
	i = *idx + 1;
	if (i == count) {
		i = 0U;
	}

	p = (void *)(fifo + (*idx) * size);
 1013a08:	fb04 f303 	mul.w	r3, r4, r3
 1013a0c:	f105 0708 	add.w	r7, r5, #8
 1013a10:	468a      	mov	sl, r1
	i = *idx + 1;
 1013a12:	3401      	adds	r4, #1
				    &next);
	if (!tx) {
		return 0;
	}

	*handle = tx->handle;
 1013a14:	5af9      	ldrh	r1, [r7, r3]
 1013a16:	b2e4      	uxtb	r4, r4
		i = 0U;
 1013a18:	42a6      	cmp	r6, r4
 1013a1a:	bf08      	it	eq
 1013a1c:	2400      	moveq	r4, #0
	p = (void *)(fifo + (*idx) * size);
 1013a1e:	4693      	mov	fp, r2
 1013a20:	4681      	mov	r9, r0
	cmplt = 0U;
 1013a22:	2600      	movs	r6, #0
			     (p->ll_id == PDU_DATA_LLID_DATA_START ||
			      p->ll_id == PDU_DATA_LLID_DATA_CONTINUE)) ||
			    (!IS_NODE_TX_PTR(tx_node) &&
			     IS_NODE_TX_DATA(tx_node))) {
				/* data packet, hence count num cmplt */
				NODE_TX_DATA_SET(tx->node);
 1013a24:	f04f 0801 	mov.w	r8, #1
	*handle = tx->handle;
 1013a28:	8001      	strh	r1, [r0, #0]
 1013a2a:	443b      	add	r3, r7
	cmplt = 0U;
 1013a2c:	e01d      	b.n	1013a6a <tx_cmplt_get+0x7a>
			    (!IS_NODE_TX_PTR(tx_node) &&
 1013a2e:	2801      	cmp	r0, #1
 1013a30:	d02c      	beq.n	1013a8c <tx_cmplt_get+0x9c>
 1013a32:	2212      	movs	r2, #18
 1013a34:	605a      	str	r2, [r3, #4]
#if defined(CONFIG_BT_CTLR_ADV_ISO) || \
	defined(CONFIG_BT_CTLR_CONN_ISO)
next_ack:
#endif /* CONFIG_BT_CTLR_ADV_ISO || CONFIG_BT_CTLR_CONN_ISO */

		*first = next;
 1013a36:	f88a 4000 	strb.w	r4, [sl]
		tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
 1013a3a:	78a9      	ldrb	r1, [r5, #2]
 1013a3c:	f895 c004 	ldrb.w	ip, [r5, #4]
 1013a40:	782b      	ldrb	r3, [r5, #0]
	if (*idx >= count) {
 1013a42:	42a1      	cmp	r1, r4
 1013a44:	bf88      	it	hi
 1013a46:	46a4      	movhi	ip, r4
	if (*idx == last) {
 1013a48:	45e3      	cmp	fp, ip
 1013a4a:	d023      	beq.n	1013a94 <tx_cmplt_get+0xa4>
	p = (void *)(fifo + (*idx) * size);
 1013a4c:	fb03 f30c 	mul.w	r3, r3, ip
	i = *idx + 1;
 1013a50:	f10c 0c01 	add.w	ip, ip, #1
 1013a54:	fa5f f48c 	uxtb.w	r4, ip
		i = 0U;
 1013a58:	42a1      	cmp	r1, r4
 1013a5a:	bf08      	it	eq
 1013a5c:	2400      	moveq	r4, #0
					    mfifo_tx_ack.n, mfifo_tx_ack.f,
					    last, &next);
	} while (tx && tx->handle == *handle);
 1013a5e:	5af8      	ldrh	r0, [r7, r3]
 1013a60:	f8b9 1000 	ldrh.w	r1, [r9]
	p = (void *)(fifo + (*idx) * size);
 1013a64:	443b      	add	r3, r7
 1013a66:	4288      	cmp	r0, r1
 1013a68:	d114      	bne.n	1013a94 <tx_cmplt_get+0xa4>
			tx_node = tx->node;
 1013a6a:	6858      	ldr	r0, [r3, #4]
			if (!tx_node ||
 1013a6c:	b160      	cbz	r0, 1013a88 <tx_cmplt_get+0x98>
 1013a6e:	28ff      	cmp	r0, #255	; 0xff
 1013a70:	d9dd      	bls.n	1013a2e <tx_cmplt_get+0x3e>
			     (p->ll_id == PDU_DATA_LLID_DATA_START ||
 1013a72:	7901      	ldrb	r1, [r0, #4]
 1013a74:	f001 0103 	and.w	r1, r1, #3
			    (IS_NODE_TX_PTR(tx_node) &&
 1013a78:	3901      	subs	r1, #1
 1013a7a:	2901      	cmp	r1, #1
 1013a7c:	d90d      	bls.n	1013a9a <tx_cmplt_get+0xaa>
				NODE_TX_CTRL_SET(tx->node);
 1013a7e:	2112      	movs	r1, #18
 1013a80:	6059      	str	r1, [r3, #4]
				ll_tx_mem_release(tx_node);
 1013a82:	f002 f879 	bl	1015b78 <ll_tx_mem_release>
 1013a86:	e7d6      	b.n	1013a36 <tx_cmplt_get+0x46>
				NODE_TX_DATA_SET(tx->node);
 1013a88:	f8c3 8004 	str.w	r8, [r3, #4]
				cmplt++;
 1013a8c:	3601      	adds	r6, #1
 1013a8e:	b2f6      	uxtb	r6, r6
			if (IS_NODE_TX_PTR(tx_node)) {
 1013a90:	e7d1      	b.n	1013a36 <tx_cmplt_get+0x46>
		return 0;
 1013a92:	2600      	movs	r6, #0

	return cmplt;
}
 1013a94:	4630      	mov	r0, r6
 1013a96:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				cmplt++;
 1013a9a:	3601      	adds	r6, #1
				NODE_TX_DATA_SET(tx->node);
 1013a9c:	2101      	movs	r1, #1
				cmplt++;
 1013a9e:	b2f6      	uxtb	r6, r6
 1013aa0:	e7ee      	b.n	1013a80 <tx_cmplt_get+0x90>
 1013aa2:	bf00      	nop
 1013aa4:	21000520 	.word	0x21000520

01013aa8 <rx_replenish>:
{
 1013aa8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (max > mem_link_rx.quota_pdu) {
 1013aac:	4f3b      	ldr	r7, [pc, #236]	; (1013b9c <rx_replenish+0xf4>)
 1013aae:	883b      	ldrh	r3, [r7, #0]
 1013ab0:	4298      	cmp	r0, r3
 1013ab2:	d965      	bls.n	1013b80 <rx_replenish+0xd8>
	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1013ab4:	f013 06ff 	ands.w	r6, r3, #255	; 0xff
 1013ab8:	d02a      	beq.n	1013b10 <rx_replenish+0x68>
 1013aba:	4d39      	ldr	r5, [pc, #228]	; (1013ba0 <rx_replenish+0xf8>)
		link = mem_acquire(&mem_link_rx.free);
 1013abc:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 1013ba4 <rx_replenish+0xfc>
	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1013ac0:	796c      	ldrb	r4, [r5, #5]
		rx = mem_acquire(&mem_pdu_rx.free);
 1013ac2:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 1013ba8 <rx_replenish+0x100>
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1013ac6:	f105 0a08 	add.w	sl, r5, #8
	if (last == count) {
 1013aca:	78ab      	ldrb	r3, [r5, #2]
	last = last + 1;
 1013acc:	3401      	adds	r4, #1
 1013ace:	b2e4      	uxtb	r4, r4
		last = 0U;
 1013ad0:	42a3      	cmp	r3, r4
 1013ad2:	bf08      	it	eq
 1013ad4:	2400      	moveq	r4, #0
	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1013ad6:	792b      	ldrb	r3, [r5, #4]
	if (last == first) {
 1013ad8:	42a3      	cmp	r3, r4
 1013ada:	d01b      	beq.n	1013b14 <rx_replenish+0x6c>
		link = mem_acquire(&mem_link_rx.free);
 1013adc:	4640      	mov	r0, r8
 1013ade:	f7fd f9a3 	bl	1010e28 <mem_acquire>
		if (!link) {
 1013ae2:	4683      	mov	fp, r0
 1013ae4:	b1a0      	cbz	r0, 1013b10 <rx_replenish+0x68>
		rx = mem_acquire(&mem_pdu_rx.free);
 1013ae6:	4648      	mov	r0, r9
 1013ae8:	f7fd f99e 	bl	1010e28 <mem_acquire>
		if (!rx) {
 1013aec:	2800      	cmp	r0, #0
 1013aee:	d049      	beq.n	1013b84 <rx_replenish+0xdc>
		rx->link = link;
 1013af0:	f8c0 b000 	str.w	fp, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1013af4:	796b      	ldrb	r3, [r5, #5]
 1013af6:	782a      	ldrb	r2, [r5, #0]
 1013af8:	fb02 f303 	mul.w	r3, r2, r3
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1013afc:	f84a 0003 	str.w	r0, [sl, r3]
	mem_link_rx.quota_pdu += delta;
 1013b00:	883b      	ldrh	r3, [r7, #0]
		max--;
 1013b02:	3e01      	subs	r6, #1
	mem_link_rx.quota_pdu += delta;
 1013b04:	3b01      	subs	r3, #1
	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1013b06:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
	*last = idx; /* Commit: Update write index */
 1013b0a:	716c      	strb	r4, [r5, #5]
	mem_link_rx.quota_pdu += delta;
 1013b0c:	803b      	strh	r3, [r7, #0]
	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1013b0e:	d1dc      	bne.n	1013aca <rx_replenish+0x22>
}
 1013b10:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (mem_link_rx.quota_pdu &&
 1013b14:	883b      	ldrh	r3, [r7, #0]
 1013b16:	2b00      	cmp	r3, #0
 1013b18:	d0fa      	beq.n	1013b10 <rx_replenish+0x68>
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
 1013b1a:	f8df 9090 	ldr.w	r9, [pc, #144]	; 1013bac <rx_replenish+0x104>
		link = mem_acquire(&mem_link_rx.free);
 1013b1e:	4d21      	ldr	r5, [pc, #132]	; (1013ba4 <rx_replenish+0xfc>)
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
 1013b20:	f899 4005 	ldrb.w	r4, [r9, #5]
		rx = mem_acquire(&mem_pdu_rx.free);
 1013b24:	4e20      	ldr	r6, [pc, #128]	; (1013ba8 <rx_replenish+0x100>)
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1013b26:	f109 0808 	add.w	r8, r9, #8
	if (last == count) {
 1013b2a:	f899 3002 	ldrb.w	r3, [r9, #2]
	last = last + 1;
 1013b2e:	3401      	adds	r4, #1
 1013b30:	b2e4      	uxtb	r4, r4
		last = 0U;
 1013b32:	42a3      	cmp	r3, r4
 1013b34:	bf08      	it	eq
 1013b36:	2400      	moveq	r4, #0
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
 1013b38:	f899 3004 	ldrb.w	r3, [r9, #4]
	if (last == first) {
 1013b3c:	42a3      	cmp	r3, r4
 1013b3e:	d0e7      	beq.n	1013b10 <rx_replenish+0x68>
		link = mem_acquire(&mem_link_rx.free);
 1013b40:	4628      	mov	r0, r5
 1013b42:	f7fd f971 	bl	1010e28 <mem_acquire>
		if (!link) {
 1013b46:	4682      	mov	sl, r0
 1013b48:	2800      	cmp	r0, #0
 1013b4a:	d0e1      	beq.n	1013b10 <rx_replenish+0x68>
		rx = mem_acquire(&mem_pdu_rx.free);
 1013b4c:	4630      	mov	r0, r6
 1013b4e:	f7fd f96b 	bl	1010e28 <mem_acquire>
		if (!rx) {
 1013b52:	b1e8      	cbz	r0, 1013b90 <rx_replenish+0xe8>
		link->mem = NULL;
 1013b54:	2300      	movs	r3, #0
 1013b56:	f8ca 3004 	str.w	r3, [sl, #4]
		rx->link = link;
 1013b5a:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1013b5e:	f899 3005 	ldrb.w	r3, [r9, #5]
 1013b62:	f899 2000 	ldrb.w	r2, [r9]
 1013b66:	fb02 f303 	mul.w	r3, r2, r3
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1013b6a:	f848 0003 	str.w	r0, [r8, r3]
	mem_link_rx.quota_pdu += delta;
 1013b6e:	883b      	ldrh	r3, [r7, #0]
	*last = idx; /* Commit: Update write index */
 1013b70:	f889 4005 	strb.w	r4, [r9, #5]
 1013b74:	3b01      	subs	r3, #1
 1013b76:	b29b      	uxth	r3, r3
 1013b78:	803b      	strh	r3, [r7, #0]
	while (mem_link_rx.quota_pdu &&
 1013b7a:	2b00      	cmp	r3, #0
 1013b7c:	d1d5      	bne.n	1013b2a <rx_replenish+0x82>
 1013b7e:	e7c7      	b.n	1013b10 <rx_replenish+0x68>
 1013b80:	4606      	mov	r6, r0
 1013b82:	e79a      	b.n	1013aba <rx_replenish+0x12>
	mem_release(link, &mem_link_rx.free);
 1013b84:	4658      	mov	r0, fp
}
 1013b86:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	mem_release(link, &mem_link_rx.free);
 1013b8a:	4906      	ldr	r1, [pc, #24]	; (1013ba4 <rx_replenish+0xfc>)
 1013b8c:	f7fd b968 	b.w	1010e60 <mem_release>
 1013b90:	4650      	mov	r0, sl
}
 1013b92:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	mem_release(link, &mem_link_rx.free);
 1013b96:	4903      	ldr	r1, [pc, #12]	; (1013ba4 <rx_replenish+0xfc>)
 1013b98:	f7fd b962 	b.w	1010e60 <mem_release>
 1013b9c:	21004d64 	.word	0x21004d64
 1013ba0:	21000594 	.word	0x21000594
 1013ba4:	21004d68 	.word	0x21004d68
 1013ba8:	21004e64 	.word	0x21004e64
 1013bac:	21000548 	.word	0x21000548

01013bb0 <ull_done>:
}
#endif /* CONFIG_BT_CONN || CONFIG_BT_CTLR_ADV_ISO */

#if !defined(CONFIG_BT_CTLR_LOW_LAT_ULL)
static void ull_done(void *param)
{
 1013bb0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1013bb4:	4e3c      	ldr	r6, [pc, #240]	; (1013ca8 <ull_done+0xf8>)
	void *release;

	/* Decrement prepare reference if ULL will not resume */
	ull_hdr = done->param;
	if (ull_hdr) {
		LL_ASSERT(ull_ref_get(ull_hdr));
 1013bb6:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 1013cac <ull_done+0xfc>
 1013bba:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 1013cb0 <ull_done+0x100>
{
 1013bbe:	b083      	sub	sp, #12
		link = memq_peek(memq_ull_done.head, memq_ull_done.tail,
 1013bc0:	aa01      	add	r2, sp, #4
 1013bc2:	e9d6 0100 	ldrd	r0, r1, [r6]
 1013bc6:	f7fd f99f 	bl	1010f08 <memq_peek>
		if (link) {
 1013bca:	4604      	mov	r4, r0
 1013bcc:	2800      	cmp	r0, #0
 1013bce:	d03e      	beq.n	1013c4e <ull_done+0x9e>
			(void)memq_dequeue(memq_ull_done.tail,
 1013bd0:	2200      	movs	r2, #0
 1013bd2:	4631      	mov	r1, r6
 1013bd4:	6870      	ldr	r0, [r6, #4]
 1013bd6:	f7fd f99f 	bl	1010f18 <memq_dequeue>
			rx_demux_event_done(link, done);
 1013bda:	9f01      	ldr	r7, [sp, #4]
	ull_hdr = done->param;
 1013bdc:	69fd      	ldr	r5, [r7, #28]
	if (ull_hdr) {
 1013bde:	b135      	cbz	r5, 1013bee <ull_done+0x3e>
	return hdr->ref;
 1013be0:	782b      	ldrb	r3, [r5, #0]
		LL_ASSERT(ull_ref_get(ull_hdr));
 1013be2:	2b00      	cmp	r3, #0
 1013be4:	d052      	beq.n	1013c8c <ull_done+0xdc>
	return hdr->ref--;
 1013be6:	782b      	ldrb	r3, [r5, #0]
 1013be8:	3b01      	subs	r3, #1
 1013bea:	b2db      	uxtb	r3, r3
 1013bec:	702b      	strb	r3, [r5, #0]
		ull_ref_dec(ull_hdr);
	}

	/* Process role dependent event done */
	switch (done->extra.type) {
 1013bee:	f897 3020 	ldrb.w	r3, [r7, #32]
 1013bf2:	b123      	cbz	r3, 1013bfe <ull_done+0x4e>
 1013bf4:	2b01      	cmp	r3, #1
 1013bf6:	d13b      	bne.n	1013c70 <ull_done+0xc0>
#if defined(CONFIG_BT_CONN)
	case EVENT_DONE_EXTRA_TYPE_CONN:
		ull_conn_done(done);
 1013bf8:	4638      	mov	r0, r7
 1013bfa:	f002 fbef 	bl	10163dc <ull_conn_done>
		LL_ASSERT(0);
		break;
	}

	/* Release done */
	done->extra.type = 0U;
 1013bfe:	2000      	movs	r0, #0
	release = RXFIFO_RELEASE(done, link, done);
 1013c00:	4a2c      	ldr	r2, [pc, #176]	; (1013cb4 <ull_done+0x104>)
	done->extra.type = 0U;
 1013c02:	f887 0020 	strb.w	r0, [r7, #32]
	last = last + 1;
 1013c06:	7953      	ldrb	r3, [r2, #5]
	if (last == count) {
 1013c08:	7891      	ldrb	r1, [r2, #2]
	last = last + 1;
 1013c0a:	3301      	adds	r3, #1
 1013c0c:	b2db      	uxtb	r3, r3
		last = 0U;
 1013c0e:	4299      	cmp	r1, r3
 1013c10:	bf08      	it	eq
 1013c12:	4603      	moveq	r3, r0
	release = RXFIFO_RELEASE(done, link, done);
 1013c14:	7911      	ldrb	r1, [r2, #4]
 1013c16:	f892 c000 	ldrb.w	ip, [r2]
	if (last == first) {
 1013c1a:	4299      	cmp	r1, r3
 1013c1c:	d01a      	beq.n	1013c54 <ull_done+0xa4>

	if (!mfifo_enqueue_idx_get(n, f, *l, &idx)) {
		return NULL;
	}

	rx->link = link;
 1013c1e:	603c      	str	r4, [r7, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1013c20:	7951      	ldrb	r1, [r2, #5]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1013c22:	fb0c 2101 	mla	r1, ip, r1, r2
 1013c26:	608f      	str	r7, [r1, #8]
	*last = idx; /* Commit: Update write index */
 1013c28:	7153      	strb	r3, [r2, #5]
	if (ull_hdr && !ull_ref_get(ull_hdr) && ull_hdr->disabled_cb) {
 1013c2a:	2d00      	cmp	r5, #0
 1013c2c:	d0c8      	beq.n	1013bc0 <ull_done+0x10>
	return hdr->ref;
 1013c2e:	782b      	ldrb	r3, [r5, #0]
 1013c30:	2b00      	cmp	r3, #0
 1013c32:	d1c5      	bne.n	1013bc0 <ull_done+0x10>
 1013c34:	696b      	ldr	r3, [r5, #20]
 1013c36:	2b00      	cmp	r3, #0
 1013c38:	d0c2      	beq.n	1013bc0 <ull_done+0x10>
		ull_hdr->disabled_cb(ull_hdr->disabled_param);
 1013c3a:	69a8      	ldr	r0, [r5, #24]
 1013c3c:	4798      	blx	r3
		link = memq_peek(memq_ull_done.head, memq_ull_done.tail,
 1013c3e:	e9d6 0100 	ldrd	r0, r1, [r6]
 1013c42:	aa01      	add	r2, sp, #4
 1013c44:	f7fd f960 	bl	1010f08 <memq_peek>
		if (link) {
 1013c48:	4604      	mov	r4, r0
 1013c4a:	2800      	cmp	r0, #0
 1013c4c:	d1c0      	bne.n	1013bd0 <ull_done+0x20>
}
 1013c4e:	b003      	add	sp, #12
 1013c50:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	LL_ASSERT(release == done);
 1013c54:	f640 33b7 	movw	r3, #2999	; 0xbb7
 1013c58:	4642      	mov	r2, r8
 1013c5a:	4917      	ldr	r1, [pc, #92]	; (1013cb8 <ull_done+0x108>)
 1013c5c:	4817      	ldr	r0, [pc, #92]	; (1013cbc <ull_done+0x10c>)
 1013c5e:	f010 ffba 	bl	1024bd6 <assert_print>
 1013c62:	4040      	eors	r0, r0
 1013c64:	f380 8811 	msr	BASEPRI, r0
 1013c68:	f04f 0003 	mov.w	r0, #3
 1013c6c:	df02      	svc	2
 1013c6e:	e7dc      	b.n	1013c2a <ull_done+0x7a>
		LL_ASSERT(0);
 1013c70:	f44f 633b 	mov.w	r3, #2992	; 0xbb0
 1013c74:	4642      	mov	r2, r8
 1013c76:	4912      	ldr	r1, [pc, #72]	; (1013cc0 <ull_done+0x110>)
 1013c78:	4810      	ldr	r0, [pc, #64]	; (1013cbc <ull_done+0x10c>)
 1013c7a:	f010 ffac 	bl	1024bd6 <assert_print>
 1013c7e:	4040      	eors	r0, r0
 1013c80:	f380 8811 	msr	BASEPRI, r0
 1013c84:	f04f 0003 	mov.w	r0, #3
 1013c88:	df02      	svc	2
		break;
 1013c8a:	e7b8      	b.n	1013bfe <ull_done+0x4e>
		LL_ASSERT(ull_ref_get(ull_hdr));
 1013c8c:	f640 3359 	movw	r3, #2905	; 0xb59
 1013c90:	4642      	mov	r2, r8
 1013c92:	4649      	mov	r1, r9
 1013c94:	4809      	ldr	r0, [pc, #36]	; (1013cbc <ull_done+0x10c>)
 1013c96:	f010 ff9e 	bl	1024bd6 <assert_print>
 1013c9a:	4040      	eors	r0, r0
 1013c9c:	f380 8811 	msr	BASEPRI, r0
 1013ca0:	f04f 0003 	mov.w	r0, #3
 1013ca4:	df02      	svc	2
 1013ca6:	e79e      	b.n	1013be6 <ull_done+0x36>
 1013ca8:	21004d4c 	.word	0x21004d4c
 1013cac:	0102a558 	.word	0x0102a558
 1013cb0:	0102a59c 	.word	0x0102a59c
 1013cb4:	21000698 	.word	0x21000698
 1013cb8:	0102a5b4 	.word	0x0102a5b4
 1013cbc:	0102a278 	.word	0x0102a278
 1013cc0:	0102a300 	.word	0x0102a300

01013cc4 <rx_demux>:
{
 1013cc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1013cc8:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 1013e78 <rx_demux+0x1b4>
	k_sem_give(sem_recv);
 1013ccc:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 1013e7c <rx_demux+0x1b8>
			LL_ASSERT(rx);
 1013cd0:	f8df b1ac 	ldr.w	fp, [pc, #428]	; 1013e80 <rx_demux+0x1bc>
 1013cd4:	f8df a1ac 	ldr.w	sl, [pc, #428]	; 1013e84 <rx_demux+0x1c0>
{
 1013cd8:	b087      	sub	sp, #28
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
 1013cda:	aa03      	add	r2, sp, #12
 1013cdc:	e9d8 0100 	ldrd	r0, r1, [r8]
 1013ce0:	f7fd f912 	bl	1010f08 <memq_peek>
		if (link) {
 1013ce4:	4605      	mov	r5, r0
 1013ce6:	2800      	cmp	r0, #0
 1013ce8:	d035      	beq.n	1013d56 <rx_demux+0x92>
			LL_ASSERT(rx);
 1013cea:	9b03      	ldr	r3, [sp, #12]
 1013cec:	2b00      	cmp	r3, #0
 1013cee:	f000 80a6 	beq.w	1013e3e <rx_demux+0x17a>
			link_tx = ull_conn_ack_by_last_peek(rx->ack_last,
 1013cf2:	7818      	ldrb	r0, [r3, #0]
 1013cf4:	aa04      	add	r2, sp, #16
 1013cf6:	a902      	add	r1, sp, #8
 1013cf8:	f002 fd74 	bl	10167e4 <ull_conn_ack_by_last_peek>
			if (link_tx) {
 1013cfc:	4604      	mov	r4, r0
 1013cfe:	2800      	cmp	r0, #0
 1013d00:	d055      	beq.n	1013dae <rx_demux+0xea>
				rx_demux_conn_tx_ack(rx->ack_last, handle,
 1013d02:	e9dd 1303 	ldrd	r1, r3, [sp, #12]
 1013d06:	f8bd 2008 	ldrh.w	r2, [sp, #8]
 1013d0a:	780f      	ldrb	r7, [r1, #0]
 1013d0c:	ae05      	add	r6, sp, #20
 1013d0e:	f8ad 200a 	strh.w	r2, [sp, #10]
 1013d12:	9305      	str	r3, [sp, #20]
static inline void rx_demux_conn_tx_ack(uint8_t ack_last, uint16_t handle,
 1013d14:	f10d 050a 	add.w	r5, sp, #10
		ull_conn_ack_dequeue();
 1013d18:	f002 fd7e 	bl	1016818 <ull_conn_ack_dequeue>
		ull_conn_tx_ack(handle, link, node_tx);
 1013d1c:	4621      	mov	r1, r4
 1013d1e:	9a05      	ldr	r2, [sp, #20]
 1013d20:	f8bd 000a 	ldrh.w	r0, [sp, #10]
 1013d24:	f002 fdc0 	bl	10168a8 <ull_conn_tx_ack>
		ull_conn_link_tx_release(link);
 1013d28:	4620      	mov	r0, r4
 1013d2a:	f002 fd33 	bl	1016794 <ull_conn_link_tx_release>
		link = ull_conn_ack_by_last_peek(ack_last, &handle, &node_tx);
 1013d2e:	4632      	mov	r2, r6
 1013d30:	4629      	mov	r1, r5
 1013d32:	4638      	mov	r0, r7
 1013d34:	f002 fd56 	bl	10167e4 <ull_conn_ack_by_last_peek>
	} while (link);
 1013d38:	4604      	mov	r4, r0
 1013d3a:	2800      	cmp	r0, #0
 1013d3c:	d1ec      	bne.n	1013d18 <rx_demux+0x54>
	k_sem_give(sem_recv);
 1013d3e:	f8d9 0000 	ldr.w	r0, [r9]
 1013d42:	f00d fcad 	bl	10216a0 <z_impl_k_sem_give>
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
 1013d46:	e9d8 0100 	ldrd	r0, r1, [r8]
 1013d4a:	aa03      	add	r2, sp, #12
 1013d4c:	f7fd f8dc 	bl	1010f08 <memq_peek>
		if (link) {
 1013d50:	4605      	mov	r5, r0
 1013d52:	2800      	cmp	r0, #0
 1013d54:	d1c9      	bne.n	1013cea <rx_demux+0x26>
			link = ull_conn_ack_peek(&ack_last, &handle, &node_tx);
 1013d56:	aa04      	add	r2, sp, #16
 1013d58:	a902      	add	r1, sp, #8
 1013d5a:	f10d 0007 	add.w	r0, sp, #7
 1013d5e:	f002 fd25 	bl	10167ac <ull_conn_ack_peek>
			if (link) {
 1013d62:	4604      	mov	r4, r0
 1013d64:	2800      	cmp	r0, #0
 1013d66:	d067      	beq.n	1013e38 <rx_demux+0x174>
				rx_demux_conn_tx_ack(ack_last, handle,
 1013d68:	9b04      	ldr	r3, [sp, #16]
 1013d6a:	f89d 7007 	ldrb.w	r7, [sp, #7]
static inline void rx_demux_conn_tx_ack(uint8_t ack_last, uint16_t handle,
 1013d6e:	9305      	str	r3, [sp, #20]
 1013d70:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 1013d74:	ae05      	add	r6, sp, #20
 1013d76:	f8ad 300a 	strh.w	r3, [sp, #10]
 1013d7a:	f10d 050a 	add.w	r5, sp, #10
		ull_conn_ack_dequeue();
 1013d7e:	f002 fd4b 	bl	1016818 <ull_conn_ack_dequeue>
		ull_conn_tx_ack(handle, link, node_tx);
 1013d82:	4621      	mov	r1, r4
 1013d84:	9a05      	ldr	r2, [sp, #20]
 1013d86:	f8bd 000a 	ldrh.w	r0, [sp, #10]
 1013d8a:	f002 fd8d 	bl	10168a8 <ull_conn_tx_ack>
		ull_conn_link_tx_release(link);
 1013d8e:	4620      	mov	r0, r4
 1013d90:	f002 fd00 	bl	1016794 <ull_conn_link_tx_release>
		link = ull_conn_ack_by_last_peek(ack_last, &handle, &node_tx);
 1013d94:	4632      	mov	r2, r6
 1013d96:	4629      	mov	r1, r5
 1013d98:	4638      	mov	r0, r7
 1013d9a:	f002 fd23 	bl	10167e4 <ull_conn_ack_by_last_peek>
	} while (link);
 1013d9e:	4604      	mov	r4, r0
 1013da0:	2800      	cmp	r0, #0
 1013da2:	d1ec      	bne.n	1013d7e <rx_demux+0xba>
	k_sem_give(sem_recv);
 1013da4:	f8d9 0000 	ldr.w	r0, [r9]
 1013da8:	f00d fc7a 	bl	10216a0 <z_impl_k_sem_give>
	} while (link);
 1013dac:	e7cb      	b.n	1013d46 <rx_demux+0x82>
				nack = rx_demux_rx(link, rx);
 1013dae:	9b03      	ldr	r3, [sp, #12]
 1013db0:	9305      	str	r3, [sp, #20]
	switch (rx->type) {
 1013db2:	791b      	ldrb	r3, [r3, #4]
 1013db4:	3b01      	subs	r3, #1
 1013db6:	2b17      	cmp	r3, #23
 1013db8:	d80d      	bhi.n	1013dd6 <rx_demux+0x112>
 1013dba:	e8df f003 	tbb	[pc, r3]
 1013dbe:	0c1a      	.short	0x0c1a
 1013dc0:	0c0c0c38 	.word	0x0c0c0c38
 1013dc4:	0c0c0c0c 	.word	0x0c0c0c0c
 1013dc8:	0c0c0c0c 	.word	0x0c0c0c0c
 1013dcc:	0c0c0c0c 	.word	0x0c0c0c0c
 1013dd0:	0c0c0c0c 	.word	0x0c0c0c0c
 1013dd4:	1a2d      	.short	0x1a2d
		LL_ASSERT(0);
 1013dd6:	f640 3346 	movw	r3, #2886	; 0xb46
 1013dda:	4a29      	ldr	r2, [pc, #164]	; (1013e80 <rx_demux+0x1bc>)
 1013ddc:	492a      	ldr	r1, [pc, #168]	; (1013e88 <rx_demux+0x1c4>)
 1013dde:	482b      	ldr	r0, [pc, #172]	; (1013e8c <rx_demux+0x1c8>)
 1013de0:	f010 fef9 	bl	1024bd6 <assert_print>
 1013de4:	4040      	eors	r0, r0
 1013de6:	f380 8811 	msr	BASEPRI, r0
 1013dea:	f04f 0003 	mov.w	r0, #3
 1013dee:	df02      	svc	2
			if (nack) {
 1013df0:	e773      	b.n	1013cda <rx_demux+0x16>
		(void)memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
 1013df2:	4921      	ldr	r1, [pc, #132]	; (1013e78 <rx_demux+0x1b4>)
 1013df4:	2200      	movs	r2, #0
 1013df6:	f8d8 0004 	ldr.w	r0, [r8, #4]
 1013dfa:	f7fd f88d 	bl	1010f18 <memq_dequeue>
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 1013dfe:	4628      	mov	r0, r5
	rx_hdr->ack_last = mfifo_tx_ack.l;
 1013e00:	4b23      	ldr	r3, [pc, #140]	; (1013e90 <rx_demux+0x1cc>)
		ll_rx_put_sched(link, rx);
 1013e02:	9905      	ldr	r1, [sp, #20]
	rx_hdr->ack_last = mfifo_tx_ack.l;
 1013e04:	795b      	ldrb	r3, [r3, #5]
 1013e06:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 1013e08:	4a22      	ldr	r2, [pc, #136]	; (1013e94 <rx_demux+0x1d0>)
 1013e0a:	f7fd f873 	bl	1010ef4 <memq_enqueue>
	k_sem_give(sem_recv);
 1013e0e:	4b1b      	ldr	r3, [pc, #108]	; (1013e7c <rx_demux+0x1b8>)
 1013e10:	6818      	ldr	r0, [r3, #0]
 1013e12:	f00d fc45 	bl	10216a0 <z_impl_k_sem_give>
			if (nack) {
 1013e16:	e760      	b.n	1013cda <rx_demux+0x16>
		(void)memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
 1013e18:	2200      	movs	r2, #0
 1013e1a:	4917      	ldr	r1, [pc, #92]	; (1013e78 <rx_demux+0x1b4>)
 1013e1c:	f8d8 0004 	ldr.w	r0, [r8, #4]
 1013e20:	f7fd f87a 	bl	1010f18 <memq_dequeue>
		ull_conn_setup(link, rx);
 1013e24:	4628      	mov	r0, r5
 1013e26:	9905      	ldr	r1, [sp, #20]
 1013e28:	f002 f97e 	bl	1016128 <ull_conn_setup>
			if (nack) {
 1013e2c:	e755      	b.n	1013cda <rx_demux+0x16>
		nack = ull_conn_rx(link, (void *)&rx);
 1013e2e:	4628      	mov	r0, r5
 1013e30:	a905      	add	r1, sp, #20
 1013e32:	f002 f9a1 	bl	1016178 <ull_conn_rx>
		if (nack) {
 1013e36:	b188      	cbz	r0, 1013e5c <rx_demux+0x198>
}
 1013e38:	b007      	add	sp, #28
 1013e3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			LL_ASSERT(rx);
 1013e3e:	f640 1398 	movw	r3, #2456	; 0x998
 1013e42:	465a      	mov	r2, fp
 1013e44:	4651      	mov	r1, sl
 1013e46:	4811      	ldr	r0, [pc, #68]	; (1013e8c <rx_demux+0x1c8>)
 1013e48:	f010 fec5 	bl	1024bd6 <assert_print>
 1013e4c:	4040      	eors	r0, r0
 1013e4e:	f380 8811 	msr	BASEPRI, r0
 1013e52:	f04f 0003 	mov.w	r0, #3
 1013e56:	df02      	svc	2
			link_tx = ull_conn_ack_by_last_peek(rx->ack_last,
 1013e58:	9b03      	ldr	r3, [sp, #12]
 1013e5a:	e74a      	b.n	1013cf2 <rx_demux+0x2e>
		(void)memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
 1013e5c:	4602      	mov	r2, r0
 1013e5e:	4906      	ldr	r1, [pc, #24]	; (1013e78 <rx_demux+0x1b4>)
 1013e60:	f8d8 0004 	ldr.w	r0, [r8, #4]
 1013e64:	f7fd f858 	bl	1010f18 <memq_dequeue>
		if (rx) {
 1013e68:	9905      	ldr	r1, [sp, #20]
 1013e6a:	2900      	cmp	r1, #0
 1013e6c:	f43f af35 	beq.w	1013cda <rx_demux+0x16>
	rx_hdr->ack_last = mfifo_tx_ack.l;
 1013e70:	4b07      	ldr	r3, [pc, #28]	; (1013e90 <rx_demux+0x1cc>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 1013e72:	4628      	mov	r0, r5
	rx_hdr->ack_last = mfifo_tx_ack.l;
 1013e74:	795b      	ldrb	r3, [r3, #5]
 1013e76:	e7c6      	b.n	1013e06 <rx_demux+0x142>
 1013e78:	21004d5c 	.word	0x21004d5c
 1013e7c:	210066fc 	.word	0x210066fc
 1013e80:	0102a558 	.word	0x0102a558
 1013e84:	0102a5c4 	.word	0x0102a5c4
 1013e88:	0102a300 	.word	0x0102a300
 1013e8c:	0102a278 	.word	0x0102a278
 1013e90:	21000520 	.word	0x21000520
 1013e94:	21004d58 	.word	0x21004d58

01013e98 <ll_rx_get>:
{
 1013e98:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1013e9c:	4680      	mov	r8, r0
 1013e9e:	4689      	mov	r9, r1
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
 1013ea0:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 1013f6c <ll_rx_get+0xd4>
 1013ea4:	4f32      	ldr	r7, [pc, #200]	; (1013f70 <ll_rx_get+0xd8>)
{
 1013ea6:	b082      	sub	sp, #8
			f = mfifo_tx_ack.f;
 1013ea8:	f1aa 0504 	sub.w	r5, sl, #4
	*node_rx = NULL;
 1013eac:	2300      	movs	r3, #0
 1013eae:	f8c8 3000 	str.w	r3, [r8]
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
 1013eb2:	aa01      	add	r2, sp, #4
 1013eb4:	e9d7 0100 	ldrd	r0, r1, [r7]
 1013eb8:	f7fd f826 	bl	1010f08 <memq_peek>
	if (link) {
 1013ebc:	4606      	mov	r6, r0
 1013ebe:	2800      	cmp	r0, #0
 1013ec0:	d042      	beq.n	1013f48 <ll_rx_get+0xb0>
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
 1013ec2:	9b01      	ldr	r3, [sp, #4]
 1013ec4:	4651      	mov	r1, sl
 1013ec6:	781a      	ldrb	r2, [r3, #0]
 1013ec8:	4648      	mov	r0, r9
 1013eca:	f7ff fd91 	bl	10139f0 <tx_cmplt_get>
		if (!cmplt) {
 1013ece:	4603      	mov	r3, r0
 1013ed0:	2800      	cmp	r0, #0
 1013ed2:	d140      	bne.n	1013f56 <ll_rx_get+0xbe>
			f = mfifo_tx_ack.f;
 1013ed4:	792a      	ldrb	r2, [r5, #4]
 1013ed6:	f88d 2001 	strb.w	r2, [sp, #1]
				cmplt_curr = tx_cmplt_get(&h, &f,
 1013eda:	796a      	ldrb	r2, [r5, #5]
 1013edc:	f10d 0101 	add.w	r1, sp, #1
 1013ee0:	f10d 0002 	add.w	r0, sp, #2
 1013ee4:	461c      	mov	r4, r3
 1013ee6:	f7ff fd83 	bl	10139f0 <tx_cmplt_get>
 1013eea:	ea44 0200 	orr.w	r2, r4, r0
			} while ((cmplt_prev != 0U) ||
 1013eee:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
				cmplt_curr = tx_cmplt_get(&h, &f,
 1013ef2:	4603      	mov	r3, r0
			} while ((cmplt_prev != 0U) ||
 1013ef4:	d1f1      	bne.n	1013eda <ll_rx_get+0x42>
			} else if (rx->type == NODE_RX_TYPE_RELEASE) {
 1013ef6:	9901      	ldr	r1, [sp, #4]
 1013ef8:	790b      	ldrb	r3, [r1, #4]
 1013efa:	2b01      	cmp	r3, #1
 1013efc:	d12f      	bne.n	1013f5e <ll_rx_get+0xc6>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
 1013efe:	4c1d      	ldr	r4, [pc, #116]	; (1013f74 <ll_rx_get+0xdc>)
	(void)memq_dequeue(memq_ll_rx.tail,
 1013f00:	4639      	mov	r1, r7
 1013f02:	6878      	ldr	r0, [r7, #4]
 1013f04:	f7fd f808 	bl	1010f18 <memq_dequeue>
	mem_release(link, &mem_link_rx.free);
 1013f08:	4630      	mov	r0, r6
 1013f0a:	1d21      	adds	r1, r4, #4
 1013f0c:	f7fc ffa8 	bl	1010e60 <mem_release>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
 1013f10:	8823      	ldrh	r3, [r4, #0]
 1013f12:	2b13      	cmp	r3, #19
 1013f14:	d809      	bhi.n	1013f2a <ll_rx_get+0x92>
	mem_release(node_rx, &mem_pdu_rx.free);
 1013f16:	9801      	ldr	r0, [sp, #4]
	mem_link_rx.quota_pdu += delta;
 1013f18:	3301      	adds	r3, #1
	mem_release(node_rx, &mem_pdu_rx.free);
 1013f1a:	4917      	ldr	r1, [pc, #92]	; (1013f78 <ll_rx_get+0xe0>)
	mem_link_rx.quota_pdu += delta;
 1013f1c:	8023      	strh	r3, [r4, #0]
	mem_release(node_rx, &mem_pdu_rx.free);
 1013f1e:	f7fc ff9f 	bl	1010e60 <mem_release>
	rx_replenish(1U);
 1013f22:	2001      	movs	r0, #1
 1013f24:	f7ff fdc0 	bl	1013aa8 <rx_replenish>
				goto ll_rx_get_again;
 1013f28:	e7c0      	b.n	1013eac <ll_rx_get+0x14>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
 1013f2a:	f240 638b 	movw	r3, #1675	; 0x68b
 1013f2e:	4a13      	ldr	r2, [pc, #76]	; (1013f7c <ll_rx_get+0xe4>)
 1013f30:	4913      	ldr	r1, [pc, #76]	; (1013f80 <ll_rx_get+0xe8>)
 1013f32:	4814      	ldr	r0, [pc, #80]	; (1013f84 <ll_rx_get+0xec>)
 1013f34:	f010 fe4f 	bl	1024bd6 <assert_print>
 1013f38:	4040      	eors	r0, r0
 1013f3a:	f380 8811 	msr	BASEPRI, r0
 1013f3e:	f04f 0003 	mov.w	r0, #3
 1013f42:	df02      	svc	2
	mem_link_rx.quota_pdu += delta;
 1013f44:	8823      	ldrh	r3, [r4, #0]
 1013f46:	e7e6      	b.n	1013f16 <ll_rx_get+0x7e>
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, mfifo_tx_ack.l);
 1013f48:	490f      	ldr	r1, [pc, #60]	; (1013f88 <ll_rx_get+0xf0>)
 1013f4a:	4648      	mov	r0, r9
 1013f4c:	794a      	ldrb	r2, [r1, #5]
 1013f4e:	3104      	adds	r1, #4
 1013f50:	f7ff fd4e 	bl	10139f0 <tx_cmplt_get>
 1013f54:	4603      	mov	r3, r0
}
 1013f56:	4618      	mov	r0, r3
 1013f58:	b002      	add	sp, #8
 1013f5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
 1013f5e:	4613      	mov	r3, r2
}
 1013f60:	4618      	mov	r0, r3
			*node_rx = rx;
 1013f62:	f8c8 1000 	str.w	r1, [r8]
}
 1013f66:	b002      	add	sp, #8
 1013f68:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1013f6c:	21000524 	.word	0x21000524
 1013f70:	21004d54 	.word	0x21004d54
 1013f74:	21004d64 	.word	0x21004d64
 1013f78:	21004e64 	.word	0x21004e64
 1013f7c:	0102a558 	.word	0x0102a558
 1013f80:	0102a5c8 	.word	0x0102a5c8
 1013f84:	0102a278 	.word	0x0102a278
 1013f88:	21000520 	.word	0x21000520

01013f8c <ll_rx_dequeue>:
	struct node_rx_hdr *rx = NULL;
 1013f8c:	2300      	movs	r3, #0
{
 1013f8e:	b570      	push	{r4, r5, r6, lr}
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
 1013f90:	4953      	ldr	r1, [pc, #332]	; (10140e0 <ll_rx_dequeue+0x154>)
{
 1013f92:	b082      	sub	sp, #8
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
 1013f94:	6848      	ldr	r0, [r1, #4]
 1013f96:	aa01      	add	r2, sp, #4
	struct node_rx_hdr *rx = NULL;
 1013f98:	9301      	str	r3, [sp, #4]
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
 1013f9a:	f7fc ffbd 	bl	1010f18 <memq_dequeue>
	LL_ASSERT(link);
 1013f9e:	4604      	mov	r4, r0
 1013fa0:	2800      	cmp	r0, #0
 1013fa2:	d051      	beq.n	1014048 <ll_rx_dequeue+0xbc>
	mem_release(link, &mem_link_rx.free);
 1013fa4:	4620      	mov	r0, r4
 1013fa6:	494f      	ldr	r1, [pc, #316]	; (10140e4 <ll_rx_dequeue+0x158>)
 1013fa8:	f7fc ff5a 	bl	1010e60 <mem_release>
	switch (rx->type) {
 1013fac:	9a01      	ldr	r2, [sp, #4]
 1013fae:	7913      	ldrb	r3, [r2, #4]
 1013fb0:	2b1d      	cmp	r3, #29
 1013fb2:	d810      	bhi.n	1013fd6 <ll_rx_dequeue+0x4a>
 1013fb4:	e8df f003 	tbb	[pc, r3]
 1013fb8:	1e0f0f1e 	.word	0x1e0f0f1e
 1013fbc:	0f0f0f0f 	.word	0x0f0f0f0f
 1013fc0:	0f0f0f0f 	.word	0x0f0f0f0f
 1013fc4:	0f0f0f0f 	.word	0x0f0f0f0f
 1013fc8:	0f0f0f0f 	.word	0x0f0f0f0f
 1013fcc:	2f0f0f0f 	.word	0x2f0f0f0f
 1013fd0:	1e1e1e1e 	.word	0x1e1e1e1e
 1013fd4:	1e1e      	.short	0x1e1e
		LL_ASSERT(0);
 1013fd6:	f240 5343 	movw	r3, #1347	; 0x543
 1013fda:	4a43      	ldr	r2, [pc, #268]	; (10140e8 <ll_rx_dequeue+0x15c>)
 1013fdc:	4943      	ldr	r1, [pc, #268]	; (10140ec <ll_rx_dequeue+0x160>)
 1013fde:	4844      	ldr	r0, [pc, #272]	; (10140f0 <ll_rx_dequeue+0x164>)
 1013fe0:	f010 fdf9 	bl	1024bd6 <assert_print>
 1013fe4:	4040      	eors	r0, r0
 1013fe6:	f380 8811 	msr	BASEPRI, r0
 1013fea:	f04f 0003 	mov.w	r0, #3
 1013fee:	df02      	svc	2
}
 1013ff0:	b002      	add	sp, #8
 1013ff2:	bd70      	pop	{r4, r5, r6, pc}
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
 1013ff4:	2b00      	cmp	r3, #0
 1013ff6:	d1fb      	bne.n	1013ff0 <ll_rx_dequeue+0x64>
 1013ff8:	f240 533f 	movw	r3, #1343	; 0x53f
 1013ffc:	4a3a      	ldr	r2, [pc, #232]	; (10140e8 <ll_rx_dequeue+0x15c>)
 1013ffe:	493d      	ldr	r1, [pc, #244]	; (10140f4 <ll_rx_dequeue+0x168>)
 1014000:	483b      	ldr	r0, [pc, #236]	; (10140f0 <ll_rx_dequeue+0x164>)
 1014002:	f010 fde8 	bl	1024bd6 <assert_print>
 1014006:	4040      	eors	r0, r0
 1014008:	f380 8811 	msr	BASEPRI, r0
 101400c:	f04f 0003 	mov.w	r0, #3
 1014010:	df02      	svc	2
}
 1014012:	b002      	add	sp, #8
 1014014:	bd70      	pop	{r4, r5, r6, pc}
		} else if ((cc->status == BT_HCI_ERR_ADV_TIMEOUT) || cc->role) {
 1014016:	7f13      	ldrb	r3, [r2, #28]
 1014018:	2b3c      	cmp	r3, #60	; 0x3c
 101401a:	d023      	beq.n	1014064 <ll_rx_dequeue+0xd8>
 101401c:	7f53      	ldrb	r3, [r2, #29]
 101401e:	b183      	cbz	r3, 1014042 <ll_rx_dequeue+0xb6>
			adv = HDR_LLL2ULL(lll);
 1014020:	6893      	ldr	r3, [r2, #8]
 1014022:	681c      	ldr	r4, [r3, #0]
				if (adv->node_rx_cc_free) {
 1014024:	6e60      	ldr	r0, [r4, #100]	; 0x64
 1014026:	b120      	cbz	r0, 1014032 <ll_rx_dequeue+0xa6>
					adv->node_rx_cc_free = NULL;
 1014028:	2300      	movs	r3, #0
	mem_release(node_rx, &mem_pdu_rx.free);
 101402a:	4933      	ldr	r1, [pc, #204]	; (10140f8 <ll_rx_dequeue+0x16c>)
					adv->node_rx_cc_free = NULL;
 101402c:	6663      	str	r3, [r4, #100]	; 0x64
	mem_release(node_rx, &mem_pdu_rx.free);
 101402e:	f7fc ff17 	bl	1010e60 <mem_release>
			adv->is_enabled = 0U;
 1014032:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
 1014036:	f36f 0300 	bfc	r3, #0, #1
 101403a:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a
}
 101403e:	b002      	add	sp, #8
 1014040:	bd70      	pop	{r4, r5, r6, pc}
			LL_ASSERT(0);
 1014042:	f44f 6399 	mov.w	r3, #1224	; 0x4c8
 1014046:	e7c8      	b.n	1013fda <ll_rx_dequeue+0x4e>
	LL_ASSERT(link);
 1014048:	f240 430b 	movw	r3, #1035	; 0x40b
 101404c:	4a26      	ldr	r2, [pc, #152]	; (10140e8 <ll_rx_dequeue+0x15c>)
 101404e:	492b      	ldr	r1, [pc, #172]	; (10140fc <ll_rx_dequeue+0x170>)
 1014050:	4827      	ldr	r0, [pc, #156]	; (10140f0 <ll_rx_dequeue+0x164>)
 1014052:	f010 fdc0 	bl	1024bd6 <assert_print>
 1014056:	4040      	eors	r0, r0
 1014058:	f380 8811 	msr	BASEPRI, r0
 101405c:	f04f 0003 	mov.w	r0, #3
 1014060:	df02      	svc	2
 1014062:	e79f      	b.n	1013fa4 <ll_rx_dequeue+0x18>
			lll = ftr->param;
 1014064:	6896      	ldr	r6, [r2, #8]
			adv = HDR_LLL2ULL(lll);
 1014066:	e9d6 4500 	ldrd	r4, r5, [r6]
				LL_ASSERT(conn_lll);
 101406a:	b1ed      	cbz	r5, 10140a8 <ll_rx_dequeue+0x11c>
				lll->conn = NULL;
 101406c:	2300      	movs	r3, #0
 101406e:	6073      	str	r3, [r6, #4]
				LL_ASSERT(!conn_lll->link_tx_free);
 1014070:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 1014072:	b163      	cbz	r3, 101408e <ll_rx_dequeue+0x102>
 1014074:	f240 4384 	movw	r3, #1156	; 0x484
 1014078:	4a1b      	ldr	r2, [pc, #108]	; (10140e8 <ll_rx_dequeue+0x15c>)
 101407a:	4921      	ldr	r1, [pc, #132]	; (1014100 <ll_rx_dequeue+0x174>)
 101407c:	481c      	ldr	r0, [pc, #112]	; (10140f0 <ll_rx_dequeue+0x164>)
 101407e:	f010 fdaa 	bl	1024bd6 <assert_print>
 1014082:	4040      	eors	r0, r0
 1014084:	f380 8811 	msr	BASEPRI, r0
 1014088:	f04f 0003 	mov.w	r0, #3
 101408c:	df02      	svc	2
				link = memq_deinit(&conn_lll->memq_tx.head,
 101408e:	f105 0160 	add.w	r1, r5, #96	; 0x60
 1014092:	f105 005c 	add.w	r0, r5, #92	; 0x5c
 1014096:	f7fc ff23 	bl	1010ee0 <memq_deinit>
				LL_ASSERT(link);
 101409a:	4606      	mov	r6, r0
 101409c:	b190      	cbz	r0, 10140c4 <ll_rx_dequeue+0x138>
				ll_conn_release(conn);
 101409e:	6828      	ldr	r0, [r5, #0]
				conn_lll->link_tx_free = link;
 10140a0:	66ee      	str	r6, [r5, #108]	; 0x6c
				ll_conn_release(conn);
 10140a2:	f001 fd39 	bl	1015b18 <ll_conn_release>
 10140a6:	e7c4      	b.n	1014032 <ll_rx_dequeue+0xa6>
				LL_ASSERT(conn_lll);
 10140a8:	f240 4381 	movw	r3, #1153	; 0x481
 10140ac:	4a0e      	ldr	r2, [pc, #56]	; (10140e8 <ll_rx_dequeue+0x15c>)
 10140ae:	4915      	ldr	r1, [pc, #84]	; (1014104 <ll_rx_dequeue+0x178>)
 10140b0:	480f      	ldr	r0, [pc, #60]	; (10140f0 <ll_rx_dequeue+0x164>)
 10140b2:	f010 fd90 	bl	1024bd6 <assert_print>
 10140b6:	4040      	eors	r0, r0
 10140b8:	f380 8811 	msr	BASEPRI, r0
 10140bc:	f04f 0003 	mov.w	r0, #3
 10140c0:	df02      	svc	2
 10140c2:	e7d3      	b.n	101406c <ll_rx_dequeue+0xe0>
				LL_ASSERT(link);
 10140c4:	f240 4387 	movw	r3, #1159	; 0x487
 10140c8:	4a07      	ldr	r2, [pc, #28]	; (10140e8 <ll_rx_dequeue+0x15c>)
 10140ca:	490c      	ldr	r1, [pc, #48]	; (10140fc <ll_rx_dequeue+0x170>)
 10140cc:	4808      	ldr	r0, [pc, #32]	; (10140f0 <ll_rx_dequeue+0x164>)
 10140ce:	f010 fd82 	bl	1024bd6 <assert_print>
 10140d2:	4040      	eors	r0, r0
 10140d4:	f380 8811 	msr	BASEPRI, r0
 10140d8:	f04f 0003 	mov.w	r0, #3
 10140dc:	df02      	svc	2
 10140de:	e7de      	b.n	101409e <ll_rx_dequeue+0x112>
 10140e0:	21004d54 	.word	0x21004d54
 10140e4:	21004d68 	.word	0x21004d68
 10140e8:	0102a558 	.word	0x0102a558
 10140ec:	0102a300 	.word	0x0102a300
 10140f0:	0102a278 	.word	0x0102a278
 10140f4:	0102a62c 	.word	0x0102a62c
 10140f8:	21004e64 	.word	0x21004e64
 10140fc:	0102a92c 	.word	0x0102a92c
 1014100:	0102a614 	.word	0x0102a614
 1014104:	0102a608 	.word	0x0102a608

01014108 <ll_rx_mem_release>:
{
 1014108:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx = *node_rx;
 101410c:	6804      	ldr	r4, [r0, #0]
{
 101410e:	4680      	mov	r8, r0
	while (rx) {
 1014110:	b344      	cbz	r4, 1014164 <ll_rx_mem_release+0x5c>
			LL_ASSERT(0);
 1014112:	4f57      	ldr	r7, [pc, #348]	; (1014270 <ll_rx_mem_release+0x168>)
 1014114:	f8df 915c 	ldr.w	r9, [pc, #348]	; 1014274 <ll_rx_mem_release+0x16c>
 1014118:	4e57      	ldr	r6, [pc, #348]	; (1014278 <ll_rx_mem_release+0x170>)
		rx = rx->next;
 101411a:	4625      	mov	r5, r4
		switch (rx_free->type) {
 101411c:	792b      	ldrb	r3, [r5, #4]
		rx = rx->next;
 101411e:	6824      	ldr	r4, [r4, #0]
		switch (rx_free->type) {
 1014120:	2b1d      	cmp	r3, #29
 1014122:	d810      	bhi.n	1014146 <ll_rx_mem_release+0x3e>
 1014124:	e8df f003 	tbb	[pc, r3]
 1014128:	380f0f38 	.word	0x380f0f38
 101412c:	0f0f0f0f 	.word	0x0f0f0f0f
 1014130:	0f0f0f0f 	.word	0x0f0f0f0f
 1014134:	0f0f0f0f 	.word	0x0f0f0f0f
 1014138:	0f0f0f0f 	.word	0x0f0f0f0f
 101413c:	260f0f0f 	.word	0x260f0f0f
 1014140:	38383856 	.word	0x38383856
 1014144:	3838      	.short	0x3838
			LL_ASSERT(0);
 1014146:	f240 637f 	movw	r3, #1663	; 0x67f
 101414a:	463a      	mov	r2, r7
 101414c:	4649      	mov	r1, r9
 101414e:	4630      	mov	r0, r6
 1014150:	f010 fd41 	bl	1024bd6 <assert_print>
 1014154:	4040      	eors	r0, r0
 1014156:	f380 8811 	msr	BASEPRI, r0
 101415a:	f04f 0003 	mov.w	r0, #3
 101415e:	df02      	svc	2
	while (rx) {
 1014160:	2c00      	cmp	r4, #0
 1014162:	d1da      	bne.n	101411a <ll_rx_mem_release+0x12>
	*node_rx = rx;
 1014164:	2300      	movs	r3, #0
 1014166:	f8c8 3000 	str.w	r3, [r8]
	rx_replenish(UINT8_MAX);
 101416a:	20ff      	movs	r0, #255	; 0xff
}
 101416c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx_replenish(UINT8_MAX);
 1014170:	f7ff bc9a 	b.w	1013aa8 <rx_replenish>
			} else if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
 1014174:	7f2b      	ldrb	r3, [r5, #28]
 1014176:	2b3c      	cmp	r3, #60	; 0x3c
 1014178:	d063      	beq.n	1014242 <ll_rx_mem_release+0x13a>
				LL_ASSERT(!cc->status);
 101417a:	b1db      	cbz	r3, 10141b4 <ll_rx_mem_release+0xac>
 101417c:	f240 53a7 	movw	r3, #1447	; 0x5a7
 1014180:	4a3b      	ldr	r2, [pc, #236]	; (1014270 <ll_rx_mem_release+0x168>)
 1014182:	493e      	ldr	r1, [pc, #248]	; (101427c <ll_rx_mem_release+0x174>)
 1014184:	483c      	ldr	r0, [pc, #240]	; (1014278 <ll_rx_mem_release+0x170>)
 1014186:	f010 fd26 	bl	1024bd6 <assert_print>
 101418a:	4040      	eors	r0, r0
 101418c:	f380 8811 	msr	BASEPRI, r0
 1014190:	f04f 0003 	mov.w	r0, #3
 1014194:	df02      	svc	2
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
 1014196:	792b      	ldrb	r3, [r5, #4]
 1014198:	b963      	cbnz	r3, 10141b4 <ll_rx_mem_release+0xac>
 101419a:	f240 53fd 	movw	r3, #1533	; 0x5fd
 101419e:	463a      	mov	r2, r7
 10141a0:	4630      	mov	r0, r6
 10141a2:	4937      	ldr	r1, [pc, #220]	; (1014280 <ll_rx_mem_release+0x178>)
 10141a4:	f010 fd17 	bl	1024bd6 <assert_print>
 10141a8:	4040      	eors	r0, r0
 10141aa:	f380 8811 	msr	BASEPRI, r0
 10141ae:	f04f 0003 	mov.w	r0, #3
 10141b2:	df02      	svc	2
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
 10141b4:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 1014284 <ll_rx_mem_release+0x17c>
 10141b8:	f8ba 3000 	ldrh.w	r3, [sl]
 10141bc:	2b13      	cmp	r3, #19
 10141be:	d830      	bhi.n	1014222 <ll_rx_mem_release+0x11a>
	mem_link_rx.quota_pdu += delta;
 10141c0:	3301      	adds	r3, #1
	mem_release(node_rx, &mem_pdu_rx.free);
 10141c2:	4628      	mov	r0, r5
 10141c4:	4930      	ldr	r1, [pc, #192]	; (1014288 <ll_rx_mem_release+0x180>)
	mem_link_rx.quota_pdu += delta;
 10141c6:	f8aa 3000 	strh.w	r3, [sl]
	mem_release(node_rx, &mem_pdu_rx.free);
 10141ca:	f7fc fe49 	bl	1010e60 <mem_release>
	while (rx) {
 10141ce:	2c00      	cmp	r4, #0
 10141d0:	d1a3      	bne.n	101411a <ll_rx_mem_release+0x12>
 10141d2:	e7c7      	b.n	1014164 <ll_rx_mem_release+0x5c>
			if (IS_ACL_HANDLE(rx_free->handle)) {
 10141d4:	88e8      	ldrh	r0, [r5, #6]
 10141d6:	2807      	cmp	r0, #7
 10141d8:	d8c2      	bhi.n	1014160 <ll_rx_mem_release+0x58>
				conn = ll_conn_get(rx_free->handle);
 10141da:	f001 fcab 	bl	1015b34 <ll_conn_get>
				LL_ASSERT(!conn->lll.link_tx_free);
 10141de:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
				conn = ll_conn_get(rx_free->handle);
 10141e2:	4605      	mov	r5, r0
				LL_ASSERT(!conn->lll.link_tx_free);
 10141e4:	b163      	cbz	r3, 1014200 <ll_rx_mem_release+0xf8>
 10141e6:	f240 636e 	movw	r3, #1646	; 0x66e
 10141ea:	4a21      	ldr	r2, [pc, #132]	; (1014270 <ll_rx_mem_release+0x168>)
 10141ec:	4927      	ldr	r1, [pc, #156]	; (101428c <ll_rx_mem_release+0x184>)
 10141ee:	4822      	ldr	r0, [pc, #136]	; (1014278 <ll_rx_mem_release+0x170>)
 10141f0:	f010 fcf1 	bl	1024bd6 <assert_print>
 10141f4:	4040      	eors	r0, r0
 10141f6:	f380 8811 	msr	BASEPRI, r0
 10141fa:	f04f 0003 	mov.w	r0, #3
 10141fe:	df02      	svc	2
				link = memq_deinit(&conn->lll.memq_tx.head,
 1014200:	f105 017c 	add.w	r1, r5, #124	; 0x7c
 1014204:	f105 0078 	add.w	r0, r5, #120	; 0x78
 1014208:	f7fc fe6a 	bl	1010ee0 <memq_deinit>
				LL_ASSERT(link);
 101420c:	4682      	mov	sl, r0
 101420e:	b300      	cbz	r0, 1014252 <ll_rx_mem_release+0x14a>
				ll_conn_release(conn);
 1014210:	4628      	mov	r0, r5
				conn->lll.link_tx_free = link;
 1014212:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
				ll_conn_release(conn);
 1014216:	f001 fc7f 	bl	1015b18 <ll_conn_release>
	while (rx) {
 101421a:	2c00      	cmp	r4, #0
 101421c:	f47f af7d 	bne.w	101411a <ll_rx_mem_release+0x12>
 1014220:	e7a0      	b.n	1014164 <ll_rx_mem_release+0x5c>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
 1014222:	f240 638b 	movw	r3, #1675	; 0x68b
 1014226:	463a      	mov	r2, r7
 1014228:	4630      	mov	r0, r6
 101422a:	4919      	ldr	r1, [pc, #100]	; (1014290 <ll_rx_mem_release+0x188>)
 101422c:	f010 fcd3 	bl	1024bd6 <assert_print>
 1014230:	4040      	eors	r0, r0
 1014232:	f380 8811 	msr	BASEPRI, r0
 1014236:	f04f 0003 	mov.w	r0, #3
 101423a:	df02      	svc	2
	mem_link_rx.quota_pdu += delta;
 101423c:	f8ba 3000 	ldrh.w	r3, [sl]
 1014240:	e7be      	b.n	10141c0 <ll_rx_mem_release+0xb8>
	mem_release(node_rx, &mem_pdu_rx.free);
 1014242:	4628      	mov	r0, r5
 1014244:	4910      	ldr	r1, [pc, #64]	; (1014288 <ll_rx_mem_release+0x180>)
 1014246:	f7fc fe0b 	bl	1010e60 <mem_release>
	while (rx) {
 101424a:	2c00      	cmp	r4, #0
 101424c:	f47f af65 	bne.w	101411a <ll_rx_mem_release+0x12>
 1014250:	e788      	b.n	1014164 <ll_rx_mem_release+0x5c>
				LL_ASSERT(link);
 1014252:	f240 6371 	movw	r3, #1649	; 0x671
 1014256:	4a06      	ldr	r2, [pc, #24]	; (1014270 <ll_rx_mem_release+0x168>)
 1014258:	490e      	ldr	r1, [pc, #56]	; (1014294 <ll_rx_mem_release+0x18c>)
 101425a:	4807      	ldr	r0, [pc, #28]	; (1014278 <ll_rx_mem_release+0x170>)
 101425c:	f010 fcbb 	bl	1024bd6 <assert_print>
 1014260:	4040      	eors	r0, r0
 1014262:	f380 8811 	msr	BASEPRI, r0
 1014266:	f04f 0003 	mov.w	r0, #3
 101426a:	df02      	svc	2
 101426c:	e7d0      	b.n	1014210 <ll_rx_mem_release+0x108>
 101426e:	bf00      	nop
 1014270:	0102a558 	.word	0x0102a558
 1014274:	0102a300 	.word	0x0102a300
 1014278:	0102a278 	.word	0x0102a278
 101427c:	0102a64c 	.word	0x0102a64c
 1014280:	0102a658 	.word	0x0102a658
 1014284:	21004d64 	.word	0x21004d64
 1014288:	21004e64 	.word	0x21004e64
 101428c:	0102a67c 	.word	0x0102a67c
 1014290:	0102a5c8 	.word	0x0102a5c8
 1014294:	0102a92c 	.word	0x0102a92c

01014298 <ll_rx_link_alloc>:
	return mem_acquire(&mem_link_rx.free);
 1014298:	4801      	ldr	r0, [pc, #4]	; (10142a0 <ll_rx_link_alloc+0x8>)
 101429a:	f7fc bdc5 	b.w	1010e28 <mem_acquire>
 101429e:	bf00      	nop
 10142a0:	21004d68 	.word	0x21004d68

010142a4 <ll_rx_link_release>:
	mem_release(link, &mem_link_rx.free);
 10142a4:	4901      	ldr	r1, [pc, #4]	; (10142ac <ll_rx_link_release+0x8>)
 10142a6:	f7fc bddb 	b.w	1010e60 <mem_release>
 10142aa:	bf00      	nop
 10142ac:	21004d68 	.word	0x21004d68

010142b0 <ll_rx_alloc>:
	return mem_acquire(&mem_pdu_rx.free);
 10142b0:	4801      	ldr	r0, [pc, #4]	; (10142b8 <ll_rx_alloc+0x8>)
 10142b2:	f7fc bdb9 	b.w	1010e28 <mem_acquire>
 10142b6:	bf00      	nop
 10142b8:	21004e64 	.word	0x21004e64

010142bc <ll_rx_release>:
	mem_release(node_rx, &mem_pdu_rx.free);
 10142bc:	4901      	ldr	r1, [pc, #4]	; (10142c4 <ll_rx_release+0x8>)
 10142be:	f7fc bdcf 	b.w	1010e60 <mem_release>
 10142c2:	bf00      	nop
 10142c4:	21004e64 	.word	0x21004e64

010142c8 <ll_rx_put>:
	rx_hdr->ack_last = mfifo_tx_ack.l;
 10142c8:	4b02      	ldr	r3, [pc, #8]	; (10142d4 <ll_rx_put+0xc>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 10142ca:	4a03      	ldr	r2, [pc, #12]	; (10142d8 <ll_rx_put+0x10>)
	rx_hdr->ack_last = mfifo_tx_ack.l;
 10142cc:	795b      	ldrb	r3, [r3, #5]
 10142ce:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 10142d0:	f7fc be10 	b.w	1010ef4 <memq_enqueue>
 10142d4:	21000520 	.word	0x21000520
 10142d8:	21004d58 	.word	0x21004d58

010142dc <ll_rx_put_sched>:
{
 10142dc:	b508      	push	{r3, lr}
	rx_hdr->ack_last = mfifo_tx_ack.l;
 10142de:	4b06      	ldr	r3, [pc, #24]	; (10142f8 <ll_rx_put_sched+0x1c>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 10142e0:	4a06      	ldr	r2, [pc, #24]	; (10142fc <ll_rx_put_sched+0x20>)
	rx_hdr->ack_last = mfifo_tx_ack.l;
 10142e2:	795b      	ldrb	r3, [r3, #5]
 10142e4:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 10142e6:	f7fc fe05 	bl	1010ef4 <memq_enqueue>
	k_sem_give(sem_recv);
 10142ea:	4b05      	ldr	r3, [pc, #20]	; (1014300 <ll_rx_put_sched+0x24>)
 10142ec:	6818      	ldr	r0, [r3, #0]
}
 10142ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 10142f2:	f00d b9d5 	b.w	10216a0 <z_impl_k_sem_give>
 10142f6:	bf00      	nop
 10142f8:	21000520 	.word	0x21000520
 10142fc:	21004d58 	.word	0x21004d58
 1014300:	210066fc 	.word	0x210066fc

01014304 <ll_pdu_rx_alloc_peek>:
	if (count > MFIFO_AVAIL_COUNT_GET(ll_pdu_rx_free)) {
 1014304:	490e      	ldr	r1, [pc, #56]	; (1014340 <ll_pdu_rx_alloc_peek+0x3c>)
 1014306:	790b      	ldrb	r3, [r1, #4]
 1014308:	794a      	ldrb	r2, [r1, #5]
	if (last >= first) {
 101430a:	4293      	cmp	r3, r2
 101430c:	d80d      	bhi.n	101432a <ll_pdu_rx_alloc_peek+0x26>
		return last - first;
 101430e:	eba2 0c03 	sub.w	ip, r2, r3
 1014312:	fa5f fc8c 	uxtb.w	ip, ip
 1014316:	4560      	cmp	r0, ip
 1014318:	d80f      	bhi.n	101433a <ll_pdu_rx_alloc_peek+0x36>
	if (first == last) {
 101431a:	4293      	cmp	r3, r2
 101431c:	d00d      	beq.n	101433a <ll_pdu_rx_alloc_peek+0x36>
	return MFIFO_DEQUEUE_PEEK(ll_pdu_rx_free);
 101431e:	780a      	ldrb	r2, [r1, #0]
	return *((void **)(fifo + first * size));
 1014320:	fb02 f303 	mul.w	r3, r2, r3
 1014324:	4a07      	ldr	r2, [pc, #28]	; (1014344 <ll_pdu_rx_alloc_peek+0x40>)
 1014326:	58d0      	ldr	r0, [r2, r3]
 1014328:	4770      	bx	lr
	if (count > MFIFO_AVAIL_COUNT_GET(ll_pdu_rx_free)) {
 101432a:	f8b1 c002 	ldrh.w	ip, [r1, #2]
		return count - first + last;
 101432e:	ebac 0c03 	sub.w	ip, ip, r3
 1014332:	4462      	add	r2, ip
 1014334:	b2d2      	uxtb	r2, r2
 1014336:	4290      	cmp	r0, r2
 1014338:	d9f1      	bls.n	101431e <ll_pdu_rx_alloc_peek+0x1a>
		return NULL;
 101433a:	2000      	movs	r0, #0
}
 101433c:	4770      	bx	lr
 101433e:	bf00      	nop
 1014340:	21000548 	.word	0x21000548
 1014344:	21000550 	.word	0x21000550

01014348 <ll_pdu_rx_alloc>:
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
 1014348:	4b09      	ldr	r3, [pc, #36]	; (1014370 <ll_pdu_rx_alloc+0x28>)
 * @return              Head buffer; or NULL if queue was empty
 */
static inline void *mfifo_dequeue(uint8_t *fifo, uint8_t size, uint8_t count,
				  uint8_t last, uint8_t *first)
{
	uint8_t _first = *first; /* Copy read-index */
 101434a:	7919      	ldrb	r1, [r3, #4]
	void *mem;

	/* Queue is empty if first == last */
	if (_first == last) {
 101434c:	795a      	ldrb	r2, [r3, #5]
 101434e:	7818      	ldrb	r0, [r3, #0]
 1014350:	428a      	cmp	r2, r1
 1014352:	f893 c002 	ldrb.w	ip, [r3, #2]
 1014356:	d009      	beq.n	101436c <ll_pdu_rx_alloc+0x24>
	 * API 2: fifo is array of void-ptrs
	 */
	mem = *((void **)(fifo + _first * size));

	/* Circular buffer increment read-index modulo 'count' */
	_first += 1U;
 1014358:	1c4a      	adds	r2, r1, #1
 101435a:	b2d2      	uxtb	r2, r2
	if (_first == count) {
		_first = 0U;
 101435c:	4594      	cmp	ip, r2
 101435e:	bf08      	it	eq
 1014360:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
 1014362:	fb00 3101 	mla	r1, r0, r1, r3
 1014366:	6888      	ldr	r0, [r1, #8]
	}

	*first = _first; /* Write back read-index */
 1014368:	711a      	strb	r2, [r3, #4]

	return mem;
 101436a:	4770      	bx	lr
		return NULL;
 101436c:	2000      	movs	r0, #0
}
 101436e:	4770      	bx	lr
 1014370:	21000548 	.word	0x21000548

01014374 <ll_tx_ack_put>:
{
 1014374:	b538      	push	{r3, r4, r5, lr}
	idx = MFIFO_ENQUEUE_GET(tx_ack, (void **)&tx);
 1014376:	4c14      	ldr	r4, [pc, #80]	; (10143c8 <ll_tx_ack_put+0x54>)
 1014378:	7962      	ldrb	r2, [r4, #5]
	if (last == count) {
 101437a:	f894 e002 	ldrb.w	lr, [r4, #2]
	last = last + 1;
 101437e:	1c53      	adds	r3, r2, #1
 1014380:	b2db      	uxtb	r3, r3
		last = 0U;
 1014382:	459e      	cmp	lr, r3
 1014384:	bf08      	it	eq
 1014386:	2300      	moveq	r3, #0
 1014388:	f894 c004 	ldrb.w	ip, [r4, #4]
 101438c:	7825      	ldrb	r5, [r4, #0]
	if (last == first) {
 101438e:	459c      	cmp	ip, r3
 1014390:	d009      	beq.n	10143a6 <ll_tx_ack_put+0x32>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 1014392:	fb05 f202 	mul.w	r2, r5, r2
 1014396:	f104 0c08 	add.w	ip, r4, #8
	tx->handle = handle;
 101439a:	f82c 0002 	strh.w	r0, [ip, r2]
 101439e:	4462      	add	r2, ip
	tx->node = node_tx;
 10143a0:	6051      	str	r1, [r2, #4]
	*last = idx; /* Commit: Update write index */
 10143a2:	7163      	strb	r3, [r4, #5]
}
 10143a4:	bd38      	pop	{r3, r4, r5, pc}
	LL_ASSERT(tx);
 10143a6:	f240 63e5 	movw	r3, #1765	; 0x6e5
 10143aa:	4a08      	ldr	r2, [pc, #32]	; (10143cc <ll_tx_ack_put+0x58>)
 10143ac:	4908      	ldr	r1, [pc, #32]	; (10143d0 <ll_tx_ack_put+0x5c>)
 10143ae:	4809      	ldr	r0, [pc, #36]	; (10143d4 <ll_tx_ack_put+0x60>)
 10143b0:	f010 fc11 	bl	1024bd6 <assert_print>
 10143b4:	4040      	eors	r0, r0
 10143b6:	f380 8811 	msr	BASEPRI, r0
 10143ba:	f04f 0003 	mov.w	r0, #3
 10143be:	df02      	svc	2
	tx->handle = handle;
 10143c0:	2300      	movs	r3, #0
 10143c2:	801b      	strh	r3, [r3, #0]
 10143c4:	deff      	udf	#255	; 0xff
 10143c6:	bf00      	nop
 10143c8:	21000520 	.word	0x21000520
 10143cc:	0102a558 	.word	0x0102a558
 10143d0:	0102a920 	.word	0x0102a920
 10143d4:	0102a278 	.word	0x0102a278

010143d8 <ll_timeslice_ticker_id_get>:
	*instance_index = TICKER_INSTANCE_ID_CTLR;
 10143d8:	2200      	movs	r2, #0
	*ticker_id = (TICKER_NODES - FLASH_TICKER_NODES);
 10143da:	230b      	movs	r3, #11
	*instance_index = TICKER_INSTANCE_ID_CTLR;
 10143dc:	7002      	strb	r2, [r0, #0]
	*ticker_id = (TICKER_NODES - FLASH_TICKER_NODES);
 10143de:	700b      	strb	r3, [r1, #0]
}
 10143e0:	4770      	bx	lr
 10143e2:	bf00      	nop

010143e4 <ll_radio_state_abort>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
 10143e4:	2200      	movs	r2, #0
{
 10143e6:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
 10143e8:	2001      	movs	r0, #1
 10143ea:	4611      	mov	r1, r2
 10143ec:	4b09      	ldr	r3, [pc, #36]	; (1014414 <ll_radio_state_abort+0x30>)
 10143ee:	f7fc fdf9 	bl	1010fe4 <mayfly_enqueue>
	LL_ASSERT(!ret);
 10143f2:	b900      	cbnz	r0, 10143f6 <ll_radio_state_abort+0x12>
}
 10143f4:	bd08      	pop	{r3, pc}
	LL_ASSERT(!ret);
 10143f6:	f240 63fd 	movw	r3, #1789	; 0x6fd
 10143fa:	4a07      	ldr	r2, [pc, #28]	; (1014418 <ll_radio_state_abort+0x34>)
 10143fc:	4907      	ldr	r1, [pc, #28]	; (101441c <ll_radio_state_abort+0x38>)
 10143fe:	4808      	ldr	r0, [pc, #32]	; (1014420 <ll_radio_state_abort+0x3c>)
 1014400:	f010 fbe9 	bl	1024bd6 <assert_print>
 1014404:	4040      	eors	r0, r0
 1014406:	f380 8811 	msr	BASEPRI, r0
 101440a:	f04f 0003 	mov.w	r0, #3
 101440e:	df02      	svc	2
}
 1014410:	bd08      	pop	{r3, pc}
 1014412:	bf00      	nop
 1014414:	21000500 	.word	0x21000500
 1014418:	0102a558 	.word	0x0102a558
 101441c:	0102a694 	.word	0x0102a694
 1014420:	0102a278 	.word	0x0102a278

01014424 <ll_radio_state_is_idle>:
	return lll_radio_is_idle();
 1014424:	f007 b9e6 	b.w	101b7f4 <lll_radio_is_idle>

01014428 <ull_ticker_status_take>:
	if (ret == TICKER_STATUS_BUSY) {
 1014428:	f030 0302 	bics.w	r3, r0, #2
{
 101442c:	b510      	push	{r4, lr}
 101442e:	460c      	mov	r4, r1
	if (ret == TICKER_STATUS_BUSY) {
 1014430:	d002      	beq.n	1014438 <ull_ticker_status_take+0x10>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 1014432:	680b      	ldr	r3, [r1, #0]
 1014434:	2b02      	cmp	r3, #2
 1014436:	d008      	beq.n	101444a <ull_ticker_status_take+0x22>
	return z_impl_k_sem_take(sem, timeout);
 1014438:	f04f 32ff 	mov.w	r2, #4294967295
 101443c:	f04f 33ff 	mov.w	r3, #4294967295
 1014440:	4809      	ldr	r0, [pc, #36]	; (1014468 <ull_ticker_status_take+0x40>)
 1014442:	f00d f971 	bl	1021728 <z_impl_k_sem_take>
	return *ret_cb;
 1014446:	6820      	ldr	r0, [r4, #0]
}
 1014448:	bd10      	pop	{r4, pc}
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 101444a:	f240 7319 	movw	r3, #1817	; 0x719
 101444e:	4a07      	ldr	r2, [pc, #28]	; (101446c <ull_ticker_status_take+0x44>)
 1014450:	4907      	ldr	r1, [pc, #28]	; (1014470 <ull_ticker_status_take+0x48>)
 1014452:	4808      	ldr	r0, [pc, #32]	; (1014474 <ull_ticker_status_take+0x4c>)
 1014454:	f010 fbbf 	bl	1024bd6 <assert_print>
 1014458:	4040      	eors	r0, r0
 101445a:	f380 8811 	msr	BASEPRI, r0
 101445e:	f04f 0003 	mov.w	r0, #3
 1014462:	df02      	svc	2
 1014464:	e7e8      	b.n	1014438 <ull_ticker_status_take+0x10>
 1014466:	bf00      	nop
 1014468:	21006700 	.word	0x21006700
 101446c:	0102a558 	.word	0x0102a558
 1014470:	0102a69c 	.word	0x0102a69c
 1014474:	0102a278 	.word	0x0102a278

01014478 <ull_disable_mark>:
	if (!*m) {
 1014478:	4904      	ldr	r1, [pc, #16]	; (101448c <ull_disable_mark+0x14>)
 101447a:	680a      	ldr	r2, [r1, #0]
 101447c:	b10a      	cbz	r2, 1014482 <ull_disable_mark+0xa>
}
 101447e:	4610      	mov	r0, r2
 1014480:	4770      	bx	lr
		*m = param;
 1014482:	4602      	mov	r2, r0
 1014484:	6008      	str	r0, [r1, #0]
}
 1014486:	4610      	mov	r0, r2
 1014488:	4770      	bx	lr
 101448a:	bf00      	nop
 101448c:	21004d44 	.word	0x21004d44

01014490 <ull_disable_unmark>:
	if (*m && *m == param) {
 1014490:	4a04      	ldr	r2, [pc, #16]	; (10144a4 <ull_disable_unmark+0x14>)
 1014492:	6813      	ldr	r3, [r2, #0]
 1014494:	b123      	cbz	r3, 10144a0 <ull_disable_unmark+0x10>
 1014496:	4298      	cmp	r0, r3
		*m = NULL;
 1014498:	bf0a      	itet	eq
 101449a:	2100      	moveq	r1, #0
	return NULL;
 101449c:	2300      	movne	r3, #0
		*m = NULL;
 101449e:	6011      	streq	r1, [r2, #0]
}
 10144a0:	4618      	mov	r0, r3
 10144a2:	4770      	bx	lr
 10144a4:	21004d44 	.word	0x21004d44

010144a8 <ull_disable_mark_get>:
	return mark_get(mark_disable);
 10144a8:	4b01      	ldr	r3, [pc, #4]	; (10144b0 <ull_disable_mark_get+0x8>)
}
 10144aa:	6818      	ldr	r0, [r3, #0]
 10144ac:	4770      	bx	lr
 10144ae:	bf00      	nop
 10144b0:	21004d44 	.word	0x21004d44

010144b4 <ull_update_mark>:
	if (!*m) {
 10144b4:	4904      	ldr	r1, [pc, #16]	; (10144c8 <ull_update_mark+0x14>)
 10144b6:	680a      	ldr	r2, [r1, #0]
 10144b8:	b10a      	cbz	r2, 10144be <ull_update_mark+0xa>
}
 10144ba:	4610      	mov	r0, r2
 10144bc:	4770      	bx	lr
		*m = param;
 10144be:	4602      	mov	r2, r0
 10144c0:	6008      	str	r0, [r1, #0]
}
 10144c2:	4610      	mov	r0, r2
 10144c4:	4770      	bx	lr
 10144c6:	bf00      	nop
 10144c8:	21004d48 	.word	0x21004d48

010144cc <ull_update_unmark>:
	if (*m && *m == param) {
 10144cc:	4a04      	ldr	r2, [pc, #16]	; (10144e0 <ull_update_unmark+0x14>)
 10144ce:	6813      	ldr	r3, [r2, #0]
 10144d0:	b123      	cbz	r3, 10144dc <ull_update_unmark+0x10>
 10144d2:	4298      	cmp	r0, r3
		*m = NULL;
 10144d4:	bf0a      	itet	eq
 10144d6:	2100      	moveq	r1, #0
	return NULL;
 10144d8:	2300      	movne	r3, #0
		*m = NULL;
 10144da:	6011      	streq	r1, [r2, #0]
}
 10144dc:	4618      	mov	r0, r3
 10144de:	4770      	bx	lr
 10144e0:	21004d48 	.word	0x21004d48

010144e4 <ull_update_mark_get>:
	return mark_get(mark_update);
 10144e4:	4b01      	ldr	r3, [pc, #4]	; (10144ec <ull_update_mark_get+0x8>)
}
 10144e6:	6818      	ldr	r0, [r3, #0]
 10144e8:	4770      	bx	lr
 10144ea:	bf00      	nop
 10144ec:	21004d48 	.word	0x21004d48

010144f0 <ull_disable>:
{
 10144f0:	b530      	push	{r4, r5, lr}
	hdr = HDR_LLL2ULL(lll);
 10144f2:	6805      	ldr	r5, [r0, #0]
{
 10144f4:	b087      	sub	sp, #28
 10144f6:	782b      	ldrb	r3, [r5, #0]
	if (!ull_ref_get(hdr)) {
 10144f8:	b353      	cbz	r3, 1014550 <ull_disable+0x60>
	compiler_barrier();
 10144fa:	4604      	mov	r4, r0
	return z_impl_k_sem_init(sem, initial_count, limit);
 10144fc:	2201      	movs	r2, #1
 10144fe:	2100      	movs	r1, #0
 1014500:	4668      	mov	r0, sp
 1014502:	f014 ff08 	bl	1029316 <z_impl_k_sem_init>
	hdr->disabled_cb = disabled_cb;
 1014506:	4a14      	ldr	r2, [pc, #80]	; (1014558 <ull_disable+0x68>)
 1014508:	782b      	ldrb	r3, [r5, #0]
	hdr->disabled_param = &sem;
 101450a:	f8c5 d018 	str.w	sp, [r5, #24]
	hdr->disabled_cb = disabled_cb;
 101450e:	616a      	str	r2, [r5, #20]
	if (!ull_ref_get(hdr)) {
 1014510:	b1f3      	cbz	r3, 1014550 <ull_disable+0x60>
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
 1014512:	2200      	movs	r2, #0
	mfy.param = lll;
 1014514:	4b11      	ldr	r3, [pc, #68]	; (101455c <ull_disable+0x6c>)
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
 1014516:	2003      	movs	r0, #3
 1014518:	4611      	mov	r1, r2
	mfy.param = lll;
 101451a:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
 101451c:	f7fc fd62 	bl	1010fe4 <mayfly_enqueue>
	LL_ASSERT(!ret);
 1014520:	b940      	cbnz	r0, 1014534 <ull_disable+0x44>
	return z_impl_k_sem_take(sem, timeout);
 1014522:	f04f 32ff 	mov.w	r2, #4294967295
 1014526:	f04f 33ff 	mov.w	r3, #4294967295
 101452a:	4668      	mov	r0, sp
 101452c:	f00d f8fc 	bl	1021728 <z_impl_k_sem_take>
}
 1014530:	b007      	add	sp, #28
 1014532:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!ret);
 1014534:	f240 7396 	movw	r3, #1942	; 0x796
 1014538:	4a09      	ldr	r2, [pc, #36]	; (1014560 <ull_disable+0x70>)
 101453a:	490a      	ldr	r1, [pc, #40]	; (1014564 <ull_disable+0x74>)
 101453c:	480a      	ldr	r0, [pc, #40]	; (1014568 <ull_disable+0x78>)
 101453e:	f010 fb4a 	bl	1024bd6 <assert_print>
 1014542:	4040      	eors	r0, r0
 1014544:	f380 8811 	msr	BASEPRI, r0
 1014548:	f04f 0003 	mov.w	r0, #3
 101454c:	df02      	svc	2
 101454e:	e7e8      	b.n	1014522 <ull_disable+0x32>
		return -EALREADY;
 1014550:	f06f 0077 	mvn.w	r0, #119	; 0x77
 1014554:	e7ec      	b.n	1014530 <ull_disable+0x40>
 1014556:	bf00      	nop
 1014558:	010139ed 	.word	0x010139ed
 101455c:	210004f0 	.word	0x210004f0
 1014560:	0102a558 	.word	0x0102a558
 1014564:	0102a694 	.word	0x0102a694
 1014568:	0102a278 	.word	0x0102a278

0101456c <ull_ticker_stop_with_mark>:
{
 101456c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!*m) {
 101456e:	4e1f      	ldr	r6, [pc, #124]	; (10145ec <ull_ticker_stop_with_mark+0x80>)
{
 1014570:	460c      	mov	r4, r1
	if (!*m) {
 1014572:	6833      	ldr	r3, [r6, #0]
{
 1014574:	4617      	mov	r7, r2
 1014576:	b085      	sub	sp, #20
	if (!*m) {
 1014578:	b363      	cbz	r3, 10145d4 <ull_ticker_stop_with_mark+0x68>
	if (mark != param) {
 101457a:	4299      	cmp	r1, r3
 101457c:	d115      	bne.n	10145aa <ull_ticker_stop_with_mark+0x3e>
	ret_cb = TICKER_STATUS_BUSY;
 101457e:	f04f 0c02 	mov.w	ip, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 1014582:	ad03      	add	r5, sp, #12
 1014584:	4602      	mov	r2, r0
 1014586:	2103      	movs	r1, #3
 1014588:	4b19      	ldr	r3, [pc, #100]	; (10145f0 <ull_ticker_stop_with_mark+0x84>)
 101458a:	9500      	str	r5, [sp, #0]
 101458c:	2000      	movs	r0, #0
	ret_cb = TICKER_STATUS_BUSY;
 101458e:	f8cd c00c 	str.w	ip, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 1014592:	f7fd fe0f 	bl	10121b4 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
 1014596:	4629      	mov	r1, r5
 1014598:	f7ff ff46 	bl	1014428 <ull_ticker_status_take>
	if (ret) {
 101459c:	4605      	mov	r5, r0
 101459e:	b140      	cbz	r0, 10145b2 <ull_ticker_stop_with_mark+0x46>
	if (*m && *m == param) {
 10145a0:	6833      	ldr	r3, [r6, #0]
 10145a2:	b10b      	cbz	r3, 10145a8 <ull_ticker_stop_with_mark+0x3c>
 10145a4:	429c      	cmp	r4, r3
 10145a6:	d017      	beq.n	10145d8 <ull_ticker_stop_with_mark+0x6c>
		if (mark != param) {
 10145a8:	b1c4      	cbz	r4, 10145dc <ull_ticker_stop_with_mark+0x70>
		return -ENOLCK;
 10145aa:	f06f 002d 	mvn.w	r0, #45	; 0x2d
}
 10145ae:	b005      	add	sp, #20
 10145b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	err = ull_disable(lll_disable);
 10145b2:	4638      	mov	r0, r7
 10145b4:	f7ff ff9c 	bl	10144f0 <ull_disable>
	if (*m && *m == param) {
 10145b8:	6833      	ldr	r3, [r6, #0]
 10145ba:	b10b      	cbz	r3, 10145c0 <ull_ticker_stop_with_mark+0x54>
 10145bc:	429c      	cmp	r4, r3
 10145be:	d011      	beq.n	10145e4 <ull_ticker_stop_with_mark+0x78>
	if (mark != param) {
 10145c0:	2c00      	cmp	r4, #0
 10145c2:	d1f2      	bne.n	10145aa <ull_ticker_stop_with_mark+0x3e>
	if (err && (err != -EALREADY)) {
 10145c4:	2800      	cmp	r0, #0
 10145c6:	d0f2      	beq.n	10145ae <ull_ticker_stop_with_mark+0x42>
	return 0;
 10145c8:	f110 0f78 	cmn.w	r0, #120	; 0x78
 10145cc:	bf08      	it	eq
 10145ce:	2000      	moveq	r0, #0
}
 10145d0:	b005      	add	sp, #20
 10145d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*m = param;
 10145d4:	6031      	str	r1, [r6, #0]
	if (mark != param) {
 10145d6:	e7d2      	b.n	101457e <ull_ticker_stop_with_mark+0x12>
		*m = NULL;
 10145d8:	2300      	movs	r3, #0
 10145da:	6033      	str	r3, [r6, #0]
		return -EALREADY;
 10145dc:	f06f 0077 	mvn.w	r0, #119	; 0x77
}
 10145e0:	b005      	add	sp, #20
 10145e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*m = NULL;
 10145e4:	6035      	str	r5, [r6, #0]
	if (err && (err != -EALREADY)) {
 10145e6:	2800      	cmp	r0, #0
 10145e8:	d0e1      	beq.n	10145ae <ull_ticker_stop_with_mark+0x42>
 10145ea:	e7ed      	b.n	10145c8 <ull_ticker_stop_with_mark+0x5c>
 10145ec:	21004d44 	.word	0x21004d44
 10145f0:	010139e1 	.word	0x010139e1

010145f4 <ull_pdu_rx_alloc_peek>:
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
 10145f4:	490e      	ldr	r1, [pc, #56]	; (1014630 <ull_pdu_rx_alloc_peek+0x3c>)
 10145f6:	790b      	ldrb	r3, [r1, #4]
 10145f8:	794a      	ldrb	r2, [r1, #5]
	if (last >= first) {
 10145fa:	4293      	cmp	r3, r2
 10145fc:	d80d      	bhi.n	101461a <ull_pdu_rx_alloc_peek+0x26>
		return last - first;
 10145fe:	eba2 0c03 	sub.w	ip, r2, r3
 1014602:	fa5f fc8c 	uxtb.w	ip, ip
 1014606:	4560      	cmp	r0, ip
 1014608:	d80f      	bhi.n	101462a <ull_pdu_rx_alloc_peek+0x36>
	if (first == last) {
 101460a:	4293      	cmp	r3, r2
 101460c:	d00d      	beq.n	101462a <ull_pdu_rx_alloc_peek+0x36>
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
 101460e:	780a      	ldrb	r2, [r1, #0]
	return *((void **)(fifo + first * size));
 1014610:	fb02 f303 	mul.w	r3, r2, r3
 1014614:	4a07      	ldr	r2, [pc, #28]	; (1014634 <ull_pdu_rx_alloc_peek+0x40>)
 1014616:	58d0      	ldr	r0, [r2, r3]
 1014618:	4770      	bx	lr
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
 101461a:	f8b1 c002 	ldrh.w	ip, [r1, #2]
		return count - first + last;
 101461e:	ebac 0c03 	sub.w	ip, ip, r3
 1014622:	4462      	add	r2, ip
 1014624:	b2d2      	uxtb	r2, r2
 1014626:	4290      	cmp	r0, r2
 1014628:	d9f1      	bls.n	101460e <ull_pdu_rx_alloc_peek+0x1a>
		return NULL;
 101462a:	2000      	movs	r0, #0
}
 101462c:	4770      	bx	lr
 101462e:	bf00      	nop
 1014630:	21000594 	.word	0x21000594
 1014634:	2100059c 	.word	0x2100059c

01014638 <ull_pdu_rx_alloc>:
	return MFIFO_DEQUEUE(pdu_rx_free);
 1014638:	4b09      	ldr	r3, [pc, #36]	; (1014660 <ull_pdu_rx_alloc+0x28>)
	uint8_t _first = *first; /* Copy read-index */
 101463a:	7919      	ldrb	r1, [r3, #4]
	if (_first == last) {
 101463c:	795a      	ldrb	r2, [r3, #5]
 101463e:	7818      	ldrb	r0, [r3, #0]
 1014640:	428a      	cmp	r2, r1
 1014642:	f893 c002 	ldrb.w	ip, [r3, #2]
 1014646:	d009      	beq.n	101465c <ull_pdu_rx_alloc+0x24>
	_first += 1U;
 1014648:	1c4a      	adds	r2, r1, #1
 101464a:	b2d2      	uxtb	r2, r2
		_first = 0U;
 101464c:	4594      	cmp	ip, r2
 101464e:	bf08      	it	eq
 1014650:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
 1014652:	fb00 3101 	mla	r1, r0, r1, r3
 1014656:	6888      	ldr	r0, [r1, #8]
	*first = _first; /* Write back read-index */
 1014658:	711a      	strb	r2, [r3, #4]
	return mem;
 101465a:	4770      	bx	lr
		return NULL;
 101465c:	2000      	movs	r0, #0
}
 101465e:	4770      	bx	lr
 1014660:	21000594 	.word	0x21000594

01014664 <ull_rx_put>:
{
 1014664:	b538      	push	{r3, r4, r5, lr}
 1014666:	460c      	mov	r4, r1
 1014668:	4605      	mov	r5, r0
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
 101466a:	f002 f899 	bl	10167a0 <ull_conn_ack_last_idx_get>
 101466e:	4603      	mov	r3, r0
 1014670:	7023      	strb	r3, [r4, #0]
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 1014672:	4621      	mov	r1, r4
 1014674:	4628      	mov	r0, r5
}
 1014676:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 101467a:	4a01      	ldr	r2, [pc, #4]	; (1014680 <ull_rx_put+0x1c>)
 101467c:	f7fc bc3a 	b.w	1010ef4 <memq_enqueue>
 1014680:	21004d60 	.word	0x21004d60

01014684 <ull_rx_sched>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
 1014684:	2201      	movs	r2, #1
 1014686:	2000      	movs	r0, #0
 1014688:	4611      	mov	r1, r2
 101468a:	4b01      	ldr	r3, [pc, #4]	; (1014690 <ull_rx_sched+0xc>)
 101468c:	f7fc bcaa 	b.w	1010fe4 <mayfly_enqueue>
 1014690:	210004e0 	.word	0x210004e0

01014694 <ull_rx_put_sched>:
{
 1014694:	b570      	push	{r4, r5, r6, lr}
 1014696:	460c      	mov	r4, r1
 1014698:	4605      	mov	r5, r0
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
 101469a:	f002 f881 	bl	10167a0 <ull_conn_ack_last_idx_get>
 101469e:	4603      	mov	r3, r0
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 10146a0:	4621      	mov	r1, r4
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
 10146a2:	7023      	strb	r3, [r4, #0]
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 10146a4:	4628      	mov	r0, r5
 10146a6:	4a05      	ldr	r2, [pc, #20]	; (10146bc <ull_rx_put_sched+0x28>)
 10146a8:	f7fc fc24 	bl	1010ef4 <memq_enqueue>
}
 10146ac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
 10146b0:	2201      	movs	r2, #1
 10146b2:	2000      	movs	r0, #0
 10146b4:	4611      	mov	r1, r2
 10146b6:	4b02      	ldr	r3, [pc, #8]	; (10146c0 <ull_rx_put_sched+0x2c>)
 10146b8:	f7fc bc94 	b.w	1010fe4 <mayfly_enqueue>
 10146bc:	21004d60 	.word	0x21004d60
 10146c0:	210004e0 	.word	0x210004e0

010146c4 <ull_prepare_enqueue>:
{
 10146c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
 10146c8:	4e17      	ldr	r6, [pc, #92]	; (1014728 <ull_prepare_enqueue+0x64>)
{
 10146ca:	4699      	mov	r9, r3
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
 10146cc:	f896 c005 	ldrb.w	ip, [r6, #5]
	if (last == count) {
 10146d0:	78b4      	ldrb	r4, [r6, #2]
	last = last + 1;
 10146d2:	f10c 0501 	add.w	r5, ip, #1
 10146d6:	b2ed      	uxtb	r5, r5
		last = 0U;
 10146d8:	42ac      	cmp	r4, r5
 10146da:	bf08      	it	eq
 10146dc:	2500      	moveq	r5, #0
 10146de:	7934      	ldrb	r4, [r6, #4]
{
 10146e0:	f89d a020 	ldrb.w	sl, [sp, #32]
	if (last == first) {
 10146e4:	42ac      	cmp	r4, r5
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
 10146e6:	7833      	ldrb	r3, [r6, #0]
 10146e8:	d019      	beq.n	101471e <ull_prepare_enqueue+0x5a>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 10146ea:	4680      	mov	r8, r0
 10146ec:	460f      	mov	r7, r1
 10146ee:	f106 0408 	add.w	r4, r6, #8
 10146f2:	fb03 440c 	mla	r4, r3, ip, r4
	memcpy(&e->prepare_param, prepare_param, sizeof(e->prepare_param));
 10146f6:	4611      	mov	r1, r2
 10146f8:	4620      	mov	r0, r4
 10146fa:	2210      	movs	r2, #16
 10146fc:	f012 f93a 	bl	1026974 <memcpy>
	e->is_resume = is_resume;
 1014700:	7f23      	ldrb	r3, [r4, #28]
 1014702:	f00a 0a01 	and.w	sl, sl, #1
 1014706:	f023 0303 	bic.w	r3, r3, #3
 101470a:	ea43 030a 	orr.w	r3, r3, sl
	e->is_abort_cb = is_abort_cb;
 101470e:	e9c4 9804 	strd	r9, r8, [r4, #16]
	e->abort_cb = abort_cb;
 1014712:	61a7      	str	r7, [r4, #24]
	e->is_resume = is_resume;
 1014714:	7723      	strb	r3, [r4, #28]
	*last = idx; /* Commit: Update write index */
 1014716:	7175      	strb	r5, [r6, #5]
}
 1014718:	4620      	mov	r0, r4
 101471a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return NULL;
 101471e:	2400      	movs	r4, #0
}
 1014720:	4620      	mov	r0, r4
 1014722:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1014726:	bf00      	nop
 1014728:	210006b4 	.word	0x210006b4

0101472c <ull_prepare_dequeue_get>:
	return MFIFO_DEQUEUE_GET(prep);
 101472c:	4805      	ldr	r0, [pc, #20]	; (1014744 <ull_prepare_dequeue_get+0x18>)
 101472e:	7902      	ldrb	r2, [r0, #4]
	if (first == last) {
 1014730:	7941      	ldrb	r1, [r0, #5]
 1014732:	f890 c000 	ldrb.w	ip, [r0]
 1014736:	4291      	cmp	r1, r2
	return (void *)(fifo + first * size);
 1014738:	bf1a      	itte	ne
 101473a:	3008      	addne	r0, #8
 101473c:	fb0c 0002 	mlane	r0, ip, r2, r0
		return NULL;
 1014740:	2000      	moveq	r0, #0
}
 1014742:	4770      	bx	lr
 1014744:	210006b4 	.word	0x210006b4

01014748 <ull_prepare_dequeue_iter>:
{
 1014748:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
 101474a:	4b0d      	ldr	r3, [pc, #52]	; (1014780 <ull_prepare_dequeue_iter+0x38>)
	if (*idx >= count) {
 101474c:	7802      	ldrb	r2, [r0, #0]
 101474e:	f893 c002 	ldrb.w	ip, [r3, #2]
 1014752:	f893 e005 	ldrb.w	lr, [r3, #5]
 1014756:	4594      	cmp	ip, r2
 1014758:	bf98      	it	ls
 101475a:	791a      	ldrbls	r2, [r3, #4]
 101475c:	781c      	ldrb	r4, [r3, #0]
		*idx = first;
 101475e:	bf98      	it	ls
 1014760:	7002      	strbls	r2, [r0, #0]
	if (*idx == last) {
 1014762:	4596      	cmp	lr, r2
{
 1014764:	4601      	mov	r1, r0
 1014766:	d009      	beq.n	101477c <ull_prepare_dequeue_iter+0x34>
	i = *idx + 1;
 1014768:	1c53      	adds	r3, r2, #1
 101476a:	b2db      	uxtb	r3, r3
		i = 0U;
 101476c:	459c      	cmp	ip, r3
 101476e:	bf08      	it	eq
 1014770:	2300      	moveq	r3, #0
	p = (void *)(fifo + (*idx) * size);
 1014772:	4804      	ldr	r0, [pc, #16]	; (1014784 <ull_prepare_dequeue_iter+0x3c>)
	*idx = i;
 1014774:	700b      	strb	r3, [r1, #0]
	p = (void *)(fifo + (*idx) * size);
 1014776:	fb04 0002 	mla	r0, r4, r2, r0
}
 101477a:	bd10      	pop	{r4, pc}
		return NULL;
 101477c:	2000      	movs	r0, #0
 101477e:	bd10      	pop	{r4, pc}
 1014780:	210006b4 	.word	0x210006b4
 1014784:	210006bc 	.word	0x210006bc

01014788 <ull_prepare_dequeue>:
{
 1014788:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return MFIFO_DEQUEUE_GET(prep);
 101478c:	4c2b      	ldr	r4, [pc, #172]	; (101483c <ull_prepare_dequeue+0xb4>)
{
 101478e:	b083      	sub	sp, #12
	return MFIFO_DEQUEUE_GET(prep);
 1014790:	7923      	ldrb	r3, [r4, #4]
	if (first == last) {
 1014792:	7962      	ldrb	r2, [r4, #5]
 1014794:	7821      	ldrb	r1, [r4, #0]
 1014796:	429a      	cmp	r2, r3
{
 1014798:	9001      	str	r0, [sp, #4]
 101479a:	d032      	beq.n	1014802 <ull_prepare_dequeue+0x7a>
	return (void *)(fifo + first * size);
 101479c:	f04f 0800 	mov.w	r8, #0
 10147a0:	46c2      	mov	sl, r8
 10147a2:	f104 0908 	add.w	r9, r4, #8
 10147a6:	fb01 9303 	mla	r3, r1, r3, r9
			mfy.param = next;
 10147aa:	f8df b094 	ldr.w	fp, [pc, #148]	; 1014840 <ull_prepare_dequeue+0xb8>
		uint8_t is_aborted = next->is_aborted;
 10147ae:	7f1a      	ldrb	r2, [r3, #28]
		void *param = next->prepare_param.param;
 10147b0:	68df      	ldr	r7, [r3, #12]
		if (!is_aborted) {
 10147b2:	0791      	lsls	r1, r2, #30
		uint8_t is_aborted = next->is_aborted;
 10147b4:	f3c2 0540 	ubfx	r5, r2, #1, #1
		uint8_t is_resume = next->is_resume;
 10147b8:	f002 0601 	and.w	r6, r2, #1
		if (!is_aborted) {
 10147bc:	d524      	bpl.n	1014808 <ull_prepare_dequeue+0x80>
		MFIFO_DEQUEUE(prep);
 10147be:	7962      	ldrb	r2, [r4, #5]
	uint8_t _first = *first; /* Copy read-index */
 10147c0:	7923      	ldrb	r3, [r4, #4]
 10147c2:	7821      	ldrb	r1, [r4, #0]
	if (_first == last) {
 10147c4:	429a      	cmp	r2, r3
 10147c6:	78a0      	ldrb	r0, [r4, #2]
 10147c8:	d01b      	beq.n	1014802 <ull_prepare_dequeue+0x7a>
	_first += 1U;
 10147ca:	3301      	adds	r3, #1
 10147cc:	b2db      	uxtb	r3, r3
		_first = 0U;
 10147ce:	4298      	cmp	r0, r3
 10147d0:	bf08      	it	eq
 10147d2:	2300      	moveq	r3, #0
	if (first == last) {
 10147d4:	429a      	cmp	r2, r3
	*first = _first; /* Write back read-index */
 10147d6:	7123      	strb	r3, [r4, #4]
	if (first == last) {
 10147d8:	d013      	beq.n	1014802 <ull_prepare_dequeue+0x7a>
	return (void *)(fifo + first * size);
 10147da:	fb01 9303 	mla	r3, r1, r3, r9
		if (!is_aborted) {
 10147de:	2d00      	cmp	r5, #0
 10147e0:	d1e5      	bne.n	10147ae <ull_prepare_dequeue+0x26>
			if (!is_resume) {
 10147e2:	b176      	cbz	r6, 1014802 <ull_prepare_dequeue+0x7a>
			if (!param_resume_head) {
 10147e4:	f1ba 0f00 	cmp.w	sl, #0
 10147e8:	d026      	beq.n	1014838 <ull_prepare_dequeue+0xb0>
				param_resume_next = param;
 10147ea:	f1b8 0f00 	cmp.w	r8, #0
 10147ee:	bf08      	it	eq
 10147f0:	46b8      	moveq	r8, r7
			if (next->is_resume &&
 10147f2:	7f1a      	ldrb	r2, [r3, #28]
 10147f4:	07d2      	lsls	r2, r2, #31
 10147f6:	d5da      	bpl.n	10147ae <ull_prepare_dequeue+0x26>
			    ((next->prepare_param.param ==
 10147f8:	68da      	ldr	r2, [r3, #12]
			if (next->is_resume &&
 10147fa:	4592      	cmp	sl, r2
 10147fc:	d001      	beq.n	1014802 <ull_prepare_dequeue+0x7a>
			      param_resume_head) ||
 10147fe:	4590      	cmp	r8, r2
 1014800:	d1d5      	bne.n	10147ae <ull_prepare_dequeue+0x26>
}
 1014802:	b003      	add	sp, #12
 1014804:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mfy.param = next;
 1014808:	f8cb 3008 	str.w	r3, [fp, #8]
			ret = mayfly_enqueue(caller_id, TICKER_USER_ID_LLL, 0,
 101480c:	462a      	mov	r2, r5
 101480e:	4629      	mov	r1, r5
 1014810:	4b0b      	ldr	r3, [pc, #44]	; (1014840 <ull_prepare_dequeue+0xb8>)
 1014812:	9801      	ldr	r0, [sp, #4]
 1014814:	f7fc fbe6 	bl	1010fe4 <mayfly_enqueue>
			LL_ASSERT(!ret);
 1014818:	2800      	cmp	r0, #0
 101481a:	d0d0      	beq.n	10147be <ull_prepare_dequeue+0x36>
 101481c:	f640 0319 	movw	r3, #2073	; 0x819
 1014820:	4a08      	ldr	r2, [pc, #32]	; (1014844 <ull_prepare_dequeue+0xbc>)
 1014822:	4909      	ldr	r1, [pc, #36]	; (1014848 <ull_prepare_dequeue+0xc0>)
 1014824:	4809      	ldr	r0, [pc, #36]	; (101484c <ull_prepare_dequeue+0xc4>)
 1014826:	f010 f9d6 	bl	1024bd6 <assert_print>
 101482a:	4040      	eors	r0, r0
 101482c:	f380 8811 	msr	BASEPRI, r0
 1014830:	f04f 0003 	mov.w	r0, #3
 1014834:	df02      	svc	2
 1014836:	e7c2      	b.n	10147be <ull_prepare_dequeue+0x36>
				param_resume_head = param;
 1014838:	46ba      	mov	sl, r7
 101483a:	e7da      	b.n	10147f2 <ull_prepare_dequeue+0x6a>
 101483c:	210006b4 	.word	0x210006b4
 1014840:	210004c0 	.word	0x210004c0
 1014844:	0102a558 	.word	0x0102a558
 1014848:	0102a694 	.word	0x0102a694
 101484c:	0102a278 	.word	0x0102a278

01014850 <ull_event_done_extra_get>:
	evdone = MFIFO_DEQUEUE_PEEK(done);
 1014850:	4b06      	ldr	r3, [pc, #24]	; (101486c <ull_event_done_extra_get+0x1c>)
 1014852:	791a      	ldrb	r2, [r3, #4]
	if (first == last) {
 1014854:	7959      	ldrb	r1, [r3, #5]
 1014856:	7818      	ldrb	r0, [r3, #0]
 1014858:	4291      	cmp	r1, r2
 101485a:	d005      	beq.n	1014868 <ull_event_done_extra_get+0x18>
	return *((void **)(fifo + first * size));
 101485c:	fb00 3302 	mla	r3, r0, r2, r3
 1014860:	6898      	ldr	r0, [r3, #8]
	if (!evdone) {
 1014862:	b110      	cbz	r0, 101486a <ull_event_done_extra_get+0x1a>
	return &evdone->extra;
 1014864:	3020      	adds	r0, #32
 1014866:	4770      	bx	lr
		return NULL;
 1014868:	2000      	movs	r0, #0
}
 101486a:	4770      	bx	lr
 101486c:	21000698 	.word	0x21000698

01014870 <ull_event_done>:
{
 1014870:	b538      	push	{r3, r4, r5, lr}
	evdone = MFIFO_DEQUEUE(done);
 1014872:	4a12      	ldr	r2, [pc, #72]	; (10148bc <ull_event_done+0x4c>)
	uint8_t _first = *first; /* Copy read-index */
 1014874:	7913      	ldrb	r3, [r2, #4]
	if (_first == last) {
 1014876:	7954      	ldrb	r4, [r2, #5]
 1014878:	7811      	ldrb	r1, [r2, #0]
 101487a:	429c      	cmp	r4, r3
 101487c:	7895      	ldrb	r5, [r2, #2]
 101487e:	d01b      	beq.n	10148b8 <ull_event_done+0x48>
	mem = *((void **)(fifo + _first * size));
 1014880:	fb01 2103 	mla	r1, r1, r3, r2
	_first += 1U;
 1014884:	3301      	adds	r3, #1
 1014886:	b2db      	uxtb	r3, r3
		_first = 0U;
 1014888:	429d      	cmp	r5, r3
 101488a:	bf08      	it	eq
 101488c:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
 101488e:	688c      	ldr	r4, [r1, #8]
	*first = _first; /* Write back read-index */
 1014890:	7113      	strb	r3, [r2, #4]
	if (!evdone) {
 1014892:	b18c      	cbz	r4, 10148b8 <ull_event_done+0x48>
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
 1014894:	2302      	movs	r3, #2
	evdone->hdr.link = NULL;
 1014896:	2500      	movs	r5, #0
	memq_enqueue(link, done, &memq_ull_done.tail);
 1014898:	4621      	mov	r1, r4
 101489a:	4a09      	ldr	r2, [pc, #36]	; (10148c0 <ull_event_done+0x50>)
	evdone->param = param;
 101489c:	61e0      	str	r0, [r4, #28]
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
 101489e:	7123      	strb	r3, [r4, #4]
	memq_enqueue(link, done, &memq_ull_done.tail);
 10148a0:	6820      	ldr	r0, [r4, #0]
	evdone->hdr.link = NULL;
 10148a2:	6025      	str	r5, [r4, #0]
	memq_enqueue(link, done, &memq_ull_done.tail);
 10148a4:	f7fc fb26 	bl	1010ef4 <memq_enqueue>
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
 10148a8:	2201      	movs	r2, #1
 10148aa:	4628      	mov	r0, r5
 10148ac:	4611      	mov	r1, r2
 10148ae:	4b05      	ldr	r3, [pc, #20]	; (10148c4 <ull_event_done+0x54>)
 10148b0:	f7fc fb98 	bl	1010fe4 <mayfly_enqueue>
}
 10148b4:	4620      	mov	r0, r4
 10148b6:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
 10148b8:	2400      	movs	r4, #0
 10148ba:	e7fb      	b.n	10148b4 <ull_event_done+0x44>
 10148bc:	21000698 	.word	0x21000698
 10148c0:	21004d50 	.word	0x21004d50
 10148c4:	210004d0 	.word	0x210004d0

010148c8 <ull_rxfifo_alloc>:
{
 10148c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10148cc:	b083      	sub	sp, #12
 10148ce:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 10148d0:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 10148d2:	f89d c03c 	ldrb.w	ip, [sp, #60]	; 0x3c
 10148d6:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 10148da:	9401      	str	r4, [sp, #4]
 10148dc:	9500      	str	r5, [sp, #0]
	while ((max--) && mfifo_enqueue_idx_get(n, f, *l, &idx)) {
 10148de:	f1bc 0f00 	cmp.w	ip, #0
 10148e2:	d02b      	beq.n	101493c <ull_rxfifo_alloc+0x74>
 10148e4:	4680      	mov	r8, r0
 10148e6:	460e      	mov	r6, r1
 10148e8:	4617      	mov	r7, r2
 10148ea:	461d      	mov	r5, r3
 10148ec:	f10c 34ff 	add.w	r4, ip, #4294967295
 10148f0:	f893 9000 	ldrb.w	r9, [r3]
 10148f4:	b2e4      	uxtb	r4, r4
	last = last + 1;
 10148f6:	f109 0301 	add.w	r3, r9, #1
 10148fa:	fa5f f983 	uxtb.w	r9, r3
		last = 0U;
 10148fe:	454e      	cmp	r6, r9
 1014900:	bf08      	it	eq
 1014902:	f04f 0900 	moveq.w	r9, #0
	if (last == first) {
 1014906:	454f      	cmp	r7, r9
 1014908:	d018      	beq.n	101493c <ull_rxfifo_alloc+0x74>
		link = mem_acquire(link_free);
 101490a:	9800      	ldr	r0, [sp, #0]
 101490c:	f7fc fa8c 	bl	1010e28 <mem_acquire>
		if (!link) {
 1014910:	4683      	mov	fp, r0
 1014912:	b198      	cbz	r0, 101493c <ull_rxfifo_alloc+0x74>
		rx = mem_acquire(mem_free);
 1014914:	9801      	ldr	r0, [sp, #4]
 1014916:	f7fc fa87 	bl	1010e28 <mem_acquire>
		if (!rx) {
 101491a:	b190      	cbz	r0, 1014942 <ull_rxfifo_alloc+0x7a>
		link->mem = NULL;
 101491c:	2300      	movs	r3, #0
 101491e:	f8cb 3004 	str.w	r3, [fp, #4]
		rx->link = link;
 1014922:	f8c0 b000 	str.w	fp, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1014926:	782a      	ldrb	r2, [r5, #0]
 1014928:	fb08 f202 	mul.w	r2, r8, r2
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 101492c:	f84a 0002 	str.w	r0, [sl, r2]
	while ((max--) && mfifo_enqueue_idx_get(n, f, *l, &idx)) {
 1014930:	3c01      	subs	r4, #1
 1014932:	b2e4      	uxtb	r4, r4
 1014934:	2cff      	cmp	r4, #255	; 0xff
	*last = idx; /* Commit: Update write index */
 1014936:	f885 9000 	strb.w	r9, [r5]
 101493a:	d1dc      	bne.n	10148f6 <ull_rxfifo_alloc+0x2e>
}
 101493c:	b003      	add	sp, #12
 101493e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mem_release(link, link_free);
 1014942:	4658      	mov	r0, fp
 1014944:	9900      	ldr	r1, [sp, #0]
}
 1014946:	b003      	add	sp, #12
 1014948:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			mem_release(link, link_free);
 101494c:	f7fc ba88 	b.w	1010e60 <mem_release>

01014950 <init_reset>:
	RXFIFO_INIT_ALLOC(done);
 1014950:	f04f 0c00 	mov.w	ip, #0
{
 1014954:	b570      	push	{r4, r5, r6, lr}
	RXFIFO_INIT_ALLOC(done);
 1014956:	4d3f      	ldr	r5, [pc, #252]	; (1014a54 <init_reset+0x104>)
 1014958:	4c3f      	ldr	r4, [pc, #252]	; (1014a58 <init_reset+0x108>)
{
 101495a:	b084      	sub	sp, #16
	RXFIFO_INIT_ALLOC(done);
 101495c:	f8a4 c004 	strh.w	ip, [r4, #4]
 1014960:	462b      	mov	r3, r5
 1014962:	79aa      	ldrb	r2, [r5, #6]
 1014964:	88a9      	ldrh	r1, [r5, #4]
 1014966:	f105 0008 	add.w	r0, r5, #8
 101496a:	f7fc fa2d 	bl	1010dc8 <mem_init>
 101496e:	4e3b      	ldr	r6, [pc, #236]	; (1014a5c <init_reset+0x10c>)
 1014970:	79eb      	ldrb	r3, [r5, #7]
 1014972:	79aa      	ldrb	r2, [r5, #6]
 1014974:	2108      	movs	r1, #8
 1014976:	441a      	add	r2, r3
 1014978:	1d30      	adds	r0, r6, #4
 101497a:	4633      	mov	r3, r6
 101497c:	f7fc fa24 	bl	1010dc8 <mem_init>
 1014980:	9602      	str	r6, [sp, #8]
 1014982:	79a8      	ldrb	r0, [r5, #6]
 1014984:	7922      	ldrb	r2, [r4, #4]
 1014986:	78a1      	ldrb	r1, [r4, #2]
 1014988:	9003      	str	r0, [sp, #12]
 101498a:	9501      	str	r5, [sp, #4]
 101498c:	1d63      	adds	r3, r4, #5
 101498e:	f814 0b08 	ldrb.w	r0, [r4], #8
 1014992:	9400      	str	r4, [sp, #0]
 1014994:	f7ff ff98 	bl	10148c8 <ull_rxfifo_alloc>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
 1014998:	4b31      	ldr	r3, [pc, #196]	; (1014a60 <init_reset+0x110>)
 101499a:	2216      	movs	r2, #22
 101499c:	1d18      	adds	r0, r3, #4
 101499e:	f44f 718e 	mov.w	r1, #284	; 0x11c
 10149a2:	f7fc fa11 	bl	1010dc8 <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
 10149a6:	4b2f      	ldr	r3, [pc, #188]	; (1014a64 <init_reset+0x114>)
 10149a8:	221f      	movs	r2, #31
 10149aa:	1d18      	adds	r0, r3, #4
 10149ac:	2108      	movs	r1, #8
 10149ae:	f7fc fa0b 	bl	1010dc8 <mem_init>
	link = mem_acquire(&mem_link_rx.free);
 10149b2:	482c      	ldr	r0, [pc, #176]	; (1014a64 <init_reset+0x114>)
 10149b4:	f7fc fa38 	bl	1010e28 <mem_acquire>
	LL_ASSERT(link);
 10149b8:	4604      	mov	r4, r0
 10149ba:	b308      	cbz	r0, 1014a00 <init_reset+0xb0>
	MEMQ_INIT(ull_rx, link);
 10149bc:	4a2a      	ldr	r2, [pc, #168]	; (1014a68 <init_reset+0x118>)
 10149be:	4620      	mov	r0, r4
 10149c0:	1f11      	subs	r1, r2, #4
 10149c2:	f7fc fa89 	bl	1010ed8 <memq_init>
	link = mem_acquire(&mem_link_done.free);
 10149c6:	4825      	ldr	r0, [pc, #148]	; (1014a5c <init_reset+0x10c>)
 10149c8:	f7fc fa2e 	bl	1010e28 <mem_acquire>
	LL_ASSERT(link);
 10149cc:	4604      	mov	r4, r0
 10149ce:	b328      	cbz	r0, 1014a1c <init_reset+0xcc>
	MEMQ_INIT(ull_done, link);
 10149d0:	4a26      	ldr	r2, [pc, #152]	; (1014a6c <init_reset+0x11c>)
 10149d2:	4620      	mov	r0, r4
 10149d4:	1f11      	subs	r1, r2, #4
 10149d6:	f7fc fa7f 	bl	1010ed8 <memq_init>
	link = mem_acquire(&mem_link_rx.free);
 10149da:	4822      	ldr	r0, [pc, #136]	; (1014a64 <init_reset+0x114>)
 10149dc:	f7fc fa24 	bl	1010e28 <mem_acquire>
	LL_ASSERT(link);
 10149e0:	4604      	mov	r4, r0
 10149e2:	b348      	cbz	r0, 1014a38 <init_reset+0xe8>
	MEMQ_INIT(ll_rx, link);
 10149e4:	4a22      	ldr	r2, [pc, #136]	; (1014a70 <init_reset+0x120>)
 10149e6:	4620      	mov	r0, r4
 10149e8:	1f11      	subs	r1, r2, #4
 10149ea:	f7fc fa75 	bl	1010ed8 <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
 10149ee:	2214      	movs	r2, #20
 10149f0:	4b20      	ldr	r3, [pc, #128]	; (1014a74 <init_reset+0x124>)
	rx_replenish(UINT8_MAX);
 10149f2:	20ff      	movs	r0, #255	; 0xff
	mem_link_rx.quota_pdu = RX_CNT;
 10149f4:	801a      	strh	r2, [r3, #0]
	rx_replenish(UINT8_MAX);
 10149f6:	f7ff f857 	bl	1013aa8 <rx_replenish>
}
 10149fa:	2000      	movs	r0, #0
 10149fc:	b004      	add	sp, #16
 10149fe:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(link);
 1014a00:	f640 03c8 	movw	r3, #2248	; 0x8c8
 1014a04:	4a1c      	ldr	r2, [pc, #112]	; (1014a78 <init_reset+0x128>)
 1014a06:	491d      	ldr	r1, [pc, #116]	; (1014a7c <init_reset+0x12c>)
 1014a08:	481d      	ldr	r0, [pc, #116]	; (1014a80 <init_reset+0x130>)
 1014a0a:	f010 f8e4 	bl	1024bd6 <assert_print>
 1014a0e:	4040      	eors	r0, r0
 1014a10:	f380 8811 	msr	BASEPRI, r0
 1014a14:	f04f 0003 	mov.w	r0, #3
 1014a18:	df02      	svc	2
 1014a1a:	e7cf      	b.n	10149bc <init_reset+0x6c>
	LL_ASSERT(link);
 1014a1c:	f44f 630d 	mov.w	r3, #2256	; 0x8d0
 1014a20:	4a15      	ldr	r2, [pc, #84]	; (1014a78 <init_reset+0x128>)
 1014a22:	4916      	ldr	r1, [pc, #88]	; (1014a7c <init_reset+0x12c>)
 1014a24:	4816      	ldr	r0, [pc, #88]	; (1014a80 <init_reset+0x130>)
 1014a26:	f010 f8d6 	bl	1024bd6 <assert_print>
 1014a2a:	4040      	eors	r0, r0
 1014a2c:	f380 8811 	msr	BASEPRI, r0
 1014a30:	f04f 0003 	mov.w	r0, #3
 1014a34:	df02      	svc	2
 1014a36:	e7cb      	b.n	10149d0 <init_reset+0x80>
	LL_ASSERT(link);
 1014a38:	f640 03d8 	movw	r3, #2264	; 0x8d8
 1014a3c:	4a0e      	ldr	r2, [pc, #56]	; (1014a78 <init_reset+0x128>)
 1014a3e:	490f      	ldr	r1, [pc, #60]	; (1014a7c <init_reset+0x12c>)
 1014a40:	480f      	ldr	r0, [pc, #60]	; (1014a80 <init_reset+0x130>)
 1014a42:	f010 f8c8 	bl	1024bd6 <assert_print>
 1014a46:	4040      	eors	r0, r0
 1014a48:	f380 8811 	msr	BASEPRI, r0
 1014a4c:	f04f 0003 	mov.w	r0, #3
 1014a50:	df02      	svc	2
 1014a52:	e7c7      	b.n	10149e4 <init_reset+0x94>
 1014a54:	210005b0 	.word	0x210005b0
 1014a58:	21000698 	.word	0x21000698
 1014a5c:	210066d0 	.word	0x210066d0
 1014a60:	21004e64 	.word	0x21004e64
 1014a64:	21004d68 	.word	0x21004d68
 1014a68:	21004d60 	.word	0x21004d60
 1014a6c:	21004d50 	.word	0x21004d50
 1014a70:	21004d58 	.word	0x21004d58
 1014a74:	21004d64 	.word	0x21004d64
 1014a78:	0102a558 	.word	0x0102a558
 1014a7c:	0102a92c 	.word	0x0102a92c
 1014a80:	0102a278 	.word	0x0102a278

01014a84 <ll_init>:
{
 1014a84:	b530      	push	{r4, r5, lr}
	sem_recv = sem_rx;
 1014a86:	4b29      	ldr	r3, [pc, #164]	; (1014b2c <ll_init+0xa8>)
	if (!mayfly_initialized) {
 1014a88:	4c29      	ldr	r4, [pc, #164]	; (1014b30 <ll_init+0xac>)
{
 1014a8a:	b087      	sub	sp, #28
	sem_recv = sem_rx;
 1014a8c:	6018      	str	r0, [r3, #0]
	cntr_init();
 1014a8e:	f008 faa1 	bl	101cfd4 <cntr_init>
	if (!mayfly_initialized) {
 1014a92:	7823      	ldrb	r3, [r4, #0]
 1014a94:	2b00      	cmp	r3, #0
 1014a96:	d044      	beq.n	1014b22 <ll_init+0x9e>
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
 1014a98:	2405      	movs	r4, #5
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
 1014a9a:	2304      	movs	r3, #4
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 1014a9c:	210d      	movs	r1, #13
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
 1014a9e:	2002      	movs	r0, #2
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 1014aa0:	4d24      	ldr	r5, [pc, #144]	; (1014b34 <ll_init+0xb0>)
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
 1014aa2:	4a25      	ldr	r2, [pc, #148]	; (1014b38 <ll_init+0xb4>)
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 1014aa4:	9505      	str	r5, [sp, #20]
 1014aa6:	4d25      	ldr	r5, [pc, #148]	; (1014b3c <ll_init+0xb8>)
 1014aa8:	9200      	str	r2, [sp, #0]
 1014aaa:	9504      	str	r5, [sp, #16]
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
 1014aac:	7013      	strb	r3, [r2, #0]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 1014aae:	4d24      	ldr	r5, [pc, #144]	; (1014b40 <ll_init+0xbc>)
 1014ab0:	9101      	str	r1, [sp, #4]
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
 1014ab2:	7214      	strb	r4, [r2, #8]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 1014ab4:	4c23      	ldr	r4, [pc, #140]	; (1014b44 <ll_init+0xc0>)
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
 1014ab6:	7410      	strb	r0, [r2, #16]
	ticker_users[MAYFLY_CALL_ID_PROGRAM][0] = TICKER_USER_THREAD_OPS;
 1014ab8:	7610      	strb	r0, [r2, #24]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 1014aba:	2000      	movs	r0, #0
 1014abc:	e9cd 4502 	strd	r4, r5, [sp, #8]
 1014ac0:	4a21      	ldr	r2, [pc, #132]	; (1014b48 <ll_init+0xc4>)
 1014ac2:	f7fd fa4d 	bl	1011f60 <ticker_init>
	LL_ASSERT(!err);
 1014ac6:	b9f0      	cbnz	r0, 1014b06 <ll_init+0x82>
	return z_impl_k_sem_init(sem, initial_count, limit);
 1014ac8:	2201      	movs	r2, #1
 1014aca:	2100      	movs	r1, #0
 1014acc:	481f      	ldr	r0, [pc, #124]	; (1014b4c <ll_init+0xc8>)
 1014ace:	f014 fc22 	bl	1029316 <z_impl_k_sem_init>
	err = lll_init();
 1014ad2:	f006 fd0d 	bl	101b4f0 <lll_init>
	if (err) {
 1014ad6:	b108      	cbz	r0, 1014adc <ll_init+0x58>
}
 1014ad8:	b007      	add	sp, #28
 1014ada:	bd30      	pop	{r4, r5, pc}
	err = init_reset();
 1014adc:	f7ff ff38 	bl	1014950 <init_reset>
	if (err) {
 1014ae0:	2800      	cmp	r0, #0
 1014ae2:	d1f9      	bne.n	1014ad8 <ll_init+0x54>
	err = lll_adv_init();
 1014ae4:	f007 f964 	bl	101bdb0 <lll_adv_init>
	if (err) {
 1014ae8:	2800      	cmp	r0, #0
 1014aea:	d1f5      	bne.n	1014ad8 <ll_init+0x54>
	err = ull_adv_init();
 1014aec:	f000 fcdc 	bl	10154a8 <ull_adv_init>
	if (err) {
 1014af0:	2800      	cmp	r0, #0
 1014af2:	d1f1      	bne.n	1014ad8 <ll_init+0x54>
	err = lll_conn_init();
 1014af4:	f007 fd82 	bl	101c5fc <lll_conn_init>
	if (err) {
 1014af8:	2800      	cmp	r0, #0
 1014afa:	d1ed      	bne.n	1014ad8 <ll_init+0x54>
}
 1014afc:	b007      	add	sp, #28
 1014afe:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	err = ull_conn_init();
 1014b02:	f001 ba83 	b.w	101600c <ull_conn_init>
	LL_ASSERT(!err);
 1014b06:	f240 235d 	movw	r3, #605	; 0x25d
 1014b0a:	4a11      	ldr	r2, [pc, #68]	; (1014b50 <ll_init+0xcc>)
 1014b0c:	4911      	ldr	r1, [pc, #68]	; (1014b54 <ll_init+0xd0>)
 1014b0e:	4812      	ldr	r0, [pc, #72]	; (1014b58 <ll_init+0xd4>)
 1014b10:	f010 f861 	bl	1024bd6 <assert_print>
 1014b14:	4040      	eors	r0, r0
 1014b16:	f380 8811 	msr	BASEPRI, r0
 1014b1a:	f04f 0003 	mov.w	r0, #3
 1014b1e:	df02      	svc	2
 1014b20:	e7d2      	b.n	1014ac8 <ll_init+0x44>
		mayfly_init();
 1014b22:	f7fc fa09 	bl	1010f38 <mayfly_init>
		mayfly_initialized = true;
 1014b26:	2301      	movs	r3, #1
 1014b28:	7023      	strb	r3, [r4, #0]
 1014b2a:	e7b5      	b.n	1014a98 <ll_init+0x14>
 1014b2c:	210066fc 	.word	0x210066fc
 1014b30:	21008348 	.word	0x21008348
 1014b34:	0101dbf5 	.word	0x0101dbf5
 1014b38:	210069bc 	.word	0x210069bc
 1014b3c:	0101db15 	.word	0x0101db15
 1014b40:	0101dab1 	.word	0x0101dab1
 1014b44:	21006718 	.word	0x21006718
 1014b48:	210069dc 	.word	0x210069dc
 1014b4c:	21006700 	.word	0x21006700
 1014b50:	0102a558 	.word	0x0102a558
 1014b54:	0102a594 	.word	0x0102a594
 1014b58:	0102a278 	.word	0x0102a278

01014b5c <ll_reset>:
{
 1014b5c:	b510      	push	{r4, lr}
 1014b5e:	b086      	sub	sp, #24
	err = ull_adv_reset();
 1014b60:	f000 fcb2 	bl	10154c8 <ull_adv_reset>
	LL_ASSERT(!err);
 1014b64:	2800      	cmp	r0, #0
 1014b66:	d130      	bne.n	1014bca <ll_reset+0x6e>
	err = ull_conn_reset();
 1014b68:	f001 fa52 	bl	1016010 <ull_conn_reset>
	LL_ASSERT(!err);
 1014b6c:	2800      	cmp	r0, #0
 1014b6e:	d13d      	bne.n	1014bec <ll_reset+0x90>
	MFIFO_INIT(tx_ack);
 1014b70:	2400      	movs	r4, #0
 1014b72:	483a      	ldr	r0, [pc, #232]	; (1014c5c <ll_reset+0x100>)
	MFIFO_INIT(prep);
 1014b74:	493a      	ldr	r1, [pc, #232]	; (1014c60 <ll_reset+0x104>)
	MFIFO_INIT(pdu_rx_free);
 1014b76:	4a3b      	ldr	r2, [pc, #236]	; (1014c64 <ll_reset+0x108>)
	MFIFO_INIT(ll_pdu_rx_free);
 1014b78:	4b3b      	ldr	r3, [pc, #236]	; (1014c68 <ll_reset+0x10c>)
	MFIFO_INIT(tx_ack);
 1014b7a:	8084      	strh	r4, [r0, #4]
	MFIFO_INIT(prep);
 1014b7c:	808c      	strh	r4, [r1, #4]
	MFIFO_INIT(pdu_rx_free);
 1014b7e:	8094      	strh	r4, [r2, #4]
	MFIFO_INIT(ll_pdu_rx_free);
 1014b80:	809c      	strh	r4, [r3, #4]
 1014b82:	2201      	movs	r2, #1
 1014b84:	4621      	mov	r1, r4
 1014b86:	4668      	mov	r0, sp
 1014b88:	f014 fbc5 	bl	1029316 <z_impl_k_sem_init>
		mfy.param = &sem;
 1014b8c:	4b37      	ldr	r3, [pc, #220]	; (1014c6c <ll_reset+0x110>)
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
 1014b8e:	4622      	mov	r2, r4
 1014b90:	4621      	mov	r1, r4
 1014b92:	2003      	movs	r0, #3
		mfy.param = &sem;
 1014b94:	f8c3 d008 	str.w	sp, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
 1014b98:	f7fc fa24 	bl	1010fe4 <mayfly_enqueue>
		LL_ASSERT(!retval);
 1014b9c:	2800      	cmp	r0, #0
 1014b9e:	d14f      	bne.n	1014c40 <ll_reset+0xe4>
	return z_impl_k_sem_take(sem, timeout);
 1014ba0:	f04f 32ff 	mov.w	r2, #4294967295
 1014ba4:	f04f 33ff 	mov.w	r3, #4294967295
 1014ba8:	4668      	mov	r0, sp
 1014baa:	f00c fdbd 	bl	1021728 <z_impl_k_sem_take>
	err = ull_adv_reset_finalize();
 1014bae:	f000 fc91 	bl	10154d4 <ull_adv_reset_finalize>
	LL_ASSERT(!err);
 1014bb2:	2800      	cmp	r0, #0
 1014bb4:	d136      	bne.n	1014c24 <ll_reset+0xc8>
	err = init_reset();
 1014bb6:	f7ff fecb 	bl	1014950 <init_reset>
	LL_ASSERT(!err);
 1014bba:	bb28      	cbnz	r0, 1014c08 <ll_reset+0xac>
	(void)ll_addr_set(1U, NULL);
 1014bbc:	2100      	movs	r1, #0
 1014bbe:	2001      	movs	r0, #1
}
 1014bc0:	b006      	add	sp, #24
 1014bc2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void)ll_addr_set(1U, NULL);
 1014bc6:	f7fd bb69 	b.w	101229c <ll_addr_set>
	LL_ASSERT(!err);
 1014bca:	f240 3303 	movw	r3, #771	; 0x303
 1014bce:	4a28      	ldr	r2, [pc, #160]	; (1014c70 <ll_reset+0x114>)
 1014bd0:	4928      	ldr	r1, [pc, #160]	; (1014c74 <ll_reset+0x118>)
 1014bd2:	4829      	ldr	r0, [pc, #164]	; (1014c78 <ll_reset+0x11c>)
 1014bd4:	f00f ffff 	bl	1024bd6 <assert_print>
 1014bd8:	4040      	eors	r0, r0
 1014bda:	f380 8811 	msr	BASEPRI, r0
 1014bde:	f04f 0003 	mov.w	r0, #3
 1014be2:	df02      	svc	2
	err = ull_conn_reset();
 1014be4:	f001 fa14 	bl	1016010 <ull_conn_reset>
	LL_ASSERT(!err);
 1014be8:	2800      	cmp	r0, #0
 1014bea:	d0c1      	beq.n	1014b70 <ll_reset+0x14>
 1014bec:	f240 3335 	movw	r3, #821	; 0x335
 1014bf0:	4a1f      	ldr	r2, [pc, #124]	; (1014c70 <ll_reset+0x114>)
 1014bf2:	4920      	ldr	r1, [pc, #128]	; (1014c74 <ll_reset+0x118>)
 1014bf4:	4820      	ldr	r0, [pc, #128]	; (1014c78 <ll_reset+0x11c>)
 1014bf6:	f00f ffee 	bl	1024bd6 <assert_print>
 1014bfa:	4040      	eors	r0, r0
 1014bfc:	f380 8811 	msr	BASEPRI, r0
 1014c00:	f04f 0003 	mov.w	r0, #3
 1014c04:	df02      	svc	2
 1014c06:	e7b3      	b.n	1014b70 <ll_reset+0x14>
	LL_ASSERT(!err);
 1014c08:	f240 337e 	movw	r3, #894	; 0x37e
 1014c0c:	4a18      	ldr	r2, [pc, #96]	; (1014c70 <ll_reset+0x114>)
 1014c0e:	4919      	ldr	r1, [pc, #100]	; (1014c74 <ll_reset+0x118>)
 1014c10:	4819      	ldr	r0, [pc, #100]	; (1014c78 <ll_reset+0x11c>)
 1014c12:	f00f ffe0 	bl	1024bd6 <assert_print>
 1014c16:	4040      	eors	r0, r0
 1014c18:	f380 8811 	msr	BASEPRI, r0
 1014c1c:	f04f 0003 	mov.w	r0, #3
 1014c20:	df02      	svc	2
 1014c22:	e7cb      	b.n	1014bbc <ll_reset+0x60>
	LL_ASSERT(!err);
 1014c24:	f240 3371 	movw	r3, #881	; 0x371
 1014c28:	4a11      	ldr	r2, [pc, #68]	; (1014c70 <ll_reset+0x114>)
 1014c2a:	4912      	ldr	r1, [pc, #72]	; (1014c74 <ll_reset+0x118>)
 1014c2c:	4812      	ldr	r0, [pc, #72]	; (1014c78 <ll_reset+0x11c>)
 1014c2e:	f00f ffd2 	bl	1024bd6 <assert_print>
 1014c32:	4040      	eors	r0, r0
 1014c34:	f380 8811 	msr	BASEPRI, r0
 1014c38:	f04f 0003 	mov.w	r0, #3
 1014c3c:	df02      	svc	2
 1014c3e:	e7ba      	b.n	1014bb6 <ll_reset+0x5a>
		LL_ASSERT(!retval);
 1014c40:	f44f 7359 	mov.w	r3, #868	; 0x364
 1014c44:	4a0a      	ldr	r2, [pc, #40]	; (1014c70 <ll_reset+0x114>)
 1014c46:	490d      	ldr	r1, [pc, #52]	; (1014c7c <ll_reset+0x120>)
 1014c48:	480b      	ldr	r0, [pc, #44]	; (1014c78 <ll_reset+0x11c>)
 1014c4a:	f00f ffc4 	bl	1024bd6 <assert_print>
 1014c4e:	4040      	eors	r0, r0
 1014c50:	f380 8811 	msr	BASEPRI, r0
 1014c54:	f04f 0003 	mov.w	r0, #3
 1014c58:	df02      	svc	2
 1014c5a:	e7a1      	b.n	1014ba0 <ll_reset+0x44>
 1014c5c:	21000520 	.word	0x21000520
 1014c60:	210006b4 	.word	0x210006b4
 1014c64:	21000594 	.word	0x21000594
 1014c68:	21000548 	.word	0x21000548
 1014c6c:	21000510 	.word	0x21000510
 1014c70:	0102a558 	.word	0x0102a558
 1014c74:	0102a594 	.word	0x0102a594
 1014c78:	0102a278 	.word	0x0102a278
 1014c7c:	0102a6bc 	.word	0x0102a6bc

01014c80 <ll_deinit>:
{
 1014c80:	b508      	push	{r3, lr}
	ll_reset();
 1014c82:	f7ff ff6b 	bl	1014b5c <ll_reset>
}
 1014c86:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return lll_deinit();
 1014c8a:	f006 bc61 	b.w	101b550 <lll_deinit>
 1014c8e:	bf00      	nop

01014c90 <lll_prepare>:
 *	   -EINPROGRESS: Event already in progress and prepare was queued
 */
int lll_prepare(lll_is_abort_cb_t is_abort_cb, lll_abort_cb_t abort_cb,
		lll_prepare_cb_t prepare_cb, int8_t event_prio,
		struct lll_prepare_param *prepare_param)
{
 1014c90:	b510      	push	{r4, lr}
	}

	prepare_param->prio = prio;
#endif /* CONFIG_BT_CTLR_JIT_SCHEDULING */

	return lll_prepare_resolve(is_abort_cb, abort_cb, prepare_cb,
 1014c92:	2400      	movs	r4, #0
{
 1014c94:	b082      	sub	sp, #8
	return lll_prepare_resolve(is_abort_cb, abort_cb, prepare_cb,
 1014c96:	e9cd 4400 	strd	r4, r4, [sp]
 1014c9a:	9b04      	ldr	r3, [sp, #16]
 1014c9c:	f006 fe48 	bl	101b930 <lll_prepare_resolve>
				   prepare_param, 0, 0);
}
 1014ca0:	b002      	add	sp, #8
 1014ca2:	bd10      	pop	{r4, pc}

01014ca4 <lll_resume>:
{
	struct lll_event *next;
	int ret;

	next = param;
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
 1014ca4:	2201      	movs	r2, #1
{
 1014ca6:	b510      	push	{r4, lr}
 1014ca8:	b082      	sub	sp, #8
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
 1014caa:	9201      	str	r2, [sp, #4]
				  next->prepare_cb, &next->prepare_param,
				  next->is_resume, 1);
 1014cac:	7f04      	ldrb	r4, [r0, #28]
{
 1014cae:	4603      	mov	r3, r0
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
 1014cb0:	4014      	ands	r4, r2
 1014cb2:	6902      	ldr	r2, [r0, #16]
 1014cb4:	e9d0 0105 	ldrd	r0, r1, [r0, #20]
 1014cb8:	9400      	str	r4, [sp, #0]
 1014cba:	f006 fe39 	bl	101b930 <lll_prepare_resolve>
	LL_ASSERT(!ret || ret == -EINPROGRESS);
 1014cbe:	b108      	cbz	r0, 1014cc4 <lll_resume+0x20>
 1014cc0:	3077      	adds	r0, #119	; 0x77
 1014cc2:	d101      	bne.n	1014cc8 <lll_resume+0x24>
}
 1014cc4:	b002      	add	sp, #8
 1014cc6:	bd10      	pop	{r4, pc}
	LL_ASSERT(!ret || ret == -EINPROGRESS);
 1014cc8:	234c      	movs	r3, #76	; 0x4c
 1014cca:	4a06      	ldr	r2, [pc, #24]	; (1014ce4 <lll_resume+0x40>)
 1014ccc:	4906      	ldr	r1, [pc, #24]	; (1014ce8 <lll_resume+0x44>)
 1014cce:	4807      	ldr	r0, [pc, #28]	; (1014cec <lll_resume+0x48>)
 1014cd0:	f00f ff81 	bl	1024bd6 <assert_print>
 1014cd4:	4040      	eors	r0, r0
 1014cd6:	f380 8811 	msr	BASEPRI, r0
 1014cda:	f04f 0003 	mov.w	r0, #3
 1014cde:	df02      	svc	2
}
 1014ce0:	b002      	add	sp, #8
 1014ce2:	bd10      	pop	{r4, pc}
 1014ce4:	0102a6c4 	.word	0x0102a6c4
 1014ce8:	0102a708 	.word	0x0102a708
 1014cec:	0102a278 	.word	0x0102a278

01014cf0 <ticker_stop_cb>:
{
 1014cf0:	b530      	push	{r4, r5, lr}
 1014cf2:	b083      	sub	sp, #12
 1014cf4:	9d07      	ldr	r5, [sp, #28]
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
 1014cf6:	4b19      	ldr	r3, [pc, #100]	; (1014d5c <ticker_stop_cb+0x6c>)
 1014cf8:	4a19      	ldr	r2, [pc, #100]	; (1014d60 <ticker_stop_cb+0x70>)
 1014cfa:	1aeb      	subs	r3, r5, r3
 1014cfc:	fba2 2303 	umull	r2, r3, r2, r3
	LL_ASSERT(handle < BT_CTLR_ADV_SET);
 1014d00:	f413 5f7f 	tst.w	r3, #16320	; 0x3fc0
	handle = ull_adv_handle_get(adv);
 1014d04:	f3c3 1487 	ubfx	r4, r3, #6, #8
	LL_ASSERT(handle < BT_CTLR_ADV_SET);
 1014d08:	d119      	bne.n	1014d3e <ticker_stop_cb+0x4e>
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
 1014d0a:	1ca2      	adds	r2, r4, #2
 1014d0c:	4b15      	ldr	r3, [pc, #84]	; (1014d64 <ticker_stop_cb+0x74>)
 1014d0e:	2101      	movs	r1, #1
 1014d10:	2000      	movs	r0, #0
 1014d12:	9500      	str	r5, [sp, #0]
 1014d14:	b2d2      	uxtb	r2, r2
 1014d16:	f7fd fa4d 	bl	10121b4 <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 1014d1a:	f030 0302 	bics.w	r3, r0, #2
 1014d1e:	d00c      	beq.n	1014d3a <ticker_stop_cb+0x4a>
 1014d20:	f640 1374 	movw	r3, #2420	; 0x974
 1014d24:	4a10      	ldr	r2, [pc, #64]	; (1014d68 <ticker_stop_cb+0x78>)
 1014d26:	4911      	ldr	r1, [pc, #68]	; (1014d6c <ticker_stop_cb+0x7c>)
 1014d28:	4811      	ldr	r0, [pc, #68]	; (1014d70 <ticker_stop_cb+0x80>)
 1014d2a:	f00f ff54 	bl	1024bd6 <assert_print>
 1014d2e:	4040      	eors	r0, r0
 1014d30:	f380 8811 	msr	BASEPRI, r0
 1014d34:	f04f 0003 	mov.w	r0, #3
 1014d38:	df02      	svc	2
}
 1014d3a:	b003      	add	sp, #12
 1014d3c:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(handle < BT_CTLR_ADV_SET);
 1014d3e:	f640 136f 	movw	r3, #2415	; 0x96f
 1014d42:	4a09      	ldr	r2, [pc, #36]	; (1014d68 <ticker_stop_cb+0x78>)
 1014d44:	490b      	ldr	r1, [pc, #44]	; (1014d74 <ticker_stop_cb+0x84>)
 1014d46:	480a      	ldr	r0, [pc, #40]	; (1014d70 <ticker_stop_cb+0x80>)
 1014d48:	f00f ff45 	bl	1024bd6 <assert_print>
 1014d4c:	4040      	eors	r0, r0
 1014d4e:	f380 8811 	msr	BASEPRI, r0
 1014d52:	f04f 0003 	mov.w	r0, #3
 1014d56:	df02      	svc	2
 1014d58:	e7d7      	b.n	1014d0a <ticker_stop_cb+0x1a>
 1014d5a:	bf00      	nop
 1014d5c:	21006c80 	.word	0x21006c80
 1014d60:	8d3dcb09 	.word	0x8d3dcb09
 1014d64:	01014e0d 	.word	0x01014e0d
 1014d68:	0102a71c 	.word	0x0102a71c
 1014d6c:	0102a768 	.word	0x0102a768
 1014d70:	0102a278 	.word	0x0102a278
 1014d74:	0102a75c 	.word	0x0102a75c

01014d78 <disabled_cb>:
{
 1014d78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	adv = ((struct lll_hdr *)param)->parent;
 1014d7a:	6805      	ldr	r5, [r0, #0]
{
 1014d7c:	4606      	mov	r6, r0
	LL_ASSERT(adv->link_cc_free);
 1014d7e:	6e2f      	ldr	r7, [r5, #96]	; 0x60
 1014d80:	b1d7      	cbz	r7, 1014db8 <disabled_cb+0x40>
	adv->link_cc_free = NULL;
 1014d82:	2300      	movs	r3, #0
	LL_ASSERT(adv->node_rx_cc_free);
 1014d84:	6e6c      	ldr	r4, [r5, #100]	; 0x64
	adv->link_cc_free = NULL;
 1014d86:	662b      	str	r3, [r5, #96]	; 0x60
	LL_ASSERT(adv->node_rx_cc_free);
 1014d88:	b34c      	cbz	r4, 1014dde <disabled_cb+0x66>
	adv->node_rx_cc_free = NULL;
 1014d8a:	2100      	movs	r1, #0
	rx->hdr.handle = 0xffff;
 1014d8c:	f64f 73ff 	movw	r3, #65535	; 0xffff
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 1014d90:	f04f 0c17 	mov.w	ip, #23
	adv->node_rx_cc_free = NULL;
 1014d94:	6669      	str	r1, [r5, #100]	; 0x64
	memset(cc, 0x00, sizeof(struct node_rx_cc));
 1014d96:	f104 001c 	add.w	r0, r4, #28
	rx->hdr.handle = 0xffff;
 1014d9a:	80e3      	strh	r3, [r4, #6]
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 1014d9c:	f884 c004 	strb.w	ip, [r4, #4]
	memset(cc, 0x00, sizeof(struct node_rx_cc));
 1014da0:	2212      	movs	r2, #18
 1014da2:	f011 fdf2 	bl	102698a <memset>
	cc->status = BT_HCI_ERR_ADV_TIMEOUT;
 1014da6:	233c      	movs	r3, #60	; 0x3c
	rx->hdr.rx_ftr.param = param;
 1014da8:	60a6      	str	r6, [r4, #8]
	cc->status = BT_HCI_ERR_ADV_TIMEOUT;
 1014daa:	7723      	strb	r3, [r4, #28]
	ll_rx_put_sched(link, rx);
 1014dac:	4621      	mov	r1, r4
 1014dae:	4638      	mov	r0, r7
}
 1014db0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	ll_rx_put_sched(link, rx);
 1014db4:	f7ff ba92 	b.w	10142dc <ll_rx_put_sched>
	LL_ASSERT(adv->link_cc_free);
 1014db8:	f640 13bc 	movw	r3, #2492	; 0x9bc
 1014dbc:	4a0f      	ldr	r2, [pc, #60]	; (1014dfc <disabled_cb+0x84>)
 1014dbe:	4910      	ldr	r1, [pc, #64]	; (1014e00 <disabled_cb+0x88>)
 1014dc0:	4810      	ldr	r0, [pc, #64]	; (1014e04 <disabled_cb+0x8c>)
 1014dc2:	f00f ff08 	bl	1024bd6 <assert_print>
 1014dc6:	4040      	eors	r0, r0
 1014dc8:	f380 8811 	msr	BASEPRI, r0
 1014dcc:	f04f 0003 	mov.w	r0, #3
 1014dd0:	df02      	svc	2
	adv->link_cc_free = NULL;
 1014dd2:	2300      	movs	r3, #0
	LL_ASSERT(adv->node_rx_cc_free);
 1014dd4:	6e6c      	ldr	r4, [r5, #100]	; 0x64
	link = adv->link_cc_free;
 1014dd6:	6e2f      	ldr	r7, [r5, #96]	; 0x60
	adv->link_cc_free = NULL;
 1014dd8:	662b      	str	r3, [r5, #96]	; 0x60
	LL_ASSERT(adv->node_rx_cc_free);
 1014dda:	2c00      	cmp	r4, #0
 1014ddc:	d1d5      	bne.n	1014d8a <disabled_cb+0x12>
 1014dde:	f44f 631c 	mov.w	r3, #2496	; 0x9c0
 1014de2:	4a06      	ldr	r2, [pc, #24]	; (1014dfc <disabled_cb+0x84>)
 1014de4:	4908      	ldr	r1, [pc, #32]	; (1014e08 <disabled_cb+0x90>)
 1014de6:	4807      	ldr	r0, [pc, #28]	; (1014e04 <disabled_cb+0x8c>)
 1014de8:	f00f fef5 	bl	1024bd6 <assert_print>
 1014dec:	4040      	eors	r0, r0
 1014dee:	f380 8811 	msr	BASEPRI, r0
 1014df2:	f04f 0003 	mov.w	r0, #3
 1014df6:	df02      	svc	2
	rx = adv->node_rx_cc_free;
 1014df8:	6e6c      	ldr	r4, [r5, #100]	; 0x64
 1014dfa:	e7c6      	b.n	1014d8a <disabled_cb+0x12>
 1014dfc:	0102a71c 	.word	0x0102a71c
 1014e00:	0102a784 	.word	0x0102a784
 1014e04:	0102a278 	.word	0x0102a278
 1014e08:	0102a798 	.word	0x0102a798

01014e0c <ticker_stop_op_cb>:
	if (status != TICKER_STATUS_SUCCESS) {
 1014e0c:	4602      	mov	r2, r0
 1014e0e:	b100      	cbz	r0, 1014e12 <ticker_stop_op_cb+0x6>
 1014e10:	4770      	bx	lr
	mfy.param = param;
 1014e12:	4608      	mov	r0, r1
{
 1014e14:	b508      	push	{r3, lr}
	mfy.param = param;
 1014e16:	4b0b      	ldr	r3, [pc, #44]	; (1014e44 <ticker_stop_op_cb+0x38>)
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 1014e18:	2101      	movs	r1, #1
	mfy.param = param;
 1014e1a:	6098      	str	r0, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 1014e1c:	2002      	movs	r0, #2
 1014e1e:	f7fc f8e1 	bl	1010fe4 <mayfly_enqueue>
	LL_ASSERT(!ret);
 1014e22:	b900      	cbnz	r0, 1014e26 <ticker_stop_op_cb+0x1a>
}
 1014e24:	bd08      	pop	{r3, pc}
	LL_ASSERT(!ret);
 1014e26:	f44f 6319 	mov.w	r3, #2448	; 0x990
 1014e2a:	4a07      	ldr	r2, [pc, #28]	; (1014e48 <ticker_stop_op_cb+0x3c>)
 1014e2c:	4907      	ldr	r1, [pc, #28]	; (1014e4c <ticker_stop_op_cb+0x40>)
 1014e2e:	4808      	ldr	r0, [pc, #32]	; (1014e50 <ticker_stop_op_cb+0x44>)
 1014e30:	f00f fed1 	bl	1024bd6 <assert_print>
 1014e34:	4040      	eors	r0, r0
 1014e36:	f380 8811 	msr	BASEPRI, r0
 1014e3a:	f04f 0003 	mov.w	r0, #3
 1014e3e:	df02      	svc	2
}
 1014e40:	bd08      	pop	{r3, pc}
 1014e42:	bf00      	nop
 1014e44:	210007dc 	.word	0x210007dc
 1014e48:	0102a71c 	.word	0x0102a71c
 1014e4c:	0102a694 	.word	0x0102a694
 1014e50:	0102a278 	.word	0x0102a278

01014e54 <adv_disable>:
{
 1014e54:	b538      	push	{r3, r4, r5, lr}
 1014e56:	4604      	mov	r4, r0
 1014e58:	f810 3b1c 	ldrb.w	r3, [r0], #28
	if (ull_ref_get(hdr)) {
 1014e5c:	b353      	cbz	r3, 1014eb4 <adv_disable+0x60>
		mfy.param = &adv->lll;
 1014e5e:	4d17      	ldr	r5, [pc, #92]	; (1014ebc <adv_disable+0x68>)
		LL_ASSERT(!hdr->disabled_cb);
 1014e60:	6963      	ldr	r3, [r4, #20]
		mfy.param = &adv->lll;
 1014e62:	60a8      	str	r0, [r5, #8]
		LL_ASSERT(!hdr->disabled_cb);
 1014e64:	b16b      	cbz	r3, 1014e82 <adv_disable+0x2e>
 1014e66:	f640 13a5 	movw	r3, #2469	; 0x9a5
 1014e6a:	4a15      	ldr	r2, [pc, #84]	; (1014ec0 <adv_disable+0x6c>)
 1014e6c:	4915      	ldr	r1, [pc, #84]	; (1014ec4 <adv_disable+0x70>)
 1014e6e:	4816      	ldr	r0, [pc, #88]	; (1014ec8 <adv_disable+0x74>)
 1014e70:	f00f feb1 	bl	1024bd6 <assert_print>
 1014e74:	4040      	eors	r0, r0
 1014e76:	f380 8811 	msr	BASEPRI, r0
 1014e7a:	f04f 0003 	mov.w	r0, #3
 1014e7e:	df02      	svc	2
		hdr->disabled_param = mfy.param;
 1014e80:	68a8      	ldr	r0, [r5, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1014e82:	2200      	movs	r2, #0
		hdr->disabled_cb = disabled_cb;
 1014e84:	4911      	ldr	r1, [pc, #68]	; (1014ecc <adv_disable+0x78>)
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1014e86:	4b0d      	ldr	r3, [pc, #52]	; (1014ebc <adv_disable+0x68>)
		hdr->disabled_cb = disabled_cb;
 1014e88:	e9c4 1005 	strd	r1, r0, [r4, #20]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1014e8c:	2001      	movs	r0, #1
 1014e8e:	4611      	mov	r1, r2
 1014e90:	f7fc f8a8 	bl	1010fe4 <mayfly_enqueue>
		LL_ASSERT(!ret);
 1014e94:	b900      	cbnz	r0, 1014e98 <adv_disable+0x44>
}
 1014e96:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(!ret);
 1014e98:	f640 13ac 	movw	r3, #2476	; 0x9ac
 1014e9c:	4a08      	ldr	r2, [pc, #32]	; (1014ec0 <adv_disable+0x6c>)
 1014e9e:	490c      	ldr	r1, [pc, #48]	; (1014ed0 <adv_disable+0x7c>)
 1014ea0:	4809      	ldr	r0, [pc, #36]	; (1014ec8 <adv_disable+0x74>)
 1014ea2:	f00f fe98 	bl	1024bd6 <assert_print>
 1014ea6:	4040      	eors	r0, r0
 1014ea8:	f380 8811 	msr	BASEPRI, r0
 1014eac:	f04f 0003 	mov.w	r0, #3
 1014eb0:	df02      	svc	2
}
 1014eb2:	bd38      	pop	{r3, r4, r5, pc}
 1014eb4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		disabled_cb(&adv->lll);
 1014eb8:	f7ff bf5e 	b.w	1014d78 <disabled_cb>
 1014ebc:	210007cc 	.word	0x210007cc
 1014ec0:	0102a71c 	.word	0x0102a71c
 1014ec4:	0102a7b0 	.word	0x0102a7b0
 1014ec8:	0102a278 	.word	0x0102a278
 1014ecc:	01014d79 	.word	0x01014d79
 1014ed0:	0102a694 	.word	0x0102a694

01014ed4 <ticker_update_op_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 1014ed4:	b900      	cbnz	r0, 1014ed8 <ticker_update_op_cb+0x4>
 1014ed6:	4770      	bx	lr
{
 1014ed8:	b510      	push	{r4, lr}
 1014eda:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 1014edc:	f7ff fae4 	bl	10144a8 <ull_disable_mark_get>
 1014ee0:	4284      	cmp	r4, r0
 1014ee2:	d00c      	beq.n	1014efe <ticker_update_op_cb+0x2a>
 1014ee4:	f640 1361 	movw	r3, #2401	; 0x961
 1014ee8:	4a05      	ldr	r2, [pc, #20]	; (1014f00 <ticker_update_op_cb+0x2c>)
 1014eea:	4906      	ldr	r1, [pc, #24]	; (1014f04 <ticker_update_op_cb+0x30>)
 1014eec:	4806      	ldr	r0, [pc, #24]	; (1014f08 <ticker_update_op_cb+0x34>)
 1014eee:	f00f fe72 	bl	1024bd6 <assert_print>
 1014ef2:	4040      	eors	r0, r0
 1014ef4:	f380 8811 	msr	BASEPRI, r0
 1014ef8:	f04f 0003 	mov.w	r0, #3
 1014efc:	df02      	svc	2
}
 1014efe:	bd10      	pop	{r4, pc}
 1014f00:	0102a71c 	.word	0x0102a71c
 1014f04:	0102a7c4 	.word	0x0102a7c4
 1014f08:	0102a278 	.word	0x0102a278

01014f0c <init_set.constprop.0>:
	pdu->tx_addr = 0;
	pdu->rx_addr = 0;
	pdu->len = BDADDR_SIZE;
}

static void init_set(struct ll_adv_set *adv)
 1014f0c:	b500      	push	{lr}
	pdu->len = BDADDR_SIZE;
 1014f0e:	2106      	movs	r1, #6
{
	adv->interval = BT_LE_ADV_INTERVAL_DEFAULT;
 1014f10:	f44f 6e00 	mov.w	lr, #2048	; 0x800
	pdu->type = pdu_type;
 1014f14:	f04f 0c00 	mov.w	ip, #0
 1014f18:	2004      	movs	r0, #4
	adv->interval = BT_LE_ADV_INTERVAL_DEFAULT;
 1014f1a:	4b0e      	ldr	r3, [pc, #56]	; (1014f54 <init_set.constprop.0+0x48>)
#if defined(CONFIG_BT_CTLR_PRIVACY)
	adv->own_addr_type = BT_ADDR_LE_PUBLIC;
#endif /* CONFIG_BT_CTLR_PRIVACY */
	adv->lll.chan_map = BT_LE_ADV_CHAN_MAP_ALL;
 1014f1c:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
	adv->interval = BT_LE_ADV_INTERVAL_DEFAULT;
 1014f1e:	f8a3 e068 	strh.w	lr, [r3, #104]	; 0x68
	adv->lll.chan_map = BT_LE_ADV_CHAN_MAP_ALL;
 1014f22:	f422 7243 	bic.w	r2, r2, #780	; 0x30c
 1014f26:	f022 0202 	bic.w	r2, r2, #2
 1014f2a:	f042 020e 	orr.w	r2, r2, #14
 1014f2e:	849a      	strh	r2, [r3, #36]	; 0x24
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 1014f30:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 1014f34:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 1014f38:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
	pdu->type = pdu_type;
 1014f3a:	f882 c000 	strb.w	ip, [r2]
	pdu->len = BDADDR_SIZE;
 1014f3e:	7051      	strb	r1, [r2, #1]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 1014f40:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 1014f44:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 1014f48:	6b9b      	ldr	r3, [r3, #56]	; 0x38
	pdu->type = pdu_type;
 1014f4a:	7018      	strb	r0, [r3, #0]
	pdu->len = BDADDR_SIZE;
 1014f4c:	7059      	strb	r1, [r3, #1]
	init_pdu(lll_adv_data_peek(&ll_adv[0].lll), PDU_ADV_TYPE_ADV_IND);

#if !defined(CONFIG_BT_CTLR_ADV_EXT)
	init_pdu(lll_adv_scan_rsp_peek(&ll_adv[0].lll), PDU_ADV_TYPE_SCAN_RSP);
#endif /* !CONFIG_BT_CTLR_ADV_EXT */
}
 1014f4e:	f85d fb04 	ldr.w	pc, [sp], #4
 1014f52:	bf00      	nop
 1014f54:	21006c80 	.word	0x21006c80

01014f58 <conn_release.constprop.0>:
static void conn_release(struct ll_adv_set *adv)
 1014f58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct lll_conn *lll = adv->lll.conn;
 1014f5a:	4c1b      	ldr	r4, [pc, #108]	; (1014fc8 <conn_release.constprop.0+0x70>)
 1014f5c:	6a25      	ldr	r5, [r4, #32]
	LL_ASSERT(!lll->link_tx_free);
 1014f5e:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 1014f60:	b163      	cbz	r3, 1014f7c <conn_release.constprop.0+0x24>
 1014f62:	f640 13e9 	movw	r3, #2537	; 0x9e9
 1014f66:	4a19      	ldr	r2, [pc, #100]	; (1014fcc <conn_release.constprop.0+0x74>)
 1014f68:	4919      	ldr	r1, [pc, #100]	; (1014fd0 <conn_release.constprop.0+0x78>)
 1014f6a:	481a      	ldr	r0, [pc, #104]	; (1014fd4 <conn_release.constprop.0+0x7c>)
 1014f6c:	f00f fe33 	bl	1024bd6 <assert_print>
 1014f70:	4040      	eors	r0, r0
 1014f72:	f380 8811 	msr	BASEPRI, r0
 1014f76:	f04f 0003 	mov.w	r0, #3
 1014f7a:	df02      	svc	2
	link = memq_deinit(&lll->memq_tx.head, &lll->memq_tx.tail);
 1014f7c:	f105 0160 	add.w	r1, r5, #96	; 0x60
 1014f80:	f105 005c 	add.w	r0, r5, #92	; 0x5c
 1014f84:	f7fb ffac 	bl	1010ee0 <memq_deinit>
	LL_ASSERT(link);
 1014f88:	4606      	mov	r6, r0
 1014f8a:	b170      	cbz	r0, 1014faa <conn_release.constprop.0+0x52>
	adv->lll.conn = NULL;
 1014f8c:	2700      	movs	r7, #0
	ll_conn_release(lll->hdr.parent);
 1014f8e:	6828      	ldr	r0, [r5, #0]
	lll->link_tx_free = link;
 1014f90:	66ee      	str	r6, [r5, #108]	; 0x6c
	ll_conn_release(lll->hdr.parent);
 1014f92:	f000 fdc1 	bl	1015b18 <ll_conn_release>
	ll_rx_release(adv->node_rx_cc_free);
 1014f96:	6e60      	ldr	r0, [r4, #100]	; 0x64
	adv->lll.conn = NULL;
 1014f98:	6227      	str	r7, [r4, #32]
	ll_rx_release(adv->node_rx_cc_free);
 1014f9a:	f7ff f98f 	bl	10142bc <ll_rx_release>
	ll_rx_link_release(adv->link_cc_free);
 1014f9e:	6e20      	ldr	r0, [r4, #96]	; 0x60
	adv->node_rx_cc_free = NULL;
 1014fa0:	6667      	str	r7, [r4, #100]	; 0x64
	ll_rx_link_release(adv->link_cc_free);
 1014fa2:	f7ff f97f 	bl	10142a4 <ll_rx_link_release>
	adv->link_cc_free = NULL;
 1014fa6:	6627      	str	r7, [r4, #96]	; 0x60
}
 1014fa8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	LL_ASSERT(link);
 1014faa:	f640 13eb 	movw	r3, #2539	; 0x9eb
 1014fae:	4a07      	ldr	r2, [pc, #28]	; (1014fcc <conn_release.constprop.0+0x74>)
 1014fb0:	4909      	ldr	r1, [pc, #36]	; (1014fd8 <conn_release.constprop.0+0x80>)
 1014fb2:	4808      	ldr	r0, [pc, #32]	; (1014fd4 <conn_release.constprop.0+0x7c>)
 1014fb4:	f00f fe0f 	bl	1024bd6 <assert_print>
 1014fb8:	4040      	eors	r0, r0
 1014fba:	f380 8811 	msr	BASEPRI, r0
 1014fbe:	f04f 0003 	mov.w	r0, #3
 1014fc2:	df02      	svc	2
 1014fc4:	e7e2      	b.n	1014f8c <conn_release.constprop.0+0x34>
 1014fc6:	bf00      	nop
 1014fc8:	21006c80 	.word	0x21006c80
 1014fcc:	0102a71c 	.word	0x0102a71c
 1014fd0:	0102a7f4 	.word	0x0102a7f4
 1014fd4:	0102a278 	.word	0x0102a278
 1014fd8:	0102a92c 	.word	0x0102a92c

01014fdc <disable.constprop.0>:
static inline uint8_t disable(uint8_t handle)
 1014fdc:	b570      	push	{r4, r5, r6, lr}
	if (!adv || !adv->is_enabled) {
 1014fde:	4c4a      	ldr	r4, [pc, #296]	; (1015108 <disable.constprop.0+0x12c>)
static inline uint8_t disable(uint8_t handle)
 1014fe0:	b084      	sub	sp, #16
	if (!adv || !adv->is_enabled) {
 1014fe2:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
 1014fe6:	07d9      	lsls	r1, r3, #31
 1014fe8:	d552      	bpl.n	1015090 <disable.constprop.0+0xb4>
	if (adv->lll.conn) {
 1014fea:	6a23      	ldr	r3, [r4, #32]
 1014fec:	b153      	cbz	r3, 1015004 <disable.constprop.0+0x28>
		adv->lll.conn->periph.cancelled = 1U;
 1014fee:	f893 2020 	ldrb.w	r2, [r3, #32]
 1014ff2:	f042 0202 	orr.w	r2, r2, #2
 1014ff6:	f883 2020 	strb.w	r2, [r3, #32]
		if (unlikely(adv->lll.conn->periph.initiated)) {
 1014ffa:	6a23      	ldr	r3, [r4, #32]
 1014ffc:	f893 3020 	ldrb.w	r3, [r3, #32]
 1015000:	07da      	lsls	r2, r3, #31
 1015002:	d47f      	bmi.n	1015104 <disable.constprop.0+0x128>
	mark = ull_disable_mark(adv);
 1015004:	4840      	ldr	r0, [pc, #256]	; (1015108 <disable.constprop.0+0x12c>)
 1015006:	f7ff fa37 	bl	1014478 <ull_disable_mark>
	LL_ASSERT(mark == adv);
 101500a:	4284      	cmp	r4, r0
 101500c:	d00c      	beq.n	1015028 <disable.constprop.0+0x4c>
 101500e:	f640 23b4 	movw	r3, #2740	; 0xab4
 1015012:	4a3e      	ldr	r2, [pc, #248]	; (101510c <disable.constprop.0+0x130>)
 1015014:	493e      	ldr	r1, [pc, #248]	; (1015110 <disable.constprop.0+0x134>)
 1015016:	483f      	ldr	r0, [pc, #252]	; (1015114 <disable.constprop.0+0x138>)
 1015018:	f00f fddd 	bl	1024bd6 <assert_print>
 101501c:	4040      	eors	r0, r0
 101501e:	f380 8811 	msr	BASEPRI, r0
 1015022:	f04f 0003 	mov.w	r0, #3
 1015026:	df02      	svc	2
	if (adv->lll.is_hdcd) {
 1015028:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 101502c:	07db      	lsls	r3, r3, #31
 101502e:	d432      	bmi.n	1015096 <disable.constprop.0+0xba>
 1015030:	ad03      	add	r5, sp, #12
	ret_cb = TICKER_STATUS_BUSY;
 1015032:	2202      	movs	r2, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 1015034:	2103      	movs	r1, #3
 1015036:	2000      	movs	r0, #0
 1015038:	4b37      	ldr	r3, [pc, #220]	; (1015118 <disable.constprop.0+0x13c>)
 101503a:	9500      	str	r5, [sp, #0]
	ret_cb = TICKER_STATUS_BUSY;
 101503c:	9203      	str	r2, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 101503e:	f7fd f8b9 	bl	10121b4 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
 1015042:	4629      	mov	r1, r5
 1015044:	f7ff f9f0 	bl	1014428 <ull_ticker_status_take>
	if (ret) {
 1015048:	2800      	cmp	r0, #0
 101504a:	d149      	bne.n	10150e0 <disable.constprop.0+0x104>
	err = ull_disable(&adv->lll);
 101504c:	4833      	ldr	r0, [pc, #204]	; (101511c <disable.constprop.0+0x140>)
 101504e:	f7ff fa4f 	bl	10144f0 <ull_disable>
	LL_ASSERT(!err || (err == -EALREADY));
 1015052:	b108      	cbz	r0, 1015058 <disable.constprop.0+0x7c>
 1015054:	3078      	adds	r0, #120	; 0x78
 1015056:	d135      	bne.n	10150c4 <disable.constprop.0+0xe8>
	mark = ull_disable_unmark(adv);
 1015058:	482b      	ldr	r0, [pc, #172]	; (1015108 <disable.constprop.0+0x12c>)
 101505a:	f7ff fa19 	bl	1014490 <ull_disable_unmark>
	LL_ASSERT(mark == adv);
 101505e:	4284      	cmp	r4, r0
 1015060:	d00c      	beq.n	101507c <disable.constprop.0+0xa0>
 1015062:	f640 23d6 	movw	r3, #2774	; 0xad6
 1015066:	4a29      	ldr	r2, [pc, #164]	; (101510c <disable.constprop.0+0x130>)
 1015068:	4929      	ldr	r1, [pc, #164]	; (1015110 <disable.constprop.0+0x134>)
 101506a:	482a      	ldr	r0, [pc, #168]	; (1015114 <disable.constprop.0+0x138>)
 101506c:	f00f fdb3 	bl	1024bd6 <assert_print>
 1015070:	4040      	eors	r0, r0
 1015072:	f380 8811 	msr	BASEPRI, r0
 1015076:	f04f 0003 	mov.w	r0, #3
 101507a:	df02      	svc	2
	if (adv->lll.conn) {
 101507c:	6a23      	ldr	r3, [r4, #32]
 101507e:	b10b      	cbz	r3, 1015084 <disable.constprop.0+0xa8>
		conn_release(adv);
 1015080:	f7ff ff6a 	bl	1014f58 <conn_release.constprop.0>
	adv->is_enabled = 0U;
 1015084:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
 1015088:	f36f 0300 	bfc	r3, #0, #1
 101508c:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a
			return 0;
 1015090:	2000      	movs	r0, #0
}
 1015092:	b004      	add	sp, #16
 1015094:	bd70      	pop	{r4, r5, r6, pc}
		ret_cb = TICKER_STATUS_BUSY;
 1015096:	2602      	movs	r6, #2
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 1015098:	ad03      	add	r5, sp, #12
 101509a:	2103      	movs	r1, #3
 101509c:	2201      	movs	r2, #1
 101509e:	2000      	movs	r0, #0
 10150a0:	4b1d      	ldr	r3, [pc, #116]	; (1015118 <disable.constprop.0+0x13c>)
 10150a2:	9500      	str	r5, [sp, #0]
		ret_cb = TICKER_STATUS_BUSY;
 10150a4:	9603      	str	r6, [sp, #12]
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 10150a6:	f7fd f885 	bl	10121b4 <ticker_stop>
		ret = ull_ticker_status_take(ret, &ret_cb);
 10150aa:	4629      	mov	r1, r5
 10150ac:	f7ff f9bc 	bl	1014428 <ull_ticker_status_take>
		if (ret) {
 10150b0:	2800      	cmp	r0, #0
 10150b2:	d0be      	beq.n	1015032 <disable.constprop.0+0x56>
			mark = ull_disable_unmark(adv);
 10150b4:	4814      	ldr	r0, [pc, #80]	; (1015108 <disable.constprop.0+0x12c>)
 10150b6:	f7ff f9eb 	bl	1014490 <ull_disable_unmark>
			LL_ASSERT(mark == adv);
 10150ba:	4284      	cmp	r4, r0
 10150bc:	d022      	beq.n	1015104 <disable.constprop.0+0x128>
 10150be:	f640 23bf 	movw	r3, #2751	; 0xabf
 10150c2:	e014      	b.n	10150ee <disable.constprop.0+0x112>
	LL_ASSERT(!err || (err == -EALREADY));
 10150c4:	f640 23d3 	movw	r3, #2771	; 0xad3
 10150c8:	4a10      	ldr	r2, [pc, #64]	; (101510c <disable.constprop.0+0x130>)
 10150ca:	4915      	ldr	r1, [pc, #84]	; (1015120 <disable.constprop.0+0x144>)
 10150cc:	4811      	ldr	r0, [pc, #68]	; (1015114 <disable.constprop.0+0x138>)
 10150ce:	f00f fd82 	bl	1024bd6 <assert_print>
 10150d2:	4040      	eors	r0, r0
 10150d4:	f380 8811 	msr	BASEPRI, r0
 10150d8:	f04f 0003 	mov.w	r0, #3
 10150dc:	df02      	svc	2
 10150de:	e7bb      	b.n	1015058 <disable.constprop.0+0x7c>
		mark = ull_disable_unmark(adv);
 10150e0:	4809      	ldr	r0, [pc, #36]	; (1015108 <disable.constprop.0+0x12c>)
 10150e2:	f7ff f9d5 	bl	1014490 <ull_disable_unmark>
		LL_ASSERT(mark == adv);
 10150e6:	4284      	cmp	r4, r0
 10150e8:	d00c      	beq.n	1015104 <disable.constprop.0+0x128>
 10150ea:	f640 23cd 	movw	r3, #2765	; 0xacd
 10150ee:	4a07      	ldr	r2, [pc, #28]	; (101510c <disable.constprop.0+0x130>)
 10150f0:	4907      	ldr	r1, [pc, #28]	; (1015110 <disable.constprop.0+0x134>)
 10150f2:	4808      	ldr	r0, [pc, #32]	; (1015114 <disable.constprop.0+0x138>)
 10150f4:	f00f fd6f 	bl	1024bd6 <assert_print>
 10150f8:	4040      	eors	r0, r0
 10150fa:	f380 8811 	msr	BASEPRI, r0
 10150fe:	f04f 0003 	mov.w	r0, #3
 1015102:	df02      	svc	2
			return BT_HCI_ERR_CMD_DISALLOWED;
 1015104:	200c      	movs	r0, #12
 1015106:	e7c4      	b.n	1015092 <disable.constprop.0+0xb6>
 1015108:	21006c80 	.word	0x21006c80
 101510c:	0102a71c 	.word	0x0102a71c
 1015110:	0102a808 	.word	0x0102a808
 1015114:	0102a278 	.word	0x0102a278
 1015118:	010139e1 	.word	0x010139e1
 101511c:	21006c9c 	.word	0x21006c9c
 1015120:	0102a814 	.word	0x0102a814

01015124 <adv_time_get.constprop.0.isra.0>:
		if (pdu->type == PDU_ADV_TYPE_NONCONN_IND) {
 1015124:	7803      	ldrb	r3, [r0, #0]
				   rxtx_turn_us * (adv_chn_cnt - 1);
 1015126:	f102 3cff 	add.w	ip, r2, #4294967295
		if (pdu->type == PDU_ADV_TYPE_NONCONN_IND) {
 101512a:	f003 030f 	and.w	r3, r3, #15
 101512e:	2b02      	cmp	r3, #2
			time_us += BYTES2US(adv_size, PHY_1M) * adv_chn_cnt +
 1015130:	fa1f fc8c 	uxth.w	ip, ip
		if (pdu->type == PDU_ADV_TYPE_NONCONN_IND) {
 1015134:	d022      	beq.n	101517c <adv_time_get.constprop.0.isra.0+0x58>
			if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 1015136:	2b01      	cmp	r3, #1
 1015138:	d00c      	beq.n	1015154 <adv_time_get.constprop.0.isra.0+0x30>
			BYTES2US((PDU_OVERHEAD_SIZE(PHY_1M) +
 101513a:	3110      	adds	r1, #16
		const uint16_t scan_rsp_us =
 101513c:	00c9      	lsls	r1, r1, #3
			} else if (pdu->type == PDU_ADV_TYPE_ADV_IND) {
 101513e:	b18b      	cbz	r3, 1015164 <adv_time_get.constprop.0.isra.0+0x40>
			} else if (pdu->type == PDU_ADV_TYPE_SCAN_IND) {
 1015140:	2b06      	cmp	r3, #6
 1015142:	d00f      	beq.n	1015164 <adv_time_get.constprop.0.isra.0+0x40>
 1015144:	f44f 73f3 	mov.w	r3, #486	; 0x1e6
			time_us += (BYTES2US(adv_size, PHY_1M) +
 1015148:	f240 208f 	movw	r0, #655	; 0x28f
 101514c:	fb0c 0003 	mla	r0, ip, r3, r0
 1015150:	b280      	uxth	r0, r0
}
 1015152:	4770      	bx	lr
			time_us += (BYTES2US(adv_size, PHY_1M) +
 1015154:	f240 2316 	movw	r3, #534	; 0x216
 1015158:	f240 401f 	movw	r0, #1055	; 0x41f
 101515c:	fb0c 0003 	mla	r0, ip, r3, r0
 1015160:	b280      	uxth	r0, r0
}
 1015162:	4770      	bx	lr
				adv_size += pdu->len;
 1015164:	7840      	ldrb	r0, [r0, #1]
 1015166:	f201 3157 	addw	r1, r1, #855	; 0x357
 101516a:	3010      	adds	r0, #16
			time_us += (BYTES2US(adv_size, PHY_1M) +
 101516c:	00c0      	lsls	r0, r0, #3
				    rxtx_turn_us) * (adv_chn_cnt - 1) +
 101516e:	f500 73b3 	add.w	r3, r0, #358	; 0x166
 1015172:	4408      	add	r0, r1
			time_us += (BYTES2US(adv_size, PHY_1M) +
 1015174:	fb0c 0003 	mla	r0, ip, r3, r0
 1015178:	b280      	uxth	r0, r0
}
 101517a:	4770      	bx	lr
			adv_size += pdu->len;
 101517c:	7841      	ldrb	r1, [r0, #1]
			time_us += BYTES2US(adv_size, PHY_1M) * adv_chn_cnt +
 101517e:	eb0c 038c 	add.w	r3, ip, ip, lsl #2
 1015182:	ebc3 1003 	rsb	r0, r3, r3, lsl #4
 1015186:	0040      	lsls	r0, r0, #1
 1015188:	f101 0310 	add.w	r3, r1, #16
 101518c:	00db      	lsls	r3, r3, #3
 101518e:	f200 1077 	addw	r0, r0, #375	; 0x177
 1015192:	fb03 0202 	mla	r2, r3, r2, r0
 1015196:	b290      	uxth	r0, r2
 1015198:	4770      	bx	lr
 101519a:	bf00      	nop

0101519c <ticker_cb>:
	if (IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) ||
 101519c:	f64f 71ff 	movw	r1, #65535	; 0xffff
{
 10151a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) ||
 10151a4:	428b      	cmp	r3, r1
{
 10151a6:	b08a      	sub	sp, #40	; 0x28
 10151a8:	f89d 8040 	ldrb.w	r8, [sp, #64]	; 0x40
 10151ac:	9c11      	ldr	r4, [sp, #68]	; 0x44
	if (IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) ||
 10151ae:	d019      	beq.n	10151e4 <ticker_cb+0x48>
	return ++hdr->ref;
 10151b0:	461d      	mov	r5, r3
 10151b2:	7823      	ldrb	r3, [r4, #0]
 10151b4:	4607      	mov	r7, r0
 10151b6:	3301      	adds	r3, #1
 10151b8:	b2db      	uxtb	r3, r3
 10151ba:	4616      	mov	r6, r2
 10151bc:	7023      	strb	r3, [r4, #0]
		LL_ASSERT(ref);
 10151be:	2b00      	cmp	r3, #0
 10151c0:	d063      	beq.n	101528a <ticker_cb+0xee>
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 10151c2:	2200      	movs	r2, #0
		p.ticks_at_expire = ticks_at_expire;
 10151c4:	4938      	ldr	r1, [pc, #224]	; (10152a8 <ticker_cb+0x10c>)
		mfy.param = &p;
 10151c6:	4b39      	ldr	r3, [pc, #228]	; (10152ac <ticker_cb+0x110>)
	lll = &adv->lll;
 10151c8:	f104 001c 	add.w	r0, r4, #28
		p.param = lll;
 10151cc:	60c8      	str	r0, [r1, #12]
		p.remainder = remainder;
 10151ce:	e9c1 7600 	strd	r7, r6, [r1]
		p.lazy = lazy;
 10151d2:	810d      	strh	r5, [r1, #8]
		p.force = force;
 10151d4:	f881 800a 	strb.w	r8, [r1, #10]
		mfy.param = &p;
 10151d8:	6099      	str	r1, [r3, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 10151da:	2001      	movs	r0, #1
 10151dc:	4611      	mov	r1, r2
 10151de:	f7fb ff01 	bl	1010fe4 <mayfly_enqueue>
		LL_ASSERT(!ret);
 10151e2:	b938      	cbnz	r0, 10151f4 <ticker_cb+0x58>
	if (!lll->is_hdcd)
 10151e4:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
 10151e8:	f010 0501 	ands.w	r5, r0, #1
 10151ec:	d014      	beq.n	1015218 <ticker_cb+0x7c>
}
 10151ee:	b00a      	add	sp, #40	; 0x28
 10151f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LL_ASSERT(!ret);
 10151f4:	f640 132e 	movw	r3, #2350	; 0x92e
 10151f8:	4a2d      	ldr	r2, [pc, #180]	; (10152b0 <ticker_cb+0x114>)
 10151fa:	492e      	ldr	r1, [pc, #184]	; (10152b4 <ticker_cb+0x118>)
 10151fc:	482e      	ldr	r0, [pc, #184]	; (10152b8 <ticker_cb+0x11c>)
 10151fe:	f00f fcea 	bl	1024bd6 <assert_print>
 1015202:	4040      	eors	r0, r0
 1015204:	f380 8811 	msr	BASEPRI, r0
 1015208:	f04f 0003 	mov.w	r0, #3
 101520c:	df02      	svc	2
	if (!lll->is_hdcd)
 101520e:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
 1015212:	f010 0501 	ands.w	r5, r0, #1
 1015216:	d1ea      	bne.n	10151ee <ticker_cb+0x52>
	random_delay %= ticks_delay_window;
 1015218:	f240 1647 	movw	r6, #327	; 0x147
	lll_rand_isr_get(&random_delay, sizeof(random_delay));
 101521c:	2104      	movs	r1, #4
 101521e:	a809      	add	r0, sp, #36	; 0x24
 1015220:	f006 f9d8 	bl	101b5d4 <lll_rand_isr_get>
	random_delay %= ticks_delay_window;
 1015224:	9b09      	ldr	r3, [sp, #36]	; 0x24
 1015226:	4a25      	ldr	r2, [pc, #148]	; (10152bc <ticker_cb+0x120>)
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 1015228:	9406      	str	r4, [sp, #24]
	random_delay %= ticks_delay_window;
 101522a:	fba2 1203 	umull	r1, r2, r2, r3
 101522e:	1a99      	subs	r1, r3, r2
 1015230:	eb02 0251 	add.w	r2, r2, r1, lsr #1
 1015234:	0a11      	lsrs	r1, r2, #8
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
 1015236:	4a22      	ldr	r2, [pc, #136]	; (10152c0 <ticker_cb+0x124>)
	random_delay %= ticks_delay_window;
 1015238:	fb06 3311 	mls	r3, r6, r1, r3
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
 101523c:	1aa2      	subs	r2, r4, r2
 101523e:	4c21      	ldr	r4, [pc, #132]	; (10152c4 <ticker_cb+0x128>)
	random_delay += (ticks_delay_window_offset + 1);
 1015240:	3301      	adds	r3, #1
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
 1015242:	fba4 4202 	umull	r4, r2, r4, r2
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 1015246:	4c20      	ldr	r4, [pc, #128]	; (10152c8 <ticker_cb+0x12c>)
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
 1015248:	0992      	lsrs	r2, r2, #6
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 101524a:	3202      	adds	r2, #2
 101524c:	4628      	mov	r0, r5
 101524e:	2101      	movs	r1, #1
 1015250:	e9cd 5503 	strd	r5, r5, [sp, #12]
 1015254:	e9cd 5500 	strd	r5, r5, [sp]
 1015258:	9502      	str	r5, [sp, #8]
 101525a:	b2d2      	uxtb	r2, r2
 101525c:	9405      	str	r4, [sp, #20]
	random_delay += (ticks_delay_window_offset + 1);
 101525e:	9309      	str	r3, [sp, #36]	; 0x24
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 1015260:	f7fc ff8c 	bl	101217c <ticker_update>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 1015264:	f030 0302 	bics.w	r3, r0, #2
 1015268:	d0c1      	beq.n	10151ee <ticker_cb+0x52>
 101526a:	f240 73b2 	movw	r3, #1970	; 0x7b2
 101526e:	4a10      	ldr	r2, [pc, #64]	; (10152b0 <ticker_cb+0x114>)
 1015270:	4916      	ldr	r1, [pc, #88]	; (10152cc <ticker_cb+0x130>)
 1015272:	4811      	ldr	r0, [pc, #68]	; (10152b8 <ticker_cb+0x11c>)
 1015274:	f00f fcaf 	bl	1024bd6 <assert_print>
 1015278:	4040      	eors	r0, r0
 101527a:	f380 8811 	msr	BASEPRI, r0
 101527e:	f04f 0003 	mov.w	r0, #3
 1015282:	df02      	svc	2
}
 1015284:	b00a      	add	sp, #40	; 0x28
 1015286:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LL_ASSERT(ref);
 101528a:	f640 1321 	movw	r3, #2337	; 0x921
 101528e:	4a08      	ldr	r2, [pc, #32]	; (10152b0 <ticker_cb+0x114>)
 1015290:	490f      	ldr	r1, [pc, #60]	; (10152d0 <ticker_cb+0x134>)
 1015292:	4809      	ldr	r0, [pc, #36]	; (10152b8 <ticker_cb+0x11c>)
 1015294:	f00f fc9f 	bl	1024bd6 <assert_print>
 1015298:	4040      	eors	r0, r0
 101529a:	f380 8811 	msr	BASEPRI, r0
 101529e:	f04f 0003 	mov.w	r0, #3
 10152a2:	df02      	svc	2
 10152a4:	e78d      	b.n	10151c2 <ticker_cb+0x26>
 10152a6:	bf00      	nop
 10152a8:	21006c54 	.word	0x21006c54
 10152ac:	210007bc 	.word	0x210007bc
 10152b0:	0102a71c 	.word	0x0102a71c
 10152b4:	0102a694 	.word	0x0102a694
 10152b8:	0102a278 	.word	0x0102a278
 10152bc:	90d4f121 	.word	0x90d4f121
 10152c0:	21006c80 	.word	0x21006c80
 10152c4:	8d3dcb09 	.word	0x8d3dcb09
 10152c8:	01014ed5 	.word	0x01014ed5
 10152cc:	0102a830 	.word	0x0102a830
 10152d0:	0102a82c 	.word	0x0102a82c

010152d4 <ll_adv_params_set>:
{
 10152d4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (!adv || adv->is_enabled) {
 10152d8:	4c6d      	ldr	r4, [pc, #436]	; (1015490 <ll_adv_params_set+0x1bc>)
{
 10152da:	468e      	mov	lr, r1
	if (!adv || adv->is_enabled) {
 10152dc:	f894 606a 	ldrb.w	r6, [r4, #106]	; 0x6a
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
 10152e0:	496c      	ldr	r1, [pc, #432]	; (1015494 <ll_adv_params_set+0x1c0>)
{
 10152e2:	b083      	sub	sp, #12
	if (!adv || adv->is_enabled) {
 10152e4:	f016 0601 	ands.w	r6, r6, #1
{
 10152e8:	4605      	mov	r5, r0
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
 10152ea:	c903      	ldmia	r1, {r0, r1}
{
 10152ec:	f89d c02c 	ldrb.w	ip, [sp, #44]	; 0x2c
 10152f0:	f89d 8030 	ldrb.w	r8, [sp, #48]	; 0x30
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
 10152f4:	9000      	str	r0, [sp, #0]
 10152f6:	f88d 1004 	strb.w	r1, [sp, #4]
	if (!adv || adv->is_enabled) {
 10152fa:	f040 80a0 	bne.w	101543e <ll_adv_params_set+0x16a>
	if (adv_type != 0x01) {
 10152fe:	4671      	mov	r1, lr
		adv->interval = 0;
 1015300:	2901      	cmp	r1, #1
 1015302:	4628      	mov	r0, r5
 1015304:	461f      	mov	r7, r3
 1015306:	bf08      	it	eq
 1015308:	2000      	moveq	r0, #0
	pdu->type = pdu_adv_type[adv_type];
 101530a:	f10e 0308 	add.w	r3, lr, #8
 101530e:	eb0d 0103 	add.w	r1, sp, r3
 1015312:	f811 3c08 	ldrb.w	r3, [r1, #-8]
 1015316:	4615      	mov	r5, r2
	if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2) &&
 1015318:	f013 0f0e 	tst.w	r3, #14
 101531c:	bf0c      	ite	eq
 101531e:	2101      	moveq	r1, #1
 1015320:	2100      	movne	r1, #0
	adv->lll.chan_map = chan_map;
 1015322:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 1015324:	f00c 0c07 	and.w	ip, ip, #7
 1015328:	f008 0803 	and.w	r8, r8, #3
 101532c:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 1015330:	f422 7243 	bic.w	r2, r2, #780	; 0x30c
 1015334:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
 1015338:	f022 0202 	bic.w	r2, r2, #2
 101533c:	ea4c 0c02 	orr.w	ip, ip, r2
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 1015340:	f894 2029 	ldrb.w	r2, [r4, #41]	; 0x29
 1015344:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
 1015348:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 101534c:	f8d2 802c 	ldr.w	r8, [r2, #44]	; 0x2c
 1015350:	f8a4 c024 	strh.w	ip, [r4, #36]	; 0x24
	pdu_type_prev = pdu->type;
 1015354:	f898 2000 	ldrb.w	r2, [r8]
	pdu->type = pdu_adv_type[adv_type];
 1015358:	f003 030f 	and.w	r3, r3, #15
 101535c:	f022 001f 	bic.w	r0, r2, #31
 1015360:	4303      	orrs	r3, r0
 1015362:	f361 1345 	bfi	r3, r1, #5, #1
 1015366:	f888 3000 	strb.w	r3, [r8]
	if (((pdu->type == PDU_ADV_TYPE_DIRECT_IND) ||
 101536a:	f003 030f 	and.w	r3, r3, #15
 101536e:	2b01      	cmp	r3, #1
	pdu_type_prev = pdu->type;
 1015370:	f002 020f 	and.w	r2, r2, #15
	if (((pdu->type == PDU_ADV_TYPE_DIRECT_IND) ||
 1015374:	d02e      	beq.n	10153d4 <ll_adv_params_set+0x100>
	} else if (pdu->len == 0) {
 1015376:	f898 3001 	ldrb.w	r3, [r8, #1]
 101537a:	b9f3      	cbnz	r3, 10153ba <ll_adv_params_set+0xe6>
		pdu->len = BDADDR_SIZE;
 101537c:	2206      	movs	r2, #6
		pdu->tx_addr = own_addr_type & 0x1;
 101537e:	f898 3000 	ldrb.w	r3, [r8]
 1015382:	f005 0501 	and.w	r5, r5, #1
 1015386:	f365 1386 	bfi	r3, r5, #6, #1
		pdu->rx_addr = 0;
 101538a:	f36f 13c7 	bfc	r3, #7, #1
		pdu->len = BDADDR_SIZE;
 101538e:	f888 2001 	strb.w	r2, [r8, #1]
		pdu->rx_addr = 0;
 1015392:	f888 3000 	strb.w	r3, [r8]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 1015396:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 101539a:	61e4      	str	r4, [r4, #28]
 101539c:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 10153a0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
		pdu->type = PDU_ADV_TYPE_SCAN_RSP;
 10153a2:	01ad      	lsls	r5, r5, #6
		if (pdu->len == 0) {
 10153a4:	785a      	ldrb	r2, [r3, #1]
		pdu->type = PDU_ADV_TYPE_SCAN_RSP;
 10153a6:	f045 0504 	orr.w	r5, r5, #4
 10153aa:	701d      	strb	r5, [r3, #0]
		if (pdu->len == 0) {
 10153ac:	b90a      	cbnz	r2, 10153b2 <ll_adv_params_set+0xde>
			pdu->len = BDADDR_SIZE;
 10153ae:	2206      	movs	r2, #6
 10153b0:	705a      	strb	r2, [r3, #1]
}
 10153b2:	4630      	mov	r0, r6
 10153b4:	b003      	add	sp, #12
 10153b6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (((pdu_type_prev == PDU_ADV_TYPE_DIRECT_IND) ||
 10153ba:	2a01      	cmp	r2, #1
 10153bc:	d031      	beq.n	1015422 <ll_adv_params_set+0x14e>
		pdu->tx_addr = own_addr_type & 0x1;
 10153be:	f898 3000 	ldrb.w	r3, [r8]
 10153c2:	f005 0501 	and.w	r5, r5, #1
 10153c6:	f365 1386 	bfi	r3, r5, #6, #1
		pdu->rx_addr = 0;
 10153ca:	f36f 13c7 	bfc	r3, #7, #1
 10153ce:	f888 3000 	strb.w	r3, [r8]
 10153d2:	e7e0      	b.n	1015396 <ll_adv_params_set+0xc2>
	    (pdu_type_prev != PDU_ADV_TYPE_DIRECT_IND) &&
 10153d4:	2a01      	cmp	r2, #1
 10153d6:	d00f      	beq.n	10153f8 <ll_adv_params_set+0x124>
		if (pdu->len == 0U) {
 10153d8:	f898 2001 	ldrb.w	r2, [r8, #1]
 10153dc:	bba2      	cbnz	r2, 1015448 <ll_adv_params_set+0x174>
			adv->ad_data_backup.len = 0U;
 10153de:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 10153e2:	f898 3000 	ldrb.w	r3, [r8]
 10153e6:	f003 030f 	and.w	r3, r3, #15
 10153ea:	2b01      	cmp	r3, #1
 10153ec:	d004      	beq.n	10153f8 <ll_adv_params_set+0x124>
	} else if (pdu->len == 0) {
 10153ee:	f898 3001 	ldrb.w	r3, [r8, #1]
 10153f2:	2b00      	cmp	r3, #0
 10153f4:	d0c2      	beq.n	101537c <ll_adv_params_set+0xa8>
 10153f6:	e7e2      	b.n	10153be <ll_adv_params_set+0xea>
			memcpy(adv->ad_data_backup.data, pdu->adv_ind.data,
 10153f8:	f108 0908 	add.w	r9, r8, #8
		pdu->tx_addr = own_addr_type & 0x1;
 10153fc:	f898 3000 	ldrb.w	r3, [r8]
 1015400:	f005 0501 	and.w	r5, r5, #1
 1015404:	f365 1386 	bfi	r3, r5, #6, #1
		pdu->rx_addr = direct_addr_type;
 1015408:	f367 13c7 	bfi	r3, r7, #7, #1
 101540c:	f888 3000 	strb.w	r3, [r8]
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
 1015410:	4648      	mov	r0, r9
 1015412:	2206      	movs	r2, #6
 1015414:	990a      	ldr	r1, [sp, #40]	; 0x28
 1015416:	f011 faad 	bl	1026974 <memcpy>
		pdu->len = sizeof(struct pdu_adv_direct_ind);
 101541a:	230c      	movs	r3, #12
 101541c:	f888 3001 	strb.w	r3, [r8, #1]
 1015420:	e7b9      	b.n	1015396 <ll_adv_params_set+0xc2>
			memcpy(pdu->adv_ind.data, adv->ad_data_backup.data,
 1015422:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 1015426:	f104 0141 	add.w	r1, r4, #65	; 0x41
 101542a:	f108 0008 	add.w	r0, r8, #8
 101542e:	f011 faa1 	bl	1026974 <memcpy>
			pdu->len = offsetof(struct pdu_adv_adv_ind, data) +
 1015432:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 1015436:	3306      	adds	r3, #6
 1015438:	f888 3001 	strb.w	r3, [r8, #1]
 101543c:	e7bf      	b.n	10153be <ll_adv_params_set+0xea>
		return BT_HCI_ERR_CMD_DISALLOWED;
 101543e:	260c      	movs	r6, #12
}
 1015440:	4630      	mov	r0, r6
 1015442:	b003      	add	sp, #12
 1015444:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			LL_ASSERT(pdu->len >=
 1015448:	2a05      	cmp	r2, #5
 101544a:	d910      	bls.n	101546e <ll_adv_params_set+0x19a>
			adv->ad_data_backup.len = pdu->len -
 101544c:	3a06      	subs	r2, #6
 101544e:	b2d2      	uxtb	r2, r2
			memcpy(adv->ad_data_backup.data, pdu->adv_ind.data,
 1015450:	f108 0908 	add.w	r9, r8, #8
 1015454:	4649      	mov	r1, r9
 1015456:	4810      	ldr	r0, [pc, #64]	; (1015498 <ll_adv_params_set+0x1c4>)
			adv->ad_data_backup.len = pdu->len -
 1015458:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
			memcpy(adv->ad_data_backup.data, pdu->adv_ind.data,
 101545c:	f011 fa8a 	bl	1026974 <memcpy>
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 1015460:	f898 3000 	ldrb.w	r3, [r8]
 1015464:	f003 030f 	and.w	r3, r3, #15
 1015468:	2b01      	cmp	r3, #1
 101546a:	d1c0      	bne.n	10153ee <ll_adv_params_set+0x11a>
 101546c:	e7c6      	b.n	10153fc <ll_adv_params_set+0x128>
			LL_ASSERT(pdu->len >=
 101546e:	f240 13af 	movw	r3, #431	; 0x1af
 1015472:	4a0a      	ldr	r2, [pc, #40]	; (101549c <ll_adv_params_set+0x1c8>)
 1015474:	490a      	ldr	r1, [pc, #40]	; (10154a0 <ll_adv_params_set+0x1cc>)
 1015476:	480b      	ldr	r0, [pc, #44]	; (10154a4 <ll_adv_params_set+0x1d0>)
 1015478:	f00f fbad 	bl	1024bd6 <assert_print>
 101547c:	4040      	eors	r0, r0
 101547e:	f380 8811 	msr	BASEPRI, r0
 1015482:	f04f 0003 	mov.w	r0, #3
 1015486:	df02      	svc	2
			adv->ad_data_backup.len = pdu->len -
 1015488:	f898 2001 	ldrb.w	r2, [r8, #1]
 101548c:	e7de      	b.n	101544c <ll_adv_params_set+0x178>
 101548e:	bf00      	nop
 1015490:	21006c80 	.word	0x21006c80
 1015494:	01029b40 	.word	0x01029b40
 1015498:	21006cc1 	.word	0x21006cc1
 101549c:	0102a71c 	.word	0x0102a71c
 10154a0:	0102a868 	.word	0x0102a868
 10154a4:	0102a278 	.word	0x0102a278

010154a8 <ull_adv_init>:
{
 10154a8:	b510      	push	{r4, lr}
		lll_adv_data_init(&ll_adv[handle].lll.adv_data);
 10154aa:	4c06      	ldr	r4, [pc, #24]	; (10154c4 <ull_adv_init+0x1c>)
 10154ac:	4620      	mov	r0, r4
 10154ae:	f006 fcaf 	bl	101be10 <lll_adv_data_init>
		lll_adv_data_init(&ll_adv[handle].lll.scan_rsp);
 10154b2:	f104 000c 	add.w	r0, r4, #12
 10154b6:	f006 fcab 	bl	101be10 <lll_adv_data_init>
	init_set(&ll_adv[0]);
 10154ba:	f7ff fd27 	bl	1014f0c <init_set.constprop.0>
}
 10154be:	2000      	movs	r0, #0
 10154c0:	bd10      	pop	{r4, pc}
 10154c2:	bf00      	nop
 10154c4:	21006ca8 	.word	0x21006ca8

010154c8 <ull_adv_reset>:
{
 10154c8:	b508      	push	{r3, lr}
		(void)disable(handle);
 10154ca:	f7ff fd87 	bl	1014fdc <disable.constprop.0>
}
 10154ce:	2000      	movs	r0, #0
 10154d0:	bd08      	pop	{r3, pc}
 10154d2:	bf00      	nop

010154d4 <ull_adv_reset_finalize>:
{
 10154d4:	b538      	push	{r3, r4, r5, lr}
		lll_adv_data_reset(&lll->adv_data);
 10154d6:	4c09      	ldr	r4, [pc, #36]	; (10154fc <ull_adv_reset_finalize+0x28>)
		lll_adv_data_reset(&lll->scan_rsp);
 10154d8:	f104 050c 	add.w	r5, r4, #12
		lll_adv_data_reset(&lll->adv_data);
 10154dc:	4620      	mov	r0, r4
 10154de:	f006 fca7 	bl	101be30 <lll_adv_data_reset>
		lll_adv_data_reset(&lll->scan_rsp);
 10154e2:	4628      	mov	r0, r5
 10154e4:	f006 fca4 	bl	101be30 <lll_adv_data_reset>
		lll_adv_data_init(&ll_adv[handle].lll.adv_data);
 10154e8:	4620      	mov	r0, r4
 10154ea:	f006 fc91 	bl	101be10 <lll_adv_data_init>
		lll_adv_data_init(&ll_adv[handle].lll.scan_rsp);
 10154ee:	4628      	mov	r0, r5
 10154f0:	f006 fc8e 	bl	101be10 <lll_adv_data_init>
	init_set(&ll_adv[0]);
 10154f4:	f7ff fd0a 	bl	1014f0c <init_set.constprop.0>
}
 10154f8:	2000      	movs	r0, #0
 10154fa:	bd38      	pop	{r3, r4, r5, pc}
 10154fc:	21006ca8 	.word	0x21006ca8

01015500 <ull_adv_handle_get>:
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
 1015500:	4a03      	ldr	r2, [pc, #12]	; (1015510 <ull_adv_handle_get+0x10>)
 1015502:	4b04      	ldr	r3, [pc, #16]	; (1015514 <ull_adv_handle_get+0x14>)
 1015504:	1a80      	subs	r0, r0, r2
 1015506:	fba3 3000 	umull	r3, r0, r3, r0
}
 101550a:	f3c0 108f 	ubfx	r0, r0, #6, #16
 101550e:	4770      	bx	lr
 1015510:	21006c80 	.word	0x21006c80
 1015514:	8d3dcb09 	.word	0x8d3dcb09

01015518 <ull_adv_lll_handle_get>:
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
 1015518:	4a04      	ldr	r2, [pc, #16]	; (101552c <ull_adv_lll_handle_get+0x14>)
 101551a:	6800      	ldr	r0, [r0, #0]
 101551c:	4b04      	ldr	r3, [pc, #16]	; (1015530 <ull_adv_lll_handle_get+0x18>)
 101551e:	1a80      	subs	r0, r0, r2
 1015520:	fba3 3000 	umull	r3, r0, r3, r0
}
 1015524:	f3c0 108f 	ubfx	r0, r0, #6, #16
 1015528:	4770      	bx	lr
 101552a:	bf00      	nop
 101552c:	21006c80 	.word	0x21006c80
 1015530:	8d3dcb09 	.word	0x8d3dcb09

01015534 <ull_adv_is_enabled>:
	if (handle >= BT_CTLR_ADV_SET) {
 1015534:	b928      	cbnz	r0, 1015542 <ull_adv_is_enabled+0xe>
	if (!adv || !adv->is_enabled) {
 1015536:	4b04      	ldr	r3, [pc, #16]	; (1015548 <ull_adv_is_enabled+0x14>)
 1015538:	f893 006a 	ldrb.w	r0, [r3, #106]	; 0x6a
 101553c:	f000 0001 	and.w	r0, r0, #1
 1015540:	4770      	bx	lr
 1015542:	2000      	movs	r0, #0
}
 1015544:	4770      	bx	lr
 1015546:	bf00      	nop
 1015548:	21006c80 	.word	0x21006c80

0101554c <ull_adv_data_set>:
	if (len > PDU_AC_LEG_DATA_SIZE_MAX) {
 101554c:	291f      	cmp	r1, #31
 101554e:	d865      	bhi.n	101561c <ull_adv_data_set+0xd0>
{
 1015550:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 1015554:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 1015558:	460e      	mov	r6, r1
 101555a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 101555e:	6adf      	ldr	r7, [r3, #44]	; 0x2c
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
 1015560:	4605      	mov	r5, r0
 1015562:	783b      	ldrb	r3, [r7, #0]
 1015564:	4690      	mov	r8, r2
 1015566:	f003 030f 	and.w	r3, r3, #15
 101556a:	2b01      	cmp	r3, #1
{
 101556c:	b083      	sub	sp, #12
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
 101556e:	d057      	beq.n	1015620 <ull_adv_data_set+0xd4>
	return lll_adv_pdu_alloc(&lll->adv_data, idx);
 1015570:	f100 0928 	add.w	r9, r0, #40	; 0x28
 1015574:	f10d 0106 	add.w	r1, sp, #6
 1015578:	4648      	mov	r0, r9
 101557a:	f006 fccd 	bl	101bf18 <lll_adv_pdu_alloc>
 101557e:	f10d 0107 	add.w	r1, sp, #7
 1015582:	4604      	mov	r4, r0
 1015584:	4648      	mov	r0, r9
 1015586:	f006 fcc7 	bl	101bf18 <lll_adv_pdu_alloc>
		__ASSERT((idx == idx_test), "Probable AD Data Corruption.\n");
 101558a:	f89d 2006 	ldrb.w	r2, [sp, #6]
 101558e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 1015592:	429a      	cmp	r2, r3
 1015594:	d14c      	bne.n	1015630 <ull_adv_data_set+0xe4>
	pdu->rx_addr = prev->rx_addr;
 1015596:	4639      	mov	r1, r7
 1015598:	4620      	mov	r0, r4
	pdu->type = prev->type;
 101559a:	783a      	ldrb	r2, [r7, #0]
 101559c:	7823      	ldrb	r3, [r4, #0]
 101559e:	f002 020f 	and.w	r2, r2, #15
 10155a2:	f023 031f 	bic.w	r3, r3, #31
 10155a6:	4313      	orrs	r3, r2
 10155a8:	7023      	strb	r3, [r4, #0]
		pdu->chan_sel = prev->chan_sel;
 10155aa:	783b      	ldrb	r3, [r7, #0]
 10155ac:	7822      	ldrb	r2, [r4, #0]
 10155ae:	f3c3 1340 	ubfx	r3, r3, #5, #1
 10155b2:	f363 1245 	bfi	r2, r3, #5, #1
 10155b6:	7022      	strb	r2, [r4, #0]
	pdu->tx_addr = prev->tx_addr;
 10155b8:	783b      	ldrb	r3, [r7, #0]
 10155ba:	b2d2      	uxtb	r2, r2
 10155bc:	f3c3 1380 	ubfx	r3, r3, #6, #1
 10155c0:	f363 1286 	bfi	r2, r3, #6, #1
 10155c4:	7022      	strb	r2, [r4, #0]
	pdu->rx_addr = prev->rx_addr;
 10155c6:	f811 3b02 	ldrb.w	r3, [r1], #2
 10155ca:	b2d7      	uxtb	r7, r2
 10155cc:	09db      	lsrs	r3, r3, #7
 10155ce:	f363 17c7 	bfi	r7, r3, #7, #1
	memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
 10155d2:	2206      	movs	r2, #6
	pdu->rx_addr = prev->rx_addr;
 10155d4:	f800 7b02 	strb.w	r7, [r0], #2
	memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
 10155d8:	f011 f9cc 	bl	1026974 <memcpy>
	memcpy(&pdu->adv_ind.data[0], data, len);
 10155dc:	4632      	mov	r2, r6
 10155de:	4641      	mov	r1, r8
 10155e0:	f104 0008 	add.w	r0, r4, #8
	pdu->len = BDADDR_SIZE + len;
 10155e4:	3606      	adds	r6, #6
	memcpy(&pdu->adv_ind.data[0], data, len);
 10155e6:	f011 f9c5 	bl	1026974 <memcpy>
	pdu->len = BDADDR_SIZE + len;
 10155ea:	7066      	strb	r6, [r4, #1]
	if (adv->is_enabled) {
 10155ec:	f895 306a 	ldrb.w	r3, [r5, #106]	; 0x6a
 10155f0:	07db      	lsls	r3, r3, #31
 10155f2:	d407      	bmi.n	1015604 <ull_adv_data_set+0xb8>
	pdu->last = idx;
 10155f4:	f89d 3006 	ldrb.w	r3, [sp, #6]
 10155f8:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
		return 0;
 10155fc:	2000      	movs	r0, #0
}
 10155fe:	b003      	add	sp, #12
 1015600:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 1015604:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
		err = ull_adv_time_update(adv, pdu, pdu_scan);
 1015608:	4621      	mov	r1, r4
 101560a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 101560e:	4628      	mov	r0, r5
 1015610:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 1015612:	f7eb fb09 	bl	1000c28 <ull_adv_time_update>
		if (err) {
 1015616:	2800      	cmp	r0, #0
 1015618:	d0ec      	beq.n	10155f4 <ull_adv_data_set+0xa8>
 101561a:	e7f0      	b.n	10155fe <ull_adv_data_set+0xb2>
		return BT_HCI_ERR_INVALID_PARAM;
 101561c:	2012      	movs	r0, #18
}
 101561e:	4770      	bx	lr
		memcpy(adv->ad_data_backup.data, data, adv->ad_data_backup.len);
 1015620:	460a      	mov	r2, r1
		adv->ad_data_backup.len = len;
 1015622:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
		memcpy(adv->ad_data_backup.data, data, adv->ad_data_backup.len);
 1015626:	4641      	mov	r1, r8
 1015628:	3041      	adds	r0, #65	; 0x41
 101562a:	f011 f9a3 	bl	1026974 <memcpy>
		return 0;
 101562e:	e7e5      	b.n	10155fc <ull_adv_data_set+0xb0>
		__ASSERT((idx == idx_test), "Probable AD Data Corruption.\n");
 1015630:	4907      	ldr	r1, [pc, #28]	; (1015650 <ull_adv_data_set+0x104>)
 1015632:	f240 733b 	movw	r3, #1851	; 0x73b
 1015636:	4a07      	ldr	r2, [pc, #28]	; (1015654 <ull_adv_data_set+0x108>)
 1015638:	4807      	ldr	r0, [pc, #28]	; (1015658 <ull_adv_data_set+0x10c>)
 101563a:	f00f facc 	bl	1024bd6 <assert_print>
 101563e:	4807      	ldr	r0, [pc, #28]	; (101565c <ull_adv_data_set+0x110>)
 1015640:	f00f fac9 	bl	1024bd6 <assert_print>
 1015644:	f240 713b 	movw	r1, #1851	; 0x73b
 1015648:	4802      	ldr	r0, [pc, #8]	; (1015654 <ull_adv_data_set+0x108>)
 101564a:	f00f fabd 	bl	1024bc8 <assert_post_action>
 101564e:	bf00      	nop
 1015650:	0102a8a8 	.word	0x0102a8a8
 1015654:	0102a71c 	.word	0x0102a71c
 1015658:	0102a278 	.word	0x0102a278
 101565c:	0102a8bc 	.word	0x0102a8bc

01015660 <ll_adv_data_set>:
{
 1015660:	4603      	mov	r3, r0
 1015662:	460a      	mov	r2, r1
	return ull_adv_data_set(adv, len, data);
 1015664:	4801      	ldr	r0, [pc, #4]	; (101566c <ll_adv_data_set+0xc>)
 1015666:	4619      	mov	r1, r3
 1015668:	f7ff bf70 	b.w	101554c <ull_adv_data_set>
 101566c:	21006c80 	.word	0x21006c80

01015670 <ull_scan_rsp_set>:
	if (len > PDU_AC_LEG_DATA_SIZE_MAX) {
 1015670:	291f      	cmp	r1, #31
 1015672:	d860      	bhi.n	1015736 <ull_scan_rsp_set+0xc6>
{
 1015674:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1015678:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 101567c:	460f      	mov	r7, r1
 101567e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 1015682:	6b9e      	ldr	r6, [r3, #56]	; 0x38
	if (!prev) {
 1015684:	4604      	mov	r4, r0
 1015686:	4690      	mov	r8, r2
{
 1015688:	b082      	sub	sp, #8
		err = lll_adv_data_init(&adv->lll.scan_rsp);
 101568a:	f100 0534 	add.w	r5, r0, #52	; 0x34
	if (!prev) {
 101568e:	2e00      	cmp	r6, #0
 1015690:	d041      	beq.n	1015716 <ull_scan_rsp_set+0xa6>
	return lll_adv_pdu_alloc(&lll->scan_rsp, idx);
 1015692:	4628      	mov	r0, r5
 1015694:	f10d 0107 	add.w	r1, sp, #7
 1015698:	f006 fc3e 	bl	101bf18 <lll_adv_pdu_alloc>
	pdu->tx_addr = prev->tx_addr;
 101569c:	4631      	mov	r1, r6
 101569e:	4605      	mov	r5, r0
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
 10156a0:	7803      	ldrb	r3, [r0, #0]
	pdu->len = BDADDR_SIZE + len;
 10156a2:	1dbe      	adds	r6, r7, #6
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
 10156a4:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 10156a8:	f043 0304 	orr.w	r3, r3, #4
 10156ac:	7003      	strb	r3, [r0, #0]
	pdu->tx_addr = prev->tx_addr;
 10156ae:	f811 0b02 	ldrb.w	r0, [r1], #2
 10156b2:	b2db      	uxtb	r3, r3
 10156b4:	f3c0 1080 	ubfx	r0, r0, #6, #1
 10156b8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 10156bc:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 10156c0:	702b      	strb	r3, [r5, #0]
	memcpy(&pdu->scan_rsp.addr[0], &prev->scan_rsp.addr[0], BDADDR_SIZE);
 10156c2:	2206      	movs	r2, #6
	pdu->len = BDADDR_SIZE + len;
 10156c4:	706e      	strb	r6, [r5, #1]
	memcpy(&pdu->scan_rsp.addr[0], &prev->scan_rsp.addr[0], BDADDR_SIZE);
 10156c6:	1ca8      	adds	r0, r5, #2
 10156c8:	f011 f954 	bl	1026974 <memcpy>
	memcpy(&pdu->scan_rsp.data[0], data, len);
 10156cc:	463a      	mov	r2, r7
 10156ce:	4641      	mov	r1, r8
 10156d0:	f105 0008 	add.w	r0, r5, #8
 10156d4:	f011 f94e 	bl	1026974 <memcpy>
	if (adv->is_enabled) {
 10156d8:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
 10156dc:	07da      	lsls	r2, r3, #31
 10156de:	d407      	bmi.n	10156f0 <ull_scan_rsp_set+0x80>
	return 0;
 10156e0:	2000      	movs	r0, #0
	pdu->last = idx;
 10156e2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 10156e6:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 10156ea:	b002      	add	sp, #8
 10156ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if ((pdu_adv_scan->type == PDU_ADV_TYPE_ADV_IND) ||
 10156f0:	2341      	movs	r3, #65	; 0x41
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 10156f2:	f894 2029 	ldrb.w	r2, [r4, #41]	; 0x29
 10156f6:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 10156fa:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 10156fc:	780a      	ldrb	r2, [r1, #0]
 10156fe:	f002 020f 	and.w	r2, r2, #15
 1015702:	40d3      	lsrs	r3, r2
 1015704:	07db      	lsls	r3, r3, #31
 1015706:	d5eb      	bpl.n	10156e0 <ull_scan_rsp_set+0x70>
			err = ull_adv_time_update(adv, pdu_adv_scan, pdu);
 1015708:	462a      	mov	r2, r5
 101570a:	4620      	mov	r0, r4
 101570c:	f7eb fa8c 	bl	1000c28 <ull_adv_time_update>
			if (err) {
 1015710:	2800      	cmp	r0, #0
 1015712:	d0e5      	beq.n	10156e0 <ull_scan_rsp_set+0x70>
 1015714:	e7e9      	b.n	10156ea <ull_scan_rsp_set+0x7a>
		err = lll_adv_data_init(&adv->lll.scan_rsp);
 1015716:	4628      	mov	r0, r5
 1015718:	f006 fb7a 	bl	101be10 <lll_adv_data_init>
		if (err) {
 101571c:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 1015720:	d1e3      	bne.n	10156ea <ull_scan_rsp_set+0x7a>
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 1015722:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 1015726:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 101572a:	6b9e      	ldr	r6, [r3, #56]	; 0x38
	pdu->type = pdu_type;
 101572c:	2304      	movs	r3, #4
 101572e:	7033      	strb	r3, [r6, #0]
	pdu->len = BDADDR_SIZE;
 1015730:	2306      	movs	r3, #6
 1015732:	7073      	strb	r3, [r6, #1]
}
 1015734:	e7ad      	b.n	1015692 <ull_scan_rsp_set+0x22>
		return BT_HCI_ERR_INVALID_PARAM;
 1015736:	2012      	movs	r0, #18
}
 1015738:	4770      	bx	lr
 101573a:	bf00      	nop

0101573c <ll_adv_scan_rsp_set>:
{
 101573c:	4603      	mov	r3, r0
 101573e:	460a      	mov	r2, r1
	return ull_scan_rsp_set(adv, len, data);
 1015740:	4801      	ldr	r0, [pc, #4]	; (1015748 <ll_adv_scan_rsp_set+0xc>)
 1015742:	4619      	mov	r1, r3
 1015744:	f7ff bf94 	b.w	1015670 <ull_scan_rsp_set>
 1015748:	21006c80 	.word	0x21006c80

0101574c <init_reset>:
{
 101574c:	b510      	push	{r4, lr}
	mem_init(conn_pool, sizeof(struct ll_conn),
 101574e:	2208      	movs	r2, #8
 1015750:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015754:	4b12      	ldr	r3, [pc, #72]	; (10157a0 <init_reset+0x54>)
 1015756:	4813      	ldr	r0, [pc, #76]	; (10157a4 <init_reset+0x58>)
 1015758:	f7fb fb36 	bl	1010dc8 <mem_init>
	mem_init(mem_conn_tx.pool, CONN_TX_BUF_SIZE, CONN_DATA_BUFFERS,
 101575c:	4b12      	ldr	r3, [pc, #72]	; (10157a8 <init_reset+0x5c>)
 101575e:	2203      	movs	r2, #3
 1015760:	1d18      	adds	r0, r3, #4
 1015762:	f44f 7182 	mov.w	r1, #260	; 0x104
 1015766:	f7fb fb2f 	bl	1010dc8 <mem_init>
	mem_init(mem_link_tx.pool, sizeof(memq_link_t),
 101576a:	4b10      	ldr	r3, [pc, #64]	; (10157ac <init_reset+0x60>)
 101576c:	2223      	movs	r2, #35	; 0x23
 101576e:	1d18      	adds	r0, r3, #4
 1015770:	2108      	movs	r1, #8
 1015772:	f7fb fb29 	bl	1010dc8 <mem_init>
	ull_cp_init();
 1015776:	f002 fc71 	bl	101805c <ull_cp_init>
	default_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 101577a:	f04f 0c1b 	mov.w	ip, #27
	default_tx_time = PDU_DC_MAX_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 101577e:	f44f 71a4 	mov.w	r1, #328	; 0x148
	default_phy_tx |= PHY_2M;
 1015782:	2303      	movs	r3, #3
	}
}

static inline void cpr_active_reset(void)
{
	conn_upd_curr = NULL;
 1015784:	2000      	movs	r0, #0
	default_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 1015786:	4a0a      	ldr	r2, [pc, #40]	; (10157b0 <init_reset+0x64>)
 1015788:	4c0a      	ldr	r4, [pc, #40]	; (10157b4 <init_reset+0x68>)
 101578a:	f8a2 c000 	strh.w	ip, [r2]
	default_tx_time = PDU_DC_MAX_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 101578e:	4a0a      	ldr	r2, [pc, #40]	; (10157b8 <init_reset+0x6c>)
 1015790:	6020      	str	r0, [r4, #0]
 1015792:	8011      	strh	r1, [r2, #0]
	default_phy_tx |= PHY_2M;
 1015794:	4909      	ldr	r1, [pc, #36]	; (10157bc <init_reset+0x70>)
	default_phy_rx |= PHY_2M;
 1015796:	4a0a      	ldr	r2, [pc, #40]	; (10157c0 <init_reset+0x74>)
	default_phy_tx |= PHY_2M;
 1015798:	700b      	strb	r3, [r1, #0]
	default_phy_rx |= PHY_2M;
 101579a:	7013      	strb	r3, [r2, #0]
}
 101579c:	bd10      	pop	{r4, pc}
 101579e:	bf00      	nop
 10157a0:	21006d14 	.word	0x21006d14
 10157a4:	210036f0 	.word	0x210036f0
 10157a8:	21006e34 	.word	0x21006e34
 10157ac:	21006d18 	.word	0x21006d18
 10157b0:	210081d6 	.word	0x210081d6
 10157b4:	21007144 	.word	0x21007144
 10157b8:	210081d4 	.word	0x210081d4
 10157bc:	2100834a 	.word	0x2100834a
 10157c0:	21008349 	.word	0x21008349

010157c4 <tx_lll_flush>:
{
 10157c4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 10157c8:	4605      	mov	r5, r0
	conn = HDR_LLL2ULL(lll);
 10157ca:	f8d0 8000 	ldr.w	r8, [r0]
{
 10157ce:	b083      	sub	sp, #12
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
 10157d0:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 10157d4:	4931      	ldr	r1, [pc, #196]	; (101589c <tx_lll_flush+0xd8>)
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
 10157d6:	f100 065c 	add.w	r6, r0, #92	; 0x5c
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
 10157da:	4640      	mov	r0, r8
 10157dc:	f7fb fb5c 	bl	1010e98 <mem_index_get>
	lll_conn_flush(handle, lll);
 10157e0:	4629      	mov	r1, r5
 10157e2:	f006 ff19 	bl	101c618 <lll_conn_flush>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
 10157e6:	4631      	mov	r1, r6
 10157e8:	6e28      	ldr	r0, [r5, #96]	; 0x60
 10157ea:	aa01      	add	r2, sp, #4
 10157ec:	f7fb fb94 	bl	1010f18 <memq_dequeue>
	while (link) {
 10157f0:	b328      	cbz	r0, 101583e <tx_lll_flush+0x7a>
		lll_tx->handle = LLL_HANDLE_INVALID;
 10157f2:	f64f 77ff 	movw	r7, #65535	; 0xffff
 10157f6:	4c2a      	ldr	r4, [pc, #168]	; (10158a0 <tx_lll_flush+0xdc>)
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 10157f8:	f104 0908 	add.w	r9, r4, #8
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
 10157fc:	7962      	ldrb	r2, [r4, #5]
	if (last == count) {
 10157fe:	78a1      	ldrb	r1, [r4, #2]
	last = last + 1;
 1015800:	1c53      	adds	r3, r2, #1
 1015802:	b2db      	uxtb	r3, r3
		last = 0U;
 1015804:	4299      	cmp	r1, r3
 1015806:	bf08      	it	eq
 1015808:	2300      	moveq	r3, #0
 101580a:	7921      	ldrb	r1, [r4, #4]
 101580c:	f894 c000 	ldrb.w	ip, [r4]
	if (last == first) {
 1015810:	4299      	cmp	r1, r3
 1015812:	d032      	beq.n	101587a <tx_lll_flush+0xb6>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 1015814:	fb0c f202 	mul.w	r2, ip, r2
		lll_tx->node = tx;
 1015818:	9901      	ldr	r1, [sp, #4]
 101581a:	eb02 0c09 	add.w	ip, r2, r9
		lll_tx->handle = LLL_HANDLE_INVALID;
 101581e:	f829 7002 	strh.w	r7, [r9, r2]
		lll_tx->node = tx;
 1015822:	f8cc 1004 	str.w	r1, [ip, #4]
		link->next = tx->next; /* Indicates ctrl pool or data pool */
 1015826:	680a      	ldr	r2, [r1, #0]
 1015828:	6002      	str	r2, [r0, #0]
		tx->next = link;
 101582a:	9a01      	ldr	r2, [sp, #4]
 101582c:	6010      	str	r0, [r2, #0]
		link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
 101582e:	4631      	mov	r1, r6
 1015830:	6e28      	ldr	r0, [r5, #96]	; 0x60
 1015832:	aa01      	add	r2, sp, #4
	*last = idx; /* Commit: Update write index */
 1015834:	7163      	strb	r3, [r4, #5]
 1015836:	f7fb fb6f 	bl	1010f18 <memq_dequeue>
	while (link) {
 101583a:	2800      	cmp	r0, #0
 101583c:	d1de      	bne.n	10157fc <tx_lll_flush+0x38>
	LL_ASSERT(rx->hdr.link);
 101583e:	f8d8 014c 	ldr.w	r0, [r8, #332]	; 0x14c
	rx = (void *)&conn->llcp_terminate.node_rx;
 1015842:	f508 74a6 	add.w	r4, r8, #332	; 0x14c
	LL_ASSERT(rx->hdr.link);
 1015846:	b140      	cbz	r0, 101585a <tx_lll_flush+0x96>
	rx->hdr.link = NULL;
 1015848:	2300      	movs	r3, #0
	ull_rx_put_sched(link, rx);
 101584a:	4621      	mov	r1, r4
	rx->hdr.link = NULL;
 101584c:	f8c8 314c 	str.w	r3, [r8, #332]	; 0x14c
	ull_rx_put_sched(link, rx);
 1015850:	f7fe ff20 	bl	1014694 <ull_rx_put_sched>
}
 1015854:	b003      	add	sp, #12
 1015856:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	LL_ASSERT(rx->hdr.link);
 101585a:	f640 23e4 	movw	r3, #2788	; 0xae4
 101585e:	4a11      	ldr	r2, [pc, #68]	; (10158a4 <tx_lll_flush+0xe0>)
 1015860:	4911      	ldr	r1, [pc, #68]	; (10158a8 <tx_lll_flush+0xe4>)
 1015862:	4812      	ldr	r0, [pc, #72]	; (10158ac <tx_lll_flush+0xe8>)
 1015864:	f00f f9b7 	bl	1024bd6 <assert_print>
 1015868:	4040      	eors	r0, r0
 101586a:	f380 8811 	msr	BASEPRI, r0
 101586e:	f04f 0003 	mov.w	r0, #3
 1015872:	df02      	svc	2
	link = rx->hdr.link;
 1015874:	f8d8 014c 	ldr.w	r0, [r8, #332]	; 0x14c
 1015878:	e7e6      	b.n	1015848 <tx_lll_flush+0x84>
		LL_ASSERT(lll_tx);
 101587a:	f44f 632d 	mov.w	r3, #2768	; 0xad0
 101587e:	4a09      	ldr	r2, [pc, #36]	; (10158a4 <tx_lll_flush+0xe0>)
 1015880:	490b      	ldr	r1, [pc, #44]	; (10158b0 <tx_lll_flush+0xec>)
 1015882:	480a      	ldr	r0, [pc, #40]	; (10158ac <tx_lll_flush+0xe8>)
 1015884:	f00f f9a7 	bl	1024bd6 <assert_print>
 1015888:	4040      	eors	r0, r0
 101588a:	f380 8811 	msr	BASEPRI, r0
 101588e:	f04f 0003 	mov.w	r0, #3
 1015892:	df02      	svc	2
		lll_tx->handle = LLL_HANDLE_INVALID;
 1015894:	2300      	movs	r3, #0
 1015896:	801b      	strh	r3, [r3, #0]
 1015898:	deff      	udf	#255	; 0xff
 101589a:	bf00      	nop
 101589c:	210036f0 	.word	0x210036f0
 10158a0:	2100082c 	.word	0x2100082c
 10158a4:	0102a8dc 	.word	0x0102a8dc
 10158a8:	0102a924 	.word	0x0102a924
 10158ac:	0102a278 	.word	0x0102a278
 10158b0:	0102a91c 	.word	0x0102a91c

010158b4 <ticker_stop_op_cb>:
{
 10158b4:	b510      	push	{r4, lr}
 10158b6:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 10158b8:	b9b0      	cbnz	r0, 10158e8 <ticker_stop_op_cb+0x34>
	mfy.param = param;
 10158ba:	4b12      	ldr	r3, [pc, #72]	; (1015904 <ticker_stop_op_cb+0x50>)
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 10158bc:	2200      	movs	r2, #0
 10158be:	2101      	movs	r1, #1
 10158c0:	2002      	movs	r0, #2
	mfy.param = param;
 10158c2:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 10158c4:	f7fb fb8e 	bl	1010fe4 <mayfly_enqueue>
	LL_ASSERT(!ret);
 10158c8:	b900      	cbnz	r0, 10158cc <ticker_stop_op_cb+0x18>
}
 10158ca:	bd10      	pop	{r4, pc}
	LL_ASSERT(!ret);
 10158cc:	f640 238a 	movw	r3, #2698	; 0xa8a
 10158d0:	4a0d      	ldr	r2, [pc, #52]	; (1015908 <ticker_stop_op_cb+0x54>)
 10158d2:	490e      	ldr	r1, [pc, #56]	; (101590c <ticker_stop_op_cb+0x58>)
 10158d4:	480e      	ldr	r0, [pc, #56]	; (1015910 <ticker_stop_op_cb+0x5c>)
 10158d6:	f00f f97e 	bl	1024bd6 <assert_print>
 10158da:	4040      	eors	r0, r0
 10158dc:	f380 8811 	msr	BASEPRI, r0
 10158e0:	f04f 0003 	mov.w	r0, #3
 10158e4:	df02      	svc	2
}
 10158e6:	bd10      	pop	{r4, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 10158e8:	f640 2384 	movw	r3, #2692	; 0xa84
 10158ec:	4a06      	ldr	r2, [pc, #24]	; (1015908 <ticker_stop_op_cb+0x54>)
 10158ee:	4909      	ldr	r1, [pc, #36]	; (1015914 <ticker_stop_op_cb+0x60>)
 10158f0:	4807      	ldr	r0, [pc, #28]	; (1015910 <ticker_stop_op_cb+0x5c>)
 10158f2:	f00f f970 	bl	1024bd6 <assert_print>
 10158f6:	4040      	eors	r0, r0
 10158f8:	f380 8811 	msr	BASEPRI, r0
 10158fc:	f04f 0003 	mov.w	r0, #3
 1015900:	df02      	svc	2
 1015902:	e7da      	b.n	10158ba <ticker_stop_op_cb+0x6>
 1015904:	2100080c 	.word	0x2100080c
 1015908:	0102a8dc 	.word	0x0102a8dc
 101590c:	0102a694 	.word	0x0102a694
 1015910:	0102a278 	.word	0x0102a278
 1015914:	0102a934 	.word	0x0102a934

01015918 <disabled_cb>:
{
 1015918:	4601      	mov	r1, r0
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 101591a:	2200      	movs	r2, #0
{
 101591c:	b508      	push	{r3, lr}
	mfy.param = param;
 101591e:	4b0b      	ldr	r3, [pc, #44]	; (101594c <disabled_cb+0x34>)
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1015920:	2001      	movs	r0, #1
	mfy.param = param;
 1015922:	6099      	str	r1, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1015924:	4611      	mov	r1, r2
 1015926:	f7fb fb5d 	bl	1010fe4 <mayfly_enqueue>
	LL_ASSERT(!ret);
 101592a:	b900      	cbnz	r0, 101592e <disabled_cb+0x16>
}
 101592c:	bd08      	pop	{r3, pc}
	LL_ASSERT(!ret);
 101592e:	f640 23b6 	movw	r3, #2742	; 0xab6
 1015932:	4a07      	ldr	r2, [pc, #28]	; (1015950 <disabled_cb+0x38>)
 1015934:	4907      	ldr	r1, [pc, #28]	; (1015954 <disabled_cb+0x3c>)
 1015936:	4808      	ldr	r0, [pc, #32]	; (1015958 <disabled_cb+0x40>)
 1015938:	f00f f94d 	bl	1024bd6 <assert_print>
 101593c:	4040      	eors	r0, r0
 101593e:	f380 8811 	msr	BASEPRI, r0
 1015942:	f04f 0003 	mov.w	r0, #3
 1015946:	df02      	svc	2
}
 1015948:	bd08      	pop	{r3, pc}
 101594a:	bf00      	nop
 101594c:	210007ec 	.word	0x210007ec
 1015950:	0102a8dc 	.word	0x0102a8dc
 1015954:	0102a694 	.word	0x0102a694
 1015958:	0102a278 	.word	0x0102a278

0101595c <conn_disable>:
{
 101595c:	b538      	push	{r3, r4, r5, lr}
 101595e:	4604      	mov	r4, r0
	return hdr->ref;
 1015960:	f810 3b1c 	ldrb.w	r3, [r0], #28
	if (ull_ref_get(hdr)) {
 1015964:	b353      	cbz	r3, 10159bc <conn_disable+0x60>
		mfy.param = &conn->lll;
 1015966:	4d17      	ldr	r5, [pc, #92]	; (10159c4 <conn_disable+0x68>)
		LL_ASSERT(!hdr->disabled_cb);
 1015968:	6963      	ldr	r3, [r4, #20]
		mfy.param = &conn->lll;
 101596a:	60a8      	str	r0, [r5, #8]
		LL_ASSERT(!hdr->disabled_cb);
 101596c:	b16b      	cbz	r3, 101598a <conn_disable+0x2e>
 101596e:	f640 239f 	movw	r3, #2719	; 0xa9f
 1015972:	4a15      	ldr	r2, [pc, #84]	; (10159c8 <conn_disable+0x6c>)
 1015974:	4915      	ldr	r1, [pc, #84]	; (10159cc <conn_disable+0x70>)
 1015976:	4816      	ldr	r0, [pc, #88]	; (10159d0 <conn_disable+0x74>)
 1015978:	f00f f92d 	bl	1024bd6 <assert_print>
 101597c:	4040      	eors	r0, r0
 101597e:	f380 8811 	msr	BASEPRI, r0
 1015982:	f04f 0003 	mov.w	r0, #3
 1015986:	df02      	svc	2
		hdr->disabled_param = mfy.param;
 1015988:	68a8      	ldr	r0, [r5, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 101598a:	2200      	movs	r2, #0
		hdr->disabled_cb = disabled_cb;
 101598c:	4911      	ldr	r1, [pc, #68]	; (10159d4 <conn_disable+0x78>)
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 101598e:	4b0d      	ldr	r3, [pc, #52]	; (10159c4 <conn_disable+0x68>)
		hdr->disabled_cb = disabled_cb;
 1015990:	e9c4 1005 	strd	r1, r0, [r4, #20]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1015994:	2001      	movs	r0, #1
 1015996:	4611      	mov	r1, r2
 1015998:	f7fb fb24 	bl	1010fe4 <mayfly_enqueue>
		LL_ASSERT(!ret);
 101599c:	b900      	cbnz	r0, 10159a0 <conn_disable+0x44>
}
 101599e:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(!ret);
 10159a0:	f640 23a6 	movw	r3, #2726	; 0xaa6
 10159a4:	4a08      	ldr	r2, [pc, #32]	; (10159c8 <conn_disable+0x6c>)
 10159a6:	490c      	ldr	r1, [pc, #48]	; (10159d8 <conn_disable+0x7c>)
 10159a8:	4809      	ldr	r0, [pc, #36]	; (10159d0 <conn_disable+0x74>)
 10159aa:	f00f f914 	bl	1024bd6 <assert_print>
 10159ae:	4040      	eors	r0, r0
 10159b0:	f380 8811 	msr	BASEPRI, r0
 10159b4:	f04f 0003 	mov.w	r0, #3
 10159b8:	df02      	svc	2
}
 10159ba:	bd38      	pop	{r3, r4, r5, pc}
 10159bc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		disabled_cb(&conn->lll);
 10159c0:	f7ff bfaa 	b.w	1015918 <disabled_cb>
 10159c4:	210007fc 	.word	0x210007fc
 10159c8:	0102a8dc 	.word	0x0102a8dc
 10159cc:	0102a7b0 	.word	0x0102a7b0
 10159d0:	0102a278 	.word	0x0102a278
 10159d4:	01015919 	.word	0x01015919
 10159d8:	0102a694 	.word	0x0102a694

010159dc <conn_setup_adv_scan_disabled_cb>:
{
 10159dc:	b508      	push	{r3, lr}
	lll = *((struct lll_conn **)((uint8_t *)ftr->param +
 10159de:	6883      	ldr	r3, [r0, #8]
 10159e0:	685a      	ldr	r2, [r3, #4]
	switch (lll->role) {
 10159e2:	7f53      	ldrb	r3, [r2, #29]
 10159e4:	09db      	lsrs	r3, r3, #7
 10159e6:	d10d      	bne.n	1015a04 <conn_setup_adv_scan_disabled_cb+0x28>
		LL_ASSERT(0);
 10159e8:	f640 13d8 	movw	r3, #2520	; 0x9d8
 10159ec:	4a08      	ldr	r2, [pc, #32]	; (1015a10 <conn_setup_adv_scan_disabled_cb+0x34>)
 10159ee:	4909      	ldr	r1, [pc, #36]	; (1015a14 <conn_setup_adv_scan_disabled_cb+0x38>)
 10159f0:	4809      	ldr	r0, [pc, #36]	; (1015a18 <conn_setup_adv_scan_disabled_cb+0x3c>)
 10159f2:	f00f f8f0 	bl	1024bd6 <assert_print>
 10159f6:	4040      	eors	r0, r0
 10159f8:	f380 8811 	msr	BASEPRI, r0
 10159fc:	f04f 0003 	mov.w	r0, #3
 1015a00:	df02      	svc	2
}
 1015a02:	bd08      	pop	{r3, pc}
		ull_periph_setup(rx, ftr, lll);
 1015a04:	4601      	mov	r1, r0
}
 1015a06:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		ull_periph_setup(rx, ftr, lll);
 1015a0a:	3108      	adds	r1, #8
 1015a0c:	f7eb bb00 	b.w	1001010 <ull_periph_setup>
 1015a10:	0102a8dc 	.word	0x0102a8dc
 1015a14:	0102a300 	.word	0x0102a300
 1015a18:	0102a278 	.word	0x0102a278

01015a1c <ticker_update_conn_op_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 1015a1c:	b900      	cbnz	r0, 1015a20 <ticker_update_conn_op_cb+0x4>
 1015a1e:	4770      	bx	lr
{
 1015a20:	b510      	push	{r4, lr}
 1015a22:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 1015a24:	f7fe fd5e 	bl	10144e4 <ull_update_mark_get>
 1015a28:	4284      	cmp	r4, r0
 1015a2a:	d010      	beq.n	1015a4e <ticker_update_conn_op_cb+0x32>
 1015a2c:	f7fe fd3c 	bl	10144a8 <ull_disable_mark_get>
 1015a30:	4284      	cmp	r4, r0
 1015a32:	d00c      	beq.n	1015a4e <ticker_update_conn_op_cb+0x32>
 1015a34:	f640 139b 	movw	r3, #2459	; 0x99b
 1015a38:	4a05      	ldr	r2, [pc, #20]	; (1015a50 <ticker_update_conn_op_cb+0x34>)
 1015a3a:	4906      	ldr	r1, [pc, #24]	; (1015a54 <ticker_update_conn_op_cb+0x38>)
 1015a3c:	4806      	ldr	r0, [pc, #24]	; (1015a58 <ticker_update_conn_op_cb+0x3c>)
 1015a3e:	f00f f8ca 	bl	1024bd6 <assert_print>
 1015a42:	4040      	eors	r0, r0
 1015a44:	f380 8811 	msr	BASEPRI, r0
 1015a48:	f04f 0003 	mov.w	r0, #3
 1015a4c:	df02      	svc	2
}
 1015a4e:	bd10      	pop	{r4, pc}
 1015a50:	0102a8dc 	.word	0x0102a8dc
 1015a54:	0102a940 	.word	0x0102a940
 1015a58:	0102a278 	.word	0x0102a278

01015a5c <ticker_start_conn_op_cb>:
{
 1015a5c:	b510      	push	{r4, lr}
 1015a5e:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 1015a60:	b990      	cbnz	r0, 1015a88 <ticker_start_conn_op_cb+0x2c>
	p = ull_update_unmark(param);
 1015a62:	4620      	mov	r0, r4
 1015a64:	f7fe fd32 	bl	10144cc <ull_update_unmark>
	LL_ASSERT(p == param);
 1015a68:	4284      	cmp	r4, r0
 1015a6a:	d00c      	beq.n	1015a86 <ticker_start_conn_op_cb+0x2a>
 1015a6c:	f640 13b1 	movw	r3, #2481	; 0x9b1
 1015a70:	4a0c      	ldr	r2, [pc, #48]	; (1015aa4 <ticker_start_conn_op_cb+0x48>)
 1015a72:	490d      	ldr	r1, [pc, #52]	; (1015aa8 <ticker_start_conn_op_cb+0x4c>)
 1015a74:	480d      	ldr	r0, [pc, #52]	; (1015aac <ticker_start_conn_op_cb+0x50>)
 1015a76:	f00f f8ae 	bl	1024bd6 <assert_print>
 1015a7a:	4040      	eors	r0, r0
 1015a7c:	f380 8811 	msr	BASEPRI, r0
 1015a80:	f04f 0003 	mov.w	r0, #3
 1015a84:	df02      	svc	2
}
 1015a86:	bd10      	pop	{r4, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 1015a88:	f640 13ae 	movw	r3, #2478	; 0x9ae
 1015a8c:	4a05      	ldr	r2, [pc, #20]	; (1015aa4 <ticker_start_conn_op_cb+0x48>)
 1015a8e:	4908      	ldr	r1, [pc, #32]	; (1015ab0 <ticker_start_conn_op_cb+0x54>)
 1015a90:	4806      	ldr	r0, [pc, #24]	; (1015aac <ticker_start_conn_op_cb+0x50>)
 1015a92:	f00f f8a0 	bl	1024bd6 <assert_print>
 1015a96:	4040      	eors	r0, r0
 1015a98:	f380 8811 	msr	BASEPRI, r0
 1015a9c:	f04f 0003 	mov.w	r0, #3
 1015aa0:	df02      	svc	2
 1015aa2:	e7de      	b.n	1015a62 <ticker_start_conn_op_cb+0x6>
 1015aa4:	0102a8dc 	.word	0x0102a8dc
 1015aa8:	0102a994 	.word	0x0102a994
 1015aac:	0102a278 	.word	0x0102a278
 1015ab0:	0102a934 	.word	0x0102a934

01015ab4 <ticker_stop_conn_op_cb>:
{
 1015ab4:	b510      	push	{r4, lr}
 1015ab6:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 1015ab8:	b990      	cbnz	r0, 1015ae0 <ticker_stop_conn_op_cb+0x2c>
	p = ull_update_mark(param);
 1015aba:	4620      	mov	r0, r4
 1015abc:	f7fe fcfa 	bl	10144b4 <ull_update_mark>
	LL_ASSERT(p == param);
 1015ac0:	4284      	cmp	r4, r0
 1015ac2:	d00c      	beq.n	1015ade <ticker_stop_conn_op_cb+0x2a>
 1015ac4:	f640 13a7 	movw	r3, #2471	; 0x9a7
 1015ac8:	4a0c      	ldr	r2, [pc, #48]	; (1015afc <ticker_stop_conn_op_cb+0x48>)
 1015aca:	490d      	ldr	r1, [pc, #52]	; (1015b00 <ticker_stop_conn_op_cb+0x4c>)
 1015acc:	480d      	ldr	r0, [pc, #52]	; (1015b04 <ticker_stop_conn_op_cb+0x50>)
 1015ace:	f00f f882 	bl	1024bd6 <assert_print>
 1015ad2:	4040      	eors	r0, r0
 1015ad4:	f380 8811 	msr	BASEPRI, r0
 1015ad8:	f04f 0003 	mov.w	r0, #3
 1015adc:	df02      	svc	2
}
 1015ade:	bd10      	pop	{r4, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 1015ae0:	f640 13a4 	movw	r3, #2468	; 0x9a4
 1015ae4:	4a05      	ldr	r2, [pc, #20]	; (1015afc <ticker_stop_conn_op_cb+0x48>)
 1015ae6:	4908      	ldr	r1, [pc, #32]	; (1015b08 <ticker_stop_conn_op_cb+0x54>)
 1015ae8:	4806      	ldr	r0, [pc, #24]	; (1015b04 <ticker_stop_conn_op_cb+0x50>)
 1015aea:	f00f f874 	bl	1024bd6 <assert_print>
 1015aee:	4040      	eors	r0, r0
 1015af0:	f380 8811 	msr	BASEPRI, r0
 1015af4:	f04f 0003 	mov.w	r0, #3
 1015af8:	df02      	svc	2
 1015afa:	e7de      	b.n	1015aba <ticker_stop_conn_op_cb+0x6>
 1015afc:	0102a8dc 	.word	0x0102a8dc
 1015b00:	0102a994 	.word	0x0102a994
 1015b04:	0102a278 	.word	0x0102a278
 1015b08:	0102a934 	.word	0x0102a934

01015b0c <ll_conn_acquire>:
	return mem_acquire(&conn_free);
 1015b0c:	4801      	ldr	r0, [pc, #4]	; (1015b14 <ll_conn_acquire+0x8>)
 1015b0e:	f7fb b98b 	b.w	1010e28 <mem_acquire>
 1015b12:	bf00      	nop
 1015b14:	21006d14 	.word	0x21006d14

01015b18 <ll_conn_release>:
	mem_release(conn, &conn_free);
 1015b18:	4901      	ldr	r1, [pc, #4]	; (1015b20 <ll_conn_release+0x8>)
 1015b1a:	f7fb b9a1 	b.w	1010e60 <mem_release>
 1015b1e:	bf00      	nop
 1015b20:	21006d14 	.word	0x21006d14

01015b24 <ll_conn_handle_get>:
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
 1015b24:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 1015b28:	4901      	ldr	r1, [pc, #4]	; (1015b30 <ll_conn_handle_get+0xc>)
 1015b2a:	f7fb b9b5 	b.w	1010e98 <mem_index_get>
 1015b2e:	bf00      	nop
 1015b30:	210036f0 	.word	0x210036f0

01015b34 <ll_conn_get>:
{
 1015b34:	4602      	mov	r2, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015b36:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015b3a:	4801      	ldr	r0, [pc, #4]	; (1015b40 <ll_conn_get+0xc>)
 1015b3c:	f7fb b9a8 	b.w	1010e90 <mem_get>
 1015b40:	210036f0 	.word	0x210036f0

01015b44 <ll_connected_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015b44:	2807      	cmp	r0, #7
 1015b46:	d80d      	bhi.n	1015b64 <ll_connected_get+0x20>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015b48:	4602      	mov	r2, r0
{
 1015b4a:	b510      	push	{r4, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015b4c:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015b50:	4604      	mov	r4, r0
 1015b52:	4805      	ldr	r0, [pc, #20]	; (1015b68 <ll_connected_get+0x24>)
 1015b54:	f7fb f99c 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1015b58:	8d03      	ldrh	r3, [r0, #40]	; 0x28
 1015b5a:	42a3      	cmp	r3, r4
 1015b5c:	d100      	bne.n	1015b60 <ll_connected_get+0x1c>
}
 1015b5e:	bd10      	pop	{r4, pc}
		return NULL;
 1015b60:	2000      	movs	r0, #0
}
 1015b62:	bd10      	pop	{r4, pc}
		return NULL;
 1015b64:	2000      	movs	r0, #0
}
 1015b66:	4770      	bx	lr
 1015b68:	210036f0 	.word	0x210036f0

01015b6c <ll_tx_mem_acquire>:
	return mem_acquire(&mem_conn_tx.free);
 1015b6c:	4801      	ldr	r0, [pc, #4]	; (1015b74 <ll_tx_mem_acquire+0x8>)
 1015b6e:	f7fb b95b 	b.w	1010e28 <mem_acquire>
 1015b72:	bf00      	nop
 1015b74:	21006e34 	.word	0x21006e34

01015b78 <ll_tx_mem_release>:
	mem_release(tx, &mem_conn_tx.free);
 1015b78:	4901      	ldr	r1, [pc, #4]	; (1015b80 <ll_tx_mem_release+0x8>)
 1015b7a:	f7fb b971 	b.w	1010e60 <mem_release>
 1015b7e:	bf00      	nop
 1015b80:	21006e34 	.word	0x21006e34

01015b84 <ll_tx_mem_enqueue>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015b84:	2807      	cmp	r0, #7
 1015b86:	d842      	bhi.n	1015c0e <ll_tx_mem_enqueue+0x8a>
{
 1015b88:	b570      	push	{r4, r5, r6, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015b8a:	4602      	mov	r2, r0
 1015b8c:	4604      	mov	r4, r0
 1015b8e:	460e      	mov	r6, r1
 1015b90:	4820      	ldr	r0, [pc, #128]	; (1015c14 <ll_tx_mem_enqueue+0x90>)
 1015b92:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015b96:	f7fb f97b 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1015b9a:	8d03      	ldrh	r3, [r0, #40]	; 0x28
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015b9c:	4605      	mov	r5, r0
	if (conn->lll.handle != handle) {
 1015b9e:	42a3      	cmp	r3, r4
 1015ba0:	d11f      	bne.n	1015be2 <ll_tx_mem_enqueue+0x5e>
	idx = MFIFO_ENQUEUE_GET(conn_tx, (void **) &lll_tx);
 1015ba2:	4a1d      	ldr	r2, [pc, #116]	; (1015c18 <ll_tx_mem_enqueue+0x94>)
 1015ba4:	f892 c005 	ldrb.w	ip, [r2, #5]
	if (last == count) {
 1015ba8:	7891      	ldrb	r1, [r2, #2]
	last = last + 1;
 1015baa:	f10c 0301 	add.w	r3, ip, #1
 1015bae:	b2db      	uxtb	r3, r3
		last = 0U;
 1015bb0:	4299      	cmp	r1, r3
 1015bb2:	bf08      	it	eq
 1015bb4:	2300      	moveq	r3, #0
 1015bb6:	7911      	ldrb	r1, [r2, #4]
 1015bb8:	7810      	ldrb	r0, [r2, #0]
	if (last == first) {
 1015bba:	4299      	cmp	r1, r3
 1015bbc:	d024      	beq.n	1015c08 <ll_tx_mem_enqueue+0x84>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 1015bbe:	fb00 fc0c 	mul.w	ip, r0, ip
 1015bc2:	f102 0108 	add.w	r1, r2, #8
	lll_tx->handle = handle;
 1015bc6:	f821 400c 	strh.w	r4, [r1, ip]
 1015bca:	448c      	add	ip, r1
	lll_tx->node = tx;
 1015bcc:	f8cc 6004 	str.w	r6, [ip, #4]
	*last = idx; /* Commit: Update write index */
 1015bd0:	7153      	strb	r3, [r2, #5]
 1015bd2:	782b      	ldrb	r3, [r5, #0]
	if (ull_ref_get(&conn->ull)) {
 1015bd4:	b943      	cbnz	r3, 1015be8 <ll_tx_mem_enqueue+0x64>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
 1015bd6:	f995 3039 	ldrsb.w	r3, [r5, #57]	; 0x39
 1015bda:	2b00      	cmp	r3, #0
 1015bdc:	db0f      	blt.n	1015bfe <ll_tx_mem_enqueue+0x7a>
	return 0;
 1015bde:	2000      	movs	r0, #0
}
 1015be0:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
 1015be2:	f06f 0015 	mvn.w	r0, #21
}
 1015be6:	bd70      	pop	{r4, r5, r6, pc}
	mfy.param = conn;
 1015be8:	4b0c      	ldr	r3, [pc, #48]	; (1015c1c <ll_tx_mem_enqueue+0x98>)
	mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 0U, &mfy);
 1015bea:	2200      	movs	r2, #0
 1015bec:	2101      	movs	r1, #1
 1015bee:	2003      	movs	r0, #3
	mfy.param = conn;
 1015bf0:	609d      	str	r5, [r3, #8]
	mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 0U, &mfy);
 1015bf2:	f7fb f9f7 	bl	1010fe4 <mayfly_enqueue>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
 1015bf6:	f995 3039 	ldrsb.w	r3, [r5, #57]	; 0x39
 1015bfa:	2b00      	cmp	r3, #0
 1015bfc:	daef      	bge.n	1015bde <ll_tx_mem_enqueue+0x5a>
		ull_periph_latency_cancel(conn, handle);
 1015bfe:	4621      	mov	r1, r4
 1015c00:	4628      	mov	r0, r5
 1015c02:	f005 f911 	bl	101ae28 <ull_periph_latency_cancel>
 1015c06:	e7ea      	b.n	1015bde <ll_tx_mem_enqueue+0x5a>
		return -ENOBUFS;
 1015c08:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
 1015c0c:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
 1015c0e:	f06f 0015 	mvn.w	r0, #21
}
 1015c12:	4770      	bx	lr
 1015c14:	210036f0 	.word	0x210036f0
 1015c18:	21000954 	.word	0x21000954
 1015c1c:	2100081c 	.word	0x2100081c

01015c20 <ll_conn_update>:
{
 1015c20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015c24:	2807      	cmp	r0, #7
{
 1015c26:	b085      	sub	sp, #20
 1015c28:	f8bd 9038 	ldrh.w	r9, [sp, #56]	; 0x38
 1015c2c:	f8bd a03c 	ldrh.w	sl, [sp, #60]	; 0x3c
 1015c30:	f8bd b040 	ldrh.w	fp, [sp, #64]	; 0x40
 1015c34:	9203      	str	r2, [sp, #12]
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015c36:	d814      	bhi.n	1015c62 <ll_conn_update+0x42>
 1015c38:	4604      	mov	r4, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015c3a:	4602      	mov	r2, r0
 1015c3c:	460d      	mov	r5, r1
 1015c3e:	481b      	ldr	r0, [pc, #108]	; (1015cac <ll_conn_update+0x8c>)
 1015c40:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015c44:	461e      	mov	r6, r3
 1015c46:	f7fb f923 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1015c4a:	f8b0 8028 	ldrh.w	r8, [r0, #40]	; 0x28
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015c4e:	4607      	mov	r7, r0
	if (conn->lll.handle != handle) {
 1015c50:	45a0      	cmp	r8, r4
 1015c52:	d106      	bne.n	1015c62 <ll_conn_update+0x42>
	if (cmd == 0U) {
 1015c54:	b175      	cbz	r5, 1015c74 <ll_conn_update+0x54>
	} else if (cmd == 2U) {
 1015c56:	2d02      	cmp	r5, #2
 1015c58:	d007      	beq.n	1015c6a <ll_conn_update+0x4a>
		return BT_HCI_ERR_UNKNOWN_CMD;
 1015c5a:	2001      	movs	r0, #1
}
 1015c5c:	b005      	add	sp, #20
 1015c5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015c62:	2002      	movs	r0, #2
}
 1015c64:	b005      	add	sp, #20
 1015c66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (status == 0U) {
 1015c6a:	9b03      	ldr	r3, [sp, #12]
 1015c6c:	b9ab      	cbnz	r3, 1015c9a <ll_conn_update+0x7a>
			ull_cp_conn_param_req_reply(conn);
 1015c6e:	f002 fc0f 	bl	1018490 <ull_cp_conn_param_req_reply>
 1015c72:	e00e      	b.n	1015c92 <ll_conn_update+0x72>
		err = ull_cp_conn_update(conn, interval_min, interval_max, latency, timeout,
 1015c74:	9c11      	ldr	r4, [sp, #68]	; 0x44
 1015c76:	4653      	mov	r3, sl
 1015c78:	464a      	mov	r2, r9
 1015c7a:	4631      	mov	r1, r6
 1015c7c:	f8cd b000 	str.w	fp, [sp]
 1015c80:	9401      	str	r4, [sp, #4]
 1015c82:	f002 fb7d 	bl	1018380 <ull_cp_conn_update>
		if (err) {
 1015c86:	2800      	cmp	r0, #0
 1015c88:	d1ec      	bne.n	1015c64 <ll_conn_update+0x44>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
 1015c8a:	f997 3039 	ldrsb.w	r3, [r7, #57]	; 0x39
 1015c8e:	2b00      	cmp	r3, #0
 1015c90:	db07      	blt.n	1015ca2 <ll_conn_update+0x82>
		return BT_HCI_ERR_SUCCESS;
 1015c92:	2000      	movs	r0, #0
}
 1015c94:	b005      	add	sp, #20
 1015c96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ull_cp_conn_param_req_neg_reply(conn, status);
 1015c9a:	9903      	ldr	r1, [sp, #12]
 1015c9c:	f002 fc08 	bl	10184b0 <ull_cp_conn_param_req_neg_reply>
 1015ca0:	e7f7      	b.n	1015c92 <ll_conn_update+0x72>
			ull_periph_latency_cancel(conn, handle);
 1015ca2:	4641      	mov	r1, r8
 1015ca4:	4638      	mov	r0, r7
 1015ca6:	f005 f8bf 	bl	101ae28 <ull_periph_latency_cancel>
 1015caa:	e7f2      	b.n	1015c92 <ll_conn_update+0x72>
 1015cac:	210036f0 	.word	0x210036f0

01015cb0 <ll_chm_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015cb0:	2807      	cmp	r0, #7
 1015cb2:	d81d      	bhi.n	1015cf0 <ll_chm_get+0x40>
{
 1015cb4:	b570      	push	{r4, r5, r6, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015cb6:	4602      	mov	r2, r0
 1015cb8:	4604      	mov	r4, r0
 1015cba:	460d      	mov	r5, r1
 1015cbc:	480d      	ldr	r0, [pc, #52]	; (1015cf4 <ll_chm_get+0x44>)
 1015cbe:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015cc2:	f7fb f8e5 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1015cc6:	8d03      	ldrh	r3, [r0, #40]	; 0x28
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015cc8:	4606      	mov	r6, r0
	if (conn->lll.handle != handle) {
 1015cca:	42a3      	cmp	r3, r4
 1015ccc:	d109      	bne.n	1015ce2 <ll_chm_get+0x32>
	pending_chm = ull_cp_chan_map_update_pending(conn);
 1015cce:	f002 faf7 	bl	10182c0 <ull_cp_chan_map_update_pending>
	if (pending_chm) {
 1015cd2:	4601      	mov	r1, r0
		memcpy(chm, pending_chm, sizeof(conn->lll.data_chan_map));
 1015cd4:	2205      	movs	r2, #5
 1015cd6:	4628      	mov	r0, r5
	if (pending_chm) {
 1015cd8:	b129      	cbz	r1, 1015ce6 <ll_chm_get+0x36>
		memcpy(chm, pending_chm, sizeof(conn->lll.data_chan_map));
 1015cda:	f010 fe4b 	bl	1026974 <memcpy>
	return 0;
 1015cde:	2000      	movs	r0, #0
}
 1015ce0:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015ce2:	2002      	movs	r0, #2
}
 1015ce4:	bd70      	pop	{r4, r5, r6, pc}
		memcpy(chm, conn->lll.data_chan_map, sizeof(conn->lll.data_chan_map));
 1015ce6:	f106 0134 	add.w	r1, r6, #52	; 0x34
 1015cea:	f010 fe43 	bl	1026974 <memcpy>
 1015cee:	e7f6      	b.n	1015cde <ll_chm_get+0x2e>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015cf0:	2002      	movs	r0, #2
}
 1015cf2:	4770      	bx	lr
 1015cf4:	210036f0 	.word	0x210036f0

01015cf8 <ll_terminate_ind_send>:
	if (IS_ACL_HANDLE(handle)) {
 1015cf8:	2807      	cmp	r0, #7
{
 1015cfa:	b570      	push	{r4, r5, r6, lr}
	if (IS_ACL_HANDLE(handle)) {
 1015cfc:	d902      	bls.n	1015d04 <ll_terminate_ind_send+0xc>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015cfe:	2402      	movs	r4, #2
}
 1015d00:	4620      	mov	r0, r4
 1015d02:	bd70      	pop	{r4, r5, r6, pc}
 1015d04:	4605      	mov	r5, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015d06:	4602      	mov	r2, r0
 1015d08:	460c      	mov	r4, r1
 1015d0a:	4815      	ldr	r0, [pc, #84]	; (1015d60 <ll_terminate_ind_send+0x68>)
 1015d0c:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015d10:	f7fb f8be 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1015d14:	8d03      	ldrh	r3, [r0, #40]	; 0x28
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015d16:	4606      	mov	r6, r0
	if (conn->lll.handle != handle) {
 1015d18:	42ab      	cmp	r3, r5
 1015d1a:	d11f      	bne.n	1015d5c <ll_terminate_ind_send+0x64>
	switch (reason) {
 1015d1c:	2c1a      	cmp	r4, #26
 1015d1e:	d804      	bhi.n	1015d2a <ll_terminate_ind_send+0x32>
 1015d20:	2c04      	cmp	r4, #4
 1015d22:	d816      	bhi.n	1015d52 <ll_terminate_ind_send+0x5a>
 1015d24:	2412      	movs	r4, #18
}
 1015d26:	4620      	mov	r0, r4
 1015d28:	bd70      	pop	{r4, r5, r6, pc}
	switch (reason) {
 1015d2a:	2c29      	cmp	r4, #41	; 0x29
 1015d2c:	d001      	beq.n	1015d32 <ll_terminate_ind_send+0x3a>
 1015d2e:	2c3b      	cmp	r4, #59	; 0x3b
 1015d30:	d1f8      	bne.n	1015d24 <ll_terminate_ind_send+0x2c>
		err = ull_cp_terminate(conn, reason);
 1015d32:	4621      	mov	r1, r4
 1015d34:	4630      	mov	r0, r6
 1015d36:	f002 fab1 	bl	101829c <ull_cp_terminate>
		if (err) {
 1015d3a:	4604      	mov	r4, r0
 1015d3c:	2800      	cmp	r0, #0
 1015d3e:	d1df      	bne.n	1015d00 <ll_terminate_ind_send+0x8>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
 1015d40:	f996 3039 	ldrsb.w	r3, [r6, #57]	; 0x39
 1015d44:	2b00      	cmp	r3, #0
 1015d46:	dadb      	bge.n	1015d00 <ll_terminate_ind_send+0x8>
			ull_periph_latency_cancel(conn, handle);
 1015d48:	4629      	mov	r1, r5
 1015d4a:	4630      	mov	r0, r6
 1015d4c:	f005 f86c 	bl	101ae28 <ull_periph_latency_cancel>
 1015d50:	e7d6      	b.n	1015d00 <ll_terminate_ind_send+0x8>
	switch (reason) {
 1015d52:	4b04      	ldr	r3, [pc, #16]	; (1015d64 <ll_terminate_ind_send+0x6c>)
 1015d54:	40e3      	lsrs	r3, r4
 1015d56:	07db      	lsls	r3, r3, #31
 1015d58:	d4eb      	bmi.n	1015d32 <ll_terminate_ind_send+0x3a>
 1015d5a:	e7e3      	b.n	1015d24 <ll_terminate_ind_send+0x2c>
			return BT_HCI_ERR_CMD_DISALLOWED;
 1015d5c:	240c      	movs	r4, #12
 1015d5e:	e7cf      	b.n	1015d00 <ll_terminate_ind_send+0x8>
 1015d60:	210036f0 	.word	0x210036f0
 1015d64:	04380020 	.word	0x04380020

01015d68 <ll_feature_req_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015d68:	2807      	cmp	r0, #7
{
 1015d6a:	b570      	push	{r4, r5, r6, lr}
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015d6c:	d814      	bhi.n	1015d98 <ll_feature_req_send+0x30>
 1015d6e:	4604      	mov	r4, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015d70:	4602      	mov	r2, r0
 1015d72:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015d76:	480d      	ldr	r0, [pc, #52]	; (1015dac <ll_feature_req_send+0x44>)
 1015d78:	f7fb f88a 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1015d7c:	8d06      	ldrh	r6, [r0, #40]	; 0x28
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015d7e:	4605      	mov	r5, r0
	if (conn->lll.handle != handle) {
 1015d80:	42a6      	cmp	r6, r4
 1015d82:	d109      	bne.n	1015d98 <ll_feature_req_send+0x30>
	err = ull_cp_feature_exchange(conn);
 1015d84:	f002 fa4a 	bl	101821c <ull_cp_feature_exchange>
	if (err) {
 1015d88:	4604      	mov	r4, r0
 1015d8a:	b918      	cbnz	r0, 1015d94 <ll_feature_req_send+0x2c>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
 1015d8c:	f995 3039 	ldrsb.w	r3, [r5, #57]	; 0x39
 1015d90:	2b00      	cmp	r3, #0
 1015d92:	db04      	blt.n	1015d9e <ll_feature_req_send+0x36>
}
 1015d94:	4620      	mov	r0, r4
 1015d96:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015d98:	2402      	movs	r4, #2
}
 1015d9a:	4620      	mov	r0, r4
 1015d9c:	bd70      	pop	{r4, r5, r6, pc}
		ull_periph_latency_cancel(conn, handle);
 1015d9e:	4628      	mov	r0, r5
 1015da0:	4631      	mov	r1, r6
 1015da2:	f005 f841 	bl	101ae28 <ull_periph_latency_cancel>
}
 1015da6:	4620      	mov	r0, r4
 1015da8:	bd70      	pop	{r4, r5, r6, pc}
 1015daa:	bf00      	nop
 1015dac:	210036f0 	.word	0x210036f0

01015db0 <ll_version_ind_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015db0:	2807      	cmp	r0, #7
{
 1015db2:	b570      	push	{r4, r5, r6, lr}
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015db4:	d814      	bhi.n	1015de0 <ll_version_ind_send+0x30>
 1015db6:	4604      	mov	r4, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015db8:	4602      	mov	r2, r0
 1015dba:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015dbe:	480d      	ldr	r0, [pc, #52]	; (1015df4 <ll_version_ind_send+0x44>)
 1015dc0:	f7fb f866 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1015dc4:	8d06      	ldrh	r6, [r0, #40]	; 0x28
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015dc6:	4605      	mov	r5, r0
	if (conn->lll.handle != handle) {
 1015dc8:	42a6      	cmp	r6, r4
 1015dca:	d109      	bne.n	1015de0 <ll_version_ind_send+0x30>
	err = ull_cp_version_exchange(conn);
 1015dcc:	f002 fa34 	bl	1018238 <ull_cp_version_exchange>
	if (err) {
 1015dd0:	4604      	mov	r4, r0
 1015dd2:	b918      	cbnz	r0, 1015ddc <ll_version_ind_send+0x2c>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
 1015dd4:	f995 3039 	ldrsb.w	r3, [r5, #57]	; 0x39
 1015dd8:	2b00      	cmp	r3, #0
 1015dda:	db04      	blt.n	1015de6 <ll_version_ind_send+0x36>
}
 1015ddc:	4620      	mov	r0, r4
 1015dde:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015de0:	2402      	movs	r4, #2
}
 1015de2:	4620      	mov	r0, r4
 1015de4:	bd70      	pop	{r4, r5, r6, pc}
		ull_periph_latency_cancel(conn, handle);
 1015de6:	4628      	mov	r0, r5
 1015de8:	4631      	mov	r1, r6
 1015dea:	f005 f81d 	bl	101ae28 <ull_periph_latency_cancel>
}
 1015dee:	4620      	mov	r0, r4
 1015df0:	bd70      	pop	{r4, r5, r6, pc}
 1015df2:	bf00      	nop
 1015df4:	210036f0 	.word	0x210036f0

01015df8 <ll_length_req_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015df8:	2807      	cmp	r0, #7
 1015dfa:	d825      	bhi.n	1015e48 <ll_length_req_send+0x50>
{
 1015dfc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1015e00:	4604      	mov	r4, r0
 1015e02:	460e      	mov	r6, r1
 1015e04:	4617      	mov	r7, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015e06:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015e0a:	4602      	mov	r2, r0
 1015e0c:	4812      	ldr	r0, [pc, #72]	; (1015e58 <ll_length_req_send+0x60>)
 1015e0e:	f7fb f83f 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1015e12:	f8b0 8028 	ldrh.w	r8, [r0, #40]	; 0x28
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015e16:	4605      	mov	r5, r0
	if (conn->lll.handle != handle) {
 1015e18:	45a0      	cmp	r8, r4
 1015e1a:	d10f      	bne.n	1015e3c <ll_length_req_send+0x44>
}

static inline bool feature_dle(struct ll_conn *conn)
{
#if defined(CONFIG_BT_CTLR_DATA_LENGTH)
	return (conn->llcp.fex.features_used & LL_FEAT_BIT_DLE) != 0;
 1015e1c:	f8d0 3130 	ldr.w	r3, [r0, #304]	; 0x130
	if (!feature_dle(conn)) {
 1015e20:	069b      	lsls	r3, r3, #26
 1015e22:	d50e      	bpl.n	1015e42 <ll_length_req_send+0x4a>
	err = ull_cp_data_length_update(conn, tx_octets, tx_time);
 1015e24:	463a      	mov	r2, r7
 1015e26:	4631      	mov	r1, r6
 1015e28:	f002 fa5c 	bl	10182e4 <ull_cp_data_length_update>
	if (err) {
 1015e2c:	b920      	cbnz	r0, 1015e38 <ll_length_req_send+0x40>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
 1015e2e:	f995 3039 	ldrsb.w	r3, [r5, #57]	; 0x39
 1015e32:	2b00      	cmp	r3, #0
 1015e34:	db0a      	blt.n	1015e4c <ll_length_req_send+0x54>
	return 0;
 1015e36:	2000      	movs	r0, #0
}
 1015e38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015e3c:	2002      	movs	r0, #2
}
 1015e3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 1015e42:	201a      	movs	r0, #26
}
 1015e44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015e48:	2002      	movs	r0, #2
}
 1015e4a:	4770      	bx	lr
		ull_periph_latency_cancel(conn, handle);
 1015e4c:	4641      	mov	r1, r8
 1015e4e:	4628      	mov	r0, r5
 1015e50:	f004 ffea 	bl	101ae28 <ull_periph_latency_cancel>
 1015e54:	e7ef      	b.n	1015e36 <ll_length_req_send+0x3e>
 1015e56:	bf00      	nop
 1015e58:	210036f0 	.word	0x210036f0

01015e5c <ll_length_default_get>:
	*max_tx_octets = default_tx_octets;
 1015e5c:	4a03      	ldr	r2, [pc, #12]	; (1015e6c <ll_length_default_get+0x10>)
	*max_tx_time = default_tx_time;
 1015e5e:	4b04      	ldr	r3, [pc, #16]	; (1015e70 <ll_length_default_get+0x14>)
	*max_tx_octets = default_tx_octets;
 1015e60:	8812      	ldrh	r2, [r2, #0]
	*max_tx_time = default_tx_time;
 1015e62:	881b      	ldrh	r3, [r3, #0]
	*max_tx_octets = default_tx_octets;
 1015e64:	8002      	strh	r2, [r0, #0]
	*max_tx_time = default_tx_time;
 1015e66:	800b      	strh	r3, [r1, #0]
}
 1015e68:	4770      	bx	lr
 1015e6a:	bf00      	nop
 1015e6c:	210081d6 	.word	0x210081d6
 1015e70:	210081d4 	.word	0x210081d4

01015e74 <ll_length_default_set>:
{
 1015e74:	4684      	mov	ip, r0
	default_tx_octets = max_tx_octets;
 1015e76:	4a03      	ldr	r2, [pc, #12]	; (1015e84 <ll_length_default_set+0x10>)
	default_tx_time = max_tx_time;
 1015e78:	4b03      	ldr	r3, [pc, #12]	; (1015e88 <ll_length_default_set+0x14>)
}
 1015e7a:	2000      	movs	r0, #0
	default_tx_octets = max_tx_octets;
 1015e7c:	f8a2 c000 	strh.w	ip, [r2]
	default_tx_time = max_tx_time;
 1015e80:	8019      	strh	r1, [r3, #0]
}
 1015e82:	4770      	bx	lr
 1015e84:	210081d6 	.word	0x210081d6
 1015e88:	210081d4 	.word	0x210081d4

01015e8c <ll_length_max_get>:
	*max_tx_time = PDU_DC_MAX_US(LL_LENGTH_OCTETS_RX_MAX, PHY);
 1015e8c:	f640 0c48 	movw	ip, #2120	; 0x848
{
 1015e90:	b500      	push	{lr}
	*max_tx_octets = LL_LENGTH_OCTETS_RX_MAX;
 1015e92:	f04f 0efb 	mov.w	lr, #251	; 0xfb
 1015e96:	f8a0 e000 	strh.w	lr, [r0]
	*max_rx_octets = LL_LENGTH_OCTETS_RX_MAX;
 1015e9a:	f8a2 e000 	strh.w	lr, [r2]
	*max_tx_time = PDU_DC_MAX_US(LL_LENGTH_OCTETS_RX_MAX, PHY);
 1015e9e:	f8a1 c000 	strh.w	ip, [r1]
	*max_rx_time = PDU_DC_MAX_US(LL_LENGTH_OCTETS_RX_MAX, PHY);
 1015ea2:	f8a3 c000 	strh.w	ip, [r3]
}
 1015ea6:	f85d fb04 	ldr.w	pc, [sp], #4
 1015eaa:	bf00      	nop

01015eac <ll_phy_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015eac:	2807      	cmp	r0, #7
 1015eae:	d81b      	bhi.n	1015ee8 <ll_phy_get+0x3c>
{
 1015eb0:	b570      	push	{r4, r5, r6, lr}
 1015eb2:	4604      	mov	r4, r0
 1015eb4:	460e      	mov	r6, r1
 1015eb6:	4615      	mov	r5, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015eb8:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015ebc:	4602      	mov	r2, r0
 1015ebe:	480b      	ldr	r0, [pc, #44]	; (1015eec <ll_phy_get+0x40>)
 1015ec0:	f7fa ffe6 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1015ec4:	8d02      	ldrh	r2, [r0, #40]	; 0x28
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015ec6:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 1015ec8:	42a2      	cmp	r2, r4
 1015eca:	d10b      	bne.n	1015ee4 <ll_phy_get+0x38>
	*tx = conn->lll.phy_tx;
 1015ecc:	f893 4076 	ldrb.w	r4, [r3, #118]	; 0x76
	return 0;
 1015ed0:	2000      	movs	r0, #0
	*tx = conn->lll.phy_tx;
 1015ed2:	f3c4 0402 	ubfx	r4, r4, #0, #3
 1015ed6:	7034      	strb	r4, [r6, #0]
	*rx = conn->lll.phy_rx;
 1015ed8:	f893 3077 	ldrb.w	r3, [r3, #119]	; 0x77
 1015edc:	f3c3 0302 	ubfx	r3, r3, #0, #3
 1015ee0:	702b      	strb	r3, [r5, #0]
}
 1015ee2:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015ee4:	2002      	movs	r0, #2
}
 1015ee6:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015ee8:	2002      	movs	r0, #2
}
 1015eea:	4770      	bx	lr
 1015eec:	210036f0 	.word	0x210036f0

01015ef0 <ll_phy_default_set>:
{
 1015ef0:	4684      	mov	ip, r0
	default_phy_tx = tx;
 1015ef2:	4a03      	ldr	r2, [pc, #12]	; (1015f00 <ll_phy_default_set+0x10>)
	default_phy_rx = rx;
 1015ef4:	4b03      	ldr	r3, [pc, #12]	; (1015f04 <ll_phy_default_set+0x14>)
}
 1015ef6:	2000      	movs	r0, #0
	default_phy_tx = tx;
 1015ef8:	f882 c000 	strb.w	ip, [r2]
	default_phy_rx = rx;
 1015efc:	7019      	strb	r1, [r3, #0]
}
 1015efe:	4770      	bx	lr
 1015f00:	2100834a 	.word	0x2100834a
 1015f04:	21008349 	.word	0x21008349

01015f08 <ll_phy_req_send>:
{
 1015f08:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015f0c:	2807      	cmp	r0, #7
{
 1015f0e:	b083      	sub	sp, #12
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015f10:	d824      	bhi.n	1015f5c <ll_phy_req_send+0x54>
 1015f12:	4604      	mov	r4, r0
 1015f14:	4688      	mov	r8, r1
 1015f16:	4617      	mov	r7, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015f18:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015f1c:	4602      	mov	r2, r0
 1015f1e:	4814      	ldr	r0, [pc, #80]	; (1015f70 <ll_phy_req_send+0x68>)
 1015f20:	461e      	mov	r6, r3
 1015f22:	f7fa ffb5 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1015f26:	f8b0 9028 	ldrh.w	r9, [r0, #40]	; 0x28
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015f2a:	4605      	mov	r5, r0
	if (conn->lll.handle != handle) {
 1015f2c:	45a1      	cmp	r9, r4
 1015f2e:	d115      	bne.n	1015f5c <ll_phy_req_send+0x54>
}

static inline bool feature_phy_2m(struct ll_conn *conn)
{
#if defined(CONFIG_BT_CTLR_PHY_2M)
	return (conn->llcp.fex.features_used & LL_FEAT_BIT_PHY_2M) != 0;
 1015f30:	f8d0 3130 	ldr.w	r3, [r0, #304]	; 0x130
	if (!feature_phy_2m(conn) && !feature_phy_coded(conn)) {
 1015f34:	05db      	lsls	r3, r3, #23
 1015f36:	d516      	bpl.n	1015f66 <ll_phy_req_send+0x5e>
	err = ull_cp_phy_update(conn, tx, flags, rx, 1U);
 1015f38:	2401      	movs	r4, #1
 1015f3a:	4633      	mov	r3, r6
 1015f3c:	9400      	str	r4, [sp, #0]
 1015f3e:	463a      	mov	r2, r7
 1015f40:	4641      	mov	r1, r8
 1015f42:	f002 f987 	bl	1018254 <ull_cp_phy_update>
	if (err) {
 1015f46:	4604      	mov	r4, r0
 1015f48:	b948      	cbnz	r0, 1015f5e <ll_phy_req_send+0x56>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
 1015f4a:	f995 3039 	ldrsb.w	r3, [r5, #57]	; 0x39
 1015f4e:	2b00      	cmp	r3, #0
 1015f50:	da05      	bge.n	1015f5e <ll_phy_req_send+0x56>
		ull_periph_latency_cancel(conn, handle);
 1015f52:	4649      	mov	r1, r9
 1015f54:	4628      	mov	r0, r5
 1015f56:	f004 ff67 	bl	101ae28 <ull_periph_latency_cancel>
 1015f5a:	e000      	b.n	1015f5e <ll_phy_req_send+0x56>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015f5c:	2402      	movs	r4, #2
}
 1015f5e:	4620      	mov	r0, r4
 1015f60:	b003      	add	sp, #12
 1015f62:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 1015f66:	241a      	movs	r4, #26
}
 1015f68:	4620      	mov	r0, r4
 1015f6a:	b003      	add	sp, #12
 1015f6c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1015f70:	210036f0 	.word	0x210036f0

01015f74 <ll_apto_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015f74:	2807      	cmp	r0, #7
 1015f76:	d81d      	bhi.n	1015fb4 <ll_apto_get+0x40>
{
 1015f78:	b538      	push	{r3, r4, r5, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015f7a:	4602      	mov	r2, r0
 1015f7c:	4604      	mov	r4, r0
 1015f7e:	460d      	mov	r5, r1
 1015f80:	480d      	ldr	r0, [pc, #52]	; (1015fb8 <ll_apto_get+0x44>)
 1015f82:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015f86:	f7fa ff83 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1015f8a:	8d03      	ldrh	r3, [r0, #40]	; 0x28
 1015f8c:	42a3      	cmp	r3, r4
 1015f8e:	d10f      	bne.n	1015fb0 <ll_apto_get+0x3c>
	*apto = conn->apto_reload * conn->lll.interval * 125U / 1000;
 1015f90:	8d41      	ldrh	r1, [r0, #42]	; 0x2a
 1015f92:	f8b0 317e 	ldrh.w	r3, [r0, #382]	; 0x17e
 1015f96:	4a09      	ldr	r2, [pc, #36]	; (1015fbc <ll_apto_get+0x48>)
 1015f98:	fb01 f303 	mul.w	r3, r1, r3
 1015f9c:	ebc3 1143 	rsb	r1, r3, r3, lsl #5
 1015fa0:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 1015fa4:	fba2 2303 	umull	r2, r3, r2, r3
 1015fa8:	099b      	lsrs	r3, r3, #6
 1015faa:	802b      	strh	r3, [r5, #0]
	return 0;
 1015fac:	2000      	movs	r0, #0
}
 1015fae:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015fb0:	2002      	movs	r0, #2
}
 1015fb2:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015fb4:	2002      	movs	r0, #2
}
 1015fb6:	4770      	bx	lr
 1015fb8:	210036f0 	.word	0x210036f0
 1015fbc:	10624dd3 	.word	0x10624dd3

01015fc0 <ll_apto_set>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 1015fc0:	2807      	cmp	r0, #7
 1015fc2:	d81e      	bhi.n	1016002 <ll_apto_set+0x42>
{
 1015fc4:	b538      	push	{r3, r4, r5, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015fc6:	4602      	mov	r2, r0
 1015fc8:	4604      	mov	r4, r0
 1015fca:	460d      	mov	r5, r1
 1015fcc:	480e      	ldr	r0, [pc, #56]	; (1016008 <ll_apto_set+0x48>)
 1015fce:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1015fd2:	f7fa ff5d 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1015fd6:	8d02      	ldrh	r2, [r0, #40]	; 0x28
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1015fd8:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 1015fda:	42a2      	cmp	r2, r4
 1015fdc:	d10f      	bne.n	1015ffe <ll_apto_set+0x3e>
	conn->apto_reload = RADIO_CONN_EVENTS(apto * 10U * 1000U,
 1015fde:	f240 44e2 	movw	r4, #1250	; 0x4e2
 1015fe2:	f242 7110 	movw	r1, #10000	; 0x2710
 1015fe6:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
	return 0;
 1015fe8:	2000      	movs	r0, #0
	conn->apto_reload = RADIO_CONN_EVENTS(apto * 10U * 1000U,
 1015fea:	fb04 f202 	mul.w	r2, r4, r2
 1015fee:	fb01 2105 	mla	r1, r1, r5, r2
 1015ff2:	3901      	subs	r1, #1
 1015ff4:	fbb1 f1f2 	udiv	r1, r1, r2
 1015ff8:	f8a3 117e 	strh.w	r1, [r3, #382]	; 0x17e
}
 1015ffc:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1015ffe:	2002      	movs	r0, #2
}
 1016000:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1016002:	2002      	movs	r0, #2
}
 1016004:	4770      	bx	lr
 1016006:	bf00      	nop
 1016008:	210036f0 	.word	0x210036f0

0101600c <ull_conn_init>:
	err = init_reset();
 101600c:	f7ff bb9e 	b.w	101574c <init_reset>

01016010 <ull_conn_reset>:
{
 1016010:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1016014:	2500      	movs	r5, #0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1016016:	4e1a      	ldr	r6, [pc, #104]	; (1016080 <ull_conn_reset+0x70>)
	LL_ASSERT(err == 0 || err == -EALREADY);
 1016018:	f8df 8068 	ldr.w	r8, [pc, #104]	; 1016084 <ull_conn_reset+0x74>
 101601c:	4f1a      	ldr	r7, [pc, #104]	; (1016088 <ull_conn_reset+0x78>)
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 101601e:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1016022:	b2aa      	uxth	r2, r5
 1016024:	4630      	mov	r0, r6
 1016026:	f7fa ff33 	bl	1010e90 <mem_get>
 101602a:	4604      	mov	r4, r0
	err = ull_ticker_stop_with_mark(TICKER_ID_CONN_BASE + handle,
 101602c:	1ce8      	adds	r0, r5, #3
 101602e:	4621      	mov	r1, r4
 1016030:	b2c0      	uxtb	r0, r0
 1016032:	f104 021c 	add.w	r2, r4, #28
 1016036:	f7fe fa99 	bl	101456c <ull_ticker_stop_with_mark>
	LL_ASSERT(err == 0 || err == -EALREADY);
 101603a:	4603      	mov	r3, r0
 101603c:	b170      	cbz	r0, 101605c <ull_conn_reset+0x4c>
 101603e:	3378      	adds	r3, #120	; 0x78
 1016040:	4812      	ldr	r0, [pc, #72]	; (101608c <ull_conn_reset+0x7c>)
 1016042:	d00b      	beq.n	101605c <ull_conn_reset+0x4c>
 1016044:	f640 13e6 	movw	r3, #2534	; 0x9e6
 1016048:	4642      	mov	r2, r8
 101604a:	4639      	mov	r1, r7
 101604c:	f00e fdc3 	bl	1024bd6 <assert_print>
 1016050:	4040      	eors	r0, r0
 1016052:	f380 8811 	msr	BASEPRI, r0
 1016056:	f04f 0003 	mov.w	r0, #3
 101605a:	df02      	svc	2
	conn->lll.handle = LLL_HANDLE_INVALID;
 101605c:	f64f 72ff 	movw	r2, #65535	; 0xffff
	conn->lll.link_tx_free = NULL;
 1016060:	2300      	movs	r3, #0
	for (handle = 0U; handle < CONFIG_BT_MAX_CONN; handle++) {
 1016062:	3501      	adds	r5, #1
 1016064:	2d08      	cmp	r5, #8
	conn->lll.handle = LLL_HANDLE_INVALID;
 1016066:	8522      	strh	r2, [r4, #40]	; 0x28
	conn->lll.link_tx_free = NULL;
 1016068:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
	for (handle = 0U; handle < CONFIG_BT_MAX_CONN; handle++) {
 101606c:	d1d7      	bne.n	101601e <ull_conn_reset+0xe>
	MFIFO_INIT(conn_tx);
 101606e:	4908      	ldr	r1, [pc, #32]	; (1016090 <ull_conn_reset+0x80>)
	MFIFO_INIT(conn_ack);
 1016070:	4a08      	ldr	r2, [pc, #32]	; (1016094 <ull_conn_reset+0x84>)
	MFIFO_INIT(conn_tx);
 1016072:	808b      	strh	r3, [r1, #4]
	MFIFO_INIT(conn_ack);
 1016074:	8093      	strh	r3, [r2, #4]
}
 1016076:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	err = init_reset();
 101607a:	f7ff bb67 	b.w	101574c <init_reset>
 101607e:	bf00      	nop
 1016080:	210036f0 	.word	0x210036f0
 1016084:	0102a8dc 	.word	0x0102a8dc
 1016088:	0102a9d0 	.word	0x0102a9d0
 101608c:	0102a278 	.word	0x0102a278
 1016090:	21000954 	.word	0x21000954
 1016094:	2100082c 	.word	0x2100082c

01016098 <ull_conn_default_phy_tx_get>:
	return default_phy_tx;
 1016098:	4b01      	ldr	r3, [pc, #4]	; (10160a0 <ull_conn_default_phy_tx_get+0x8>)
}
 101609a:	7818      	ldrb	r0, [r3, #0]
 101609c:	4770      	bx	lr
 101609e:	bf00      	nop
 10160a0:	2100834a 	.word	0x2100834a

010160a4 <ull_conn_default_phy_rx_get>:
	return default_phy_rx;
 10160a4:	4b01      	ldr	r3, [pc, #4]	; (10160ac <ull_conn_default_phy_rx_get+0x8>)
}
 10160a6:	7818      	ldrb	r0, [r3, #0]
 10160a8:	4770      	bx	lr
 10160aa:	bf00      	nop
 10160ac:	21008349 	.word	0x21008349

010160b0 <ull_conn_peer_connected>:
{
 10160b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10160b4:	2500      	movs	r5, #0
 10160b6:	4681      	mov	r9, r0
 10160b8:	468a      	mov	sl, r1
 10160ba:	4616      	mov	r6, r2
 10160bc:	4698      	mov	r8, r3
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 10160be:	4f19      	ldr	r7, [pc, #100]	; (1016124 <ull_conn_peer_connected+0x74>)
 10160c0:	e001      	b.n	10160c6 <ull_conn_peer_connected+0x16>
	for (handle = 0U; handle < CONFIG_BT_MAX_CONN; handle++) {
 10160c2:	2d08      	cmp	r5, #8
 10160c4:	d02b      	beq.n	101611e <ull_conn_peer_connected+0x6e>
 10160c6:	fa1f fb85 	uxth.w	fp, r5
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 10160ca:	465a      	mov	r2, fp
 10160cc:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 10160d0:	4638      	mov	r0, r7
 10160d2:	f7fa fedd 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 10160d6:	8d03      	ldrh	r3, [r0, #40]	; 0x28
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 10160d8:	4604      	mov	r4, r0
	if (conn->lll.handle != handle) {
 10160da:	455b      	cmp	r3, fp
	for (handle = 0U; handle < CONFIG_BT_MAX_CONN; handle++) {
 10160dc:	f105 0501 	add.w	r5, r5, #1
	if (conn->lll.handle != handle) {
 10160e0:	d1ef      	bne.n	10160c2 <ull_conn_peer_connected+0x12>
		    conn->peer_id_addr_type == peer_id_addr_type &&
 10160e2:	f890 c192 	ldrb.w	ip, [r0, #402]	; 0x192
 10160e6:	f3cc 0c40 	ubfx	ip, ip, #1, #1
		if (conn &&
 10160ea:	45b4      	cmp	ip, r6
 10160ec:	d1e9      	bne.n	10160c2 <ull_conn_peer_connected+0x12>
		    !memcmp(conn->peer_id_addr, peer_id_addr, BDADDR_SIZE) &&
 10160ee:	2206      	movs	r2, #6
 10160f0:	4641      	mov	r1, r8
 10160f2:	f200 1099 	addw	r0, r0, #409	; 0x199
 10160f6:	f010 fc2d 	bl	1026954 <memcmp>
		    conn->peer_id_addr_type == peer_id_addr_type &&
 10160fa:	2800      	cmp	r0, #0
 10160fc:	d1e1      	bne.n	10160c2 <ull_conn_peer_connected+0x12>
		    conn->own_id_addr_type == own_id_addr_type &&
 10160fe:	f894 3192 	ldrb.w	r3, [r4, #402]	; 0x192
 1016102:	f003 0301 	and.w	r3, r3, #1
		    !memcmp(conn->peer_id_addr, peer_id_addr, BDADDR_SIZE) &&
 1016106:	454b      	cmp	r3, r9
 1016108:	d1db      	bne.n	10160c2 <ull_conn_peer_connected+0x12>
		    !memcmp(conn->own_id_addr, own_id_addr, BDADDR_SIZE)) {
 101610a:	2206      	movs	r2, #6
 101610c:	4651      	mov	r1, sl
 101610e:	f204 1093 	addw	r0, r4, #403	; 0x193
 1016112:	f010 fc1f 	bl	1026954 <memcmp>
		    conn->own_id_addr_type == own_id_addr_type &&
 1016116:	2800      	cmp	r0, #0
 1016118:	d1d3      	bne.n	10160c2 <ull_conn_peer_connected+0x12>
			return true;
 101611a:	2001      	movs	r0, #1
 101611c:	e000      	b.n	1016120 <ull_conn_peer_connected+0x70>
	return false;
 101611e:	2000      	movs	r0, #0
}
 1016120:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1016124:	210036f0 	.word	0x210036f0

01016128 <ull_conn_setup>:
{
 1016128:	b538      	push	{r3, r4, r5, lr}
	hdr = HDR_LLL2ULL(ftr->param);
 101612a:	688b      	ldr	r3, [r1, #8]
	rx->link = rx_link;
 101612c:	6008      	str	r0, [r1, #0]
	hdr = HDR_LLL2ULL(ftr->param);
 101612e:	681d      	ldr	r5, [r3, #0]
{
 1016130:	460c      	mov	r4, r1
 1016132:	782b      	ldrb	r3, [r5, #0]
	if (ull_ref_get(hdr)) {
 1016134:	b193      	cbz	r3, 101615c <ull_conn_setup+0x34>
		LL_ASSERT(!hdr->disabled_cb);
 1016136:	696b      	ldr	r3, [r5, #20]
 1016138:	b163      	cbz	r3, 1016154 <ull_conn_setup+0x2c>
 101613a:	f240 4343 	movw	r3, #1091	; 0x443
 101613e:	4a0a      	ldr	r2, [pc, #40]	; (1016168 <ull_conn_setup+0x40>)
 1016140:	490a      	ldr	r1, [pc, #40]	; (101616c <ull_conn_setup+0x44>)
 1016142:	480b      	ldr	r0, [pc, #44]	; (1016170 <ull_conn_setup+0x48>)
 1016144:	f00e fd47 	bl	1024bd6 <assert_print>
 1016148:	4040      	eors	r0, r0
 101614a:	f380 8811 	msr	BASEPRI, r0
 101614e:	f04f 0003 	mov.w	r0, #3
 1016152:	df02      	svc	2
		hdr->disabled_cb = conn_setup_adv_scan_disabled_cb;
 1016154:	4b07      	ldr	r3, [pc, #28]	; (1016174 <ull_conn_setup+0x4c>)
 1016156:	e9c5 3405 	strd	r3, r4, [r5, #20]
}
 101615a:	bd38      	pop	{r3, r4, r5, pc}
		conn_setup_adv_scan_disabled_cb(rx);
 101615c:	4608      	mov	r0, r1
}
 101615e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		conn_setup_adv_scan_disabled_cb(rx);
 1016162:	f7ff bc3b 	b.w	10159dc <conn_setup_adv_scan_disabled_cb>
 1016166:	bf00      	nop
 1016168:	0102a8dc 	.word	0x0102a8dc
 101616c:	0102a7b0 	.word	0x0102a7b0
 1016170:	0102a278 	.word	0x0102a278
 1016174:	010159dd 	.word	0x010159dd

01016178 <ull_conn_rx>:
{
 1016178:	b570      	push	{r4, r5, r6, lr}
	conn = ll_connected_get((*rx)->hdr.handle);
 101617a:	680b      	ldr	r3, [r1, #0]
 101617c:	88de      	ldrh	r6, [r3, #6]
	if (handle >= CONFIG_BT_MAX_CONN) {
 101617e:	2e07      	cmp	r6, #7
 1016180:	d834      	bhi.n	10161ec <ull_conn_rx+0x74>
 1016182:	460c      	mov	r4, r1
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1016184:	4632      	mov	r2, r6
 1016186:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 101618a:	481a      	ldr	r0, [pc, #104]	; (10161f4 <ull_conn_rx+0x7c>)
 101618c:	f7fa fe80 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1016190:	8d03      	ldrh	r3, [r0, #40]	; 0x28
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1016192:	4605      	mov	r5, r0
	if (conn->lll.handle != handle) {
 1016194:	42b3      	cmp	r3, r6
 1016196:	d128      	bne.n	10161ea <ull_conn_rx+0x72>
	ull_cp_tx_ntf(conn);
 1016198:	f002 f9c6 	bl	1018528 <ull_cp_tx_ntf>
	pdu_rx = (void *)(*rx)->pdu;
 101619c:	6821      	ldr	r1, [r4, #0]
	switch (pdu_rx->ll_id) {
 101619e:	7f0b      	ldrb	r3, [r1, #28]
 10161a0:	f003 0303 	and.w	r3, r3, #3
 10161a4:	2b03      	cmp	r3, #3
 10161a6:	d107      	bne.n	10161b8 <ull_conn_rx+0x40>
		ull_cp_rx(conn, *rx);
 10161a8:	4628      	mov	r0, r5
 10161aa:	f002 f9d1 	bl	1018550 <ull_cp_rx>
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
 10161ae:	2201      	movs	r2, #1
 10161b0:	6823      	ldr	r3, [r4, #0]
 10161b2:	711a      	strb	r2, [r3, #4]
}
 10161b4:	2000      	movs	r0, #0
 10161b6:	bd70      	pop	{r4, r5, r6, pc}
	switch (pdu_rx->ll_id) {
 10161b8:	b95b      	cbnz	r3, 10161d2 <ull_conn_rx+0x5a>
		if (conn->pause_rx_data) {
 10161ba:	f895 3178 	ldrb.w	r3, [r5, #376]	; 0x178
 10161be:	079b      	lsls	r3, r3, #30
 10161c0:	d503      	bpl.n	10161ca <ull_conn_rx+0x52>
			conn->llcp_terminate.reason_final =
 10161c2:	233d      	movs	r3, #61	; 0x3d
 10161c4:	f885 3148 	strb.w	r3, [r5, #328]	; 0x148
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
 10161c8:	6821      	ldr	r1, [r4, #0]
 10161ca:	2301      	movs	r3, #1
 10161cc:	710b      	strb	r3, [r1, #4]
}
 10161ce:	2000      	movs	r0, #0
 10161d0:	bd70      	pop	{r4, r5, r6, pc}
		if (conn->pause_rx_data) {
 10161d2:	f895 3178 	ldrb.w	r3, [r5, #376]	; 0x178
 10161d6:	079a      	lsls	r2, r3, #30
 10161d8:	d5ec      	bpl.n	10161b4 <ull_conn_rx+0x3c>
			conn->llcp_terminate.reason_final =
 10161da:	233d      	movs	r3, #61	; 0x3d
			(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
 10161dc:	2201      	movs	r2, #1
			conn->llcp_terminate.reason_final =
 10161de:	f885 3148 	strb.w	r3, [r5, #328]	; 0x148
			(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
 10161e2:	6823      	ldr	r3, [r4, #0]
}
 10161e4:	2000      	movs	r0, #0
			(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
 10161e6:	711a      	strb	r2, [r3, #4]
}
 10161e8:	bd70      	pop	{r4, r5, r6, pc}
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
 10161ea:	6823      	ldr	r3, [r4, #0]
 10161ec:	2201      	movs	r2, #1
 10161ee:	711a      	strb	r2, [r3, #4]
}
 10161f0:	2000      	movs	r0, #0
 10161f2:	bd70      	pop	{r4, r5, r6, pc}
 10161f4:	210036f0 	.word	0x210036f0

010161f8 <ull_conn_llcp>:
	LL_ASSERT(conn->lll.handle != LLL_HANDLE_INVALID);
 10161f8:	f64f 73ff 	movw	r3, #65535	; 0xffff
{
 10161fc:	b570      	push	{r4, r5, r6, lr}
 10161fe:	4615      	mov	r5, r2
	LL_ASSERT(conn->lll.handle != LLL_HANDLE_INVALID);
 1016200:	8d02      	ldrh	r2, [r0, #40]	; 0x28
{
 1016202:	4604      	mov	r4, r0
	LL_ASSERT(conn->lll.handle != LLL_HANDLE_INVALID);
 1016204:	429a      	cmp	r2, r3
{
 1016206:	460e      	mov	r6, r1
	LL_ASSERT(conn->lll.handle != LLL_HANDLE_INVALID);
 1016208:	d00c      	beq.n	1016224 <ull_conn_llcp+0x2c>
	ull_cp_run(conn);
 101620a:	4620      	mov	r0, r4
	conn->llcp.prep.ticks_at_expire = ticks_at_expire;
 101620c:	f8c4 610c 	str.w	r6, [r4, #268]	; 0x10c
	conn->llcp.prep.lazy = lazy;
 1016210:	f8a4 5110 	strh.w	r5, [r4, #272]	; 0x110
	ull_cp_run(conn);
 1016214:	f001 ffbe 	bl	1018194 <ull_cp_run>
	if (conn->cancel_prepare) {
 1016218:	f894 3178 	ldrb.w	r3, [r4, #376]	; 0x178
 101621c:	f013 0001 	ands.w	r0, r3, #1
 1016220:	d10e      	bne.n	1016240 <ull_conn_llcp+0x48>
}
 1016222:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(conn->lll.handle != LLL_HANDLE_INVALID);
 1016224:	f240 53b6 	movw	r3, #1462	; 0x5b6
 1016228:	4a09      	ldr	r2, [pc, #36]	; (1016250 <ull_conn_llcp+0x58>)
 101622a:	490a      	ldr	r1, [pc, #40]	; (1016254 <ull_conn_llcp+0x5c>)
 101622c:	480a      	ldr	r0, [pc, #40]	; (1016258 <ull_conn_llcp+0x60>)
 101622e:	f00e fcd2 	bl	1024bd6 <assert_print>
 1016232:	4040      	eors	r0, r0
 1016234:	f380 8811 	msr	BASEPRI, r0
 1016238:	f04f 0003 	mov.w	r0, #3
 101623c:	df02      	svc	2
 101623e:	e7e4      	b.n	101620a <ull_conn_llcp+0x12>
		conn->cancel_prepare = 0U;
 1016240:	f36f 0300 	bfc	r3, #0, #1
 1016244:	f884 3178 	strb.w	r3, [r4, #376]	; 0x178
		return -ECANCELED;
 1016248:	f06f 008b 	mvn.w	r0, #139	; 0x8b
}
 101624c:	bd70      	pop	{r4, r5, r6, pc}
 101624e:	bf00      	nop
 1016250:	0102a8dc 	.word	0x0102a8dc
 1016254:	0102a9e8 	.word	0x0102a9e8
 1016258:	0102a278 	.word	0x0102a278

0101625c <ull_conn_tx_demux>:
{
 101625c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
 1016260:	4d1d      	ldr	r5, [pc, #116]	; (10162d8 <ull_conn_tx_demux+0x7c>)
{
 1016262:	4680      	mov	r8, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1016264:	4f1d      	ldr	r7, [pc, #116]	; (10162dc <ull_conn_tx_demux+0x80>)
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
 1016266:	796a      	ldrb	r2, [r5, #5]
	return (void *)(fifo + first * size);
 1016268:	f105 0608 	add.w	r6, r5, #8
 101626c:	e01c      	b.n	10162a8 <ull_conn_tx_demux+0x4c>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 101626e:	464a      	mov	r2, r9
 1016270:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1016274:	4638      	mov	r0, r7
 1016276:	f7fa fe0b 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 101627a:	8d03      	ldrh	r3, [r0, #40]	; 0x28
			ull_tx_q_enqueue_data(&conn->tx_q, tx);
 101627c:	30d4      	adds	r0, #212	; 0xd4
	if (conn->lll.handle != handle) {
 101627e:	454b      	cmp	r3, r9
 1016280:	d11e      	bne.n	10162c0 <ull_conn_tx_demux+0x64>
			ull_tx_q_enqueue_data(&conn->tx_q, tx);
 1016282:	6861      	ldr	r1, [r4, #4]
 1016284:	f001 fd14 	bl	1017cb0 <ull_tx_q_enqueue_data>
	uint8_t _first = *first; /* Copy read-index */
 1016288:	7929      	ldrb	r1, [r5, #4]
		MFIFO_DEQUEUE(conn_tx);
 101628a:	796a      	ldrb	r2, [r5, #5]
	_first += 1U;
 101628c:	1c4b      	adds	r3, r1, #1
	if (_first == last) {
 101628e:	428a      	cmp	r2, r1
 1016290:	78a8      	ldrb	r0, [r5, #2]
	} while (--count);
 1016292:	f108 38ff 	add.w	r8, r8, #4294967295
	_first += 1U;
 1016296:	b2db      	uxtb	r3, r3
	if (_first == last) {
 1016298:	d003      	beq.n	10162a2 <ull_conn_tx_demux+0x46>
		_first = 0U;
 101629a:	4298      	cmp	r0, r3
 101629c:	bf08      	it	eq
 101629e:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
 10162a0:	712b      	strb	r3, [r5, #4]
 10162a2:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
 10162a6:	d015      	beq.n	10162d4 <ull_conn_tx_demux+0x78>
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
 10162a8:	792b      	ldrb	r3, [r5, #4]
 10162aa:	7829      	ldrb	r1, [r5, #0]
	if (first == last) {
 10162ac:	4293      	cmp	r3, r2
 10162ae:	d011      	beq.n	10162d4 <ull_conn_tx_demux+0x78>
	return (void *)(fifo + first * size);
 10162b0:	fb01 f303 	mul.w	r3, r1, r3
		conn = ll_connected_get(lll_tx->handle);
 10162b4:	f836 9003 	ldrh.w	r9, [r6, r3]
 10162b8:	199c      	adds	r4, r3, r6
	if (handle >= CONFIG_BT_MAX_CONN) {
 10162ba:	f1b9 0f07 	cmp.w	r9, #7
 10162be:	d9d6      	bls.n	101626e <ull_conn_tx_demux+0x12>
			struct node_tx *tx = lll_tx->node;
 10162c0:	6861      	ldr	r1, [r4, #4]
			ll_tx_ack_put(LLL_HANDLE_INVALID, tx);
 10162c2:	f64f 70ff 	movw	r0, #65535	; 0xffff
			p->ll_id = PDU_DATA_LLID_RESV;
 10162c6:	790b      	ldrb	r3, [r1, #4]
 10162c8:	f36f 0301 	bfc	r3, #0, #2
 10162cc:	710b      	strb	r3, [r1, #4]
			ll_tx_ack_put(LLL_HANDLE_INVALID, tx);
 10162ce:	f7fe f851 	bl	1014374 <ll_tx_ack_put>
 10162d2:	e7d9      	b.n	1016288 <ull_conn_tx_demux+0x2c>
}
 10162d4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 10162d8:	21000954 	.word	0x21000954
 10162dc:	210036f0 	.word	0x210036f0

010162e0 <conn_cleanup_finalize>:
{
 10162e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10162e4:	4681      	mov	r9, r0
 10162e6:	b083      	sub	sp, #12
	ull_cp_state_set(conn, ULL_CP_DISCONNECTED);
 10162e8:	2101      	movs	r1, #1
	ull_tx_q_resume_data(&conn->tx_q);
 10162ea:	f109 06d4 	add.w	r6, r9, #212	; 0xd4
	ull_cp_state_set(conn, ULL_CP_DISCONNECTED);
 10162ee:	f001 ff5b 	bl	10181a8 <ull_cp_state_set>
	ull_tx_q_resume_data(&conn->tx_q);
 10162f2:	4630      	mov	r0, r6
 10162f4:	f001 fcc4 	bl	1017c80 <ull_tx_q_resume_data>
	tx = ull_tx_q_dequeue(&conn->tx_q);
 10162f8:	4630      	mov	r0, r6
 10162fa:	f001 fcf9 	bl	1017cf0 <ull_tx_q_dequeue>
	if (tx) {
 10162fe:	2800      	cmp	r0, #0
 1016300:	d03b      	beq.n	101637a <conn_cleanup_finalize+0x9a>
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
 1016302:	7903      	ldrb	r3, [r0, #4]
		link = mem_acquire(&mem_link_tx.free);
 1016304:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 10163c4 <conn_cleanup_finalize+0xe4>
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
 1016308:	f003 0303 	and.w	r3, r3, #3
 101630c:	2b03      	cmp	r3, #3
 101630e:	bf0c      	ite	eq
 1016310:	4603      	moveq	r3, r0
 1016312:	2300      	movne	r3, #0
 1016314:	4604      	mov	r4, r0
			tx->next = NULL;
 1016316:	6003      	str	r3, [r0, #0]
		link = mem_acquire(&mem_link_tx.free);
 1016318:	4640      	mov	r0, r8
 101631a:	f7fa fd85 	bl	1010e28 <mem_acquire>
		LL_ASSERT(link);
 101631e:	f8df b0a8 	ldr.w	fp, [pc, #168]	; 10163c8 <conn_cleanup_finalize+0xe8>
 1016322:	4605      	mov	r5, r0
 1016324:	f8df a0a4 	ldr.w	sl, [pc, #164]	; 10163cc <conn_cleanup_finalize+0xec>
 1016328:	f109 077c 	add.w	r7, r9, #124	; 0x7c
 101632c:	b1b8      	cbz	r0, 101635e <conn_cleanup_finalize+0x7e>
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
 101632e:	4621      	mov	r1, r4
 1016330:	463a      	mov	r2, r7
 1016332:	4628      	mov	r0, r5
 1016334:	f7fa fdde 	bl	1010ef4 <memq_enqueue>
	tx = ull_tx_q_dequeue(&conn->tx_q);
 1016338:	4630      	mov	r0, r6
 101633a:	f001 fcd9 	bl	1017cf0 <ull_tx_q_dequeue>
	if (tx) {
 101633e:	4604      	mov	r4, r0
 1016340:	b1d8      	cbz	r0, 101637a <conn_cleanup_finalize+0x9a>
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
 1016342:	7903      	ldrb	r3, [r0, #4]
 1016344:	f003 0303 	and.w	r3, r3, #3
 1016348:	2b03      	cmp	r3, #3
 101634a:	bf0c      	ite	eq
 101634c:	4603      	moveq	r3, r0
 101634e:	2300      	movne	r3, #0
			tx->next = NULL;
 1016350:	6003      	str	r3, [r0, #0]
		link = mem_acquire(&mem_link_tx.free);
 1016352:	4640      	mov	r0, r8
 1016354:	f7fa fd68 	bl	1010e28 <mem_acquire>
		LL_ASSERT(link);
 1016358:	4605      	mov	r5, r0
 101635a:	2800      	cmp	r0, #0
 101635c:	d1e7      	bne.n	101632e <conn_cleanup_finalize+0x4e>
 101635e:	f640 2374 	movw	r3, #2676	; 0xa74
 1016362:	465a      	mov	r2, fp
 1016364:	4651      	mov	r1, sl
 1016366:	481a      	ldr	r0, [pc, #104]	; (10163d0 <conn_cleanup_finalize+0xf0>)
 1016368:	f00e fc35 	bl	1024bd6 <assert_print>
 101636c:	4040      	eors	r0, r0
 101636e:	f380 8811 	msr	BASEPRI, r0
 1016372:	f04f 0003 	mov.w	r0, #3
 1016376:	df02      	svc	2
 1016378:	e7d9      	b.n	101632e <conn_cleanup_finalize+0x4e>
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 101637a:	f8b9 2028 	ldrh.w	r2, [r9, #40]	; 0x28
 101637e:	4b15      	ldr	r3, [pc, #84]	; (10163d4 <conn_cleanup_finalize+0xf4>)
 1016380:	3203      	adds	r2, #3
 1016382:	2101      	movs	r1, #1
 1016384:	2000      	movs	r0, #0
 1016386:	f8cd 9000 	str.w	r9, [sp]
 101638a:	b2d2      	uxtb	r2, r2
 101638c:	f7fb ff12 	bl	10121b4 <ticker_stop>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 1016390:	f030 0302 	bics.w	r3, r0, #2
 1016394:	d00c      	beq.n	10163b0 <conn_cleanup_finalize+0xd0>
 1016396:	f640 232b 	movw	r3, #2603	; 0xa2b
 101639a:	4a0b      	ldr	r2, [pc, #44]	; (10163c8 <conn_cleanup_finalize+0xe8>)
 101639c:	490e      	ldr	r1, [pc, #56]	; (10163d8 <conn_cleanup_finalize+0xf8>)
 101639e:	480c      	ldr	r0, [pc, #48]	; (10163d0 <conn_cleanup_finalize+0xf0>)
 10163a0:	f00e fc19 	bl	1024bd6 <assert_print>
 10163a4:	4040      	eors	r0, r0
 10163a6:	f380 8811 	msr	BASEPRI, r0
 10163aa:	f04f 0003 	mov.w	r0, #3
 10163ae:	df02      	svc	2
	lll->handle = LLL_HANDLE_INVALID;
 10163b0:	f64f 73ff 	movw	r3, #65535	; 0xffff
	ull_conn_tx_demux(UINT8_MAX);
 10163b4:	20ff      	movs	r0, #255	; 0xff
	lll->handle = LLL_HANDLE_INVALID;
 10163b6:	f8a9 3028 	strh.w	r3, [r9, #40]	; 0x28
}
 10163ba:	b003      	add	sp, #12
 10163bc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	ull_conn_tx_demux(UINT8_MAX);
 10163c0:	f7ff bf4c 	b.w	101625c <ull_conn_tx_demux>
 10163c4:	21006d18 	.word	0x21006d18
 10163c8:	0102a8dc 	.word	0x0102a8dc
 10163cc:	0102a92c 	.word	0x0102a92c
 10163d0:	0102a278 	.word	0x0102a278
 10163d4:	010158b5 	.word	0x010158b5
 10163d8:	0102a9a0 	.word	0x0102a9a0

010163dc <ull_conn_done>:
	if (unlikely(lll->handle == LLL_HANDLE_INVALID)) {
 10163dc:	f64f 73ff 	movw	r3, #65535	; 0xffff
{
 10163e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	conn = CONTAINER_OF(done->param, struct ll_conn, ull);
 10163e4:	69c4      	ldr	r4, [r0, #28]
{
 10163e6:	b08d      	sub	sp, #52	; 0x34
	if (unlikely(lll->handle == LLL_HANDLE_INVALID)) {
 10163e8:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 10163ea:	429a      	cmp	r2, r3
 10163ec:	d058      	beq.n	10164a0 <ull_conn_done+0xc4>
 10163ee:	4605      	mov	r5, r0
	ull_cp_tx_ntf(conn);
 10163f0:	4620      	mov	r0, r4
 10163f2:	f002 f899 	bl	1018528 <ull_cp_tx_ntf>
	switch (done->extra.mic_state) {
 10163f6:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
 10163fa:	2b01      	cmp	r3, #1
 10163fc:	f000 80d2 	beq.w	10165a4 <ull_conn_done+0x1c8>
 1016400:	2b02      	cmp	r3, #2
 1016402:	f000 80bd 	beq.w	1016580 <ull_conn_done+0x1a4>
 1016406:	2b00      	cmp	r3, #0
 1016408:	f000 809c 	beq.w	1016544 <ull_conn_done+0x168>
	reason_final = conn->llcp_terminate.reason_final;
 101640c:	f894 7148 	ldrb.w	r7, [r4, #328]	; 0x148
	if (reason_final && (
 1016410:	2f00      	cmp	r7, #0
 1016412:	f040 80b9 	bne.w	1016588 <ull_conn_done+0x1ac>
	if (lll->latency_prepare) {
 1016416:	8de6      	ldrh	r6, [r4, #46]	; 0x2e
	latency_event = lll->latency_event;
 1016418:	f8b4 8030 	ldrh.w	r8, [r4, #48]	; 0x30
	if (lll->latency_prepare) {
 101641c:	2e00      	cmp	r6, #0
 101641e:	d142      	bne.n	10164a6 <ull_conn_done+0xca>
	ticks_drift_plus = 0U;
 1016420:	2300      	movs	r3, #0
	if (done->extra.trx_cnt) {
 1016422:	8caa      	ldrh	r2, [r5, #36]	; 0x24
		elapsed_event = latency_event + 1U;
 1016424:	f108 0601 	add.w	r6, r8, #1
	ticks_drift_minus = 0U;
 1016428:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
		elapsed_event = latency_event + 1U;
 101642c:	b2b6      	uxth	r6, r6
	if (done->extra.trx_cnt) {
 101642e:	2a00      	cmp	r2, #0
 1016430:	d041      	beq.n	10164b6 <ull_conn_done+0xda>
		} else if (lll->role) {
 1016432:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
 1016436:	2b00      	cmp	r3, #0
 1016438:	f2c0 80fe 	blt.w	1016638 <ull_conn_done+0x25c>
		conn->connect_expire = 0U;
 101643c:	2300      	movs	r3, #0
 101643e:	f8a4 3182 	strh.w	r3, [r4, #386]	; 0x182
	if (done->extra.crc_valid) {
 1016442:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 1016446:	07d9      	lsls	r1, r3, #31
 1016448:	f140 80b2 	bpl.w	10165b0 <ull_conn_done+0x1d4>
		conn->supervision_expire = 0U;
 101644c:	2300      	movs	r3, #0
 101644e:	f8a4 3186 	strh.w	r3, [r4, #390]	; 0x186
	if (-ETIMEDOUT == ull_cp_prt_elapse(conn, elapsed_event, &error_code)) {
 1016452:	4631      	mov	r1, r6
 1016454:	4620      	mov	r0, r4
 1016456:	f10d 0227 	add.w	r2, sp, #39	; 0x27
 101645a:	f001 fe57 	bl	101810c <ull_cp_prt_elapse>
 101645e:	3074      	adds	r0, #116	; 0x74
 1016460:	f000 80fd 	beq.w	101665e <ull_conn_done+0x282>
	if (conn->apto_expire != 0U) {
 1016464:	f8b4 3180 	ldrh.w	r3, [r4, #384]	; 0x180
 1016468:	b12b      	cbz	r3, 1016476 <ull_conn_done+0x9a>
		if (conn->apto_expire > elapsed_event) {
 101646a:	42b3      	cmp	r3, r6
 101646c:	f240 80bc 	bls.w	10165e8 <ull_conn_done+0x20c>
			conn->apto_expire -= elapsed_event;
 1016470:	1b9b      	subs	r3, r3, r6
 1016472:	f8a4 3180 	strh.w	r3, [r4, #384]	; 0x180
	if (conn->appto_expire != 0U) {
 1016476:	f8b4 317c 	ldrh.w	r3, [r4, #380]	; 0x17c
 101647a:	b12b      	cbz	r3, 1016488 <ull_conn_done+0xac>
		if (conn->appto_expire > elapsed_event) {
 101647c:	42b3      	cmp	r3, r6
 101647e:	f240 80c3 	bls.w	1016608 <ull_conn_done+0x22c>
			conn->appto_expire -= elapsed_event;
 1016482:	1b9b      	subs	r3, r3, r6
 1016484:	f8a4 317c 	strh.w	r3, [r4, #380]	; 0x17c
	if (ticks_drift_plus || ticks_drift_minus || lazy || force) {
 1016488:	9d0a      	ldr	r5, [sp, #40]	; 0x28
	if ((force) || (latency_event != lll->latency_event)) {
 101648a:	8e22      	ldrh	r2, [r4, #48]	; 0x30
	if (ticks_drift_plus || ticks_drift_minus || lazy || force) {
 101648c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	if ((force) || (latency_event != lll->latency_event)) {
 101648e:	bb97      	cbnz	r7, 10164f6 <ull_conn_done+0x11a>
 1016490:	4590      	cmp	r8, r2
 1016492:	f000 80a3 	beq.w	10165dc <ull_conn_done+0x200>
		lazy = lll->latency_event + 1U;
 1016496:	3201      	adds	r2, #1
 1016498:	b291      	uxth	r1, r2
	if (ticks_drift_plus || ticks_drift_minus || lazy || force) {
 101649a:	bb73      	cbnz	r3, 10164fa <ull_conn_done+0x11e>
 101649c:	bb6d      	cbnz	r5, 10164fa <ull_conn_done+0x11e>
 101649e:	bb61      	cbnz	r1, 10164fa <ull_conn_done+0x11e>
}
 10164a0:	b00d      	add	sp, #52	; 0x34
 10164a2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	ticks_drift_plus = 0U;
 10164a6:	2300      	movs	r3, #0
	if (done->extra.trx_cnt) {
 10164a8:	8caa      	ldrh	r2, [r5, #36]	; 0x24
		elapsed_event = latency_event + lll->latency_prepare;
 10164aa:	4446      	add	r6, r8
	ticks_drift_minus = 0U;
 10164ac:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
		elapsed_event = latency_event + lll->latency_prepare;
 10164b0:	b2b6      	uxth	r6, r6
	if (done->extra.trx_cnt) {
 10164b2:	2a00      	cmp	r2, #0
 10164b4:	d1bd      	bne.n	1016432 <ull_conn_done+0x56>
	if (done->extra.crc_valid) {
 10164b6:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 10164ba:	07da      	lsls	r2, r3, #31
 10164bc:	d4c6      	bmi.n	101644c <ull_conn_done+0x70>
	else if (conn->connect_expire) {
 10164be:	f8b4 3182 	ldrh.w	r3, [r4, #386]	; 0x182
 10164c2:	2b00      	cmp	r3, #0
 10164c4:	d074      	beq.n	10165b0 <ull_conn_done+0x1d4>
		if (conn->connect_expire > elapsed_event) {
 10164c6:	42b3      	cmp	r3, r6
 10164c8:	f240 80f0 	bls.w	10166ac <ull_conn_done+0x2d0>
			conn->connect_expire -= elapsed_event;
 10164cc:	1b9b      	subs	r3, r3, r6
 10164ce:	f8a4 3182 	strh.w	r3, [r4, #386]	; 0x182
	if (conn->supervision_expire) {
 10164d2:	f8b4 3186 	ldrh.w	r3, [r4, #390]	; 0x186
 10164d6:	2b00      	cmp	r3, #0
 10164d8:	d0bb      	beq.n	1016452 <ull_conn_done+0x76>
		if (conn->supervision_expire > elapsed_event) {
 10164da:	429e      	cmp	r6, r3
 10164dc:	f080 80cd 	bcs.w	101667a <ull_conn_done+0x29e>
			lll->latency_event = 0U;
 10164e0:	2200      	movs	r2, #0
			conn->supervision_expire -= elapsed_event;
 10164e2:	1b9b      	subs	r3, r3, r6
 10164e4:	b29b      	uxth	r3, r3
			if (conn->supervision_expire <= 6U) {
 10164e6:	2b06      	cmp	r3, #6
			conn->supervision_expire -= elapsed_event;
 10164e8:	f8a4 3186 	strh.w	r3, [r4, #390]	; 0x186
			lll->latency_event = 0U;
 10164ec:	8622      	strh	r2, [r4, #48]	; 0x30
			if (conn->supervision_expire <= 6U) {
 10164ee:	f200 8092 	bhi.w	1016616 <ull_conn_done+0x23a>
				force = 1U;
 10164f2:	2701      	movs	r7, #1
 10164f4:	e7ad      	b.n	1016452 <ull_conn_done+0x76>
		lazy = lll->latency_event + 1U;
 10164f6:	3201      	adds	r2, #1
 10164f8:	b291      	uxth	r1, r2
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
 10164fa:	2000      	movs	r0, #0
		uint8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
 10164fc:	8d22      	ldrh	r2, [r4, #40]	; 0x28
		struct ll_conn *conn = lll->hdr.parent;
 10164fe:	69e4      	ldr	r4, [r4, #28]
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
 1016500:	9500      	str	r5, [sp, #0]
 1016502:	4d77      	ldr	r5, [pc, #476]	; (10166e0 <ull_conn_done+0x304>)
		uint8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
 1016504:	3203      	adds	r2, #3
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
 1016506:	e9cd 1703 	strd	r1, r7, [sp, #12]
 101650a:	e9cd 0001 	strd	r0, r0, [sp, #4]
 101650e:	2101      	movs	r1, #1
 1016510:	9406      	str	r4, [sp, #24]
 1016512:	b2d2      	uxtb	r2, r2
 1016514:	9505      	str	r5, [sp, #20]
 1016516:	f7fb fe31 	bl	101217c <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 101651a:	f030 0302 	bics.w	r3, r0, #2
 101651e:	d0bf      	beq.n	10164a0 <ull_conn_done+0xc4>
 1016520:	f7fd ffc2 	bl	10144a8 <ull_disable_mark_get>
 1016524:	4284      	cmp	r4, r0
 1016526:	d0bb      	beq.n	10164a0 <ull_conn_done+0xc4>
 1016528:	f44f 63ec 	mov.w	r3, #1888	; 0x760
 101652c:	4a6d      	ldr	r2, [pc, #436]	; (10166e4 <ull_conn_done+0x308>)
 101652e:	496e      	ldr	r1, [pc, #440]	; (10166e8 <ull_conn_done+0x30c>)
 1016530:	486e      	ldr	r0, [pc, #440]	; (10166ec <ull_conn_done+0x310>)
 1016532:	f00e fb50 	bl	1024bd6 <assert_print>
 1016536:	4040      	eors	r0, r0
 1016538:	f380 8811 	msr	BASEPRI, r0
 101653c:	f04f 0003 	mov.w	r0, #3
 1016540:	df02      	svc	2
 1016542:	e7ad      	b.n	10164a0 <ull_conn_done+0xc4>
		if (lll->enc_rx && lll->enc_tx) {
 1016544:	f894 308e 	ldrb.w	r3, [r4, #142]	; 0x8e
 1016548:	f003 0318 	and.w	r3, r3, #24
 101654c:	2b18      	cmp	r3, #24
 101654e:	f47f af5d 	bne.w	101640c <ull_conn_done+0x30>
					    (lll->latency + 6)) ?
 1016552:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
			appto_reload_new = (conn->apto_reload >
 1016554:	f8b4 217e 	ldrh.w	r2, [r4, #382]	; 0x17e
					    (lll->latency + 6)) ?
 1016558:	1d8b      	adds	r3, r1, #6
			appto_reload_new = (conn->apto_reload >
 101655a:	429a      	cmp	r2, r3
 101655c:	bfd2      	itee	le
 101655e:	4613      	movle	r3, r2
 1016560:	1f93      	subgt	r3, r2, #6
 1016562:	1a5b      	subgt	r3, r3, r1
			if (conn->appto_reload != appto_reload_new) {
 1016564:	f8b4 117a 	ldrh.w	r1, [r4, #378]	; 0x17a
			appto_reload_new = (conn->apto_reload >
 1016568:	bfc8      	it	gt
 101656a:	b29b      	uxthgt	r3, r3
			if (conn->appto_reload != appto_reload_new) {
 101656c:	4299      	cmp	r1, r3
 101656e:	f000 8097 	beq.w	10166a0 <ull_conn_done+0x2c4>
				conn->appto_reload = appto_reload_new;
 1016572:	f8a4 317a 	strh.w	r3, [r4, #378]	; 0x17a
				conn->appto_expire = conn->appto_reload;
 1016576:	f8a4 317c 	strh.w	r3, [r4, #380]	; 0x17c
				conn->apto_expire = conn->apto_reload;
 101657a:	f8a4 2180 	strh.w	r2, [r4, #384]	; 0x180
 101657e:	e745      	b.n	101640c <ull_conn_done+0x30>
		conn->llcp_terminate.reason_final =
 1016580:	233d      	movs	r3, #61	; 0x3d
	reason_final = conn->llcp_terminate.reason_final;
 1016582:	461f      	mov	r7, r3
		conn->llcp_terminate.reason_final =
 1016584:	f884 3148 	strb.w	r3, [r4, #328]	; 0x148
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
 1016588:	2318      	movs	r3, #24
	conn_cleanup_finalize(conn);
 101658a:	4620      	mov	r0, r4
	rx->hdr.handle = conn->lll.handle;
 101658c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
	*((uint8_t *)rx->pdu) = reason;
 101658e:	f884 7168 	strb.w	r7, [r4, #360]	; 0x168
	rx->hdr.handle = conn->lll.handle;
 1016592:	f8a4 2152 	strh.w	r2, [r4, #338]	; 0x152
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
 1016596:	f884 3150 	strb.w	r3, [r4, #336]	; 0x150
}
 101659a:	b00d      	add	sp, #52	; 0x34
 101659c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	conn_cleanup_finalize(conn);
 10165a0:	f7ff be9e 	b.w	10162e0 <conn_cleanup_finalize>
		conn->appto_expire = conn->apto_expire = 0U;
 10165a4:	2300      	movs	r3, #0
 10165a6:	f8a4 3180 	strh.w	r3, [r4, #384]	; 0x180
 10165aa:	f8a4 317c 	strh.w	r3, [r4, #380]	; 0x17c
		break;
 10165ae:	e72d      	b.n	101640c <ull_conn_done+0x30>
		if (!conn->supervision_expire) {
 10165b0:	f8b4 3186 	ldrh.w	r3, [r4, #390]	; 0x186
 10165b4:	2b00      	cmp	r3, #0
 10165b6:	d190      	bne.n	10164da <ull_conn_done+0xfe>
			const uint32_t conn_interval_us = conn->lll.interval * CONN_INT_UNIT_US;
 10165b8:	f240 43e2 	movw	r3, #1250	; 0x4e2
			conn->supervision_expire = RADIO_CONN_EVENTS(
 10165bc:	f242 7110 	movw	r1, #10000	; 0x2710
			const uint32_t conn_interval_us = conn->lll.interval * CONN_INT_UNIT_US;
 10165c0:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 10165c2:	fb03 f202 	mul.w	r2, r3, r2
			conn->supervision_expire = RADIO_CONN_EVENTS(
 10165c6:	f8b4 3184 	ldrh.w	r3, [r4, #388]	; 0x184
 10165ca:	fb01 2303 	mla	r3, r1, r3, r2
 10165ce:	3b01      	subs	r3, #1
 10165d0:	fbb3 f3f2 	udiv	r3, r3, r2
 10165d4:	b29b      	uxth	r3, r3
 10165d6:	f8a4 3186 	strh.w	r3, [r4, #390]	; 0x186
 10165da:	e77c      	b.n	10164d6 <ull_conn_done+0xfa>
	if (ticks_drift_plus || ticks_drift_minus || lazy || force) {
 10165dc:	b913      	cbnz	r3, 10165e4 <ull_conn_done+0x208>
 10165de:	2d00      	cmp	r5, #0
 10165e0:	f43f af5e 	beq.w	10164a0 <ull_conn_done+0xc4>
	lazy = 0U;
 10165e4:	4639      	mov	r1, r7
 10165e6:	e788      	b.n	10164fa <ull_conn_done+0x11e>
			rx = ll_pdu_rx_alloc();
 10165e8:	f7fd feae 	bl	1014348 <ll_pdu_rx_alloc>
			if (rx) {
 10165ec:	4601      	mov	r1, r0
 10165ee:	2800      	cmp	r0, #0
 10165f0:	d052      	beq.n	1016698 <ull_conn_done+0x2bc>
				conn->apto_expire = 0U;
 10165f2:	2300      	movs	r3, #0
 10165f4:	f8a4 3180 	strh.w	r3, [r4, #384]	; 0x180
				rx->type = NODE_RX_TYPE_APTO;
 10165f8:	231b      	movs	r3, #27
				rx->handle = lll->handle;
 10165fa:	8d22      	ldrh	r2, [r4, #40]	; 0x28
				rx->type = NODE_RX_TYPE_APTO;
 10165fc:	7103      	strb	r3, [r0, #4]
				rx->handle = lll->handle;
 10165fe:	80c2      	strh	r2, [r0, #6]
				ll_rx_put_sched(rx->link, rx);
 1016600:	6800      	ldr	r0, [r0, #0]
 1016602:	f7fd fe6b 	bl	10142dc <ll_rx_put_sched>
 1016606:	e736      	b.n	1016476 <ull_conn_done+0x9a>
			conn->appto_expire = 0U;
 1016608:	2300      	movs	r3, #0
			ull_cp_le_ping(conn);
 101660a:	4620      	mov	r0, r4
			conn->appto_expire = 0U;
 101660c:	f8a4 317c 	strh.w	r3, [r4, #380]	; 0x17c
			ull_cp_le_ping(conn);
 1016610:	f001 fdf6 	bl	1018200 <ull_cp_le_ping>
 1016614:	e738      	b.n	1016488 <ull_conn_done+0xac>
			else if (lll->role) {
 1016616:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
 101661a:	4293      	cmp	r3, r2
 101661c:	f6bf af19 	bge.w	1016452 <ull_conn_done+0x76>
				if (latency_event) {
 1016620:	f1b8 0f00 	cmp.w	r8, #0
 1016624:	f47f af65 	bne.w	10164f2 <ull_conn_done+0x116>
					force = conn->periph.force & 0x01;
 1016628:	f8d4 3170 	ldr.w	r3, [r4, #368]	; 0x170
					conn->periph.force >>= 1U;
 101662c:	085a      	lsrs	r2, r3, #1
					if (force) {
 101662e:	07db      	lsls	r3, r3, #31
 1016630:	d451      	bmi.n	10166d6 <ull_conn_done+0x2fa>
					conn->periph.force >>= 1U;
 1016632:	f8c4 2170 	str.w	r2, [r4, #368]	; 0x170
 1016636:	e70c      	b.n	1016452 <ull_conn_done+0x76>
			ull_drift_ticks_get(done, &ticks_drift_plus,
 1016638:	4628      	mov	r0, r5
 101663a:	aa0a      	add	r2, sp, #40	; 0x28
 101663c:	a90b      	add	r1, sp, #44	; 0x2c
			if (!ull_tx_q_peek(&conn->tx_q)) {
 101663e:	f104 09d4 	add.w	r9, r4, #212	; 0xd4
			ull_drift_ticks_get(done, &ticks_drift_plus,
 1016642:	f7ea f8c9 	bl	10007d8 <ull_drift_ticks_get>
			if (!ull_tx_q_peek(&conn->tx_q)) {
 1016646:	4648      	mov	r0, r9
 1016648:	f001 fb50 	bl	1017cec <ull_tx_q_peek>
 101664c:	2800      	cmp	r0, #0
 101664e:	d03e      	beq.n	10166ce <ull_conn_done+0x2f2>
			if (ull_tx_q_peek(&conn->tx_q) ||
 1016650:	4648      	mov	r0, r9
 1016652:	f001 fb4b 	bl	1017cec <ull_tx_q_peek>
 1016656:	b360      	cbz	r0, 10166b2 <ull_conn_done+0x2d6>
				lll->latency_event = 0U;
 1016658:	2300      	movs	r3, #0
 101665a:	8623      	strh	r3, [r4, #48]	; 0x30
 101665c:	e6ee      	b.n	101643c <ull_conn_done+0x60>
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
 101665e:	2318      	movs	r3, #24
		conn_cleanup(conn, error_code);
 1016660:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
	rx->hdr.handle = conn->lll.handle;
 1016664:	8d21      	ldrh	r1, [r4, #40]	; 0x28
	conn_cleanup_finalize(conn);
 1016666:	4620      	mov	r0, r4
	rx->hdr.handle = conn->lll.handle;
 1016668:	f8a4 1152 	strh.w	r1, [r4, #338]	; 0x152
	*((uint8_t *)rx->pdu) = reason;
 101666c:	f884 2168 	strb.w	r2, [r4, #360]	; 0x168
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
 1016670:	f884 3150 	strb.w	r3, [r4, #336]	; 0x150
	conn_cleanup_finalize(conn);
 1016674:	f7ff fe34 	bl	10162e0 <conn_cleanup_finalize>
		return;
 1016678:	e712      	b.n	10164a0 <ull_conn_done+0xc4>
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
 101667a:	2218      	movs	r2, #24
	*((uint8_t *)rx->pdu) = reason;
 101667c:	2308      	movs	r3, #8
	rx->hdr.handle = conn->lll.handle;
 101667e:	8d21      	ldrh	r1, [r4, #40]	; 0x28
	conn_cleanup_finalize(conn);
 1016680:	4620      	mov	r0, r4
	rx->hdr.handle = conn->lll.handle;
 1016682:	f8a4 1152 	strh.w	r1, [r4, #338]	; 0x152
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
 1016686:	f884 2150 	strb.w	r2, [r4, #336]	; 0x150
	*((uint8_t *)rx->pdu) = reason;
 101668a:	f884 3168 	strb.w	r3, [r4, #360]	; 0x168
	conn_cleanup_finalize(conn);
 101668e:	f7ff fe27 	bl	10162e0 <conn_cleanup_finalize>
}
 1016692:	b00d      	add	sp, #52	; 0x34
 1016694:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				conn->apto_expire = 1U;
 1016698:	2301      	movs	r3, #1
 101669a:	f8a4 3180 	strh.w	r3, [r4, #384]	; 0x180
 101669e:	e6ea      	b.n	1016476 <ull_conn_done+0x9a>
			if (conn->apto_expire == 0U) {
 10166a0:	f8b4 1180 	ldrh.w	r1, [r4, #384]	; 0x180
 10166a4:	2900      	cmp	r1, #0
 10166a6:	f47f aeb1 	bne.w	101640c <ull_conn_done+0x30>
 10166aa:	e764      	b.n	1016576 <ull_conn_done+0x19a>
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
 10166ac:	2218      	movs	r2, #24
	*((uint8_t *)rx->pdu) = reason;
 10166ae:	233e      	movs	r3, #62	; 0x3e
 10166b0:	e7e5      	b.n	101667e <ull_conn_done+0x2a2>
			    memq_peek(lll->memq_tx.head,
 10166b2:	4602      	mov	r2, r0
 10166b4:	e9d4 011e 	ldrd	r0, r1, [r4, #120]	; 0x78
 10166b8:	f7fa fc26 	bl	1010f08 <memq_peek>
			if (ull_tx_q_peek(&conn->tx_q) ||
 10166bc:	2800      	cmp	r0, #0
 10166be:	d1cb      	bne.n	1016658 <ull_conn_done+0x27c>
			} else if (lll->periph.latency_enabled) {
 10166c0:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 10166c4:	0758      	lsls	r0, r3, #29
				lll->latency_event = lll->latency;
 10166c6:	bf44      	itt	mi
 10166c8:	8da3      	ldrhmi	r3, [r4, #44]	; 0x2c
 10166ca:	8623      	strhmi	r3, [r4, #48]	; 0x30
 10166cc:	e6b6      	b.n	101643c <ull_conn_done+0x60>
				ull_conn_tx_demux(UINT8_MAX);
 10166ce:	20ff      	movs	r0, #255	; 0xff
 10166d0:	f7ff fdc4 	bl	101625c <ull_conn_tx_demux>
 10166d4:	e7bc      	b.n	1016650 <ull_conn_done+0x274>
						conn->periph.force |= BIT(31);
 10166d6:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 10166da:	f8c4 2170 	str.w	r2, [r4, #368]	; 0x170
 10166de:	e708      	b.n	10164f2 <ull_conn_done+0x116>
 10166e0:	01015a1d 	.word	0x01015a1d
 10166e4:	0102a8dc 	.word	0x0102a8dc
 10166e8:	0102aa04 	.word	0x0102aa04
 10166ec:	0102a278 	.word	0x0102a278

010166f0 <ull_conn_tx_lll_enqueue>:
	while (count--) {
 10166f0:	2900      	cmp	r1, #0
 10166f2:	d03a      	beq.n	101676a <ull_conn_tx_lll_enqueue+0x7a>
{
 10166f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10166f8:	1e4d      	subs	r5, r1, #1
 10166fa:	4607      	mov	r7, r0
		link = mem_acquire(&mem_link_tx.free);
 10166fc:	f8df 906c 	ldr.w	r9, [pc, #108]	; 101676c <ull_conn_tx_lll_enqueue+0x7c>
		LL_ASSERT(link);
 1016700:	f8df b06c 	ldr.w	fp, [pc, #108]	; 1016770 <ull_conn_tx_lll_enqueue+0x80>
 1016704:	f8df a06c 	ldr.w	sl, [pc, #108]	; 1016774 <ull_conn_tx_lll_enqueue+0x84>
 1016708:	b2ed      	uxtb	r5, r5
	tx = ull_tx_q_dequeue(&conn->tx_q);
 101670a:	f100 08d4 	add.w	r8, r0, #212	; 0xd4
 101670e:	e016      	b.n	101673e <ull_conn_tx_lll_enqueue+0x4e>
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
 1016710:	7923      	ldrb	r3, [r4, #4]
		link = mem_acquire(&mem_link_tx.free);
 1016712:	4648      	mov	r0, r9
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
 1016714:	f003 0303 	and.w	r3, r3, #3
			tx->next = tx;
 1016718:	2b03      	cmp	r3, #3
 101671a:	bf0c      	ite	eq
 101671c:	4623      	moveq	r3, r4
 101671e:	2300      	movne	r3, #0
 1016720:	6023      	str	r3, [r4, #0]
		link = mem_acquire(&mem_link_tx.free);
 1016722:	f7fa fb81 	bl	1010e28 <mem_acquire>
		LL_ASSERT(link);
 1016726:	4606      	mov	r6, r0
 1016728:	b188      	cbz	r0, 101674e <ull_conn_tx_lll_enqueue+0x5e>
	while (count--) {
 101672a:	3d01      	subs	r5, #1
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
 101672c:	4621      	mov	r1, r4
 101672e:	4630      	mov	r0, r6
 1016730:	f107 027c 	add.w	r2, r7, #124	; 0x7c
	while (count--) {
 1016734:	b2ed      	uxtb	r5, r5
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
 1016736:	f7fa fbdd 	bl	1010ef4 <memq_enqueue>
	while (count--) {
 101673a:	2dff      	cmp	r5, #255	; 0xff
 101673c:	d005      	beq.n	101674a <ull_conn_tx_lll_enqueue+0x5a>
	tx = ull_tx_q_dequeue(&conn->tx_q);
 101673e:	4640      	mov	r0, r8
 1016740:	f001 fad6 	bl	1017cf0 <ull_tx_q_dequeue>
	if (tx) {
 1016744:	4604      	mov	r4, r0
 1016746:	2800      	cmp	r0, #0
 1016748:	d1e2      	bne.n	1016710 <ull_conn_tx_lll_enqueue+0x20>
}
 101674a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		LL_ASSERT(link);
 101674e:	f240 73d5 	movw	r3, #2005	; 0x7d5
 1016752:	465a      	mov	r2, fp
 1016754:	4651      	mov	r1, sl
 1016756:	4808      	ldr	r0, [pc, #32]	; (1016778 <ull_conn_tx_lll_enqueue+0x88>)
 1016758:	f00e fa3d 	bl	1024bd6 <assert_print>
 101675c:	4040      	eors	r0, r0
 101675e:	f380 8811 	msr	BASEPRI, r0
 1016762:	f04f 0003 	mov.w	r0, #3
 1016766:	df02      	svc	2
 1016768:	e7df      	b.n	101672a <ull_conn_tx_lll_enqueue+0x3a>
 101676a:	4770      	bx	lr
 101676c:	21006d18 	.word	0x21006d18
 1016770:	0102a8dc 	.word	0x0102a8dc
 1016774:	0102a92c 	.word	0x0102a92c
 1016778:	0102a278 	.word	0x0102a278

0101677c <tx_demux>:
{
 101677c:	b510      	push	{r4, lr}
 101677e:	4604      	mov	r4, r0
	ull_conn_tx_demux(1);
 1016780:	2001      	movs	r0, #1
 1016782:	f7ff fd6b 	bl	101625c <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(param, 1);
 1016786:	4620      	mov	r0, r4
}
 1016788:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	ull_conn_tx_lll_enqueue(param, 1);
 101678c:	2101      	movs	r1, #1
 101678e:	f7ff bfaf 	b.w	10166f0 <ull_conn_tx_lll_enqueue>
 1016792:	bf00      	nop

01016794 <ull_conn_link_tx_release>:
	mem_release(link, &mem_link_tx.free);
 1016794:	4901      	ldr	r1, [pc, #4]	; (101679c <ull_conn_link_tx_release+0x8>)
 1016796:	f7fa bb63 	b.w	1010e60 <mem_release>
 101679a:	bf00      	nop
 101679c:	21006d18 	.word	0x21006d18

010167a0 <ull_conn_ack_last_idx_get>:
	return mfifo_conn_ack.l;
 10167a0:	4b01      	ldr	r3, [pc, #4]	; (10167a8 <ull_conn_ack_last_idx_get+0x8>)
}
 10167a2:	7958      	ldrb	r0, [r3, #5]
 10167a4:	4770      	bx	lr
 10167a6:	bf00      	nop
 10167a8:	2100082c 	.word	0x2100082c

010167ac <ull_conn_ack_peek>:
{
 10167ac:	b510      	push	{r4, lr}
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
 10167ae:	4b0c      	ldr	r3, [pc, #48]	; (10167e0 <ull_conn_ack_peek+0x34>)
 10167b0:	f893 c004 	ldrb.w	ip, [r3, #4]
 10167b4:	f893 e005 	ldrb.w	lr, [r3, #5]
 10167b8:	781c      	ldrb	r4, [r3, #0]
	if (first == last) {
 10167ba:	45f4      	cmp	ip, lr
 10167bc:	d00d      	beq.n	10167da <ull_conn_ack_peek+0x2e>
	return (void *)(fifo + first * size);
 10167be:	fb04 fc0c 	mul.w	ip, r4, ip
	*ack_last = mfifo_conn_ack.l;
 10167c2:	f880 e000 	strb.w	lr, [r0]
 10167c6:	3308      	adds	r3, #8
 10167c8:	eb0c 0003 	add.w	r0, ip, r3
	*handle = lll_tx->handle;
 10167cc:	f833 300c 	ldrh.w	r3, [r3, ip]
 10167d0:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
 10167d2:	6843      	ldr	r3, [r0, #4]
 10167d4:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
 10167d6:	6818      	ldr	r0, [r3, #0]
}
 10167d8:	bd10      	pop	{r4, pc}
		return NULL;
 10167da:	2000      	movs	r0, #0
}
 10167dc:	bd10      	pop	{r4, pc}
 10167de:	bf00      	nop
 10167e0:	2100082c 	.word	0x2100082c

010167e4 <ull_conn_ack_by_last_peek>:
{
 10167e4:	b500      	push	{lr}
	lll_tx = mfifo_dequeue_get(mfifo_conn_ack.m, mfifo_conn_ack.s,
 10167e6:	4b0b      	ldr	r3, [pc, #44]	; (1016814 <ull_conn_ack_by_last_peek+0x30>)
 10167e8:	f893 c004 	ldrb.w	ip, [r3, #4]
 10167ec:	f893 e000 	ldrb.w	lr, [r3]
	if (first == last) {
 10167f0:	4584      	cmp	ip, r0
 10167f2:	d00c      	beq.n	101680e <ull_conn_ack_by_last_peek+0x2a>
	return (void *)(fifo + first * size);
 10167f4:	fb0e fc0c 	mul.w	ip, lr, ip
 10167f8:	3308      	adds	r3, #8
 10167fa:	eb0c 0003 	add.w	r0, ip, r3
	*handle = lll_tx->handle;
 10167fe:	f833 300c 	ldrh.w	r3, [r3, ip]
 1016802:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
 1016804:	6843      	ldr	r3, [r0, #4]
 1016806:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
 1016808:	6818      	ldr	r0, [r3, #0]
}
 101680a:	f85d fb04 	ldr.w	pc, [sp], #4
		return NULL;
 101680e:	2000      	movs	r0, #0
 1016810:	e7fb      	b.n	101680a <ull_conn_ack_by_last_peek+0x26>
 1016812:	bf00      	nop
 1016814:	2100082c 	.word	0x2100082c

01016818 <ull_conn_ack_dequeue>:
	return MFIFO_DEQUEUE(conn_ack);
 1016818:	4b09      	ldr	r3, [pc, #36]	; (1016840 <ull_conn_ack_dequeue+0x28>)
	uint8_t _first = *first; /* Copy read-index */
 101681a:	7919      	ldrb	r1, [r3, #4]
	if (_first == last) {
 101681c:	795a      	ldrb	r2, [r3, #5]
 101681e:	7818      	ldrb	r0, [r3, #0]
 1016820:	428a      	cmp	r2, r1
 1016822:	f893 c002 	ldrb.w	ip, [r3, #2]
 1016826:	d009      	beq.n	101683c <ull_conn_ack_dequeue+0x24>
	_first += 1U;
 1016828:	1c4a      	adds	r2, r1, #1
 101682a:	b2d2      	uxtb	r2, r2
		_first = 0U;
 101682c:	4594      	cmp	ip, r2
 101682e:	bf08      	it	eq
 1016830:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
 1016832:	fb00 3101 	mla	r1, r0, r1, r3
 1016836:	6888      	ldr	r0, [r1, #8]
	*first = _first; /* Write back read-index */
 1016838:	711a      	strb	r2, [r3, #4]
	return mem;
 101683a:	4770      	bx	lr
		return NULL;
 101683c:	2000      	movs	r0, #0
}
 101683e:	4770      	bx	lr
 1016840:	2100082c 	.word	0x2100082c

01016844 <ull_conn_lll_ack_enqueue>:
{
 1016844:	b538      	push	{r3, r4, r5, lr}
	idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
 1016846:	4c14      	ldr	r4, [pc, #80]	; (1016898 <ull_conn_lll_ack_enqueue+0x54>)
 1016848:	7962      	ldrb	r2, [r4, #5]
	if (last == count) {
 101684a:	f894 e002 	ldrb.w	lr, [r4, #2]
	last = last + 1;
 101684e:	1c53      	adds	r3, r2, #1
 1016850:	b2db      	uxtb	r3, r3
		last = 0U;
 1016852:	459e      	cmp	lr, r3
 1016854:	bf08      	it	eq
 1016856:	2300      	moveq	r3, #0
 1016858:	f894 c004 	ldrb.w	ip, [r4, #4]
 101685c:	7825      	ldrb	r5, [r4, #0]
	if (last == first) {
 101685e:	459c      	cmp	ip, r3
 1016860:	d009      	beq.n	1016876 <ull_conn_lll_ack_enqueue+0x32>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 1016862:	fb05 f202 	mul.w	r2, r5, r2
 1016866:	f104 0c08 	add.w	ip, r4, #8
	lll_tx->handle = handle;
 101686a:	f82c 0002 	strh.w	r0, [ip, r2]
 101686e:	4462      	add	r2, ip
	lll_tx->node = tx;
 1016870:	6051      	str	r1, [r2, #4]
	*last = idx; /* Commit: Update write index */
 1016872:	7163      	strb	r3, [r4, #5]
}
 1016874:	bd38      	pop	{r3, r4, r5, pc}
	LL_ASSERT(lll_tx);
 1016876:	f640 0315 	movw	r3, #2069	; 0x815
 101687a:	4a08      	ldr	r2, [pc, #32]	; (101689c <ull_conn_lll_ack_enqueue+0x58>)
 101687c:	4908      	ldr	r1, [pc, #32]	; (10168a0 <ull_conn_lll_ack_enqueue+0x5c>)
 101687e:	4809      	ldr	r0, [pc, #36]	; (10168a4 <ull_conn_lll_ack_enqueue+0x60>)
 1016880:	f00e f9a9 	bl	1024bd6 <assert_print>
 1016884:	4040      	eors	r0, r0
 1016886:	f380 8811 	msr	BASEPRI, r0
 101688a:	f04f 0003 	mov.w	r0, #3
 101688e:	df02      	svc	2
	lll_tx->handle = handle;
 1016890:	2300      	movs	r3, #0
 1016892:	801b      	strh	r3, [r3, #0]
 1016894:	deff      	udf	#255	; 0xff
 1016896:	bf00      	nop
 1016898:	2100082c 	.word	0x2100082c
 101689c:	0102a8dc 	.word	0x0102a8dc
 10168a0:	0102a91c 	.word	0x0102a91c
 10168a4:	0102a278 	.word	0x0102a278

010168a8 <ull_conn_tx_ack>:
{
 10168a8:	b570      	push	{r4, r5, r6, lr}
	LL_ASSERT(pdu_tx->len);
 10168aa:	7953      	ldrb	r3, [r2, #5]
{
 10168ac:	4614      	mov	r4, r2
 10168ae:	4605      	mov	r5, r0
 10168b0:	460e      	mov	r6, r1
	LL_ASSERT(pdu_tx->len);
 10168b2:	b36b      	cbz	r3, 1016910 <ull_conn_tx_ack+0x68>
	if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
 10168b4:	7923      	ldrb	r3, [r4, #4]
 10168b6:	f003 0203 	and.w	r2, r3, #3
 10168ba:	2a03      	cmp	r2, #3
 10168bc:	d00c      	beq.n	10168d8 <ull_conn_tx_ack+0x30>
	} else if (handle == LLL_HANDLE_INVALID) {
 10168be:	f64f 72ff 	movw	r2, #65535	; 0xffff
 10168c2:	4295      	cmp	r5, r2
		pdu_tx->ll_id = PDU_DATA_LLID_RESV;
 10168c4:	bf04      	itt	eq
 10168c6:	f36f 0301 	bfceq	r3, #0, #2
 10168ca:	7123      	strbeq	r3, [r4, #4]
	ll_tx_ack_put(handle, tx);
 10168cc:	4621      	mov	r1, r4
 10168ce:	4628      	mov	r0, r5
}
 10168d0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ll_tx_ack_put(handle, tx);
 10168d4:	f7fd bd4e 	b.w	1014374 <ll_tx_ack_put>
		if (handle != LLL_HANDLE_INVALID) {
 10168d8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 10168dc:	429d      	cmp	r5, r3
 10168de:	d125      	bne.n	101692c <ull_conn_tx_ack+0x84>
		if (link->next == (void *)tx) {
 10168e0:	6833      	ldr	r3, [r6, #0]
 10168e2:	429c      	cmp	r4, r3
 10168e4:	d039      	beq.n	101695a <ull_conn_tx_ack+0xb2>
		LL_ASSERT(!link->next);
 10168e6:	2b00      	cmp	r3, #0
 10168e8:	d0f0      	beq.n	10168cc <ull_conn_tx_ack+0x24>
 10168ea:	f640 0345 	movw	r3, #2117	; 0x845
 10168ee:	4a1e      	ldr	r2, [pc, #120]	; (1016968 <ull_conn_tx_ack+0xc0>)
 10168f0:	491e      	ldr	r1, [pc, #120]	; (101696c <ull_conn_tx_ack+0xc4>)
 10168f2:	481f      	ldr	r0, [pc, #124]	; (1016970 <ull_conn_tx_ack+0xc8>)
 10168f4:	f00e f96f 	bl	1024bd6 <assert_print>
 10168f8:	4040      	eors	r0, r0
 10168fa:	f380 8811 	msr	BASEPRI, r0
 10168fe:	f04f 0003 	mov.w	r0, #3
 1016902:	df02      	svc	2
	ll_tx_ack_put(handle, tx);
 1016904:	4621      	mov	r1, r4
 1016906:	4628      	mov	r0, r5
}
 1016908:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ll_tx_ack_put(handle, tx);
 101690c:	f7fd bd32 	b.w	1014374 <ll_tx_ack_put>
	LL_ASSERT(pdu_tx->len);
 1016910:	f640 0322 	movw	r3, #2082	; 0x822
 1016914:	4a14      	ldr	r2, [pc, #80]	; (1016968 <ull_conn_tx_ack+0xc0>)
 1016916:	4917      	ldr	r1, [pc, #92]	; (1016974 <ull_conn_tx_ack+0xcc>)
 1016918:	4815      	ldr	r0, [pc, #84]	; (1016970 <ull_conn_tx_ack+0xc8>)
 101691a:	f00e f95c 	bl	1024bd6 <assert_print>
 101691e:	4040      	eors	r0, r0
 1016920:	f380 8811 	msr	BASEPRI, r0
 1016924:	f04f 0003 	mov.w	r0, #3
 1016928:	df02      	svc	2
 101692a:	e7c3      	b.n	10168b4 <ull_conn_tx_ack+0xc>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 101692c:	462a      	mov	r2, r5
 101692e:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 1016932:	4811      	ldr	r0, [pc, #68]	; (1016978 <ull_conn_tx_ack+0xd0>)
 1016934:	f7fa faac 	bl	1010e90 <mem_get>
			ull_cp_tx_ack(conn, tx);
 1016938:	4621      	mov	r1, r4
 101693a:	f001 fdd7 	bl	10184ec <ull_cp_tx_ack>
		if (link->next == (void *)tx) {
 101693e:	6833      	ldr	r3, [r6, #0]
 1016940:	42a3      	cmp	r3, r4
 1016942:	d1d0      	bne.n	10168e6 <ull_conn_tx_ack+0x3e>
	if (handle >= CONFIG_BT_MAX_CONN) {
 1016944:	2d07      	cmp	r5, #7
 1016946:	d808      	bhi.n	101695a <ull_conn_tx_ack+0xb2>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 1016948:	462a      	mov	r2, r5
 101694a:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 101694e:	480a      	ldr	r0, [pc, #40]	; (1016978 <ull_conn_tx_ack+0xd0>)
 1016950:	f7fa fa9e 	bl	1010e90 <mem_get>
	if (conn->lll.handle != handle) {
 1016954:	8d03      	ldrh	r3, [r0, #40]	; 0x28
 1016956:	42ab      	cmp	r3, r5
 1016958:	d000      	beq.n	101695c <ull_conn_tx_ack+0xb4>
		return NULL;
 101695a:	2000      	movs	r0, #0
			ull_cp_release_tx(conn, tx);
 101695c:	4621      	mov	r1, r4
}
 101695e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			ull_cp_release_tx(conn, tx);
 1016962:	f001 bbcd 	b.w	1018100 <ull_cp_release_tx>
 1016966:	bf00      	nop
 1016968:	0102a8dc 	.word	0x0102a8dc
 101696c:	0102aa6c 	.word	0x0102aa6c
 1016970:	0102a278 	.word	0x0102a278
 1016974:	0102aa60 	.word	0x0102aa60
 1016978:	210036f0 	.word	0x210036f0

0101697c <ull_conn_lll_max_tx_octets_get>:
	switch (lll->phy_tx_time) {
 101697c:	f890 205a 	ldrb.w	r2, [r0, #90]	; 0x5a
		max_tx_octets = (lll->dle.eff.max_tx_time >> 3) - 10;
 1016980:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
	switch (lll->phy_tx_time) {
 1016984:	f3c2 1202 	ubfx	r2, r2, #4, #3
 1016988:	2a02      	cmp	r2, #2
		max_tx_octets = (lll->dle.eff.max_tx_time >> 3) - 10;
 101698a:	bf14      	ite	ne
 101698c:	08db      	lsrne	r3, r3, #3
		max_tx_octets = (lll->dle.eff.max_tx_time >> 2) - 11;
 101698e:	089b      	lsreq	r3, r3, #2
	if (lll->enc_tx) {
 1016990:	f890 2072 	ldrb.w	r2, [r0, #114]	; 0x72
		max_tx_octets = (lll->dle.eff.max_tx_time >> 3) - 10;
 1016994:	bf14      	ite	ne
 1016996:	3b0a      	subne	r3, #10
		max_tx_octets = (lll->dle.eff.max_tx_time >> 2) - 11;
 1016998:	3b0b      	subeq	r3, #11
 101699a:	b29b      	uxth	r3, r3
	if (lll->enc_tx) {
 101699c:	06d2      	lsls	r2, r2, #27
		max_tx_octets -= 4U;
 101699e:	bf48      	it	mi
 10169a0:	3b04      	submi	r3, #4
	return max_tx_octets;
 10169a2:	f8b0 004c 	ldrh.w	r0, [r0, #76]	; 0x4c
		max_tx_octets -= 4U;
 10169a6:	bf48      	it	mi
 10169a8:	b29b      	uxthmi	r3, r3
}
 10169aa:	4298      	cmp	r0, r3
 10169ac:	bf28      	it	cs
 10169ae:	4618      	movcs	r0, r3
 10169b0:	4770      	bx	lr
 10169b2:	bf00      	nop

010169b4 <ull_pdu_data_init>:
}
 10169b4:	4770      	bx	lr
 10169b6:	bf00      	nop

010169b8 <ull_conn_pause_rx_data>:
	conn->pause_rx_data = 1U;
 10169b8:	f890 3178 	ldrb.w	r3, [r0, #376]	; 0x178
 10169bc:	f043 0302 	orr.w	r3, r3, #2
 10169c0:	f880 3178 	strb.w	r3, [r0, #376]	; 0x178
}
 10169c4:	4770      	bx	lr
 10169c6:	bf00      	nop

010169c8 <ull_conn_resume_rx_data>:
	conn->pause_rx_data = 0U;
 10169c8:	f890 3178 	ldrb.w	r3, [r0, #376]	; 0x178
 10169cc:	f36f 0341 	bfc	r3, #1, #1
 10169d0:	f880 3178 	strb.w	r3, [r0, #376]	; 0x178
}
 10169d4:	4770      	bx	lr
 10169d6:	bf00      	nop

010169d8 <ull_conn_event_counter>:
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
 10169d8:	8e43      	ldrh	r3, [r0, #50]	; 0x32
 10169da:	f8b0 1110 	ldrh.w	r1, [r0, #272]	; 0x110
 10169de:	8dc2      	ldrh	r2, [r0, #46]	; 0x2e
 10169e0:	1858      	adds	r0, r3, r1
 10169e2:	4410      	add	r0, r2
}
 10169e4:	b280      	uxth	r0, r0
 10169e6:	4770      	bx	lr

010169e8 <ull_conn_chan_map_set>:

}
#endif /* CONFIG_BT_PERIPHERAL */

void ull_conn_chan_map_set(struct ll_conn *conn, const uint8_t chm[5])
{
 10169e8:	b538      	push	{r3, r4, r5, lr}
	struct lll_conn *lll = &conn->lll;

	memcpy(lll->data_chan_map, chm, sizeof(lll->data_chan_map));
 10169ea:	f100 0534 	add.w	r5, r0, #52	; 0x34
{
 10169ee:	4604      	mov	r4, r0
	memcpy(lll->data_chan_map, chm, sizeof(lll->data_chan_map));
 10169f0:	2205      	movs	r2, #5
 10169f2:	4628      	mov	r0, r5
 10169f4:	f00f ffbe 	bl	1026974 <memcpy>
	lll->data_chan_count = util_ones_count_get(lll->data_chan_map, sizeof(lll->data_chan_map));
 10169f8:	2105      	movs	r1, #5
 10169fa:	4628      	mov	r0, r5
 10169fc:	f7fa fbf6 	bl	10111ec <util_ones_count_get>
 1016a00:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 1016a04:	f360 0305 	bfi	r3, r0, #0, #6
 1016a08:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
}
 1016a0c:	bd38      	pop	{r3, r4, r5, pc}
 1016a0e:	bf00      	nop

01016a10 <ull_dle_max_time_get>:
#endif

	rx_time = PDU_DC_MAX_US(LL_LENGTH_OCTETS_RX_MAX, phy_select);

#if defined(CONFIG_BT_CTLR_PHY)
	tx_time = MIN(conn->lll.dle.default_tx_time,
 1016a10:	f640 0c48 	movw	ip, #2120	; 0x848
 1016a14:	f8b0 3070 	ldrh.w	r3, [r0, #112]	; 0x70
	 * minimum value for time is 328 us
	 */
	rx_time = MAX(PDU_DC_PAYLOAD_TIME_MIN, rx_time);
	tx_time = MAX(PDU_DC_PAYLOAD_TIME_MIN, tx_time);

	*max_rx_time = rx_time;
 1016a18:	f8a1 c000 	strh.w	ip, [r1]
	tx_time = MIN(conn->lll.dle.default_tx_time,
 1016a1c:	4563      	cmp	r3, ip
 1016a1e:	bf28      	it	cs
 1016a20:	4663      	movcs	r3, ip
	tx_time = MAX(PDU_DC_PAYLOAD_TIME_MIN, tx_time);
 1016a22:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 1016a26:	bf38      	it	cc
 1016a28:	f44f 73a4 	movcc.w	r3, #328	; 0x148
	*max_tx_time = tx_time;
 1016a2c:	8013      	strh	r3, [r2, #0]

void ull_dle_max_time_get(struct ll_conn *conn, uint16_t *max_rx_time,
				    uint16_t *max_tx_time)
{
	return dle_max_time_get(conn, max_rx_time, max_tx_time);
}
 1016a2e:	4770      	bx	lr

01016a30 <ull_dle_update_eff>:
/*
 * TODO: this probably can be optimised for ex. by creating a macro for the
 * ull_dle_update_eff function
 */
uint8_t ull_dle_update_eff(struct ll_conn *conn)
{
 1016a30:	b510      	push	{r4, lr}
uint8_t ull_dle_update_eff_rx(struct ll_conn *conn)
{
	uint8_t dle_changed = 0U;

	const uint16_t eff_rx_octets =
		MAX(MIN(conn->lll.dle.local.max_rx_octets, conn->lll.dle.remote.max_tx_octets),
 1016a32:	f8b0 2060 	ldrh.w	r2, [r0, #96]	; 0x60
 1016a36:	f8b0 105a 	ldrh.w	r1, [r0, #90]	; 0x5a
{
 1016a3a:	4603      	mov	r3, r0
	const uint16_t eff_rx_octets =
 1016a3c:	428a      	cmp	r2, r1
 1016a3e:	bf28      	it	cs
 1016a40:	460a      	movcs	r2, r1
		    PDU_DC_PAYLOAD_SIZE_MIN);

#if defined(CONFIG_BT_CTLR_PHY)
	unsigned int min_eff_rx_time = (conn->lll.phy_rx == PHY_CODED) ?
 1016a42:	f890 0077 	ldrb.w	r0, [r0, #119]	; 0x77
			PDU_DC_PAYLOAD_TIME_MIN_CODED : PDU_DC_PAYLOAD_TIME_MIN;

	const uint16_t eff_rx_time =
		MAX(MIN(conn->lll.dle.local.max_rx_time, conn->lll.dle.remote.max_tx_time),
 1016a46:	f8b3 1064 	ldrh.w	r1, [r3, #100]	; 0x64
			PDU_DC_PAYLOAD_TIME_MIN_CODED : PDU_DC_PAYLOAD_TIME_MIN;
 1016a4a:	f000 0007 	and.w	r0, r0, #7
		MAX(MIN(conn->lll.dle.local.max_rx_time, conn->lll.dle.remote.max_tx_time),
 1016a4e:	f8b3 c05e 	ldrh.w	ip, [r3, #94]	; 0x5e
	const uint16_t eff_rx_octets =
 1016a52:	2a1b      	cmp	r2, #27
 1016a54:	bf38      	it	cc
 1016a56:	221b      	movcc	r2, #27
			PDU_DC_PAYLOAD_TIME_MIN_CODED : PDU_DC_PAYLOAD_TIME_MIN;
 1016a58:	2804      	cmp	r0, #4
 1016a5a:	bf14      	ite	ne
 1016a5c:	f44f 70a4 	movne.w	r0, #328	; 0x148
 1016a60:	f44f 6029 	moveq.w	r0, #2704	; 0xa90
		MAX(MIN(conn->lll.dle.local.max_rx_time, conn->lll.dle.remote.max_tx_time),
 1016a64:	4561      	cmp	r1, ip
 1016a66:	bf28      	it	cs
 1016a68:	4661      	movcs	r1, ip
	const uint16_t eff_rx_time =
 1016a6a:	4281      	cmp	r1, r0
 1016a6c:	bf38      	it	cc
 1016a6e:	4601      	movcc	r1, r0
		    min_eff_rx_time);

	if (eff_rx_time != conn->lll.dle.eff.max_rx_time) {
 1016a70:	f8b3 406e 	ldrh.w	r4, [r3, #110]	; 0x6e
	const uint16_t eff_tx_octets =
		MAX(MIN(conn->lll.dle.local.max_tx_octets, conn->lll.dle.remote.max_rx_octets),
		    PDU_DC_PAYLOAD_SIZE_MIN);

#if defined(CONFIG_BT_CTLR_PHY)
	unsigned int min_eff_tx_time = (conn->lll.phy_tx == PHY_CODED) ?
 1016a74:	f893 c076 	ldrb.w	ip, [r3, #118]	; 0x76
	if (eff_rx_time != conn->lll.dle.eff.max_rx_time) {
 1016a78:	428c      	cmp	r4, r1
		conn->lll.dle.eff.max_rx_time = eff_rx_time;
 1016a7a:	bf18      	it	ne
 1016a7c:	f8a3 106e 	strhne.w	r1, [r3, #110]	; 0x6e
	if (eff_rx_octets != conn->lll.dle.eff.max_rx_octets) {
 1016a80:	f8b3 106a 	ldrh.w	r1, [r3, #106]	; 0x6a
		dle_changed = 1;
 1016a84:	bf14      	ite	ne
 1016a86:	2001      	movne	r0, #1
	uint8_t dle_changed = 0U;
 1016a88:	2000      	moveq	r0, #0
	if (eff_rx_octets != conn->lll.dle.eff.max_rx_octets) {
 1016a8a:	4291      	cmp	r1, r2
		conn->lll.dle.eff.max_rx_octets = eff_rx_octets;
 1016a8c:	bf18      	it	ne
 1016a8e:	f8a3 206a 	strhne.w	r2, [r3, #106]	; 0x6a
		MAX(MIN(conn->lll.dle.local.max_tx_octets, conn->lll.dle.remote.max_rx_octets),
 1016a92:	f8b3 1058 	ldrh.w	r1, [r3, #88]	; 0x58
 1016a96:	f8b3 2062 	ldrh.w	r2, [r3, #98]	; 0x62
		dle_changed = 1;
 1016a9a:	bf18      	it	ne
 1016a9c:	2001      	movne	r0, #1
	const uint16_t eff_tx_octets =
 1016a9e:	428a      	cmp	r2, r1
 1016aa0:	bf28      	it	cs
 1016aa2:	460a      	movcs	r2, r1
			PDU_DC_PAYLOAD_TIME_MIN_CODED : PDU_DC_PAYLOAD_TIME_MIN;
 1016aa4:	f00c 0c07 	and.w	ip, ip, #7

	const uint16_t eff_tx_time =
		MAX(MIN(conn->lll.dle.local.max_tx_time, conn->lll.dle.remote.max_rx_time),
 1016aa8:	f8b3 1066 	ldrh.w	r1, [r3, #102]	; 0x66
 1016aac:	f8b3 405c 	ldrh.w	r4, [r3, #92]	; 0x5c
	const uint16_t eff_tx_octets =
 1016ab0:	2a1b      	cmp	r2, #27
 1016ab2:	bf38      	it	cc
 1016ab4:	221b      	movcc	r2, #27
			PDU_DC_PAYLOAD_TIME_MIN_CODED : PDU_DC_PAYLOAD_TIME_MIN;
 1016ab6:	f1bc 0f04 	cmp.w	ip, #4
 1016aba:	bf14      	ite	ne
 1016abc:	f44f 7ca4 	movne.w	ip, #328	; 0x148
 1016ac0:	f44f 6c29 	moveq.w	ip, #2704	; 0xa90
		MAX(MIN(conn->lll.dle.local.max_tx_time, conn->lll.dle.remote.max_rx_time),
 1016ac4:	42a1      	cmp	r1, r4
 1016ac6:	bf28      	it	cs
 1016ac8:	4621      	movcs	r1, r4
	const uint16_t eff_tx_time =
 1016aca:	4561      	cmp	r1, ip
 1016acc:	bf38      	it	cc
 1016ace:	4661      	movcc	r1, ip
		    min_eff_tx_time);

	if (eff_tx_time != conn->lll.dle.eff.max_tx_time) {
 1016ad0:	f8b3 e06c 	ldrh.w	lr, [r3, #108]	; 0x6c
 1016ad4:	458e      	cmp	lr, r1
		conn->lll.dle.eff.max_tx_time = eff_tx_time;
 1016ad6:	bf18      	it	ne
 1016ad8:	f8a3 106c 	strhne.w	r1, [r3, #108]	; 0x6c
	}
#else
	conn->lll.dle.eff.max_tx_time = PDU_DC_MAX_US(eff_tx_octets, PHY_1M);
#endif

	if (eff_tx_octets != conn->lll.dle.eff.max_tx_octets) {
 1016adc:	f8b3 1068 	ldrh.w	r1, [r3, #104]	; 0x68
		dle_changed = 1;
 1016ae0:	bf14      	ite	ne
 1016ae2:	f04f 0c01 	movne.w	ip, #1
	uint8_t dle_changed = 0U;
 1016ae6:	f04f 0c00 	moveq.w	ip, #0
	if (eff_tx_octets != conn->lll.dle.eff.max_tx_octets) {
 1016aea:	4291      	cmp	r1, r2
		conn->lll.dle.eff.max_tx_octets = eff_tx_octets;
		dle_changed = 1;
 1016aec:	bf1c      	itt	ne
 1016aee:	f04f 0c01 	movne.w	ip, #1
		conn->lll.dle.eff.max_tx_octets = eff_tx_octets;
 1016af2:	f8a3 2068 	strhne.w	r2, [r3, #104]	; 0x68
}
 1016af6:	ea4c 0000 	orr.w	r0, ip, r0
 1016afa:	bd10      	pop	{r4, pc}

01016afc <ull_dle_update_eff_rx>:
{
 1016afc:	b500      	push	{lr}
		MAX(MIN(conn->lll.dle.local.max_rx_octets, conn->lll.dle.remote.max_tx_octets),
 1016afe:	f8b0 2060 	ldrh.w	r2, [r0, #96]	; 0x60
 1016b02:	f8b0 105a 	ldrh.w	r1, [r0, #90]	; 0x5a
{
 1016b06:	4603      	mov	r3, r0
	const uint16_t eff_rx_octets =
 1016b08:	428a      	cmp	r2, r1
 1016b0a:	bf28      	it	cs
 1016b0c:	460a      	movcs	r2, r1
	unsigned int min_eff_rx_time = (conn->lll.phy_rx == PHY_CODED) ?
 1016b0e:	f890 0077 	ldrb.w	r0, [r0, #119]	; 0x77
		MAX(MIN(conn->lll.dle.local.max_rx_time, conn->lll.dle.remote.max_tx_time),
 1016b12:	f8b3 1064 	ldrh.w	r1, [r3, #100]	; 0x64
			PDU_DC_PAYLOAD_TIME_MIN_CODED : PDU_DC_PAYLOAD_TIME_MIN;
 1016b16:	f000 0007 	and.w	r0, r0, #7
		MAX(MIN(conn->lll.dle.local.max_rx_time, conn->lll.dle.remote.max_tx_time),
 1016b1a:	f8b3 e05e 	ldrh.w	lr, [r3, #94]	; 0x5e
	const uint16_t eff_rx_octets =
 1016b1e:	2a1b      	cmp	r2, #27
 1016b20:	bf38      	it	cc
 1016b22:	221b      	movcc	r2, #27
			PDU_DC_PAYLOAD_TIME_MIN_CODED : PDU_DC_PAYLOAD_TIME_MIN;
 1016b24:	2804      	cmp	r0, #4
 1016b26:	bf14      	ite	ne
 1016b28:	f44f 70a4 	movne.w	r0, #328	; 0x148
 1016b2c:	f44f 6029 	moveq.w	r0, #2704	; 0xa90
		MAX(MIN(conn->lll.dle.local.max_rx_time, conn->lll.dle.remote.max_tx_time),
 1016b30:	4571      	cmp	r1, lr
 1016b32:	bf28      	it	cs
 1016b34:	4671      	movcs	r1, lr
	const uint16_t eff_rx_time =
 1016b36:	4281      	cmp	r1, r0
 1016b38:	bf38      	it	cc
 1016b3a:	4601      	movcc	r1, r0
	if (eff_rx_time != conn->lll.dle.eff.max_rx_time) {
 1016b3c:	f8b3 c06e 	ldrh.w	ip, [r3, #110]	; 0x6e
 1016b40:	458c      	cmp	ip, r1
		conn->lll.dle.eff.max_rx_time = eff_rx_time;
 1016b42:	bf18      	it	ne
 1016b44:	f8a3 106e 	strhne.w	r1, [r3, #110]	; 0x6e
	if (eff_rx_octets != conn->lll.dle.eff.max_rx_octets) {
 1016b48:	f8b3 106a 	ldrh.w	r1, [r3, #106]	; 0x6a
		dle_changed = 1;
 1016b4c:	bf14      	ite	ne
 1016b4e:	2001      	movne	r0, #1
	uint8_t dle_changed = 0U;
 1016b50:	2000      	moveq	r0, #0
	if (eff_rx_octets != conn->lll.dle.eff.max_rx_octets) {
 1016b52:	4291      	cmp	r1, r2
		conn->lll.dle.eff.max_rx_octets = eff_rx_octets;
 1016b54:	bf1c      	itt	ne
 1016b56:	f8a3 206a 	strhne.w	r2, [r3, #106]	; 0x6a
		dle_changed = 1;
 1016b5a:	2001      	movne	r0, #1
}
 1016b5c:	f85d fb04 	ldr.w	pc, [sp], #4

01016b60 <ull_dle_update_eff_tx>:
{
 1016b60:	b500      	push	{lr}
		MAX(MIN(conn->lll.dle.local.max_tx_octets, conn->lll.dle.remote.max_rx_octets),
 1016b62:	f8b0 2062 	ldrh.w	r2, [r0, #98]	; 0x62
 1016b66:	f8b0 1058 	ldrh.w	r1, [r0, #88]	; 0x58
{
 1016b6a:	4603      	mov	r3, r0
	const uint16_t eff_tx_octets =
 1016b6c:	428a      	cmp	r2, r1
 1016b6e:	bf28      	it	cs
 1016b70:	460a      	movcs	r2, r1
	unsigned int min_eff_tx_time = (conn->lll.phy_tx == PHY_CODED) ?
 1016b72:	f890 0076 	ldrb.w	r0, [r0, #118]	; 0x76
		MAX(MIN(conn->lll.dle.local.max_tx_time, conn->lll.dle.remote.max_rx_time),
 1016b76:	f8b3 1066 	ldrh.w	r1, [r3, #102]	; 0x66
			PDU_DC_PAYLOAD_TIME_MIN_CODED : PDU_DC_PAYLOAD_TIME_MIN;
 1016b7a:	f000 0007 	and.w	r0, r0, #7
		MAX(MIN(conn->lll.dle.local.max_tx_time, conn->lll.dle.remote.max_rx_time),
 1016b7e:	f8b3 e05c 	ldrh.w	lr, [r3, #92]	; 0x5c
	const uint16_t eff_tx_octets =
 1016b82:	2a1b      	cmp	r2, #27
 1016b84:	bf38      	it	cc
 1016b86:	221b      	movcc	r2, #27
			PDU_DC_PAYLOAD_TIME_MIN_CODED : PDU_DC_PAYLOAD_TIME_MIN;
 1016b88:	2804      	cmp	r0, #4
 1016b8a:	bf14      	ite	ne
 1016b8c:	f44f 70a4 	movne.w	r0, #328	; 0x148
 1016b90:	f44f 6029 	moveq.w	r0, #2704	; 0xa90
		MAX(MIN(conn->lll.dle.local.max_tx_time, conn->lll.dle.remote.max_rx_time),
 1016b94:	4571      	cmp	r1, lr
 1016b96:	bf28      	it	cs
 1016b98:	4671      	movcs	r1, lr
	const uint16_t eff_tx_time =
 1016b9a:	4281      	cmp	r1, r0
 1016b9c:	bf38      	it	cc
 1016b9e:	4601      	movcc	r1, r0
	if (eff_tx_time != conn->lll.dle.eff.max_tx_time) {
 1016ba0:	f8b3 c06c 	ldrh.w	ip, [r3, #108]	; 0x6c
 1016ba4:	458c      	cmp	ip, r1
		conn->lll.dle.eff.max_tx_time = eff_tx_time;
 1016ba6:	bf18      	it	ne
 1016ba8:	f8a3 106c 	strhne.w	r1, [r3, #108]	; 0x6c
	if (eff_tx_octets != conn->lll.dle.eff.max_tx_octets) {
 1016bac:	f8b3 1068 	ldrh.w	r1, [r3, #104]	; 0x68
		dle_changed = 1;
 1016bb0:	bf14      	ite	ne
 1016bb2:	2001      	movne	r0, #1
	uint8_t dle_changed = 0U;
 1016bb4:	2000      	moveq	r0, #0
	if (eff_tx_octets != conn->lll.dle.eff.max_tx_octets) {
 1016bb6:	4291      	cmp	r1, r2
		conn->lll.dle.eff.max_tx_octets = eff_tx_octets;
 1016bb8:	bf1c      	itt	ne
 1016bba:	f8a3 2068 	strhne.w	r2, [r3, #104]	; 0x68
		dle_changed = 1;
 1016bbe:	2001      	movne	r0, #1
	}

	return dle_changed;
}
 1016bc0:	f85d fb04 	ldr.w	pc, [sp], #4

01016bc4 <ull_dle_local_tx_update>:
	/* trim to supported values */
	if (*tx_octets > LL_LENGTH_OCTETS_TX_MAX) {
		*tx_octets = LL_LENGTH_OCTETS_TX_MAX;
	}

	if (*tx_time > tx_time_max) {
 1016bc4:	f640 0348 	movw	r3, #2120	; 0x848
 1016bc8:	429a      	cmp	r2, r3
 1016bca:	bf28      	it	cs
 1016bcc:	461a      	movcs	r2, r3
	if (*tx_octets > LL_LENGTH_OCTETS_TX_MAX) {
 1016bce:	29fb      	cmp	r1, #251	; 0xfb
 1016bd0:	bf28      	it	cs
 1016bd2:	21fb      	movcs	r1, #251	; 0xfb
	tx_time = MAX(PDU_DC_PAYLOAD_TIME_MIN, tx_time);
 1016bd4:	f5b2 7fa4 	cmp.w	r2, #328	; 0x148
 1016bd8:	4694      	mov	ip, r2
 1016bda:	bf38      	it	cc
 1016bdc:	f44f 7ca4 	movcc.w	ip, #328	; 0x148
	ull_len_data_length_trim(&tx_octets, &tx_time);

	conn->lll.dle.default_tx_octets = tx_octets;

#if defined(CONFIG_BT_CTLR_PHY)
	conn->lll.dle.default_tx_time = tx_time;
 1016be0:	f8a0 2070 	strh.w	r2, [r0, #112]	; 0x70
	conn->lll.dle.default_tx_octets = tx_octets;
 1016be4:	f8a0 1072 	strh.w	r1, [r0, #114]	; 0x72
	*max_rx_time = rx_time;
 1016be8:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e
#endif /* CONFIG_BT_CTLR_PHY */

	dle_max_time_get(conn, &conn->lll.dle.local.max_rx_time, &conn->lll.dle.local.max_tx_time);
	conn->lll.dle.local.max_tx_octets = conn->lll.dle.default_tx_octets;
 1016bec:	f8a0 1058 	strh.w	r1, [r0, #88]	; 0x58
	*max_tx_time = tx_time;
 1016bf0:	f8a0 c05c 	strh.w	ip, [r0, #92]	; 0x5c
}
 1016bf4:	4770      	bx	lr
 1016bf6:	bf00      	nop

01016bf8 <ull_dle_init>:

void ull_dle_init(struct ll_conn *conn, uint8_t phy)
{
 1016bf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1016bfa:	460f      	mov	r7, r1
 1016bfc:	4604      	mov	r4, r0
#if defined(CONFIG_BT_CTLR_PHY)
	const uint16_t max_time_min = PDU_DC_MAX_US(PDU_DC_PAYLOAD_SIZE_MIN, phy);
 1016bfe:	f007 0603 	and.w	r6, r7, #3
	const uint16_t max_time_max = PDU_DC_MAX_US(LL_LENGTH_OCTETS_RX_MAX, phy);
#endif

	/* Clear DLE data set */
	memset(&conn->lll.dle, 0, sizeof(conn->lll.dle));
 1016c02:	221e      	movs	r2, #30
 1016c04:	2100      	movs	r1, #0
 1016c06:	3058      	adds	r0, #88	; 0x58
 1016c08:	f00f febf 	bl	102698a <memset>
	const uint16_t max_time_max = PDU_DC_MAX_US(LL_LENGTH_OCTETS_RX_MAX, phy);
 1016c0c:	f506 7184 	add.w	r1, r6, #264	; 0x108
	const uint16_t max_time_min = PDU_DC_MAX_US(PDU_DC_PAYLOAD_SIZE_MIN, phy);
 1016c10:	f3c7 0740 	ubfx	r7, r7, #1, #1
	const uint16_t max_time_max = PDU_DC_MAX_US(LL_LENGTH_OCTETS_RX_MAX, phy);
 1016c14:	00c9      	lsls	r1, r1, #3
 1016c16:	40f9      	lsrs	r1, r7
 1016c18:	f8a4 105e 	strh.w	r1, [r4, #94]	; 0x5e
	if (*tx_time > tx_time_max) {
 1016c1c:	f640 0148 	movw	r1, #2120	; 0x848
	/* See BT. 5.2 Spec - Vol 6, Part B, Sect 4.5.10
	 * Default to locally max supported rx/tx length/time
	 */
	ull_dle_local_tx_update(conn, default_tx_octets, default_tx_time);
 1016c20:	4b31      	ldr	r3, [pc, #196]	; (1016ce8 <ull_dle_init+0xf0>)
 1016c22:	4a32      	ldr	r2, [pc, #200]	; (1016cec <ull_dle_init+0xf4>)
	if (*tx_octets > LL_LENGTH_OCTETS_TX_MAX) {
 1016c24:	881b      	ldrh	r3, [r3, #0]
	if (*tx_time > tx_time_max) {
 1016c26:	8812      	ldrh	r2, [r2, #0]
	if (*tx_octets > LL_LENGTH_OCTETS_TX_MAX) {
 1016c28:	2bfb      	cmp	r3, #251	; 0xfb
 1016c2a:	bf28      	it	cs
 1016c2c:	23fb      	movcs	r3, #251	; 0xfb
	if (*tx_time > tx_time_max) {
 1016c2e:	428a      	cmp	r2, r1
 1016c30:	bf28      	it	cs
 1016c32:	460a      	movcs	r2, r1
	unsigned int min_eff_rx_time = (conn->lll.phy_rx == PHY_CODED) ?
 1016c34:	f894 0077 	ldrb.w	r0, [r4, #119]	; 0x77
	tx_time = MAX(PDU_DC_PAYLOAD_TIME_MIN, tx_time);
 1016c38:	f5b2 7fa4 	cmp.w	r2, #328	; 0x148
			PDU_DC_PAYLOAD_TIME_MIN_CODED : PDU_DC_PAYLOAD_TIME_MIN;
 1016c3c:	f000 0007 	and.w	r0, r0, #7
	conn->lll.dle.default_tx_time = tx_time;
 1016c40:	f8a4 2070 	strh.w	r2, [r4, #112]	; 0x70
	tx_time = MAX(PDU_DC_PAYLOAD_TIME_MIN, tx_time);
 1016c44:	bf38      	it	cc
 1016c46:	f44f 72a4 	movcc.w	r2, #328	; 0x148
			PDU_DC_PAYLOAD_TIME_MIN_CODED : PDU_DC_PAYLOAD_TIME_MIN;
 1016c4a:	2804      	cmp	r0, #4
 1016c4c:	bf14      	ite	ne
 1016c4e:	f44f 70a4 	movne.w	r0, #328	; 0x148
 1016c52:	f44f 6029 	moveq.w	r0, #2704	; 0xa90
	const uint16_t max_time_min = PDU_DC_MAX_US(PDU_DC_PAYLOAD_SIZE_MIN, phy);
 1016c56:	f106 0528 	add.w	r5, r6, #40	; 0x28
 1016c5a:	00ed      	lsls	r5, r5, #3
 1016c5c:	40fd      	lsrs	r5, r7
		MAX(MIN(conn->lll.dle.local.max_rx_time, conn->lll.dle.remote.max_tx_time),
 1016c5e:	4285      	cmp	r5, r0
	conn->lll.dle.default_tx_octets = tx_octets;
 1016c60:	f8a4 3072 	strh.w	r3, [r4, #114]	; 0x72
	conn->lll.dle.local.max_tx_octets = conn->lll.dle.default_tx_octets;
 1016c64:	f8a4 3058 	strh.w	r3, [r4, #88]	; 0x58
	const uint16_t max_time_min = PDU_DC_MAX_US(PDU_DC_PAYLOAD_SIZE_MIN, phy);
 1016c68:	b2ab      	uxth	r3, r5
		MAX(MIN(conn->lll.dle.local.max_rx_time, conn->lll.dle.remote.max_tx_time),
 1016c6a:	bf38      	it	cc
 1016c6c:	4605      	movcc	r5, r0
	if (eff_rx_time != conn->lll.dle.eff.max_rx_time) {
 1016c6e:	f8b4 106e 	ldrh.w	r1, [r4, #110]	; 0x6e
	const uint16_t eff_rx_time =
 1016c72:	b2ad      	uxth	r5, r5
	if (eff_rx_time != conn->lll.dle.eff.max_rx_time) {
 1016c74:	42a9      	cmp	r1, r5
	if (eff_rx_octets != conn->lll.dle.eff.max_rx_octets) {
 1016c76:	f8b4 106a 	ldrh.w	r1, [r4, #106]	; 0x6a
		conn->lll.dle.eff.max_rx_time = eff_rx_time;
 1016c7a:	bf18      	it	ne
 1016c7c:	f8a4 506e 	strhne.w	r5, [r4, #110]	; 0x6e
	if (eff_rx_octets != conn->lll.dle.eff.max_rx_octets) {
 1016c80:	291b      	cmp	r1, #27
		conn->lll.dle.eff.max_rx_octets = eff_rx_octets;
 1016c82:	bf1c      	itt	ne
 1016c84:	211b      	movne	r1, #27
 1016c86:	f8a4 106a 	strhne.w	r1, [r4, #106]	; 0x6a
	unsigned int min_eff_tx_time = (conn->lll.phy_tx == PHY_CODED) ?
 1016c8a:	f894 1076 	ldrb.w	r1, [r4, #118]	; 0x76
	/* Default to minimum rx/tx data length/time */
	conn->lll.dle.remote.max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
	conn->lll.dle.remote.max_rx_octets = PDU_DC_PAYLOAD_SIZE_MIN;

#if defined(CONFIG_BT_CTLR_PHY)
	conn->lll.dle.remote.max_tx_time = max_time_min;
 1016c8e:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
			PDU_DC_PAYLOAD_TIME_MIN_CODED : PDU_DC_PAYLOAD_TIME_MIN;
 1016c92:	f001 0107 	and.w	r1, r1, #7
 1016c96:	2904      	cmp	r1, #4
 1016c98:	bf14      	ite	ne
 1016c9a:	f44f 71a4 	movne.w	r1, #328	; 0x148
 1016c9e:	f44f 6129 	moveq.w	r1, #2704	; 0xa90
		MAX(MIN(conn->lll.dle.local.max_tx_time, conn->lll.dle.remote.max_rx_time),
 1016ca2:	4293      	cmp	r3, r2
	conn->lll.dle.remote.max_rx_time = max_time_min;
 1016ca4:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
		MAX(MIN(conn->lll.dle.local.max_tx_time, conn->lll.dle.remote.max_rx_time),
 1016ca8:	bf28      	it	cs
 1016caa:	4613      	movcs	r3, r2
	const uint16_t eff_tx_time =
 1016cac:	428b      	cmp	r3, r1
 1016cae:	bf38      	it	cc
 1016cb0:	460b      	movcc	r3, r1
	if (eff_tx_time != conn->lll.dle.eff.max_tx_time) {
 1016cb2:	f8b4 006c 	ldrh.w	r0, [r4, #108]	; 0x6c
	conn->lll.dle.remote.max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 1016cb6:	f04f 161b 	mov.w	r6, #1769499	; 0x1b001b
	if (eff_tx_time != conn->lll.dle.eff.max_tx_time) {
 1016cba:	4298      	cmp	r0, r3
		conn->lll.dle.eff.max_tx_time = eff_tx_time;
 1016cbc:	bf18      	it	ne
 1016cbe:	f8a4 306c 	strhne.w	r3, [r4, #108]	; 0x6c
	if (eff_tx_octets != conn->lll.dle.eff.max_tx_octets) {
 1016cc2:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
	conn->lll.dle.remote.max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 1016cc6:	6626      	str	r6, [r4, #96]	; 0x60
	if (eff_tx_octets != conn->lll.dle.eff.max_tx_octets) {
 1016cc8:	2b1b      	cmp	r3, #27
		conn->lll.dle.eff.max_tx_octets = eff_tx_octets;
 1016cca:	bf18      	it	ne
 1016ccc:	231b      	movne	r3, #27
	conn->lll.dle.local.max_rx_octets = LL_LENGTH_OCTETS_RX_MAX;
 1016cce:	f04f 06fb 	mov.w	r6, #251	; 0xfb
		conn->lll.dle.eff.max_tx_octets = eff_tx_octets;
 1016cd2:	bf18      	it	ne
 1016cd4:	f8a4 3068 	strhne.w	r3, [r4, #104]	; 0x68
	 * connection is established
	 */
#if defined(CONFIG_BT_CTLR_PHY)
	if ((conn->lll.dle.local.max_rx_time != max_time_min ||
	     conn->lll.dle.local.max_tx_time != max_time_min)) {
		conn->lll.dle.update = 1;
 1016cd8:	2301      	movs	r3, #1
	conn->lll.dle.local.max_rx_octets = LL_LENGTH_OCTETS_RX_MAX;
 1016cda:	f8a4 605a 	strh.w	r6, [r4, #90]	; 0x5a
	*max_tx_time = tx_time;
 1016cde:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
		conn->lll.dle.update = 1;
 1016ce2:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
		if (conn->lll.dle.local.max_tx_octets != PDU_DC_PAYLOAD_SIZE_MIN ||
		    conn->lll.dle.local.max_rx_octets != PDU_DC_PAYLOAD_SIZE_MIN) {
			conn->lll.dle.update = 1;
		}
	}
}
 1016ce6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1016ce8:	210081d6 	.word	0x210081d6
 1016cec:	210081d4 	.word	0x210081d4

01016cf0 <pu_check_update_ind>:
	 */
	return (phy < 5 && phy != 3);
}

static uint8_t pu_check_update_ind(struct ll_conn *conn, struct proc_ctx *ctx)
{
 1016cf0:	b570      	push	{r4, r5, r6, lr}
	uint8_t ret = 0;

	/* Check if either phy selected is invalid */
	if (!phy_valid(ctx->data.pu.c_to_p_phy) || !phy_valid(ctx->data.pu.p_to_c_phy)) {
 1016cf2:	f891 3022 	ldrb.w	r3, [r1, #34]	; 0x22
{
 1016cf6:	460c      	mov	r4, r1
	return (phy < 5 && phy != 3);
 1016cf8:	2b04      	cmp	r3, #4
	if (!phy_valid(ctx->data.pu.c_to_p_phy) || !phy_valid(ctx->data.pu.p_to_c_phy)) {
 1016cfa:	f891 2023 	ldrb.w	r2, [r1, #35]	; 0x23
	return (phy < 5 && phy != 3);
 1016cfe:	d803      	bhi.n	1016d08 <pu_check_update_ind+0x18>
 1016d00:	2b03      	cmp	r3, #3
 1016d02:	d001      	beq.n	1016d08 <pu_check_update_ind+0x18>
 1016d04:	2a04      	cmp	r2, #4
 1016d06:	d90b      	bls.n	1016d20 <pu_check_update_ind+0x30>
		/* more than one or any rfu bit selected in either phy */
		ctx->data.pu.error = BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL;
 1016d08:	2111      	movs	r1, #17
		ret = 1;
	}

	/* Both tx and rx PHY unchanged */
	if (!((ctx->data.pu.c_to_p_phy | ctx->data.pu.p_to_c_phy) & 0x07)) {
 1016d0a:	4313      	orrs	r3, r2
 1016d0c:	f013 0307 	ands.w	r3, r3, #7
		ret = 1;
 1016d10:	f04f 0501 	mov.w	r5, #1
		ctx->data.pu.error = BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL;
 1016d14:	77a1      	strb	r1, [r4, #30]
	if (!((ctx->data.pu.c_to_p_phy | ctx->data.pu.p_to_c_phy) & 0x07)) {
 1016d16:	d10b      	bne.n	1016d30 <pu_check_update_ind+0x40>
		/* if no phy changes, quit procedure, and possibly signal host */
		ctx->data.pu.error = BT_HCI_ERR_SUCCESS;
		ret = 1;
 1016d18:	2501      	movs	r5, #1
	} else {
		/* if instant already passed, quit procedure with error */
		if (is_instant_reached_or_passed(ctx->data.pu.instant,
						 ull_conn_event_counter(conn))) {
			ctx->data.pu.error = BT_HCI_ERR_INSTANT_PASSED;
 1016d1a:	77a3      	strb	r3, [r4, #30]
			ret = 1;
		}
	}
	return ret;
}
 1016d1c:	4628      	mov	r0, r5
 1016d1e:	bd70      	pop	{r4, r5, r6, pc}
	return (phy < 5 && phy != 3);
 1016d20:	2a03      	cmp	r2, #3
 1016d22:	d00d      	beq.n	1016d40 <pu_check_update_ind+0x50>
	if (!((ctx->data.pu.c_to_p_phy | ctx->data.pu.p_to_c_phy) & 0x07)) {
 1016d24:	4313      	orrs	r3, r2
 1016d26:	f013 0307 	ands.w	r3, r3, #7
	uint8_t ret = 0;
 1016d2a:	f04f 0500 	mov.w	r5, #0
	if (!((ctx->data.pu.c_to_p_phy | ctx->data.pu.p_to_c_phy) & 0x07)) {
 1016d2e:	d0f3      	beq.n	1016d18 <pu_check_update_ind+0x28>
		if (is_instant_reached_or_passed(ctx->data.pu.instant,
 1016d30:	8c26      	ldrh	r6, [r4, #32]
 1016d32:	f7ff fe51 	bl	10169d8 <ull_conn_event_counter>
 1016d36:	1b80      	subs	r0, r0, r6
 1016d38:	0403      	lsls	r3, r0, #16
 1016d3a:	d4ef      	bmi.n	1016d1c <pu_check_update_ind+0x2c>
 1016d3c:	2328      	movs	r3, #40	; 0x28
 1016d3e:	e7eb      	b.n	1016d18 <pu_check_update_ind+0x28>
		ctx->data.pu.error = BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL;
 1016d40:	2311      	movs	r3, #17
		ret = 1;
 1016d42:	2501      	movs	r5, #1
		ctx->data.pu.error = BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL;
 1016d44:	778b      	strb	r3, [r1, #30]
	if (!((ctx->data.pu.c_to_p_phy | ctx->data.pu.p_to_c_phy) & 0x07)) {
 1016d46:	e7f3      	b.n	1016d30 <pu_check_update_ind+0x40>

01016d48 <pu_ntf>:
	/* Restart procedure response timeout timer */
	llcp_lr_prt_restart(conn);
}

static void pu_ntf(struct ll_conn *conn, struct proc_ctx *ctx)
{
 1016d48:	b570      	push	{r4, r5, r6, lr}
 1016d4a:	4606      	mov	r6, r0
 1016d4c:	460d      	mov	r5, r1
	struct node_rx_pdu *ntf;
	struct node_rx_pu *pdu;

	/* Allocate ntf node */
	ntf = llcp_ntf_alloc();
 1016d4e:	f001 f8c7 	bl	1017ee0 <llcp_ntf_alloc>
	LL_ASSERT(ntf);
 1016d52:	4604      	mov	r4, r0
 1016d54:	b1c0      	cbz	r0, 1016d88 <pu_ntf+0x40>

	ntf->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 1016d56:	231d      	movs	r3, #29
 1016d58:	7123      	strb	r3, [r4, #4]
	ntf->hdr.handle = conn->lll.handle;
 1016d5a:	8d33      	ldrh	r3, [r6, #40]	; 0x28
	pdu->status = ctx->data.pu.error;
	pdu->rx = conn->lll.phy_rx;
	pdu->tx = conn->lll.phy_tx;

	/* Enqueue notification towards LL */
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1016d5c:	4621      	mov	r1, r4
	ntf->hdr.handle = conn->lll.handle;
 1016d5e:	80e3      	strh	r3, [r4, #6]
	pdu->status = ctx->data.pu.error;
 1016d60:	7fab      	ldrb	r3, [r5, #30]
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1016d62:	6820      	ldr	r0, [r4, #0]
	pdu->status = ctx->data.pu.error;
 1016d64:	7723      	strb	r3, [r4, #28]
	pdu->rx = conn->lll.phy_rx;
 1016d66:	f896 3077 	ldrb.w	r3, [r6, #119]	; 0x77
 1016d6a:	f3c3 0302 	ubfx	r3, r3, #0, #3
 1016d6e:	77a3      	strb	r3, [r4, #30]
	pdu->tx = conn->lll.phy_tx;
 1016d70:	f896 3076 	ldrb.w	r3, [r6, #118]	; 0x76
 1016d74:	f3c3 0302 	ubfx	r3, r3, #0, #3
 1016d78:	7763      	strb	r3, [r4, #29]
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1016d7a:	f7fd faaf 	bl	10142dc <ll_rx_put_sched>
	ctx->data.pu.ntf_pu = 0;
 1016d7e:	7f6b      	ldrb	r3, [r5, #29]
 1016d80:	f36f 0300 	bfc	r3, #0, #1
 1016d84:	776b      	strb	r3, [r5, #29]
}
 1016d86:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(ntf);
 1016d88:	f240 139f 	movw	r3, #415	; 0x19f
 1016d8c:	4a05      	ldr	r2, [pc, #20]	; (1016da4 <pu_ntf+0x5c>)
 1016d8e:	4906      	ldr	r1, [pc, #24]	; (1016da8 <pu_ntf+0x60>)
 1016d90:	4806      	ldr	r0, [pc, #24]	; (1016dac <pu_ntf+0x64>)
 1016d92:	f00d ff20 	bl	1024bd6 <assert_print>
 1016d96:	4040      	eors	r0, r0
 1016d98:	f380 8811 	msr	BASEPRI, r0
 1016d9c:	f04f 0003 	mov.w	r0, #3
 1016da0:	df02      	svc	2
 1016da2:	e7d8      	b.n	1016d56 <pu_ntf+0xe>
 1016da4:	0102aa8c 	.word	0x0102aa8c
 1016da8:	0102aad0 	.word	0x0102aad0
 1016dac:	0102a278 	.word	0x0102a278

01016db0 <pu_update_eff_times>:
{
 1016db0:	b5f0      	push	{r4, r5, r6, r7, lr}
 1016db2:	460e      	mov	r6, r1
 1016db4:	b083      	sub	sp, #12
	ull_dle_max_time_get(conn, &max_rx_time, &max_tx_time);
 1016db6:	f10d 0206 	add.w	r2, sp, #6
 1016dba:	a901      	add	r1, sp, #4
{
 1016dbc:	4604      	mov	r4, r0
	uint16_t eff_tx_time = lll->dle.eff.max_tx_time;
 1016dbe:	f8b0 506c 	ldrh.w	r5, [r0, #108]	; 0x6c
	uint16_t eff_rx_time = lll->dle.eff.max_rx_time;
 1016dc2:	f8b0 706e 	ldrh.w	r7, [r0, #110]	; 0x6e
	ull_dle_max_time_get(conn, &max_rx_time, &max_tx_time);
 1016dc6:	f7ff fe23 	bl	1016a10 <ull_dle_max_time_get>
	if ((ctx->data.pu.p_to_c_phy && (lll->role == BT_HCI_ROLE_PERIPHERAL)) ||
 1016dca:	f896 2023 	ldrb.w	r2, [r6, #35]	; 0x23
 1016dce:	2a00      	cmp	r2, #0
 1016dd0:	d156      	bne.n	1016e80 <pu_update_eff_times+0xd0>
 1016dd2:	f896 3022 	ldrb.w	r3, [r6, #34]	; 0x22
 1016dd6:	b9cb      	cbnz	r3, 1016e0c <pu_update_eff_times+0x5c>
	if ((eff_tx_time > lll->dle.eff.max_tx_time) ||
 1016dd8:	f8b4 306c 	ldrh.w	r3, [r4, #108]	; 0x6c
 1016ddc:	42ab      	cmp	r3, r5
 1016dde:	d30e      	bcc.n	1016dfe <pu_update_eff_times+0x4e>
 1016de0:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 1016de4:	429a      	cmp	r2, r3
 1016de6:	d30a      	bcc.n	1016dfe <pu_update_eff_times+0x4e>
	    (eff_rx_time > lll->dle.eff.max_rx_time) ||
 1016de8:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
	    (lll->dle.eff.max_tx_time > max_tx_time) ||
 1016dec:	42bb      	cmp	r3, r7
 1016dee:	d306      	bcc.n	1016dfe <pu_update_eff_times+0x4e>
	    (eff_rx_time > lll->dle.eff.max_rx_time) ||
 1016df0:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 1016df4:	429a      	cmp	r2, r3
 1016df6:	d302      	bcc.n	1016dfe <pu_update_eff_times+0x4e>
	return 0U;
 1016df8:	2000      	movs	r0, #0
}
 1016dfa:	b003      	add	sp, #12
 1016dfc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return 1U;
 1016dfe:	2001      	movs	r0, #1
		lll->dle.eff.max_tx_time = eff_tx_time;
 1016e00:	f8a4 506c 	strh.w	r5, [r4, #108]	; 0x6c
		lll->dle.eff.max_rx_time = eff_rx_time;
 1016e04:	f8a4 706e 	strh.w	r7, [r4, #110]	; 0x6e
}
 1016e08:	b003      	add	sp, #12
 1016e0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	    (ctx->data.pu.c_to_p_phy && (lll->role == BT_HCI_ROLE_CENTRAL))) {
 1016e0c:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
 1016e10:	2800      	cmp	r0, #0
 1016e12:	db1d      	blt.n	1016e50 <pu_update_eff_times+0xa0>
			pu_calc_eff_time(lll->dle.eff.max_tx_octets, lll->phy_tx, max_tx_time);
 1016e14:	f894 1076 	ldrb.w	r1, [r4, #118]	; 0x76
	uint16_t payload_time = PDU_DC_MAX_US(max_octets, phy);
 1016e18:	f894 5068 	ldrb.w	r5, [r4, #104]	; 0x68
 1016e1c:	f001 0303 	and.w	r3, r1, #3
 1016e20:	442b      	add	r3, r5
 1016e22:	330d      	adds	r3, #13
 1016e24:	00db      	lsls	r3, r3, #3
 1016e26:	f3c1 0140 	ubfx	r1, r1, #1, #1
 1016e2a:	40cb      	lsrs	r3, r1
	eff_time = MAX(PDU_DC_PAYLOAD_TIME_MIN, payload_time);
 1016e2c:	b29b      	uxth	r3, r3
 1016e2e:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 1016e32:	bf38      	it	cc
 1016e34:	f44f 73a4 	movcc.w	r3, #328	; 0x148
	eff_time = MIN(eff_time, default_time);
 1016e38:	f8bd 5006 	ldrh.w	r5, [sp, #6]
 1016e3c:	429d      	cmp	r5, r3
 1016e3e:	bf28      	it	cs
 1016e40:	461d      	movcs	r5, r3
	if ((ctx->data.pu.p_to_c_phy && (lll->role == BT_HCI_ROLE_CENTRAL)) ||
 1016e42:	b332      	cbz	r2, 1016e92 <pu_update_eff_times+0xe2>
 1016e44:	2800      	cmp	r0, #0
 1016e46:	da03      	bge.n	1016e50 <pu_update_eff_times+0xa0>
 1016e48:	f896 3022 	ldrb.w	r3, [r6, #34]	; 0x22
 1016e4c:	2b00      	cmp	r3, #0
 1016e4e:	d0c3      	beq.n	1016dd8 <pu_update_eff_times+0x28>
			pu_calc_eff_time(lll->dle.eff.max_rx_octets, lll->phy_rx, max_rx_time);
 1016e50:	f894 2077 	ldrb.w	r2, [r4, #119]	; 0x77
	uint16_t payload_time = PDU_DC_MAX_US(max_octets, phy);
 1016e54:	f894 106a 	ldrb.w	r1, [r4, #106]	; 0x6a
 1016e58:	f002 0303 	and.w	r3, r2, #3
 1016e5c:	440b      	add	r3, r1
 1016e5e:	330d      	adds	r3, #13
 1016e60:	00db      	lsls	r3, r3, #3
 1016e62:	f3c2 0240 	ubfx	r2, r2, #1, #1
 1016e66:	40d3      	lsrs	r3, r2
	eff_time = MAX(PDU_DC_PAYLOAD_TIME_MIN, payload_time);
 1016e68:	b29b      	uxth	r3, r3
 1016e6a:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 1016e6e:	bf38      	it	cc
 1016e70:	f44f 73a4 	movcc.w	r3, #328	; 0x148
	eff_time = MIN(eff_time, default_time);
 1016e74:	f8bd 7004 	ldrh.w	r7, [sp, #4]
 1016e78:	429f      	cmp	r7, r3
 1016e7a:	bf28      	it	cs
 1016e7c:	461f      	movcs	r7, r3
	return eff_time;
 1016e7e:	e7ab      	b.n	1016dd8 <pu_update_eff_times+0x28>
	if ((ctx->data.pu.p_to_c_phy && (lll->role == BT_HCI_ROLE_PERIPHERAL)) ||
 1016e80:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
 1016e84:	2800      	cmp	r0, #0
 1016e86:	dbc5      	blt.n	1016e14 <pu_update_eff_times+0x64>
 1016e88:	f896 3022 	ldrb.w	r3, [r6, #34]	; 0x22
 1016e8c:	2b00      	cmp	r3, #0
 1016e8e:	d0df      	beq.n	1016e50 <pu_update_eff_times+0xa0>
 1016e90:	e7c0      	b.n	1016e14 <pu_update_eff_times+0x64>
	if ((ctx->data.pu.p_to_c_phy && (lll->role == BT_HCI_ROLE_CENTRAL)) ||
 1016e92:	f896 3022 	ldrb.w	r3, [r6, #34]	; 0x22
 1016e96:	2b00      	cmp	r3, #0
 1016e98:	d09e      	beq.n	1016dd8 <pu_update_eff_times+0x28>
	    (ctx->data.pu.c_to_p_phy && (lll->role == BT_HCI_ROLE_PERIPHERAL))) {
 1016e9a:	2800      	cmp	r0, #0
 1016e9c:	da9c      	bge.n	1016dd8 <pu_update_eff_times+0x28>
 1016e9e:	e7d7      	b.n	1016e50 <pu_update_eff_times+0xa0>

01016ea0 <rp_pu_send_phy_rsp.constprop.0>:
	}
}
#endif /* CONFIG_BT_CENTRAL */

#if defined(CONFIG_BT_PERIPHERAL)
static void rp_pu_send_phy_rsp(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
 1016ea0:	b570      	push	{r4, r5, r6, lr}
 1016ea2:	4605      	mov	r5, r0
 1016ea4:	460c      	mov	r4, r1
{
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx) ||
 1016ea6:	f003 fe13 	bl	101aad0 <llcp_rr_ispaused>
 1016eaa:	b110      	cbz	r0, 1016eb2 <rp_pu_send_phy_rsp.constprop.0+0x12>
	    (llcp_rr_get_paused_cmd(conn) == PROC_PHY_UPDATE)) {
		ctx->state = RP_PU_STATE_WAIT_TX_PHY_RSP;
 1016eac:	2302      	movs	r3, #2
 1016eae:	72a3      	strb	r3, [r4, #10]
		llcp_rr_set_paused_cmd(conn, PROC_CTE_REQ);
		rp_pu_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_PHY_RSP);
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_PHY_UPD_IND;
		ctx->state = RP_PU_STATE_WAIT_TX_ACK_PHY_RSP;
	}
}
 1016eb0:	bd70      	pop	{r4, r5, r6, pc}
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx) ||
 1016eb2:	4621      	mov	r1, r4
 1016eb4:	4628      	mov	r0, r5
 1016eb6:	f000 ffef 	bl	1017e98 <llcp_tx_alloc_peek>
 1016eba:	2800      	cmp	r0, #0
 1016ebc:	d0f6      	beq.n	1016eac <rp_pu_send_phy_rsp.constprop.0+0xc>
	    (llcp_rr_get_paused_cmd(conn) == PROC_PHY_UPDATE)) {
 1016ebe:	4628      	mov	r0, r5
 1016ec0:	f003 fdfa 	bl	101aab8 <llcp_rr_get_paused_cmd>
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx) ||
 1016ec4:	2807      	cmp	r0, #7
 1016ec6:	d0f1      	beq.n	1016eac <rp_pu_send_phy_rsp.constprop.0+0xc>
		llcp_rr_set_paused_cmd(conn, PROC_CTE_REQ);
 1016ec8:	210d      	movs	r1, #13
 1016eca:	4628      	mov	r0, r5
 1016ecc:	f003 fdf2 	bl	101aab4 <llcp_rr_set_paused_cmd>
	tx = llcp_tx_alloc(conn, ctx);
 1016ed0:	4621      	mov	r1, r4
 1016ed2:	4628      	mov	r0, r5
 1016ed4:	f000 ffe8 	bl	1017ea8 <llcp_tx_alloc>
	LL_ASSERT(tx);
 1016ed8:	4606      	mov	r6, r0
 1016eda:	b188      	cbz	r0, 1016f00 <rp_pu_send_phy_rsp.constprop.0+0x60>
		llcp_pdu_encode_phy_rsp(conn, pdu);
 1016edc:	4628      	mov	r0, r5
 1016ede:	1d31      	adds	r1, r6, #4
 1016ee0:	f002 fd06 	bl	10198f0 <llcp_pdu_encode_phy_rsp>
	ctx->tx_ack = tx;
 1016ee4:	6166      	str	r6, [r4, #20]
	ctx->tx_opcode = pdu->llctrl.opcode;
 1016ee6:	79f3      	ldrb	r3, [r6, #7]
	llcp_tx_enqueue(conn, tx);
 1016ee8:	4631      	mov	r1, r6
	ctx->tx_opcode = pdu->llctrl.opcode;
 1016eea:	7363      	strb	r3, [r4, #13]
	llcp_tx_enqueue(conn, tx);
 1016eec:	4628      	mov	r0, r5
 1016eee:	f000 fff9 	bl	1017ee4 <llcp_tx_enqueue>
	llcp_rr_prt_restart(conn);
 1016ef2:	4628      	mov	r0, r5
 1016ef4:	f003 fdf4 	bl	101aae0 <llcp_rr_prt_restart>
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_PHY_UPD_IND;
 1016ef8:	2218      	movs	r2, #24
 1016efa:	2303      	movs	r3, #3
 1016efc:	72e2      	strb	r2, [r4, #11]
		ctx->state = RP_PU_STATE_WAIT_TX_ACK_PHY_RSP;
 1016efe:	e7d6      	b.n	1016eae <rp_pu_send_phy_rsp.constprop.0+0xe>
	LL_ASSERT(tx);
 1016f00:	f240 3386 	movw	r3, #902	; 0x386
 1016f04:	4a05      	ldr	r2, [pc, #20]	; (1016f1c <rp_pu_send_phy_rsp.constprop.0+0x7c>)
 1016f06:	4906      	ldr	r1, [pc, #24]	; (1016f20 <rp_pu_send_phy_rsp.constprop.0+0x80>)
 1016f08:	4806      	ldr	r0, [pc, #24]	; (1016f24 <rp_pu_send_phy_rsp.constprop.0+0x84>)
 1016f0a:	f00d fe64 	bl	1024bd6 <assert_print>
 1016f0e:	4040      	eors	r0, r0
 1016f10:	f380 8811 	msr	BASEPRI, r0
 1016f14:	f04f 0003 	mov.w	r0, #3
 1016f18:	df02      	svc	2
 1016f1a:	e7df      	b.n	1016edc <rp_pu_send_phy_rsp.constprop.0+0x3c>
 1016f1c:	0102aa8c 	.word	0x0102aa8c
 1016f20:	0102a920 	.word	0x0102a920
 1016f24:	0102a278 	.word	0x0102a278

01016f28 <pu_dle_ntf.constprop.0>:
static void pu_dle_ntf(struct ll_conn *conn, struct proc_ctx *ctx)
 1016f28:	b538      	push	{r3, r4, r5, lr}
 1016f2a:	4605      	mov	r5, r0
	ntf = llcp_ntf_alloc();
 1016f2c:	f000 ffd8 	bl	1017ee0 <llcp_ntf_alloc>
	LL_ASSERT(ntf);
 1016f30:	4604      	mov	r4, r0
 1016f32:	b170      	cbz	r0, 1016f52 <pu_dle_ntf.constprop.0+0x2a>
	ntf->hdr.type = NODE_RX_TYPE_DC_PDU;
 1016f34:	2303      	movs	r3, #3
 1016f36:	7123      	strb	r3, [r4, #4]
	ntf->hdr.handle = conn->lll.handle;
 1016f38:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
	llcp_ntf_encode_length_change(conn, pdu);
 1016f3a:	4628      	mov	r0, r5
 1016f3c:	f104 011c 	add.w	r1, r4, #28
	ntf->hdr.handle = conn->lll.handle;
 1016f40:	80e3      	strh	r3, [r4, #6]
	llcp_ntf_encode_length_change(conn, pdu);
 1016f42:	f002 fde9 	bl	1019b18 <llcp_ntf_encode_length_change>
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1016f46:	4621      	mov	r1, r4
 1016f48:	6820      	ldr	r0, [r4, #0]
}
 1016f4a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1016f4e:	f7fd b9c5 	b.w	10142dc <ll_rx_put_sched>
	LL_ASSERT(ntf);
 1016f52:	f44f 73db 	mov.w	r3, #438	; 0x1b6
 1016f56:	4a06      	ldr	r2, [pc, #24]	; (1016f70 <pu_dle_ntf.constprop.0+0x48>)
 1016f58:	4906      	ldr	r1, [pc, #24]	; (1016f74 <pu_dle_ntf.constprop.0+0x4c>)
 1016f5a:	4807      	ldr	r0, [pc, #28]	; (1016f78 <pu_dle_ntf.constprop.0+0x50>)
 1016f5c:	f00d fe3b 	bl	1024bd6 <assert_print>
 1016f60:	4040      	eors	r0, r0
 1016f62:	f380 8811 	msr	BASEPRI, r0
 1016f66:	f04f 0003 	mov.w	r0, #3
 1016f6a:	df02      	svc	2
 1016f6c:	e7e2      	b.n	1016f34 <pu_dle_ntf.constprop.0+0xc>
 1016f6e:	bf00      	nop
 1016f70:	0102aa8c 	.word	0x0102aa8c
 1016f74:	0102aad0 	.word	0x0102aad0
 1016f78:	0102a278 	.word	0x0102a278

01016f7c <lp_pu_tx_ntf.constprop.0>:
static void lp_pu_tx_ntf(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt)
 1016f7c:	b570      	push	{r4, r5, r6, lr}
	uint8_t ntf_count = ctx->data.pu.ntf_pu + NTF_DLE;
 1016f7e:	7f4a      	ldrb	r2, [r1, #29]
static void lp_pu_tx_ntf(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt)
 1016f80:	460c      	mov	r4, r1
	uint8_t ntf_count = ctx->data.pu.ntf_pu + NTF_DLE;
 1016f82:	f3c2 0300 	ubfx	r3, r2, #0, #1
 1016f86:	f3c2 0c40 	ubfx	ip, r2, #1, #1
 1016f8a:	4463      	add	r3, ip
 1016f8c:	b2db      	uxtb	r3, r3
	if ((ntf_count > 1) && !llcp_ntf_alloc_num_available(ntf_count)) {
 1016f8e:	2b02      	cmp	r3, #2
static void lp_pu_tx_ntf(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt)
 1016f90:	4605      	mov	r5, r0
	if ((ntf_count > 1) && !llcp_ntf_alloc_num_available(ntf_count)) {
 1016f92:	d025      	beq.n	1016fe0 <lp_pu_tx_ntf.constprop.0+0x64>
	if (ntf_count && !llcp_ntf_alloc_num_available(ntf_count)) {
 1016f94:	b983      	cbnz	r3, 1016fb8 <lp_pu_tx_ntf.constprop.0+0x3c>
		if (ctx->data.pu.ntf_pu) {
 1016f96:	07d6      	lsls	r6, r2, #31
 1016f98:	d428      	bmi.n	1016fec <lp_pu_tx_ntf.constprop.0+0x70>
		if (ctx->data.pu.ntf_dle) {
 1016f9a:	0793      	lsls	r3, r2, #30
 1016f9c:	d502      	bpl.n	1016fa4 <lp_pu_tx_ntf.constprop.0+0x28>
			pu_dle_ntf(conn, ctx);
 1016f9e:	4628      	mov	r0, r5
 1016fa0:	f7ff ffc2 	bl	1016f28 <pu_dle_ntf.constprop.0>
		llcp_lr_complete(conn);
 1016fa4:	4628      	mov	r0, r5
 1016fa6:	f002 fa85 	bl	10194b4 <llcp_lr_complete>
		ctx->state = LP_PU_STATE_IDLE;
 1016faa:	2100      	movs	r1, #0
 1016fac:	72a1      	strb	r1, [r4, #10]
		llcp_rr_set_paused_cmd(conn, PROC_NONE);
 1016fae:	4628      	mov	r0, r5
}
 1016fb0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		llcp_rr_set_paused_cmd(conn, PROC_NONE);
 1016fb4:	f003 bd7e 	b.w	101aab4 <llcp_rr_set_paused_cmd>
 1016fb8:	2601      	movs	r6, #1
	if (ntf_count && !llcp_ntf_alloc_num_available(ntf_count)) {
 1016fba:	4630      	mov	r0, r6
 1016fbc:	f000 ff88 	bl	1017ed0 <llcp_ntf_alloc_num_available>
 1016fc0:	b158      	cbz	r0, 1016fda <lp_pu_tx_ntf.constprop.0+0x5e>
		if (ctx->data.pu.ntf_pu) {
 1016fc2:	7f62      	ldrb	r2, [r4, #29]
 1016fc4:	07d1      	lsls	r1, r2, #31
 1016fc6:	d5e8      	bpl.n	1016f9a <lp_pu_tx_ntf.constprop.0+0x1e>
			pu_ntf(conn, ctx);
 1016fc8:	4621      	mov	r1, r4
 1016fca:	4628      	mov	r0, r5
 1016fcc:	f7ff febc 	bl	1016d48 <pu_ntf>
			if (ntf_count == 1 && NTF_DLE == 1) {
 1016fd0:	2e01      	cmp	r6, #1
 1016fd2:	d10f      	bne.n	1016ff4 <lp_pu_tx_ntf.constprop.0+0x78>
 1016fd4:	7f63      	ldrb	r3, [r4, #29]
 1016fd6:	079a      	lsls	r2, r3, #30
 1016fd8:	d5e4      	bpl.n	1016fa4 <lp_pu_tx_ntf.constprop.0+0x28>
		ctx->state = LP_PU_STATE_WAIT_NTF;
 1016fda:	2309      	movs	r3, #9
 1016fdc:	72a3      	strb	r3, [r4, #10]
}
 1016fde:	bd70      	pop	{r4, r5, r6, pc}
	if ((ntf_count > 1) && !llcp_ntf_alloc_num_available(ntf_count)) {
 1016fe0:	4618      	mov	r0, r3
 1016fe2:	f000 ff75 	bl	1017ed0 <llcp_ntf_alloc_num_available>
 1016fe6:	1c46      	adds	r6, r0, #1
 1016fe8:	b2f6      	uxtb	r6, r6
 1016fea:	e7e6      	b.n	1016fba <lp_pu_tx_ntf.constprop.0+0x3e>
			pu_ntf(conn, ctx);
 1016fec:	f7ff feac 	bl	1016d48 <pu_ntf>
		if (ctx->data.pu.ntf_dle) {
 1016ff0:	7f62      	ldrb	r2, [r4, #29]
 1016ff2:	e7d2      	b.n	1016f9a <lp_pu_tx_ntf.constprop.0+0x1e>
			if (ntf_count == 1 && NTF_DLE == 1) {
 1016ff4:	7f62      	ldrb	r2, [r4, #29]
 1016ff6:	e7d0      	b.n	1016f9a <lp_pu_tx_ntf.constprop.0+0x1e>

01016ff8 <lp_pu_send_phy_req.constprop.0>:
static void lp_pu_send_phy_req(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
 1016ff8:	b570      	push	{r4, r5, r6, lr}
 1016ffa:	4605      	mov	r5, r0
 1016ffc:	460c      	mov	r4, r1
	if (llcp_lr_ispaused(conn) || llcp_rr_get_collision(conn) ||
 1016ffe:	f002 f9c5 	bl	101938c <llcp_lr_ispaused>
 1017002:	b110      	cbz	r0, 101700a <lp_pu_send_phy_req.constprop.0+0x12>
		ctx->state = LP_PU_STATE_WAIT_TX_PHY_REQ;
 1017004:	2301      	movs	r3, #1
 1017006:	72a3      	strb	r3, [r4, #10]
}
 1017008:	bd70      	pop	{r4, r5, r6, pc}
	if (llcp_lr_ispaused(conn) || llcp_rr_get_collision(conn) ||
 101700a:	4628      	mov	r0, r5
 101700c:	f003 fd56 	bl	101aabc <llcp_rr_get_collision>
 1017010:	2800      	cmp	r0, #0
 1017012:	d1f7      	bne.n	1017004 <lp_pu_send_phy_req.constprop.0+0xc>
	    !llcp_tx_alloc_peek(conn, ctx) ||
 1017014:	4621      	mov	r1, r4
 1017016:	4628      	mov	r0, r5
 1017018:	f000 ff3e 	bl	1017e98 <llcp_tx_alloc_peek>
	if (llcp_lr_ispaused(conn) || llcp_rr_get_collision(conn) ||
 101701c:	2800      	cmp	r0, #0
 101701e:	d0f1      	beq.n	1017004 <lp_pu_send_phy_req.constprop.0+0xc>
	    (llcp_rr_get_paused_cmd(conn) == PROC_PHY_UPDATE)) {
 1017020:	4628      	mov	r0, r5
 1017022:	f003 fd49 	bl	101aab8 <llcp_rr_get_paused_cmd>
	    !llcp_tx_alloc_peek(conn, ctx) ||
 1017026:	2807      	cmp	r0, #7
 1017028:	d0ec      	beq.n	1017004 <lp_pu_send_phy_req.constprop.0+0xc>
		llcp_rr_set_incompat(conn, INCOMPAT_RESOLVABLE);
 101702a:	2101      	movs	r1, #1
 101702c:	4628      	mov	r0, r5
 101702e:	f003 fd3d 	bl	101aaac <llcp_rr_set_incompat>
		llcp_rr_set_paused_cmd(conn, PROC_CTE_REQ);
 1017032:	210d      	movs	r1, #13
 1017034:	4628      	mov	r0, r5
 1017036:	f003 fd3d 	bl	101aab4 <llcp_rr_set_paused_cmd>
	tx = llcp_tx_alloc(conn, ctx);
 101703a:	4621      	mov	r1, r4
 101703c:	4628      	mov	r0, r5
 101703e:	f000 ff33 	bl	1017ea8 <llcp_tx_alloc>
	LL_ASSERT(tx);
 1017042:	4606      	mov	r6, r0
 1017044:	b360      	cbz	r0, 10170a0 <lp_pu_send_phy_req.constprop.0+0xa8>
	conn->phy_pref_rx = ctx->data.pu.rx;
 1017046:	7f23      	ldrb	r3, [r4, #28]
 1017048:	f895 218c 	ldrb.w	r2, [r5, #396]	; 0x18c
 101704c:	f3c3 03c2 	ubfx	r3, r3, #3, #3
 1017050:	f363 02c5 	bfi	r2, r3, #3, #3
 1017054:	f885 218c 	strb.w	r2, [r5, #396]	; 0x18c
	conn->phy_pref_tx = ctx->data.pu.tx;
 1017058:	7f22      	ldrb	r2, [r4, #28]
 101705a:	f895 318c 	ldrb.w	r3, [r5, #396]	; 0x18c
		llcp_pdu_encode_phy_req(ctx, pdu);
 101705e:	4620      	mov	r0, r4
	conn->phy_pref_tx = ctx->data.pu.tx;
 1017060:	f362 0302 	bfi	r3, r2, #0, #3
 1017064:	f885 318c 	strb.w	r3, [r5, #396]	; 0x18c
	conn->lll.phy_flags = ctx->data.pu.flags;
 1017068:	7f23      	ldrb	r3, [r4, #28]
 101706a:	f895 2076 	ldrb.w	r2, [r5, #118]	; 0x76
 101706e:	f3c3 1380 	ubfx	r3, r3, #6, #1
 1017072:	f363 02c3 	bfi	r2, r3, #3, #1
 1017076:	f885 2076 	strb.w	r2, [r5, #118]	; 0x76
		llcp_pdu_encode_phy_req(ctx, pdu);
 101707a:	1d31      	adds	r1, r6, #4
 101707c:	f002 fc18 	bl	10198b0 <llcp_pdu_encode_phy_req>
	ctx->tx_ack = tx;
 1017080:	6166      	str	r6, [r4, #20]
	ctx->tx_opcode = pdu->llctrl.opcode;
 1017082:	79f3      	ldrb	r3, [r6, #7]
	llcp_tx_enqueue(conn, tx);
 1017084:	4631      	mov	r1, r6
	ctx->tx_opcode = pdu->llctrl.opcode;
 1017086:	7363      	strb	r3, [r4, #13]
	llcp_tx_enqueue(conn, tx);
 1017088:	4628      	mov	r0, r5
 101708a:	f000 ff2b 	bl	1017ee4 <llcp_tx_enqueue>
	llcp_lr_prt_restart(conn);
 101708e:	4628      	mov	r0, r5
 1017090:	f002 f98c 	bl	10193ac <llcp_lr_prt_restart>
		llcp_tx_pause_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_PHY_UPDATE);
 1017094:	2102      	movs	r1, #2
 1017096:	4628      	mov	r0, r5
 1017098:	f000 ff28 	bl	1017eec <llcp_tx_pause_data>
 101709c:	2302      	movs	r3, #2
 101709e:	e7b2      	b.n	1017006 <lp_pu_send_phy_req.constprop.0+0xe>
	LL_ASSERT(tx);
 10170a0:	f44f 73bc 	mov.w	r3, #376	; 0x178
 10170a4:	4a05      	ldr	r2, [pc, #20]	; (10170bc <lp_pu_send_phy_req.constprop.0+0xc4>)
 10170a6:	4906      	ldr	r1, [pc, #24]	; (10170c0 <lp_pu_send_phy_req.constprop.0+0xc8>)
 10170a8:	4806      	ldr	r0, [pc, #24]	; (10170c4 <lp_pu_send_phy_req.constprop.0+0xcc>)
 10170aa:	f00d fd94 	bl	1024bd6 <assert_print>
 10170ae:	4040      	eors	r0, r0
 10170b0:	f380 8811 	msr	BASEPRI, r0
 10170b4:	f04f 0003 	mov.w	r0, #3
 10170b8:	df02      	svc	2
 10170ba:	e7c4      	b.n	1017046 <lp_pu_send_phy_req.constprop.0+0x4e>
 10170bc:	0102aa8c 	.word	0x0102aa8c
 10170c0:	0102a920 	.word	0x0102a920
 10170c4:	0102a278 	.word	0x0102a278

010170c8 <lp_pu_execute_fsm>:
{
 10170c8:	b570      	push	{r4, r5, r6, lr}
 10170ca:	461d      	mov	r5, r3
	switch (ctx->state) {
 10170cc:	7a8b      	ldrb	r3, [r1, #10]
{
 10170ce:	460c      	mov	r4, r1
 10170d0:	4606      	mov	r6, r0
 10170d2:	b082      	sub	sp, #8
	switch (ctx->state) {
 10170d4:	2b09      	cmp	r3, #9
 10170d6:	d80b      	bhi.n	10170f0 <lp_pu_execute_fsm+0x28>
 10170d8:	e8df f003 	tbb	[pc, r3]
 10170dc:	0a190505 	.word	0x0a190505
 10170e0:	5b230a0a 	.word	0x5b230a0a
 10170e4:	968c      	.short	0x968c
	switch (evt) {
 10170e6:	2a00      	cmp	r2, #0
 10170e8:	f000 8092 	beq.w	1017210 <lp_pu_execute_fsm+0x148>
}
 10170ec:	b002      	add	sp, #8
 10170ee:	bd70      	pop	{r4, r5, r6, pc}
		LL_ASSERT(0);
 10170f0:	f240 3346 	movw	r3, #838	; 0x346
 10170f4:	4a91      	ldr	r2, [pc, #580]	; (101733c <lp_pu_execute_fsm+0x274>)
 10170f6:	4992      	ldr	r1, [pc, #584]	; (1017340 <lp_pu_execute_fsm+0x278>)
 10170f8:	4892      	ldr	r0, [pc, #584]	; (1017344 <lp_pu_execute_fsm+0x27c>)
 10170fa:	f00d fd6c 	bl	1024bd6 <assert_print>
 10170fe:	4040      	eors	r0, r0
 1017100:	f380 8811 	msr	BASEPRI, r0
 1017104:	f04f 0003 	mov.w	r0, #3
 1017108:	df02      	svc	2
}
 101710a:	b002      	add	sp, #8
 101710c:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 101710e:	2a03      	cmp	r2, #3
 1017110:	d1ec      	bne.n	10170ec <lp_pu_execute_fsm+0x24>
		switch (conn->lll.role) {
 1017112:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 1017116:	09db      	lsrs	r3, r3, #7
 1017118:	f040 80b6 	bne.w	1017288 <lp_pu_execute_fsm+0x1c0>
			LL_ASSERT(0);
 101711c:	f240 2373 	movw	r3, #627	; 0x273
 1017120:	e7e8      	b.n	10170f4 <lp_pu_execute_fsm+0x2c>
	switch (evt) {
 1017122:	2a05      	cmp	r2, #5
 1017124:	f000 8096 	beq.w	1017254 <lp_pu_execute_fsm+0x18c>
 1017128:	2a06      	cmp	r2, #6
 101712a:	d077      	beq.n	101721c <lp_pu_execute_fsm+0x154>
 101712c:	2a02      	cmp	r2, #2
 101712e:	d1dd      	bne.n	10170ec <lp_pu_execute_fsm+0x24>
		LL_ASSERT(conn->lll.role == BT_HCI_ROLE_PERIPHERAL);
 1017130:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
 1017134:	2b00      	cmp	r3, #0
 1017136:	db0c      	blt.n	1017152 <lp_pu_execute_fsm+0x8a>
 1017138:	f44f 732d 	mov.w	r3, #692	; 0x2b4
 101713c:	4a7f      	ldr	r2, [pc, #508]	; (101733c <lp_pu_execute_fsm+0x274>)
 101713e:	4982      	ldr	r1, [pc, #520]	; (1017348 <lp_pu_execute_fsm+0x280>)
 1017140:	4880      	ldr	r0, [pc, #512]	; (1017344 <lp_pu_execute_fsm+0x27c>)
 1017142:	f00d fd48 	bl	1024bd6 <assert_print>
 1017146:	4040      	eors	r0, r0
 1017148:	f380 8811 	msr	BASEPRI, r0
 101714c:	f04f 0003 	mov.w	r0, #3
 1017150:	df02      	svc	2
		llcp_pdu_decode_phy_update_ind(ctx, (struct pdu_data *)param);
 1017152:	4629      	mov	r1, r5
 1017154:	4620      	mov	r0, r4
 1017156:	f002 fbe1 	bl	101991c <llcp_pdu_decode_phy_update_ind>
		const uint8_t end_procedure = pu_check_update_ind(conn, ctx);
 101715a:	4621      	mov	r1, r4
 101715c:	4630      	mov	r0, r6
 101715e:	f7ff fdc7 	bl	1016cf0 <pu_check_update_ind>
		if (!end_procedure) {
 1017162:	2800      	cmp	r0, #0
 1017164:	f040 80ab 	bne.w	10172be <lp_pu_execute_fsm+0x1f6>
			if (ctx->data.pu.p_to_c_phy) {
 1017168:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
 101716c:	b12b      	cbz	r3, 101717a <lp_pu_execute_fsm+0xb2>
	lll->phy_tx_time = phy_tx;
 101716e:	f896 2076 	ldrb.w	r2, [r6, #118]	; 0x76
 1017172:	f363 1206 	bfi	r2, r3, #4, #3
 1017176:	f886 2076 	strb.w	r2, [r6, #118]	; 0x76
			llcp_lr_prt_stop(conn);
 101717a:	4630      	mov	r0, r6
 101717c:	f002 f920 	bl	10193c0 <llcp_lr_prt_stop>
			ctx->state = LP_PU_STATE_WAIT_INSTANT;
 1017180:	2307      	movs	r3, #7
 1017182:	72a3      	strb	r3, [r4, #10]
		llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_PHY_UPDATE);
 1017184:	2102      	movs	r1, #2
 1017186:	4630      	mov	r0, r6
}
 1017188:	b002      	add	sp, #8
 101718a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_PHY_UPDATE);
 101718e:	f000 bec1 	b.w	1017f14 <llcp_tx_resume_data>
	switch (evt) {
 1017192:	2a00      	cmp	r2, #0
 1017194:	d1aa      	bne.n	10170ec <lp_pu_execute_fsm+0x24>
	if (is_instant_reached_or_passed(ctx->data.pu.instant, ull_conn_event_counter(conn))) {
 1017196:	8c25      	ldrh	r5, [r4, #32]
 1017198:	f7ff fc1e 	bl	10169d8 <ull_conn_event_counter>
 101719c:	1b40      	subs	r0, r0, r5
 101719e:	0403      	lsls	r3, r0, #16
 10171a0:	d4a4      	bmi.n	10170ec <lp_pu_execute_fsm+0x24>
	} else if (lll->role == BT_HCI_ROLE_PERIPHERAL) {
 10171a2:	f996 5039 	ldrsb.w	r5, [r6, #57]	; 0x39
	const uint8_t old_tx = lll->phy_tx;
 10171a6:	f896 0076 	ldrb.w	r0, [r6, #118]	; 0x76
	const uint8_t old_rx = lll->phy_rx;
 10171aa:	f896 3077 	ldrb.w	r3, [r6, #119]	; 0x77
	} else if (lll->role == BT_HCI_ROLE_PERIPHERAL) {
 10171ae:	2d00      	cmp	r5, #0
 10171b0:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
 10171b4:	f894 1023 	ldrb.w	r1, [r4, #35]	; 0x23
	const uint8_t old_tx = lll->phy_tx;
 10171b8:	f000 0e07 	and.w	lr, r0, #7
	const uint8_t old_rx = lll->phy_rx;
 10171bc:	f003 0c07 	and.w	ip, r3, #7
	} else if (lll->role == BT_HCI_ROLE_PERIPHERAL) {
 10171c0:	f2c0 808c 	blt.w	10172dc <lp_pu_execute_fsm+0x214>
		llcp_rr_set_incompat(conn, INCOMPAT_NO_COLLISION);
 10171c4:	2100      	movs	r1, #0
 10171c6:	4630      	mov	r0, r6
 10171c8:	f003 fc70 	bl	101aaac <llcp_rr_set_incompat>
		ctx->data.pu.error = BT_HCI_ERR_SUCCESS;
 10171cc:	2200      	movs	r2, #0
		ctx->data.pu.ntf_pu = (phy_changed || ctx->data.pu.host_initiated);
 10171ce:	7f23      	ldrb	r3, [r4, #28]
		ctx->data.pu.error = BT_HCI_ERR_SUCCESS;
 10171d0:	77a2      	strb	r2, [r4, #30]
		ctx->data.pu.ntf_pu = (phy_changed || ctx->data.pu.host_initiated);
 10171d2:	09db      	lsrs	r3, r3, #7
 10171d4:	7f62      	ldrb	r2, [r4, #29]
	ctx->state = LP_PU_STATE_WAIT_INSTANT_ON_AIR;
 10171d6:	2108      	movs	r1, #8
		ctx->data.pu.ntf_pu = (phy_changed || ctx->data.pu.host_initiated);
 10171d8:	f363 0200 	bfi	r2, r3, #0, #1
 10171dc:	7762      	strb	r2, [r4, #29]
	pu_set_timing_restrict(conn, conn->lll.phy_tx);
 10171de:	f896 3076 	ldrb.w	r3, [r6, #118]	; 0x76
	lll->phy_tx_time = phy_tx;
 10171e2:	461a      	mov	r2, r3
	pu_set_timing_restrict(conn, conn->lll.phy_tx);
 10171e4:	f3c3 0302 	ubfx	r3, r3, #0, #3
	lll->phy_tx_time = phy_tx;
 10171e8:	f363 1206 	bfi	r2, r3, #4, #3
 10171ec:	f886 2076 	strb.w	r2, [r6, #118]	; 0x76
	ctx->state = LP_PU_STATE_WAIT_INSTANT_ON_AIR;
 10171f0:	72a1      	strb	r1, [r4, #10]
}
 10171f2:	e77b      	b.n	10170ec <lp_pu_execute_fsm+0x24>
	switch (evt) {
 10171f4:	2a04      	cmp	r2, #4
 10171f6:	f47f af79 	bne.w	10170ec <lp_pu_execute_fsm+0x24>
		lp_pu_tx_ntf(conn, ctx, evt);
 10171fa:	4621      	mov	r1, r4
 10171fc:	4630      	mov	r0, r6
}
 10171fe:	b002      	add	sp, #8
 1017200:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		lp_pu_tx_ntf(conn, ctx, evt);
 1017204:	f7ff beba 	b.w	1016f7c <lp_pu_tx_ntf.constprop.0>
	switch (evt) {
 1017208:	2a00      	cmp	r2, #0
 101720a:	f47f af6f 	bne.w	10170ec <lp_pu_execute_fsm+0x24>
 101720e:	e7f4      	b.n	10171fa <lp_pu_execute_fsm+0x132>
		lp_pu_send_phy_req(conn, ctx, evt, param);
 1017210:	4621      	mov	r1, r4
}
 1017212:	b002      	add	sp, #8
 1017214:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		lp_pu_send_phy_req(conn, ctx, evt, param);
 1017218:	f7ff beee 	b.w	1016ff8 <lp_pu_send_phy_req.constprop.0>
		llcp_rr_set_incompat(conn, INCOMPAT_NO_COLLISION);
 101721c:	2100      	movs	r1, #0
 101721e:	f003 fc45 	bl	101aaac <llcp_rr_set_incompat>
		ctx->data.pu.error = BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 1017222:	221a      	movs	r2, #26
	lp_pu_tx_ntf(conn, ctx, evt);
 1017224:	4621      	mov	r1, r4
 1017226:	4630      	mov	r0, r6
	conn->llcp.fex.features_used &= ~ll_feat_mask;
 1017228:	f8d6 3130 	ldr.w	r3, [r6, #304]	; 0x130
 101722c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 1017230:	f8c6 3130 	str.w	r3, [r6, #304]	; 0x130
		ctx->data.pu.ntf_pu = 1;
 1017234:	7f63      	ldrb	r3, [r4, #29]
		ctx->data.pu.error = BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 1017236:	77a2      	strb	r2, [r4, #30]
		ctx->data.pu.ntf_pu = 1;
 1017238:	f043 0301 	orr.w	r3, r3, #1
 101723c:	7763      	strb	r3, [r4, #29]
	pu_set_timing_restrict(conn, conn->lll.phy_tx);
 101723e:	f896 3076 	ldrb.w	r3, [r6, #118]	; 0x76
 1017242:	f3c3 0202 	ubfx	r2, r3, #0, #3
	lll->phy_tx_time = phy_tx;
 1017246:	f362 1306 	bfi	r3, r2, #4, #3
 101724a:	f886 3076 	strb.w	r3, [r6, #118]	; 0x76
	lp_pu_tx_ntf(conn, ctx, evt);
 101724e:	f7ff fe95 	bl	1016f7c <lp_pu_tx_ntf.constprop.0>
}
 1017252:	e797      	b.n	1017184 <lp_pu_execute_fsm+0xbc>
		llcp_rr_set_incompat(conn, INCOMPAT_NO_COLLISION);
 1017254:	2100      	movs	r1, #0
 1017256:	f003 fc29 	bl	101aaac <llcp_rr_set_incompat>
		llcp_pdu_decode_reject_ext_ind(ctx, (struct pdu_data *) param);
 101725a:	4629      	mov	r1, r5
 101725c:	4620      	mov	r0, r4
 101725e:	f002 fb1f 	bl	10198a0 <llcp_pdu_decode_reject_ext_ind>
		ctx->data.pu.ntf_pu = 1;
 1017262:	7f63      	ldrb	r3, [r4, #29]
		ctx->data.pu.error = ctx->reject_ext_ind.error_code;
 1017264:	f894 204a 	ldrb.w	r2, [r4, #74]	; 0x4a
		ctx->data.pu.ntf_pu = 1;
 1017268:	f043 0301 	orr.w	r3, r3, #1
		ctx->data.pu.error = ctx->reject_ext_ind.error_code;
 101726c:	77a2      	strb	r2, [r4, #30]
		ctx->data.pu.ntf_pu = 1;
 101726e:	7763      	strb	r3, [r4, #29]
	pu_set_timing_restrict(conn, conn->lll.phy_tx);
 1017270:	f896 3076 	ldrb.w	r3, [r6, #118]	; 0x76
	lp_pu_tx_ntf(conn, ctx, evt);
 1017274:	4621      	mov	r1, r4
	lll->phy_tx_time = phy_tx;
 1017276:	461a      	mov	r2, r3
	pu_set_timing_restrict(conn, conn->lll.phy_tx);
 1017278:	f3c3 0302 	ubfx	r3, r3, #0, #3
	lll->phy_tx_time = phy_tx;
 101727c:	f363 1206 	bfi	r2, r3, #4, #3
	lp_pu_tx_ntf(conn, ctx, evt);
 1017280:	4630      	mov	r0, r6
	lll->phy_tx_time = phy_tx;
 1017282:	f886 2076 	strb.w	r2, [r6, #118]	; 0x76
 1017286:	e7e2      	b.n	101724e <lp_pu_execute_fsm+0x186>
	uint8_t phy_tx_time[8] = { 0,	      PHY_1M,	 PHY_2M,    PHY_1M,
 1017288:	4b30      	ldr	r3, [pc, #192]	; (101734c <lp_pu_execute_fsm+0x284>)
				conn, pu_select_phy_timing_restrict(conn, ctx->data.pu.tx));
 101728a:	7f25      	ldrb	r5, [r4, #28]
	uint8_t phy_tx_time[8] = { 0,	      PHY_1M,	 PHY_2M,    PHY_1M,
 101728c:	e893 0003 	ldmia.w	r3, {r0, r1}
 1017290:	ab02      	add	r3, sp, #8
 1017292:	e903 0003 	stmdb	r3, {r0, r1}
	const uint8_t phys = phy_tx | lll->phy_tx;
 1017296:	f896 3076 	ldrb.w	r3, [r6, #118]	; 0x76
			llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_PHY_UPDATE);
 101729a:	2102      	movs	r1, #2
	lll->phy_tx_time = phy_tx;
 101729c:	461a      	mov	r2, r3
	return phy_tx_time[phys];
 101729e:	432b      	orrs	r3, r5
 10172a0:	f003 0307 	and.w	r3, r3, #7
 10172a4:	3308      	adds	r3, #8
 10172a6:	446b      	add	r3, sp
 10172a8:	f813 5c08 	ldrb.w	r5, [r3, #-8]
			ctx->state = LP_PU_STATE_WAIT_RX_PHY_UPDATE_IND;
 10172ac:	f641 0306 	movw	r3, #6150	; 0x1806
	lll->phy_tx_time = phy_tx;
 10172b0:	f365 1206 	bfi	r2, r5, #4, #3
 10172b4:	f886 2076 	strb.w	r2, [r6, #118]	; 0x76
			llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_PHY_UPDATE);
 10172b8:	4630      	mov	r0, r6
			ctx->state = LP_PU_STATE_WAIT_RX_PHY_UPDATE_IND;
 10172ba:	8163      	strh	r3, [r4, #10]
			llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_PHY_UPDATE);
 10172bc:	e764      	b.n	1017188 <lp_pu_execute_fsm+0xc0>
			llcp_rr_set_incompat(conn, INCOMPAT_NO_COLLISION);
 10172be:	2100      	movs	r1, #0
 10172c0:	4630      	mov	r0, r6
 10172c2:	f003 fbf3 	bl	101aaac <llcp_rr_set_incompat>
			if (ctx->data.pu.error != BT_HCI_ERR_SUCCESS) {
 10172c6:	7fa3      	ldrb	r3, [r4, #30]
 10172c8:	b10b      	cbz	r3, 10172ce <lp_pu_execute_fsm+0x206>
				conn->llcp_terminate.reason_final = ctx->data.pu.error;
 10172ca:	f886 3148 	strb.w	r3, [r6, #328]	; 0x148
			ctx->data.pu.ntf_pu = ctx->data.pu.host_initiated;
 10172ce:	7f23      	ldrb	r3, [r4, #28]
 10172d0:	7f62      	ldrb	r2, [r4, #29]
 10172d2:	09db      	lsrs	r3, r3, #7
 10172d4:	f363 0200 	bfi	r2, r3, #0, #1
 10172d8:	7762      	strb	r2, [r4, #29]
 10172da:	e7c9      	b.n	1017270 <lp_pu_execute_fsm+0x1a8>
		if (p_to_c_phy) {
 10172dc:	f011 0103 	ands.w	r1, r1, #3
 10172e0:	d01d      	beq.n	101731e <lp_pu_execute_fsm+0x256>
			lll->phy_tx = p_to_c_phy;
 10172e2:	f361 0002 	bfi	r0, r1, #0, #3
		if (c_to_p_phy) {
 10172e6:	f012 0203 	ands.w	r2, r2, #3
			lll->phy_tx = p_to_c_phy;
 10172ea:	f886 0076 	strb.w	r0, [r6, #118]	; 0x76
		if (c_to_p_phy) {
 10172ee:	d021      	beq.n	1017334 <lp_pu_execute_fsm+0x26c>
			lll->phy_rx = c_to_p_phy;
 10172f0:	f362 0302 	bfi	r3, r2, #0, #3
	return ((old_tx != lll->phy_tx) || (old_rx != lll->phy_rx));
 10172f4:	458e      	cmp	lr, r1
			lll->phy_rx = c_to_p_phy;
 10172f6:	f886 3077 	strb.w	r3, [r6, #119]	; 0x77
	return ((old_tx != lll->phy_tx) || (old_rx != lll->phy_rx));
 10172fa:	d018      	beq.n	101732e <lp_pu_execute_fsm+0x266>
			ctx->data.pu.ntf_dle = pu_update_eff_times(conn, ctx);
 10172fc:	4621      	mov	r1, r4
 10172fe:	4630      	mov	r0, r6
 1017300:	f7ff fd56 	bl	1016db0 <pu_update_eff_times>
 1017304:	4602      	mov	r2, r0
 1017306:	7f63      	ldrb	r3, [r4, #29]
		llcp_rr_set_incompat(conn, INCOMPAT_NO_COLLISION);
 1017308:	2100      	movs	r1, #0
			ctx->data.pu.ntf_dle = pu_update_eff_times(conn, ctx);
 101730a:	f362 0341 	bfi	r3, r2, #1, #1
 101730e:	7763      	strb	r3, [r4, #29]
		llcp_rr_set_incompat(conn, INCOMPAT_NO_COLLISION);
 1017310:	4630      	mov	r0, r6
 1017312:	f003 fbcb 	bl	101aaac <llcp_rr_set_incompat>
		ctx->data.pu.error = BT_HCI_ERR_SUCCESS;
 1017316:	2200      	movs	r2, #0
 1017318:	2301      	movs	r3, #1
 101731a:	77a2      	strb	r2, [r4, #30]
		ctx->data.pu.ntf_pu = (phy_changed || ctx->data.pu.host_initiated);
 101731c:	e75a      	b.n	10171d4 <lp_pu_execute_fsm+0x10c>
		if (c_to_p_phy) {
 101731e:	f012 0203 	ands.w	r2, r2, #3
 1017322:	f43f af4f 	beq.w	10171c4 <lp_pu_execute_fsm+0xfc>
			lll->phy_rx = c_to_p_phy;
 1017326:	f362 0302 	bfi	r3, r2, #0, #3
 101732a:	f886 3077 	strb.w	r3, [r6, #119]	; 0x77
	return ((old_tx != lll->phy_tx) || (old_rx != lll->phy_rx));
 101732e:	4594      	cmp	ip, r2
 1017330:	d1e4      	bne.n	10172fc <lp_pu_execute_fsm+0x234>
 1017332:	e747      	b.n	10171c4 <lp_pu_execute_fsm+0xfc>
 1017334:	458e      	cmp	lr, r1
 1017336:	d1e1      	bne.n	10172fc <lp_pu_execute_fsm+0x234>
 1017338:	e744      	b.n	10171c4 <lp_pu_execute_fsm+0xfc>
 101733a:	bf00      	nop
 101733c:	0102aa8c 	.word	0x0102aa8c
 1017340:	0102a300 	.word	0x0102a300
 1017344:	0102a278 	.word	0x0102a278
 1017348:	0102aad4 	.word	0x0102aad4
 101734c:	01029b48 	.word	0x01029b48

01017350 <llcp_lp_pu_rx>:
	switch (pdu->llctrl.opcode) {
 1017350:	f892 c01f 	ldrb.w	ip, [r2, #31]
	struct pdu_data *pdu = (struct pdu_data *)rx->pdu;
 1017354:	f102 031c 	add.w	r3, r2, #28
	switch (pdu->llctrl.opcode) {
 1017358:	f1bc 0f11 	cmp.w	ip, #17
 101735c:	d00f      	beq.n	101737e <llcp_lp_pu_rx+0x2e>
 101735e:	f1bc 0f18 	cmp.w	ip, #24
 1017362:	d012      	beq.n	101738a <llcp_lp_pu_rx+0x3a>
 1017364:	f1bc 0f07 	cmp.w	ip, #7
 1017368:	d00c      	beq.n	1017384 <llcp_lp_pu_rx+0x34>
		conn->llcp_terminate.reason_final = BT_HCI_ERR_LMP_PDU_NOT_ALLOWED;
 101736a:	2324      	movs	r3, #36	; 0x24
{
 101736c:	b510      	push	{r4, lr}
		conn->llcp_terminate.reason_final = BT_HCI_ERR_LMP_PDU_NOT_ALLOWED;
 101736e:	f880 3148 	strb.w	r3, [r0, #328]	; 0x148
 1017372:	460c      	mov	r4, r1
		llcp_lr_complete(conn);
 1017374:	f002 f89e 	bl	10194b4 <llcp_lr_complete>
		ctx->state = LP_PU_STATE_IDLE;
 1017378:	2300      	movs	r3, #0
 101737a:	72a3      	strb	r3, [r4, #10]
}
 101737c:	bd10      	pop	{r4, pc}
		lp_pu_execute_fsm(conn, ctx, LP_PU_EVT_REJECT, pdu);
 101737e:	2205      	movs	r2, #5
 1017380:	f7ff bea2 	b.w	10170c8 <lp_pu_execute_fsm>
		lp_pu_execute_fsm(conn, ctx, LP_PU_EVT_UNKNOWN, pdu);
 1017384:	2206      	movs	r2, #6
 1017386:	f7ff be9f 	b.w	10170c8 <lp_pu_execute_fsm>
		lp_pu_execute_fsm(conn, ctx, LP_PU_EVT_PHY_UPDATE_IND, pdu);
 101738a:	2202      	movs	r2, #2
 101738c:	f7ff be9c 	b.w	10170c8 <lp_pu_execute_fsm>

01017390 <llcp_lp_pu_init_proc>:
	ctx->state = LP_PU_STATE_IDLE;
 1017390:	2300      	movs	r3, #0
 1017392:	7283      	strb	r3, [r0, #10]
}
 1017394:	4770      	bx	lr
 1017396:	bf00      	nop

01017398 <llcp_lp_pu_run>:
{
 1017398:	4613      	mov	r3, r2
	lp_pu_execute_fsm(conn, ctx, LP_PU_EVT_RUN, param);
 101739a:	2200      	movs	r2, #0
 101739c:	f7ff be94 	b.w	10170c8 <lp_pu_execute_fsm>

010173a0 <llcp_lp_pu_tx_ack>:
{
 10173a0:	4613      	mov	r3, r2
	lp_pu_execute_fsm(conn, ctx, LP_PU_EVT_ACK, param);
 10173a2:	2203      	movs	r2, #3
 10173a4:	f7ff be90 	b.w	10170c8 <lp_pu_execute_fsm>

010173a8 <llcp_lp_pu_tx_ntf>:
	lp_pu_execute_fsm(conn, ctx, LP_PU_EVT_NTF, NULL);
 10173a8:	2300      	movs	r3, #0
 10173aa:	2204      	movs	r2, #4
 10173ac:	f7ff be8c 	b.w	10170c8 <lp_pu_execute_fsm>

010173b0 <rp_pu_tx_ntf>:
{
 10173b0:	b570      	push	{r4, r5, r6, lr}
	uint8_t ntf_count = ctx->data.pu.ntf_pu + NTF_DLE;
 10173b2:	7f4a      	ldrb	r2, [r1, #29]
{
 10173b4:	460c      	mov	r4, r1
	uint8_t ntf_count = ctx->data.pu.ntf_pu + NTF_DLE;
 10173b6:	f3c2 0300 	ubfx	r3, r2, #0, #1
 10173ba:	f3c2 0c40 	ubfx	ip, r2, #1, #1
 10173be:	4463      	add	r3, ip
 10173c0:	b2db      	uxtb	r3, r3
	if ((ntf_count > 1) && !llcp_ntf_alloc_num_available(ntf_count)) {
 10173c2:	2b02      	cmp	r3, #2
{
 10173c4:	4605      	mov	r5, r0
	if ((ntf_count > 1) && !llcp_ntf_alloc_num_available(ntf_count)) {
 10173c6:	d025      	beq.n	1017414 <rp_pu_tx_ntf+0x64>
	if ((ntf_count > 0) && !llcp_ntf_alloc_num_available(ntf_count)) {
 10173c8:	b983      	cbnz	r3, 10173ec <rp_pu_tx_ntf+0x3c>
		if (ctx->data.pu.ntf_pu) {
 10173ca:	07d6      	lsls	r6, r2, #31
 10173cc:	d428      	bmi.n	1017420 <rp_pu_tx_ntf+0x70>
		if (ctx->data.pu.ntf_dle) {
 10173ce:	0793      	lsls	r3, r2, #30
 10173d0:	d502      	bpl.n	10173d8 <rp_pu_tx_ntf+0x28>
			pu_dle_ntf(conn, ctx);
 10173d2:	4628      	mov	r0, r5
 10173d4:	f7ff fda8 	bl	1016f28 <pu_dle_ntf.constprop.0>
	llcp_rr_set_paused_cmd(conn, PROC_NONE);
 10173d8:	2100      	movs	r1, #0
 10173da:	4628      	mov	r0, r5
 10173dc:	f003 fb6a 	bl	101aab4 <llcp_rr_set_paused_cmd>
	llcp_rr_complete(conn);
 10173e0:	4628      	mov	r0, r5
 10173e2:	f003 fbfb 	bl	101abdc <llcp_rr_complete>
}
 10173e6:	2300      	movs	r3, #0
		ctx->state = RP_PU_STATE_WAIT_NTF;
 10173e8:	72a3      	strb	r3, [r4, #10]
}
 10173ea:	bd70      	pop	{r4, r5, r6, pc}
 10173ec:	2601      	movs	r6, #1
	if ((ntf_count > 0) && !llcp_ntf_alloc_num_available(ntf_count)) {
 10173ee:	4630      	mov	r0, r6
 10173f0:	f000 fd6e 	bl	1017ed0 <llcp_ntf_alloc_num_available>
 10173f4:	b158      	cbz	r0, 101740e <rp_pu_tx_ntf+0x5e>
		if (ctx->data.pu.ntf_pu) {
 10173f6:	7f62      	ldrb	r2, [r4, #29]
 10173f8:	07d1      	lsls	r1, r2, #31
 10173fa:	d5e8      	bpl.n	10173ce <rp_pu_tx_ntf+0x1e>
			pu_ntf(conn, ctx);
 10173fc:	4621      	mov	r1, r4
 10173fe:	4628      	mov	r0, r5
 1017400:	f7ff fca2 	bl	1016d48 <pu_ntf>
			if (ntf_count == 1 && NTF_DLE == 1) {
 1017404:	2e01      	cmp	r6, #1
 1017406:	d10f      	bne.n	1017428 <rp_pu_tx_ntf+0x78>
 1017408:	7f63      	ldrb	r3, [r4, #29]
 101740a:	079a      	lsls	r2, r3, #30
 101740c:	d5e4      	bpl.n	10173d8 <rp_pu_tx_ntf+0x28>
		ctx->state = RP_PU_STATE_WAIT_NTF;
 101740e:	2309      	movs	r3, #9
 1017410:	72a3      	strb	r3, [r4, #10]
}
 1017412:	bd70      	pop	{r4, r5, r6, pc}
	if ((ntf_count > 1) && !llcp_ntf_alloc_num_available(ntf_count)) {
 1017414:	4618      	mov	r0, r3
 1017416:	f000 fd5b 	bl	1017ed0 <llcp_ntf_alloc_num_available>
 101741a:	1c46      	adds	r6, r0, #1
 101741c:	b2f6      	uxtb	r6, r6
 101741e:	e7e6      	b.n	10173ee <rp_pu_tx_ntf+0x3e>
			pu_ntf(conn, ctx);
 1017420:	f7ff fc92 	bl	1016d48 <pu_ntf>
		if (ctx->data.pu.ntf_dle) {
 1017424:	7f62      	ldrb	r2, [r4, #29]
 1017426:	e7d2      	b.n	10173ce <rp_pu_tx_ntf+0x1e>
			if (ntf_count == 1 && NTF_DLE == 1) {
 1017428:	7f62      	ldrb	r2, [r4, #29]
 101742a:	e7d0      	b.n	10173ce <rp_pu_tx_ntf+0x1e>

0101742c <rp_pu_execute_fsm>:
		break;
	}
}

static void rp_pu_execute_fsm(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
{
 101742c:	b5f0      	push	{r4, r5, r6, r7, lr}
 101742e:	460c      	mov	r4, r1
	switch (ctx->state) {
 1017430:	7a89      	ldrb	r1, [r1, #10]
{
 1017432:	4606      	mov	r6, r0
 1017434:	4615      	mov	r5, r2
 1017436:	b083      	sub	sp, #12
	switch (ctx->state) {
 1017438:	2909      	cmp	r1, #9
 101743a:	d80b      	bhi.n	1017454 <rp_pu_execute_fsm+0x28>
 101743c:	e8df f001 	tbb	[pc, r1]
 1017440:	19c695d0 	.word	0x19c695d0
 1017444:	5d4a0a0a 	.word	0x5d4a0a0a
 1017448:	058a      	.short	0x058a
	switch (evt) {
 101744a:	2d00      	cmp	r5, #0
 101744c:	f000 8085 	beq.w	101755a <rp_pu_execute_fsm+0x12e>
		break;
	default:
		/* Unknown state */
		LL_ASSERT(0);
	}
}
 1017450:	b003      	add	sp, #12
 1017452:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LL_ASSERT(0);
 1017454:	f44f 639f 	mov.w	r3, #1272	; 0x4f8
 1017458:	4a82      	ldr	r2, [pc, #520]	; (1017664 <rp_pu_execute_fsm+0x238>)
 101745a:	4983      	ldr	r1, [pc, #524]	; (1017668 <rp_pu_execute_fsm+0x23c>)
 101745c:	4883      	ldr	r0, [pc, #524]	; (101766c <rp_pu_execute_fsm+0x240>)
 101745e:	f00d fbba 	bl	1024bd6 <assert_print>
 1017462:	4040      	eors	r0, r0
 1017464:	f380 8811 	msr	BASEPRI, r0
 1017468:	f04f 0003 	mov.w	r0, #3
 101746c:	df02      	svc	2
}
 101746e:	b003      	add	sp, #12
 1017470:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (evt) {
 1017472:	2d02      	cmp	r5, #2
 1017474:	d1ec      	bne.n	1017450 <rp_pu_execute_fsm+0x24>
			LL_ASSERT(conn->lll.role == BT_HCI_ROLE_PERIPHERAL);
 1017476:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
 101747a:	2b00      	cmp	r3, #0
 101747c:	db0c      	blt.n	1017498 <rp_pu_execute_fsm+0x6c>
 101747e:	f240 4349 	movw	r3, #1097	; 0x449
 1017482:	4a78      	ldr	r2, [pc, #480]	; (1017664 <rp_pu_execute_fsm+0x238>)
 1017484:	497a      	ldr	r1, [pc, #488]	; (1017670 <rp_pu_execute_fsm+0x244>)
 1017486:	4879      	ldr	r0, [pc, #484]	; (101766c <rp_pu_execute_fsm+0x240>)
 1017488:	f00d fba5 	bl	1024bd6 <assert_print>
 101748c:	4040      	eors	r0, r0
 101748e:	f380 8811 	msr	BASEPRI, r0
 1017492:	f04f 0003 	mov.w	r0, #3
 1017496:	df02      	svc	2
	uint8_t phy_tx_time[8] = { 0,	      PHY_1M,	 PHY_2M,    PHY_1M,
 1017498:	4b76      	ldr	r3, [pc, #472]	; (1017674 <rp_pu_execute_fsm+0x248>)
				conn, pu_select_phy_timing_restrict(conn, ctx->data.pu.tx));
 101749a:	7f25      	ldrb	r5, [r4, #28]
	uint8_t phy_tx_time[8] = { 0,	      PHY_1M,	 PHY_2M,    PHY_1M,
 101749c:	e893 0003 	ldmia.w	r3, {r0, r1}
 10174a0:	ab02      	add	r3, sp, #8
 10174a2:	e903 0003 	stmdb	r3, {r0, r1}
	const uint8_t phys = phy_tx | lll->phy_tx;
 10174a6:	f896 3076 	ldrb.w	r3, [r6, #118]	; 0x76
		llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_PHY_UPDATE);
 10174aa:	2102      	movs	r1, #2
	lll->phy_tx_time = phy_tx;
 10174ac:	461a      	mov	r2, r3
	return phy_tx_time[phys];
 10174ae:	432b      	orrs	r3, r5
 10174b0:	f003 0307 	and.w	r3, r3, #7
 10174b4:	3308      	adds	r3, #8
 10174b6:	446b      	add	r3, sp
 10174b8:	f813 5c08 	ldrb.w	r5, [r3, #-8]
		llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_PHY_UPDATE);
 10174bc:	4630      	mov	r0, r6
			ctx->state = RP_PU_STATE_WAIT_RX_PHY_UPDATE_IND;
 10174be:	2306      	movs	r3, #6
	lll->phy_tx_time = phy_tx;
 10174c0:	f365 1206 	bfi	r2, r5, #4, #3
 10174c4:	f886 2076 	strb.w	r2, [r6, #118]	; 0x76
			ctx->state = RP_PU_STATE_WAIT_RX_PHY_UPDATE_IND;
 10174c8:	72a3      	strb	r3, [r4, #10]
}
 10174ca:	b003      	add	sp, #12
 10174cc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_PHY_UPDATE);
 10174d0:	f000 bd20 	b.w	1017f14 <llcp_tx_resume_data>
	switch (evt) {
 10174d4:	2d03      	cmp	r5, #3
 10174d6:	d1bb      	bne.n	1017450 <rp_pu_execute_fsm+0x24>
		llcp_pdu_decode_phy_update_ind(ctx, (struct pdu_data *)param);
 10174d8:	4619      	mov	r1, r3
 10174da:	4620      	mov	r0, r4
 10174dc:	f002 fa1e 	bl	101991c <llcp_pdu_decode_phy_update_ind>
		const uint8_t end_procedure = pu_check_update_ind(conn, ctx);
 10174e0:	4621      	mov	r1, r4
 10174e2:	4630      	mov	r0, r6
 10174e4:	f7ff fc04 	bl	1016cf0 <pu_check_update_ind>
		if (!end_procedure) {
 10174e8:	2800      	cmp	r0, #0
 10174ea:	f000 808c 	beq.w	1017606 <rp_pu_execute_fsm+0x1da>
			if (ctx->data.pu.error == BT_HCI_ERR_INSTANT_PASSED) {
 10174ee:	7fa3      	ldrb	r3, [r4, #30]
 10174f0:	2b28      	cmp	r3, #40	; 0x28
				conn->llcp_terminate.reason_final = BT_HCI_ERR_INSTANT_PASSED;
 10174f2:	bf08      	it	eq
 10174f4:	f886 3148 	strbeq.w	r3, [r6, #328]	; 0x148
 10174f8:	e01d      	b.n	1017536 <rp_pu_execute_fsm+0x10a>
	switch (evt) {
 10174fa:	2d00      	cmp	r5, #0
 10174fc:	d1a8      	bne.n	1017450 <rp_pu_execute_fsm+0x24>
	if (is_instant_reached_or_passed(ctx->data.pu.instant, ull_conn_event_counter(conn))) {
 10174fe:	8c27      	ldrh	r7, [r4, #32]
 1017500:	f7ff fa6a 	bl	10169d8 <ull_conn_event_counter>
 1017504:	1bc0      	subs	r0, r0, r7
 1017506:	0403      	lsls	r3, r0, #16
 1017508:	d4a2      	bmi.n	1017450 <rp_pu_execute_fsm+0x24>
		ctx->data.pu.error = BT_HCI_ERR_SUCCESS;
 101750a:	77a5      	strb	r5, [r4, #30]
	} else if (lll->role == BT_HCI_ROLE_PERIPHERAL) {
 101750c:	f996 5039 	ldrsb.w	r5, [r6, #57]	; 0x39
	const uint8_t old_tx = lll->phy_tx;
 1017510:	f896 0076 	ldrb.w	r0, [r6, #118]	; 0x76
	const uint8_t old_rx = lll->phy_rx;
 1017514:	f896 3077 	ldrb.w	r3, [r6, #119]	; 0x77
	} else if (lll->role == BT_HCI_ROLE_PERIPHERAL) {
 1017518:	2d00      	cmp	r5, #0
 101751a:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
 101751e:	f894 1023 	ldrb.w	r1, [r4, #35]	; 0x23
	const uint8_t old_tx = lll->phy_tx;
 1017522:	f000 0c07 	and.w	ip, r0, #7
	const uint8_t old_rx = lll->phy_rx;
 1017526:	f003 0707 	and.w	r7, r3, #7
	} else if (lll->role == BT_HCI_ROLE_PERIPHERAL) {
 101752a:	db72      	blt.n	1017612 <rp_pu_execute_fsm+0x1e6>
{
 101752c:	2200      	movs	r2, #0
		ctx->data.pu.ntf_pu = phy_changed;
 101752e:	7f63      	ldrb	r3, [r4, #29]
 1017530:	f362 0300 	bfi	r3, r2, #0, #1
 1017534:	7763      	strb	r3, [r4, #29]
	pu_set_timing_restrict(conn, conn->lll.phy_tx);
 1017536:	f896 3076 	ldrb.w	r3, [r6, #118]	; 0x76
	lll->phy_tx_time = phy_tx;
 101753a:	461a      	mov	r2, r3
	pu_set_timing_restrict(conn, conn->lll.phy_tx);
 101753c:	f3c3 0302 	ubfx	r3, r3, #0, #3
	lll->phy_tx_time = phy_tx;
 1017540:	f363 1206 	bfi	r2, r3, #4, #3
 1017544:	f886 2076 	strb.w	r2, [r6, #118]	; 0x76
	if (ctx->data.pu.ntf_pu) {
 1017548:	7f63      	ldrb	r3, [r4, #29]
 101754a:	07da      	lsls	r2, r3, #31
 101754c:	d551      	bpl.n	10175f2 <rp_pu_execute_fsm+0x1c6>
		ctx->state = RP_PU_STATE_WAIT_INSTANT_ON_AIR;
 101754e:	2308      	movs	r3, #8
 1017550:	72a3      	strb	r3, [r4, #10]
 1017552:	e77d      	b.n	1017450 <rp_pu_execute_fsm+0x24>
	switch (evt) {
 1017554:	2d04      	cmp	r5, #4
 1017556:	f47f af7b 	bne.w	1017450 <rp_pu_execute_fsm+0x24>
		rp_pu_tx_ntf(conn, ctx, evt, param);
 101755a:	462a      	mov	r2, r5
 101755c:	4621      	mov	r1, r4
 101755e:	4630      	mov	r0, r6
}
 1017560:	b003      	add	sp, #12
 1017562:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		rp_pu_tx_ntf(conn, ctx, evt, param);
 1017566:	f7ff bf23 	b.w	10173b0 <rp_pu_tx_ntf>
	llcp_pdu_decode_phy_req(ctx, (struct pdu_data *)param);
 101756a:	4619      	mov	r1, r3
 101756c:	4620      	mov	r0, r4
 101756e:	f002 f9b3 	bl	10198d8 <llcp_pdu_decode_phy_req>
	ctx->data.pu.rx &= rx;
 1017572:	7f22      	ldrb	r2, [r4, #28]
	pu_combine_phys(conn, ctx, conn->phy_pref_tx, conn->phy_pref_rx);
 1017574:	f896 318c 	ldrb.w	r3, [r6, #396]	; 0x18c
	ctx->data.pu.rx &= rx;
 1017578:	f3c2 00c2 	ubfx	r0, r2, #3, #3
	pu_combine_phys(conn, ctx, conn->phy_pref_tx, conn->phy_pref_rx);
 101757c:	f3c3 01c2 	ubfx	r1, r3, #3, #3
	ctx->data.pu.tx &= tx;
 1017580:	4001      	ands	r1, r0
	pu_combine_phys(conn, ctx, conn->phy_pref_tx, conn->phy_pref_rx);
 1017582:	f3c3 0302 	ubfx	r3, r3, #0, #3
	ctx->data.pu.tx &= tx;
 1017586:	f3c2 0002 	ubfx	r0, r2, #0, #3
 101758a:	4003      	ands	r3, r0
 101758c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 1017590:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 1017594:	4313      	orrs	r3, r2
 1017596:	7723      	strb	r3, [r4, #28]
	if (conn->lll.role == BT_HCI_ROLE_CENTRAL && (!ctx->data.pu.rx || !ctx->data.pu.tx)) {
 1017598:	f996 3039 	ldrsb.w	r3, [r6, #57]	; 0x39
 101759c:	2b00      	cmp	r3, #0
 101759e:	db07      	blt.n	10175b0 <rp_pu_execute_fsm+0x184>
 10175a0:	7f23      	ldrb	r3, [r4, #28]
 10175a2:	f013 0f38 	tst.w	r3, #56	; 0x38
 10175a6:	d121      	bne.n	10175ec <rp_pu_execute_fsm+0x1c0>
		ctx->data.pu.tx = 0;
 10175a8:	7f23      	ldrb	r3, [r4, #28]
 10175aa:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 10175ae:	7723      	strb	r3, [r4, #28]
	llcp_tx_pause_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_PHY_UPDATE);
 10175b0:	2102      	movs	r1, #2
 10175b2:	4630      	mov	r0, r6
 10175b4:	f000 fc9a 	bl	1017eec <llcp_tx_pause_data>
	switch (evt) {
 10175b8:	2d01      	cmp	r5, #1
 10175ba:	f47f af49 	bne.w	1017450 <rp_pu_execute_fsm+0x24>
		switch (conn->lll.role) {
 10175be:	f896 3039 	ldrb.w	r3, [r6, #57]	; 0x39
 10175c2:	09db      	lsrs	r3, r3, #7
 10175c4:	d105      	bne.n	10175d2 <rp_pu_execute_fsm+0x1a6>
			LL_ASSERT(0);
 10175c6:	f240 4329 	movw	r3, #1065	; 0x429
 10175ca:	e745      	b.n	1017458 <rp_pu_execute_fsm+0x2c>
	switch (evt) {
 10175cc:	2d00      	cmp	r5, #0
 10175ce:	f47f af3f 	bne.w	1017450 <rp_pu_execute_fsm+0x24>
			rp_pu_send_phy_rsp(conn, ctx, evt, param);
 10175d2:	4621      	mov	r1, r4
 10175d4:	4630      	mov	r0, r6
}
 10175d6:	b003      	add	sp, #12
 10175d8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			rp_pu_send_phy_rsp(conn, ctx, evt, param);
 10175dc:	f7ff bc60 	b.w	1016ea0 <rp_pu_send_phy_rsp.constprop.0>
	switch (evt) {
 10175e0:	2d00      	cmp	r5, #0
 10175e2:	f47f af35 	bne.w	1017450 <rp_pu_execute_fsm+0x24>
		ctx->state = RP_PU_STATE_WAIT_RX_PHY_REQ;
 10175e6:	2301      	movs	r3, #1
 10175e8:	72a3      	strb	r3, [r4, #10]
		break;
 10175ea:	e731      	b.n	1017450 <rp_pu_execute_fsm+0x24>
	if (conn->lll.role == BT_HCI_ROLE_CENTRAL && (!ctx->data.pu.rx || !ctx->data.pu.tx)) {
 10175ec:	0759      	lsls	r1, r3, #29
 10175ee:	d1df      	bne.n	10175b0 <rp_pu_execute_fsm+0x184>
 10175f0:	e7da      	b.n	10175a8 <rp_pu_execute_fsm+0x17c>
	llcp_rr_set_paused_cmd(conn, PROC_NONE);
 10175f2:	2100      	movs	r1, #0
 10175f4:	4630      	mov	r0, r6
 10175f6:	f003 fa5d 	bl	101aab4 <llcp_rr_set_paused_cmd>
	llcp_rr_complete(conn);
 10175fa:	4630      	mov	r0, r6
 10175fc:	f003 faee 	bl	101abdc <llcp_rr_complete>
	ctx->state = RP_PU_STATE_IDLE;
 1017600:	2300      	movs	r3, #0
 1017602:	72a3      	strb	r3, [r4, #10]
}
 1017604:	e724      	b.n	1017450 <rp_pu_execute_fsm+0x24>
			llcp_rr_prt_stop(conn);
 1017606:	4630      	mov	r0, r6
 1017608:	f003 fa70 	bl	101aaec <llcp_rr_prt_stop>
			ctx->state = RP_PU_STATE_WAIT_INSTANT;
 101760c:	2307      	movs	r3, #7
 101760e:	72a3      	strb	r3, [r4, #10]
 1017610:	e71e      	b.n	1017450 <rp_pu_execute_fsm+0x24>
		if (p_to_c_phy) {
 1017612:	f011 0103 	ands.w	r1, r1, #3
 1017616:	d016      	beq.n	1017646 <rp_pu_execute_fsm+0x21a>
			lll->phy_tx = p_to_c_phy;
 1017618:	f361 0002 	bfi	r0, r1, #0, #3
		if (c_to_p_phy) {
 101761c:	f012 0203 	ands.w	r2, r2, #3
			lll->phy_tx = p_to_c_phy;
 1017620:	f886 0076 	strb.w	r0, [r6, #118]	; 0x76
		if (c_to_p_phy) {
 1017624:	d01a      	beq.n	101765c <rp_pu_execute_fsm+0x230>
			lll->phy_rx = c_to_p_phy;
 1017626:	f362 0302 	bfi	r3, r2, #0, #3
	return ((old_tx != lll->phy_tx) || (old_rx != lll->phy_rx));
 101762a:	458c      	cmp	ip, r1
			lll->phy_rx = c_to_p_phy;
 101762c:	f886 3077 	strb.w	r3, [r6, #119]	; 0x77
	return ((old_tx != lll->phy_tx) || (old_rx != lll->phy_rx));
 1017630:	d011      	beq.n	1017656 <rp_pu_execute_fsm+0x22a>
			ctx->data.pu.ntf_dle = pu_update_eff_times(conn, ctx);
 1017632:	4621      	mov	r1, r4
 1017634:	4630      	mov	r0, r6
 1017636:	f7ff fbbb 	bl	1016db0 <pu_update_eff_times>
 101763a:	7f63      	ldrb	r3, [r4, #29]
 101763c:	2201      	movs	r2, #1
 101763e:	f360 0341 	bfi	r3, r0, #1, #1
 1017642:	7763      	strb	r3, [r4, #29]
 1017644:	e773      	b.n	101752e <rp_pu_execute_fsm+0x102>
		if (c_to_p_phy) {
 1017646:	f012 0203 	ands.w	r2, r2, #3
 101764a:	f43f af6f 	beq.w	101752c <rp_pu_execute_fsm+0x100>
			lll->phy_rx = c_to_p_phy;
 101764e:	f362 0302 	bfi	r3, r2, #0, #3
 1017652:	f886 3077 	strb.w	r3, [r6, #119]	; 0x77
	return ((old_tx != lll->phy_tx) || (old_rx != lll->phy_rx));
 1017656:	4297      	cmp	r7, r2
 1017658:	d1eb      	bne.n	1017632 <rp_pu_execute_fsm+0x206>
 101765a:	e767      	b.n	101752c <rp_pu_execute_fsm+0x100>
 101765c:	458c      	cmp	ip, r1
 101765e:	d1e8      	bne.n	1017632 <rp_pu_execute_fsm+0x206>
 1017660:	e764      	b.n	101752c <rp_pu_execute_fsm+0x100>
 1017662:	bf00      	nop
 1017664:	0102aa8c 	.word	0x0102aa8c
 1017668:	0102a300 	.word	0x0102a300
 101766c:	0102a278 	.word	0x0102a278
 1017670:	0102aad4 	.word	0x0102aad4
 1017674:	01029b48 	.word	0x01029b48

01017678 <llcp_rp_pu_rx>:

void llcp_rp_pu_rx(struct ll_conn *conn, struct proc_ctx *ctx, struct node_rx_pdu *rx)
{
 1017678:	b510      	push	{r4, lr}
	struct pdu_data *pdu = (struct pdu_data *)rx->pdu;

	switch (pdu->llctrl.opcode) {
 101767a:	f892 e01f 	ldrb.w	lr, [r2, #31]
	struct pdu_data *pdu = (struct pdu_data *)rx->pdu;
 101767e:	f102 031c 	add.w	r3, r2, #28
	switch (pdu->llctrl.opcode) {
 1017682:	f1be 0f16 	cmp.w	lr, #22
 1017686:	d00b      	beq.n	10176a0 <llcp_rp_pu_rx+0x28>
 1017688:	f1be 0f18 	cmp.w	lr, #24
 101768c:	d00d      	beq.n	10176aa <llcp_rp_pu_rx+0x32>
		break;
#endif /* CONFIG_BT_PERIPHERAL */
	default:
		/* Invalid behaviour */
		/* Invalid PDU received so terminate connection */
		conn->llcp_terminate.reason_final = BT_HCI_ERR_LMP_PDU_NOT_ALLOWED;
 101768e:	2324      	movs	r3, #36	; 0x24
 1017690:	f880 3148 	strb.w	r3, [r0, #328]	; 0x148
 1017694:	460c      	mov	r4, r1
		llcp_rr_complete(conn);
 1017696:	f003 faa1 	bl	101abdc <llcp_rr_complete>
		ctx->state = RP_PU_STATE_IDLE;
 101769a:	2300      	movs	r3, #0
 101769c:	72a3      	strb	r3, [r4, #10]
		break;
	}
}
 101769e:	bd10      	pop	{r4, pc}
		rp_pu_execute_fsm(conn, ctx, RP_PU_EVT_PHY_REQ, pdu);
 10176a0:	2201      	movs	r2, #1
}
 10176a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		rp_pu_execute_fsm(conn, ctx, RP_PU_EVT_PHY_REQ, pdu);
 10176a6:	f7ff bec1 	b.w	101742c <rp_pu_execute_fsm>
		rp_pu_execute_fsm(conn, ctx, RP_PU_EVT_PHY_UPDATE_IND, pdu);
 10176aa:	2203      	movs	r2, #3
}
 10176ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		rp_pu_execute_fsm(conn, ctx, RP_PU_EVT_PHY_UPDATE_IND, pdu);
 10176b0:	f7ff bebc 	b.w	101742c <rp_pu_execute_fsm>

010176b4 <llcp_rp_pu_init_proc>:

void llcp_rp_pu_init_proc(struct proc_ctx *ctx)
 10176b4:	2300      	movs	r3, #0
 10176b6:	7283      	strb	r3, [r0, #10]
 10176b8:	4770      	bx	lr
 10176ba:	bf00      	nop

010176bc <llcp_rp_pu_run>:
{
	ctx->state = RP_PU_STATE_IDLE;
}

void llcp_rp_pu_run(struct ll_conn *conn, struct proc_ctx *ctx, void *param)
{
 10176bc:	4613      	mov	r3, r2
	rp_pu_execute_fsm(conn, ctx, RP_PU_EVT_RUN, param);
 10176be:	2200      	movs	r2, #0
 10176c0:	f7ff beb4 	b.w	101742c <rp_pu_execute_fsm>

010176c4 <llcp_rp_pu_tx_ack>:
}

void llcp_rp_pu_tx_ack(struct ll_conn *conn, struct proc_ctx *ctx, void *param)
{
 10176c4:	4613      	mov	r3, r2
	rp_pu_execute_fsm(conn, ctx, RP_PU_EVT_ACK, param);
 10176c6:	2202      	movs	r2, #2
 10176c8:	f7ff beb0 	b.w	101742c <rp_pu_execute_fsm>

010176cc <llcp_rp_pu_tx_ntf>:
}

void llcp_rp_pu_tx_ntf(struct ll_conn *conn, struct proc_ctx *ctx)
{
	rp_pu_execute_fsm(conn, ctx, RP_PU_EVT_NTF, NULL);
 10176cc:	2300      	movs	r3, #0
 10176ce:	2204      	movs	r2, #4
 10176d0:	f7ff beac 	b.w	101742c <rp_pu_execute_fsm>

010176d4 <llcp_rp_enc_tx>:
/*
 * LLCP Remote Procedure Encryption FSM
 */

static struct node_tx *llcp_rp_enc_tx(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t opcode)
{
 10176d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10176d6:	4606      	mov	r6, r0
 10176d8:	460f      	mov	r7, r1
 10176da:	4615      	mov	r5, r2
	struct node_tx *tx;
	struct pdu_data *pdu;

	/* Allocate tx node */
	tx = llcp_tx_alloc(conn, ctx);
 10176dc:	f000 fbe4 	bl	1017ea8 <llcp_tx_alloc>
	LL_ASSERT(tx);
 10176e0:	4604      	mov	r4, r0
 10176e2:	2800      	cmp	r0, #0
 10176e4:	d039      	beq.n	101775a <llcp_rp_enc_tx+0x86>

	pdu = (struct pdu_data *)tx->pdu;

	/* Encode LL Control PDU */
	switch (opcode) {
 10176e6:	1f2a      	subs	r2, r5, #4
	pdu = (struct pdu_data *)tx->pdu;
 10176e8:	1d20      	adds	r0, r4, #4
	switch (opcode) {
 10176ea:	2a09      	cmp	r2, #9
 10176ec:	d806      	bhi.n	10176fc <llcp_rp_enc_tx+0x28>
 10176ee:	e8df f002 	tbb	[pc, r2]
 10176f2:	201d      	.short	0x201d
 10176f4:	05050523 	.word	0x05050523
 10176f8:	29052605 	.word	0x29052605
		} else {
			llcp_pdu_encode_reject_ind(pdu, BT_HCI_ERR_PIN_OR_KEY_MISSING);
		}
		break;
	default:
		LL_ASSERT(0);
 10176fc:	f240 23e1 	movw	r3, #737	; 0x2e1
 1017700:	4a1f      	ldr	r2, [pc, #124]	; (1017780 <llcp_rp_enc_tx+0xac>)
 1017702:	4920      	ldr	r1, [pc, #128]	; (1017784 <llcp_rp_enc_tx+0xb0>)
 1017704:	4820      	ldr	r0, [pc, #128]	; (1017788 <llcp_rp_enc_tx+0xb4>)
 1017706:	f00d fa66 	bl	1024bd6 <assert_print>
 101770a:	4040      	eors	r0, r0
 101770c:	f380 8811 	msr	BASEPRI, r0
 1017710:	f04f 0003 	mov.w	r0, #3
 1017714:	df02      	svc	2
	}

	ctx->tx_opcode = pdu->llctrl.opcode;
 1017716:	79e3      	ldrb	r3, [r4, #7]

	/* Enqueue LL Control PDU towards LLL */
	llcp_tx_enqueue(conn, tx);
 1017718:	4621      	mov	r1, r4
 101771a:	4630      	mov	r0, r6
	ctx->tx_opcode = pdu->llctrl.opcode;
 101771c:	737b      	strb	r3, [r7, #13]
	llcp_tx_enqueue(conn, tx);
 101771e:	f000 fbe1 	bl	1017ee4 <llcp_tx_enqueue>

	/* Restart procedure response timeout timer */
	llcp_rr_prt_restart(conn);
 1017722:	4630      	mov	r0, r6
 1017724:	f003 f9dc 	bl	101aae0 <llcp_rr_prt_restart>

	return tx;
}
 1017728:	4620      	mov	r0, r4
 101772a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		llcp_pdu_encode_enc_rsp(pdu);
 101772c:	f002 f864 	bl	10197f8 <llcp_pdu_encode_enc_rsp>
		break;
 1017730:	e7f1      	b.n	1017716 <llcp_rp_enc_tx+0x42>
		llcp_pdu_encode_start_enc_req(pdu);
 1017732:	f002 f879 	bl	1019828 <llcp_pdu_encode_start_enc_req>
		break;
 1017736:	e7ee      	b.n	1017716 <llcp_rp_enc_tx+0x42>
		llcp_pdu_encode_start_enc_rsp(pdu);
 1017738:	f002 f880 	bl	101983c <llcp_pdu_encode_start_enc_rsp>
		break;
 101773c:	e7eb      	b.n	1017716 <llcp_rp_enc_tx+0x42>
		llcp_pdu_encode_pause_enc_rsp(pdu);
 101773e:	f002 f887 	bl	1019850 <llcp_pdu_encode_pause_enc_rsp>
		break;
 1017742:	e7e8      	b.n	1017716 <llcp_rp_enc_tx+0x42>
		if (conn->llcp.fex.valid && feature_ext_rej_ind(conn)) {
 1017744:	f896 3121 	ldrb.w	r3, [r6, #289]	; 0x121
 1017748:	b11b      	cbz	r3, 1017752 <llcp_rp_enc_tx+0x7e>
	return (conn->llcp.fex.features_used & LL_FEAT_BIT_EXT_REJ_IND) != 0;
 101774a:	f8d6 3130 	ldr.w	r3, [r6, #304]	; 0x130
 101774e:	075b      	lsls	r3, r3, #29
 1017750:	d411      	bmi.n	1017776 <llcp_rp_enc_tx+0xa2>
			llcp_pdu_encode_reject_ind(pdu, BT_HCI_ERR_PIN_OR_KEY_MISSING);
 1017752:	2106      	movs	r1, #6
 1017754:	f002 f886 	bl	1019864 <llcp_pdu_encode_reject_ind>
 1017758:	e7dd      	b.n	1017716 <llcp_rp_enc_tx+0x42>
	LL_ASSERT(tx);
 101775a:	f240 23c6 	movw	r3, #710	; 0x2c6
 101775e:	4a08      	ldr	r2, [pc, #32]	; (1017780 <llcp_rp_enc_tx+0xac>)
 1017760:	490a      	ldr	r1, [pc, #40]	; (101778c <llcp_rp_enc_tx+0xb8>)
 1017762:	4809      	ldr	r0, [pc, #36]	; (1017788 <llcp_rp_enc_tx+0xb4>)
 1017764:	f00d fa37 	bl	1024bd6 <assert_print>
 1017768:	4040      	eors	r0, r0
 101776a:	f380 8811 	msr	BASEPRI, r0
 101776e:	f04f 0003 	mov.w	r0, #3
 1017772:	df02      	svc	2
 1017774:	e7b7      	b.n	10176e6 <llcp_rp_enc_tx+0x12>
			llcp_pdu_encode_reject_ext_ind(pdu, PDU_DATA_LLCTRL_TYPE_ENC_REQ,
 1017776:	2206      	movs	r2, #6
 1017778:	2103      	movs	r1, #3
 101777a:	f002 f87f 	bl	101987c <llcp_pdu_encode_reject_ext_ind>
 101777e:	e7ca      	b.n	1017716 <llcp_rp_enc_tx+0x42>
 1017780:	0102aaec 	.word	0x0102aaec
 1017784:	0102a300 	.word	0x0102a300
 1017788:	0102a278 	.word	0x0102a278
 101778c:	0102a920 	.word	0x0102a920

01017790 <rp_enc_ntf_ltk>:

static void rp_enc_ntf_ltk(struct ll_conn *conn, struct proc_ctx *ctx)
{
 1017790:	b570      	push	{r4, r5, r6, lr}
 1017792:	4605      	mov	r5, r0
 1017794:	460e      	mov	r6, r1
	struct node_rx_pdu *ntf;
	struct pdu_data *pdu;

	/* Allocate ntf node */
	ntf = llcp_ntf_alloc();
 1017796:	f000 fba3 	bl	1017ee0 <llcp_ntf_alloc>
	LL_ASSERT(ntf);
 101779a:	4604      	mov	r4, r0
 101779c:	b170      	cbz	r0, 10177bc <rp_enc_ntf_ltk+0x2c>

	ntf->hdr.type = NODE_RX_TYPE_DC_PDU;
 101779e:	2303      	movs	r3, #3
 10177a0:	7123      	strb	r3, [r4, #4]
	ntf->hdr.handle = conn->lll.handle;
 10177a2:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
	pdu = (struct pdu_data *)ntf->pdu;

	llcp_ntf_encode_enc_req(ctx, pdu);
 10177a4:	4630      	mov	r0, r6
 10177a6:	f104 011c 	add.w	r1, r4, #28
	ntf->hdr.handle = conn->lll.handle;
 10177aa:	80e3      	strh	r3, [r4, #6]
	llcp_ntf_encode_enc_req(ctx, pdu);
 10177ac:	f002 f808 	bl	10197c0 <llcp_ntf_encode_enc_req>

	/* Enqueue notification towards LL */
	ll_rx_put_sched(ntf->hdr.link, ntf);
 10177b0:	4621      	mov	r1, r4
 10177b2:	6820      	ldr	r0, [r4, #0]
}
 10177b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ll_rx_put_sched(ntf->hdr.link, ntf);
 10177b8:	f7fc bd90 	b.w	10142dc <ll_rx_put_sched>
	LL_ASSERT(ntf);
 10177bc:	f240 23f6 	movw	r3, #758	; 0x2f6
 10177c0:	4a05      	ldr	r2, [pc, #20]	; (10177d8 <rp_enc_ntf_ltk+0x48>)
 10177c2:	4906      	ldr	r1, [pc, #24]	; (10177dc <rp_enc_ntf_ltk+0x4c>)
 10177c4:	4806      	ldr	r0, [pc, #24]	; (10177e0 <rp_enc_ntf_ltk+0x50>)
 10177c6:	f00d fa06 	bl	1024bd6 <assert_print>
 10177ca:	4040      	eors	r0, r0
 10177cc:	f380 8811 	msr	BASEPRI, r0
 10177d0:	f04f 0003 	mov.w	r0, #3
 10177d4:	df02      	svc	2
 10177d6:	e7e2      	b.n	101779e <rp_enc_ntf_ltk+0xe>
 10177d8:	0102aaec 	.word	0x0102aaec
 10177dc:	0102aad0 	.word	0x0102aad0
 10177e0:	0102a278 	.word	0x0102a278

010177e4 <rp_enc_send_start_enc_req.part.0>:
		rp_enc_store_s(conn, ctx, (struct pdu_data *)tx->pdu);
		rp_enc_send_ltk_ntf(conn, ctx, evt, param);
	}
}

static void rp_enc_send_start_enc_req(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt,
 10177e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10177e6:	460d      	mov	r5, r1
 10177e8:	4604      	mov	r4, r0
	ecb_encrypt(&ctx->data.enc.ltk[0], &ctx->data.enc.skd[0], NULL, &conn->lll.ccm_rx.key[0]);
 10177ea:	f100 068f 	add.w	r6, r0, #143	; 0x8f
 10177ee:	4633      	mov	r3, r6
 10177f0:	2200      	movs	r2, #0
 10177f2:	3137      	adds	r1, #55	; 0x37
 10177f4:	f105 0027 	add.w	r0, r5, #39	; 0x27
 10177f8:	f005 fc64 	bl	101d0c4 <ecb_encrypt>
	memcpy(&conn->lll.ccm_tx.key[0], &conn->lll.ccm_rx.key[0], sizeof(conn->lll.ccm_tx.key));
 10177fc:	4631      	mov	r1, r6
 10177fe:	2210      	movs	r2, #16
 1017800:	f104 00b0 	add.w	r0, r4, #176	; 0xb0
 1017804:	f00f f8b6 	bl	1026974 <memcpy>
	memcpy(&conn->lll.ccm_tx.iv[0], &conn->lll.ccm_rx.iv[0], sizeof(conn->lll.ccm_tx.iv));
 1017808:	2208      	movs	r2, #8
 101780a:	f104 01a8 	add.w	r1, r4, #168	; 0xa8
 101780e:	f104 00c9 	add.w	r0, r4, #201	; 0xc9
 1017812:	f00f f8af 	bl	1026974 <memcpy>
	conn->lll.ccm_rx.counter = 0U;
 1017816:	2300      	movs	r3, #0
	conn->lll.ccm_tx.counter = 0U;
 1017818:	2600      	movs	r6, #0
 101781a:	2700      	movs	r7, #0
		conn->lll.ccm_tx.direction = 0U;
 101781c:	f894 c0c8 	ldrb.w	ip, [r4, #200]	; 0xc8
	conn->lll.ccm_rx.counter = 0U;
 1017820:	f884 309f 	strb.w	r3, [r4, #159]	; 0x9f
		conn->lll.ccm_tx.direction = 0U;
 1017824:	f363 0c00 	bfi	ip, r3, #0, #1
	conn->lll.ccm_rx.counter = 0U;
 1017828:	f884 30a0 	strb.w	r3, [r4, #160]	; 0xa0
 101782c:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
 1017830:	f884 30a2 	strb.w	r3, [r4, #162]	; 0xa2
 1017834:	f884 30a3 	strb.w	r3, [r4, #163]	; 0xa3
 1017838:	f884 30a4 	strb.w	r3, [r4, #164]	; 0xa4
 101783c:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5
 1017840:	f884 30a6 	strb.w	r3, [r4, #166]	; 0xa6
		conn->lll.ccm_rx.direction = 1U;
 1017844:	f894 30a7 	ldrb.w	r3, [r4, #167]	; 0xa7
{
	if (!llcp_tx_alloc_peek(conn, ctx)) {
		ctx->state = RP_ENC_STATE_WAIT_TX_START_ENC_REQ;
	} else {
		enc_setup_lll(conn, ctx, BT_HCI_ROLE_PERIPHERAL);
		llcp_rp_enc_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_START_ENC_REQ);
 1017848:	2205      	movs	r2, #5
		conn->lll.ccm_rx.direction = 1U;
 101784a:	f043 0301 	orr.w	r3, r3, #1
 101784e:	f884 30a7 	strb.w	r3, [r4, #167]	; 0xa7
		llcp_rp_enc_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_START_ENC_REQ);
 1017852:	4629      	mov	r1, r5
 1017854:	4620      	mov	r0, r4
	conn->lll.ccm_tx.counter = 0U;
 1017856:	e9c4 6730 	strd	r6, r7, [r4, #192]	; 0xc0
		conn->lll.ccm_tx.direction = 0U;
 101785a:	f884 c0c8 	strb.w	ip, [r4, #200]	; 0xc8
		llcp_rp_enc_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_START_ENC_REQ);
 101785e:	f7ff ff39 	bl	10176d4 <llcp_rp_enc_tx>
		/* Wait for the LL_START_ENC_RSP */
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
		ctx->state = RP_ENC_STATE_WAIT_RX_START_ENC_RSP;
 1017862:	f240 6307 	movw	r3, #1543	; 0x607
 1017866:	816b      	strh	r3, [r5, #10]

		/* Rx Decryption enabled */
		conn->lll.enc_rx = 1U;
 1017868:	f894 308e 	ldrb.w	r3, [r4, #142]	; 0x8e
 101786c:	f043 0308 	orr.w	r3, r3, #8
 1017870:	f884 308e 	strb.w	r3, [r4, #142]	; 0x8e
	}
}
 1017874:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1017876:	bf00      	nop

01017878 <rp_enc_send_enc_rsp.part.0.isra.0>:
static void rp_enc_send_enc_rsp(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt,
 1017878:	b570      	push	{r4, r5, r6, lr}
		tx = llcp_rp_enc_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_ENC_RSP);
 101787a:	2204      	movs	r2, #4
static void rp_enc_send_enc_rsp(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt,
 101787c:	460c      	mov	r4, r1
 101787e:	4606      	mov	r6, r0
		tx = llcp_rp_enc_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_ENC_RSP);
 1017880:	f7ff ff28 	bl	10176d4 <llcp_rp_enc_tx>
	memcpy(&ctx->data.enc.skds, pdu->llctrl.enc_rsp.skds, sizeof(pdu->llctrl.enc_rsp.skds));
 1017884:	2208      	movs	r2, #8
		tx = llcp_rp_enc_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_ENC_RSP);
 1017886:	4605      	mov	r5, r0
	memcpy(&ctx->data.enc.skds, pdu->llctrl.enc_rsp.skds, sizeof(pdu->llctrl.enc_rsp.skds));
 1017888:	f104 003f 	add.w	r0, r4, #63	; 0x3f
 101788c:	18a9      	adds	r1, r5, r2
 101788e:	f00f f871 	bl	1026974 <memcpy>
	memcpy(&conn->lll.ccm_rx.iv[4], pdu->llctrl.enc_rsp.ivs, sizeof(pdu->llctrl.enc_rsp.ivs));
 1017892:	2204      	movs	r2, #4
 1017894:	f105 0110 	add.w	r1, r5, #16
 1017898:	f106 00ac 	add.w	r0, r6, #172	; 0xac
 101789c:	f00f f86a 	bl	1026974 <memcpy>
	if (!llcp_ntf_alloc_is_available()) {
 10178a0:	f000 fb0e 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 10178a4:	b910      	cbnz	r0, 10178ac <rp_enc_send_enc_rsp.part.0.isra.0+0x34>
 10178a6:	2303      	movs	r3, #3
		ctx->state = RP_ENC_STATE_WAIT_NTF_LTK_REQ;
 10178a8:	72a3      	strb	r3, [r4, #10]
}
 10178aa:	bd70      	pop	{r4, r5, r6, pc}
		rp_enc_ntf_ltk(conn, ctx);
 10178ac:	4621      	mov	r1, r4
 10178ae:	4630      	mov	r0, r6
 10178b0:	f7ff ff6e 	bl	1017790 <rp_enc_ntf_ltk>
}
 10178b4:	2304      	movs	r3, #4
		ctx->state = RP_ENC_STATE_WAIT_NTF_LTK_REQ;
 10178b6:	72a3      	strb	r3, [r4, #10]
}
 10178b8:	bd70      	pop	{r4, r5, r6, pc}
 10178ba:	bf00      	nop

010178bc <rp_enc_complete.isra.0>:
static void rp_enc_complete(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
 10178bc:	b570      	push	{r4, r5, r6, lr}
 10178be:	4605      	mov	r5, r0
 10178c0:	460c      	mov	r4, r1
	if (!llcp_ntf_alloc_is_available()) {
 10178c2:	f000 fafd 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 10178c6:	b910      	cbnz	r0, 10178ce <rp_enc_complete.isra.0+0x12>
		ctx->state = RP_ENC_STATE_WAIT_NTF;
 10178c8:	2308      	movs	r3, #8
 10178ca:	72a3      	strb	r3, [r4, #10]
}
 10178cc:	bd70      	pop	{r4, r5, r6, pc}
	ntf = llcp_ntf_alloc();
 10178ce:	f000 fb07 	bl	1017ee0 <llcp_ntf_alloc>
	LL_ASSERT(ntf);
 10178d2:	4606      	mov	r6, r0
 10178d4:	2800      	cmp	r0, #0
 10178d6:	d044      	beq.n	1017962 <rp_enc_complete.isra.0+0xa6>
	ntf->hdr.type = NODE_RX_TYPE_DC_PDU;
 10178d8:	2303      	movs	r3, #3
 10178da:	7133      	strb	r3, [r6, #4]
	ntf->hdr.handle = conn->lll.handle;
 10178dc:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
 10178de:	80f3      	strh	r3, [r6, #6]
	if (ctx->proc == PROC_ENCRYPTION_START) {
 10178e0:	7a23      	ldrb	r3, [r4, #8]
 10178e2:	2b05      	cmp	r3, #5
 10178e4:	d038      	beq.n	1017958 <rp_enc_complete.isra.0+0x9c>
	} else if (ctx->proc == PROC_ENCRYPTION_PAUSE) {
 10178e6:	2b06      	cmp	r3, #6
 10178e8:	d10d      	bne.n	1017906 <rp_enc_complete.isra.0+0x4a>
		ntf->hdr.type = NODE_RX_TYPE_ENC_REFRESH;
 10178ea:	231a      	movs	r3, #26
 10178ec:	7133      	strb	r3, [r6, #4]
	ll_rx_put_sched(ntf->hdr.link, ntf);
 10178ee:	4631      	mov	r1, r6
 10178f0:	6830      	ldr	r0, [r6, #0]
 10178f2:	f7fc fcf3 	bl	10142dc <ll_rx_put_sched>
}

static void rp_enc_send_start_enc_rsp(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt,
				      void *param)
{
	if (!llcp_tx_alloc_peek(conn, ctx)) {
 10178f6:	4621      	mov	r1, r4
 10178f8:	4628      	mov	r0, r5
 10178fa:	f000 facd 	bl	1017e98 <llcp_tx_alloc_peek>
 10178fe:	b980      	cbnz	r0, 1017922 <rp_enc_complete.isra.0+0x66>
		ctx->state = RP_ENC_STATE_WAIT_TX_START_ENC_RSP;
 1017900:	2309      	movs	r3, #9
 1017902:	72a3      	strb	r3, [r4, #10]
}
 1017904:	bd70      	pop	{r4, r5, r6, pc}
		LL_ASSERT(0);
 1017906:	f44f 7346 	mov.w	r3, #792	; 0x318
 101790a:	4a1d      	ldr	r2, [pc, #116]	; (1017980 <rp_enc_complete.isra.0+0xc4>)
 101790c:	491d      	ldr	r1, [pc, #116]	; (1017984 <rp_enc_complete.isra.0+0xc8>)
 101790e:	481e      	ldr	r0, [pc, #120]	; (1017988 <rp_enc_complete.isra.0+0xcc>)
 1017910:	f00d f961 	bl	1024bd6 <assert_print>
 1017914:	4040      	eors	r0, r0
 1017916:	f380 8811 	msr	BASEPRI, r0
 101791a:	f04f 0003 	mov.w	r0, #3
 101791e:	df02      	svc	2
 1017920:	e7e5      	b.n	10178ee <rp_enc_complete.isra.0+0x32>
	} else {
		llcp_rp_enc_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_START_ENC_RSP);
 1017922:	2206      	movs	r2, #6
 1017924:	4621      	mov	r1, r4
 1017926:	4628      	mov	r0, r5
 1017928:	f7ff fed4 	bl	10176d4 <llcp_rp_enc_tx>
		llcp_rr_complete(conn);
 101792c:	4628      	mov	r0, r5
 101792e:	f003 f955 	bl	101abdc <llcp_rr_complete>
		ctx->state = RP_ENC_STATE_UNENCRYPTED;
 1017932:	2300      	movs	r3, #0

		/* Resume Tx data */
		llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_ENCRYPTION);
 1017934:	2101      	movs	r1, #1
		ctx->state = RP_ENC_STATE_UNENCRYPTED;
 1017936:	72a3      	strb	r3, [r4, #10]
		llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_ENCRYPTION);
 1017938:	4628      	mov	r0, r5
 101793a:	f000 faeb 	bl	1017f14 <llcp_tx_resume_data>
		/* Resume Rx data */
		ull_conn_resume_rx_data(conn);
 101793e:	4628      	mov	r0, r5
 1017940:	f7ff f842 	bl	10169c8 <ull_conn_resume_rx_data>

		/* Resume possibly paused local procedure */
		llcp_lr_resume(conn);
 1017944:	4628      	mov	r0, r5
 1017946:	f001 fd2d 	bl	10193a4 <llcp_lr_resume>

		/* Tx Encryption enabled */
		conn->lll.enc_tx = 1U;
 101794a:	f895 308e 	ldrb.w	r3, [r5, #142]	; 0x8e
 101794e:	f043 0310 	orr.w	r3, r3, #16
 1017952:	f885 308e 	strb.w	r3, [r5, #142]	; 0x8e
}
 1017956:	bd70      	pop	{r4, r5, r6, pc}
		llcp_pdu_encode_start_enc_rsp(pdu);
 1017958:	f106 001c 	add.w	r0, r6, #28
 101795c:	f001 ff6e 	bl	101983c <llcp_pdu_encode_start_enc_rsp>
 1017960:	e7c5      	b.n	10178ee <rp_enc_complete.isra.0+0x32>
	LL_ASSERT(ntf);
 1017962:	f240 3309 	movw	r3, #777	; 0x309
 1017966:	4a06      	ldr	r2, [pc, #24]	; (1017980 <rp_enc_complete.isra.0+0xc4>)
 1017968:	4908      	ldr	r1, [pc, #32]	; (101798c <rp_enc_complete.isra.0+0xd0>)
 101796a:	4807      	ldr	r0, [pc, #28]	; (1017988 <rp_enc_complete.isra.0+0xcc>)
 101796c:	f00d f933 	bl	1024bd6 <assert_print>
 1017970:	4040      	eors	r0, r0
 1017972:	f380 8811 	msr	BASEPRI, r0
 1017976:	f04f 0003 	mov.w	r0, #3
 101797a:	df02      	svc	2
 101797c:	e7ac      	b.n	10178d8 <rp_enc_complete.isra.0+0x1c>
 101797e:	bf00      	nop
 1017980:	0102aaec 	.word	0x0102aaec
 1017984:	0102a300 	.word	0x0102a300
 1017988:	0102a278 	.word	0x0102a278
 101798c:	0102aad0 	.word	0x0102aad0

01017990 <rp_enc_execute_fsm>:
		break;
	}
}

static void rp_enc_execute_fsm(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
{
 1017990:	b570      	push	{r4, r5, r6, lr}
 1017992:	4615      	mov	r5, r2
	switch (ctx->state) {
 1017994:	7a8a      	ldrb	r2, [r1, #10]
{
 1017996:	460c      	mov	r4, r1
 1017998:	4606      	mov	r6, r0
 101799a:	b082      	sub	sp, #8
	switch (ctx->state) {
 101799c:	2a0d      	cmp	r2, #13
 101799e:	f200 80fa 	bhi.w	1017b96 <rp_enc_execute_fsm+0x206>
 10179a2:	e8df f002 	tbb	[pc, r2]
 10179a6:	1713      	.short	0x1713
 10179a8:	3e251b32 	.word	0x3e251b32
 10179ac:	58554c49 	.word	0x58554c49
 10179b0:	07786762 	.word	0x07786762
	switch (evt) {
 10179b4:	2d08      	cmp	r5, #8
 10179b6:	d10f      	bne.n	10179d8 <rp_enc_execute_fsm+0x48>
		ctx->state = RP_ENC_STATE_WAIT_RX_ENC_REQ;
 10179b8:	f240 3301 	movw	r3, #769	; 0x301
 10179bc:	8163      	strh	r3, [r4, #10]
		conn->lll.enc_tx = 0U;
 10179be:	f890 308e 	ldrb.w	r3, [r0, #142]	; 0x8e
 10179c2:	f36f 1304 	bfc	r3, #4, #1
 10179c6:	f880 308e 	strb.w	r3, [r0, #142]	; 0x8e
		break;
 10179ca:	e005      	b.n	10179d8 <rp_enc_execute_fsm+0x48>
	switch (evt) {
 10179cc:	b925      	cbnz	r5, 10179d8 <rp_enc_execute_fsm+0x48>
		ctx->state = RP_ENC_STATE_WAIT_RX_ENC_REQ;
 10179ce:	2301      	movs	r3, #1
 10179d0:	72a3      	strb	r3, [r4, #10]
		break;
 10179d2:	e001      	b.n	10179d8 <rp_enc_execute_fsm+0x48>
	switch (evt) {
 10179d4:	2d01      	cmp	r5, #1
 10179d6:	d07f      	beq.n	1017ad8 <rp_enc_execute_fsm+0x148>
		break;
	default:
		/* Unknown state */
		LL_ASSERT(0);
	}
}
 10179d8:	b002      	add	sp, #8
 10179da:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 10179dc:	2d00      	cmp	r5, #0
 10179de:	d1fb      	bne.n	10179d8 <rp_enc_execute_fsm+0x48>
	if (!llcp_ntf_alloc_is_available()) {
 10179e0:	f000 fa6e 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 10179e4:	2800      	cmp	r0, #0
 10179e6:	f040 80b5 	bne.w	1017b54 <rp_enc_execute_fsm+0x1c4>
		ctx->state = RP_ENC_STATE_WAIT_NTF_LTK_REQ;
 10179ea:	2303      	movs	r3, #3
 10179ec:	72a3      	strb	r3, [r4, #10]
 10179ee:	e7f3      	b.n	10179d8 <rp_enc_execute_fsm+0x48>
	switch (evt) {
 10179f0:	2d03      	cmp	r5, #3
 10179f2:	d018      	beq.n	1017a26 <rp_enc_execute_fsm+0x96>
 10179f4:	2d04      	cmp	r5, #4
 10179f6:	d1ef      	bne.n	10179d8 <rp_enc_execute_fsm+0x48>
	if (!llcp_tx_alloc_peek(conn, ctx)) {
 10179f8:	4621      	mov	r1, r4
 10179fa:	4630      	mov	r0, r6
 10179fc:	f000 fa4c 	bl	1017e98 <llcp_tx_alloc_peek>
 1017a00:	2800      	cmp	r0, #0
 1017a02:	d152      	bne.n	1017aaa <rp_enc_execute_fsm+0x11a>
		ctx->state = RP_ENC_STATE_WAIT_TX_REJECT_IND;
 1017a04:	2306      	movs	r3, #6
 1017a06:	72a3      	strb	r3, [r4, #10]
 1017a08:	e7e6      	b.n	10179d8 <rp_enc_execute_fsm+0x48>
	switch (evt) {
 1017a0a:	2d00      	cmp	r5, #0
 1017a0c:	d1e4      	bne.n	10179d8 <rp_enc_execute_fsm+0x48>
	if (!llcp_tx_alloc_peek(conn, ctx)) {
 1017a0e:	4621      	mov	r1, r4
 1017a10:	4630      	mov	r0, r6
 1017a12:	f000 fa41 	bl	1017e98 <llcp_tx_alloc_peek>
 1017a16:	2800      	cmp	r0, #0
 1017a18:	f040 8095 	bne.w	1017b46 <rp_enc_execute_fsm+0x1b6>
		ctx->state = RP_ENC_STATE_WAIT_TX_ENC_RSP;
 1017a1c:	2302      	movs	r3, #2
 1017a1e:	72a3      	strb	r3, [r4, #10]
 1017a20:	e7da      	b.n	10179d8 <rp_enc_execute_fsm+0x48>
	switch (evt) {
 1017a22:	2d00      	cmp	r5, #0
 1017a24:	d1d8      	bne.n	10179d8 <rp_enc_execute_fsm+0x48>
	if (!llcp_tx_alloc_peek(conn, ctx)) {
 1017a26:	4621      	mov	r1, r4
 1017a28:	4630      	mov	r0, r6
 1017a2a:	f000 fa35 	bl	1017e98 <llcp_tx_alloc_peek>
 1017a2e:	2800      	cmp	r0, #0
 1017a30:	d134      	bne.n	1017a9c <rp_enc_execute_fsm+0x10c>
		ctx->state = RP_ENC_STATE_WAIT_TX_START_ENC_REQ;
 1017a32:	2305      	movs	r3, #5
 1017a34:	72a3      	strb	r3, [r4, #10]
 1017a36:	e7cf      	b.n	10179d8 <rp_enc_execute_fsm+0x48>
	switch (evt) {
 1017a38:	2d00      	cmp	r5, #0
 1017a3a:	d1cd      	bne.n	10179d8 <rp_enc_execute_fsm+0x48>
 1017a3c:	e7dc      	b.n	10179f8 <rp_enc_execute_fsm+0x68>
	switch (evt) {
 1017a3e:	2d02      	cmp	r5, #2
 1017a40:	d1ca      	bne.n	10179d8 <rp_enc_execute_fsm+0x48>
		rp_enc_complete(conn, ctx, evt, param);
 1017a42:	4621      	mov	r1, r4
 1017a44:	4630      	mov	r0, r6
}
 1017a46:	b002      	add	sp, #8
 1017a48:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		rp_enc_complete(conn, ctx, evt, param);
 1017a4c:	f7ff bf36 	b.w	10178bc <rp_enc_complete.isra.0>
	switch (evt) {
 1017a50:	2d00      	cmp	r5, #0
 1017a52:	d1c1      	bne.n	10179d8 <rp_enc_execute_fsm+0x48>
 1017a54:	e7f5      	b.n	1017a42 <rp_enc_execute_fsm+0xb2>
	switch (evt) {
 1017a56:	2d00      	cmp	r5, #0
 1017a58:	d1be      	bne.n	10179d8 <rp_enc_execute_fsm+0x48>
	if (!llcp_tx_alloc_peek(conn, ctx)) {
 1017a5a:	4621      	mov	r1, r4
 1017a5c:	f000 fa1c 	bl	1017e98 <llcp_tx_alloc_peek>
 1017a60:	2800      	cmp	r0, #0
 1017a62:	d17e      	bne.n	1017b62 <rp_enc_execute_fsm+0x1d2>
		ctx->state = RP_ENC_STATE_WAIT_TX_START_ENC_RSP;
 1017a64:	2309      	movs	r3, #9
 1017a66:	72a3      	strb	r3, [r4, #10]
 1017a68:	e7b6      	b.n	10179d8 <rp_enc_execute_fsm+0x48>
	switch (evt) {
 1017a6a:	2d00      	cmp	r5, #0
 1017a6c:	d1b4      	bne.n	10179d8 <rp_enc_execute_fsm+0x48>
		ctx->state = RP_ENC_STATE_WAIT_RX_PAUSE_ENC_REQ;
 1017a6e:	230b      	movs	r3, #11
 1017a70:	72a3      	strb	r3, [r4, #10]
		break;
 1017a72:	e7b1      	b.n	10179d8 <rp_enc_execute_fsm+0x48>
	switch (evt) {
 1017a74:	2d07      	cmp	r5, #7
 1017a76:	d1af      	bne.n	10179d8 <rp_enc_execute_fsm+0x48>
		llcp_tx_pause_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_ENCRYPTION);
 1017a78:	2101      	movs	r1, #1
 1017a7a:	f000 fa37 	bl	1017eec <llcp_tx_pause_data>
		ull_conn_pause_rx_data(conn);
 1017a7e:	4630      	mov	r0, r6
 1017a80:	f7fe ff9a 	bl	10169b8 <ull_conn_pause_rx_data>
	if (!llcp_tx_alloc_peek(conn, ctx)) {
 1017a84:	4621      	mov	r1, r4
 1017a86:	4630      	mov	r0, r6
 1017a88:	f000 fa06 	bl	1017e98 <llcp_tx_alloc_peek>
 1017a8c:	2800      	cmp	r0, #0
 1017a8e:	d14b      	bne.n	1017b28 <rp_enc_execute_fsm+0x198>
		ctx->state = RP_ENC_STATE_WAIT_TX_PAUSE_ENC_RSP;
 1017a90:	230c      	movs	r3, #12
 1017a92:	72a3      	strb	r3, [r4, #10]
 1017a94:	e7a0      	b.n	10179d8 <rp_enc_execute_fsm+0x48>
	switch (evt) {
 1017a96:	2d00      	cmp	r5, #0
 1017a98:	d19e      	bne.n	10179d8 <rp_enc_execute_fsm+0x48>
 1017a9a:	e7f3      	b.n	1017a84 <rp_enc_execute_fsm+0xf4>
 1017a9c:	4621      	mov	r1, r4
 1017a9e:	4630      	mov	r0, r6
}
 1017aa0:	b002      	add	sp, #8
 1017aa2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 1017aa6:	f7ff be9d 	b.w	10177e4 <rp_enc_send_start_enc_req.part.0>
		llcp_rp_enc_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_REJECT_IND);
 1017aaa:	220d      	movs	r2, #13
 1017aac:	4621      	mov	r1, r4
 1017aae:	4630      	mov	r0, r6
 1017ab0:	f7ff fe10 	bl	10176d4 <llcp_rp_enc_tx>
		llcp_rr_complete(conn);
 1017ab4:	4630      	mov	r0, r6
 1017ab6:	f003 f891 	bl	101abdc <llcp_rr_complete>
		ctx->state = RP_ENC_STATE_UNENCRYPTED;
 1017aba:	2300      	movs	r3, #0
		llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_ENCRYPTION);
 1017abc:	2101      	movs	r1, #1
 1017abe:	4630      	mov	r0, r6
		ctx->state = RP_ENC_STATE_UNENCRYPTED;
 1017ac0:	72a3      	strb	r3, [r4, #10]
		llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_ENCRYPTION);
 1017ac2:	f000 fa27 	bl	1017f14 <llcp_tx_resume_data>
		ull_conn_resume_rx_data(conn);
 1017ac6:	4630      	mov	r0, r6
 1017ac8:	f7fe ff7e 	bl	10169c8 <ull_conn_resume_rx_data>
		llcp_lr_resume(conn);
 1017acc:	4630      	mov	r0, r6
}
 1017ace:	b002      	add	sp, #8
 1017ad0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		llcp_lr_resume(conn);
 1017ad4:	f001 bc66 	b.w	10193a4 <llcp_lr_resume>
		llcp_tx_pause_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_ENCRYPTION);
 1017ad8:	4629      	mov	r1, r5
 1017ada:	9301      	str	r3, [sp, #4]
 1017adc:	f000 fa06 	bl	1017eec <llcp_tx_pause_data>
		ull_conn_pause_rx_data(conn);
 1017ae0:	4630      	mov	r0, r6
 1017ae2:	f7fe ff69 	bl	10169b8 <ull_conn_pause_rx_data>
		llcp_lr_pause(conn);
 1017ae6:	4630      	mov	r0, r6
 1017ae8:	f001 fc58 	bl	101939c <llcp_lr_pause>
	memcpy(ctx->data.enc.rand, pdu->llctrl.enc_req.rand, sizeof(ctx->data.enc.rand));
 1017aec:	9b01      	ldr	r3, [sp, #4]
 1017aee:	2208      	movs	r2, #8
 1017af0:	1d19      	adds	r1, r3, #4
 1017af2:	f104 001d 	add.w	r0, r4, #29
 1017af6:	f00e ff3d 	bl	1026974 <memcpy>
	ctx->data.enc.ediv[0] = pdu->llctrl.enc_req.ediv[0];
 1017afa:	9b01      	ldr	r3, [sp, #4]
	memcpy(&ctx->data.enc.skdm, pdu->llctrl.enc_req.skdm, sizeof(ctx->data.enc.skdm));
 1017afc:	2208      	movs	r2, #8
	ctx->data.enc.ediv[0] = pdu->llctrl.enc_req.ediv[0];
 1017afe:	7b19      	ldrb	r1, [r3, #12]
	memcpy(&ctx->data.enc.skdm, pdu->llctrl.enc_req.skdm, sizeof(ctx->data.enc.skdm));
 1017b00:	f104 0037 	add.w	r0, r4, #55	; 0x37
	ctx->data.enc.ediv[0] = pdu->llctrl.enc_req.ediv[0];
 1017b04:	f884 1025 	strb.w	r1, [r4, #37]	; 0x25
	ctx->data.enc.ediv[1] = pdu->llctrl.enc_req.ediv[1];
 1017b08:	7b59      	ldrb	r1, [r3, #13]
 1017b0a:	f884 1026 	strb.w	r1, [r4, #38]	; 0x26
	memcpy(&ctx->data.enc.skdm, pdu->llctrl.enc_req.skdm, sizeof(ctx->data.enc.skdm));
 1017b0e:	f103 010e 	add.w	r1, r3, #14
 1017b12:	f00e ff2f 	bl	1026974 <memcpy>
	memcpy(&conn->lll.ccm_rx.iv[0], pdu->llctrl.enc_req.ivm, sizeof(pdu->llctrl.enc_req.ivm));
 1017b16:	9b01      	ldr	r3, [sp, #4]
 1017b18:	2204      	movs	r2, #4
 1017b1a:	f103 0116 	add.w	r1, r3, #22
 1017b1e:	f106 00a8 	add.w	r0, r6, #168	; 0xa8
 1017b22:	f00e ff27 	bl	1026974 <memcpy>
 1017b26:	e772      	b.n	1017a0e <rp_enc_execute_fsm+0x7e>
		llcp_rp_enc_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP);
 1017b28:	220b      	movs	r2, #11
 1017b2a:	4621      	mov	r1, r4
 1017b2c:	4630      	mov	r0, r6
 1017b2e:	f7ff fdd1 	bl	10176d4 <llcp_rp_enc_tx>
		ctx->state = RP_ENC_STATE_WAIT_RX_PAUSE_ENC_RSP;
 1017b32:	f640 330d 	movw	r3, #2829	; 0xb0d
 1017b36:	8163      	strh	r3, [r4, #10]
		conn->lll.enc_rx = 0U;
 1017b38:	f896 308e 	ldrb.w	r3, [r6, #142]	; 0x8e
 1017b3c:	f36f 03c3 	bfc	r3, #3, #1
 1017b40:	f886 308e 	strb.w	r3, [r6, #142]	; 0x8e
}
 1017b44:	e748      	b.n	10179d8 <rp_enc_execute_fsm+0x48>
 1017b46:	4621      	mov	r1, r4
 1017b48:	4630      	mov	r0, r6
}
 1017b4a:	b002      	add	sp, #8
 1017b4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 1017b50:	f7ff be92 	b.w	1017878 <rp_enc_send_enc_rsp.part.0.isra.0>
		rp_enc_ntf_ltk(conn, ctx);
 1017b54:	4621      	mov	r1, r4
 1017b56:	4630      	mov	r0, r6
 1017b58:	f7ff fe1a 	bl	1017790 <rp_enc_ntf_ltk>
		ctx->state = RP_ENC_STATE_WAIT_LTK_REPLY;
 1017b5c:	2304      	movs	r3, #4
 1017b5e:	72a3      	strb	r3, [r4, #10]
}
 1017b60:	e73a      	b.n	10179d8 <rp_enc_execute_fsm+0x48>
		llcp_rp_enc_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_START_ENC_RSP);
 1017b62:	2206      	movs	r2, #6
 1017b64:	4621      	mov	r1, r4
 1017b66:	4630      	mov	r0, r6
 1017b68:	f7ff fdb4 	bl	10176d4 <llcp_rp_enc_tx>
		llcp_rr_complete(conn);
 1017b6c:	4630      	mov	r0, r6
 1017b6e:	f003 f835 	bl	101abdc <llcp_rr_complete>
		llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_ENCRYPTION);
 1017b72:	2101      	movs	r1, #1
 1017b74:	4630      	mov	r0, r6
		ctx->state = RP_ENC_STATE_UNENCRYPTED;
 1017b76:	72a5      	strb	r5, [r4, #10]
		llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_ENCRYPTION);
 1017b78:	f000 f9cc 	bl	1017f14 <llcp_tx_resume_data>
		ull_conn_resume_rx_data(conn);
 1017b7c:	4630      	mov	r0, r6
 1017b7e:	f7fe ff23 	bl	10169c8 <ull_conn_resume_rx_data>
		llcp_lr_resume(conn);
 1017b82:	4630      	mov	r0, r6
 1017b84:	f001 fc0e 	bl	10193a4 <llcp_lr_resume>
		conn->lll.enc_tx = 1U;
 1017b88:	f896 308e 	ldrb.w	r3, [r6, #142]	; 0x8e
 1017b8c:	f043 0310 	orr.w	r3, r3, #16
 1017b90:	f886 308e 	strb.w	r3, [r6, #142]	; 0x8e
}
 1017b94:	e720      	b.n	10179d8 <rp_enc_execute_fsm+0x48>
		LL_ASSERT(0);
 1017b96:	f240 43ae 	movw	r3, #1198	; 0x4ae
 1017b9a:	4a06      	ldr	r2, [pc, #24]	; (1017bb4 <rp_enc_execute_fsm+0x224>)
 1017b9c:	4906      	ldr	r1, [pc, #24]	; (1017bb8 <rp_enc_execute_fsm+0x228>)
 1017b9e:	4807      	ldr	r0, [pc, #28]	; (1017bbc <rp_enc_execute_fsm+0x22c>)
 1017ba0:	f00d f819 	bl	1024bd6 <assert_print>
 1017ba4:	4040      	eors	r0, r0
 1017ba6:	f380 8811 	msr	BASEPRI, r0
 1017baa:	f04f 0003 	mov.w	r0, #3
 1017bae:	df02      	svc	2
}
 1017bb0:	e712      	b.n	10179d8 <rp_enc_execute_fsm+0x48>
 1017bb2:	bf00      	nop
 1017bb4:	0102aaec 	.word	0x0102aaec
 1017bb8:	0102a300 	.word	0x0102a300
 1017bbc:	0102a278 	.word	0x0102a278

01017bc0 <llcp_rp_enc_rx>:

void llcp_rp_enc_rx(struct ll_conn *conn, struct proc_ctx *ctx, struct node_rx_pdu *rx)
{
	struct pdu_data *pdu = (struct pdu_data *)rx->pdu;

	switch (pdu->llctrl.opcode) {
 1017bc0:	f892 c01f 	ldrb.w	ip, [r2, #31]
	struct pdu_data *pdu = (struct pdu_data *)rx->pdu;
 1017bc4:	f102 031c 	add.w	r3, r2, #28
	switch (pdu->llctrl.opcode) {
 1017bc8:	f1ac 0203 	sub.w	r2, ip, #3
 1017bcc:	2a08      	cmp	r2, #8
 1017bce:	d806      	bhi.n	1017bde <llcp_rp_enc_rx+0x1e>
 1017bd0:	e8df f002 	tbb	[pc, r2]
 1017bd4:	0f050512 	.word	0x0f050512
 1017bd8:	0c050505 	.word	0x0c050505
 1017bdc:	09          	.byte	0x09
 1017bdd:	00          	.byte	0x00
		 * immediately exit the Connection state, and shall transition to the Standby state.
		 * The Host shall be notified that the link has been disconnected with the error
		 * code Connection Terminated Due to MIC Failure (0x3D).
		 */

		conn->llcp_terminate.reason_final = BT_HCI_ERR_TERM_DUE_TO_MIC_FAIL;
 1017bde:	233d      	movs	r3, #61	; 0x3d
 1017be0:	f880 3148 	strb.w	r3, [r0, #328]	; 0x148
	}
}
 1017be4:	4770      	bx	lr
		rp_enc_execute_fsm(conn, ctx, RP_ENC_EVT_PAUSE_ENC_RSP, pdu);
 1017be6:	2208      	movs	r2, #8
 1017be8:	f7ff bed2 	b.w	1017990 <rp_enc_execute_fsm>
		rp_enc_execute_fsm(conn, ctx, RP_ENC_EVT_PAUSE_ENC_REQ, pdu);
 1017bec:	2207      	movs	r2, #7
 1017bee:	f7ff becf 	b.w	1017990 <rp_enc_execute_fsm>
		rp_enc_execute_fsm(conn, ctx, RP_ENC_EVT_START_ENC_RSP, pdu);
 1017bf2:	2202      	movs	r2, #2
 1017bf4:	f7ff becc 	b.w	1017990 <rp_enc_execute_fsm>
		rp_enc_execute_fsm(conn, ctx, RP_ENC_EVT_ENC_REQ, pdu);
 1017bf8:	2201      	movs	r2, #1
 1017bfa:	f7ff bec9 	b.w	1017990 <rp_enc_execute_fsm>
 1017bfe:	bf00      	nop

01017c00 <llcp_rp_enc_init_proc>:

void llcp_rp_enc_init_proc(struct proc_ctx *ctx)
{
 1017c00:	b508      	push	{r3, lr}
	switch (ctx->proc) {
 1017c02:	7a03      	ldrb	r3, [r0, #8]
 1017c04:	2b05      	cmp	r3, #5
 1017c06:	d00f      	beq.n	1017c28 <llcp_rp_enc_init_proc+0x28>
 1017c08:	2b06      	cmp	r3, #6
 1017c0a:	d010      	beq.n	1017c2e <llcp_rp_enc_init_proc+0x2e>
		break;
	case PROC_ENCRYPTION_PAUSE:
		ctx->state = RP_ENC_STATE_ENCRYPTED;
		break;
	default:
		LL_ASSERT(0);
 1017c0c:	f240 43e3 	movw	r3, #1251	; 0x4e3
 1017c10:	4a08      	ldr	r2, [pc, #32]	; (1017c34 <llcp_rp_enc_init_proc+0x34>)
 1017c12:	4909      	ldr	r1, [pc, #36]	; (1017c38 <llcp_rp_enc_init_proc+0x38>)
 1017c14:	4809      	ldr	r0, [pc, #36]	; (1017c3c <llcp_rp_enc_init_proc+0x3c>)
 1017c16:	f00c ffde 	bl	1024bd6 <assert_print>
 1017c1a:	4040      	eors	r0, r0
 1017c1c:	f380 8811 	msr	BASEPRI, r0
 1017c20:	f04f 0003 	mov.w	r0, #3
 1017c24:	df02      	svc	2
	}
}
 1017c26:	bd08      	pop	{r3, pc}
		ctx->state = RP_ENC_STATE_UNENCRYPTED;
 1017c28:	2300      	movs	r3, #0
 1017c2a:	7283      	strb	r3, [r0, #10]
}
 1017c2c:	bd08      	pop	{r3, pc}
		ctx->state = RP_ENC_STATE_ENCRYPTED;
 1017c2e:	230a      	movs	r3, #10
 1017c30:	7283      	strb	r3, [r0, #10]
}
 1017c32:	bd08      	pop	{r3, pc}
 1017c34:	0102aaec 	.word	0x0102aaec
 1017c38:	0102a300 	.word	0x0102a300
 1017c3c:	0102a278 	.word	0x0102a278

01017c40 <llcp_rp_enc_ltk_req_reply>:

void llcp_rp_enc_ltk_req_reply(struct ll_conn *conn, struct proc_ctx *ctx)
{
	rp_enc_execute_fsm(conn, ctx, RP_ENC_EVT_LTK_REQ_REPLY, NULL);
 1017c40:	2300      	movs	r3, #0
 1017c42:	2203      	movs	r2, #3
 1017c44:	f7ff bea4 	b.w	1017990 <rp_enc_execute_fsm>

01017c48 <llcp_rp_enc_ltk_req_neg_reply>:
}

void llcp_rp_enc_ltk_req_neg_reply(struct ll_conn *conn, struct proc_ctx *ctx)
{
	rp_enc_execute_fsm(conn, ctx, RP_ENC_EVT_LTK_REQ_NEG_REPLY, NULL);
 1017c48:	2300      	movs	r3, #0
 1017c4a:	2204      	movs	r2, #4
 1017c4c:	f7ff bea0 	b.w	1017990 <rp_enc_execute_fsm>

01017c50 <llcp_rp_enc_ltk_req_reply_allowed>:
}

bool llcp_rp_enc_ltk_req_reply_allowed(struct ll_conn *conn, struct proc_ctx *ctx)
{
	return (ctx->state == RP_ENC_STATE_WAIT_LTK_REPLY);
 1017c50:	7a88      	ldrb	r0, [r1, #10]
}
 1017c52:	f1a0 0004 	sub.w	r0, r0, #4
 1017c56:	fab0 f080 	clz	r0, r0
 1017c5a:	0940      	lsrs	r0, r0, #5
 1017c5c:	4770      	bx	lr
 1017c5e:	bf00      	nop

01017c60 <llcp_rp_enc_run>:

void llcp_rp_enc_run(struct ll_conn *conn, struct proc_ctx *ctx, void *param)
{
 1017c60:	4613      	mov	r3, r2
	rp_enc_execute_fsm(conn, ctx, RP_ENC_EVT_RUN, param);
 1017c62:	2200      	movs	r2, #0
 1017c64:	f7ff be94 	b.w	1017990 <rp_enc_execute_fsm>

01017c68 <ull_tx_q_init>:

#include "ull_tx_queue.h"

void ull_tx_q_init(struct ull_tx_q *queue)
{
	queue->pause_data = 0U;
 1017c68:	2300      	movs	r3, #0
 1017c6a:	7003      	strb	r3, [r0, #0]
	list->head = NULL;
 1017c6c:	6043      	str	r3, [r0, #4]
 1017c6e:	6083      	str	r3, [r0, #8]
 1017c70:	60c3      	str	r3, [r0, #12]
 1017c72:	6103      	str	r3, [r0, #16]
	sys_slist_init(&queue->tx_list);
	sys_slist_init(&queue->data_list);
}
 1017c74:	4770      	bx	lr
 1017c76:	bf00      	nop

01017c78 <ull_tx_q_pause_data>:

void ull_tx_q_pause_data(struct ull_tx_q *queue)
{
	queue->pause_data++;
 1017c78:	7803      	ldrb	r3, [r0, #0]
 1017c7a:	3301      	adds	r3, #1
 1017c7c:	7003      	strb	r3, [r0, #0]
}
 1017c7e:	4770      	bx	lr

01017c80 <ull_tx_q_resume_data>:

void ull_tx_q_resume_data(struct ull_tx_q *queue)
{
	if (queue->pause_data > 0) {
 1017c80:	7803      	ldrb	r3, [r0, #0]
 1017c82:	b95b      	cbnz	r3, 1017c9c <ull_tx_q_resume_data+0x1c>
	return list->head;
 1017c84:	68c3      	ldr	r3, [r0, #12]
		queue->pause_data--;
	}

	/* move all paused data to the tail of tx list, only if not empty and no longer paused */
	if (!queue->pause_data &&  !sys_slist_is_empty(&queue->data_list)) {
 1017c86:	b17b      	cbz	r3, 1017ca8 <ull_tx_q_resume_data+0x28>
	return list->tail;
 1017c88:	6902      	ldr	r2, [r0, #16]
Z_GENLIST_APPEND_LIST(slist, snode)
 1017c8a:	b11a      	cbz	r2, 1017c94 <ull_tx_q_resume_data+0x14>
	return list->tail;
 1017c8c:	6881      	ldr	r1, [r0, #8]
Z_GENLIST_APPEND_LIST(slist, snode)
 1017c8e:	b161      	cbz	r1, 1017caa <ull_tx_q_resume_data+0x2a>
	parent->next = child;
 1017c90:	600b      	str	r3, [r1, #0]
	list->tail = node;
 1017c92:	6082      	str	r2, [r0, #8]
	list->head = NULL;
 1017c94:	2300      	movs	r3, #0
 1017c96:	60c3      	str	r3, [r0, #12]
 1017c98:	6103      	str	r3, [r0, #16]
		sys_slist_merge_slist(&queue->tx_list, &queue->data_list);
	}
}
 1017c9a:	4770      	bx	lr
		queue->pause_data--;
 1017c9c:	3b01      	subs	r3, #1
 1017c9e:	b2db      	uxtb	r3, r3
 1017ca0:	7003      	strb	r3, [r0, #0]
	if (!queue->pause_data &&  !sys_slist_is_empty(&queue->data_list)) {
 1017ca2:	2b00      	cmp	r3, #0
 1017ca4:	d0ee      	beq.n	1017c84 <ull_tx_q_resume_data+0x4>
}
 1017ca6:	4770      	bx	lr
 1017ca8:	4770      	bx	lr
	list->head = node;
 1017caa:	6043      	str	r3, [r0, #4]
}
 1017cac:	e7f1      	b.n	1017c92 <ull_tx_q_resume_data+0x12>
 1017cae:	bf00      	nop

01017cb0 <ull_tx_q_enqueue_data>:

void ull_tx_q_enqueue_data(struct ull_tx_q *queue, struct node_tx *tx)
{
	sys_slist_t *list;

	if (queue->pause_data) {
 1017cb0:	7803      	ldrb	r3, [r0, #0]
 1017cb2:	b13b      	cbz	r3, 1017cc4 <ull_tx_q_enqueue_data+0x14>
	parent->next = child;
 1017cb4:	2300      	movs	r3, #0
		/* enqueue data pdu into paused data wait list */
		list = &queue->data_list;
 1017cb6:	300c      	adds	r0, #12
 1017cb8:	600b      	str	r3, [r1, #0]
	return list->tail;
 1017cba:	6843      	ldr	r3, [r0, #4]
Z_GENLIST_APPEND(slist, snode)
 1017cbc:	b143      	cbz	r3, 1017cd0 <ull_tx_q_enqueue_data+0x20>
	parent->next = child;
 1017cbe:	6019      	str	r1, [r3, #0]
	list->tail = node;
 1017cc0:	6041      	str	r1, [r0, #4]
		/* enqueue data pdu into tx list */
		list = &queue->tx_list;
	}

	sys_slist_append(list, (sys_snode_t *)tx);
}
 1017cc2:	4770      	bx	lr
	parent->next = child;
 1017cc4:	2300      	movs	r3, #0
		list = &queue->tx_list;
 1017cc6:	3004      	adds	r0, #4
 1017cc8:	600b      	str	r3, [r1, #0]
	return list->tail;
 1017cca:	6843      	ldr	r3, [r0, #4]
Z_GENLIST_APPEND(slist, snode)
 1017ccc:	2b00      	cmp	r3, #0
 1017cce:	d1f6      	bne.n	1017cbe <ull_tx_q_enqueue_data+0xe>
	list->head = node;
 1017cd0:	6001      	str	r1, [r0, #0]
 1017cd2:	6041      	str	r1, [r0, #4]
}
 1017cd4:	4770      	bx	lr
 1017cd6:	bf00      	nop

01017cd8 <ull_tx_q_enqueue_ctrl>:
	parent->next = child;
 1017cd8:	2300      	movs	r3, #0
 1017cda:	600b      	str	r3, [r1, #0]
	return list->tail;
 1017cdc:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_APPEND(slist, snode)
 1017cde:	b113      	cbz	r3, 1017ce6 <ull_tx_q_enqueue_ctrl+0xe>
	parent->next = child;
 1017ce0:	6019      	str	r1, [r3, #0]
	list->tail = node;
 1017ce2:	6081      	str	r1, [r0, #8]

void ull_tx_q_enqueue_ctrl(struct ull_tx_q *queue, struct node_tx *tx)
{
	/* enqueue ctrl pdu into tx list */
	sys_slist_append(&queue->tx_list, (sys_snode_t *)tx);
}
 1017ce4:	4770      	bx	lr
	list->head = node;
 1017ce6:	6041      	str	r1, [r0, #4]
 1017ce8:	6081      	str	r1, [r0, #8]
}
 1017cea:	4770      	bx	lr

01017cec <ull_tx_q_peek>:
	struct node_tx *tx;

	tx = (struct node_tx *)sys_slist_peek_head(&queue->tx_list);

	return tx;
}
 1017cec:	6840      	ldr	r0, [r0, #4]
 1017cee:	4770      	bx	lr

01017cf0 <ull_tx_q_dequeue>:

struct node_tx *ull_tx_q_dequeue(struct ull_tx_q *queue)
{
 1017cf0:	4603      	mov	r3, r0
	return list->head;
 1017cf2:	6840      	ldr	r0, [r0, #4]
Z_GENLIST_GET(slist, snode)
 1017cf4:	b128      	cbz	r0, 1017d02 <ull_tx_q_dequeue+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1017cf6:	6899      	ldr	r1, [r3, #8]
	return node->next;
 1017cf8:	6802      	ldr	r2, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1017cfa:	4288      	cmp	r0, r1
	list->head = node;
 1017cfc:	605a      	str	r2, [r3, #4]
	list->tail = node;
 1017cfe:	bf08      	it	eq
 1017d00:	609a      	streq	r2, [r3, #8]
	struct node_tx *tx;

	tx = (struct node_tx *)sys_slist_get(&queue->tx_list);

	return tx;
}
 1017d02:	4770      	bx	lr

01017d04 <pdu_validate_conn_update_ind>:
#define VALIDATE_PDU_LEN(pdu, type) (pdu->len == PDU_DATA_LLCTRL_LEN(type))

#if defined(CONFIG_BT_PERIPHERAL)
static bool pdu_validate_conn_update_ind(struct pdu_data *pdu)
{
	return VALIDATE_PDU_LEN(pdu, conn_update_ind);
 1017d04:	7840      	ldrb	r0, [r0, #1]
}
 1017d06:	f1a0 000c 	sub.w	r0, r0, #12
 1017d0a:	fab0 f080 	clz	r0, r0
 1017d0e:	0940      	lsrs	r0, r0, #5
 1017d10:	4770      	bx	lr
 1017d12:	bf00      	nop

01017d14 <pdu_validate_chan_map_ind>:

static bool pdu_validate_chan_map_ind(struct pdu_data *pdu)
{
	return VALIDATE_PDU_LEN(pdu, chan_map_ind);
 1017d14:	7840      	ldrb	r0, [r0, #1]
}
 1017d16:	f1a0 0008 	sub.w	r0, r0, #8
 1017d1a:	fab0 f080 	clz	r0, r0
 1017d1e:	0940      	lsrs	r0, r0, #5
 1017d20:	4770      	bx	lr
 1017d22:	bf00      	nop

01017d24 <pdu_validate_terminate_ind>:
#endif /* CONFIG_BT_PERIPHERAL */

static bool pdu_validate_terminate_ind(struct pdu_data *pdu)
{
	return VALIDATE_PDU_LEN(pdu, terminate_ind);
 1017d24:	7840      	ldrb	r0, [r0, #1]
}
 1017d26:	f1a0 0002 	sub.w	r0, r0, #2
 1017d2a:	fab0 f080 	clz	r0, r0
 1017d2e:	0940      	lsrs	r0, r0, #5
 1017d30:	4770      	bx	lr
 1017d32:	bf00      	nop

01017d34 <pdu_validate_enc_req>:

#if defined(CONFIG_BT_CTLR_LE_ENC) && defined(CONFIG_BT_PERIPHERAL)
static bool pdu_validate_enc_req(struct pdu_data *pdu)
{
	return VALIDATE_PDU_LEN(pdu, enc_req);
 1017d34:	7840      	ldrb	r0, [r0, #1]
}
 1017d36:	f1a0 0017 	sub.w	r0, r0, #23
 1017d3a:	fab0 f080 	clz	r0, r0
 1017d3e:	0940      	lsrs	r0, r0, #5
 1017d40:	4770      	bx	lr
 1017d42:	bf00      	nop

01017d44 <pdu_validate_start_enc_rsp>:
#endif /* CONFIG_BT_CTLR_LE_ENC && CONFIG_BT_CENTRAL */

#if defined(CONFIG_BT_CTLR_LE_ENC) && defined(CONFIG_BT_PERIPHERAL)
static bool pdu_validate_start_enc_rsp(struct pdu_data *pdu)
{
	return VALIDATE_PDU_LEN(pdu, start_enc_rsp);
 1017d44:	7840      	ldrb	r0, [r0, #1]
}
 1017d46:	f1a0 0001 	sub.w	r0, r0, #1
 1017d4a:	fab0 f080 	clz	r0, r0
 1017d4e:	0940      	lsrs	r0, r0, #5
 1017d50:	4770      	bx	lr
 1017d52:	bf00      	nop

01017d54 <pdu_validate_feature_req>:
}

#if defined(CONFIG_BT_PERIPHERAL)
static bool pdu_validate_feature_req(struct pdu_data *pdu)
{
	return VALIDATE_PDU_LEN(pdu, feature_req);
 1017d54:	7840      	ldrb	r0, [r0, #1]
}
 1017d56:	f1a0 0009 	sub.w	r0, r0, #9
 1017d5a:	fab0 f080 	clz	r0, r0
 1017d5e:	0940      	lsrs	r0, r0, #5
 1017d60:	4770      	bx	lr
 1017d62:	bf00      	nop

01017d64 <pdu_validate_version_ind>:
}
#endif

static bool pdu_validate_version_ind(struct pdu_data *pdu)
{
	return VALIDATE_PDU_LEN(pdu, version_ind);
 1017d64:	7840      	ldrb	r0, [r0, #1]
}
 1017d66:	f1a0 0006 	sub.w	r0, r0, #6
 1017d6a:	fab0 f080 	clz	r0, r0
 1017d6e:	0940      	lsrs	r0, r0, #5
 1017d70:	4770      	bx	lr
 1017d72:	bf00      	nop

01017d74 <pdu_validate_conn_param_req>:
#endif /* CONFIG_BT_CTLR_PER_INIT_FEAT_XCHG && CONFIG_BT_CENTRAL */

#if defined(CONFIG_BT_CTLR_CONN_PARAM_REQ)
static bool pdu_validate_conn_param_req(struct pdu_data *pdu)
{
	return VALIDATE_PDU_LEN(pdu, conn_param_req);
 1017d74:	7840      	ldrb	r0, [r0, #1]
}
 1017d76:	f1a0 0018 	sub.w	r0, r0, #24
 1017d7a:	fab0 f080 	clz	r0, r0
 1017d7e:	0940      	lsrs	r0, r0, #5
 1017d80:	4770      	bx	lr
 1017d82:	bf00      	nop

01017d84 <pdu_validate_reject_ext_ind>:
	return VALIDATE_PDU_LEN(pdu, conn_param_rsp);
}

static bool pdu_validate_reject_ext_ind(struct pdu_data *pdu)
{
	return VALIDATE_PDU_LEN(pdu, reject_ext_ind);
 1017d84:	7840      	ldrb	r0, [r0, #1]
}
 1017d86:	f1a0 0003 	sub.w	r0, r0, #3
 1017d8a:	fab0 f080 	clz	r0, r0
 1017d8e:	0940      	lsrs	r0, r0, #5
 1017d90:	4770      	bx	lr
 1017d92:	bf00      	nop

01017d94 <pdu_validate_phy_upd_ind>:
	return VALIDATE_PDU_LEN(pdu, phy_rsp);
}

static bool pdu_validate_phy_upd_ind(struct pdu_data *pdu)
{
	return VALIDATE_PDU_LEN(pdu, phy_upd_ind);
 1017d94:	7840      	ldrb	r0, [r0, #1]
}
 1017d96:	f1a0 0005 	sub.w	r0, r0, #5
 1017d9a:	fab0 f080 	clz	r0, r0
 1017d9e:	0940      	lsrs	r0, r0, #5
 1017da0:	4770      	bx	lr
 1017da2:	bf00      	nop

01017da4 <pdu_validate_clock_accuracy_rsp>:
{
	return VALIDATE_PDU_LEN(pdu, clock_accuracy_req);
}
#endif /* CONFIG_BT_CTLR_DATA_LENGTH */

static bool pdu_validate_clock_accuracy_rsp(struct pdu_data *pdu)
 1017da4:	7840      	ldrb	r0, [r0, #1]
 1017da6:	f1a0 0002 	sub.w	r0, r0, #2
 1017daa:	fab0 f080 	clz	r0, r0
 1017dae:	0940      	lsrs	r0, r0, #5
 1017db0:	4770      	bx	lr
 1017db2:	bf00      	nop

01017db4 <pdu_validate_unknown_rsp>:
static bool pdu_validate_unknown_rsp(struct pdu_data *pdu)
 1017db4:	7840      	ldrb	r0, [r0, #1]
 1017db6:	f1a0 0002 	sub.w	r0, r0, #2
 1017dba:	fab0 f080 	clz	r0, r0
 1017dbe:	0940      	lsrs	r0, r0, #5
 1017dc0:	4770      	bx	lr
 1017dc2:	bf00      	nop

01017dc4 <pdu_validate_pause_enc_req>:
static bool pdu_validate_pause_enc_req(struct pdu_data *pdu)
 1017dc4:	7840      	ldrb	r0, [r0, #1]
 1017dc6:	f1a0 0001 	sub.w	r0, r0, #1
 1017dca:	fab0 f080 	clz	r0, r0
 1017dce:	0940      	lsrs	r0, r0, #5
 1017dd0:	4770      	bx	lr
 1017dd2:	bf00      	nop

01017dd4 <pdu_validate_reject_ind>:
static bool pdu_validate_reject_ind(struct pdu_data *pdu)
 1017dd4:	7840      	ldrb	r0, [r0, #1]
 1017dd6:	f1a0 0002 	sub.w	r0, r0, #2
 1017dda:	fab0 f080 	clz	r0, r0
 1017dde:	0940      	lsrs	r0, r0, #5
 1017de0:	4770      	bx	lr
 1017de2:	bf00      	nop

01017de4 <pdu_validate_conn_param_rsp>:
static bool pdu_validate_conn_param_rsp(struct pdu_data *pdu)
 1017de4:	7840      	ldrb	r0, [r0, #1]
 1017de6:	f1a0 0018 	sub.w	r0, r0, #24
 1017dea:	fab0 f080 	clz	r0, r0
 1017dee:	0940      	lsrs	r0, r0, #5
 1017df0:	4770      	bx	lr
 1017df2:	bf00      	nop

01017df4 <pdu_validate_ping_req>:
static bool pdu_validate_ping_req(struct pdu_data *pdu)
 1017df4:	7840      	ldrb	r0, [r0, #1]
 1017df6:	f1a0 0001 	sub.w	r0, r0, #1
 1017dfa:	fab0 f080 	clz	r0, r0
 1017dfe:	0940      	lsrs	r0, r0, #5
 1017e00:	4770      	bx	lr
 1017e02:	bf00      	nop

01017e04 <pdu_validate_ping_rsp>:
static bool pdu_validate_ping_rsp(struct pdu_data *pdu)
 1017e04:	7840      	ldrb	r0, [r0, #1]
 1017e06:	f1a0 0001 	sub.w	r0, r0, #1
 1017e0a:	fab0 f080 	clz	r0, r0
 1017e0e:	0940      	lsrs	r0, r0, #5
 1017e10:	4770      	bx	lr
 1017e12:	bf00      	nop

01017e14 <pdu_validate_length_req>:
static bool pdu_validate_length_req(struct pdu_data *pdu)
 1017e14:	7840      	ldrb	r0, [r0, #1]
 1017e16:	f1a0 0009 	sub.w	r0, r0, #9
 1017e1a:	fab0 f080 	clz	r0, r0
 1017e1e:	0940      	lsrs	r0, r0, #5
 1017e20:	4770      	bx	lr
 1017e22:	bf00      	nop

01017e24 <pdu_validate_length_rsp>:
static bool pdu_validate_length_rsp(struct pdu_data *pdu)
 1017e24:	7840      	ldrb	r0, [r0, #1]
 1017e26:	f1a0 0009 	sub.w	r0, r0, #9
 1017e2a:	fab0 f080 	clz	r0, r0
 1017e2e:	0940      	lsrs	r0, r0, #5
 1017e30:	4770      	bx	lr
 1017e32:	bf00      	nop

01017e34 <pdu_validate_phy_req>:
static bool pdu_validate_phy_req(struct pdu_data *pdu)
 1017e34:	7840      	ldrb	r0, [r0, #1]
 1017e36:	f1a0 0003 	sub.w	r0, r0, #3
 1017e3a:	fab0 f080 	clz	r0, r0
 1017e3e:	0940      	lsrs	r0, r0, #5
 1017e40:	4770      	bx	lr
 1017e42:	bf00      	nop

01017e44 <pdu_validate_phy_rsp>:
static bool pdu_validate_phy_rsp(struct pdu_data *pdu)
 1017e44:	7840      	ldrb	r0, [r0, #1]
 1017e46:	f1a0 0003 	sub.w	r0, r0, #3
 1017e4a:	fab0 f080 	clz	r0, r0
 1017e4e:	0940      	lsrs	r0, r0, #5
 1017e50:	4770      	bx	lr
 1017e52:	bf00      	nop

01017e54 <llcp_proc_ctx_release>:
{
 1017e54:	b510      	push	{r4, lr}
	LL_ASSERT(ctx->owner);
 1017e56:	6841      	ldr	r1, [r0, #4]
{
 1017e58:	4604      	mov	r4, r0
	LL_ASSERT(ctx->owner);
 1017e5a:	b121      	cbz	r1, 1017e66 <llcp_proc_ctx_release+0x12>
	mem_release(ctx, &ctx->owner->free);
 1017e5c:	4620      	mov	r0, r4
}
 1017e5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	mem_release(ctx, &ctx->owner->free);
 1017e62:	f7f8 bffd 	b.w	1010e60 <mem_release>
	LL_ASSERT(ctx->owner);
 1017e66:	235d      	movs	r3, #93	; 0x5d
 1017e68:	4a08      	ldr	r2, [pc, #32]	; (1017e8c <llcp_proc_ctx_release+0x38>)
 1017e6a:	4909      	ldr	r1, [pc, #36]	; (1017e90 <llcp_proc_ctx_release+0x3c>)
 1017e6c:	4809      	ldr	r0, [pc, #36]	; (1017e94 <llcp_proc_ctx_release+0x40>)
 1017e6e:	f00c feb2 	bl	1024bd6 <assert_print>
 1017e72:	4040      	eors	r0, r0
 1017e74:	f380 8811 	msr	BASEPRI, r0
 1017e78:	f04f 0003 	mov.w	r0, #3
 1017e7c:	df02      	svc	2
	mem_release(ctx, &ctx->owner->free);
 1017e7e:	4620      	mov	r0, r4
 1017e80:	6861      	ldr	r1, [r4, #4]
}
 1017e82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	mem_release(ctx, &ctx->owner->free);
 1017e86:	f7f8 bfeb 	b.w	1010e60 <mem_release>
 1017e8a:	bf00      	nop
 1017e8c:	0102ab30 	.word	0x0102ab30
 1017e90:	0102ab70 	.word	0x0102ab70
 1017e94:	0102a278 	.word	0x0102a278

01017e98 <llcp_tx_alloc_peek>:
	return mem_tx.free != NULL;
 1017e98:	4b02      	ldr	r3, [pc, #8]	; (1017ea4 <llcp_tx_alloc_peek+0xc>)
 1017e9a:	6818      	ldr	r0, [r3, #0]
}
 1017e9c:	3800      	subs	r0, #0
 1017e9e:	bf18      	it	ne
 1017ea0:	2001      	movne	r0, #1
 1017ea2:	4770      	bx	lr
 1017ea4:	2100098c 	.word	0x2100098c

01017ea8 <llcp_tx_alloc>:
{
 1017ea8:	b510      	push	{r4, lr}
	tx = (struct node_tx *)mem_acquire(&mem_tx.free);
 1017eaa:	4804      	ldr	r0, [pc, #16]	; (1017ebc <llcp_tx_alloc+0x14>)
 1017eac:	f7f8 ffbc 	bl	1010e28 <mem_acquire>
 1017eb0:	4604      	mov	r4, r0
	ull_pdu_data_init(pdu);
 1017eb2:	3004      	adds	r0, #4
 1017eb4:	f7fe fd7e 	bl	10169b4 <ull_pdu_data_init>
}
 1017eb8:	4620      	mov	r0, r4
 1017eba:	bd10      	pop	{r4, pc}
 1017ebc:	2100098c 	.word	0x2100098c

01017ec0 <llcp_ntf_alloc_is_available>:
{
 1017ec0:	b508      	push	{r3, lr}
	return ll_pdu_rx_alloc_peek(1) != NULL;
 1017ec2:	2001      	movs	r0, #1
 1017ec4:	f7fc fa1e 	bl	1014304 <ll_pdu_rx_alloc_peek>
}
 1017ec8:	3800      	subs	r0, #0
 1017eca:	bf18      	it	ne
 1017ecc:	2001      	movne	r0, #1
 1017ece:	bd08      	pop	{r3, pc}

01017ed0 <llcp_ntf_alloc_num_available>:
{
 1017ed0:	b508      	push	{r3, lr}
	return ll_pdu_rx_alloc_peek(count) != NULL;
 1017ed2:	f7fc fa17 	bl	1014304 <ll_pdu_rx_alloc_peek>
}
 1017ed6:	3800      	subs	r0, #0
 1017ed8:	bf18      	it	ne
 1017eda:	2001      	movne	r0, #1
 1017edc:	bd08      	pop	{r3, pc}
 1017ede:	bf00      	nop

01017ee0 <llcp_ntf_alloc>:
	return ll_pdu_rx_alloc();
 1017ee0:	f7fc ba32 	b.w	1014348 <ll_pdu_rx_alloc>

01017ee4 <llcp_tx_enqueue>:
	ull_tx_q_enqueue_ctrl(&conn->tx_q, tx);
 1017ee4:	30d4      	adds	r0, #212	; 0xd4
 1017ee6:	f7ff bef7 	b.w	1017cd8 <ull_tx_q_enqueue_ctrl>
 1017eea:	bf00      	nop

01017eec <llcp_tx_pause_data>:
{
 1017eec:	b538      	push	{r3, r4, r5, lr}
	if (conn->llcp.tx_q_pause_data_mask == 0) {
 1017eee:	f890 3146 	ldrb.w	r3, [r0, #326]	; 0x146
{
 1017ef2:	4605      	mov	r5, r0
 1017ef4:	460c      	mov	r4, r1
	if (conn->llcp.tx_q_pause_data_mask == 0) {
 1017ef6:	b11b      	cbz	r3, 1017f00 <llcp_tx_pause_data+0x14>
	conn->llcp.tx_q_pause_data_mask |= pause_mask;
 1017ef8:	431c      	orrs	r4, r3
 1017efa:	f885 4146 	strb.w	r4, [r5, #326]	; 0x146
}
 1017efe:	bd38      	pop	{r3, r4, r5, pc}
		ull_tx_q_pause_data(&conn->tx_q);
 1017f00:	30d4      	adds	r0, #212	; 0xd4
 1017f02:	f7ff feb9 	bl	1017c78 <ull_tx_q_pause_data>
	conn->llcp.tx_q_pause_data_mask |= pause_mask;
 1017f06:	f895 3146 	ldrb.w	r3, [r5, #326]	; 0x146
 1017f0a:	431c      	orrs	r4, r3
 1017f0c:	f885 4146 	strb.w	r4, [r5, #326]	; 0x146
}
 1017f10:	bd38      	pop	{r3, r4, r5, pc}
 1017f12:	bf00      	nop

01017f14 <llcp_tx_resume_data>:
	conn->llcp.tx_q_pause_data_mask &= ~resume_mask;
 1017f14:	f890 3146 	ldrb.w	r3, [r0, #326]	; 0x146
 1017f18:	ea23 0101 	bic.w	r1, r3, r1
 1017f1c:	f880 1146 	strb.w	r1, [r0, #326]	; 0x146
	if (conn->llcp.tx_q_pause_data_mask == 0) {
 1017f20:	b101      	cbz	r1, 1017f24 <llcp_tx_resume_data+0x10>
}
 1017f22:	4770      	bx	lr
		ull_tx_q_resume_data(&conn->tx_q);
 1017f24:	30d4      	adds	r0, #212	; 0xd4
 1017f26:	f7ff beab 	b.w	1017c80 <ull_tx_q_resume_data>
 1017f2a:	bf00      	nop

01017f2c <llcp_create_local_procedure>:
{
 1017f2c:	b570      	push	{r4, r5, r6, lr}
	ctx = (struct proc_ctx *)mem_acquire(&owner->free);
 1017f2e:	4e20      	ldr	r6, [pc, #128]	; (1017fb0 <llcp_create_local_procedure+0x84>)
{
 1017f30:	4605      	mov	r5, r0
	ctx = (struct proc_ctx *)mem_acquire(&owner->free);
 1017f32:	4630      	mov	r0, r6
 1017f34:	f7f8 ff78 	bl	1010e28 <mem_acquire>
	if (ctx) {
 1017f38:	4604      	mov	r4, r0
 1017f3a:	b1e8      	cbz	r0, 1017f78 <llcp_create_local_procedure+0x4c>
	ctx->collision = 0U;
 1017f3c:	2100      	movs	r1, #0
		ctx->owner = owner;
 1017f3e:	6046      	str	r6, [r0, #4]
	ctx->proc = proc;
 1017f40:	7205      	strb	r5, [r0, #8]
	memset((void *)&ctx->data, 0, sizeof(ctx->data));
 1017f42:	222c      	movs	r2, #44	; 0x2c
 1017f44:	301c      	adds	r0, #28
	ctx->collision = 0U;
 1017f46:	6121      	str	r1, [r4, #16]
	ctx->done = 0U;
 1017f48:	61a1      	str	r1, [r4, #24]
	ctx->rx_greedy = 0U;
 1017f4a:	7321      	strb	r1, [r4, #12]
	ctx->tx_ack = NULL;
 1017f4c:	6161      	str	r1, [r4, #20]
	memset((void *)&ctx->data, 0, sizeof(ctx->data));
 1017f4e:	f00e fd1c 	bl	102698a <memset>
	ctx->rx_opcode = ULL_LLCP_INVALID_OPCODE;
 1017f52:	22ff      	movs	r2, #255	; 0xff
	switch (ctx->proc) {
 1017f54:	7a23      	ldrb	r3, [r4, #8]
	ctx->rx_opcode = ULL_LLCP_INVALID_OPCODE;
 1017f56:	72e2      	strb	r2, [r4, #11]
	switch (ctx->proc) {
 1017f58:	3b01      	subs	r3, #1
	ctx->tx_opcode = ULL_LLCP_INVALID_OPCODE;
 1017f5a:	7362      	strb	r2, [r4, #13]
	ctx->response_opcode = ULL_LLCP_INVALID_OPCODE;
 1017f5c:	7262      	strb	r2, [r4, #9]
	switch (ctx->proc) {
 1017f5e:	2b0b      	cmp	r3, #11
 1017f60:	d811      	bhi.n	1017f86 <llcp_create_local_procedure+0x5a>
 1017f62:	e8df f003 	tbb	[pc, r3]
 1017f66:	0606      	.short	0x0606
 1017f68:	10100606 	.word	0x10100606
 1017f6c:	060b0b1f 	.word	0x060b0b1f
 1017f70:	0610      	.short	0x0610
		llcp_lp_comm_init_proc(ctx);
 1017f72:	4620      	mov	r0, r4
 1017f74:	f001 f846 	bl	1019004 <llcp_lp_comm_init_proc>
}
 1017f78:	4620      	mov	r0, r4
 1017f7a:	bd70      	pop	{r4, r5, r6, pc}
		llcp_lp_cu_init_proc(ctx);
 1017f7c:	4620      	mov	r0, r4
 1017f7e:	f002 faab 	bl	101a4d8 <llcp_lp_cu_init_proc>
}
 1017f82:	4620      	mov	r0, r4
 1017f84:	bd70      	pop	{r4, r5, r6, pc}
		LL_ASSERT(0);
 1017f86:	f240 1381 	movw	r3, #385	; 0x181
 1017f8a:	4a0a      	ldr	r2, [pc, #40]	; (1017fb4 <llcp_create_local_procedure+0x88>)
 1017f8c:	490a      	ldr	r1, [pc, #40]	; (1017fb8 <llcp_create_local_procedure+0x8c>)
 1017f8e:	480b      	ldr	r0, [pc, #44]	; (1017fbc <llcp_create_local_procedure+0x90>)
 1017f90:	f00c fe21 	bl	1024bd6 <assert_print>
 1017f94:	4040      	eors	r0, r0
 1017f96:	f380 8811 	msr	BASEPRI, r0
 1017f9a:	f04f 0003 	mov.w	r0, #3
 1017f9e:	df02      	svc	2
}
 1017fa0:	4620      	mov	r0, r4
 1017fa2:	bd70      	pop	{r4, r5, r6, pc}
		llcp_lp_pu_init_proc(ctx);
 1017fa4:	4620      	mov	r0, r4
 1017fa6:	f7ff f9f3 	bl	1017390 <llcp_lp_pu_init_proc>
}
 1017faa:	4620      	mov	r0, r4
 1017fac:	bd70      	pop	{r4, r5, r6, pc}
 1017fae:	bf00      	nop
 1017fb0:	21000984 	.word	0x21000984
 1017fb4:	0102ab30 	.word	0x0102ab30
 1017fb8:	0102a300 	.word	0x0102a300
 1017fbc:	0102a278 	.word	0x0102a278

01017fc0 <llcp_create_remote_procedure>:
{
 1017fc0:	b570      	push	{r4, r5, r6, lr}
	ctx = (struct proc_ctx *)mem_acquire(&owner->free);
 1017fc2:	4e22      	ldr	r6, [pc, #136]	; (101804c <llcp_create_remote_procedure+0x8c>)
{
 1017fc4:	4605      	mov	r5, r0
	ctx = (struct proc_ctx *)mem_acquire(&owner->free);
 1017fc6:	4630      	mov	r0, r6
 1017fc8:	f7f8 ff2e 	bl	1010e28 <mem_acquire>
	if (ctx) {
 1017fcc:	4604      	mov	r4, r0
 1017fce:	b1e8      	cbz	r0, 101800c <llcp_create_remote_procedure+0x4c>
	ctx->collision = 0U;
 1017fd0:	2100      	movs	r1, #0
		ctx->owner = owner;
 1017fd2:	6046      	str	r6, [r0, #4]
	ctx->proc = proc;
 1017fd4:	7205      	strb	r5, [r0, #8]
	memset((void *)&ctx->data, 0, sizeof(ctx->data));
 1017fd6:	222c      	movs	r2, #44	; 0x2c
 1017fd8:	301c      	adds	r0, #28
	ctx->collision = 0U;
 1017fda:	6121      	str	r1, [r4, #16]
	ctx->done = 0U;
 1017fdc:	61a1      	str	r1, [r4, #24]
	ctx->rx_greedy = 0U;
 1017fde:	7321      	strb	r1, [r4, #12]
	ctx->tx_ack = NULL;
 1017fe0:	6161      	str	r1, [r4, #20]
	memset((void *)&ctx->data, 0, sizeof(ctx->data));
 1017fe2:	f00e fcd2 	bl	102698a <memset>
	ctx->rx_opcode = ULL_LLCP_INVALID_OPCODE;
 1017fe6:	23ff      	movs	r3, #255	; 0xff
	switch (ctx->proc) {
 1017fe8:	7a22      	ldrb	r2, [r4, #8]
	ctx->rx_opcode = ULL_LLCP_INVALID_OPCODE;
 1017fea:	72e3      	strb	r3, [r4, #11]
	ctx->tx_opcode = ULL_LLCP_INVALID_OPCODE;
 1017fec:	7363      	strb	r3, [r4, #13]
	ctx->response_opcode = ULL_LLCP_INVALID_OPCODE;
 1017fee:	7263      	strb	r3, [r4, #9]
	switch (ctx->proc) {
 1017ff0:	2a0c      	cmp	r2, #12
 1017ff2:	d81d      	bhi.n	1018030 <llcp_create_remote_procedure+0x70>
 1017ff4:	e8df f002 	tbb	[pc, r2]
 1017ff8:	0707070a 	.word	0x0707070a
 1017ffc:	180c0c07 	.word	0x180c0c07
 1018000:	14071010 	.word	0x14071010
 1018004:	07          	.byte	0x07
 1018005:	00          	.byte	0x00
		llcp_rp_comm_init_proc(ctx);
 1018006:	4620      	mov	r0, r4
 1018008:	f001 f810 	bl	101902c <llcp_rp_comm_init_proc>
}
 101800c:	4620      	mov	r0, r4
 101800e:	bd70      	pop	{r4, r5, r6, pc}
		llcp_rp_enc_init_proc(ctx);
 1018010:	4620      	mov	r0, r4
 1018012:	f7ff fdf5 	bl	1017c00 <llcp_rp_enc_init_proc>
		break;
 1018016:	e7f9      	b.n	101800c <llcp_create_remote_procedure+0x4c>
		llcp_rp_cu_init_proc(ctx);
 1018018:	4620      	mov	r0, r4
 101801a:	f002 fa8b 	bl	101a534 <llcp_rp_cu_init_proc>
		break;
 101801e:	e7f5      	b.n	101800c <llcp_create_remote_procedure+0x4c>
		llcp_rp_chmu_init_proc(ctx);
 1018020:	4620      	mov	r0, r4
 1018022:	f002 fadb 	bl	101a5dc <llcp_rp_chmu_init_proc>
		break;
 1018026:	e7f1      	b.n	101800c <llcp_create_remote_procedure+0x4c>
		llcp_rp_pu_init_proc(ctx);
 1018028:	4620      	mov	r0, r4
 101802a:	f7ff fb43 	bl	10176b4 <llcp_rp_pu_init_proc>
		break;
 101802e:	e7ed      	b.n	101800c <llcp_create_remote_procedure+0x4c>
		LL_ASSERT(0);
 1018030:	f44f 73ec 	mov.w	r3, #472	; 0x1d8
 1018034:	4a06      	ldr	r2, [pc, #24]	; (1018050 <llcp_create_remote_procedure+0x90>)
 1018036:	4907      	ldr	r1, [pc, #28]	; (1018054 <llcp_create_remote_procedure+0x94>)
 1018038:	4807      	ldr	r0, [pc, #28]	; (1018058 <llcp_create_remote_procedure+0x98>)
 101803a:	f00c fdcc 	bl	1024bd6 <assert_print>
 101803e:	4040      	eors	r0, r0
 1018040:	f380 8811 	msr	BASEPRI, r0
 1018044:	f04f 0003 	mov.w	r0, #3
 1018048:	df02      	svc	2
		break;
 101804a:	e7df      	b.n	101800c <llcp_create_remote_procedure+0x4c>
 101804c:	2100097c 	.word	0x2100097c
 1018050:	0102ab30 	.word	0x0102ab30
 1018054:	0102a300 	.word	0x0102a300
 1018058:	0102a278 	.word	0x0102a278

0101805c <ull_cp_init>:
{
 101805c:	b510      	push	{r4, lr}
	mem_init(mem_local_ctx.pool, PROC_CTX_BUF_SIZE,
 101805e:	4b0a      	ldr	r3, [pc, #40]	; (1018088 <ull_cp_init+0x2c>)
 1018060:	2208      	movs	r2, #8
 1018062:	6858      	ldr	r0, [r3, #4]
 1018064:	214c      	movs	r1, #76	; 0x4c
 1018066:	f7f8 feaf 	bl	1010dc8 <mem_init>
	mem_init(mem_remote_ctx.pool, PROC_CTX_BUF_SIZE,
 101806a:	4b08      	ldr	r3, [pc, #32]	; (101808c <ull_cp_init+0x30>)
 101806c:	2208      	movs	r2, #8
 101806e:	6858      	ldr	r0, [r3, #4]
 1018070:	214c      	movs	r1, #76	; 0x4c
 1018072:	f7f8 fea9 	bl	1010dc8 <mem_init>
}
 1018076:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	mem_init(mem_tx.pool, TX_CTRL_BUF_SIZE, LLCP_TX_CTRL_BUF_COUNT, &mem_tx.free);
 101807a:	4b05      	ldr	r3, [pc, #20]	; (1018090 <ull_cp_init+0x34>)
 101807c:	2220      	movs	r2, #32
 101807e:	212c      	movs	r1, #44	; 0x2c
 1018080:	6858      	ldr	r0, [r3, #4]
 1018082:	f7f8 bea1 	b.w	1010dc8 <mem_init>
 1018086:	bf00      	nop
 1018088:	21000984 	.word	0x21000984
 101808c:	2100097c 	.word	0x2100097c
 1018090:	2100098c 	.word	0x2100098c

01018094 <ull_llcp_init>:
{
 1018094:	b538      	push	{r3, r4, r5, lr}
 1018096:	4604      	mov	r4, r0
	list->head = NULL;
 1018098:	2500      	movs	r5, #0
	llcp_lr_init(conn);
 101809a:	f001 f9ff 	bl	101949c <llcp_lr_init>
	llcp_rr_init(conn);
 101809e:	4620      	mov	r0, r4
	list->tail = NULL;
 10180a0:	e9c4 553a 	strd	r5, r5, [r4, #232]	; 0xe8
	conn->llcp.local.pause = 0U;
 10180a4:	f884 50f4 	strb.w	r5, [r4, #244]	; 0xf4
	llcp_rr_init(conn);
 10180a8:	f002 fd8c 	bl	101abc4 <llcp_rr_init>
	memset(&conn->llcp.vex, 0, sizeof(conn->llcp.vex));
 10180ac:	2207      	movs	r2, #7
 10180ae:	4629      	mov	r1, r5
 10180b0:	e9c4 553e 	strd	r5, r5, [r4, #248]	; 0xf8
	conn->llcp.remote.incompat = INCOMPAT_NO_COLLISION;
 10180b4:	f884 5106 	strb.w	r5, [r4, #262]	; 0x106
	conn->llcp.remote.pause = 0U;
 10180b8:	f8a4 5104 	strh.w	r5, [r4, #260]	; 0x104
	conn->llcp.prt_reload = 0U;
 10180bc:	f8a4 5108 	strh.w	r5, [r4, #264]	; 0x108
	memset(&conn->llcp.vex, 0, sizeof(conn->llcp.vex));
 10180c0:	f504 708a 	add.w	r0, r4, #276	; 0x114
 10180c4:	f00e fc61 	bl	102698a <memset>
	memset(&conn->llcp.muc, 0, sizeof(conn->llcp.muc));
 10180c8:	2202      	movs	r2, #2
 10180ca:	4629      	mov	r1, r5
 10180cc:	f504 709c 	add.w	r0, r4, #312	; 0x138
 10180d0:	f00e fc5b 	bl	102698a <memset>
	memset(&conn->llcp.fex, 0, sizeof(conn->llcp.fex));
 10180d4:	4629      	mov	r1, r5
 10180d6:	2218      	movs	r2, #24
 10180d8:	f504 7090 	add.w	r0, r4, #288	; 0x120
 10180dc:	f00e fc55 	bl	102698a <memset>
	conn->llcp.fex.features_used = LL_FEAT;
 10180e0:	2100      	movs	r1, #0
 10180e2:	4806      	ldr	r0, [pc, #24]	; (10180fc <ull_llcp_init+0x68>)
	conn->lll.enc_rx = 0U;
 10180e4:	f894 308e 	ldrb.w	r3, [r4, #142]	; 0x8e
	conn->llcp.fex.features_used = LL_FEAT;
 10180e8:	e9c4 014c 	strd	r0, r1, [r4, #304]	; 0x130
	conn->lll.enc_rx = 0U;
 10180ec:	f023 0318 	bic.w	r3, r3, #24
	conn->llcp.tx_q_pause_data_mask = 0;
 10180f0:	f884 5146 	strb.w	r5, [r4, #326]	; 0x146
	conn->lll.enc_rx = 0U;
 10180f4:	f884 308e 	strb.w	r3, [r4, #142]	; 0x8e
	conn->lll.event_counter = 0;
 10180f8:	8665      	strh	r5, [r4, #50]	; 0x32
}
 10180fa:	bd38      	pop	{r3, r4, r5, pc}
 10180fc:	0001413f 	.word	0x0001413f

01018100 <ull_cp_release_tx>:
{
 1018100:	4608      	mov	r0, r1
	mem_release(tx, &mem_tx.free);
 1018102:	4901      	ldr	r1, [pc, #4]	; (1018108 <ull_cp_release_tx+0x8>)
 1018104:	f7f8 beac 	b.w	1010e60 <mem_release>
 1018108:	2100098c 	.word	0x2100098c

0101810c <ull_cp_prt_elapse>:
{
 101810c:	b538      	push	{r3, r4, r5, lr}
 101810e:	4614      	mov	r4, r2
	if (*expire != 0U) {
 1018110:	f8b0 20f2 	ldrh.w	r2, [r0, #242]	; 0xf2
{
 1018114:	4603      	mov	r3, r0
	if (*expire != 0U) {
 1018116:	b122      	cbz	r2, 1018122 <ull_cp_prt_elapse+0x16>
		if (*expire > elapsed_event) {
 1018118:	4291      	cmp	r1, r2
 101811a:	d20e      	bcs.n	101813a <ull_cp_prt_elapse+0x2e>
			*expire -= elapsed_event;
 101811c:	1a52      	subs	r2, r2, r1
 101811e:	f8a0 20f2 	strh.w	r2, [r0, #242]	; 0xf2
	if (*expire != 0U) {
 1018122:	f8b3 2102 	ldrh.w	r2, [r3, #258]	; 0x102
 1018126:	b122      	cbz	r2, 1018132 <ull_cp_prt_elapse+0x26>
		if (*expire > elapsed_event) {
 1018128:	4291      	cmp	r1, r2
 101812a:	d20d      	bcs.n	1018148 <ull_cp_prt_elapse+0x3c>
			*expire -= elapsed_event;
 101812c:	1a52      	subs	r2, r2, r1
 101812e:	f8a3 2102 	strh.w	r2, [r3, #258]	; 0x102
	return 0;
 1018132:	2300      	movs	r3, #0
 1018134:	4618      	mov	r0, r3
			*error_code = ctx->data.term.error_code;
 1018136:	7023      	strb	r3, [r4, #0]
}
 1018138:	bd38      	pop	{r3, r4, r5, pc}
		ctx = llcp_lr_peek(conn);
 101813a:	f001 f859 	bl	10191f0 <llcp_lr_peek>
		LL_ASSERT(ctx);
 101813e:	4605      	mov	r5, r0
 1018140:	b150      	cbz	r0, 1018158 <ull_cp_prt_elapse+0x4c>
		if (ctx->proc == PROC_TERMINATE) {
 1018142:	7a2b      	ldrb	r3, [r5, #8]
 1018144:	2b0a      	cmp	r3, #10
 1018146:	d003      	beq.n	1018150 <ull_cp_prt_elapse+0x44>
	return 0;
 1018148:	2322      	movs	r3, #34	; 0x22
		return -ETIMEDOUT;
 101814a:	f06f 0073 	mvn.w	r0, #115	; 0x73
 101814e:	e7f2      	b.n	1018136 <ull_cp_prt_elapse+0x2a>
 1018150:	f06f 0073 	mvn.w	r0, #115	; 0x73
			*error_code = ctx->data.term.error_code;
 1018154:	7f2b      	ldrb	r3, [r5, #28]
 1018156:	e7ee      	b.n	1018136 <ull_cp_prt_elapse+0x2a>
		LL_ASSERT(ctx);
 1018158:	f44f 7318 	mov.w	r3, #608	; 0x260
 101815c:	4a05      	ldr	r2, [pc, #20]	; (1018174 <ull_cp_prt_elapse+0x68>)
 101815e:	4906      	ldr	r1, [pc, #24]	; (1018178 <ull_cp_prt_elapse+0x6c>)
 1018160:	4806      	ldr	r0, [pc, #24]	; (101817c <ull_cp_prt_elapse+0x70>)
 1018162:	f00c fd38 	bl	1024bd6 <assert_print>
 1018166:	4040      	eors	r0, r0
 1018168:	f380 8811 	msr	BASEPRI, r0
 101816c:	f04f 0003 	mov.w	r0, #3
 1018170:	df02      	svc	2
 1018172:	e7e6      	b.n	1018142 <ull_cp_prt_elapse+0x36>
 1018174:	0102ab30 	.word	0x0102ab30
 1018178:	0102ab7c 	.word	0x0102ab7c
 101817c:	0102a278 	.word	0x0102a278

01018180 <ull_cp_prt_reload_set>:
	conn->llcp.prt_reload = RADIO_CONN_EVENTS((40U * 1000U * 1000U), conn_intv_us);
 1018180:	4b03      	ldr	r3, [pc, #12]	; (1018190 <ull_cp_prt_reload_set+0x10>)
 1018182:	440b      	add	r3, r1
 1018184:	fbb3 f3f1 	udiv	r3, r3, r1
 1018188:	f8a0 3108 	strh.w	r3, [r0, #264]	; 0x108
}
 101818c:	4770      	bx	lr
 101818e:	bf00      	nop
 1018190:	026259ff 	.word	0x026259ff

01018194 <ull_cp_run>:
{
 1018194:	b510      	push	{r4, lr}
 1018196:	4604      	mov	r4, r0
	llcp_rr_run(conn);
 1018198:	f002 fd1c 	bl	101abd4 <llcp_rr_run>
	llcp_lr_run(conn);
 101819c:	4620      	mov	r0, r4
}
 101819e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	llcp_lr_run(conn);
 10181a2:	f001 b983 	b.w	10194ac <llcp_lr_run>
 10181a6:	bf00      	nop

010181a8 <ull_cp_state_set>:
{
 10181a8:	b510      	push	{r4, lr}
 10181aa:	4604      	mov	r4, r0
	switch (state) {
 10181ac:	b111      	cbz	r1, 10181b4 <ull_cp_state_set+0xc>
 10181ae:	2901      	cmp	r1, #1
 10181b0:	d007      	beq.n	10181c2 <ull_cp_state_set+0x1a>
}
 10181b2:	bd10      	pop	{r4, pc}
		llcp_rr_connect(conn);
 10181b4:	f002 fd16 	bl	101abe4 <llcp_rr_connect>
		llcp_lr_connect(conn);
 10181b8:	4620      	mov	r0, r4
}
 10181ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		llcp_lr_connect(conn);
 10181be:	f001 b9a1 	b.w	1019504 <llcp_lr_connect>
		llcp_rr_disconnect(conn);
 10181c2:	f002 fd13 	bl	101abec <llcp_rr_disconnect>
		llcp_lr_disconnect(conn);
 10181c6:	4620      	mov	r0, r4
}
 10181c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		llcp_lr_disconnect(conn);
 10181cc:	f001 b9bc 	b.w	1019548 <llcp_lr_disconnect>

010181d0 <ull_cp_min_used_chans>:
	if (conn->lll.role != BT_HCI_ROLE_PERIPHERAL) {
 10181d0:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
 10181d4:	2b00      	cmp	r3, #0
 10181d6:	da11      	bge.n	10181fc <ull_cp_min_used_chans+0x2c>
{
 10181d8:	b570      	push	{r4, r5, r6, lr}
 10181da:	4604      	mov	r4, r0
	ctx = llcp_create_local_procedure(PROC_MIN_USED_CHANS);
 10181dc:	2003      	movs	r0, #3
 10181de:	460e      	mov	r6, r1
 10181e0:	4615      	mov	r5, r2
 10181e2:	f7ff fea3 	bl	1017f2c <llcp_create_local_procedure>
	if (!ctx) {
 10181e6:	4601      	mov	r1, r0
 10181e8:	b130      	cbz	r0, 10181f8 <ull_cp_min_used_chans+0x28>
	llcp_lr_enqueue(conn, ctx);
 10181ea:	4620      	mov	r0, r4
	ctx->data.muc.phys = phys;
 10181ec:	770e      	strb	r6, [r1, #28]
	ctx->data.muc.min_used_chans = min_used_chans;
 10181ee:	774d      	strb	r5, [r1, #29]
	llcp_lr_enqueue(conn, ctx);
 10181f0:	f000 ffca 	bl	1019188 <llcp_lr_enqueue>
	return BT_HCI_ERR_SUCCESS;
 10181f4:	2000      	movs	r0, #0
}
 10181f6:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 10181f8:	200c      	movs	r0, #12
}
 10181fa:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 10181fc:	200c      	movs	r0, #12
}
 10181fe:	4770      	bx	lr

01018200 <ull_cp_le_ping>:
{
 1018200:	b510      	push	{r4, lr}
 1018202:	4604      	mov	r4, r0
	ctx = llcp_create_local_procedure(PROC_LE_PING);
 1018204:	2001      	movs	r0, #1
 1018206:	f7ff fe91 	bl	1017f2c <llcp_create_local_procedure>
	if (!ctx) {
 101820a:	b128      	cbz	r0, 1018218 <ull_cp_le_ping+0x18>
 101820c:	4601      	mov	r1, r0
	llcp_lr_enqueue(conn, ctx);
 101820e:	4620      	mov	r0, r4
 1018210:	f000 ffba 	bl	1019188 <llcp_lr_enqueue>
	return BT_HCI_ERR_SUCCESS;
 1018214:	2000      	movs	r0, #0
}
 1018216:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 1018218:	200c      	movs	r0, #12
}
 101821a:	bd10      	pop	{r4, pc}

0101821c <ull_cp_feature_exchange>:
{
 101821c:	b510      	push	{r4, lr}
 101821e:	4604      	mov	r4, r0
	ctx = llcp_create_local_procedure(PROC_FEATURE_EXCHANGE);
 1018220:	2002      	movs	r0, #2
 1018222:	f7ff fe83 	bl	1017f2c <llcp_create_local_procedure>
	if (!ctx) {
 1018226:	b128      	cbz	r0, 1018234 <ull_cp_feature_exchange+0x18>
 1018228:	4601      	mov	r1, r0
	llcp_lr_enqueue(conn, ctx);
 101822a:	4620      	mov	r0, r4
 101822c:	f000 ffac 	bl	1019188 <llcp_lr_enqueue>
	return BT_HCI_ERR_SUCCESS;
 1018230:	2000      	movs	r0, #0
}
 1018232:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 1018234:	200c      	movs	r0, #12
}
 1018236:	bd10      	pop	{r4, pc}

01018238 <ull_cp_version_exchange>:
{
 1018238:	b510      	push	{r4, lr}
 101823a:	4604      	mov	r4, r0
	ctx = llcp_create_local_procedure(PROC_VERSION_EXCHANGE);
 101823c:	2004      	movs	r0, #4
 101823e:	f7ff fe75 	bl	1017f2c <llcp_create_local_procedure>
	if (!ctx) {
 1018242:	b128      	cbz	r0, 1018250 <ull_cp_version_exchange+0x18>
 1018244:	4601      	mov	r1, r0
	llcp_lr_enqueue(conn, ctx);
 1018246:	4620      	mov	r0, r4
 1018248:	f000 ff9e 	bl	1019188 <llcp_lr_enqueue>
	return BT_HCI_ERR_SUCCESS;
 101824c:	2000      	movs	r0, #0
}
 101824e:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 1018250:	200c      	movs	r0, #12
}
 1018252:	bd10      	pop	{r4, pc}

01018254 <ull_cp_phy_update>:
{
 1018254:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1018258:	4605      	mov	r5, r0
	ctx = llcp_create_local_procedure(PROC_PHY_UPDATE);
 101825a:	2007      	movs	r0, #7
{
 101825c:	4688      	mov	r8, r1
 101825e:	4617      	mov	r7, r2
 1018260:	461c      	mov	r4, r3
 1018262:	f89d 6018 	ldrb.w	r6, [sp, #24]
	ctx = llcp_create_local_procedure(PROC_PHY_UPDATE);
 1018266:	f7ff fe61 	bl	1017f2c <llcp_create_local_procedure>
	if (!ctx) {
 101826a:	b1a0      	cbz	r0, 1018296 <ull_cp_phy_update+0x42>
	ctx->data.pu.host_initiated = host_initiated;
 101826c:	4601      	mov	r1, r0
	ctx->data.pu.tx = tx;
 101826e:	00e3      	lsls	r3, r4, #3
 1018270:	f008 0807 	and.w	r8, r8, #7
 1018274:	f003 0338 	and.w	r3, r3, #56	; 0x38
 1018278:	01bf      	lsls	r7, r7, #6
 101827a:	ea43 0308 	orr.w	r3, r3, r8
 101827e:	f007 0740 	and.w	r7, r7, #64	; 0x40
 1018282:	433b      	orrs	r3, r7
 1018284:	ea43 13c6 	orr.w	r3, r3, r6, lsl #7
	llcp_lr_enqueue(conn, ctx);
 1018288:	4628      	mov	r0, r5
	ctx->data.pu.tx = tx;
 101828a:	770b      	strb	r3, [r1, #28]
	llcp_lr_enqueue(conn, ctx);
 101828c:	f000 ff7c 	bl	1019188 <llcp_lr_enqueue>
	return BT_HCI_ERR_SUCCESS;
 1018290:	2000      	movs	r0, #0
}
 1018292:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 1018296:	200c      	movs	r0, #12
}
 1018298:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0101829c <ull_cp_terminate>:
{
 101829c:	b538      	push	{r3, r4, r5, lr}
 101829e:	4605      	mov	r5, r0
 10182a0:	460c      	mov	r4, r1
	llcp_lr_abort(conn);
 10182a2:	f001 f955 	bl	1019550 <llcp_lr_abort>
	ctx = llcp_create_local_procedure(PROC_TERMINATE);
 10182a6:	200a      	movs	r0, #10
 10182a8:	f7ff fe40 	bl	1017f2c <llcp_create_local_procedure>
	if (!ctx) {
 10182ac:	b130      	cbz	r0, 10182bc <ull_cp_terminate+0x20>
 10182ae:	4601      	mov	r1, r0
	llcp_lr_enqueue(conn, ctx);
 10182b0:	4628      	mov	r0, r5
	ctx->data.term.error_code = error_code;
 10182b2:	770c      	strb	r4, [r1, #28]
	llcp_lr_enqueue(conn, ctx);
 10182b4:	f000 ff68 	bl	1019188 <llcp_lr_enqueue>
	return BT_HCI_ERR_SUCCESS;
 10182b8:	2000      	movs	r0, #0
}
 10182ba:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 10182bc:	200c      	movs	r0, #12
}
 10182be:	bd38      	pop	{r3, r4, r5, pc}

010182c0 <ull_cp_chan_map_update_pending>:
{
 10182c0:	b508      	push	{r3, lr}
	if (conn->lll.role == BT_HCI_ROLE_CENTRAL) {
 10182c2:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
 10182c6:	2b00      	cmp	r3, #0
 10182c8:	db08      	blt.n	10182dc <ull_cp_chan_map_update_pending+0x1c>
		ctx = llcp_lr_peek(conn);
 10182ca:	f000 ff91 	bl	10191f0 <llcp_lr_peek>
	if (ctx && ctx->proc == PROC_CHAN_MAP_UPDATE) {
 10182ce:	b120      	cbz	r0, 10182da <ull_cp_chan_map_update_pending+0x1a>
 10182d0:	7a03      	ldrb	r3, [r0, #8]
 10182d2:	2b0b      	cmp	r3, #11
	return NULL;
 10182d4:	bf14      	ite	ne
 10182d6:	2000      	movne	r0, #0
		return ctx->data.chmu.chm;
 10182d8:	301e      	addeq	r0, #30
}
 10182da:	bd08      	pop	{r3, pc}
		ctx = llcp_rr_peek(conn);
 10182dc:	f002 fbf4 	bl	101aac8 <llcp_rr_peek>
 10182e0:	e7f5      	b.n	10182ce <ull_cp_chan_map_update_pending+0xe>
 10182e2:	bf00      	nop

010182e4 <ull_cp_data_length_update>:
{
 10182e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10182e6:	4605      	mov	r5, r0
	ctx = llcp_create_local_procedure(PROC_DATA_LENGTH_UPDATE);
 10182e8:	200c      	movs	r0, #12
{
 10182ea:	460e      	mov	r6, r1
 10182ec:	4617      	mov	r7, r2
	ctx = llcp_create_local_procedure(PROC_DATA_LENGTH_UPDATE);
 10182ee:	f7ff fe1d 	bl	1017f2c <llcp_create_local_procedure>
	if (!ctx) {
 10182f2:	b158      	cbz	r0, 101830c <ull_cp_data_length_update+0x28>
 10182f4:	4604      	mov	r4, r0
	ull_dle_local_tx_update(conn, max_tx_octets, max_tx_time);
 10182f6:	463a      	mov	r2, r7
 10182f8:	4631      	mov	r1, r6
 10182fa:	4628      	mov	r0, r5
 10182fc:	f7fe fc62 	bl	1016bc4 <ull_dle_local_tx_update>
	llcp_lr_enqueue(conn, ctx);
 1018300:	4628      	mov	r0, r5
 1018302:	4621      	mov	r1, r4
 1018304:	f000 ff40 	bl	1019188 <llcp_lr_enqueue>
	return BT_HCI_ERR_SUCCESS;
 1018308:	2000      	movs	r0, #0
}
 101830a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 101830c:	200c      	movs	r0, #12
}
 101830e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

01018310 <ull_cp_ltk_req_reply>:
{
 1018310:	b570      	push	{r4, r5, r6, lr}
 1018312:	4605      	mov	r5, r0
 1018314:	460e      	mov	r6, r1
	ctx = llcp_rr_peek(conn);
 1018316:	f002 fbd7 	bl	101aac8 <llcp_rr_peek>
	if (ctx && (ctx->proc == PROC_ENCRYPTION_START || ctx->proc == PROC_ENCRYPTION_PAUSE) &&
 101831a:	b120      	cbz	r0, 1018326 <ull_cp_ltk_req_reply+0x16>
 101831c:	7a03      	ldrb	r3, [r0, #8]
 101831e:	4604      	mov	r4, r0
 1018320:	3b05      	subs	r3, #5
 1018322:	2b01      	cmp	r3, #1
 1018324:	d901      	bls.n	101832a <ull_cp_ltk_req_reply+0x1a>
	return BT_HCI_ERR_CMD_DISALLOWED;
 1018326:	200c      	movs	r0, #12
}
 1018328:	bd70      	pop	{r4, r5, r6, pc}
	    llcp_rp_enc_ltk_req_reply_allowed(conn, ctx)) {
 101832a:	4601      	mov	r1, r0
 101832c:	4628      	mov	r0, r5
 101832e:	f7ff fc8f 	bl	1017c50 <llcp_rp_enc_ltk_req_reply_allowed>
	if (ctx && (ctx->proc == PROC_ENCRYPTION_START || ctx->proc == PROC_ENCRYPTION_PAUSE) &&
 1018332:	2800      	cmp	r0, #0
 1018334:	d0f7      	beq.n	1018326 <ull_cp_ltk_req_reply+0x16>
		memcpy(ctx->data.enc.ltk, ltk, sizeof(ctx->data.enc.ltk));
 1018336:	2210      	movs	r2, #16
 1018338:	4631      	mov	r1, r6
 101833a:	f104 0027 	add.w	r0, r4, #39	; 0x27
 101833e:	f00e fb19 	bl	1026974 <memcpy>
		llcp_rp_enc_ltk_req_reply(conn, ctx);
 1018342:	4628      	mov	r0, r5
 1018344:	4621      	mov	r1, r4
 1018346:	f7ff fc7b 	bl	1017c40 <llcp_rp_enc_ltk_req_reply>
		return BT_HCI_ERR_SUCCESS;
 101834a:	2000      	movs	r0, #0
}
 101834c:	bd70      	pop	{r4, r5, r6, pc}
 101834e:	bf00      	nop

01018350 <ull_cp_ltk_req_neq_reply>:
{
 1018350:	b538      	push	{r3, r4, r5, lr}
 1018352:	4605      	mov	r5, r0
	ctx = llcp_rr_peek(conn);
 1018354:	f002 fbb8 	bl	101aac8 <llcp_rr_peek>
	if (ctx && (ctx->proc == PROC_ENCRYPTION_START || ctx->proc == PROC_ENCRYPTION_PAUSE) &&
 1018358:	b120      	cbz	r0, 1018364 <ull_cp_ltk_req_neq_reply+0x14>
 101835a:	7a03      	ldrb	r3, [r0, #8]
 101835c:	4604      	mov	r4, r0
 101835e:	3b05      	subs	r3, #5
 1018360:	2b01      	cmp	r3, #1
 1018362:	d901      	bls.n	1018368 <ull_cp_ltk_req_neq_reply+0x18>
	return BT_HCI_ERR_CMD_DISALLOWED;
 1018364:	200c      	movs	r0, #12
}
 1018366:	bd38      	pop	{r3, r4, r5, pc}
	    llcp_rp_enc_ltk_req_reply_allowed(conn, ctx)) {
 1018368:	4601      	mov	r1, r0
 101836a:	4628      	mov	r0, r5
 101836c:	f7ff fc70 	bl	1017c50 <llcp_rp_enc_ltk_req_reply_allowed>
	if (ctx && (ctx->proc == PROC_ENCRYPTION_START || ctx->proc == PROC_ENCRYPTION_PAUSE) &&
 1018370:	2800      	cmp	r0, #0
 1018372:	d0f7      	beq.n	1018364 <ull_cp_ltk_req_neq_reply+0x14>
		llcp_rp_enc_ltk_req_neg_reply(conn, ctx);
 1018374:	4628      	mov	r0, r5
 1018376:	4621      	mov	r1, r4
 1018378:	f7ff fc66 	bl	1017c48 <llcp_rp_enc_ltk_req_neg_reply>
		return BT_HCI_ERR_SUCCESS;
 101837c:	2000      	movs	r0, #0
}
 101837e:	bd38      	pop	{r3, r4, r5, pc}

01018380 <ull_cp_conn_update>:
{
 1018380:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1018384:	4605      	mov	r5, r0
	return (conn->llcp.fex.features_used & LL_FEAT_BIT_CONN_PARAM_REQ) != 0;
 1018386:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
 101838a:	469a      	mov	sl, r3
	if (feature_conn_param_req(conn)) {
 101838c:	0783      	lsls	r3, r0, #30
{
 101838e:	460f      	mov	r7, r1
 1018390:	4616      	mov	r6, r2
 1018392:	f8bd 9020 	ldrh.w	r9, [sp, #32]
 1018396:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
	if (feature_conn_param_req(conn)) {
 101839a:	d435      	bmi.n	1018408 <ull_cp_conn_update+0x88>
	} else if (conn->lll.role == BT_HCI_ROLE_CENTRAL) {
 101839c:	f995 3039 	ldrsb.w	r3, [r5, #57]	; 0x39
 10183a0:	2b00      	cmp	r3, #0
 10183a2:	db50      	blt.n	1018446 <ull_cp_conn_update+0xc6>
		ctx = llcp_create_local_procedure(PROC_CONN_UPDATE);
 10183a4:	2008      	movs	r0, #8
 10183a6:	f7ff fdc1 	bl	1017f2c <llcp_create_local_procedure>
 10183aa:	4604      	mov	r4, r0
	if (!ctx) {
 10183ac:	2c00      	cmp	r4, #0
 10183ae:	d058      	beq.n	1018462 <ull_cp_conn_update+0xe2>
	if (ctx->proc == PROC_CONN_UPDATE) {
 10183b0:	7a23      	ldrb	r3, [r4, #8]
 10183b2:	2b08      	cmp	r3, #8
 10183b4:	d02d      	beq.n	1018412 <ull_cp_conn_update+0x92>
	} else if (ctx->proc == PROC_CONN_PARAM_REQ) {
 10183b6:	2b09      	cmp	r3, #9
 10183b8:	d137      	bne.n	101842a <ull_cp_conn_update+0xaa>
		ctx->data.cu.interval_min = interval_min;
 10183ba:	84e7      	strh	r7, [r4, #38]	; 0x26
		ctx->data.cu.interval_max = interval_max;
 10183bc:	8526      	strh	r6, [r4, #40]	; 0x28
		ctx->data.cu.latency = latency;
 10183be:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
		ctx->data.cu.timeout = timeout;
 10183c2:	f8a4 902c 	strh.w	r9, [r4, #44]	; 0x2c
		ctx->data.cu.offsets[0] = offsets ? offsets[0] : 0x0000;
 10183c6:	f1b8 0f00 	cmp.w	r8, #0
 10183ca:	d03f      	beq.n	101844c <ull_cp_conn_update+0xcc>
 10183cc:	f8b8 3000 	ldrh.w	r3, [r8]
 10183d0:	8663      	strh	r3, [r4, #50]	; 0x32
		ctx->data.cu.offsets[1] = offsets ? offsets[1] : 0xffff;
 10183d2:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 10183d6:	86a3      	strh	r3, [r4, #52]	; 0x34
		ctx->data.cu.offsets[2] = offsets ? offsets[2] : 0xffff;
 10183d8:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 10183dc:	86e3      	strh	r3, [r4, #54]	; 0x36
		ctx->data.cu.offsets[3] = offsets ? offsets[3] : 0xffff;
 10183de:	f8b8 3006 	ldrh.w	r3, [r8, #6]
 10183e2:	8723      	strh	r3, [r4, #56]	; 0x38
		ctx->data.cu.offsets[4] = offsets ? offsets[4] : 0xffff;
 10183e4:	f8b8 3008 	ldrh.w	r3, [r8, #8]
 10183e8:	8763      	strh	r3, [r4, #58]	; 0x3a
		ctx->data.cu.offsets[5] = offsets ? offsets[5] : 0xffff;
 10183ea:	f8b8 300a 	ldrh.w	r3, [r8, #10]
 10183ee:	87a3      	strh	r3, [r4, #60]	; 0x3c
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
 10183f0:	f995 3039 	ldrsb.w	r3, [r5, #57]	; 0x39
 10183f4:	2b00      	cmp	r3, #0
 10183f6:	da11      	bge.n	101841c <ull_cp_conn_update+0x9c>
			uint16_t handle = ll_conn_handle_get(conn);
 10183f8:	4628      	mov	r0, r5
 10183fa:	f7fd fb93 	bl	1015b24 <ll_conn_handle_get>
 10183fe:	4601      	mov	r1, r0
			ull_periph_latency_cancel(conn, handle);
 1018400:	4628      	mov	r0, r5
 1018402:	f002 fd11 	bl	101ae28 <ull_periph_latency_cancel>
 1018406:	e009      	b.n	101841c <ull_cp_conn_update+0x9c>
		ctx = llcp_create_local_procedure(PROC_CONN_PARAM_REQ);
 1018408:	2009      	movs	r0, #9
 101840a:	f7ff fd8f 	bl	1017f2c <llcp_create_local_procedure>
 101840e:	4604      	mov	r4, r0
 1018410:	e7cc      	b.n	10183ac <ull_cp_conn_update+0x2c>
		ctx->data.cu.interval_max = interval_max;
 1018412:	8526      	strh	r6, [r4, #40]	; 0x28
		ctx->data.cu.latency = latency;
 1018414:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
		ctx->data.cu.timeout = timeout;
 1018418:	f8a4 902c 	strh.w	r9, [r4, #44]	; 0x2c
	llcp_lr_enqueue(conn, ctx);
 101841c:	4628      	mov	r0, r5
 101841e:	4621      	mov	r1, r4
 1018420:	f000 feb2 	bl	1019188 <llcp_lr_enqueue>
	return BT_HCI_ERR_SUCCESS;
 1018424:	2000      	movs	r0, #0
}
 1018426:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		LL_ASSERT(0); /* Unknown procedure */
 101842a:	f240 4334 	movw	r3, #1076	; 0x434
 101842e:	4a0e      	ldr	r2, [pc, #56]	; (1018468 <ull_cp_conn_update+0xe8>)
 1018430:	490e      	ldr	r1, [pc, #56]	; (101846c <ull_cp_conn_update+0xec>)
 1018432:	480f      	ldr	r0, [pc, #60]	; (1018470 <ull_cp_conn_update+0xf0>)
 1018434:	f00c fbcf 	bl	1024bd6 <assert_print>
 1018438:	4040      	eors	r0, r0
 101843a:	f380 8811 	msr	BASEPRI, r0
 101843e:	f04f 0003 	mov.w	r0, #3
 1018442:	df02      	svc	2
 1018444:	e7ea      	b.n	101841c <ull_cp_conn_update+0x9c>
		return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 1018446:	201a      	movs	r0, #26
}
 1018448:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		ctx->data.cu.offsets[0] = offsets ? offsets[0] : 0x0000;
 101844c:	f04f 32ff 	mov.w	r2, #4294967295
 1018450:	4908      	ldr	r1, [pc, #32]	; (1018474 <ull_cp_conn_update+0xf4>)
		ctx->data.cu.offsets[5] = offsets ? offsets[5] : 0xffff;
 1018452:	f64f 73ff 	movw	r3, #65535	; 0xffff
		ctx->data.cu.offsets[0] = offsets ? offsets[0] : 0x0000;
 1018456:	f8c4 1032 	str.w	r1, [r4, #50]	; 0x32
 101845a:	f8c4 2036 	str.w	r2, [r4, #54]	; 0x36
		ctx->data.cu.offsets[4] = offsets ? offsets[4] : 0xffff;
 101845e:	8762      	strh	r2, [r4, #58]	; 0x3a
		ctx->data.cu.offsets[5] = offsets ? offsets[5] : 0xffff;
 1018460:	e7c5      	b.n	10183ee <ull_cp_conn_update+0x6e>
		return BT_HCI_ERR_CMD_DISALLOWED;
 1018462:	200c      	movs	r0, #12
 1018464:	e7df      	b.n	1018426 <ull_cp_conn_update+0xa6>
 1018466:	bf00      	nop
 1018468:	0102ab30 	.word	0x0102ab30
 101846c:	0102a300 	.word	0x0102a300
 1018470:	0102a278 	.word	0x0102a278
 1018474:	ffff0000 	.word	0xffff0000

01018478 <ull_cp_remote_dle_pending>:
{
 1018478:	b508      	push	{r3, lr}
	ctx = llcp_rr_peek(conn);
 101847a:	f002 fb25 	bl	101aac8 <llcp_rr_peek>
	return (ctx && ctx->proc == PROC_DATA_LENGTH_UPDATE);
 101847e:	b128      	cbz	r0, 101848c <ull_cp_remote_dle_pending+0x14>
 1018480:	7a00      	ldrb	r0, [r0, #8]
 1018482:	f1a0 000c 	sub.w	r0, r0, #12
 1018486:	fab0 f080 	clz	r0, r0
 101848a:	0940      	lsrs	r0, r0, #5
}
 101848c:	bd08      	pop	{r3, pc}
 101848e:	bf00      	nop

01018490 <ull_cp_conn_param_req_reply>:
{
 1018490:	b510      	push	{r4, lr}
 1018492:	4604      	mov	r4, r0
	ctx = llcp_rr_peek(conn);
 1018494:	f002 fb18 	bl	101aac8 <llcp_rr_peek>
	if (ctx && ctx->proc == PROC_CONN_PARAM_REQ) {
 1018498:	b110      	cbz	r0, 10184a0 <ull_cp_conn_param_req_reply+0x10>
 101849a:	7a03      	ldrb	r3, [r0, #8]
 101849c:	2b09      	cmp	r3, #9
 101849e:	d000      	beq.n	10184a2 <ull_cp_conn_param_req_reply+0x12>
}
 10184a0:	bd10      	pop	{r4, pc}
		llcp_rp_conn_param_req_reply(conn, ctx);
 10184a2:	4601      	mov	r1, r0
 10184a4:	4620      	mov	r0, r4
}
 10184a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		llcp_rp_conn_param_req_reply(conn, ctx);
 10184aa:	f002 b84b 	b.w	101a544 <llcp_rp_conn_param_req_reply>
 10184ae:	bf00      	nop

010184b0 <ull_cp_conn_param_req_neg_reply>:
{
 10184b0:	b538      	push	{r3, r4, r5, lr}
 10184b2:	4605      	mov	r5, r0
 10184b4:	460c      	mov	r4, r1
	ctx = llcp_rr_peek(conn);
 10184b6:	f002 fb07 	bl	101aac8 <llcp_rr_peek>
	if (ctx && ctx->proc == PROC_CONN_PARAM_REQ) {
 10184ba:	b118      	cbz	r0, 10184c4 <ull_cp_conn_param_req_neg_reply+0x14>
 10184bc:	7a02      	ldrb	r2, [r0, #8]
 10184be:	4601      	mov	r1, r0
 10184c0:	2a09      	cmp	r2, #9
 10184c2:	d000      	beq.n	10184c6 <ull_cp_conn_param_req_neg_reply+0x16>
}
 10184c4:	bd38      	pop	{r3, r4, r5, pc}
		ctx->data.cu.error = error_code;
 10184c6:	770c      	strb	r4, [r1, #28]
		llcp_rp_conn_param_req_neg_reply(conn, ctx);
 10184c8:	4628      	mov	r0, r5
}
 10184ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		llcp_rp_conn_param_req_neg_reply(conn, ctx);
 10184ce:	f002 b83d 	b.w	101a54c <llcp_rp_conn_param_req_neg_reply>
 10184d2:	bf00      	nop

010184d4 <ull_cp_remote_cpr_pending>:
{
 10184d4:	b508      	push	{r3, lr}
	ctx = llcp_rr_peek(conn);
 10184d6:	f002 faf7 	bl	101aac8 <llcp_rr_peek>
	return (ctx && ctx->proc == PROC_CONN_PARAM_REQ);
 10184da:	b128      	cbz	r0, 10184e8 <ull_cp_remote_cpr_pending+0x14>
 10184dc:	7a00      	ldrb	r0, [r0, #8]
 10184de:	f1a0 0009 	sub.w	r0, r0, #9
 10184e2:	fab0 f080 	clz	r0, r0
 10184e6:	0940      	lsrs	r0, r0, #5
}
 10184e8:	bd08      	pop	{r3, pc}
 10184ea:	bf00      	nop

010184ec <ull_cp_tx_ack>:
	/* consider unsupported and unknows PDUs as valid */
	return true;
}

void ull_cp_tx_ack(struct ll_conn *conn, struct node_tx *tx)
{
 10184ec:	b538      	push	{r3, r4, r5, lr}
 10184ee:	4605      	mov	r5, r0
 10184f0:	460c      	mov	r4, r1
	struct proc_ctx *ctx;

	ctx = llcp_lr_peek(conn);
 10184f2:	f000 fe7d 	bl	10191f0 <llcp_lr_peek>
	if (ctx && ctx->tx_ack == tx) {
 10184f6:	b110      	cbz	r0, 10184fe <ull_cp_tx_ack+0x12>
 10184f8:	6943      	ldr	r3, [r0, #20]
 10184fa:	42a3      	cmp	r3, r4
 10184fc:	d00e      	beq.n	101851c <ull_cp_tx_ack+0x30>
		/* TX ack re. local request */
		llcp_lr_tx_ack(conn, ctx, tx);
	}

	ctx = llcp_rr_peek(conn);
 10184fe:	4628      	mov	r0, r5
 1018500:	f002 fae2 	bl	101aac8 <llcp_rr_peek>
	if (ctx && ctx->tx_ack == tx) {
 1018504:	b110      	cbz	r0, 101850c <ull_cp_tx_ack+0x20>
 1018506:	6943      	ldr	r3, [r0, #20]
 1018508:	42a3      	cmp	r3, r4
 101850a:	d000      	beq.n	101850e <ull_cp_tx_ack+0x22>
		/* TX ack re. remote response */
		llcp_rr_tx_ack(conn, ctx, tx);
	}
}
 101850c:	bd38      	pop	{r3, r4, r5, pc}
		llcp_rr_tx_ack(conn, ctx, tx);
 101850e:	4622      	mov	r2, r4
 1018510:	4601      	mov	r1, r0
 1018512:	4628      	mov	r0, r5
}
 1018514:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		llcp_rr_tx_ack(conn, ctx, tx);
 1018518:	f002 bb2c 	b.w	101ab74 <llcp_rr_tx_ack>
		llcp_lr_tx_ack(conn, ctx, tx);
 101851c:	4601      	mov	r1, r0
 101851e:	4622      	mov	r2, r4
 1018520:	4628      	mov	r0, r5
 1018522:	f000 ff89 	bl	1019438 <llcp_lr_tx_ack>
 1018526:	e7ea      	b.n	10184fe <ull_cp_tx_ack+0x12>

01018528 <ull_cp_tx_ntf>:

void ull_cp_tx_ntf(struct ll_conn *conn)
{
 1018528:	b510      	push	{r4, lr}
 101852a:	4604      	mov	r4, r0
	struct proc_ctx *ctx;

	ctx = llcp_lr_peek(conn);
 101852c:	f000 fe60 	bl	10191f0 <llcp_lr_peek>
	if (ctx) {
 1018530:	b118      	cbz	r0, 101853a <ull_cp_tx_ntf+0x12>
 1018532:	4601      	mov	r1, r0
		/* TX notifications towards Host */
		llcp_lr_tx_ntf(conn, ctx);
 1018534:	4620      	mov	r0, r4
 1018536:	f000 ff9f 	bl	1019478 <llcp_lr_tx_ntf>
	}

	ctx = llcp_rr_peek(conn);
 101853a:	4620      	mov	r0, r4
 101853c:	f002 fac4 	bl	101aac8 <llcp_rr_peek>
	if (ctx) {
 1018540:	4601      	mov	r1, r0
 1018542:	b120      	cbz	r0, 101854e <ull_cp_tx_ntf+0x26>
		/* TX notifications towards Host */
		llcp_rr_tx_ntf(conn, ctx);
 1018544:	4620      	mov	r0, r4
	}
}
 1018546:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		llcp_rr_tx_ntf(conn, ctx);
 101854a:	f002 bb29 	b.w	101aba0 <llcp_rr_tx_ntf>
}
 101854e:	bd10      	pop	{r4, pc}

01018550 <ull_cp_rx>:

void ull_cp_rx(struct ll_conn *conn, struct node_rx_pdu *rx)
{
 1018550:	b570      	push	{r4, r5, r6, lr}
	if (pdu->len < 1) {
 1018552:	7f4b      	ldrb	r3, [r1, #29]
{
 1018554:	460c      	mov	r4, r1
 1018556:	4605      	mov	r5, r0
	if (pdu->len < 1) {
 1018558:	2b00      	cmp	r3, #0
 101855a:	d03e      	beq.n	10185da <ull_cp_rx+0x8a>
	if (pdu->llctrl.opcode < ARRAY_SIZE(pdu_validate)) {
 101855c:	7fcb      	ldrb	r3, [r1, #31]
 101855e:	2b1e      	cmp	r3, #30
 1018560:	d929      	bls.n	10185b6 <ull_cp_rx+0x66>
		/*  Process LL_TERMINATE_IND PDU's as new procedure */
		ctx_l = NULL;
		ctx_r = NULL;
	} else {
		/* Query local and remote activity */
		ctx_l = llcp_lr_peek(conn);
 1018562:	4628      	mov	r0, r5
 1018564:	f000 fe44 	bl	10191f0 <llcp_lr_peek>
 1018568:	4606      	mov	r6, r0
		ctx_r = llcp_rr_peek(conn);
 101856a:	4628      	mov	r0, r5
 101856c:	f002 faac 	bl	101aac8 <llcp_rr_peek>
 1018570:	4601      	mov	r1, r0
	}

	if (ctx_l) {
 1018572:	2e00      	cmp	r6, #0
 1018574:	d05c      	beq.n	1018630 <ull_cp_rx+0xe0>
	return (ctx->rx_opcode == pdu->llctrl.opcode || ctx->rx_greedy);
 1018576:	7af2      	ldrb	r2, [r6, #11]
 1018578:	7fe3      	ldrb	r3, [r4, #31]
		/* Local active procedure */

		if (ctx_r) {
 101857a:	2800      	cmp	r0, #0
 101857c:	d046      	beq.n	101860c <ull_cp_rx+0xbc>
	return (ctx->rx_opcode == pdu->llctrl.opcode || ctx->rx_greedy);
 101857e:	4293      	cmp	r3, r2
 1018580:	7ac0      	ldrb	r0, [r0, #11]
 1018582:	d06f      	beq.n	1018664 <ull_cp_rx+0x114>
 1018584:	7b32      	ldrb	r2, [r6, #12]
 1018586:	2a00      	cmp	r2, #0
 1018588:	d05a      	beq.n	1018640 <ull_cp_rx+0xf0>
 101858a:	4298      	cmp	r0, r3
 101858c:	d077      	beq.n	101867e <ull_cp_rx+0x12e>
 101858e:	7b0a      	ldrb	r2, [r1, #12]
 1018590:	2a00      	cmp	r2, #0
 1018592:	d174      	bne.n	101867e <ull_cp_rx+0x12e>
	return ((pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) &&
 1018594:	2b07      	cmp	r3, #7
 1018596:	f000 80a3 	beq.w	10186e0 <ull_cp_rx+0x190>
	return ((pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND) &&
 101859a:	2b11      	cmp	r3, #17
 101859c:	d104      	bne.n	10185a8 <ull_cp_rx+0x58>
 101859e:	f894 2020 	ldrb.w	r2, [r4, #32]
 10185a2:	7b4b      	ldrb	r3, [r1, #13]
 10185a4:	429a      	cmp	r2, r3
 10185a6:	d06a      	beq.n	101867e <ull_cp_rx+0x12e>
				 * Expected local procedure PDU
				 * No remote active procedure
				 */

				/* Process PDU in local procedure */
				llcp_lr_rx(conn, ctx_l, rx);
 10185a8:	4622      	mov	r2, r4
 10185aa:	4631      	mov	r1, r6
 10185ac:	4628      	mov	r0, r5
		 */

		/* Process PDU as a new remote request */
		llcp_rr_new(conn, rx, pdu_valid);
	}
}
 10185ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				llcp_lr_rx(conn, ctx_l, rx);
 10185b2:	f000 bf09 	b.w	10193c8 <llcp_lr_rx>
		cb = pdu_validate[pdu->llctrl.opcode].validate_cb;
 10185b6:	4a4e      	ldr	r2, [pc, #312]	; (10186f0 <ull_cp_rx+0x1a0>)
 10185b8:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
		if (cb) {
 10185bc:	b122      	cbz	r2, 10185c8 <ull_cp_rx+0x78>
			return cb(pdu);
 10185be:	f101 001c 	add.w	r0, r1, #28
 10185c2:	4790      	blx	r2
	if (!pdu_valid) {
 10185c4:	b158      	cbz	r0, 10185de <ull_cp_rx+0x8e>
	return pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_TERMINATE_IND;
 10185c6:	7fe3      	ldrb	r3, [r4, #31]
	} else if (pdu_is_terminate(pdu)) {
 10185c8:	2b02      	cmp	r3, #2
 10185ca:	d1ca      	bne.n	1018562 <ull_cp_rx+0x12>
{
 10185cc:	2201      	movs	r2, #1
		llcp_rr_new(conn, rx, pdu_valid);
 10185ce:	4621      	mov	r1, r4
 10185d0:	4628      	mov	r0, r5
}
 10185d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		llcp_rr_new(conn, rx, pdu_valid);
 10185d6:	f002 bb0d 	b.w	101abf4 <llcp_rr_new>
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNUSED;
 10185da:	23ff      	movs	r3, #255	; 0xff
 10185dc:	77cb      	strb	r3, [r1, #31]
		ctx = llcp_lr_peek(conn);
 10185de:	4628      	mov	r0, r5
 10185e0:	f000 fe06 	bl	10191f0 <llcp_lr_peek>
		if (ctx && pdu_is_expected(pdu, ctx)) {
 10185e4:	b128      	cbz	r0, 10185f2 <ull_cp_rx+0xa2>
	return (ctx->rx_opcode == pdu->llctrl.opcode || ctx->rx_greedy);
 10185e6:	7fe2      	ldrb	r2, [r4, #31]
 10185e8:	7ac3      	ldrb	r3, [r0, #11]
 10185ea:	429a      	cmp	r2, r3
 10185ec:	d00d      	beq.n	101860a <ull_cp_rx+0xba>
 10185ee:	7b03      	ldrb	r3, [r0, #12]
 10185f0:	b95b      	cbnz	r3, 101860a <ull_cp_rx+0xba>
		ctx = llcp_rr_peek(conn);
 10185f2:	4628      	mov	r0, r5
 10185f4:	f002 fa68 	bl	101aac8 <llcp_rr_peek>
		if (ctx && pdu_is_expected(pdu, ctx)) {
 10185f8:	2800      	cmp	r0, #0
 10185fa:	d05e      	beq.n	10186ba <ull_cp_rx+0x16a>
	return (ctx->rx_opcode == pdu->llctrl.opcode || ctx->rx_greedy);
 10185fc:	7fe2      	ldrb	r2, [r4, #31]
 10185fe:	7ac3      	ldrb	r3, [r0, #11]
 1018600:	429a      	cmp	r2, r3
 1018602:	d002      	beq.n	101860a <ull_cp_rx+0xba>
 1018604:	7b02      	ldrb	r2, [r0, #12]
 1018606:	2a00      	cmp	r2, #0
 1018608:	d0e1      	beq.n	10185ce <ull_cp_rx+0x7e>
}
 101860a:	bd70      	pop	{r4, r5, r6, pc}
	return (ctx->rx_opcode == pdu->llctrl.opcode || ctx->rx_greedy);
 101860c:	4293      	cmp	r3, r2
 101860e:	d0cb      	beq.n	10185a8 <ull_cp_rx+0x58>
 1018610:	7b32      	ldrb	r2, [r6, #12]
 1018612:	2a00      	cmp	r2, #0
 1018614:	d1c8      	bne.n	10185a8 <ull_cp_rx+0x58>
	return ((pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) &&
 1018616:	2b07      	cmp	r3, #7
 1018618:	d05c      	beq.n	10186d4 <ull_cp_rx+0x184>
	return ((pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND) &&
 101861a:	2b11      	cmp	r3, #17
 101861c:	d05a      	beq.n	10186d4 <ull_cp_rx+0x184>
	return (pdu_is_reject_ext(pdu, ctx) || pdu_is_reject(pdu, ctx));
 101861e:	2b0d      	cmp	r3, #13
 1018620:	d0c2      	beq.n	10185a8 <ull_cp_rx+0x58>
				llcp_rr_new(conn, rx, true);
 1018622:	4621      	mov	r1, r4
 1018624:	4628      	mov	r0, r5
}
 1018626:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				llcp_rr_new(conn, rx, true);
 101862a:	2201      	movs	r2, #1
 101862c:	f002 bae2 	b.w	101abf4 <llcp_rr_new>
	} else if (ctx_r) {
 1018630:	2800      	cmp	r0, #0
 1018632:	d0cb      	beq.n	10185cc <ull_cp_rx+0x7c>
		llcp_rr_rx(conn, ctx_r, rx);
 1018634:	4622      	mov	r2, r4
 1018636:	4628      	mov	r0, r5
}
 1018638:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		llcp_rr_rx(conn, ctx_r, rx);
 101863c:	f002 ba5a 	b.w	101aaf4 <llcp_rr_rx>
	return ((pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) &&
 1018640:	2b07      	cmp	r3, #7
 1018642:	d03c      	beq.n	10186be <ull_cp_rx+0x16e>
	return ((pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND) &&
 1018644:	2b11      	cmp	r3, #17
 1018646:	d028      	beq.n	101869a <ull_cp_rx+0x14a>
	return (pdu_is_reject_ext(pdu, ctx) || pdu_is_reject(pdu, ctx));
 1018648:	f1b3 020d 	subs.w	r2, r3, #13
 101864c:	bf18      	it	ne
 101864e:	2201      	movne	r2, #1
	return (ctx->rx_opcode == pdu->llctrl.opcode || ctx->rx_greedy);
 1018650:	4298      	cmp	r0, r3
 1018652:	d02f      	beq.n	10186b4 <ull_cp_rx+0x164>
 1018654:	7b0b      	ldrb	r3, [r1, #12]
 1018656:	bb6b      	cbnz	r3, 10186b4 <ull_cp_rx+0x164>
			if (unexpected_l && unexpected_r) {
 1018658:	2a00      	cmp	r2, #0
 101865a:	d0a5      	beq.n	10185a8 <ull_cp_rx+0x58>
				conn->llcp_terminate.reason_final = BT_HCI_ERR_LOCALHOST_TERM_CONN;
 101865c:	2316      	movs	r3, #22
 101865e:	f885 3148 	strb.w	r3, [r5, #328]	; 0x148
}
 1018662:	bd70      	pop	{r4, r5, r6, pc}
	return (ctx->rx_opcode == pdu->llctrl.opcode || ctx->rx_greedy);
 1018664:	4298      	cmp	r0, r3
 1018666:	d00a      	beq.n	101867e <ull_cp_rx+0x12e>
 1018668:	7b0a      	ldrb	r2, [r1, #12]
 101866a:	b942      	cbnz	r2, 101867e <ull_cp_rx+0x12e>
	return ((pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) &&
 101866c:	2b07      	cmp	r3, #7
 101866e:	d037      	beq.n	10186e0 <ull_cp_rx+0x190>
	return ((pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND) &&
 1018670:	2b11      	cmp	r3, #17
 1018672:	d199      	bne.n	10185a8 <ull_cp_rx+0x58>
 1018674:	7b4a      	ldrb	r2, [r1, #13]
 1018676:	f894 3020 	ldrb.w	r3, [r4, #32]
 101867a:	429a      	cmp	r2, r3
 101867c:	d194      	bne.n	10185a8 <ull_cp_rx+0x58>
				LL_ASSERT(0);
 101867e:	f240 63c6 	movw	r3, #1734	; 0x6c6
 1018682:	4a1c      	ldr	r2, [pc, #112]	; (10186f4 <ull_cp_rx+0x1a4>)
 1018684:	491c      	ldr	r1, [pc, #112]	; (10186f8 <ull_cp_rx+0x1a8>)
 1018686:	481d      	ldr	r0, [pc, #116]	; (10186fc <ull_cp_rx+0x1ac>)
 1018688:	f00c faa5 	bl	1024bd6 <assert_print>
 101868c:	4040      	eors	r0, r0
 101868e:	f380 8811 	msr	BASEPRI, r0
 1018692:	f04f 0003 	mov.w	r0, #3
 1018696:	df02      	svc	2
}
 1018698:	bd70      	pop	{r4, r5, r6, pc}
	return ((pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND) &&
 101869a:	7b72      	ldrb	r2, [r6, #13]
 101869c:	f894 3020 	ldrb.w	r3, [r4, #32]
 10186a0:	1ad2      	subs	r2, r2, r3
 10186a2:	bf18      	it	ne
 10186a4:	2201      	movne	r2, #1
	return (ctx->rx_opcode == pdu->llctrl.opcode || ctx->rx_greedy);
 10186a6:	2811      	cmp	r0, #17
 10186a8:	d004      	beq.n	10186b4 <ull_cp_rx+0x164>
 10186aa:	7b08      	ldrb	r0, [r1, #12]
 10186ac:	b910      	cbnz	r0, 10186b4 <ull_cp_rx+0x164>
	return ((pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND) &&
 10186ae:	7b48      	ldrb	r0, [r1, #13]
 10186b0:	4298      	cmp	r0, r3
 10186b2:	d1d1      	bne.n	1018658 <ull_cp_rx+0x108>
			if (unexpected_l && unexpected_r) {
 10186b4:	2a00      	cmp	r2, #0
 10186b6:	d1bd      	bne.n	1018634 <ull_cp_rx+0xe4>
 10186b8:	e7e1      	b.n	101867e <ull_cp_rx+0x12e>
 10186ba:	4602      	mov	r2, r0
 10186bc:	e787      	b.n	10185ce <ull_cp_rx+0x7e>
	return ((pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) &&
 10186be:	7b72      	ldrb	r2, [r6, #13]
 10186c0:	f894 3020 	ldrb.w	r3, [r4, #32]
 10186c4:	1ad2      	subs	r2, r2, r3
 10186c6:	bf18      	it	ne
 10186c8:	2201      	movne	r2, #1
	return (ctx->rx_opcode == pdu->llctrl.opcode || ctx->rx_greedy);
 10186ca:	2807      	cmp	r0, #7
 10186cc:	d1ed      	bne.n	10186aa <ull_cp_rx+0x15a>
			if (unexpected_l && unexpected_r) {
 10186ce:	2a00      	cmp	r2, #0
 10186d0:	d1b0      	bne.n	1018634 <ull_cp_rx+0xe4>
 10186d2:	e7d4      	b.n	101867e <ull_cp_rx+0x12e>
	return ((pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND) &&
 10186d4:	7b72      	ldrb	r2, [r6, #13]
 10186d6:	f894 3020 	ldrb.w	r3, [r4, #32]
 10186da:	429a      	cmp	r2, r3
 10186dc:	d1a1      	bne.n	1018622 <ull_cp_rx+0xd2>
 10186de:	e763      	b.n	10185a8 <ull_cp_rx+0x58>
	return ((pdu->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) &&
 10186e0:	7b4a      	ldrb	r2, [r1, #13]
 10186e2:	f894 3020 	ldrb.w	r3, [r4, #32]
 10186e6:	429a      	cmp	r2, r3
 10186e8:	f47f af5e 	bne.w	10185a8 <ull_cp_rx+0x58>
 10186ec:	e7c7      	b.n	101867e <ull_cp_rx+0x12e>
 10186ee:	bf00      	nop
 10186f0:	0102ab80 	.word	0x0102ab80
 10186f4:	0102ab30 	.word	0x0102ab30
 10186f8:	0102a300 	.word	0x0102a300
 10186fc:	0102a278 	.word	0x0102a278

01018700 <rp_comm_ntf>:
{
	llcp_ntf_encode_length_change(conn, pdu);
}

static void rp_comm_ntf(struct ll_conn *conn, struct proc_ctx *ctx)
{
 1018700:	b570      	push	{r4, r5, r6, lr}
 1018702:	4605      	mov	r5, r0
 1018704:	460e      	mov	r6, r1
	struct node_rx_pdu *ntf;
	struct pdu_data *pdu;

	ARG_UNUSED(pdu);
	/* Allocate ntf node */
	ntf = llcp_ntf_alloc();
 1018706:	f7ff fbeb 	bl	1017ee0 <llcp_ntf_alloc>
	LL_ASSERT(ntf);
 101870a:	4604      	mov	r4, r0
 101870c:	b320      	cbz	r0, 1018758 <rp_comm_ntf+0x58>

	ntf->hdr.type = NODE_RX_TYPE_DC_PDU;
 101870e:	2303      	movs	r3, #3
 1018710:	7123      	strb	r3, [r4, #4]
	ntf->hdr.handle = conn->lll.handle;
 1018712:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
 1018714:	80e3      	strh	r3, [r4, #6]
	pdu = (struct pdu_data *)ntf->pdu;
	switch (ctx->proc) {
 1018716:	7a33      	ldrb	r3, [r6, #8]
 1018718:	2b0c      	cmp	r3, #12
 101871a:	d012      	beq.n	1018742 <rp_comm_ntf+0x42>
	case PROC_DATA_LENGTH_UPDATE:
		rp_comm_ntf_length_change(conn, ctx, pdu);
		break;
#endif /* CONFIG_BT_CTLR_DATA_LENGTH */
	default:
		LL_ASSERT(0);
 101871c:	f240 4389 	movw	r3, #1161	; 0x489
 1018720:	4a14      	ldr	r2, [pc, #80]	; (1018774 <rp_comm_ntf+0x74>)
 1018722:	4915      	ldr	r1, [pc, #84]	; (1018778 <rp_comm_ntf+0x78>)
 1018724:	4815      	ldr	r0, [pc, #84]	; (101877c <rp_comm_ntf+0x7c>)
 1018726:	f00c fa56 	bl	1024bd6 <assert_print>
 101872a:	4040      	eors	r0, r0
 101872c:	f380 8811 	msr	BASEPRI, r0
 1018730:	f04f 0003 	mov.w	r0, #3
 1018734:	df02      	svc	2
		break;
	}

	/* Enqueue notification towards LL */
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1018736:	4621      	mov	r1, r4
 1018738:	6820      	ldr	r0, [r4, #0]
}
 101873a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ll_rx_put_sched(ntf->hdr.link, ntf);
 101873e:	f7fb bdcd 	b.w	10142dc <ll_rx_put_sched>
	llcp_ntf_encode_length_change(conn, pdu);
 1018742:	4628      	mov	r0, r5
 1018744:	f104 011c 	add.w	r1, r4, #28
 1018748:	f001 f9e6 	bl	1019b18 <llcp_ntf_encode_length_change>
	ll_rx_put_sched(ntf->hdr.link, ntf);
 101874c:	4621      	mov	r1, r4
 101874e:	6820      	ldr	r0, [r4, #0]
}
 1018750:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1018754:	f7fb bdc2 	b.w	10142dc <ll_rx_put_sched>
	LL_ASSERT(ntf);
 1018758:	f240 437a 	movw	r3, #1146	; 0x47a
 101875c:	4a05      	ldr	r2, [pc, #20]	; (1018774 <rp_comm_ntf+0x74>)
 101875e:	4908      	ldr	r1, [pc, #32]	; (1018780 <rp_comm_ntf+0x80>)
 1018760:	4806      	ldr	r0, [pc, #24]	; (101877c <rp_comm_ntf+0x7c>)
 1018762:	f00c fa38 	bl	1024bd6 <assert_print>
 1018766:	4040      	eors	r0, r0
 1018768:	f380 8811 	msr	BASEPRI, r0
 101876c:	f04f 0003 	mov.w	r0, #3
 1018770:	df02      	svc	2
 1018772:	e7cc      	b.n	101870e <rp_comm_ntf+0xe>
 1018774:	0102abfc 	.word	0x0102abfc
 1018778:	0102a300 	.word	0x0102a300
 101877c:	0102a278 	.word	0x0102a278
 1018780:	0102aad0 	.word	0x0102aad0

01018784 <lp_comm_tx>:
{
 1018784:	b570      	push	{r4, r5, r6, lr}
 1018786:	4606      	mov	r6, r0
 1018788:	460c      	mov	r4, r1
	tx = llcp_tx_alloc(conn, ctx);
 101878a:	f7ff fb8d 	bl	1017ea8 <llcp_tx_alloc>
	LL_ASSERT(tx);
 101878e:	4605      	mov	r5, r0
 1018790:	2800      	cmp	r0, #0
 1018792:	d060      	beq.n	1018856 <lp_comm_tx+0xd2>
	switch (ctx->proc) {
 1018794:	7a23      	ldrb	r3, [r4, #8]
	pdu = (struct pdu_data *)tx->pdu;
 1018796:	1d29      	adds	r1, r5, #4
	switch (ctx->proc) {
 1018798:	3b01      	subs	r3, #1
 101879a:	2b0b      	cmp	r3, #11
 101879c:	d807      	bhi.n	10187ae <lp_comm_tx+0x2a>
 101879e:	e8df f003 	tbb	[pc, r3]
 10187a2:	2620      	.short	0x2620
 10187a4:	0606332c 	.word	0x0606332c
 10187a8:	39060606 	.word	0x39060606
 10187ac:	4006      	.short	0x4006
		LL_ASSERT(0);
 10187ae:	23ce      	movs	r3, #206	; 0xce
 10187b0:	4a2f      	ldr	r2, [pc, #188]	; (1018870 <lp_comm_tx+0xec>)
 10187b2:	4930      	ldr	r1, [pc, #192]	; (1018874 <lp_comm_tx+0xf0>)
 10187b4:	4830      	ldr	r0, [pc, #192]	; (1018878 <lp_comm_tx+0xf4>)
 10187b6:	f00c fa0e 	bl	1024bd6 <assert_print>
 10187ba:	4040      	eors	r0, r0
 10187bc:	f380 8811 	msr	BASEPRI, r0
 10187c0:	f04f 0003 	mov.w	r0, #3
 10187c4:	df02      	svc	2
	ctx->tx_opcode = pdu->llctrl.opcode;
 10187c6:	79eb      	ldrb	r3, [r5, #7]
	llcp_tx_enqueue(conn, tx);
 10187c8:	4629      	mov	r1, r5
	ctx->tx_opcode = pdu->llctrl.opcode;
 10187ca:	7363      	strb	r3, [r4, #13]
	llcp_tx_enqueue(conn, tx);
 10187cc:	4630      	mov	r0, r6
 10187ce:	f7ff fb89 	bl	1017ee4 <llcp_tx_enqueue>
	if (ctx->proc != PROC_TERMINATE) {
 10187d2:	7a23      	ldrb	r3, [r4, #8]
 10187d4:	2b0a      	cmp	r3, #10
 10187d6:	d02a      	beq.n	101882e <lp_comm_tx+0xaa>
		llcp_lr_prt_restart(conn);
 10187d8:	4630      	mov	r0, r6
}
 10187da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		llcp_lr_prt_restart(conn);
 10187de:	f000 bde5 	b.w	10193ac <llcp_lr_prt_restart>
		llcp_pdu_encode_ping_req(pdu);
 10187e2:	4608      	mov	r0, r1
 10187e4:	f000 feca 	bl	101957c <llcp_pdu_encode_ping_req>
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_PING_RSP;
 10187e8:	2313      	movs	r3, #19
 10187ea:	72e3      	strb	r3, [r4, #11]
		break;
 10187ec:	e7eb      	b.n	10187c6 <lp_comm_tx+0x42>
		llcp_pdu_encode_feature_req(conn, pdu);
 10187ee:	4630      	mov	r0, r6
 10187f0:	f000 fef8 	bl	10195e4 <llcp_pdu_encode_feature_req>
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
 10187f4:	2309      	movs	r3, #9
 10187f6:	72e3      	strb	r3, [r4, #11]
		break;
 10187f8:	e7e5      	b.n	10187c6 <lp_comm_tx+0x42>
		llcp_pdu_encode_min_used_chans_ind(ctx, pdu);
 10187fa:	4620      	mov	r0, r4
 10187fc:	f000 ff8a 	bl	1019714 <llcp_pdu_encode_min_used_chans_ind>
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_UNUSED;
 1018800:	23ff      	movs	r3, #255	; 0xff
		ctx->tx_ack = tx;
 1018802:	6165      	str	r5, [r4, #20]
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_UNUSED;
 1018804:	72e3      	strb	r3, [r4, #11]
		break;
 1018806:	e7de      	b.n	10187c6 <lp_comm_tx+0x42>
		llcp_pdu_encode_version_ind(pdu);
 1018808:	4608      	mov	r0, r1
 101880a:	f000 ffa1 	bl	1019750 <llcp_pdu_encode_version_ind>
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 101880e:	230c      	movs	r3, #12
 1018810:	72e3      	strb	r3, [r4, #11]
		break;
 1018812:	e7d8      	b.n	10187c6 <lp_comm_tx+0x42>
		llcp_pdu_encode_terminate_ind(ctx, pdu);
 1018814:	4620      	mov	r0, r4
 1018816:	f000 ff8d 	bl	1019734 <llcp_pdu_encode_terminate_ind>
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_UNUSED;
 101881a:	23ff      	movs	r3, #255	; 0xff
		ctx->tx_ack = tx;
 101881c:	6165      	str	r5, [r4, #20]
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_UNUSED;
 101881e:	72e3      	strb	r3, [r4, #11]
		break;
 1018820:	e7d1      	b.n	10187c6 <lp_comm_tx+0x42>
		llcp_pdu_encode_length_req(conn, pdu);
 1018822:	4630      	mov	r0, r6
 1018824:	f001 f948 	bl	1019ab8 <llcp_pdu_encode_length_req>
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 1018828:	2315      	movs	r3, #21
 101882a:	72e3      	strb	r3, [r4, #11]
		break;
 101882c:	e7cb      	b.n	10187c6 <lp_comm_tx+0x42>
		const uint32_t conn_interval_us = conn->lll.interval * CONN_INT_UNIT_US;
 101882e:	f240 44e2 	movw	r4, #1250	; 0x4e2
		const uint16_t sto_reload = RADIO_CONN_EVENTS(
 1018832:	f242 7210 	movw	r2, #10000	; 0x2710
		const uint32_t conn_interval_us = conn->lll.interval * CONN_INT_UNIT_US;
 1018836:	8d73      	ldrh	r3, [r6, #42]	; 0x2a
		const uint16_t sto_reload = RADIO_CONN_EVENTS(
 1018838:	f8b6 1184 	ldrh.w	r1, [r6, #388]	; 0x184
		const uint32_t conn_interval_us = conn->lll.interval * CONN_INT_UNIT_US;
 101883c:	fb04 f303 	mul.w	r3, r4, r3
		const uint16_t sto_reload = RADIO_CONN_EVENTS(
 1018840:	fb02 3101 	mla	r1, r2, r1, r3
 1018844:	3901      	subs	r1, #1
 1018846:	fbb1 f1f3 	udiv	r1, r1, r3
		llcp_lr_prt_restart_with_value(conn, sto_reload);
 101884a:	4630      	mov	r0, r6
}
 101884c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		llcp_lr_prt_restart_with_value(conn, sto_reload);
 1018850:	b289      	uxth	r1, r1
 1018852:	f000 bdb1 	b.w	10193b8 <llcp_lr_prt_restart_with_value>
	LL_ASSERT(tx);
 1018856:	2393      	movs	r3, #147	; 0x93
 1018858:	4a05      	ldr	r2, [pc, #20]	; (1018870 <lp_comm_tx+0xec>)
 101885a:	4908      	ldr	r1, [pc, #32]	; (101887c <lp_comm_tx+0xf8>)
 101885c:	4806      	ldr	r0, [pc, #24]	; (1018878 <lp_comm_tx+0xf4>)
 101885e:	f00c f9ba 	bl	1024bd6 <assert_print>
 1018862:	4040      	eors	r0, r0
 1018864:	f380 8811 	msr	BASEPRI, r0
 1018868:	f04f 0003 	mov.w	r0, #3
 101886c:	df02      	svc	2
 101886e:	e791      	b.n	1018794 <lp_comm_tx+0x10>
 1018870:	0102abfc 	.word	0x0102abfc
 1018874:	0102a300 	.word	0x0102a300
 1018878:	0102a278 	.word	0x0102a278
 101887c:	0102a920 	.word	0x0102a920

01018880 <rp_comm_tx_proxy>:
#endif /* CONFIG_BT_CTLR_DATA_LENGTH */

static bool rp_comm_tx_proxy(struct ll_conn *conn, struct proc_ctx *ctx, const bool complete)
{
 1018880:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1018884:	4607      	mov	r7, r0
 1018886:	460c      	mov	r4, r1
 1018888:	4616      	mov	r6, r2
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 101888a:	f002 f921 	bl	101aad0 <llcp_rr_ispaused>
 101888e:	b128      	cbz	r0, 101889c <rp_comm_tx_proxy+0x1c>
		ctx->state = RP_COMMON_STATE_WAIT_TX;
 1018890:	2303      	movs	r3, #3
		return false;
 1018892:	2500      	movs	r5, #0
		ctx->state = RP_COMMON_STATE_WAIT_TX;
 1018894:	72a3      	strb	r3, [r4, #10]
		llcp_rr_complete(conn);
		ctx->state = RP_COMMON_STATE_IDLE;
	}

	return true;
}
 1018896:	4628      	mov	r0, r5
 1018898:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 101889c:	4621      	mov	r1, r4
 101889e:	4638      	mov	r0, r7
 10188a0:	f7ff fafa 	bl	1017e98 <llcp_tx_alloc_peek>
 10188a4:	4605      	mov	r5, r0
 10188a6:	2800      	cmp	r0, #0
 10188a8:	d0f2      	beq.n	1018890 <rp_comm_tx_proxy+0x10>
	tx = llcp_tx_alloc(conn, ctx);
 10188aa:	4621      	mov	r1, r4
 10188ac:	4638      	mov	r0, r7
 10188ae:	f7ff fafb 	bl	1017ea8 <llcp_tx_alloc>
	LL_ASSERT(tx);
 10188b2:	4680      	mov	r8, r0
 10188b4:	b380      	cbz	r0, 1018918 <rp_comm_tx_proxy+0x98>
	switch (ctx->proc) {
 10188b6:	7a23      	ldrb	r3, [r4, #8]
	pdu = (struct pdu_data *)tx->pdu;
 10188b8:	f108 0004 	add.w	r0, r8, #4
	switch (ctx->proc) {
 10188bc:	3b01      	subs	r3, #1
 10188be:	2b0e      	cmp	r3, #14
 10188c0:	d809      	bhi.n	10188d6 <rp_comm_tx_proxy+0x56>
 10188c2:	e8df f003 	tbb	[pc, r3]
 10188c6:	413c      	.short	0x413c
 10188c8:	08084808 	.word	0x08084808
 10188cc:	08080808 	.word	0x08080808
 10188d0:	08084d08 	.word	0x08084d08
 10188d4:	37          	.byte	0x37
 10188d5:	00          	.byte	0x00
		LL_ASSERT(0);
 10188d6:	f240 4354 	movw	r3, #1108	; 0x454
 10188da:	4a26      	ldr	r2, [pc, #152]	; (1018974 <rp_comm_tx_proxy+0xf4>)
 10188dc:	4926      	ldr	r1, [pc, #152]	; (1018978 <rp_comm_tx_proxy+0xf8>)
 10188de:	4827      	ldr	r0, [pc, #156]	; (101897c <rp_comm_tx_proxy+0xfc>)
 10188e0:	f00c f979 	bl	1024bd6 <assert_print>
 10188e4:	4040      	eors	r0, r0
 10188e6:	f380 8811 	msr	BASEPRI, r0
 10188ea:	f04f 0003 	mov.w	r0, #3
 10188ee:	df02      	svc	2
	ctx->tx_opcode = pdu->llctrl.opcode;
 10188f0:	f898 3007 	ldrb.w	r3, [r8, #7]
	llcp_tx_enqueue(conn, tx);
 10188f4:	4641      	mov	r1, r8
	ctx->tx_opcode = pdu->llctrl.opcode;
 10188f6:	7363      	strb	r3, [r4, #13]
	llcp_tx_enqueue(conn, tx);
 10188f8:	4638      	mov	r0, r7
 10188fa:	f7ff faf3 	bl	1017ee4 <llcp_tx_enqueue>
	llcp_rr_prt_restart(conn);
 10188fe:	4638      	mov	r0, r7
 1018900:	f002 f8ee 	bl	101aae0 <llcp_rr_prt_restart>
	ctx->state = RP_COMMON_STATE_WAIT_TX_ACK;
 1018904:	2304      	movs	r3, #4
 1018906:	72a3      	strb	r3, [r4, #10]
	if (complete) {
 1018908:	2e00      	cmp	r6, #0
 101890a:	d0c4      	beq.n	1018896 <rp_comm_tx_proxy+0x16>
		llcp_rr_complete(conn);
 101890c:	4638      	mov	r0, r7
 101890e:	f002 f965 	bl	101abdc <llcp_rr_complete>
		ctx->state = RP_COMMON_STATE_IDLE;
 1018912:	2300      	movs	r3, #0
 1018914:	72a3      	strb	r3, [r4, #10]
 1018916:	e7be      	b.n	1018896 <rp_comm_tx_proxy+0x16>
	LL_ASSERT(tx);
 1018918:	f240 4305 	movw	r3, #1029	; 0x405
 101891c:	4a15      	ldr	r2, [pc, #84]	; (1018974 <rp_comm_tx_proxy+0xf4>)
 101891e:	4918      	ldr	r1, [pc, #96]	; (1018980 <rp_comm_tx_proxy+0x100>)
 1018920:	4816      	ldr	r0, [pc, #88]	; (101897c <rp_comm_tx_proxy+0xfc>)
 1018922:	f00c f958 	bl	1024bd6 <assert_print>
 1018926:	4040      	eors	r0, r0
 1018928:	f380 8811 	msr	BASEPRI, r0
 101892c:	f04f 0003 	mov.w	r0, #3
 1018930:	df02      	svc	2
 1018932:	e7c0      	b.n	10188b6 <rp_comm_tx_proxy+0x36>
		llcp_pdu_encode_reject_ext_ind(pdu, PDU_DATA_LLCTRL_TYPE_CIS_TERMINATE_IND,
 1018934:	2211      	movs	r2, #17
 1018936:	2122      	movs	r1, #34	; 0x22
 1018938:	f000 ffa0 	bl	101987c <llcp_pdu_encode_reject_ext_ind>
		break;
 101893c:	e7d8      	b.n	10188f0 <rp_comm_tx_proxy+0x70>
		llcp_pdu_encode_ping_rsp(pdu);
 101893e:	f000 fe27 	bl	1019590 <llcp_pdu_encode_ping_rsp>
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_UNUSED;
 1018942:	23ff      	movs	r3, #255	; 0xff
 1018944:	72e3      	strb	r3, [r4, #11]
		break;
 1018946:	e7d3      	b.n	10188f0 <rp_comm_tx_proxy+0x70>
		llcp_pdu_encode_feature_rsp(conn, pdu);
 1018948:	4601      	mov	r1, r0
 101894a:	4638      	mov	r0, r7
 101894c:	f000 fe6c 	bl	1019628 <llcp_pdu_encode_feature_rsp>
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_UNUSED;
 1018950:	23ff      	movs	r3, #255	; 0xff
 1018952:	72e3      	strb	r3, [r4, #11]
		break;
 1018954:	e7cc      	b.n	10188f0 <rp_comm_tx_proxy+0x70>
		llcp_pdu_encode_version_ind(pdu);
 1018956:	f000 fefb 	bl	1019750 <llcp_pdu_encode_version_ind>
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_UNUSED;
 101895a:	23ff      	movs	r3, #255	; 0xff
 101895c:	72e3      	strb	r3, [r4, #11]
		break;
 101895e:	e7c7      	b.n	10188f0 <rp_comm_tx_proxy+0x70>
		llcp_pdu_encode_length_rsp(conn, pdu);
 1018960:	4601      	mov	r1, r0
 1018962:	4638      	mov	r0, r7
 1018964:	f001 f8c0 	bl	1019ae8 <llcp_pdu_encode_length_rsp>
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_UNUSED;
 1018968:	23ff      	movs	r3, #255	; 0xff
		ctx->tx_ack = tx;
 101896a:	f8c4 8014 	str.w	r8, [r4, #20]
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_UNUSED;
 101896e:	72e3      	strb	r3, [r4, #11]
		break;
 1018970:	e7be      	b.n	10188f0 <rp_comm_tx_proxy+0x70>
 1018972:	bf00      	nop
 1018974:	0102abfc 	.word	0x0102abfc
 1018978:	0102a300 	.word	0x0102a300
 101897c:	0102a278 	.word	0x0102a278
 1018980:	0102a920 	.word	0x0102a920

01018984 <rp_comm_send_rsp.constprop.0>:

static void rp_comm_send_rsp(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
 1018984:	b538      	push	{r3, r4, r5, lr}
{
	switch (ctx->proc) {
 1018986:	7a0b      	ldrb	r3, [r1, #8]
static void rp_comm_send_rsp(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
 1018988:	460c      	mov	r4, r1
	switch (ctx->proc) {
 101898a:	3b01      	subs	r3, #1
static void rp_comm_send_rsp(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
 101898c:	4605      	mov	r5, r0
	switch (ctx->proc) {
 101898e:	2b0b      	cmp	r3, #11
 1018990:	d807      	bhi.n	10189a2 <rp_comm_send_rsp.constprop.0+0x1e>
 1018992:	e8df f003 	tbb	[pc, r3]
 1018996:	1914      	.short	0x1914
 1018998:	06062206 	.word	0x06062206
 101899c:	2e060606 	.word	0x2e060606
 10189a0:	3606      	.short	0x3606
		rp_comm_tx_proxy(conn, ctx, false);
		break;
#endif /* CONFIG_BT_CTLR_SCA_UPDATE */
	default:
		/* Unknown procedure */
		LL_ASSERT(0);
 10189a2:	f240 5315 	movw	r3, #1301	; 0x515
 10189a6:	4a1c      	ldr	r2, [pc, #112]	; (1018a18 <rp_comm_send_rsp.constprop.0+0x94>)
 10189a8:	491c      	ldr	r1, [pc, #112]	; (1018a1c <rp_comm_send_rsp.constprop.0+0x98>)
 10189aa:	481d      	ldr	r0, [pc, #116]	; (1018a20 <rp_comm_send_rsp.constprop.0+0x9c>)
 10189ac:	f00c f913 	bl	1024bd6 <assert_print>
 10189b0:	4040      	eors	r0, r0
 10189b2:	f380 8811 	msr	BASEPRI, r0
 10189b6:	f04f 0003 	mov.w	r0, #3
 10189ba:	df02      	svc	2
	}
}
 10189bc:	bd38      	pop	{r3, r4, r5, pc}
		rp_comm_tx_proxy(conn, ctx, true);
 10189be:	2201      	movs	r2, #1
}
 10189c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		rp_comm_tx_proxy(conn, ctx, true);
 10189c4:	f7ff bf5c 	b.w	1018880 <rp_comm_tx_proxy>
		if (rp_comm_tx_proxy(conn, ctx, true)) {
 10189c8:	2201      	movs	r2, #1
 10189ca:	f7ff ff59 	bl	1018880 <rp_comm_tx_proxy>
 10189ce:	2800      	cmp	r0, #0
 10189d0:	d0f4      	beq.n	10189bc <rp_comm_send_rsp.constprop.0+0x38>
			conn->llcp.fex.sent = 1;
 10189d2:	2301      	movs	r3, #1
 10189d4:	f885 3120 	strb.w	r3, [r5, #288]	; 0x120
}
 10189d8:	bd38      	pop	{r3, r4, r5, pc}
		if (!conn->llcp.vex.sent) {
 10189da:	f890 3114 	ldrb.w	r3, [r0, #276]	; 0x114
 10189de:	b9ab      	cbnz	r3, 1018a0c <rp_comm_send_rsp.constprop.0+0x88>
			if (rp_comm_tx_proxy(conn, ctx, true)) {
 10189e0:	2201      	movs	r2, #1
 10189e2:	f7ff ff4d 	bl	1018880 <rp_comm_tx_proxy>
 10189e6:	2800      	cmp	r0, #0
 10189e8:	d0e8      	beq.n	10189bc <rp_comm_send_rsp.constprop.0+0x38>
				conn->llcp.vex.sent = 1;
 10189ea:	2301      	movs	r3, #1
 10189ec:	f885 3114 	strb.w	r3, [r5, #276]	; 0x114
}
 10189f0:	bd38      	pop	{r3, r4, r5, pc}
	llcp_rr_complete(conn);
 10189f2:	f002 f8f3 	bl	101abdc <llcp_rr_complete>
	ctx->state = RP_COMMON_STATE_IDLE;
 10189f6:	2200      	movs	r2, #0
	conn->llcp_terminate.reason_final = ctx->data.term.error_code;
 10189f8:	7f23      	ldrb	r3, [r4, #28]
	ctx->state = RP_COMMON_STATE_IDLE;
 10189fa:	72a2      	strb	r2, [r4, #10]
	conn->llcp_terminate.reason_final = ctx->data.term.error_code;
 10189fc:	f885 3148 	strb.w	r3, [r5, #328]	; 0x148
}
 1018a00:	bd38      	pop	{r3, r4, r5, pc}
		rp_comm_tx_proxy(conn, ctx, false);
 1018a02:	2200      	movs	r2, #0
}
 1018a04:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		rp_comm_tx_proxy(conn, ctx, false);
 1018a08:	f7ff bf3a 	b.w	1018880 <rp_comm_tx_proxy>
			llcp_rr_complete(conn);
 1018a0c:	f002 f8e6 	bl	101abdc <llcp_rr_complete>
			ctx->state = RP_COMMON_STATE_IDLE;
 1018a10:	2300      	movs	r3, #0
 1018a12:	72a3      	strb	r3, [r4, #10]
}
 1018a14:	bd38      	pop	{r3, r4, r5, pc}
 1018a16:	bf00      	nop
 1018a18:	0102abfc 	.word	0x0102abfc
 1018a1c:	0102a300 	.word	0x0102a300
 1018a20:	0102a278 	.word	0x0102a278

01018a24 <rp_comm_execute_fsm>:
}
#endif /* CONFIG_BT_CTLR_DATA_LENGTH */

static void rp_comm_execute_fsm(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt,
				void *param)
{
 1018a24:	b570      	push	{r4, r5, r6, lr}
 1018a26:	460c      	mov	r4, r1
	switch (ctx->state) {
 1018a28:	7a89      	ldrb	r1, [r1, #10]
{
 1018a2a:	4605      	mov	r5, r0
	switch (ctx->state) {
 1018a2c:	2905      	cmp	r1, #5
 1018a2e:	f200 8095 	bhi.w	1018b5c <rp_comm_execute_fsm+0x138>
 1018a32:	e8df f001 	tbb	[pc, r1]
 1018a36:	0d08      	.short	0x0d08
 1018a38:	03362e20 	.word	0x03362e20
	if (llcp_ntf_alloc_is_available()) {
 1018a3c:	f7ff fa40 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 1018a40:	2800      	cmp	r0, #0
 1018a42:	d145      	bne.n	1018ad0 <rp_comm_execute_fsm+0xac>
#endif /* CONFIG_BT_CTLR_DATA_LENGTH */
	default:
		/* Unknown state */
		LL_ASSERT(0);
	}
}
 1018a44:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 1018a46:	2a00      	cmp	r2, #0
 1018a48:	d1fc      	bne.n	1018a44 <rp_comm_execute_fsm+0x20>
		ctx->state = RP_COMMON_STATE_WAIT_RX;
 1018a4a:	2301      	movs	r3, #1
 1018a4c:	72a3      	strb	r3, [r4, #10]
}
 1018a4e:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 1018a50:	2a02      	cmp	r2, #2
 1018a52:	d1f7      	bne.n	1018a44 <rp_comm_execute_fsm+0x20>
	ctx->response_opcode = pdu->llctrl.opcode;
 1018a54:	78d9      	ldrb	r1, [r3, #3]
	switch (pdu->llctrl.opcode) {
 1018a56:	1e8a      	subs	r2, r1, #2
	ctx->response_opcode = pdu->llctrl.opcode;
 1018a58:	7261      	strb	r1, [r4, #9]
	switch (pdu->llctrl.opcode) {
 1018a5a:	2a12      	cmp	r2, #18
 1018a5c:	d850      	bhi.n	1018b00 <rp_comm_execute_fsm+0xdc>
 1018a5e:	e8df f002 	tbb	[pc, r2]
 1018a62:	4f74      	.short	0x4f74
 1018a64:	4f4f4f4f 	.word	0x4f4f4f4f
 1018a68:	4f4f4f6f 	.word	0x4f4f4f6f
 1018a6c:	4f4f4f6a 	.word	0x4f4f4f6a
 1018a70:	4f1a4f4f 	.word	0x4f1a4f4f
 1018a74:	5d          	.byte	0x5d
 1018a75:	00          	.byte	0x00
	switch (evt) {
 1018a76:	2a00      	cmp	r2, #0
 1018a78:	d1e4      	bne.n	1018a44 <rp_comm_execute_fsm+0x20>
		LL_ASSERT(ctx->proc == PROC_TERMINATE);
 1018a7a:	7a23      	ldrb	r3, [r4, #8]
 1018a7c:	2b0a      	cmp	r3, #10
 1018a7e:	d131      	bne.n	1018ae4 <rp_comm_execute_fsm+0xc0>
	llcp_rr_complete(conn);
 1018a80:	4628      	mov	r0, r5
 1018a82:	f002 f8ab 	bl	101abdc <llcp_rr_complete>
	ctx->state = RP_COMMON_STATE_IDLE;
 1018a86:	2200      	movs	r2, #0
	conn->llcp_terminate.reason_final = ctx->data.term.error_code;
 1018a88:	7f23      	ldrb	r3, [r4, #28]
	ctx->state = RP_COMMON_STATE_IDLE;
 1018a8a:	72a2      	strb	r2, [r4, #10]
	conn->llcp_terminate.reason_final = ctx->data.term.error_code;
 1018a8c:	f885 3148 	strb.w	r3, [r5, #328]	; 0x148
}
 1018a90:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 1018a92:	2a00      	cmp	r2, #0
 1018a94:	d1d6      	bne.n	1018a44 <rp_comm_execute_fsm+0x20>
		rp_comm_send_rsp(conn, ctx, evt, param);
 1018a96:	4621      	mov	r1, r4
 1018a98:	4628      	mov	r0, r5
}
 1018a9a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		rp_comm_send_rsp(conn, ctx, evt, param);
 1018a9e:	f7ff bf71 	b.w	1018984 <rp_comm_send_rsp.constprop.0>
	switch (evt) {
 1018aa2:	2a01      	cmp	r2, #1
 1018aa4:	d1ce      	bne.n	1018a44 <rp_comm_execute_fsm+0x20>
		switch (ctx->proc) {
 1018aa6:	7a23      	ldrb	r3, [r4, #8]
 1018aa8:	2b0c      	cmp	r3, #12
 1018aaa:	d1cb      	bne.n	1018a44 <rp_comm_execute_fsm+0x20>
			uint8_t dle_changed = ull_dle_update_eff_tx(conn);
 1018aac:	4628      	mov	r0, r5
 1018aae:	f7fe f857 	bl	1016b60 <ull_dle_update_eff_tx>
 1018ab2:	4606      	mov	r6, r0
			dle_changed |= ctx->data.dle.ntf_dle;
 1018ab4:	7f23      	ldrb	r3, [r4, #28]
			llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_DATA_LENGTH);
 1018ab6:	2104      	movs	r1, #4
			dle_changed |= ctx->data.dle.ntf_dle;
 1018ab8:	431e      	orrs	r6, r3
 1018aba:	b2f6      	uxtb	r6, r6
			llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_DATA_LENGTH);
 1018abc:	4628      	mov	r0, r5
 1018abe:	f7ff fa29 	bl	1017f14 <llcp_tx_resume_data>
			if (dle_changed && !llcp_ntf_alloc_is_available()) {
 1018ac2:	b14e      	cbz	r6, 1018ad8 <rp_comm_execute_fsm+0xb4>
 1018ac4:	f7ff f9fc 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 1018ac8:	b910      	cbnz	r0, 1018ad0 <rp_comm_execute_fsm+0xac>
				ctx->state = RP_COMMON_STATE_WAIT_NTF;
 1018aca:	2305      	movs	r3, #5
 1018acc:	72a3      	strb	r3, [r4, #10]
}
 1018ace:	bd70      	pop	{r4, r5, r6, pc}
					rp_comm_ntf(conn, ctx);
 1018ad0:	4621      	mov	r1, r4
 1018ad2:	4628      	mov	r0, r5
 1018ad4:	f7ff fe14 	bl	1018700 <rp_comm_ntf>
				llcp_rr_complete(conn);
 1018ad8:	4628      	mov	r0, r5
 1018ada:	f002 f87f 	bl	101abdc <llcp_rr_complete>
				ctx->state = RP_COMMON_STATE_IDLE;
 1018ade:	2300      	movs	r3, #0
 1018ae0:	72a3      	strb	r3, [r4, #10]
}
 1018ae2:	bd70      	pop	{r4, r5, r6, pc}
		LL_ASSERT(ctx->proc == PROC_TERMINATE);
 1018ae4:	f240 532b 	movw	r3, #1323	; 0x52b
 1018ae8:	4a23      	ldr	r2, [pc, #140]	; (1018b78 <rp_comm_execute_fsm+0x154>)
 1018aea:	4924      	ldr	r1, [pc, #144]	; (1018b7c <rp_comm_execute_fsm+0x158>)
 1018aec:	4824      	ldr	r0, [pc, #144]	; (1018b80 <rp_comm_execute_fsm+0x15c>)
 1018aee:	f00c f872 	bl	1024bd6 <assert_print>
 1018af2:	4040      	eors	r0, r0
 1018af4:	f380 8811 	msr	BASEPRI, r0
 1018af8:	f04f 0003 	mov.w	r0, #3
 1018afc:	df02      	svc	2
 1018afe:	e7bf      	b.n	1018a80 <rp_comm_execute_fsm+0x5c>
		LL_ASSERT(0);
 1018b00:	f240 33fa 	movw	r3, #1018	; 0x3fa
 1018b04:	4a1c      	ldr	r2, [pc, #112]	; (1018b78 <rp_comm_execute_fsm+0x154>)
 1018b06:	491f      	ldr	r1, [pc, #124]	; (1018b84 <rp_comm_execute_fsm+0x160>)
 1018b08:	481d      	ldr	r0, [pc, #116]	; (1018b80 <rp_comm_execute_fsm+0x15c>)
 1018b0a:	f00c f864 	bl	1024bd6 <assert_print>
 1018b0e:	4040      	eors	r0, r0
 1018b10:	f380 8811 	msr	BASEPRI, r0
 1018b14:	f04f 0003 	mov.w	r0, #3
 1018b18:	df02      	svc	2
 1018b1a:	e7bc      	b.n	1018a96 <rp_comm_execute_fsm+0x72>
		llcp_pdu_decode_length_req(conn, pdu);
 1018b1c:	4619      	mov	r1, r3
 1018b1e:	4628      	mov	r0, r5
 1018b20:	f001 f812 	bl	1019b48 <llcp_pdu_decode_length_req>
		llcp_tx_pause_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_DATA_LENGTH);
 1018b24:	2104      	movs	r1, #4
 1018b26:	4628      	mov	r0, r5
 1018b28:	f7ff f9e0 	bl	1017eec <llcp_tx_pause_data>
		ctx->data.dle.ntf_dle = ull_dle_update_eff_rx(conn);
 1018b2c:	4628      	mov	r0, r5
 1018b2e:	f7fd ffe5 	bl	1016afc <ull_dle_update_eff_rx>
 1018b32:	7720      	strb	r0, [r4, #28]
		break;
 1018b34:	e7af      	b.n	1018a96 <rp_comm_execute_fsm+0x72>
		llcp_pdu_decode_version_ind(conn, pdu);
 1018b36:	4619      	mov	r1, r3
 1018b38:	4628      	mov	r0, r5
 1018b3a:	f000 fe31 	bl	10197a0 <llcp_pdu_decode_version_ind>
		break;
 1018b3e:	e7aa      	b.n	1018a96 <rp_comm_execute_fsm+0x72>
		llcp_pdu_decode_feature_req(conn, pdu);
 1018b40:	4619      	mov	r1, r3
 1018b42:	4628      	mov	r0, r5
 1018b44:	f000 fdac 	bl	10196a0 <llcp_pdu_decode_feature_req>
		if (feature_phy_coded(conn)) {
 1018b48:	e7a5      	b.n	1018a96 <rp_comm_execute_fsm+0x72>
		llcp_pdu_decode_terminate_ind(ctx, pdu);
 1018b4a:	4619      	mov	r1, r3
 1018b4c:	4620      	mov	r0, r4
 1018b4e:	f000 fdfb 	bl	1019748 <llcp_pdu_decode_terminate_ind>
		llcp_tx_pause_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_TERMINATE);
 1018b52:	2108      	movs	r1, #8
 1018b54:	4628      	mov	r0, r5
 1018b56:	f7ff f9c9 	bl	1017eec <llcp_tx_pause_data>
		break;
 1018b5a:	e79c      	b.n	1018a96 <rp_comm_execute_fsm+0x72>
		LL_ASSERT(0);
 1018b5c:	f240 53aa 	movw	r3, #1450	; 0x5aa
 1018b60:	4a05      	ldr	r2, [pc, #20]	; (1018b78 <rp_comm_execute_fsm+0x154>)
 1018b62:	4908      	ldr	r1, [pc, #32]	; (1018b84 <rp_comm_execute_fsm+0x160>)
 1018b64:	4806      	ldr	r0, [pc, #24]	; (1018b80 <rp_comm_execute_fsm+0x15c>)
 1018b66:	f00c f836 	bl	1024bd6 <assert_print>
 1018b6a:	4040      	eors	r0, r0
 1018b6c:	f380 8811 	msr	BASEPRI, r0
 1018b70:	f04f 0003 	mov.w	r0, #3
 1018b74:	df02      	svc	2
}
 1018b76:	bd70      	pop	{r4, r5, r6, pc}
 1018b78:	0102abfc 	.word	0x0102abfc
 1018b7c:	0102ac44 	.word	0x0102ac44
 1018b80:	0102a278 	.word	0x0102a278
 1018b84:	0102a300 	.word	0x0102a300

01018b88 <lp_comm_ntf>:
{
 1018b88:	b570      	push	{r4, r5, r6, lr}
 1018b8a:	4606      	mov	r6, r0
 1018b8c:	460d      	mov	r5, r1
	ntf = llcp_ntf_alloc();
 1018b8e:	f7ff f9a7 	bl	1017ee0 <llcp_ntf_alloc>
	LL_ASSERT(ntf);
 1018b92:	4604      	mov	r4, r0
 1018b94:	2800      	cmp	r0, #0
 1018b96:	d041      	beq.n	1018c1c <lp_comm_ntf+0x94>
	ntf->hdr.type = NODE_RX_TYPE_DC_PDU;
 1018b98:	2303      	movs	r3, #3
 1018b9a:	7123      	strb	r3, [r4, #4]
	ntf->hdr.handle = conn->lll.handle;
 1018b9c:	8d33      	ldrh	r3, [r6, #40]	; 0x28
	pdu = (struct pdu_data *)ntf->pdu;
 1018b9e:	f104 011c 	add.w	r1, r4, #28
	ntf->hdr.handle = conn->lll.handle;
 1018ba2:	80e3      	strh	r3, [r4, #6]
	switch (ctx->proc) {
 1018ba4:	7a2b      	ldrb	r3, [r5, #8]
 1018ba6:	2b04      	cmp	r3, #4
 1018ba8:	d026      	beq.n	1018bf8 <lp_comm_ntf+0x70>
 1018baa:	2b0c      	cmp	r3, #12
 1018bac:	d01b      	beq.n	1018be6 <lp_comm_ntf+0x5e>
 1018bae:	2b02      	cmp	r3, #2
 1018bb0:	d012      	beq.n	1018bd8 <lp_comm_ntf+0x50>
		LL_ASSERT(0);
 1018bb2:	f44f 73cd 	mov.w	r3, #410	; 0x19a
 1018bb6:	4a20      	ldr	r2, [pc, #128]	; (1018c38 <lp_comm_ntf+0xb0>)
 1018bb8:	4920      	ldr	r1, [pc, #128]	; (1018c3c <lp_comm_ntf+0xb4>)
 1018bba:	4821      	ldr	r0, [pc, #132]	; (1018c40 <lp_comm_ntf+0xb8>)
 1018bbc:	f00c f80b 	bl	1024bd6 <assert_print>
 1018bc0:	4040      	eors	r0, r0
 1018bc2:	f380 8811 	msr	BASEPRI, r0
 1018bc6:	f04f 0003 	mov.w	r0, #3
 1018bca:	df02      	svc	2
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1018bcc:	4621      	mov	r1, r4
 1018bce:	6820      	ldr	r0, [r4, #0]
}
 1018bd0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1018bd4:	f7fb bb82 	b.w	10142dc <ll_rx_put_sched>
	switch (ctx->response_opcode) {
 1018bd8:	7a6b      	ldrb	r3, [r5, #9]
 1018bda:	2b07      	cmp	r3, #7
 1018bdc:	d01a      	beq.n	1018c14 <lp_comm_ntf+0x8c>
 1018bde:	2b09      	cmp	r3, #9
 1018be0:	d010      	beq.n	1018c04 <lp_comm_ntf+0x7c>
		LL_ASSERT(0);
 1018be2:	23f3      	movs	r3, #243	; 0xf3
 1018be4:	e7e7      	b.n	1018bb6 <lp_comm_ntf+0x2e>
	llcp_ntf_encode_length_change(conn, pdu);
 1018be6:	4630      	mov	r0, r6
 1018be8:	f000 ff96 	bl	1019b18 <llcp_ntf_encode_length_change>
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1018bec:	4621      	mov	r1, r4
 1018bee:	6820      	ldr	r0, [r4, #0]
}
 1018bf0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1018bf4:	f7fb bb72 	b.w	10142dc <ll_rx_put_sched>
	switch (ctx->response_opcode) {
 1018bf8:	7a6b      	ldrb	r3, [r5, #9]
 1018bfa:	2b0c      	cmp	r3, #12
 1018bfc:	d006      	beq.n	1018c0c <lp_comm_ntf+0x84>
		LL_ASSERT(0);
 1018bfe:	f44f 7380 	mov.w	r3, #256	; 0x100
 1018c02:	e7d8      	b.n	1018bb6 <lp_comm_ntf+0x2e>
		llcp_ntf_encode_feature_rsp(conn, pdu);
 1018c04:	4630      	mov	r0, r6
 1018c06:	f000 fd2d 	bl	1019664 <llcp_ntf_encode_feature_rsp>
		break;
 1018c0a:	e7df      	b.n	1018bcc <lp_comm_ntf+0x44>
		llcp_ntf_encode_version_ind(conn, pdu);
 1018c0c:	4630      	mov	r0, r6
 1018c0e:	f000 fdb1 	bl	1019774 <llcp_ntf_encode_version_ind>
		break;
 1018c12:	e7db      	b.n	1018bcc <lp_comm_ntf+0x44>
		llcp_ntf_encode_unknown_rsp(ctx, pdu);
 1018c14:	4628      	mov	r0, r5
 1018c16:	f000 fcd7 	bl	10195c8 <llcp_ntf_encode_unknown_rsp>
		break;
 1018c1a:	e7d7      	b.n	1018bcc <lp_comm_ntf+0x44>
	LL_ASSERT(ntf);
 1018c1c:	f240 137d 	movw	r3, #381	; 0x17d
 1018c20:	4a05      	ldr	r2, [pc, #20]	; (1018c38 <lp_comm_ntf+0xb0>)
 1018c22:	4908      	ldr	r1, [pc, #32]	; (1018c44 <lp_comm_ntf+0xbc>)
 1018c24:	4806      	ldr	r0, [pc, #24]	; (1018c40 <lp_comm_ntf+0xb8>)
 1018c26:	f00b ffd6 	bl	1024bd6 <assert_print>
 1018c2a:	4040      	eors	r0, r0
 1018c2c:	f380 8811 	msr	BASEPRI, r0
 1018c30:	f04f 0003 	mov.w	r0, #3
 1018c34:	df02      	svc	2
 1018c36:	e7af      	b.n	1018b98 <lp_comm_ntf+0x10>
 1018c38:	0102abfc 	.word	0x0102abfc
 1018c3c:	0102a300 	.word	0x0102a300
 1018c40:	0102a278 	.word	0x0102a278
 1018c44:	0102aad0 	.word	0x0102aad0

01018c48 <lp_comm_complete.constprop.0>:
static void lp_comm_complete(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
 1018c48:	b538      	push	{r3, r4, r5, lr}
	switch (ctx->proc) {
 1018c4a:	7a0b      	ldrb	r3, [r1, #8]
static void lp_comm_complete(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
 1018c4c:	460c      	mov	r4, r1
	switch (ctx->proc) {
 1018c4e:	3b01      	subs	r3, #1
static void lp_comm_complete(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
 1018c50:	4605      	mov	r5, r0
	switch (ctx->proc) {
 1018c52:	2b0b      	cmp	r3, #11
 1018c54:	d811      	bhi.n	1018c7a <lp_comm_complete.constprop.0+0x32>
 1018c56:	e8df f003 	tbb	[pc, r3]
 1018c5a:	2c1e      	.short	0x2c1e
 1018c5c:	1010540a 	.word	0x1010540a
 1018c60:	32101010 	.word	0x32101010
 1018c64:	3a10      	.short	0x3a10
			lp_comm_ntf(conn, ctx);
 1018c66:	4621      	mov	r1, r4
 1018c68:	4628      	mov	r0, r5
 1018c6a:	f7ff ff8d 	bl	1018b88 <lp_comm_ntf>
			llcp_lr_complete(conn);
 1018c6e:	4628      	mov	r0, r5
 1018c70:	f000 fc20 	bl	10194b4 <llcp_lr_complete>
			ctx->state = LP_COMMON_STATE_IDLE;
 1018c74:	2300      	movs	r3, #0
 1018c76:	72a3      	strb	r3, [r4, #10]
}
 1018c78:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(0);
 1018c7a:	f240 2336 	movw	r3, #566	; 0x236
 1018c7e:	4a2e      	ldr	r2, [pc, #184]	; (1018d38 <lp_comm_complete.constprop.0+0xf0>)
 1018c80:	492e      	ldr	r1, [pc, #184]	; (1018d3c <lp_comm_complete.constprop.0+0xf4>)
 1018c82:	482f      	ldr	r0, [pc, #188]	; (1018d40 <lp_comm_complete.constprop.0+0xf8>)
 1018c84:	f00b ffa7 	bl	1024bd6 <assert_print>
 1018c88:	4040      	eors	r0, r0
 1018c8a:	f380 8811 	msr	BASEPRI, r0
 1018c8e:	f04f 0003 	mov.w	r0, #3
 1018c92:	df02      	svc	2
}
 1018c94:	bd38      	pop	{r3, r4, r5, pc}
		if (ctx->response_opcode == PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP ||
 1018c96:	7a4b      	ldrb	r3, [r1, #9]
 1018c98:	2b07      	cmp	r3, #7
 1018c9a:	d0e8      	beq.n	1018c6e <lp_comm_complete.constprop.0+0x26>
 1018c9c:	2b13      	cmp	r3, #19
 1018c9e:	d0e6      	beq.n	1018c6e <lp_comm_complete.constprop.0+0x26>
	conn->llcp_terminate.reason_final = BT_HCI_ERR_LMP_PDU_NOT_ALLOWED;
 1018ca0:	2324      	movs	r3, #36	; 0x24
	llcp_lr_complete(conn);
 1018ca2:	4628      	mov	r0, r5
	conn->llcp_terminate.reason_final = BT_HCI_ERR_LMP_PDU_NOT_ALLOWED;
 1018ca4:	f885 3148 	strb.w	r3, [r5, #328]	; 0x148
	llcp_lr_complete(conn);
 1018ca8:	f000 fc04 	bl	10194b4 <llcp_lr_complete>
	ctx->state = LP_COMMON_STATE_IDLE;
 1018cac:	2300      	movs	r3, #0
 1018cae:	72a3      	strb	r3, [r4, #10]
}
 1018cb0:	bd38      	pop	{r3, r4, r5, pc}
			(ctx->response_opcode == PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP ||
 1018cb2:	7a4b      	ldrb	r3, [r1, #9]
 1018cb4:	2b07      	cmp	r3, #7
 1018cb6:	d027      	beq.n	1018d08 <lp_comm_complete.constprop.0+0xc0>
 1018cb8:	2b09      	cmp	r3, #9
 1018cba:	d1f1      	bne.n	1018ca0 <lp_comm_complete.constprop.0+0x58>
 1018cbc:	e024      	b.n	1018d08 <lp_comm_complete.constprop.0+0xc0>
		llcp_lr_complete(conn);
 1018cbe:	f000 fbf9 	bl	10194b4 <llcp_lr_complete>
		ctx->state = LP_COMMON_STATE_IDLE;
 1018cc2:	2200      	movs	r2, #0
		conn->llcp_terminate.reason_final = BT_HCI_ERR_LOCALHOST_TERM_CONN;
 1018cc4:	2316      	movs	r3, #22
		ctx->state = LP_COMMON_STATE_IDLE;
 1018cc6:	72a2      	strb	r2, [r4, #10]
		conn->llcp_terminate.reason_final = BT_HCI_ERR_LOCALHOST_TERM_CONN;
 1018cc8:	f885 3148 	strb.w	r3, [r5, #328]	; 0x148
}
 1018ccc:	bd38      	pop	{r3, r4, r5, pc}
		if (ctx->response_opcode == PDU_DATA_LLCTRL_TYPE_LENGTH_RSP) {
 1018cce:	7a4b      	ldrb	r3, [r1, #9]
 1018cd0:	2b15      	cmp	r3, #21
 1018cd2:	d020      	beq.n	1018d16 <lp_comm_complete.constprop.0+0xce>
		} else if (ctx->response_opcode == PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) {
 1018cd4:	2b07      	cmp	r3, #7
 1018cd6:	d1e3      	bne.n	1018ca0 <lp_comm_complete.constprop.0+0x58>
	conn->llcp.fex.features_used &= ~ll_feat_mask;
 1018cd8:	f8d0 3130 	ldr.w	r3, [r0, #304]	; 0x130
 1018cdc:	f023 0320 	bic.w	r3, r3, #32
 1018ce0:	f8c0 3130 	str.w	r3, [r0, #304]	; 0x130
			llcp_lr_complete(conn);
 1018ce4:	f000 fbe6 	bl	10194b4 <llcp_lr_complete>
			ctx->state = LP_COMMON_STATE_IDLE;
 1018ce8:	2300      	movs	r3, #0
		if (!ull_cp_remote_dle_pending(conn)) {
 1018cea:	4628      	mov	r0, r5
				ctx->state = LP_COMMON_STATE_WAIT_NTF;
 1018cec:	72a3      	strb	r3, [r4, #10]
		if (!ull_cp_remote_dle_pending(conn)) {
 1018cee:	f7ff fbc3 	bl	1018478 <ull_cp_remote_dle_pending>
 1018cf2:	2800      	cmp	r0, #0
 1018cf4:	d1c0      	bne.n	1018c78 <lp_comm_complete.constprop.0+0x30>
			llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_DATA_LENGTH);
 1018cf6:	4628      	mov	r0, r5
}
 1018cf8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			llcp_tx_resume_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_DATA_LENGTH);
 1018cfc:	2104      	movs	r1, #4
 1018cfe:	f7ff b909 	b.w	1017f14 <llcp_tx_resume_data>
	if (valid_pdu) {
 1018d02:	7a4b      	ldrb	r3, [r1, #9]
 1018d04:	2b0c      	cmp	r3, #12
 1018d06:	d1cb      	bne.n	1018ca0 <lp_comm_complete.constprop.0+0x58>
		if (!llcp_ntf_alloc_is_available()) {
 1018d08:	f7ff f8da 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 1018d0c:	2800      	cmp	r0, #0
 1018d0e:	d1aa      	bne.n	1018c66 <lp_comm_complete.constprop.0+0x1e>
			ctx->state = LP_COMMON_STATE_WAIT_NTF;
 1018d10:	2304      	movs	r3, #4
 1018d12:	72a3      	strb	r3, [r4, #10]
}
 1018d14:	bd38      	pop	{r3, r4, r5, pc}
			uint8_t dle_changed = ull_dle_update_eff(conn);
 1018d16:	f7fd fe8b 	bl	1016a30 <ull_dle_update_eff>
			if (dle_changed && !llcp_ntf_alloc_is_available()) {
 1018d1a:	b140      	cbz	r0, 1018d2e <lp_comm_complete.constprop.0+0xe6>
 1018d1c:	f7ff f8d0 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 1018d20:	b908      	cbnz	r0, 1018d26 <lp_comm_complete.constprop.0+0xde>
 1018d22:	2304      	movs	r3, #4
 1018d24:	e7e1      	b.n	1018cea <lp_comm_complete.constprop.0+0xa2>
					lp_comm_ntf(conn, ctx);
 1018d26:	4621      	mov	r1, r4
 1018d28:	4628      	mov	r0, r5
 1018d2a:	f7ff ff2d 	bl	1018b88 <lp_comm_ntf>
				llcp_lr_complete(conn);
 1018d2e:	4628      	mov	r0, r5
 1018d30:	f000 fbc0 	bl	10194b4 <llcp_lr_complete>
				ctx->state = LP_COMMON_STATE_IDLE;
 1018d34:	e7d8      	b.n	1018ce8 <lp_comm_complete.constprop.0+0xa0>
 1018d36:	bf00      	nop
 1018d38:	0102abfc 	.word	0x0102abfc
 1018d3c:	0102a300 	.word	0x0102a300
 1018d40:	0102a278 	.word	0x0102a278

01018d44 <lp_comm_send_req.constprop.0.isra.0>:
static void lp_comm_send_req(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
 1018d44:	b570      	push	{r4, r5, r6, lr}
	switch (ctx->proc) {
 1018d46:	7a0e      	ldrb	r6, [r1, #8]
static void lp_comm_send_req(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
 1018d48:	460c      	mov	r4, r1
	switch (ctx->proc) {
 1018d4a:	1e73      	subs	r3, r6, #1
static void lp_comm_send_req(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
 1018d4c:	4605      	mov	r5, r0
	switch (ctx->proc) {
 1018d4e:	2b0b      	cmp	r3, #11
 1018d50:	d807      	bhi.n	1018d62 <lp_comm_send_req.constprop.0.isra.0+0x1e>
 1018d52:	e8df f003 	tbb	[pc, r3]
 1018d56:	1b14      	.short	0x1b14
 1018d58:	06064632 	.word	0x06064632
 1018d5c:	62060606 	.word	0x62060606
 1018d60:	6f06      	.short	0x6f06
		LL_ASSERT(0);
 1018d62:	f44f 732d 	mov.w	r3, #692	; 0x2b4
 1018d66:	4a4f      	ldr	r2, [pc, #316]	; (1018ea4 <lp_comm_send_req.constprop.0.isra.0+0x160>)
 1018d68:	494f      	ldr	r1, [pc, #316]	; (1018ea8 <lp_comm_send_req.constprop.0.isra.0+0x164>)
 1018d6a:	4850      	ldr	r0, [pc, #320]	; (1018eac <lp_comm_send_req.constprop.0.isra.0+0x168>)
 1018d6c:	f00b ff33 	bl	1024bd6 <assert_print>
 1018d70:	4040      	eors	r0, r0
 1018d72:	f380 8811 	msr	BASEPRI, r0
 1018d76:	f04f 0003 	mov.w	r0, #3
 1018d7a:	df02      	svc	2
}
 1018d7c:	bd70      	pop	{r4, r5, r6, pc}
	if (extra_cond || llcp_lr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 1018d7e:	f000 fb05 	bl	101938c <llcp_lr_ispaused>
 1018d82:	2800      	cmp	r0, #0
 1018d84:	d07b      	beq.n	1018e7e <lp_comm_send_req.constprop.0.isra.0+0x13a>
		ctx->state = LP_COMMON_STATE_WAIT_TX;
 1018d86:	2301      	movs	r3, #1
 1018d88:	72a3      	strb	r3, [r4, #10]
}
 1018d8a:	bd70      	pop	{r4, r5, r6, pc}
	if (extra_cond || llcp_lr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 1018d8c:	f000 fafe 	bl	101938c <llcp_lr_ispaused>
 1018d90:	2800      	cmp	r0, #0
 1018d92:	d1f8      	bne.n	1018d86 <lp_comm_send_req.constprop.0.isra.0+0x42>
 1018d94:	4621      	mov	r1, r4
 1018d96:	4628      	mov	r0, r5
 1018d98:	f7ff f87e 	bl	1017e98 <llcp_tx_alloc_peek>
 1018d9c:	2800      	cmp	r0, #0
 1018d9e:	d0f2      	beq.n	1018d86 <lp_comm_send_req.constprop.0.isra.0+0x42>
		lp_comm_tx(conn, ctx);
 1018da0:	4621      	mov	r1, r4
 1018da2:	4628      	mov	r0, r5
 1018da4:	f7ff fcee 	bl	1018784 <lp_comm_tx>
		ctx->state = ctx->tx_ack ? LP_COMMON_STATE_WAIT_TX_ACK : LP_COMMON_STATE_WAIT_RX;
 1018da8:	6962      	ldr	r2, [r4, #20]
			conn->llcp.fex.sent = 1;
 1018daa:	2301      	movs	r3, #1
		ctx->state = ctx->tx_ack ? LP_COMMON_STATE_WAIT_TX_ACK : LP_COMMON_STATE_WAIT_RX;
 1018dac:	2a00      	cmp	r2, #0
 1018dae:	bf08      	it	eq
 1018db0:	2603      	moveq	r6, #3
 1018db2:	72a6      	strb	r6, [r4, #10]
			conn->llcp.fex.sent = 1;
 1018db4:	f885 3120 	strb.w	r3, [r5, #288]	; 0x120
}
 1018db8:	bd70      	pop	{r4, r5, r6, pc}
	if (extra_cond || llcp_lr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 1018dba:	f000 fae7 	bl	101938c <llcp_lr_ispaused>
 1018dbe:	2800      	cmp	r0, #0
 1018dc0:	d1e1      	bne.n	1018d86 <lp_comm_send_req.constprop.0.isra.0+0x42>
 1018dc2:	4621      	mov	r1, r4
 1018dc4:	4628      	mov	r0, r5
 1018dc6:	f7ff f867 	bl	1017e98 <llcp_tx_alloc_peek>
 1018dca:	2800      	cmp	r0, #0
 1018dcc:	d0db      	beq.n	1018d86 <lp_comm_send_req.constprop.0.isra.0+0x42>
		lp_comm_tx(conn, ctx);
 1018dce:	4621      	mov	r1, r4
 1018dd0:	4628      	mov	r0, r5
 1018dd2:	f7ff fcd7 	bl	1018784 <lp_comm_tx>
		ctx->state = ctx->tx_ack ? LP_COMMON_STATE_WAIT_TX_ACK : LP_COMMON_STATE_WAIT_RX;
 1018dd6:	6963      	ldr	r3, [r4, #20]
 1018dd8:	2b00      	cmp	r3, #0
 1018dda:	bf18      	it	ne
 1018ddc:	2602      	movne	r6, #2
 1018dde:	72a6      	strb	r6, [r4, #10]
}
 1018de0:	bd70      	pop	{r4, r5, r6, pc}
		if (!conn->llcp.vex.sent) {
 1018de2:	f890 3114 	ldrb.w	r3, [r0, #276]	; 0x114
 1018de6:	2b00      	cmp	r3, #0
 1018de8:	d13d      	bne.n	1018e66 <lp_comm_send_req.constprop.0.isra.0+0x122>
	if (extra_cond || llcp_lr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 1018dea:	f000 facf 	bl	101938c <llcp_lr_ispaused>
 1018dee:	2800      	cmp	r0, #0
 1018df0:	d1c9      	bne.n	1018d86 <lp_comm_send_req.constprop.0.isra.0+0x42>
 1018df2:	4621      	mov	r1, r4
 1018df4:	4628      	mov	r0, r5
 1018df6:	f7ff f84f 	bl	1017e98 <llcp_tx_alloc_peek>
 1018dfa:	2800      	cmp	r0, #0
 1018dfc:	d0c3      	beq.n	1018d86 <lp_comm_send_req.constprop.0.isra.0+0x42>
		lp_comm_tx(conn, ctx);
 1018dfe:	4621      	mov	r1, r4
 1018e00:	4628      	mov	r0, r5
 1018e02:	f7ff fcbf 	bl	1018784 <lp_comm_tx>
		ctx->state = ctx->tx_ack ? LP_COMMON_STATE_WAIT_TX_ACK : LP_COMMON_STATE_WAIT_RX;
 1018e06:	6962      	ldr	r2, [r4, #20]
				conn->llcp.vex.sent = 1;
 1018e08:	2301      	movs	r3, #1
		ctx->state = ctx->tx_ack ? LP_COMMON_STATE_WAIT_TX_ACK : LP_COMMON_STATE_WAIT_RX;
 1018e0a:	2a00      	cmp	r2, #0
 1018e0c:	bf0c      	ite	eq
 1018e0e:	2203      	moveq	r2, #3
 1018e10:	2202      	movne	r2, #2
 1018e12:	72a2      	strb	r2, [r4, #10]
				conn->llcp.vex.sent = 1;
 1018e14:	f885 3114 	strb.w	r3, [r5, #276]	; 0x114
}
 1018e18:	bd70      	pop	{r4, r5, r6, pc}
		if (!llcp_tx_alloc_peek(conn, ctx)) {
 1018e1a:	f7ff f83d 	bl	1017e98 <llcp_tx_alloc_peek>
 1018e1e:	2800      	cmp	r0, #0
 1018e20:	d0b1      	beq.n	1018d86 <lp_comm_send_req.constprop.0.isra.0+0x42>
			lp_comm_tx(conn, ctx);
 1018e22:	4621      	mov	r1, r4
 1018e24:	4628      	mov	r0, r5
 1018e26:	f7ff fcad 	bl	1018784 <lp_comm_tx>
			ctx->data.term.error_code = BT_HCI_ERR_LOCALHOST_TERM_CONN;
 1018e2a:	2216      	movs	r2, #22
			ctx->state = LP_COMMON_STATE_WAIT_TX_ACK;
 1018e2c:	2302      	movs	r3, #2
			ctx->data.term.error_code = BT_HCI_ERR_LOCALHOST_TERM_CONN;
 1018e2e:	7722      	strb	r2, [r4, #28]
			ctx->state = LP_COMMON_STATE_WAIT_TX_ACK;
 1018e30:	72a3      	strb	r3, [r4, #10]
}
 1018e32:	bd70      	pop	{r4, r5, r6, pc}
		if (!ull_cp_remote_dle_pending(conn)) {
 1018e34:	f7ff fb20 	bl	1018478 <ull_cp_remote_dle_pending>
 1018e38:	b9d8      	cbnz	r0, 1018e72 <lp_comm_send_req.constprop.0.isra.0+0x12e>
			if (llcp_lr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 1018e3a:	4628      	mov	r0, r5
 1018e3c:	f000 faa6 	bl	101938c <llcp_lr_ispaused>
 1018e40:	2800      	cmp	r0, #0
 1018e42:	d1a0      	bne.n	1018d86 <lp_comm_send_req.constprop.0.isra.0+0x42>
 1018e44:	4621      	mov	r1, r4
 1018e46:	4628      	mov	r0, r5
 1018e48:	f7ff f826 	bl	1017e98 <llcp_tx_alloc_peek>
 1018e4c:	2800      	cmp	r0, #0
 1018e4e:	d09a      	beq.n	1018d86 <lp_comm_send_req.constprop.0.isra.0+0x42>
				llcp_tx_pause_data(conn, LLCP_TX_QUEUE_PAUSE_DATA_DATA_LENGTH);
 1018e50:	2104      	movs	r1, #4
 1018e52:	4628      	mov	r0, r5
 1018e54:	f7ff f84a 	bl	1017eec <llcp_tx_pause_data>
				lp_comm_tx(conn, ctx);
 1018e58:	4621      	mov	r1, r4
 1018e5a:	4628      	mov	r0, r5
 1018e5c:	f7ff fc92 	bl	1018784 <lp_comm_tx>
				ctx->state = LP_COMMON_STATE_WAIT_RX;
 1018e60:	2303      	movs	r3, #3
 1018e62:	72a3      	strb	r3, [r4, #10]
}
 1018e64:	bd70      	pop	{r4, r5, r6, pc}
			ctx->response_opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 1018e66:	230c      	movs	r3, #12
 1018e68:	724b      	strb	r3, [r1, #9]
}
 1018e6a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			lp_comm_complete(conn, ctx, evt, param);
 1018e6e:	f7ff beeb 	b.w	1018c48 <lp_comm_complete.constprop.0>
			llcp_lr_complete(conn);
 1018e72:	4628      	mov	r0, r5
 1018e74:	f000 fb1e 	bl	10194b4 <llcp_lr_complete>
			ctx->state = LP_COMMON_STATE_IDLE;
 1018e78:	2300      	movs	r3, #0
 1018e7a:	72a3      	strb	r3, [r4, #10]
}
 1018e7c:	bd70      	pop	{r4, r5, r6, pc}
	if (extra_cond || llcp_lr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 1018e7e:	4621      	mov	r1, r4
 1018e80:	4628      	mov	r0, r5
 1018e82:	f7ff f809 	bl	1017e98 <llcp_tx_alloc_peek>
 1018e86:	2800      	cmp	r0, #0
 1018e88:	f43f af7d 	beq.w	1018d86 <lp_comm_send_req.constprop.0.isra.0+0x42>
		lp_comm_tx(conn, ctx);
 1018e8c:	4621      	mov	r1, r4
 1018e8e:	4628      	mov	r0, r5
 1018e90:	f7ff fc78 	bl	1018784 <lp_comm_tx>
		ctx->state = ctx->tx_ack ? LP_COMMON_STATE_WAIT_TX_ACK : LP_COMMON_STATE_WAIT_RX;
 1018e94:	6963      	ldr	r3, [r4, #20]
 1018e96:	2b00      	cmp	r3, #0
 1018e98:	bf0c      	ite	eq
 1018e9a:	2303      	moveq	r3, #3
 1018e9c:	2302      	movne	r3, #2
 1018e9e:	72a3      	strb	r3, [r4, #10]
}
 1018ea0:	bd70      	pop	{r4, r5, r6, pc}
 1018ea2:	bf00      	nop
 1018ea4:	0102abfc 	.word	0x0102abfc
 1018ea8:	0102a300 	.word	0x0102a300
 1018eac:	0102a278 	.word	0x0102a278

01018eb0 <lp_comm_execute_fsm>:
{
 1018eb0:	b530      	push	{r4, r5, lr}
 1018eb2:	460c      	mov	r4, r1
	switch (ctx->state) {
 1018eb4:	7a89      	ldrb	r1, [r1, #10]
{
 1018eb6:	4605      	mov	r5, r0
 1018eb8:	b083      	sub	sp, #12
	switch (ctx->state) {
 1018eba:	2904      	cmp	r1, #4
 1018ebc:	f200 8081 	bhi.w	1018fc2 <lp_comm_execute_fsm+0x112>
 1018ec0:	e8df f001 	tbb	[pc, r1]
 1018ec4:	361d2d1a 	.word	0x361d2d1a
 1018ec8:	03          	.byte	0x03
 1018ec9:	00          	.byte	0x00
	switch (evt) {
 1018eca:	b9b2      	cbnz	r2, 1018efa <lp_comm_execute_fsm+0x4a>
		switch (ctx->proc) {
 1018ecc:	7a21      	ldrb	r1, [r4, #8]
 1018ece:	290c      	cmp	r1, #12
 1018ed0:	d813      	bhi.n	1018efa <lp_comm_execute_fsm+0x4a>
 1018ed2:	f241 0314 	movw	r3, #4116	; 0x1014
 1018ed6:	40cb      	lsrs	r3, r1
 1018ed8:	07db      	lsls	r3, r3, #31
 1018eda:	d50e      	bpl.n	1018efa <lp_comm_execute_fsm+0x4a>
			if (llcp_ntf_alloc_is_available()) {
 1018edc:	9201      	str	r2, [sp, #4]
 1018ede:	f7fe ffef 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 1018ee2:	b150      	cbz	r0, 1018efa <lp_comm_execute_fsm+0x4a>
				lp_comm_ntf(conn, ctx);
 1018ee4:	4621      	mov	r1, r4
 1018ee6:	4628      	mov	r0, r5
 1018ee8:	f7ff fe4e 	bl	1018b88 <lp_comm_ntf>
				llcp_lr_complete(conn);
 1018eec:	4628      	mov	r0, r5
 1018eee:	f000 fae1 	bl	10194b4 <llcp_lr_complete>
				ctx->state = LP_COMMON_STATE_IDLE;
 1018ef2:	9a01      	ldr	r2, [sp, #4]
 1018ef4:	72a2      	strb	r2, [r4, #10]
 1018ef6:	e000      	b.n	1018efa <lp_comm_execute_fsm+0x4a>
	switch (evt) {
 1018ef8:	b37a      	cbz	r2, 1018f5a <lp_comm_execute_fsm+0xaa>
}
 1018efa:	b003      	add	sp, #12
 1018efc:	bd30      	pop	{r4, r5, pc}
	switch (evt) {
 1018efe:	2a05      	cmp	r2, #5
 1018f00:	d1fb      	bne.n	1018efa <lp_comm_execute_fsm+0x4a>
		switch (ctx->proc) {
 1018f02:	7a23      	ldrb	r3, [r4, #8]
 1018f04:	2b03      	cmp	r3, #3
 1018f06:	d001      	beq.n	1018f0c <lp_comm_execute_fsm+0x5c>
 1018f08:	2b0a      	cmp	r3, #10
 1018f0a:	d1f6      	bne.n	1018efa <lp_comm_execute_fsm+0x4a>
			ctx->tx_ack = NULL;
 1018f0c:	2300      	movs	r3, #0
			lp_comm_complete(conn, ctx, evt, param);
 1018f0e:	4621      	mov	r1, r4
 1018f10:	4628      	mov	r0, r5
			ctx->tx_ack = NULL;
 1018f12:	6163      	str	r3, [r4, #20]
}
 1018f14:	b003      	add	sp, #12
 1018f16:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		lp_comm_complete(conn, ctx, evt, param);
 1018f1a:	f7ff be95 	b.w	1018c48 <lp_comm_complete.constprop.0>
	switch (evt) {
 1018f1e:	2a00      	cmp	r2, #0
 1018f20:	d1eb      	bne.n	1018efa <lp_comm_execute_fsm+0x4a>
		lp_comm_send_req(conn, ctx, evt, param);
 1018f22:	4621      	mov	r1, r4
 1018f24:	4628      	mov	r0, r5
}
 1018f26:	b003      	add	sp, #12
 1018f28:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		lp_comm_send_req(conn, ctx, evt, param);
 1018f2c:	f7ff bf0a 	b.w	1018d44 <lp_comm_send_req.constprop.0.isra.0>
	switch (evt) {
 1018f30:	2a01      	cmp	r2, #1
 1018f32:	d1e2      	bne.n	1018efa <lp_comm_execute_fsm+0x4a>
	ctx->response_opcode = pdu->llctrl.opcode;
 1018f34:	78d9      	ldrb	r1, [r3, #3]
	switch (pdu->llctrl.opcode) {
 1018f36:	1e8a      	subs	r2, r1, #2
	ctx->response_opcode = pdu->llctrl.opcode;
 1018f38:	7261      	strb	r1, [r4, #9]
	switch (pdu->llctrl.opcode) {
 1018f3a:	2a17      	cmp	r2, #23
 1018f3c:	d815      	bhi.n	1018f6a <lp_comm_execute_fsm+0xba>
 1018f3e:	e8df f002 	tbb	[pc, r2]
 1018f42:	1433      	.short	0x1433
 1018f44:	2e141414 	.word	0x2e141414
 1018f48:	14142914 	.word	0x14142914
 1018f4c:	14142124 	.word	0x14142124
 1018f50:	21143b14 	.word	0x21143b14
 1018f54:	14143614 	.word	0x14143614
 1018f58:	2114      	.short	0x2114
		if (llcp_lr_ispaused(conn)) {
 1018f5a:	4628      	mov	r0, r5
 1018f5c:	f000 fa16 	bl	101938c <llcp_lr_ispaused>
 1018f60:	2800      	cmp	r0, #0
 1018f62:	d0de      	beq.n	1018f22 <lp_comm_execute_fsm+0x72>
			ctx->state = LP_COMMON_STATE_WAIT_TX;
 1018f64:	2301      	movs	r3, #1
 1018f66:	72a3      	strb	r3, [r4, #10]
 1018f68:	e7c7      	b.n	1018efa <lp_comm_execute_fsm+0x4a>
		LL_ASSERT(0);
 1018f6a:	f240 333b 	movw	r3, #827	; 0x33b
 1018f6e:	4a1c      	ldr	r2, [pc, #112]	; (1018fe0 <lp_comm_execute_fsm+0x130>)
 1018f70:	491c      	ldr	r1, [pc, #112]	; (1018fe4 <lp_comm_execute_fsm+0x134>)
 1018f72:	481d      	ldr	r0, [pc, #116]	; (1018fe8 <lp_comm_execute_fsm+0x138>)
 1018f74:	f00b fe2f 	bl	1024bd6 <assert_print>
 1018f78:	4040      	eors	r0, r0
 1018f7a:	f380 8811 	msr	BASEPRI, r0
 1018f7e:	f04f 0003 	mov.w	r0, #3
 1018f82:	df02      	svc	2
		lp_comm_complete(conn, ctx, evt, param);
 1018f84:	4621      	mov	r1, r4
 1018f86:	4628      	mov	r0, r5
 1018f88:	e7c4      	b.n	1018f14 <lp_comm_execute_fsm+0x64>
		llcp_pdu_decode_version_ind(conn, pdu);
 1018f8a:	4619      	mov	r1, r3
 1018f8c:	4628      	mov	r0, r5
 1018f8e:	f000 fc07 	bl	10197a0 <llcp_pdu_decode_version_ind>
		break;
 1018f92:	e7f7      	b.n	1018f84 <lp_comm_execute_fsm+0xd4>
		llcp_pdu_decode_feature_rsp(conn, pdu);
 1018f94:	4619      	mov	r1, r3
 1018f96:	4628      	mov	r0, r5
 1018f98:	f000 fba0 	bl	10196dc <llcp_pdu_decode_feature_rsp>
		if (feature_phy_coded(conn)) {
 1018f9c:	e7f2      	b.n	1018f84 <lp_comm_execute_fsm+0xd4>
		llcp_pdu_decode_unknown_rsp(ctx, pdu);
 1018f9e:	4619      	mov	r1, r3
 1018fa0:	4620      	mov	r0, r4
 1018fa2:	f000 fb0d 	bl	10195c0 <llcp_pdu_decode_unknown_rsp>
		break;
 1018fa6:	e7ed      	b.n	1018f84 <lp_comm_execute_fsm+0xd4>
		LL_ASSERT(0);
 1018fa8:	f240 3322 	movw	r3, #802	; 0x322
 1018fac:	e7df      	b.n	1018f6e <lp_comm_execute_fsm+0xbe>
		llcp_pdu_decode_length_rsp(conn, pdu);
 1018fae:	4619      	mov	r1, r3
 1018fb0:	4628      	mov	r0, r5
 1018fb2:	f000 fdf1 	bl	1019b98 <llcp_pdu_decode_length_rsp>
		break;
 1018fb6:	e7e5      	b.n	1018f84 <lp_comm_execute_fsm+0xd4>
		llcp_pdu_decode_reject_ext_ind(ctx, pdu);
 1018fb8:	4619      	mov	r1, r3
 1018fba:	4620      	mov	r0, r4
 1018fbc:	f000 fc70 	bl	10198a0 <llcp_pdu_decode_reject_ext_ind>
		break;
 1018fc0:	e7e0      	b.n	1018f84 <lp_comm_execute_fsm+0xd4>
		LL_ASSERT(0);
 1018fc2:	f44f 7362 	mov.w	r3, #904	; 0x388
 1018fc6:	4a06      	ldr	r2, [pc, #24]	; (1018fe0 <lp_comm_execute_fsm+0x130>)
 1018fc8:	4906      	ldr	r1, [pc, #24]	; (1018fe4 <lp_comm_execute_fsm+0x134>)
 1018fca:	4807      	ldr	r0, [pc, #28]	; (1018fe8 <lp_comm_execute_fsm+0x138>)
 1018fcc:	f00b fe03 	bl	1024bd6 <assert_print>
 1018fd0:	4040      	eors	r0, r0
 1018fd2:	f380 8811 	msr	BASEPRI, r0
 1018fd6:	f04f 0003 	mov.w	r0, #3
 1018fda:	df02      	svc	2
}
 1018fdc:	e78d      	b.n	1018efa <lp_comm_execute_fsm+0x4a>
 1018fde:	bf00      	nop
 1018fe0:	0102abfc 	.word	0x0102abfc
 1018fe4:	0102a300 	.word	0x0102a300
 1018fe8:	0102a278 	.word	0x0102a278

01018fec <llcp_lp_comm_tx_ack>:
{
 1018fec:	4613      	mov	r3, r2
	lp_comm_execute_fsm(conn, ctx, LP_COMMON_EVT_ACK, tx->pdu);
 1018fee:	2205      	movs	r2, #5
 1018ff0:	3304      	adds	r3, #4
 1018ff2:	f7ff bf5d 	b.w	1018eb0 <lp_comm_execute_fsm>
 1018ff6:	bf00      	nop

01018ff8 <llcp_lp_comm_rx>:
{
 1018ff8:	4613      	mov	r3, r2
	lp_comm_execute_fsm(conn, ctx, LP_COMMON_EVT_RESPONSE, rx->pdu);
 1018ffa:	2201      	movs	r2, #1
 1018ffc:	331c      	adds	r3, #28
 1018ffe:	f7ff bf57 	b.w	1018eb0 <lp_comm_execute_fsm>
 1019002:	bf00      	nop

01019004 <llcp_lp_comm_init_proc>:
	ctx->state = LP_COMMON_STATE_IDLE;
 1019004:	2300      	movs	r3, #0
 1019006:	7283      	strb	r3, [r0, #10]
}
 1019008:	4770      	bx	lr
 101900a:	bf00      	nop

0101900c <llcp_lp_comm_run>:
{
 101900c:	4613      	mov	r3, r2
	lp_comm_execute_fsm(conn, ctx, LP_COMMON_EVT_RUN, param);
 101900e:	2200      	movs	r2, #0
 1019010:	f7ff bf4e 	b.w	1018eb0 <lp_comm_execute_fsm>

01019014 <llcp_rp_comm_rx>:

void llcp_rp_comm_rx(struct ll_conn *conn, struct proc_ctx *ctx, struct node_rx_pdu *rx)
{
 1019014:	4613      	mov	r3, r2
	rp_comm_execute_fsm(conn, ctx, RP_COMMON_EVT_REQUEST, rx->pdu);
 1019016:	2202      	movs	r2, #2
 1019018:	331c      	adds	r3, #28
 101901a:	f7ff bd03 	b.w	1018a24 <rp_comm_execute_fsm>
 101901e:	bf00      	nop

01019020 <llcp_rp_comm_tx_ack>:
}

void llcp_rp_comm_tx_ack(struct ll_conn *conn, struct proc_ctx *ctx, struct node_tx *tx)
{
 1019020:	4613      	mov	r3, r2
	rp_comm_execute_fsm(conn, ctx, RP_COMMON_EVT_ACK, tx->pdu);
 1019022:	2201      	movs	r2, #1
 1019024:	3304      	adds	r3, #4
 1019026:	f7ff bcfd 	b.w	1018a24 <rp_comm_execute_fsm>
 101902a:	bf00      	nop

0101902c <llcp_rp_comm_init_proc>:
}

void llcp_rp_comm_init_proc(struct proc_ctx *ctx)
 101902c:	2300      	movs	r3, #0
 101902e:	7283      	strb	r3, [r0, #10]
 1019030:	4770      	bx	lr
 1019032:	bf00      	nop

01019034 <llcp_rp_comm_run>:
{
	ctx->state = RP_COMMON_STATE_IDLE;
}

void llcp_rp_comm_run(struct ll_conn *conn, struct proc_ctx *ctx, void *param)
{
 1019034:	4613      	mov	r3, r2
	rp_comm_execute_fsm(conn, ctx, RP_COMMON_EVT_RUN, param);
 1019036:	2200      	movs	r2, #0
 1019038:	f7ff bcf4 	b.w	1018a24 <rp_comm_execute_fsm>

0101903c <lr_dequeue>:

	shared_data_access_unlock(key);
}

static struct proc_ctx *lr_dequeue(struct ll_conn *conn)
{
 101903c:	b570      	push	{r4, r5, r6, lr}
 101903e:	4604      	mov	r4, r0
	if (mayfly_is_running()) {
 1019040:	f004 fd32 	bl	101daa8 <mayfly_is_running>
 1019044:	b168      	cbz	r0, 1019062 <lr_dequeue+0x26>
	return list->head;
 1019046:	f8d4 50e8 	ldr.w	r5, [r4, #232]	; 0xe8
Z_GENLIST_GET(slist, snode)
 101904a:	b145      	cbz	r5, 101905e <lr_dequeue+0x22>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 101904c:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
	return node->next;
 1019050:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1019052:	4295      	cmp	r5, r2
	list->head = node;
 1019054:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
	list->tail = node;
 1019058:	bf08      	it	eq
 101905a:	f8c4 30ec 	streq.w	r3, [r4, #236]	; 0xec
	ctx = (struct proc_ctx *)sys_slist_get(&conn->llcp.local.pend_proc_list);

	shared_data_access_unlock(key);

	return ctx;
}
 101905e:	4628      	mov	r0, r5
 1019060:	bd70      	pop	{r4, r5, r6, pc}
	enabled = mayfly_is_enabled(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH) != 0U;
 1019062:	4605      	mov	r5, r0
 1019064:	2101      	movs	r1, #1
 1019066:	2003      	movs	r0, #3
 1019068:	f004 fcc0 	bl	101d9ec <mayfly_is_enabled>
	mayfly_enable(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 0U);
 101906c:	462a      	mov	r2, r5
	enabled = mayfly_is_enabled(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH) != 0U;
 101906e:	4606      	mov	r6, r0
	mayfly_enable(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 0U);
 1019070:	2101      	movs	r1, #1
 1019072:	2003      	movs	r0, #3
 1019074:	f7f7 ff82 	bl	1010f7c <mayfly_enable>
	return list->head;
 1019078:	f8d4 50e8 	ldr.w	r5, [r4, #232]	; 0xe8
Z_GENLIST_GET(slist, snode)
 101907c:	b145      	cbz	r5, 1019090 <lr_dequeue+0x54>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 101907e:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
	return node->next;
 1019082:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1019084:	4295      	cmp	r5, r2
	list->head = node;
 1019086:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
	list->tail = node;
 101908a:	bf08      	it	eq
 101908c:	f8c4 30ec 	streq.w	r3, [r4, #236]	; 0xec
	if (key) {
 1019090:	2e00      	cmp	r6, #0
 1019092:	d0e4      	beq.n	101905e <lr_dequeue+0x22>
		mayfly_enable(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 1U);
 1019094:	2201      	movs	r2, #1
 1019096:	2003      	movs	r0, #3
 1019098:	4611      	mov	r1, r2
 101909a:	f7f7 ff6f 	bl	1010f7c <mayfly_enable>
}
 101909e:	4628      	mov	r0, r5
 10190a0:	bd70      	pop	{r4, r5, r6, pc}
 10190a2:	bf00      	nop

010190a4 <lr_act_complete>:

	lr_check_done(conn, ctx);
}

static void lr_act_complete(struct ll_conn *conn)
{
 10190a4:	b570      	push	{r4, r5, r6, lr}
 10190a6:	4604      	mov	r4, r0
	if (mayfly_is_running()) {
 10190a8:	f004 fcfe 	bl	101daa8 <mayfly_is_running>
 10190ac:	b140      	cbz	r0, 10190c0 <lr_act_complete+0x1c>
	return list->head;
 10190ae:	f8d4 50e8 	ldr.w	r5, [r4, #232]	; 0xe8
	struct proc_ctx *ctx;

	ctx = llcp_lr_peek(conn);
	LL_ASSERT(ctx != NULL);
 10190b2:	b1dd      	cbz	r5, 10190ec <lr_act_complete+0x48>
	conn->llcp.local.prt_expire = 0U;
 10190b4:	2200      	movs	r2, #0

	/* Stop procedure response timeout timer */
	llcp_lr_prt_stop(conn);

	/* Mark the procedure as safe to delete */
	ctx->done = 1U;
 10190b6:	2301      	movs	r3, #1
	conn->llcp.local.prt_expire = 0U;
 10190b8:	f8a4 20f2 	strh.w	r2, [r4, #242]	; 0xf2
	ctx->done = 1U;
 10190bc:	61ab      	str	r3, [r5, #24]
}
 10190be:	bd70      	pop	{r4, r5, r6, pc}
	enabled = mayfly_is_enabled(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH) != 0U;
 10190c0:	4605      	mov	r5, r0
 10190c2:	2101      	movs	r1, #1
 10190c4:	2003      	movs	r0, #3
 10190c6:	f004 fc91 	bl	101d9ec <mayfly_is_enabled>
 10190ca:	4606      	mov	r6, r0
	mayfly_enable(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 0U);
 10190cc:	462a      	mov	r2, r5
 10190ce:	2101      	movs	r1, #1
 10190d0:	2003      	movs	r0, #3
 10190d2:	f7f7 ff53 	bl	1010f7c <mayfly_enable>
 10190d6:	f8d4 50e8 	ldr.w	r5, [r4, #232]	; 0xe8
	if (key) {
 10190da:	2e00      	cmp	r6, #0
 10190dc:	d0e9      	beq.n	10190b2 <lr_act_complete+0xe>
		mayfly_enable(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 1U);
 10190de:	2201      	movs	r2, #1
 10190e0:	2003      	movs	r0, #3
 10190e2:	4611      	mov	r1, r2
 10190e4:	f7f7 ff4a 	bl	1010f7c <mayfly_enable>
	LL_ASSERT(ctx != NULL);
 10190e8:	2d00      	cmp	r5, #0
 10190ea:	d1e3      	bne.n	10190b4 <lr_act_complete+0x10>
 10190ec:	f240 139b 	movw	r3, #411	; 0x19b
 10190f0:	4a05      	ldr	r2, [pc, #20]	; (1019108 <lr_act_complete+0x64>)
 10190f2:	4906      	ldr	r1, [pc, #24]	; (101910c <lr_act_complete+0x68>)
 10190f4:	4806      	ldr	r0, [pc, #24]	; (1019110 <lr_act_complete+0x6c>)
 10190f6:	f00b fd6e 	bl	1024bd6 <assert_print>
 10190fa:	4040      	eors	r0, r0
 10190fc:	f380 8811 	msr	BASEPRI, r0
 1019100:	f04f 0003 	mov.w	r0, #3
 1019104:	df02      	svc	2
 1019106:	e7d5      	b.n	10190b4 <lr_act_complete+0x10>
 1019108:	0102ac60 	.word	0x0102ac60
 101910c:	0102aca8 	.word	0x0102aca8
 1019110:	0102a278 	.word	0x0102a278

01019114 <lr_check_done.part.0>:
static void lr_check_done(struct ll_conn *conn, struct proc_ctx *ctx)
 1019114:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1019116:	4605      	mov	r5, r0
 1019118:	460c      	mov	r4, r1
	if (mayfly_is_running()) {
 101911a:	f004 fcc5 	bl	101daa8 <mayfly_is_running>
 101911e:	b1b8      	cbz	r0, 1019150 <lr_check_done.part.0+0x3c>
 1019120:	f8d5 60e8 	ldr.w	r6, [r5, #232]	; 0xe8
		LL_ASSERT(ctx_header == ctx);
 1019124:	42b4      	cmp	r4, r6
 1019126:	d00b      	beq.n	1019140 <lr_check_done.part.0+0x2c>
 1019128:	234e      	movs	r3, #78	; 0x4e
 101912a:	4a14      	ldr	r2, [pc, #80]	; (101917c <lr_check_done.part.0+0x68>)
 101912c:	4914      	ldr	r1, [pc, #80]	; (1019180 <lr_check_done.part.0+0x6c>)
 101912e:	4815      	ldr	r0, [pc, #84]	; (1019184 <lr_check_done.part.0+0x70>)
 1019130:	f00b fd51 	bl	1024bd6 <assert_print>
 1019134:	4040      	eors	r0, r0
 1019136:	f380 8811 	msr	BASEPRI, r0
 101913a:	f04f 0003 	mov.w	r0, #3
 101913e:	df02      	svc	2
		lr_dequeue(conn);
 1019140:	4628      	mov	r0, r5
 1019142:	f7ff ff7b 	bl	101903c <lr_dequeue>
		llcp_proc_ctx_release(ctx);
 1019146:	4620      	mov	r0, r4
}
 1019148:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		llcp_proc_ctx_release(ctx);
 101914c:	f7fe be82 	b.w	1017e54 <llcp_proc_ctx_release>
	enabled = mayfly_is_enabled(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH) != 0U;
 1019150:	4606      	mov	r6, r0
 1019152:	2101      	movs	r1, #1
 1019154:	2003      	movs	r0, #3
 1019156:	f004 fc49 	bl	101d9ec <mayfly_is_enabled>
 101915a:	4607      	mov	r7, r0
	mayfly_enable(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 0U);
 101915c:	4632      	mov	r2, r6
 101915e:	2101      	movs	r1, #1
 1019160:	2003      	movs	r0, #3
 1019162:	f7f7 ff0b 	bl	1010f7c <mayfly_enable>
 1019166:	f8d5 60e8 	ldr.w	r6, [r5, #232]	; 0xe8
	if (key) {
 101916a:	2f00      	cmp	r7, #0
 101916c:	d0da      	beq.n	1019124 <lr_check_done.part.0+0x10>
		mayfly_enable(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 1U);
 101916e:	2201      	movs	r2, #1
 1019170:	2003      	movs	r0, #3
 1019172:	4611      	mov	r1, r2
 1019174:	f7f7 ff02 	bl	1010f7c <mayfly_enable>
 1019178:	e7d4      	b.n	1019124 <lr_check_done.part.0+0x10>
 101917a:	bf00      	nop
 101917c:	0102ac60 	.word	0x0102ac60
 1019180:	0102acbc 	.word	0x0102acbc
 1019184:	0102a278 	.word	0x0102a278

01019188 <llcp_lr_enqueue>:
{
 1019188:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 101918a:	4605      	mov	r5, r0
 101918c:	460c      	mov	r4, r1
	if (mayfly_is_running()) {
 101918e:	f004 fc8b 	bl	101daa8 <mayfly_is_running>
 1019192:	b140      	cbz	r0, 10191a6 <llcp_lr_enqueue+0x1e>
	parent->next = child;
 1019194:	2300      	movs	r3, #0
 1019196:	6023      	str	r3, [r4, #0]
	return list->tail;
 1019198:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
Z_GENLIST_APPEND(slist, snode)
 101919c:	b1f3      	cbz	r3, 10191dc <llcp_lr_enqueue+0x54>
	parent->next = child;
 101919e:	601c      	str	r4, [r3, #0]
	list->tail = node;
 10191a0:	f8c5 40ec 	str.w	r4, [r5, #236]	; 0xec
}
 10191a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	enabled = mayfly_is_enabled(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH) != 0U;
 10191a6:	4606      	mov	r6, r0
 10191a8:	2101      	movs	r1, #1
 10191aa:	2003      	movs	r0, #3
 10191ac:	f004 fc1e 	bl	101d9ec <mayfly_is_enabled>
	mayfly_enable(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 0U);
 10191b0:	4632      	mov	r2, r6
	enabled = mayfly_is_enabled(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH) != 0U;
 10191b2:	4607      	mov	r7, r0
	mayfly_enable(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 0U);
 10191b4:	2101      	movs	r1, #1
 10191b6:	2003      	movs	r0, #3
 10191b8:	f7f7 fee0 	bl	1010f7c <mayfly_enable>
	parent->next = child;
 10191bc:	6026      	str	r6, [r4, #0]
	return list->tail;
 10191be:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
Z_GENLIST_APPEND(slist, snode)
 10191c2:	b183      	cbz	r3, 10191e6 <llcp_lr_enqueue+0x5e>
	parent->next = child;
 10191c4:	601c      	str	r4, [r3, #0]
	list->tail = node;
 10191c6:	f8c5 40ec 	str.w	r4, [r5, #236]	; 0xec
	if (key) {
 10191ca:	2f00      	cmp	r7, #0
 10191cc:	d0ea      	beq.n	10191a4 <llcp_lr_enqueue+0x1c>
}
 10191ce:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		mayfly_enable(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 1U);
 10191d2:	2201      	movs	r2, #1
 10191d4:	2003      	movs	r0, #3
 10191d6:	4611      	mov	r1, r2
 10191d8:	f7f7 bed0 	b.w	1010f7c <mayfly_enable>
	list->head = node;
 10191dc:	f8c5 40e8 	str.w	r4, [r5, #232]	; 0xe8
 10191e0:	f8c5 40ec 	str.w	r4, [r5, #236]	; 0xec
}
 10191e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 10191e6:	f8c5 40e8 	str.w	r4, [r5, #232]	; 0xe8
 10191ea:	f8c5 40ec 	str.w	r4, [r5, #236]	; 0xec
}
 10191ee:	e7ec      	b.n	10191ca <llcp_lr_enqueue+0x42>

010191f0 <llcp_lr_peek>:
{
 10191f0:	b570      	push	{r4, r5, r6, lr}
 10191f2:	4605      	mov	r5, r0
	if (mayfly_is_running()) {
 10191f4:	f004 fc58 	bl	101daa8 <mayfly_is_running>
 10191f8:	b118      	cbz	r0, 1019202 <llcp_lr_peek+0x12>
	return list->head;
 10191fa:	f8d5 40e8 	ldr.w	r4, [r5, #232]	; 0xe8
}
 10191fe:	4620      	mov	r0, r4
 1019200:	bd70      	pop	{r4, r5, r6, pc}
	enabled = mayfly_is_enabled(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH) != 0U;
 1019202:	4604      	mov	r4, r0
 1019204:	2101      	movs	r1, #1
 1019206:	2003      	movs	r0, #3
 1019208:	f004 fbf0 	bl	101d9ec <mayfly_is_enabled>
 101920c:	4606      	mov	r6, r0
	mayfly_enable(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 0U);
 101920e:	4622      	mov	r2, r4
 1019210:	2101      	movs	r1, #1
 1019212:	2003      	movs	r0, #3
 1019214:	f7f7 feb2 	bl	1010f7c <mayfly_enable>
 1019218:	f8d5 40e8 	ldr.w	r4, [r5, #232]	; 0xe8
	if (key) {
 101921c:	2e00      	cmp	r6, #0
 101921e:	d0ee      	beq.n	10191fe <llcp_lr_peek+0xe>
		mayfly_enable(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 1U);
 1019220:	2201      	movs	r2, #1
 1019222:	2003      	movs	r0, #3
 1019224:	4611      	mov	r1, r2
 1019226:	f7f7 fea9 	bl	1010f7c <mayfly_enable>
}
 101922a:	4620      	mov	r0, r4
 101922c:	bd70      	pop	{r4, r5, r6, pc}
 101922e:	bf00      	nop

01019230 <lr_act_run>:
{
 1019230:	b538      	push	{r3, r4, r5, lr}
 1019232:	4605      	mov	r5, r0
	ctx = llcp_lr_peek(conn);
 1019234:	f7ff ffdc 	bl	10191f0 <llcp_lr_peek>
	switch (ctx->proc) {
 1019238:	7a03      	ldrb	r3, [r0, #8]
	ctx = llcp_lr_peek(conn);
 101923a:	4604      	mov	r4, r0
	switch (ctx->proc) {
 101923c:	3b01      	subs	r3, #1
 101923e:	2b0b      	cmp	r3, #11
 1019240:	d81b      	bhi.n	101927a <lr_act_run+0x4a>
 1019242:	e8df f003 	tbb	[pc, r3]
 1019246:	0606      	.short	0x0606
 1019248:	1a1a0606 	.word	0x1a1a0606
 101924c:	06141428 	.word	0x06141428
 1019250:	061a      	.short	0x061a
		llcp_lp_comm_run(conn, ctx, NULL);
 1019252:	4601      	mov	r1, r0
 1019254:	2200      	movs	r2, #0
 1019256:	4628      	mov	r0, r5
 1019258:	f7ff fed8 	bl	101900c <llcp_lp_comm_run>
	if (ctx->done) {
 101925c:	69a3      	ldr	r3, [r4, #24]
 101925e:	b903      	cbnz	r3, 1019262 <lr_act_run+0x32>
}
 1019260:	bd38      	pop	{r3, r4, r5, pc}
 1019262:	4621      	mov	r1, r4
 1019264:	4628      	mov	r0, r5
 1019266:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 101926a:	f7ff bf53 	b.w	1019114 <lr_check_done.part.0>
		llcp_lp_cu_run(conn, ctx, NULL);
 101926e:	4601      	mov	r1, r0
 1019270:	2200      	movs	r2, #0
 1019272:	4628      	mov	r0, r5
 1019274:	f001 f934 	bl	101a4e0 <llcp_lp_cu_run>
		break;
 1019278:	e7f0      	b.n	101925c <lr_act_run+0x2c>
		LL_ASSERT(0);
 101927a:	f240 138f 	movw	r3, #399	; 0x18f
 101927e:	4a09      	ldr	r2, [pc, #36]	; (10192a4 <lr_act_run+0x74>)
 1019280:	4909      	ldr	r1, [pc, #36]	; (10192a8 <lr_act_run+0x78>)
 1019282:	480a      	ldr	r0, [pc, #40]	; (10192ac <lr_act_run+0x7c>)
 1019284:	f00b fca7 	bl	1024bd6 <assert_print>
 1019288:	4040      	eors	r0, r0
 101928a:	f380 8811 	msr	BASEPRI, r0
 101928e:	f04f 0003 	mov.w	r0, #3
 1019292:	df02      	svc	2
		break;
 1019294:	e7e2      	b.n	101925c <lr_act_run+0x2c>
		llcp_lp_pu_run(conn, ctx, NULL);
 1019296:	4601      	mov	r1, r0
 1019298:	2200      	movs	r2, #0
 101929a:	4628      	mov	r0, r5
 101929c:	f7fe f87c 	bl	1017398 <llcp_lp_pu_run>
		break;
 10192a0:	e7dc      	b.n	101925c <lr_act_run+0x2c>
 10192a2:	bf00      	nop
 10192a4:	0102ac60 	.word	0x0102ac60
 10192a8:	0102a300 	.word	0x0102a300
 10192ac:	0102a278 	.word	0x0102a278

010192b0 <lr_st_active.constprop.0>:
	}
}

static void lr_st_active(struct ll_conn *conn, uint8_t evt, void *param)
{
	switch (evt) {
 10192b0:	2901      	cmp	r1, #1
static void lr_st_active(struct ll_conn *conn, uint8_t evt, void *param)
 10192b2:	b510      	push	{r4, lr}
 10192b4:	4604      	mov	r4, r0
	switch (evt) {
 10192b6:	d017      	beq.n	10192e8 <lr_st_active.constprop.0+0x38>
 10192b8:	2903      	cmp	r1, #3
 10192ba:	d004      	beq.n	10192c6 <lr_st_active.constprop.0+0x16>
 10192bc:	b159      	cbz	r1, 10192d6 <lr_st_active.constprop.0+0x26>
		break;
	default:
		/* Ignore other evts */
		break;
	}
}
 10192be:	bd10      	pop	{r4, pc}
		llcp_proc_ctx_release(ctx);
 10192c0:	f7fe fdc8 	bl	1017e54 <llcp_proc_ctx_release>
		ctx = lr_dequeue(conn);
 10192c4:	4620      	mov	r0, r4
 10192c6:	f7ff feb9 	bl	101903c <lr_dequeue>
	while (ctx != NULL) {
 10192ca:	2800      	cmp	r0, #0
 10192cc:	d1f8      	bne.n	10192c0 <lr_st_active.constprop.0+0x10>
	conn->llcp.local.state = state;
 10192ce:	2302      	movs	r3, #2
 10192d0:	f884 30f0 	strb.w	r3, [r4, #240]	; 0xf0
}
 10192d4:	bd10      	pop	{r4, pc}
		if (llcp_lr_peek(conn)) {
 10192d6:	f7ff ff8b 	bl	10191f0 <llcp_lr_peek>
 10192da:	2800      	cmp	r0, #0
 10192dc:	d0ef      	beq.n	10192be <lr_st_active.constprop.0+0xe>
			lr_act_run(conn);
 10192de:	4620      	mov	r0, r4
}
 10192e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			lr_act_run(conn);
 10192e4:	f7ff bfa4 	b.w	1019230 <lr_act_run>
		lr_act_complete(conn);
 10192e8:	f7ff fedc 	bl	10190a4 <lr_act_complete>
	conn->llcp.local.state = state;
 10192ec:	2300      	movs	r3, #0
 10192ee:	f884 30f0 	strb.w	r3, [r4, #240]	; 0xf0
}
 10192f2:	bd10      	pop	{r4, pc}

010192f4 <lr_execute_fsm.constprop.0>:
		/* Ignore other evts */
		break;
	}
}

static void lr_execute_fsm(struct ll_conn *conn, uint8_t evt, void *param)
 10192f4:	b538      	push	{r3, r4, r5, lr}
{
	switch (conn->llcp.local.state) {
 10192f6:	f890 30f0 	ldrb.w	r3, [r0, #240]	; 0xf0
static void lr_execute_fsm(struct ll_conn *conn, uint8_t evt, void *param)
 10192fa:	4604      	mov	r4, r0
	switch (conn->llcp.local.state) {
 10192fc:	2b03      	cmp	r3, #3
 10192fe:	d831      	bhi.n	1019364 <lr_execute_fsm.constprop.0+0x70>
 1019300:	e8df f003 	tbb	[pc, r3]
 1019304:	020c0206 	.word	0x020c0206
		break;
	default:
		/* Unknown state */
		LL_ASSERT(0);
	}
}
 1019308:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		lr_st_active(conn, evt, param);
 101930c:	f7ff bfd0 	b.w	10192b0 <lr_st_active.constprop.0>
	switch (evt) {
 1019310:	2901      	cmp	r1, #1
 1019312:	d023      	beq.n	101935c <lr_execute_fsm.constprop.0+0x68>
 1019314:	2903      	cmp	r1, #3
 1019316:	d009      	beq.n	101932c <lr_execute_fsm.constprop.0+0x38>
 1019318:	b189      	cbz	r1, 101933e <lr_execute_fsm.constprop.0+0x4a>
}
 101931a:	bd38      	pop	{r3, r4, r5, pc}
	switch (evt) {
 101931c:	2902      	cmp	r1, #2
 101931e:	d1fc      	bne.n	101931a <lr_execute_fsm.constprop.0+0x26>
	conn->llcp.local.state = state;
 1019320:	2300      	movs	r3, #0
 1019322:	f880 30f0 	strb.w	r3, [r0, #240]	; 0xf0
}
 1019326:	bd38      	pop	{r3, r4, r5, pc}
		llcp_proc_ctx_release(ctx);
 1019328:	f7fe fd94 	bl	1017e54 <llcp_proc_ctx_release>
		ctx = lr_dequeue(conn);
 101932c:	4620      	mov	r0, r4
 101932e:	f7ff fe85 	bl	101903c <lr_dequeue>
	while (ctx != NULL) {
 1019332:	2800      	cmp	r0, #0
 1019334:	d1f8      	bne.n	1019328 <lr_execute_fsm.constprop.0+0x34>
	conn->llcp.local.state = state;
 1019336:	2302      	movs	r3, #2
 1019338:	f884 30f0 	strb.w	r3, [r4, #240]	; 0xf0
}
 101933c:	bd38      	pop	{r3, r4, r5, pc}
		ctx = llcp_lr_peek(conn);
 101933e:	f7ff ff57 	bl	10191f0 <llcp_lr_peek>
		if (ctx) {
 1019342:	2800      	cmp	r0, #0
 1019344:	d0e9      	beq.n	101931a <lr_execute_fsm.constprop.0+0x26>
			const enum llcp_proc curr_proc = ctx->proc;
 1019346:	7a05      	ldrb	r5, [r0, #8]
			lr_act_run(conn);
 1019348:	4620      	mov	r0, r4
 101934a:	f7ff ff71 	bl	1019230 <lr_act_run>
			if (curr_proc != PROC_TERMINATE) {
 101934e:	2d0a      	cmp	r5, #10
	conn->llcp.local.state = state;
 1019350:	bf14      	ite	ne
 1019352:	2301      	movne	r3, #1
 1019354:	2303      	moveq	r3, #3
 1019356:	f884 30f0 	strb.w	r3, [r4, #240]	; 0xf0
}
 101935a:	bd38      	pop	{r3, r4, r5, pc}
 101935c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		lr_act_complete(conn);
 1019360:	f7ff bea0 	b.w	10190a4 <lr_act_complete>
		LL_ASSERT(0);
 1019364:	f240 2329 	movw	r3, #553	; 0x229
 1019368:	4a05      	ldr	r2, [pc, #20]	; (1019380 <lr_execute_fsm.constprop.0+0x8c>)
 101936a:	4906      	ldr	r1, [pc, #24]	; (1019384 <lr_execute_fsm.constprop.0+0x90>)
 101936c:	4806      	ldr	r0, [pc, #24]	; (1019388 <lr_execute_fsm.constprop.0+0x94>)
 101936e:	f00b fc32 	bl	1024bd6 <assert_print>
 1019372:	4040      	eors	r0, r0
 1019374:	f380 8811 	msr	BASEPRI, r0
 1019378:	f04f 0003 	mov.w	r0, #3
 101937c:	df02      	svc	2
}
 101937e:	bd38      	pop	{r3, r4, r5, pc}
 1019380:	0102ac60 	.word	0x0102ac60
 1019384:	0102a300 	.word	0x0102a300
 1019388:	0102a278 	.word	0x0102a278

0101938c <llcp_lr_ispaused>:
	return conn->llcp.local.pause == 1U;
 101938c:	f890 00f4 	ldrb.w	r0, [r0, #244]	; 0xf4
}
 1019390:	f1a0 0001 	sub.w	r0, r0, #1
 1019394:	fab0 f080 	clz	r0, r0
 1019398:	0940      	lsrs	r0, r0, #5
 101939a:	4770      	bx	lr

0101939c <llcp_lr_pause>:
	conn->llcp.local.pause = 1U;
 101939c:	2301      	movs	r3, #1
 101939e:	f880 30f4 	strb.w	r3, [r0, #244]	; 0xf4
}
 10193a2:	4770      	bx	lr

010193a4 <llcp_lr_resume>:
	conn->llcp.local.pause = 0U;
 10193a4:	2300      	movs	r3, #0
 10193a6:	f880 30f4 	strb.w	r3, [r0, #244]	; 0xf4
}
 10193aa:	4770      	bx	lr

010193ac <llcp_lr_prt_restart>:
	conn->llcp.local.prt_expire = conn->llcp.prt_reload;
 10193ac:	f8b0 3108 	ldrh.w	r3, [r0, #264]	; 0x108
 10193b0:	f8a0 30f2 	strh.w	r3, [r0, #242]	; 0xf2
}
 10193b4:	4770      	bx	lr
 10193b6:	bf00      	nop

010193b8 <llcp_lr_prt_restart_with_value>:
	conn->llcp.local.prt_expire = value;
 10193b8:	f8a0 10f2 	strh.w	r1, [r0, #242]	; 0xf2
}
 10193bc:	4770      	bx	lr
 10193be:	bf00      	nop

010193c0 <llcp_lr_prt_stop>:
	conn->llcp.local.prt_expire = 0U;
 10193c0:	2300      	movs	r3, #0
 10193c2:	f8a0 30f2 	strh.w	r3, [r0, #242]	; 0xf2
}
 10193c6:	4770      	bx	lr

010193c8 <llcp_lr_rx>:
{
 10193c8:	b538      	push	{r3, r4, r5, lr}
	switch (ctx->proc) {
 10193ca:	7a0b      	ldrb	r3, [r1, #8]
{
 10193cc:	460c      	mov	r4, r1
	switch (ctx->proc) {
 10193ce:	3b01      	subs	r3, #1
{
 10193d0:	4605      	mov	r5, r0
	switch (ctx->proc) {
 10193d2:	2b0b      	cmp	r3, #11
 10193d4:	d817      	bhi.n	1019406 <llcp_lr_rx+0x3e>
 10193d6:	e8df f003 	tbb	[pc, r3]
 10193da:	0606      	.short	0x0606
 10193dc:	16160606 	.word	0x16160606
 10193e0:	06121224 	.word	0x06121224
 10193e4:	0616      	.short	0x0616
		llcp_lp_comm_rx(conn, ctx, rx);
 10193e6:	4621      	mov	r1, r4
 10193e8:	f7ff fe06 	bl	1018ff8 <llcp_lp_comm_rx>
	if (ctx->done) {
 10193ec:	69a3      	ldr	r3, [r4, #24]
 10193ee:	b903      	cbnz	r3, 10193f2 <llcp_lr_rx+0x2a>
}
 10193f0:	bd38      	pop	{r3, r4, r5, pc}
 10193f2:	4621      	mov	r1, r4
 10193f4:	4628      	mov	r0, r5
 10193f6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 10193fa:	f7ff be8b 	b.w	1019114 <lr_check_done.part.0>
		llcp_lp_cu_rx(conn, ctx, rx);
 10193fe:	4621      	mov	r1, r4
 1019400:	f001 f820 	bl	101a444 <llcp_lp_cu_rx>
		break;
 1019404:	e7f2      	b.n	10193ec <llcp_lr_rx+0x24>
		LL_ASSERT(0);
 1019406:	f240 130d 	movw	r3, #269	; 0x10d
 101940a:	4a08      	ldr	r2, [pc, #32]	; (101942c <llcp_lr_rx+0x64>)
 101940c:	4908      	ldr	r1, [pc, #32]	; (1019430 <llcp_lr_rx+0x68>)
 101940e:	4809      	ldr	r0, [pc, #36]	; (1019434 <llcp_lr_rx+0x6c>)
 1019410:	f00b fbe1 	bl	1024bd6 <assert_print>
 1019414:	4040      	eors	r0, r0
 1019416:	f380 8811 	msr	BASEPRI, r0
 101941a:	f04f 0003 	mov.w	r0, #3
 101941e:	df02      	svc	2
		break;
 1019420:	e7e4      	b.n	10193ec <llcp_lr_rx+0x24>
		llcp_lp_pu_rx(conn, ctx, rx);
 1019422:	4621      	mov	r1, r4
 1019424:	f7fd ff94 	bl	1017350 <llcp_lp_pu_rx>
		break;
 1019428:	e7e0      	b.n	10193ec <llcp_lr_rx+0x24>
 101942a:	bf00      	nop
 101942c:	0102ac60 	.word	0x0102ac60
 1019430:	0102a300 	.word	0x0102a300
 1019434:	0102a278 	.word	0x0102a278

01019438 <llcp_lr_tx_ack>:
{
 1019438:	b538      	push	{r3, r4, r5, lr}
	switch (ctx->proc) {
 101943a:	7a0b      	ldrb	r3, [r1, #8]
{
 101943c:	460c      	mov	r4, r1
	switch (ctx->proc) {
 101943e:	3b03      	subs	r3, #3
{
 1019440:	4605      	mov	r5, r0
	switch (ctx->proc) {
 1019442:	2b09      	cmp	r3, #9
 1019444:	d809      	bhi.n	101945a <llcp_lr_tx_ack+0x22>
 1019446:	e8df f003 	tbb	[pc, r3]
 101944a:	0805      	.short	0x0805
 101944c:	080b0808 	.word	0x080b0808
 1019450:	05080508 	.word	0x05080508
		llcp_lp_comm_tx_ack(conn, ctx, tx);
 1019454:	4621      	mov	r1, r4
 1019456:	f7ff fdc9 	bl	1018fec <llcp_lp_comm_tx_ack>
	if (ctx->done) {
 101945a:	69a3      	ldr	r3, [r4, #24]
 101945c:	b933      	cbnz	r3, 101946c <llcp_lr_tx_ack+0x34>
}
 101945e:	bd38      	pop	{r3, r4, r5, pc}
		llcp_lp_pu_tx_ack(conn, ctx, tx);
 1019460:	4621      	mov	r1, r4
 1019462:	f7fd ff9d 	bl	10173a0 <llcp_lp_pu_tx_ack>
	if (ctx->done) {
 1019466:	69a3      	ldr	r3, [r4, #24]
 1019468:	2b00      	cmp	r3, #0
 101946a:	d0f8      	beq.n	101945e <llcp_lr_tx_ack+0x26>
 101946c:	4621      	mov	r1, r4
 101946e:	4628      	mov	r0, r5
}
 1019470:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 1019474:	f7ff be4e 	b.w	1019114 <lr_check_done.part.0>

01019478 <llcp_lr_tx_ntf>:
{
 1019478:	b538      	push	{r3, r4, r5, lr}
	switch (ctx->proc) {
 101947a:	7a0b      	ldrb	r3, [r1, #8]
{
 101947c:	460c      	mov	r4, r1
	switch (ctx->proc) {
 101947e:	2b07      	cmp	r3, #7
{
 1019480:	4605      	mov	r5, r0
	switch (ctx->proc) {
 1019482:	d008      	beq.n	1019496 <llcp_lr_tx_ntf+0x1e>
	if (ctx->done) {
 1019484:	69a3      	ldr	r3, [r4, #24]
 1019486:	b903      	cbnz	r3, 101948a <llcp_lr_tx_ntf+0x12>
}
 1019488:	bd38      	pop	{r3, r4, r5, pc}
 101948a:	4621      	mov	r1, r4
 101948c:	4628      	mov	r0, r5
 101948e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 1019492:	f7ff be3f 	b.w	1019114 <lr_check_done.part.0>
		llcp_lp_pu_tx_ntf(conn, ctx);
 1019496:	f7fd ff87 	bl	10173a8 <llcp_lp_pu_tx_ntf>
		break;
 101949a:	e7f3      	b.n	1019484 <llcp_lr_tx_ntf+0xc>

0101949c <llcp_lr_init>:
	conn->llcp.local.state = state;
 101949c:	2202      	movs	r2, #2

void llcp_lr_init(struct ll_conn *conn)
{
	lr_set_state(conn, LR_STATE_DISCONNECT);
	conn->llcp.local.prt_expire = 0U;
 101949e:	2300      	movs	r3, #0
	conn->llcp.local.state = state;
 10194a0:	f880 20f0 	strb.w	r2, [r0, #240]	; 0xf0
	conn->llcp.local.prt_expire = 0U;
 10194a4:	f8a0 30f2 	strh.w	r3, [r0, #242]	; 0xf2
}
 10194a8:	4770      	bx	lr
 10194aa:	bf00      	nop

010194ac <llcp_lr_run>:

void llcp_lr_run(struct ll_conn *conn)
{
	lr_execute_fsm(conn, LR_EVT_RUN, NULL);
 10194ac:	2100      	movs	r1, #0
 10194ae:	f7ff bf21 	b.w	10192f4 <lr_execute_fsm.constprop.0>
 10194b2:	bf00      	nop

010194b4 <llcp_lr_complete>:
}

void llcp_lr_complete(struct ll_conn *conn)
{
 10194b4:	b510      	push	{r4, lr}
	switch (conn->llcp.local.state) {
 10194b6:	f890 30f0 	ldrb.w	r3, [r0, #240]	; 0xf0
{
 10194ba:	4604      	mov	r4, r0
	switch (conn->llcp.local.state) {
 10194bc:	2b03      	cmp	r3, #3
 10194be:	d80d      	bhi.n	10194dc <llcp_lr_complete+0x28>
 10194c0:	e8df f003 	tbb	[pc, r3]
 10194c4:	02070208 	.word	0x02070208
		lr_act_complete(conn);
 10194c8:	f7ff fdec 	bl	10190a4 <lr_act_complete>
	conn->llcp.local.state = state;
 10194cc:	2300      	movs	r3, #0
 10194ce:	f884 30f0 	strb.w	r3, [r4, #240]	; 0xf0
	lr_execute_fsm(conn, LR_EVT_COMPLETE, NULL);
}
 10194d2:	bd10      	pop	{r4, pc}
 10194d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		lr_act_complete(conn);
 10194d8:	f7ff bde4 	b.w	10190a4 <lr_act_complete>
		LL_ASSERT(0);
 10194dc:	f240 2329 	movw	r3, #553	; 0x229
 10194e0:	4a05      	ldr	r2, [pc, #20]	; (10194f8 <llcp_lr_complete+0x44>)
 10194e2:	4906      	ldr	r1, [pc, #24]	; (10194fc <llcp_lr_complete+0x48>)
 10194e4:	4806      	ldr	r0, [pc, #24]	; (1019500 <llcp_lr_complete+0x4c>)
 10194e6:	f00b fb76 	bl	1024bd6 <assert_print>
 10194ea:	4040      	eors	r0, r0
 10194ec:	f380 8811 	msr	BASEPRI, r0
 10194f0:	f04f 0003 	mov.w	r0, #3
 10194f4:	df02      	svc	2
}
 10194f6:	bd10      	pop	{r4, pc}
 10194f8:	0102ac60 	.word	0x0102ac60
 10194fc:	0102a300 	.word	0x0102a300
 1019500:	0102a278 	.word	0x0102a278

01019504 <llcp_lr_connect>:

void llcp_lr_connect(struct ll_conn *conn)
{
 1019504:	b508      	push	{r3, lr}
	switch (conn->llcp.local.state) {
 1019506:	f890 30f0 	ldrb.w	r3, [r0, #240]	; 0xf0
 101950a:	2b02      	cmp	r3, #2
 101950c:	d011      	beq.n	1019532 <llcp_lr_connect+0x2e>
 101950e:	d800      	bhi.n	1019512 <llcp_lr_connect+0xe>
	lr_execute_fsm(conn, LR_EVT_CONNECT, NULL);
}
 1019510:	bd08      	pop	{r3, pc}
	switch (conn->llcp.local.state) {
 1019512:	2b03      	cmp	r3, #3
 1019514:	d0fc      	beq.n	1019510 <llcp_lr_connect+0xc>
		LL_ASSERT(0);
 1019516:	f240 2329 	movw	r3, #553	; 0x229
 101951a:	4a08      	ldr	r2, [pc, #32]	; (101953c <llcp_lr_connect+0x38>)
 101951c:	4908      	ldr	r1, [pc, #32]	; (1019540 <llcp_lr_connect+0x3c>)
 101951e:	4809      	ldr	r0, [pc, #36]	; (1019544 <llcp_lr_connect+0x40>)
 1019520:	f00b fb59 	bl	1024bd6 <assert_print>
 1019524:	4040      	eors	r0, r0
 1019526:	f380 8811 	msr	BASEPRI, r0
 101952a:	f04f 0003 	mov.w	r0, #3
 101952e:	df02      	svc	2
}
 1019530:	bd08      	pop	{r3, pc}
	conn->llcp.local.state = state;
 1019532:	2300      	movs	r3, #0
 1019534:	f880 30f0 	strb.w	r3, [r0, #240]	; 0xf0
}
 1019538:	bd08      	pop	{r3, pc}
 101953a:	bf00      	nop
 101953c:	0102ac60 	.word	0x0102ac60
 1019540:	0102a300 	.word	0x0102a300
 1019544:	0102a278 	.word	0x0102a278

01019548 <llcp_lr_disconnect>:

void llcp_lr_disconnect(struct ll_conn *conn)
{
	lr_execute_fsm(conn, LR_EVT_DISCONNECT, NULL);
 1019548:	2103      	movs	r1, #3
 101954a:	f7ff bed3 	b.w	10192f4 <lr_execute_fsm.constprop.0>
 101954e:	bf00      	nop

01019550 <llcp_lr_abort>:
}

void llcp_lr_abort(struct ll_conn *conn)
{
 1019550:	b538      	push	{r3, r4, r5, lr}
 1019552:	4604      	mov	r4, r0
	struct proc_ctx *ctx;

	/* Flush all pending procedures */
	ctx = lr_dequeue(conn);
 1019554:	f7ff fd72 	bl	101903c <lr_dequeue>
	while (ctx) {
 1019558:	b130      	cbz	r0, 1019568 <llcp_lr_abort+0x18>
		llcp_proc_ctx_release(ctx);
 101955a:	f7fe fc7b 	bl	1017e54 <llcp_proc_ctx_release>
		ctx = lr_dequeue(conn);
 101955e:	4620      	mov	r0, r4
 1019560:	f7ff fd6c 	bl	101903c <lr_dequeue>
	while (ctx) {
 1019564:	2800      	cmp	r0, #0
 1019566:	d1f8      	bne.n	101955a <llcp_lr_abort+0xa>
	conn->llcp.local.prt_expire = 0U;
 1019568:	2500      	movs	r5, #0
	}

	llcp_lr_prt_stop(conn);
	llcp_rr_set_incompat(conn, 0U);
 101956a:	4620      	mov	r0, r4
 101956c:	4629      	mov	r1, r5
	conn->llcp.local.prt_expire = 0U;
 101956e:	f8a4 50f2 	strh.w	r5, [r4, #242]	; 0xf2
	llcp_rr_set_incompat(conn, 0U);
 1019572:	f001 fa9b 	bl	101aaac <llcp_rr_set_incompat>
	conn->llcp.local.state = state;
 1019576:	f884 50f0 	strb.w	r5, [r4, #240]	; 0xf0
	lr_set_state(conn, LR_STATE_IDLE);
}
 101957a:	bd38      	pop	{r3, r4, r5, pc}

0101957c <llcp_pdu_encode_ping_req>:
 */

void llcp_pdu_encode_ping_req(struct pdu_data *pdu)
{
	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(ping_req);
 101957c:	2101      	movs	r1, #1
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_REQ;
 101957e:	2212      	movs	r2, #18
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019580:	7803      	ldrb	r3, [r0, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(ping_req);
 1019582:	7041      	strb	r1, [r0, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019584:	f043 0303 	orr.w	r3, r3, #3
 1019588:	7003      	strb	r3, [r0, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_REQ;
 101958a:	70c2      	strb	r2, [r0, #3]
}
 101958c:	4770      	bx	lr
 101958e:	bf00      	nop

01019590 <llcp_pdu_encode_ping_rsp>:

void llcp_pdu_encode_ping_rsp(struct pdu_data *pdu)
{
	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(ping_rsp);
 1019590:	2101      	movs	r1, #1
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_RSP;
 1019592:	2213      	movs	r2, #19
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019594:	7803      	ldrb	r3, [r0, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(ping_rsp);
 1019596:	7041      	strb	r1, [r0, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019598:	f043 0303 	orr.w	r3, r3, #3
 101959c:	7003      	strb	r3, [r0, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_RSP;
 101959e:	70c2      	strb	r2, [r0, #3]
}
 10195a0:	4770      	bx	lr
 10195a2:	bf00      	nop

010195a4 <llcp_pdu_encode_unknown_rsp>:
 */

void llcp_pdu_encode_unknown_rsp(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(unknown_rsp);
 10195a4:	f04f 0c02 	mov.w	ip, #2
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
 10195a8:	2207      	movs	r2, #7
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10195aa:	780b      	ldrb	r3, [r1, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(unknown_rsp);
 10195ac:	f881 c001 	strb.w	ip, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10195b0:	f043 0303 	orr.w	r3, r3, #3
 10195b4:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
 10195b6:	70ca      	strb	r2, [r1, #3]

	pdu->llctrl.unknown_rsp.type = ctx->unknown_response.type;
 10195b8:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
 10195bc:	710b      	strb	r3, [r1, #4]
}
 10195be:	4770      	bx	lr

010195c0 <llcp_pdu_decode_unknown_rsp>:

void llcp_pdu_decode_unknown_rsp(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	ctx->unknown_response.type = pdu->llctrl.unknown_rsp.type;
 10195c0:	790b      	ldrb	r3, [r1, #4]
 10195c2:	f880 3048 	strb.w	r3, [r0, #72]	; 0x48
}
 10195c6:	4770      	bx	lr

010195c8 <llcp_ntf_encode_unknown_rsp>:
void llcp_ntf_encode_unknown_rsp(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	struct pdu_data_llctrl_unknown_rsp *p;

	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(unknown_rsp);
 10195c8:	f04f 0c02 	mov.w	ip, #2
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
 10195cc:	2207      	movs	r2, #7
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10195ce:	780b      	ldrb	r3, [r1, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(unknown_rsp);
 10195d0:	f881 c001 	strb.w	ip, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10195d4:	f043 0303 	orr.w	r3, r3, #3
 10195d8:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
 10195da:	70ca      	strb	r2, [r1, #3]
	p = &pdu->llctrl.unknown_rsp;
	p->type = ctx->unknown_response.type;
 10195dc:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
 10195e0:	710b      	strb	r3, [r1, #4]
}
 10195e2:	4770      	bx	lr

010195e4 <llcp_pdu_encode_feature_req>:

	*featuresout = feat;
}

void llcp_pdu_encode_feature_req(struct ll_conn *conn, struct pdu_data *pdu)
{
 10195e4:	b570      	push	{r4, r5, r6, lr}
	struct pdu_data_llctrl_feature_req *p;

	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(feature_req);
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_REQ;
 10195e6:	2608      	movs	r6, #8
	pdu->len = PDU_DATA_LLCTRL_LEN(feature_req);
 10195e8:	2509      	movs	r5, #9
	dst[1] = val >> 8;
 10195ea:	2300      	movs	r3, #0
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10195ec:	780a      	ldrb	r2, [r1, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_REQ;
 10195ee:	70ce      	strb	r6, [r1, #3]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10195f0:	f042 0203 	orr.w	r2, r2, #3
	pdu->len = PDU_DATA_LLCTRL_LEN(feature_req);
 10195f4:	704d      	strb	r5, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10195f6:	700a      	strb	r2, [r1, #0]

#if defined(CONFIG_BT_CTLR_PER_INIT_FEAT_XCHG) && defined(CONFIG_BT_PERIPHERAL)
	if (conn->lll.role == BT_HCI_ROLE_PERIPHERAL) {
 10195f8:	f990 2039 	ldrsb.w	r2, [r0, #57]	; 0x39
	dst[0] = val;
 10195fc:	243f      	movs	r4, #63	; 0x3f
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PER_INIT_FEAT_XCHG;
 10195fe:	429a      	cmp	r2, r3
	dst[1] = val >> 8;
 1019600:	f04f 0e41 	mov.w	lr, #65	; 0x41
	dst[0] = val;
 1019604:	f04f 0c01 	mov.w	ip, #1
 1019608:	bfac      	ite	ge
 101960a:	4632      	movge	r2, r6
 101960c:	220e      	movlt	r2, #14
 101960e:	710c      	strb	r4, [r1, #4]
	dst[1] = val >> 8;
 1019610:	f881 e005 	strb.w	lr, [r1, #5]
	dst[0] = val;
 1019614:	f881 c006 	strb.w	ip, [r1, #6]
	dst[1] = val >> 8;
 1019618:	71cb      	strb	r3, [r1, #7]
	dst[0] = val;
 101961a:	720b      	strb	r3, [r1, #8]
	dst[1] = val >> 8;
 101961c:	724b      	strb	r3, [r1, #9]
	dst[0] = val;
 101961e:	728b      	strb	r3, [r1, #10]
	dst[1] = val >> 8;
 1019620:	72cb      	strb	r3, [r1, #11]
 1019622:	70ca      	strb	r2, [r1, #3]
	}
#endif /* CONFIG_BT_CTLR_PER_INIT_FEAT_XCHG && CONFIG_BT_PERIPHERAL */

	p = &pdu->llctrl.feature_req;
	sys_put_le64(LL_FEAT, p->features);
}
 1019624:	bd70      	pop	{r4, r5, r6, pc}
 1019626:	bf00      	nop

01019628 <llcp_pdu_encode_feature_rsp>:
{
	struct pdu_data_llctrl_feature_rsp *p;
	uint64_t feature_rsp = LL_FEAT;

	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(feature_rsp);
 1019628:	f04f 0c09 	mov.w	ip, #9
 101962c:	2300      	movs	r3, #0
{
 101962e:	b510      	push	{r4, lr}
 1019630:	2441      	movs	r4, #65	; 0x41
	dst[0] = val;
 1019632:	f04f 0e01 	mov.w	lr, #1
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019636:	780a      	ldrb	r2, [r1, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(feature_rsp);
 1019638:	f881 c001 	strb.w	ip, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 101963c:	f042 0203 	orr.w	r2, r2, #3
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
 1019640:	f881 c003 	strb.w	ip, [r1, #3]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019644:	700a      	strb	r2, [r1, #0]

	/*
	 * we only filter on octet 0, remaining 7 octets are the features
	 * we support, as defined in LL_FEAT
	 */
	feature_rsp &= (FEAT_FILT_OCTET0 | conn->llcp.fex.features_used);
 1019646:	f8d0 2130 	ldr.w	r2, [r0, #304]	; 0x130
	dst[1] = val >> 8;
 101964a:	714c      	strb	r4, [r1, #5]
 101964c:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
	dst[0] = val;
 1019650:	710a      	strb	r2, [r1, #4]
 1019652:	f881 e006 	strb.w	lr, [r1, #6]
	dst[1] = val >> 8;
 1019656:	71cb      	strb	r3, [r1, #7]
	dst[0] = val;
 1019658:	720b      	strb	r3, [r1, #8]
	dst[1] = val >> 8;
 101965a:	724b      	strb	r3, [r1, #9]
	dst[0] = val;
 101965c:	728b      	strb	r3, [r1, #10]
	dst[1] = val >> 8;
 101965e:	72cb      	strb	r3, [r1, #11]

	sys_put_le64(feature_rsp, p->features);
}
 1019660:	bd10      	pop	{r4, pc}
 1019662:	bf00      	nop

01019664 <llcp_ntf_encode_feature_rsp>:
void llcp_ntf_encode_feature_rsp(struct ll_conn *conn, struct pdu_data *pdu)
{
	struct pdu_data_llctrl_feature_rsp *p;

	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(feature_rsp);
 1019664:	2209      	movs	r2, #9
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019666:	780b      	ldrb	r3, [r1, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(feature_rsp);
 1019668:	704a      	strb	r2, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 101966a:	f043 0303 	orr.w	r3, r3, #3
 101966e:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
 1019670:	70ca      	strb	r2, [r1, #3]
	p = &pdu->llctrl.feature_rsp;

	sys_put_le64(conn->llcp.fex.features_peer, p->features);
 1019672:	e9d0 234a 	ldrd	r2, r3, [r0, #296]	; 0x128
	sys_put_le16(val >> 16, &dst[2]);
 1019676:	0c10      	lsrs	r0, r2, #16
	dst[1] = val >> 8;
 1019678:	f3c2 2c07 	ubfx	ip, r2, #8, #8
	dst[0] = val;
 101967c:	710a      	strb	r2, [r1, #4]
	sys_put_le16(val >> 16, &dst[2]);
 101967e:	0c1a      	lsrs	r2, r3, #16
	dst[1] = val >> 8;
 1019680:	f881 c005 	strb.w	ip, [r1, #5]
	dst[0] = val;
 1019684:	7188      	strb	r0, [r1, #6]
	dst[1] = val >> 8;
 1019686:	ea4f 2c10 	mov.w	ip, r0, lsr #8
	dst[0] = val;
 101968a:	720b      	strb	r3, [r1, #8]
	dst[1] = val >> 8;
 101968c:	f3c3 2007 	ubfx	r0, r3, #8, #8
 1019690:	0a13      	lsrs	r3, r2, #8
 1019692:	f881 c007 	strb.w	ip, [r1, #7]
 1019696:	7248      	strb	r0, [r1, #9]
	dst[0] = val;
 1019698:	728a      	strb	r2, [r1, #10]
	dst[1] = val >> 8;
 101969a:	72cb      	strb	r3, [r1, #11]
}
 101969c:	4770      	bx	lr
 101969e:	bf00      	nop

010196a0 <llcp_pdu_decode_feature_req>:

void llcp_pdu_decode_feature_req(struct ll_conn *conn, struct pdu_data *pdu)
{
 10196a0:	b510      	push	{r4, lr}
	uint64_t featureset;

	feature_filter(pdu->llctrl.feature_req.features, &featureset);
	conn->llcp.fex.features_used = LL_FEAT & featureset;
 10196a2:	2400      	movs	r4, #0

	featureset &= (FEAT_FILT_OCTET0 | conn->llcp.fex.features_used);
	conn->llcp.fex.features_peer = featureset;

	conn->llcp.fex.valid = 1;
 10196a4:	f04f 0e01 	mov.w	lr, #1
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
 10196a8:	f8d1 c004 	ldr.w	ip, [r1, #4]
	conn->llcp.fex.features_used = LL_FEAT & featureset;
 10196ac:	4a09      	ldr	r2, [pc, #36]	; (10196d4 <llcp_pdu_decode_feature_req+0x34>)
	featureset &= (FEAT_FILT_OCTET0 | conn->llcp.fex.features_used);
 10196ae:	4b0a      	ldr	r3, [pc, #40]	; (10196d8 <llcp_pdu_decode_feature_req+0x38>)
 10196b0:	6889      	ldr	r1, [r1, #8]
	conn->llcp.fex.features_used = LL_FEAT & featureset;
 10196b2:	ea0c 0202 	and.w	r2, ip, r2
	featureset &= (FEAT_FILT_OCTET0 | conn->llcp.fex.features_used);
 10196b6:	4313      	orrs	r3, r2
 10196b8:	ea03 030c 	and.w	r3, r3, ip
 10196bc:	f001 01ef 	and.w	r1, r1, #239	; 0xef
	conn->llcp.fex.features_peer = featureset;
 10196c0:	e9c0 314a 	strd	r3, r1, [r0, #296]	; 0x128
	conn->llcp.fex.features_used = LL_FEAT & featureset;
 10196c4:	f8c0 4134 	str.w	r4, [r0, #308]	; 0x134
	conn->llcp.fex.valid = 1;
 10196c8:	f880 e121 	strb.w	lr, [r0, #289]	; 0x121
	conn->llcp.fex.features_used = LL_FEAT & featureset;
 10196cc:	f8c0 2130 	str.w	r2, [r0, #304]	; 0x130
}
 10196d0:	bd10      	pop	{r4, pc}
 10196d2:	bf00      	nop
 10196d4:	0001412f 	.word	0x0001412f
 10196d8:	f787cf00 	.word	0xf787cf00

010196dc <llcp_pdu_decode_feature_rsp>:

void llcp_pdu_decode_feature_rsp(struct ll_conn *conn, struct pdu_data *pdu)
{
 10196dc:	b530      	push	{r4, r5, lr}
	uint64_t featureset;

	feature_filter(pdu->llctrl.feature_rsp.features, &featureset);
	conn->llcp.fex.features_used = LL_FEAT & featureset;
 10196de:	2500      	movs	r5, #0

	conn->llcp.fex.features_peer = featureset;
	conn->llcp.fex.valid = 1;
 10196e0:	f04f 0e01 	mov.w	lr, #1
 10196e4:	f8d1 c004 	ldr.w	ip, [r1, #4]
 10196e8:	688b      	ldr	r3, [r1, #8]
	conn->llcp.fex.features_used = LL_FEAT & featureset;
 10196ea:	4c08      	ldr	r4, [pc, #32]	; (101970c <llcp_pdu_decode_feature_rsp+0x30>)
	feat &= LL_FEAT_BIT_MASK_VALID;
 10196ec:	4a08      	ldr	r2, [pc, #32]	; (1019710 <llcp_pdu_decode_feature_rsp+0x34>)
	conn->llcp.fex.features_used = LL_FEAT & featureset;
 10196ee:	ea0c 0404 	and.w	r4, ip, r4
	feat &= LL_FEAT_BIT_MASK_VALID;
 10196f2:	ea0c 0202 	and.w	r2, ip, r2
 10196f6:	f003 03ef 	and.w	r3, r3, #239	; 0xef
	conn->llcp.fex.features_peer = featureset;
 10196fa:	e9c0 234a 	strd	r2, r3, [r0, #296]	; 0x128
	conn->llcp.fex.features_used = LL_FEAT & featureset;
 10196fe:	f8c0 5134 	str.w	r5, [r0, #308]	; 0x134
	conn->llcp.fex.valid = 1;
 1019702:	f880 e121 	strb.w	lr, [r0, #289]	; 0x121
	conn->llcp.fex.features_used = LL_FEAT & featureset;
 1019706:	f8c0 4130 	str.w	r4, [r0, #304]	; 0x130
}
 101970a:	bd30      	pop	{r4, r5, pc}
 101970c:	0001412f 	.word	0x0001412f
 1019710:	f787cf2f 	.word	0xf787cf2f

01019714 <llcp_pdu_encode_min_used_chans_ind>:
void llcp_pdu_encode_min_used_chans_ind(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	struct pdu_data_llctrl_min_used_chans_ind *p;

	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(min_used_chans_ind);
 1019714:	f04f 0c03 	mov.w	ip, #3
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_MIN_USED_CHAN_IND;
 1019718:	2219      	movs	r2, #25
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 101971a:	780b      	ldrb	r3, [r1, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(min_used_chans_ind);
 101971c:	f881 c001 	strb.w	ip, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019720:	ea43 030c 	orr.w	r3, r3, ip
 1019724:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_MIN_USED_CHAN_IND;
 1019726:	70ca      	strb	r2, [r1, #3]
	p = &pdu->llctrl.min_used_chans_ind;
	p->phys = ctx->data.muc.phys;
 1019728:	7f03      	ldrb	r3, [r0, #28]
 101972a:	710b      	strb	r3, [r1, #4]
	p->min_used_chans = ctx->data.muc.min_used_chans;
 101972c:	7f43      	ldrb	r3, [r0, #29]
 101972e:	714b      	strb	r3, [r1, #5]
}
 1019730:	4770      	bx	lr
 1019732:	bf00      	nop

01019734 <llcp_pdu_encode_terminate_ind>:
void llcp_pdu_encode_terminate_ind(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	struct pdu_data_llctrl_terminate_ind *p;

	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(terminate_ind);
 1019734:	2202      	movs	r2, #2
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019736:	780b      	ldrb	r3, [r1, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(terminate_ind);
 1019738:	704a      	strb	r2, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 101973a:	f043 0303 	orr.w	r3, r3, #3
 101973e:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_TERMINATE_IND;
 1019740:	70ca      	strb	r2, [r1, #3]
	p = &pdu->llctrl.terminate_ind;
	p->error_code = ctx->data.term.error_code;
 1019742:	7f03      	ldrb	r3, [r0, #28]
 1019744:	710b      	strb	r3, [r1, #4]
}
 1019746:	4770      	bx	lr

01019748 <llcp_pdu_decode_terminate_ind>:

void llcp_pdu_decode_terminate_ind(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	ctx->data.term.error_code = pdu->llctrl.terminate_ind.error_code;
 1019748:	790b      	ldrb	r3, [r1, #4]
 101974a:	7703      	strb	r3, [r0, #28]
}
 101974c:	4770      	bx	lr
 101974e:	bf00      	nop

01019750 <llcp_pdu_encode_version_ind>:
	uint16_t cid;
	uint16_t svn;
	struct pdu_data_llctrl_version_ind *p;

	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(version_ind);
 1019750:	f04f 0c06 	mov.w	ip, #6
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 1019754:	f640 410c 	movw	r1, #3084	; 0xc0c
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019758:	7803      	ldrb	r3, [r0, #0]

	p = &pdu->llctrl.version_ind;
	p->version_number = LL_VERSION_NUMBER;
	cid = sys_cpu_to_le16(ll_settings_company_id());
	svn = sys_cpu_to_le16(ll_settings_subversion_number());
	p->company_id = cid;
 101975a:	4a05      	ldr	r2, [pc, #20]	; (1019770 <llcp_pdu_encode_version_ind+0x20>)
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 101975c:	f043 0303 	orr.w	r3, r3, #3
	pdu->len = PDU_DATA_LLCTRL_LEN(version_ind);
 1019760:	f880 c001 	strb.w	ip, [r0, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019764:	7003      	strb	r3, [r0, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 1019766:	f8a0 1003 	strh.w	r1, [r0, #3]
	p->company_id = cid;
 101976a:	f8c0 2005 	str.w	r2, [r0, #5]
	p->sub_version_number = svn;
}
 101976e:	4770      	bx	lr
 1019770:	ffff05f1 	.word	0xffff05f1

01019774 <llcp_ntf_encode_version_ind>:
void llcp_ntf_encode_version_ind(struct ll_conn *conn, struct pdu_data *pdu)
{
	struct pdu_data_llctrl_version_ind *p;

	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(version_ind);
 1019774:	f04f 0c06 	mov.w	ip, #6
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 1019778:	220c      	movs	r2, #12
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 101977a:	780b      	ldrb	r3, [r1, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(version_ind);
 101977c:	f881 c001 	strb.w	ip, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019780:	f043 0303 	orr.w	r3, r3, #3
 1019784:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 1019786:	70ca      	strb	r2, [r1, #3]

	p = &pdu->llctrl.version_ind;
	p->version_number = conn->llcp.vex.cached.version_number;
 1019788:	f890 3116 	ldrb.w	r3, [r0, #278]	; 0x116
 101978c:	710b      	strb	r3, [r1, #4]
	p->company_id = sys_cpu_to_le16(conn->llcp.vex.cached.company_id);
 101978e:	f8b0 3117 	ldrh.w	r3, [r0, #279]	; 0x117
 1019792:	f8a1 3005 	strh.w	r3, [r1, #5]
	p->sub_version_number = sys_cpu_to_le16(conn->llcp.vex.cached.sub_version_number);
 1019796:	f8b0 3119 	ldrh.w	r3, [r0, #281]	; 0x119
 101979a:	f8a1 3007 	strh.w	r3, [r1, #7]
}
 101979e:	4770      	bx	lr

010197a0 <llcp_pdu_decode_version_ind>:

void llcp_pdu_decode_version_ind(struct ll_conn *conn, struct pdu_data *pdu)
{
	conn->llcp.vex.valid = 1;
 10197a0:	2301      	movs	r3, #1
 10197a2:	f880 3115 	strb.w	r3, [r0, #277]	; 0x115
	conn->llcp.vex.cached.version_number = pdu->llctrl.version_ind.version_number;
 10197a6:	790b      	ldrb	r3, [r1, #4]
 10197a8:	f880 3116 	strb.w	r3, [r0, #278]	; 0x116
	conn->llcp.vex.cached.company_id = sys_le16_to_cpu(pdu->llctrl.version_ind.company_id);
 10197ac:	f8b1 3005 	ldrh.w	r3, [r1, #5]
 10197b0:	f8a0 3117 	strh.w	r3, [r0, #279]	; 0x117
	conn->llcp.vex.cached.sub_version_number =
		sys_le16_to_cpu(pdu->llctrl.version_ind.sub_version_number);
 10197b4:	f8b1 3007 	ldrh.w	r3, [r1, #7]
	conn->llcp.vex.cached.sub_version_number =
 10197b8:	f8a0 3119 	strh.w	r3, [r0, #281]	; 0x119
}
 10197bc:	4770      	bx	lr
 10197be:	bf00      	nop

010197c0 <llcp_ntf_encode_enc_req>:
{
	struct pdu_data_llctrl_enc_req *p;

	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(enc_req);
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
 10197c0:	f04f 0c03 	mov.w	ip, #3
}
#endif /* CONFIG_BT_CENTRAL */

#if defined(CONFIG_BT_PERIPHERAL)
void llcp_ntf_encode_enc_req(struct proc_ctx *ctx, struct pdu_data *pdu)
{
 10197c4:	b538      	push	{r3, r4, r5, lr}
 10197c6:	460c      	mov	r4, r1
	pdu->len = PDU_DATA_LLCTRL_LEN(enc_req);
 10197c8:	f04f 0e17 	mov.w	lr, #23
{
 10197cc:	4605      	mov	r5, r0
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10197ce:	780b      	ldrb	r3, [r1, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(enc_req);
 10197d0:	f881 e001 	strb.w	lr, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10197d4:	ea43 030c 	orr.w	r3, r3, ip
 10197d8:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
 10197da:	f881 c003 	strb.w	ip, [r1, #3]
	memcpy(p->rand, ctx->data.enc.rand, sizeof(p->rand));
 10197de:	2208      	movs	r2, #8
 10197e0:	f100 011d 	add.w	r1, r0, #29
 10197e4:	1d20      	adds	r0, r4, #4
 10197e6:	f00d f8c5 	bl	1026974 <memcpy>
	p->ediv[0] = ctx->data.enc.ediv[0];
 10197ea:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
 10197ee:	7323      	strb	r3, [r4, #12]
	p->ediv[1] = ctx->data.enc.ediv[1];
 10197f0:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
 10197f4:	7363      	strb	r3, [r4, #13]
	encode_enc_req(ctx, pdu);
}
 10197f6:	bd38      	pop	{r3, r4, r5, pc}

010197f8 <llcp_pdu_encode_enc_rsp>:
void llcp_pdu_encode_enc_rsp(struct pdu_data *pdu)
{
	struct pdu_data_llctrl_enc_rsp *p;

	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(enc_rsp);
 10197f8:	210d      	movs	r1, #13
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_RSP;
 10197fa:	2204      	movs	r2, #4
{
 10197fc:	b510      	push	{r4, lr}
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10197fe:	7803      	ldrb	r3, [r0, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(enc_rsp);
 1019800:	7041      	strb	r1, [r0, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019802:	f043 0303 	orr.w	r3, r3, #3
 1019806:	7003      	strb	r3, [r0, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_RSP;
 1019808:	70c2      	strb	r2, [r0, #3]
	p = &pdu->llctrl.enc_rsp;
	/* Optimal getting random data, p->ivs is packed right after p->skds */
	BUILD_ASSERT(offsetof(struct pdu_data_llctrl_enc_rsp, ivs) ==
		     offsetof(struct pdu_data_llctrl_enc_rsp, skds) + sizeof(p->skds),
		     "Member IVS must be after member SKDS");
	csrand_get(p->skds, sizeof(p->skds) + sizeof(p->ivs));
 101980a:	1884      	adds	r4, r0, r2
	if (k_is_in_isr()) {
 101980c:	f00f fd39 	bl	1029282 <k_is_in_isr>
		return lll_csrand_isr_get(buf, len);
 1019810:	210c      	movs	r1, #12
	if (k_is_in_isr()) {
 1019812:	b120      	cbz	r0, 101981e <llcp_pdu_encode_enc_rsp+0x26>
		return lll_csrand_isr_get(buf, len);
 1019814:	4620      	mov	r0, r4
}
 1019816:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return lll_csrand_isr_get(buf, len);
 101981a:	f001 bec9 	b.w	101b5b0 <lll_csrand_isr_get>
		return lll_csrand_get(buf, len);
 101981e:	4620      	mov	r0, r4
}
 1019820:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return lll_csrand_get(buf, len);
 1019824:	f001 bea4 	b.w	101b570 <lll_csrand_get>

01019828 <llcp_pdu_encode_start_enc_req>:

void llcp_pdu_encode_start_enc_req(struct pdu_data *pdu)
{
	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(start_enc_req);
 1019828:	2101      	movs	r1, #1
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_REQ;
 101982a:	2205      	movs	r2, #5
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 101982c:	7803      	ldrb	r3, [r0, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(start_enc_req);
 101982e:	7041      	strb	r1, [r0, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019830:	f043 0303 	orr.w	r3, r3, #3
 1019834:	7003      	strb	r3, [r0, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_REQ;
 1019836:	70c2      	strb	r2, [r0, #3]
}
 1019838:	4770      	bx	lr
 101983a:	bf00      	nop

0101983c <llcp_pdu_encode_start_enc_rsp>:
#endif /* CONFIG_BT_PERIPHERAL */

void llcp_pdu_encode_start_enc_rsp(struct pdu_data *pdu)
{
	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(start_enc_rsp);
 101983c:	2101      	movs	r1, #1
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
 101983e:	2206      	movs	r2, #6
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019840:	7803      	ldrb	r3, [r0, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(start_enc_rsp);
 1019842:	7041      	strb	r1, [r0, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019844:	f043 0303 	orr.w	r3, r3, #3
 1019848:	7003      	strb	r3, [r0, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
 101984a:	70c2      	strb	r2, [r0, #3]
}
 101984c:	4770      	bx	lr
 101984e:	bf00      	nop

01019850 <llcp_pdu_encode_pause_enc_rsp>:
#endif /* CONFIG_BT_CENTRAL */

void llcp_pdu_encode_pause_enc_rsp(struct pdu_data *pdu)
{
	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(pause_enc_rsp);
 1019850:	2101      	movs	r1, #1
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP;
 1019852:	220b      	movs	r2, #11
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019854:	7803      	ldrb	r3, [r0, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(pause_enc_rsp);
 1019856:	7041      	strb	r1, [r0, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019858:	f043 0303 	orr.w	r3, r3, #3
 101985c:	7003      	strb	r3, [r0, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP;
 101985e:	70c2      	strb	r2, [r0, #3]
}
 1019860:	4770      	bx	lr
 1019862:	bf00      	nop

01019864 <llcp_pdu_encode_reject_ind>:
#endif /* CONFIG_BT_CTLR_LE_ENC */

void llcp_pdu_encode_reject_ind(struct pdu_data *pdu, uint8_t error_code)
{
	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(reject_ind);
 1019864:	f04f 0c02 	mov.w	ip, #2
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
 1019868:	220d      	movs	r2, #13
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 101986a:	7803      	ldrb	r3, [r0, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(reject_ind);
 101986c:	f880 c001 	strb.w	ip, [r0, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019870:	f043 0303 	orr.w	r3, r3, #3
 1019874:	7003      	strb	r3, [r0, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
 1019876:	70c2      	strb	r2, [r0, #3]
	pdu->llctrl.reject_ind.error_code = error_code;
 1019878:	7101      	strb	r1, [r0, #4]
}
 101987a:	4770      	bx	lr

0101987c <llcp_pdu_encode_reject_ext_ind>:

void llcp_pdu_encode_reject_ext_ind(struct pdu_data *pdu, uint8_t reject_opcode, uint8_t error_code)
{
 101987c:	b500      	push	{lr}
	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(reject_ext_ind);
 101987e:	f04f 0e03 	mov.w	lr, #3
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 1019882:	f04f 0c11 	mov.w	ip, #17
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019886:	7803      	ldrb	r3, [r0, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(reject_ext_ind);
 1019888:	f880 e001 	strb.w	lr, [r0, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 101988c:	ea43 030e 	orr.w	r3, r3, lr
 1019890:	7003      	strb	r3, [r0, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 1019892:	f880 c003 	strb.w	ip, [r0, #3]
	pdu->llctrl.reject_ext_ind.reject_opcode = reject_opcode;
 1019896:	7101      	strb	r1, [r0, #4]
	pdu->llctrl.reject_ext_ind.error_code = error_code;
 1019898:	7142      	strb	r2, [r0, #5]
}
 101989a:	f85d fb04 	ldr.w	pc, [sp], #4
 101989e:	bf00      	nop

010198a0 <llcp_pdu_decode_reject_ext_ind>:

void llcp_pdu_decode_reject_ext_ind(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	ctx->reject_ext_ind.reject_opcode = pdu->llctrl.reject_ext_ind.reject_opcode;
 10198a0:	790b      	ldrb	r3, [r1, #4]
 10198a2:	f880 3049 	strb.w	r3, [r0, #73]	; 0x49
	ctx->reject_ext_ind.error_code = pdu->llctrl.reject_ext_ind.error_code;
 10198a6:	794b      	ldrb	r3, [r1, #5]
 10198a8:	f880 304a 	strb.w	r3, [r0, #74]	; 0x4a
}
 10198ac:	4770      	bx	lr
 10198ae:	bf00      	nop

010198b0 <llcp_pdu_encode_phy_req>:
 */

void llcp_pdu_encode_phy_req(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(phy_req);
 10198b0:	f04f 0c03 	mov.w	ip, #3
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_REQ;
 10198b4:	2216      	movs	r2, #22
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10198b6:	780b      	ldrb	r3, [r1, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(phy_req);
 10198b8:	f881 c001 	strb.w	ip, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10198bc:	ea43 030c 	orr.w	r3, r3, ip
 10198c0:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_REQ;
 10198c2:	70ca      	strb	r2, [r1, #3]
	pdu->llctrl.phy_req.rx_phys = ctx->data.pu.rx;
 10198c4:	7f03      	ldrb	r3, [r0, #28]
 10198c6:	f3c3 03c2 	ubfx	r3, r3, #3, #3
 10198ca:	714b      	strb	r3, [r1, #5]
	pdu->llctrl.phy_req.tx_phys = ctx->data.pu.tx;
 10198cc:	7f03      	ldrb	r3, [r0, #28]
 10198ce:	f3c3 0302 	ubfx	r3, r3, #0, #3
 10198d2:	710b      	strb	r3, [r1, #4]
}
 10198d4:	4770      	bx	lr
 10198d6:	bf00      	nop

010198d8 <llcp_pdu_decode_phy_req>:

void llcp_pdu_decode_phy_req(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	ctx->data.pu.rx = pdu->llctrl.phy_req.tx_phys;
 10198d8:	790a      	ldrb	r2, [r1, #4]
 10198da:	7f03      	ldrb	r3, [r0, #28]
 10198dc:	f362 03c5 	bfi	r3, r2, #3, #3
	ctx->data.pu.tx = pdu->llctrl.phy_req.rx_phys;
 10198e0:	461a      	mov	r2, r3
	ctx->data.pu.rx = pdu->llctrl.phy_req.tx_phys;
 10198e2:	7703      	strb	r3, [r0, #28]
	ctx->data.pu.tx = pdu->llctrl.phy_req.rx_phys;
 10198e4:	794b      	ldrb	r3, [r1, #5]
 10198e6:	f363 0202 	bfi	r2, r3, #0, #3
 10198ea:	7702      	strb	r2, [r0, #28]
}
 10198ec:	4770      	bx	lr
 10198ee:	bf00      	nop

010198f0 <llcp_pdu_encode_phy_rsp>:

#if defined(CONFIG_BT_PERIPHERAL)
void llcp_pdu_encode_phy_rsp(struct ll_conn *conn, struct pdu_data *pdu)
{
	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(phy_rsp);
 10198f0:	f04f 0c03 	mov.w	ip, #3
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
 10198f4:	2217      	movs	r2, #23
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10198f6:	780b      	ldrb	r3, [r1, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(phy_rsp);
 10198f8:	f881 c001 	strb.w	ip, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10198fc:	ea43 030c 	orr.w	r3, r3, ip
 1019900:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
 1019902:	70ca      	strb	r2, [r1, #3]
	pdu->llctrl.phy_rsp.rx_phys = conn->phy_pref_rx;
 1019904:	f890 318c 	ldrb.w	r3, [r0, #396]	; 0x18c
 1019908:	f3c3 03c2 	ubfx	r3, r3, #3, #3
 101990c:	714b      	strb	r3, [r1, #5]
	pdu->llctrl.phy_rsp.tx_phys = conn->phy_pref_tx;
 101990e:	f890 318c 	ldrb.w	r3, [r0, #396]	; 0x18c
 1019912:	f3c3 0302 	ubfx	r3, r3, #0, #3
 1019916:	710b      	strb	r3, [r1, #4]
}
 1019918:	4770      	bx	lr
 101991a:	bf00      	nop

0101991c <llcp_pdu_decode_phy_update_ind>:
void llcp_pdu_decode_phy_update_ind(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	ctx->data.pu.instant = sys_le16_to_cpu(pdu->llctrl.phy_upd_ind.instant);
 101991c:	88cb      	ldrh	r3, [r1, #6]
 101991e:	8403      	strh	r3, [r0, #32]
	ctx->data.pu.c_to_p_phy = pdu->llctrl.phy_upd_ind.c_to_p_phy;
 1019920:	790b      	ldrb	r3, [r1, #4]
 1019922:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
	ctx->data.pu.p_to_c_phy = pdu->llctrl.phy_upd_ind.p_to_c_phy;
 1019926:	794b      	ldrb	r3, [r1, #5]
 1019928:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
}
 101992c:	4770      	bx	lr
 101992e:	bf00      	nop

01019930 <llcp_pdu_encode_conn_param_req>:
					     struct pdu_data_llctrl_conn_param_req_rsp_common *p,
					     uint8_t opcode)
{
	pdu->ll_id = PDU_DATA_LLID_CTRL;
	/* The '+ 1U' is to count in opcode octet, the first member of struct pdu_data_llctrl */
	pdu->len = sizeof(struct pdu_data_llctrl_conn_param_req_rsp_common) + 1U;
 1019930:	f04f 0c18 	mov.w	ip, #24
	pdu->llctrl.opcode = opcode;
 1019934:	220f      	movs	r2, #15
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019936:	780b      	ldrb	r3, [r1, #0]
	pdu->len = sizeof(struct pdu_data_llctrl_conn_param_req_rsp_common) + 1U;
 1019938:	f881 c001 	strb.w	ip, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 101993c:	f043 0303 	orr.w	r3, r3, #3
 1019940:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = opcode;
 1019942:	70ca      	strb	r2, [r1, #3]

	p->interval_min = sys_cpu_to_le16(ctx->data.cu.interval_min);
 1019944:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
 1019946:	808b      	strh	r3, [r1, #4]
	p->interval_max = sys_cpu_to_le16(ctx->data.cu.interval_max);
 1019948:	8d03      	ldrh	r3, [r0, #40]	; 0x28
 101994a:	80cb      	strh	r3, [r1, #6]
	p->latency = sys_cpu_to_le16(ctx->data.cu.latency);
 101994c:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 101994e:	810b      	strh	r3, [r1, #8]
	p->timeout = sys_cpu_to_le16(ctx->data.cu.timeout);
 1019950:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 1019952:	814b      	strh	r3, [r1, #10]
	p->preferred_periodicity = ctx->data.cu.preferred_periodicity;
 1019954:	f890 302e 	ldrb.w	r3, [r0, #46]	; 0x2e
 1019958:	730b      	strb	r3, [r1, #12]
	p->reference_conn_event_count = sys_cpu_to_le16(ctx->data.cu.reference_conn_event_count);
 101995a:	8e03      	ldrh	r3, [r0, #48]	; 0x30
 101995c:	f8a1 300d 	strh.w	r3, [r1, #13]
	p->offset0 = sys_cpu_to_le16(ctx->data.cu.offsets[0]);
 1019960:	8e43      	ldrh	r3, [r0, #50]	; 0x32
 1019962:	f8a1 300f 	strh.w	r3, [r1, #15]
	p->offset1 = sys_cpu_to_le16(ctx->data.cu.offsets[1]);
 1019966:	8e83      	ldrh	r3, [r0, #52]	; 0x34
 1019968:	f8a1 3011 	strh.w	r3, [r1, #17]
	p->offset2 = sys_cpu_to_le16(ctx->data.cu.offsets[2]);
 101996c:	8ec3      	ldrh	r3, [r0, #54]	; 0x36
 101996e:	f8a1 3013 	strh.w	r3, [r1, #19]
	p->offset3 = sys_cpu_to_le16(ctx->data.cu.offsets[3]);
 1019972:	8f03      	ldrh	r3, [r0, #56]	; 0x38
 1019974:	f8a1 3015 	strh.w	r3, [r1, #21]
	p->offset4 = sys_cpu_to_le16(ctx->data.cu.offsets[4]);
 1019978:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
 101997a:	f8a1 3017 	strh.w	r3, [r1, #23]
	p->offset5 = sys_cpu_to_le16(ctx->data.cu.offsets[5]);
 101997e:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
 1019980:	f8a1 3019 	strh.w	r3, [r1, #25]
void llcp_pdu_encode_conn_param_req(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	encode_conn_param_req_rsp_common(ctx, pdu,
		(struct pdu_data_llctrl_conn_param_req_rsp_common *)&pdu->llctrl.conn_param_req,
		PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ);
}
 1019984:	4770      	bx	lr
 1019986:	bf00      	nop

01019988 <llcp_pdu_encode_conn_param_rsp>:
	pdu->len = sizeof(struct pdu_data_llctrl_conn_param_req_rsp_common) + 1U;
 1019988:	f04f 0c18 	mov.w	ip, #24
	pdu->llctrl.opcode = opcode;
 101998c:	2210      	movs	r2, #16
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 101998e:	780b      	ldrb	r3, [r1, #0]
	pdu->len = sizeof(struct pdu_data_llctrl_conn_param_req_rsp_common) + 1U;
 1019990:	f881 c001 	strb.w	ip, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019994:	f043 0303 	orr.w	r3, r3, #3
 1019998:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = opcode;
 101999a:	70ca      	strb	r2, [r1, #3]
	p->interval_min = sys_cpu_to_le16(ctx->data.cu.interval_min);
 101999c:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
 101999e:	808b      	strh	r3, [r1, #4]
	p->interval_max = sys_cpu_to_le16(ctx->data.cu.interval_max);
 10199a0:	8d03      	ldrh	r3, [r0, #40]	; 0x28
 10199a2:	80cb      	strh	r3, [r1, #6]
	p->latency = sys_cpu_to_le16(ctx->data.cu.latency);
 10199a4:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 10199a6:	810b      	strh	r3, [r1, #8]
	p->timeout = sys_cpu_to_le16(ctx->data.cu.timeout);
 10199a8:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 10199aa:	814b      	strh	r3, [r1, #10]
	p->preferred_periodicity = ctx->data.cu.preferred_periodicity;
 10199ac:	f890 302e 	ldrb.w	r3, [r0, #46]	; 0x2e
 10199b0:	730b      	strb	r3, [r1, #12]
	p->reference_conn_event_count = sys_cpu_to_le16(ctx->data.cu.reference_conn_event_count);
 10199b2:	8e03      	ldrh	r3, [r0, #48]	; 0x30
 10199b4:	f8a1 300d 	strh.w	r3, [r1, #13]
	p->offset0 = sys_cpu_to_le16(ctx->data.cu.offsets[0]);
 10199b8:	8e43      	ldrh	r3, [r0, #50]	; 0x32
 10199ba:	f8a1 300f 	strh.w	r3, [r1, #15]
	p->offset1 = sys_cpu_to_le16(ctx->data.cu.offsets[1]);
 10199be:	8e83      	ldrh	r3, [r0, #52]	; 0x34
 10199c0:	f8a1 3011 	strh.w	r3, [r1, #17]
	p->offset2 = sys_cpu_to_le16(ctx->data.cu.offsets[2]);
 10199c4:	8ec3      	ldrh	r3, [r0, #54]	; 0x36
 10199c6:	f8a1 3013 	strh.w	r3, [r1, #19]
	p->offset3 = sys_cpu_to_le16(ctx->data.cu.offsets[3]);
 10199ca:	8f03      	ldrh	r3, [r0, #56]	; 0x38
 10199cc:	f8a1 3015 	strh.w	r3, [r1, #21]
	p->offset4 = sys_cpu_to_le16(ctx->data.cu.offsets[4]);
 10199d0:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
 10199d2:	f8a1 3017 	strh.w	r3, [r1, #23]
	p->offset5 = sys_cpu_to_le16(ctx->data.cu.offsets[5]);
 10199d6:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
 10199d8:	f8a1 3019 	strh.w	r3, [r1, #25]
void llcp_pdu_encode_conn_param_rsp(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	encode_conn_param_req_rsp_common(ctx, pdu,
		(struct pdu_data_llctrl_conn_param_req_rsp_common *)&pdu->llctrl.conn_param_rsp,
		PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP);
}
 10199dc:	4770      	bx	lr
 10199de:	bf00      	nop

010199e0 <llcp_pdu_decode_conn_param_req>:

static void decode_conn_param_req_rsp_common(struct proc_ctx *ctx,
					     struct pdu_data_llctrl_conn_param_req_rsp_common *p)
{
	ctx->data.cu.interval_min = sys_le16_to_cpu(p->interval_min);
 10199e0:	888b      	ldrh	r3, [r1, #4]
 10199e2:	84c3      	strh	r3, [r0, #38]	; 0x26
	ctx->data.cu.interval_max = sys_le16_to_cpu(p->interval_max);
 10199e4:	88cb      	ldrh	r3, [r1, #6]
 10199e6:	8503      	strh	r3, [r0, #40]	; 0x28
	ctx->data.cu.latency = sys_le16_to_cpu(p->latency);
 10199e8:	890b      	ldrh	r3, [r1, #8]
 10199ea:	8543      	strh	r3, [r0, #42]	; 0x2a
	ctx->data.cu.timeout = sys_le16_to_cpu(p->timeout);
 10199ec:	894b      	ldrh	r3, [r1, #10]
 10199ee:	8583      	strh	r3, [r0, #44]	; 0x2c
	ctx->data.cu.preferred_periodicity = p->preferred_periodicity;
 10199f0:	7b0b      	ldrb	r3, [r1, #12]
 10199f2:	f880 302e 	strb.w	r3, [r0, #46]	; 0x2e
	ctx->data.cu.reference_conn_event_count = sys_le16_to_cpu(p->reference_conn_event_count);
 10199f6:	f8b1 300d 	ldrh.w	r3, [r1, #13]
 10199fa:	8603      	strh	r3, [r0, #48]	; 0x30
	ctx->data.cu.offsets[0] = sys_le16_to_cpu(p->offset0);
 10199fc:	f8b1 300f 	ldrh.w	r3, [r1, #15]
 1019a00:	8643      	strh	r3, [r0, #50]	; 0x32
	ctx->data.cu.offsets[1] = sys_le16_to_cpu(p->offset1);
 1019a02:	f8b1 3011 	ldrh.w	r3, [r1, #17]
 1019a06:	8683      	strh	r3, [r0, #52]	; 0x34
	ctx->data.cu.offsets[2] = sys_le16_to_cpu(p->offset2);
 1019a08:	f8b1 3013 	ldrh.w	r3, [r1, #19]
 1019a0c:	86c3      	strh	r3, [r0, #54]	; 0x36
	ctx->data.cu.offsets[3] = sys_le16_to_cpu(p->offset3);
 1019a0e:	f8b1 3015 	ldrh.w	r3, [r1, #21]
 1019a12:	8703      	strh	r3, [r0, #56]	; 0x38
	ctx->data.cu.offsets[4] = sys_le16_to_cpu(p->offset4);
 1019a14:	f8b1 3017 	ldrh.w	r3, [r1, #23]
 1019a18:	8743      	strh	r3, [r0, #58]	; 0x3a
	ctx->data.cu.offsets[5] = sys_le16_to_cpu(p->offset5);
 1019a1a:	f8b1 3019 	ldrh.w	r3, [r1, #25]
 1019a1e:	8783      	strh	r3, [r0, #60]	; 0x3c

void llcp_pdu_decode_conn_param_req(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	decode_conn_param_req_rsp_common(ctx,
		(struct pdu_data_llctrl_conn_param_req_rsp_common *)&pdu->llctrl.conn_param_req);
}
 1019a20:	4770      	bx	lr
 1019a22:	bf00      	nop

01019a24 <llcp_pdu_encode_conn_update_ind>:
{
	struct pdu_data_llctrl_conn_update_ind *p;

	pdu->ll_id = PDU_DATA_LLID_CTRL;
	pdu->len = PDU_DATA_LLCTRL_LEN(conn_update_ind);
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
 1019a24:	f04f 0c00 	mov.w	ip, #0
{
 1019a28:	b500      	push	{lr}
	pdu->len = PDU_DATA_LLCTRL_LEN(conn_update_ind);
 1019a2a:	f04f 0e0c 	mov.w	lr, #12
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019a2e:	780b      	ldrb	r3, [r1, #0]
	pdu->len = PDU_DATA_LLCTRL_LEN(conn_update_ind);
 1019a30:	f881 e001 	strb.w	lr, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019a34:	f043 0303 	orr.w	r3, r3, #3
 1019a38:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
 1019a3a:	f881 c003 	strb.w	ip, [r1, #3]

	p = (void *)&pdu->llctrl.conn_update_ind;
	p->win_size = ctx->data.cu.win_size;
 1019a3e:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
	p->win_offset = sys_cpu_to_le16(ctx->data.cu.win_offset_us / CONN_INT_UNIT_US);
 1019a42:	4a0b      	ldr	r2, [pc, #44]	; (1019a70 <llcp_pdu_encode_conn_update_ind+0x4c>)
	p->win_size = ctx->data.cu.win_size;
 1019a44:	710b      	strb	r3, [r1, #4]
	p->win_offset = sys_cpu_to_le16(ctx->data.cu.win_offset_us / CONN_INT_UNIT_US);
 1019a46:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 1019a48:	fba2 2303 	umull	r2, r3, r2, r3
 1019a4c:	0a9b      	lsrs	r3, r3, #10
 1019a4e:	f8a1 3005 	strh.w	r3, [r1, #5]
	p->latency = sys_cpu_to_le16(ctx->data.cu.latency);
 1019a52:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 1019a54:	f8a1 3009 	strh.w	r3, [r1, #9]
	p->interval = sys_cpu_to_le16(ctx->data.cu.interval_max);
 1019a58:	8d03      	ldrh	r3, [r0, #40]	; 0x28
 1019a5a:	f8a1 3007 	strh.w	r3, [r1, #7]
	p->timeout = sys_cpu_to_le16(ctx->data.cu.timeout);
 1019a5e:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 1019a60:	f8a1 300b 	strh.w	r3, [r1, #11]
	p->instant = sys_cpu_to_le16(ctx->data.cu.instant);
 1019a64:	8c03      	ldrh	r3, [r0, #32]
 1019a66:	f8a1 300d 	strh.w	r3, [r1, #13]
}
 1019a6a:	f85d fb04 	ldr.w	pc, [sp], #4
 1019a6e:	bf00      	nop
 1019a70:	d1b71759 	.word	0xd1b71759

01019a74 <llcp_pdu_decode_conn_update_ind>:
void llcp_pdu_decode_conn_update_ind(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	struct pdu_data_llctrl_conn_update_ind *p;

	p = (void *)&pdu->llctrl.conn_update_ind;
	ctx->data.cu.win_size = p->win_size;
 1019a74:	790b      	ldrb	r3, [r1, #4]
 1019a76:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
	ctx->data.cu.win_offset_us = sys_le16_to_cpu(p->win_offset) * CONN_INT_UNIT_US;
 1019a7a:	f8b1 3005 	ldrh.w	r3, [r1, #5]
 1019a7e:	ebc3 1243 	rsb	r2, r3, r3, lsl #5
 1019a82:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 1019a86:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 1019a8a:	005b      	lsls	r3, r3, #1
 1019a8c:	8483      	strh	r3, [r0, #36]	; 0x24
	ctx->data.cu.latency = sys_le16_to_cpu(p->latency);
 1019a8e:	f8b1 3009 	ldrh.w	r3, [r1, #9]
 1019a92:	8543      	strh	r3, [r0, #42]	; 0x2a
	ctx->data.cu.interval_max = sys_le16_to_cpu(p->interval);
 1019a94:	f8b1 3007 	ldrh.w	r3, [r1, #7]
 1019a98:	8503      	strh	r3, [r0, #40]	; 0x28
	ctx->data.cu.timeout = sys_le16_to_cpu(p->timeout);
 1019a9a:	f8b1 300b 	ldrh.w	r3, [r1, #11]
 1019a9e:	8583      	strh	r3, [r0, #44]	; 0x2c
	ctx->data.cu.instant = sys_le16_to_cpu(p->instant);
 1019aa0:	f8b1 300d 	ldrh.w	r3, [r1, #13]
 1019aa4:	8403      	strh	r3, [r0, #32]
}
 1019aa6:	4770      	bx	lr

01019aa8 <llcp_pdu_decode_chan_map_update_ind>:
	memcpy(p->chm, ctx->data.chmu.chm, sizeof(p->chm));
}

void llcp_pdu_decode_chan_map_update_ind(struct proc_ctx *ctx, struct pdu_data *pdu)
{
	ctx->data.chmu.instant = sys_le16_to_cpu(pdu->llctrl.chan_map_ind.instant);
 1019aa8:	f8b1 3009 	ldrh.w	r3, [r1, #9]
	memcpy(ctx->data.chmu.chm, pdu->llctrl.chan_map_ind.chm, sizeof(ctx->data.chmu.chm));
 1019aac:	2205      	movs	r2, #5
	ctx->data.chmu.instant = sys_le16_to_cpu(pdu->llctrl.chan_map_ind.instant);
 1019aae:	8383      	strh	r3, [r0, #28]
	memcpy(ctx->data.chmu.chm, pdu->llctrl.chan_map_ind.chm, sizeof(ctx->data.chmu.chm));
 1019ab0:	3104      	adds	r1, #4
 1019ab2:	301e      	adds	r0, #30
 1019ab4:	f00c bf5e 	b.w	1026974 <memcpy>

01019ab8 <llcp_pdu_encode_length_req>:
					 const uint8_t opcode,
					 const struct data_pdu_length *dle)
{
	pdu->ll_id = PDU_DATA_LLID_CTRL;
	/* The '+ 1U' is to count in opcode octet, the first member of struct pdu_data_llctrl */
	pdu->len = sizeof(struct pdu_data_llctrl_length_req_rsp_common) + 1U;
 1019ab8:	f04f 0c09 	mov.w	ip, #9
	pdu->llctrl.opcode = opcode;
 1019abc:	2214      	movs	r2, #20
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019abe:	780b      	ldrb	r3, [r1, #0]
	pdu->len = sizeof(struct pdu_data_llctrl_length_req_rsp_common) + 1U;
 1019ac0:	f881 c001 	strb.w	ip, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019ac4:	f043 0303 	orr.w	r3, r3, #3
 1019ac8:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = opcode;
 1019aca:	70ca      	strb	r2, [r1, #3]
	p->max_rx_octets = sys_cpu_to_le16(dle->max_rx_octets);
 1019acc:	f8b0 305a 	ldrh.w	r3, [r0, #90]	; 0x5a
 1019ad0:	808b      	strh	r3, [r1, #4]
	p->max_tx_octets = sys_cpu_to_le16(dle->max_tx_octets);
 1019ad2:	f8b0 3058 	ldrh.w	r3, [r0, #88]	; 0x58
 1019ad6:	810b      	strh	r3, [r1, #8]
	p->max_rx_time = sys_cpu_to_le16(dle->max_rx_time);
 1019ad8:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 1019adc:	80cb      	strh	r3, [r1, #6]
	p->max_tx_time = sys_cpu_to_le16(dle->max_tx_time);
 1019ade:	f8b0 305c 	ldrh.w	r3, [r0, #92]	; 0x5c
 1019ae2:	814b      	strh	r3, [r1, #10]
{
	encode_length_req_rsp_common(pdu,
		(struct pdu_data_llctrl_length_req_rsp_common *)&pdu->llctrl.length_req,
		PDU_DATA_LLCTRL_TYPE_LENGTH_REQ,
		&conn->lll.dle.local);
}
 1019ae4:	4770      	bx	lr
 1019ae6:	bf00      	nop

01019ae8 <llcp_pdu_encode_length_rsp>:
	pdu->len = sizeof(struct pdu_data_llctrl_length_req_rsp_common) + 1U;
 1019ae8:	f04f 0c09 	mov.w	ip, #9
	pdu->llctrl.opcode = opcode;
 1019aec:	2215      	movs	r2, #21
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019aee:	780b      	ldrb	r3, [r1, #0]
	pdu->len = sizeof(struct pdu_data_llctrl_length_req_rsp_common) + 1U;
 1019af0:	f881 c001 	strb.w	ip, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019af4:	f043 0303 	orr.w	r3, r3, #3
 1019af8:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = opcode;
 1019afa:	70ca      	strb	r2, [r1, #3]
	p->max_rx_octets = sys_cpu_to_le16(dle->max_rx_octets);
 1019afc:	f8b0 305a 	ldrh.w	r3, [r0, #90]	; 0x5a
 1019b00:	808b      	strh	r3, [r1, #4]
	p->max_tx_octets = sys_cpu_to_le16(dle->max_tx_octets);
 1019b02:	f8b0 3058 	ldrh.w	r3, [r0, #88]	; 0x58
 1019b06:	810b      	strh	r3, [r1, #8]
	p->max_rx_time = sys_cpu_to_le16(dle->max_rx_time);
 1019b08:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 1019b0c:	80cb      	strh	r3, [r1, #6]
	p->max_tx_time = sys_cpu_to_le16(dle->max_tx_time);
 1019b0e:	f8b0 305c 	ldrh.w	r3, [r0, #92]	; 0x5c
 1019b12:	814b      	strh	r3, [r1, #10]
{
	encode_length_req_rsp_common(pdu,
		(struct pdu_data_llctrl_length_req_rsp_common *)&pdu->llctrl.length_rsp,
		PDU_DATA_LLCTRL_TYPE_LENGTH_RSP,
		&conn->lll.dle.local);
}
 1019b14:	4770      	bx	lr
 1019b16:	bf00      	nop

01019b18 <llcp_ntf_encode_length_change>:
	pdu->len = sizeof(struct pdu_data_llctrl_length_req_rsp_common) + 1U;
 1019b18:	f04f 0c09 	mov.w	ip, #9
	pdu->llctrl.opcode = opcode;
 1019b1c:	2215      	movs	r2, #21
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019b1e:	780b      	ldrb	r3, [r1, #0]
	pdu->len = sizeof(struct pdu_data_llctrl_length_req_rsp_common) + 1U;
 1019b20:	f881 c001 	strb.w	ip, [r1, #1]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1019b24:	f043 0303 	orr.w	r3, r3, #3
 1019b28:	700b      	strb	r3, [r1, #0]
	pdu->llctrl.opcode = opcode;
 1019b2a:	70ca      	strb	r2, [r1, #3]
	p->max_rx_octets = sys_cpu_to_le16(dle->max_rx_octets);
 1019b2c:	f8b0 306a 	ldrh.w	r3, [r0, #106]	; 0x6a
 1019b30:	808b      	strh	r3, [r1, #4]
	p->max_tx_octets = sys_cpu_to_le16(dle->max_tx_octets);
 1019b32:	f8b0 3068 	ldrh.w	r3, [r0, #104]	; 0x68
 1019b36:	810b      	strh	r3, [r1, #8]
	p->max_rx_time = sys_cpu_to_le16(dle->max_rx_time);
 1019b38:	f8b0 306e 	ldrh.w	r3, [r0, #110]	; 0x6e
 1019b3c:	80cb      	strh	r3, [r1, #6]
	p->max_tx_time = sys_cpu_to_le16(dle->max_tx_time);
 1019b3e:	f8b0 306c 	ldrh.w	r3, [r0, #108]	; 0x6c
 1019b42:	814b      	strh	r3, [r1, #10]
{
	encode_length_req_rsp_common(pdu,
		(struct pdu_data_llctrl_length_req_rsp_common *)&pdu->llctrl.length_rsp,
		PDU_DATA_LLCTRL_TYPE_LENGTH_RSP,
		&conn->lll.dle.eff);
}
 1019b44:	4770      	bx	lr
 1019b46:	bf00      	nop

01019b48 <llcp_pdu_decode_length_req>:
static void decode_length_req_rsp_common(struct ll_conn *conn,
					 struct pdu_data_llctrl_length_req_rsp_common *p)
{
	struct data_pdu_length remote;

	remote.max_rx_octets = sys_le16_to_cpu(p->max_rx_octets);
 1019b48:	888a      	ldrh	r2, [r1, #4]
	if (!IN_RANGE(remote->max_rx_octets, PDU_DC_PAYLOAD_SIZE_MIN,
 1019b4a:	f1a2 031b 	sub.w	r3, r2, #27
 1019b4e:	2be0      	cmp	r3, #224	; 0xe0
 1019b50:	d821      	bhi.n	1019b96 <llcp_pdu_decode_length_req+0x4e>
	remote.max_tx_octets = sys_le16_to_cpu(p->max_tx_octets);
 1019b52:	f8b1 c008 	ldrh.w	ip, [r1, #8]
	if (!IN_RANGE(remote->max_tx_octets, PDU_DC_PAYLOAD_SIZE_MIN,
 1019b56:	f1ac 031b 	sub.w	r3, ip, #27
 1019b5a:	2be0      	cmp	r3, #224	; 0xe0
 1019b5c:	d81b      	bhi.n	1019b96 <llcp_pdu_decode_length_req+0x4e>

	conn->lll.dle.remote = remote;
}

void llcp_pdu_decode_length_req(struct ll_conn *conn, struct pdu_data *pdu)
{
 1019b5e:	b570      	push	{r4, r5, r6, lr}
	if (!IN_RANGE(remote->max_rx_time, PDU_DC_PAYLOAD_TIME_MIN,
 1019b60:	f244 1e48 	movw	lr, #16712	; 0x4148
	remote.max_rx_time = sys_le16_to_cpu(p->max_rx_time);
 1019b64:	88cc      	ldrh	r4, [r1, #6]
	if (!IN_RANGE(remote->max_rx_time, PDU_DC_PAYLOAD_TIME_MIN,
 1019b66:	f5a4 73a4 	sub.w	r3, r4, #328	; 0x148
 1019b6a:	b29b      	uxth	r3, r3
 1019b6c:	4573      	cmp	r3, lr
 1019b6e:	d811      	bhi.n	1019b94 <llcp_pdu_decode_length_req+0x4c>
 1019b70:	2300      	movs	r3, #0
	remote.max_tx_time = sys_le16_to_cpu(p->max_tx_time);
 1019b72:	894e      	ldrh	r6, [r1, #10]
 1019b74:	4619      	mov	r1, r3
	if (!IN_RANGE(remote->max_tx_time, PDU_DC_PAYLOAD_TIME_MIN,
 1019b76:	f5a6 75a4 	sub.w	r5, r6, #328	; 0x148
 1019b7a:	b2ad      	uxth	r5, r5
 1019b7c:	f36c 030f 	bfi	r3, ip, #0, #16
 1019b80:	f366 010f 	bfi	r1, r6, #0, #16
 1019b84:	f362 431f 	bfi	r3, r2, #16, #16
 1019b88:	f364 411f 	bfi	r1, r4, #16, #16
 1019b8c:	4575      	cmp	r5, lr
	conn->lll.dle.remote = remote;
 1019b8e:	bf98      	it	ls
 1019b90:	e9c0 3118 	strdls	r3, r1, [r0, #96]	; 0x60
	decode_length_req_rsp_common(conn,
		(struct pdu_data_llctrl_length_req_rsp_common *)&pdu->llctrl.length_req);
}
 1019b94:	bd70      	pop	{r4, r5, r6, pc}
 1019b96:	4770      	bx	lr

01019b98 <llcp_pdu_decode_length_rsp>:

void llcp_pdu_decode_length_rsp(struct ll_conn *conn, struct pdu_data *pdu)
 1019b98:	888a      	ldrh	r2, [r1, #4]
 1019b9a:	f1a2 031b 	sub.w	r3, r2, #27
 1019b9e:	2be0      	cmp	r3, #224	; 0xe0
 1019ba0:	d821      	bhi.n	1019be6 <llcp_pdu_decode_length_rsp+0x4e>
 1019ba2:	f8b1 c008 	ldrh.w	ip, [r1, #8]
 1019ba6:	f1ac 031b 	sub.w	r3, ip, #27
 1019baa:	2be0      	cmp	r3, #224	; 0xe0
 1019bac:	d81b      	bhi.n	1019be6 <llcp_pdu_decode_length_rsp+0x4e>
 1019bae:	b570      	push	{r4, r5, r6, lr}
 1019bb0:	f244 1e48 	movw	lr, #16712	; 0x4148
 1019bb4:	88cc      	ldrh	r4, [r1, #6]
 1019bb6:	f5a4 73a4 	sub.w	r3, r4, #328	; 0x148
 1019bba:	b29b      	uxth	r3, r3
 1019bbc:	4573      	cmp	r3, lr
 1019bbe:	d811      	bhi.n	1019be4 <llcp_pdu_decode_length_rsp+0x4c>
 1019bc0:	2300      	movs	r3, #0
 1019bc2:	894e      	ldrh	r6, [r1, #10]
 1019bc4:	4619      	mov	r1, r3
 1019bc6:	f5a6 75a4 	sub.w	r5, r6, #328	; 0x148
 1019bca:	b2ad      	uxth	r5, r5
 1019bcc:	f36c 030f 	bfi	r3, ip, #0, #16
 1019bd0:	f366 010f 	bfi	r1, r6, #0, #16
 1019bd4:	f362 431f 	bfi	r3, r2, #16, #16
 1019bd8:	f364 411f 	bfi	r1, r4, #16, #16
 1019bdc:	4575      	cmp	r5, lr
 1019bde:	bf98      	it	ls
 1019be0:	e9c0 3118 	strdls	r3, r1, [r0, #96]	; 0x60
 1019be4:	bd70      	pop	{r4, r5, r6, pc}
 1019be6:	4770      	bx	lr

01019be8 <cu_ntf>:
	return (((ctx->proc == PROC_CONN_PARAM_REQ) && (ctx->data.cu.error != 0U)) ||
		(ctx->data.cu.params_changed != 0U));
}

static void cu_ntf(struct ll_conn *conn, struct proc_ctx *ctx)
{
 1019be8:	b570      	push	{r4, r5, r6, lr}
 1019bea:	4606      	mov	r6, r0
 1019bec:	460d      	mov	r5, r1
	struct node_rx_pdu *ntf;
	struct node_rx_cu *pdu;

	/* Allocate ntf node */
	ntf = llcp_ntf_alloc();
 1019bee:	f7fe f977 	bl	1017ee0 <llcp_ntf_alloc>
	LL_ASSERT(ntf);
 1019bf2:	4604      	mov	r4, r0
 1019bf4:	b1c8      	cbz	r0, 1019c2a <cu_ntf+0x42>

	ntf->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
 1019bf6:	2319      	movs	r3, #25
 1019bf8:	7123      	strb	r3, [r4, #4]
	ntf->hdr.handle = conn->lll.handle;
 1019bfa:	8d33      	ldrh	r3, [r6, #40]	; 0x28
 1019bfc:	80e3      	strh	r3, [r4, #6]
	pdu = (struct node_rx_cu *)ntf->pdu;

	pdu->status = ctx->data.cu.error;
 1019bfe:	7f2b      	ldrb	r3, [r5, #28]
 1019c00:	7723      	strb	r3, [r4, #28]
	if (!ctx->data.cu.error) {
 1019c02:	b95b      	cbnz	r3, 1019c1c <cu_ntf+0x34>
		pdu->interval = ctx->data.cu.interval_max;
 1019c04:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
 1019c06:	83e3      	strh	r3, [r4, #30]
		pdu->latency = ctx->data.cu.latency;
 1019c08:	8d6b      	ldrh	r3, [r5, #42]	; 0x2a
 1019c0a:	8423      	strh	r3, [r4, #32]
		pdu->timeout = ctx->data.cu.timeout;
 1019c0c:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
 1019c0e:	8463      	strh	r3, [r4, #34]	; 0x22
		pdu->latency = conn->lll.latency;
		pdu->timeout = conn->supervision_timeout;
	}

	/* Enqueue notification towards LL */
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1019c10:	4621      	mov	r1, r4
 1019c12:	6820      	ldr	r0, [r4, #0]
}
 1019c14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1019c18:	f7fa bb60 	b.w	10142dc <ll_rx_put_sched>
		pdu->interval = conn->lll.interval;
 1019c1c:	8d73      	ldrh	r3, [r6, #42]	; 0x2a
 1019c1e:	83e3      	strh	r3, [r4, #30]
		pdu->latency = conn->lll.latency;
 1019c20:	8db3      	ldrh	r3, [r6, #44]	; 0x2c
 1019c22:	8423      	strh	r3, [r4, #32]
		pdu->timeout = conn->supervision_timeout;
 1019c24:	f8b6 3184 	ldrh.w	r3, [r6, #388]	; 0x184
 1019c28:	e7f1      	b.n	1019c0e <cu_ntf+0x26>
	LL_ASSERT(ntf);
 1019c2a:	23f1      	movs	r3, #241	; 0xf1
 1019c2c:	4a05      	ldr	r2, [pc, #20]	; (1019c44 <cu_ntf+0x5c>)
 1019c2e:	4906      	ldr	r1, [pc, #24]	; (1019c48 <cu_ntf+0x60>)
 1019c30:	4806      	ldr	r0, [pc, #24]	; (1019c4c <cu_ntf+0x64>)
 1019c32:	f00a ffd0 	bl	1024bd6 <assert_print>
 1019c36:	4040      	eors	r0, r0
 1019c38:	f380 8811 	msr	BASEPRI, r0
 1019c3c:	f04f 0003 	mov.w	r0, #3
 1019c40:	df02      	svc	2
 1019c42:	e7d8      	b.n	1019bf6 <cu_ntf+0xe>
 1019c44:	0102acd0 	.word	0x0102acd0
 1019c48:	0102aad0 	.word	0x0102aad0
 1019c4c:	0102a278 	.word	0x0102a278

01019c50 <rp_cu_conn_param_req_ntf>:
#endif /* CONFIG_BT_CTLR_CONN_PARAM_REQ */
}

#if defined(CONFIG_BT_CTLR_CONN_PARAM_REQ)
static void rp_cu_conn_param_req_ntf(struct ll_conn *conn, struct proc_ctx *ctx)
{
 1019c50:	b570      	push	{r4, r5, r6, lr}
 1019c52:	4605      	mov	r5, r0
 1019c54:	460e      	mov	r6, r1
	struct node_rx_pdu *ntf;
	struct pdu_data *pdu;

	/* Allocate ntf node */
	ntf = llcp_ntf_alloc();
 1019c56:	f7fe f943 	bl	1017ee0 <llcp_ntf_alloc>
	LL_ASSERT(ntf);
 1019c5a:	4604      	mov	r4, r0
 1019c5c:	b170      	cbz	r0, 1019c7c <rp_cu_conn_param_req_ntf+0x2c>

	ntf->hdr.type = NODE_RX_TYPE_DC_PDU;
 1019c5e:	2303      	movs	r3, #3
 1019c60:	7123      	strb	r3, [r4, #4]
	ntf->hdr.handle = conn->lll.handle;
 1019c62:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
	pdu = (struct pdu_data *)ntf->pdu;

	llcp_pdu_encode_conn_param_req(ctx, pdu);
 1019c64:	4630      	mov	r0, r6
 1019c66:	f104 011c 	add.w	r1, r4, #28
	ntf->hdr.handle = conn->lll.handle;
 1019c6a:	80e3      	strh	r3, [r4, #6]
	llcp_pdu_encode_conn_param_req(ctx, pdu);
 1019c6c:	f7ff fe60 	bl	1019930 <llcp_pdu_encode_conn_param_req>

	/* Enqueue notification towards LL */
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1019c70:	4621      	mov	r1, r4
 1019c72:	6820      	ldr	r0, [r4, #0]
}
 1019c74:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ll_rx_put_sched(ntf->hdr.link, ntf);
 1019c78:	f7fa bb30 	b.w	10142dc <ll_rx_put_sched>
	LL_ASSERT(ntf);
 1019c7c:	f240 23ea 	movw	r3, #746	; 0x2ea
 1019c80:	4a05      	ldr	r2, [pc, #20]	; (1019c98 <rp_cu_conn_param_req_ntf+0x48>)
 1019c82:	4906      	ldr	r1, [pc, #24]	; (1019c9c <rp_cu_conn_param_req_ntf+0x4c>)
 1019c84:	4806      	ldr	r0, [pc, #24]	; (1019ca0 <rp_cu_conn_param_req_ntf+0x50>)
 1019c86:	f00a ffa6 	bl	1024bd6 <assert_print>
 1019c8a:	4040      	eors	r0, r0
 1019c8c:	f380 8811 	msr	BASEPRI, r0
 1019c90:	f04f 0003 	mov.w	r0, #3
 1019c94:	df02      	svc	2
 1019c96:	e7e2      	b.n	1019c5e <rp_cu_conn_param_req_ntf+0xe>
 1019c98:	0102acd0 	.word	0x0102acd0
 1019c9c:	0102aad0 	.word	0x0102aad0
 1019ca0:	0102a278 	.word	0x0102a278

01019ca4 <cu_update_conn_parameters>:
{
 1019ca4:	b530      	push	{r4, r5, lr}
	if ((interval != lll->interval) || (latency != lll->latency) ||
 1019ca6:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
	ctx->data.cu.params_changed = cu_have_params_changed(
 1019ca8:	8d0a      	ldrh	r2, [r1, #40]	; 0x28
 1019caa:	8d4c      	ldrh	r4, [r1, #42]	; 0x2a
	if ((interval != lll->interval) || (latency != lll->latency) ||
 1019cac:	4293      	cmp	r3, r2
	ctx->data.cu.params_changed = cu_have_params_changed(
 1019cae:	8d8d      	ldrh	r5, [r1, #44]	; 0x2c
{
 1019cb0:	b085      	sub	sp, #20
	if ((interval != lll->interval) || (latency != lll->latency) ||
 1019cb2:	d102      	bne.n	1019cba <cu_update_conn_parameters+0x16>
 1019cb4:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 1019cb6:	42a3      	cmp	r3, r4
 1019cb8:	d013      	beq.n	1019ce2 <cu_update_conn_parameters+0x3e>
 1019cba:	2301      	movs	r3, #1
	ctx->data.cu.params_changed = cu_have_params_changed(
 1019cbc:	778b      	strb	r3, [r1, #30]
	ull_conn_update_parameters(conn, (ctx->proc == PROC_CONN_UPDATE), ctx->data.cu.win_size,
 1019cbe:	9502      	str	r5, [sp, #8]
 1019cc0:	8c8b      	ldrh	r3, [r1, #36]	; 0x24
 1019cc2:	e9cd 2400 	strd	r2, r4, [sp]
 1019cc6:	7a0c      	ldrb	r4, [r1, #8]
 1019cc8:	f891 2022 	ldrb.w	r2, [r1, #34]	; 0x22
 1019ccc:	8c09      	ldrh	r1, [r1, #32]
 1019cce:	9103      	str	r1, [sp, #12]
 1019cd0:	f1a4 0108 	sub.w	r1, r4, #8
 1019cd4:	fab1 f181 	clz	r1, r1
 1019cd8:	0949      	lsrs	r1, r1, #5
 1019cda:	f7e7 f895 	bl	1000e08 <ull_conn_update_parameters>
}
 1019cde:	b005      	add	sp, #20
 1019ce0:	bd30      	pop	{r4, r5, pc}
	if ((interval != lll->interval) || (latency != lll->latency) ||
 1019ce2:	f8b0 3184 	ldrh.w	r3, [r0, #388]	; 0x184
	ctx->data.cu.params_changed = cu_have_params_changed(
 1019ce6:	1b5b      	subs	r3, r3, r5
 1019ce8:	bf18      	it	ne
 1019cea:	2301      	movne	r3, #1
 1019cec:	e7e6      	b.n	1019cbc <cu_update_conn_parameters+0x18>
 1019cee:	bf00      	nop

01019cf0 <rp_cu_tx>:
{
 1019cf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1019cf2:	4607      	mov	r7, r0
 1019cf4:	460d      	mov	r5, r1
 1019cf6:	4616      	mov	r6, r2
	tx = llcp_tx_alloc(conn, ctx);
 1019cf8:	f7fe f8d6 	bl	1017ea8 <llcp_tx_alloc>
	LL_ASSERT(tx);
 1019cfc:	4604      	mov	r4, r0
 1019cfe:	2800      	cmp	r0, #0
 1019d00:	d03b      	beq.n	1019d7a <rp_cu_tx+0x8a>
	pdu = (struct pdu_data *)tx->pdu;
 1019d02:	1d21      	adds	r1, r4, #4
	switch (opcode) {
 1019d04:	2e11      	cmp	r6, #17
 1019d06:	d80a      	bhi.n	1019d1e <rp_cu_tx+0x2e>
 1019d08:	e8df f006 	tbb	[pc, r6]
 1019d0c:	0909092a 	.word	0x0909092a
 1019d10:	26090909 	.word	0x26090909
 1019d14:	09090909 	.word	0x09090909
 1019d18:	09090909 	.word	0x09090909
 1019d1c:	202e      	.short	0x202e
		LL_ASSERT(0);
 1019d1e:	f240 23d1 	movw	r3, #721	; 0x2d1
 1019d22:	4a1d      	ldr	r2, [pc, #116]	; (1019d98 <rp_cu_tx+0xa8>)
 1019d24:	491d      	ldr	r1, [pc, #116]	; (1019d9c <rp_cu_tx+0xac>)
 1019d26:	481e      	ldr	r0, [pc, #120]	; (1019da0 <rp_cu_tx+0xb0>)
 1019d28:	f00a ff55 	bl	1024bd6 <assert_print>
 1019d2c:	4040      	eors	r0, r0
 1019d2e:	f380 8811 	msr	BASEPRI, r0
 1019d32:	f04f 0003 	mov.w	r0, #3
 1019d36:	df02      	svc	2
	ctx->tx_opcode = pdu->llctrl.opcode;
 1019d38:	79e3      	ldrb	r3, [r4, #7]
	llcp_tx_enqueue(conn, tx);
 1019d3a:	4621      	mov	r1, r4
	ctx->tx_opcode = pdu->llctrl.opcode;
 1019d3c:	736b      	strb	r3, [r5, #13]
	llcp_tx_enqueue(conn, tx);
 1019d3e:	4638      	mov	r0, r7
 1019d40:	f7fe f8d0 	bl	1017ee4 <llcp_tx_enqueue>
	if (ctx->proc == PROC_CONN_PARAM_REQ) {
 1019d44:	7a2b      	ldrb	r3, [r5, #8]
 1019d46:	2b09      	cmp	r3, #9
 1019d48:	d012      	beq.n	1019d70 <rp_cu_tx+0x80>
}
 1019d4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		llcp_pdu_encode_reject_ext_ind(pdu, ctx->data.cu.rejected_opcode,
 1019d4c:	4608      	mov	r0, r1
 1019d4e:	7f2a      	ldrb	r2, [r5, #28]
 1019d50:	7f69      	ldrb	r1, [r5, #29]
 1019d52:	f7ff fd93 	bl	101987c <llcp_pdu_encode_reject_ext_ind>
		break;
 1019d56:	e7ef      	b.n	1019d38 <rp_cu_tx+0x48>
		llcp_pdu_encode_unknown_rsp(ctx, pdu);
 1019d58:	4628      	mov	r0, r5
 1019d5a:	f7ff fc23 	bl	10195a4 <llcp_pdu_encode_unknown_rsp>
		break;
 1019d5e:	e7eb      	b.n	1019d38 <rp_cu_tx+0x48>
		llcp_pdu_encode_conn_update_ind(ctx, pdu);
 1019d60:	4628      	mov	r0, r5
 1019d62:	f7ff fe5f 	bl	1019a24 <llcp_pdu_encode_conn_update_ind>
		break;
 1019d66:	e7e7      	b.n	1019d38 <rp_cu_tx+0x48>
		llcp_pdu_encode_conn_param_rsp(ctx, pdu);
 1019d68:	4628      	mov	r0, r5
 1019d6a:	f7ff fe0d 	bl	1019988 <llcp_pdu_encode_conn_param_rsp>
		break;
 1019d6e:	e7e3      	b.n	1019d38 <rp_cu_tx+0x48>
		llcp_rr_prt_restart(conn);
 1019d70:	4638      	mov	r0, r7
}
 1019d72:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		llcp_rr_prt_restart(conn);
 1019d76:	f000 beb3 	b.w	101aae0 <llcp_rr_prt_restart>
	LL_ASSERT(tx);
 1019d7a:	f44f 732e 	mov.w	r3, #696	; 0x2b8
 1019d7e:	4a06      	ldr	r2, [pc, #24]	; (1019d98 <rp_cu_tx+0xa8>)
 1019d80:	4908      	ldr	r1, [pc, #32]	; (1019da4 <rp_cu_tx+0xb4>)
 1019d82:	4807      	ldr	r0, [pc, #28]	; (1019da0 <rp_cu_tx+0xb0>)
 1019d84:	f00a ff27 	bl	1024bd6 <assert_print>
 1019d88:	4040      	eors	r0, r0
 1019d8a:	f380 8811 	msr	BASEPRI, r0
 1019d8e:	f04f 0003 	mov.w	r0, #3
 1019d92:	df02      	svc	2
 1019d94:	e7b5      	b.n	1019d02 <rp_cu_tx+0x12>
 1019d96:	bf00      	nop
 1019d98:	0102acd0 	.word	0x0102acd0
 1019d9c:	0102a300 	.word	0x0102a300
 1019da0:	0102a278 	.word	0x0102a278
 1019da4:	0102a920 	.word	0x0102a920

01019da8 <rp_cu_send_conn_update_ind.constprop.0>:
		cu_ntf(conn, ctx);
		rp_cu_complete(conn, ctx);
	}
}

static void rp_cu_send_conn_update_ind(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt,
 1019da8:	b570      	push	{r4, r5, r6, lr}
 1019daa:	4606      	mov	r6, r0
 1019dac:	460c      	mov	r4, r1
				       void *param)
{
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 1019dae:	f000 fe8f 	bl	101aad0 <llcp_rr_ispaused>
 1019db2:	b110      	cbz	r0, 1019dba <rp_cu_send_conn_update_ind.constprop.0+0x12>
		ctx->state = RP_CU_STATE_WAIT_TX_CONN_UPDATE_IND;
 1019db4:	2309      	movs	r3, #9
 1019db6:	72a3      	strb	r3, [r4, #10]
		cu_prepare_update_ind(conn, ctx);
		rp_cu_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND);
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_UNUSED;
		ctx->state = RP_CU_STATE_WAIT_INSTANT;
	}
}
 1019db8:	bd70      	pop	{r4, r5, r6, pc}
 1019dba:	4605      	mov	r5, r0
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 1019dbc:	4621      	mov	r1, r4
 1019dbe:	4630      	mov	r0, r6
 1019dc0:	f7fe f86a 	bl	1017e98 <llcp_tx_alloc_peek>
 1019dc4:	2800      	cmp	r0, #0
 1019dc6:	d0f5      	beq.n	1019db4 <rp_cu_send_conn_update_ind.constprop.0+0xc>
	ctx->data.cu.win_size = 1U;
 1019dc8:	2101      	movs	r1, #1
	const uint8_t preferred_periodicity = ctx->data.cu.preferred_periodicity;
 1019dca:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
		const uint16_t interval_max = (ctx->data.cu.interval_max / preferred_periodicity) *
 1019dce:	8d22      	ldrh	r2, [r4, #40]	; 0x28
	ctx->data.cu.win_offset_us = 0U;
 1019dd0:	84a5      	strh	r5, [r4, #36]	; 0x24
	ctx->data.cu.win_size = 1U;
 1019dd2:	f884 1022 	strb.w	r1, [r4, #34]	; 0x22
	if (preferred_periodicity) {
 1019dd6:	b14b      	cbz	r3, 1019dec <rp_cu_send_conn_update_ind.constprop.0+0x44>
		const uint16_t interval_max = (ctx->data.cu.interval_max / preferred_periodicity) *
 1019dd8:	fbb2 f0f3 	udiv	r0, r2, r3
 1019ddc:	fb00 f303 	mul.w	r3, r0, r3
		if (interval_max >= ctx->data.cu.interval_min) {
 1019de0:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
		const uint16_t interval_max = (ctx->data.cu.interval_max / preferred_periodicity) *
 1019de2:	b29b      	uxth	r3, r3
		if (interval_max >= ctx->data.cu.interval_min) {
 1019de4:	4299      	cmp	r1, r3
			ctx->data.cu.interval_max = interval_max;
 1019de6:	bf9c      	itt	ls
 1019de8:	461a      	movls	r2, r3
 1019dea:	8523      	strhls	r3, [r4, #40]	; 0x28
	if (ctx->data.cu.offsets[0] <= ctx->data.cu.interval_max) {
 1019dec:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 1019dee:	4293      	cmp	r3, r2
 1019df0:	d807      	bhi.n	1019e02 <rp_cu_send_conn_update_ind.constprop.0+0x5a>
		ctx->data.cu.win_offset_us = ctx->data.cu.offsets[0] * CONN_INT_UNIT_US;
 1019df2:	ebc3 1243 	rsb	r2, r3, r3, lsl #5
 1019df6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 1019dfa:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 1019dfe:	005b      	lsls	r3, r3, #1
 1019e00:	84a3      	strh	r3, [r4, #36]	; 0x24
	ctx->data.cu.instant = ull_conn_event_counter(conn) + conn->lll.latency +
 1019e02:	4630      	mov	r0, r6
 1019e04:	f7fc fde8 	bl	10169d8 <ull_conn_event_counter>
 1019e08:	4603      	mov	r3, r0
 1019e0a:	8db5      	ldrh	r5, [r6, #44]	; 0x2c
		rp_cu_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND);
 1019e0c:	2200      	movs	r2, #0
	ctx->data.cu.instant = ull_conn_event_counter(conn) + conn->lll.latency +
 1019e0e:	3506      	adds	r5, #6
 1019e10:	442b      	add	r3, r5
 1019e12:	8423      	strh	r3, [r4, #32]
		rp_cu_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND);
 1019e14:	4630      	mov	r0, r6
 1019e16:	4621      	mov	r1, r4
 1019e18:	f7ff ff6a 	bl	1019cf0 <rp_cu_tx>
		ctx->rx_opcode = PDU_DATA_LLCTRL_TYPE_UNUSED;
 1019e1c:	22ff      	movs	r2, #255	; 0xff
 1019e1e:	230b      	movs	r3, #11
 1019e20:	72e2      	strb	r2, [r4, #11]
		ctx->state = RP_CU_STATE_WAIT_TX_CONN_UPDATE_IND;
 1019e22:	72a3      	strb	r3, [r4, #10]
}
 1019e24:	bd70      	pop	{r4, r5, r6, pc}
 1019e26:	bf00      	nop

01019e28 <lp_cu_send_conn_param_req.constprop.0>:
static void lp_cu_send_conn_param_req(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt,
 1019e28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return conn_upd_curr && (conn_upd_curr != conn);
 1019e2c:	4e31      	ldr	r6, [pc, #196]	; (1019ef4 <lp_cu_send_conn_param_req.constprop.0+0xcc>)
 1019e2e:	4604      	mov	r4, r0
 1019e30:	6833      	ldr	r3, [r6, #0]
 1019e32:	460d      	mov	r5, r1
 1019e34:	b12b      	cbz	r3, 1019e42 <lp_cu_send_conn_param_req.constprop.0+0x1a>
 1019e36:	4283      	cmp	r3, r0
 1019e38:	d003      	beq.n	1019e42 <lp_cu_send_conn_param_req.constprop.0+0x1a>
		ctx->state = LP_CU_STATE_WAIT_TX_CONN_PARAM_REQ;
 1019e3a:	2301      	movs	r3, #1
 1019e3c:	72ab      	strb	r3, [r5, #10]
}
 1019e3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (cpr_active_is_set(conn) || llcp_lr_ispaused(conn) ||
 1019e42:	4620      	mov	r0, r4
 1019e44:	f7ff faa2 	bl	101938c <llcp_lr_ispaused>
 1019e48:	2800      	cmp	r0, #0
 1019e4a:	d1f6      	bne.n	1019e3a <lp_cu_send_conn_param_req.constprop.0+0x12>
	     llcp_rr_get_collision(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 1019e4c:	4620      	mov	r0, r4
 1019e4e:	f000 fe35 	bl	101aabc <llcp_rr_get_collision>
	if (cpr_active_is_set(conn) || llcp_lr_ispaused(conn) ||
 1019e52:	4607      	mov	r7, r0
 1019e54:	2800      	cmp	r0, #0
 1019e56:	d1f0      	bne.n	1019e3a <lp_cu_send_conn_param_req.constprop.0+0x12>
	     llcp_rr_get_collision(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 1019e58:	4629      	mov	r1, r5
 1019e5a:	4620      	mov	r0, r4
 1019e5c:	f7fe f81c 	bl	1017e98 <llcp_tx_alloc_peek>
 1019e60:	2800      	cmp	r0, #0
 1019e62:	d0ea      	beq.n	1019e3a <lp_cu_send_conn_param_req.constprop.0+0x12>
		uint16_t event_counter = ull_conn_event_counter(conn);
 1019e64:	4620      	mov	r0, r4
 1019e66:	f7fc fdb7 	bl	10169d8 <ull_conn_event_counter>
 1019e6a:	4680      	mov	r8, r0
		llcp_rr_set_incompat(conn, INCOMPAT_RESOLVABLE);
 1019e6c:	2101      	movs	r1, #1
 1019e6e:	4620      	mov	r0, r4
 1019e70:	f000 fe1c 	bl	101aaac <llcp_rr_set_incompat>
	tx = llcp_tx_alloc(conn, ctx);
 1019e74:	4629      	mov	r1, r5
 1019e76:	4620      	mov	r0, r4
		ctx->data.cu.preferred_periodicity = 0U;
 1019e78:	f885 702e 	strb.w	r7, [r5, #46]	; 0x2e
		ctx->data.cu.reference_conn_event_count = event_counter;
 1019e7c:	f8a5 8030 	strh.w	r8, [r5, #48]	; 0x30
	conn_upd_curr = conn;
 1019e80:	6034      	str	r4, [r6, #0]
	tx = llcp_tx_alloc(conn, ctx);
 1019e82:	f7fe f811 	bl	1017ea8 <llcp_tx_alloc>
	LL_ASSERT(tx);
 1019e86:	4606      	mov	r6, r0
 1019e88:	b328      	cbz	r0, 1019ed6 <lp_cu_send_conn_param_req.constprop.0+0xae>
		llcp_pdu_encode_conn_param_req(ctx, pdu);
 1019e8a:	4628      	mov	r0, r5
 1019e8c:	1d31      	adds	r1, r6, #4
 1019e8e:	f7ff fd4f 	bl	1019930 <llcp_pdu_encode_conn_param_req>
	ctx->tx_opcode = pdu->llctrl.opcode;
 1019e92:	79f3      	ldrb	r3, [r6, #7]
	llcp_tx_enqueue(conn, tx);
 1019e94:	4631      	mov	r1, r6
	ctx->tx_opcode = pdu->llctrl.opcode;
 1019e96:	736b      	strb	r3, [r5, #13]
	llcp_tx_enqueue(conn, tx);
 1019e98:	4620      	mov	r0, r4
 1019e9a:	f7fe f823 	bl	1017ee4 <llcp_tx_enqueue>
	if (ctx->proc == PROC_CONN_PARAM_REQ) {
 1019e9e:	7a2b      	ldrb	r3, [r5, #8]
 1019ea0:	2b09      	cmp	r3, #9
 1019ea2:	d014      	beq.n	1019ece <lp_cu_send_conn_param_req.constprop.0+0xa6>
		switch (conn->lll.role) {
 1019ea4:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 1019ea8:	09db      	lsrs	r3, r3, #7
 1019eaa:	d002      	beq.n	1019eb2 <lp_cu_send_conn_param_req.constprop.0+0x8a>
			ctx->state = LP_CU_STATE_WAIT_RX_CONN_UPDATE_IND;
 1019eac:	2304      	movs	r3, #4
 1019eae:	816b      	strh	r3, [r5, #10]
			break;
 1019eb0:	e7c5      	b.n	1019e3e <lp_cu_send_conn_param_req.constprop.0+0x16>
			LL_ASSERT(0);
 1019eb2:	f240 137d 	movw	r3, #381	; 0x17d
 1019eb6:	4a10      	ldr	r2, [pc, #64]	; (1019ef8 <lp_cu_send_conn_param_req.constprop.0+0xd0>)
 1019eb8:	4910      	ldr	r1, [pc, #64]	; (1019efc <lp_cu_send_conn_param_req.constprop.0+0xd4>)
 1019eba:	4811      	ldr	r0, [pc, #68]	; (1019f00 <lp_cu_send_conn_param_req.constprop.0+0xd8>)
 1019ebc:	f00a fe8b 	bl	1024bd6 <assert_print>
 1019ec0:	4040      	eors	r0, r0
 1019ec2:	f380 8811 	msr	BASEPRI, r0
 1019ec6:	f04f 0003 	mov.w	r0, #3
 1019eca:	df02      	svc	2
}
 1019ecc:	e7b7      	b.n	1019e3e <lp_cu_send_conn_param_req.constprop.0+0x16>
		llcp_lr_prt_restart(conn);
 1019ece:	4620      	mov	r0, r4
 1019ed0:	f7ff fa6c 	bl	10193ac <llcp_lr_prt_restart>
 1019ed4:	e7e6      	b.n	1019ea4 <lp_cu_send_conn_param_req.constprop.0+0x7c>
	LL_ASSERT(tx);
 1019ed6:	f44f 7387 	mov.w	r3, #270	; 0x10e
 1019eda:	4a07      	ldr	r2, [pc, #28]	; (1019ef8 <lp_cu_send_conn_param_req.constprop.0+0xd0>)
 1019edc:	4909      	ldr	r1, [pc, #36]	; (1019f04 <lp_cu_send_conn_param_req.constprop.0+0xdc>)
 1019ede:	4808      	ldr	r0, [pc, #32]	; (1019f00 <lp_cu_send_conn_param_req.constprop.0+0xd8>)
 1019ee0:	f00a fe79 	bl	1024bd6 <assert_print>
 1019ee4:	4040      	eors	r0, r0
 1019ee6:	f380 8811 	msr	BASEPRI, r0
 1019eea:	f04f 0003 	mov.w	r0, #3
 1019eee:	df02      	svc	2
 1019ef0:	e7cb      	b.n	1019e8a <lp_cu_send_conn_param_req.constprop.0+0x62>
 1019ef2:	bf00      	nop
 1019ef4:	21007144 	.word	0x21007144
 1019ef8:	0102acd0 	.word	0x0102acd0
 1019efc:	0102a300 	.word	0x0102a300
 1019f00:	0102a278 	.word	0x0102a278
 1019f04:	0102a920 	.word	0x0102a920

01019f08 <rp_cu_send_reject_ext_ind.constprop.0>:

#if defined(CONFIG_BT_CTLR_CONN_PARAM_REQ)
static void rp_cu_send_reject_ext_ind(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt,
 1019f08:	b570      	push	{r4, r5, r6, lr}
 1019f0a:	4606      	mov	r6, r0
 1019f0c:	460c      	mov	r4, r1
				      void *param)
{
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 1019f0e:	f000 fddf 	bl	101aad0 <llcp_rr_ispaused>
 1019f12:	b110      	cbz	r0, 1019f1a <rp_cu_send_reject_ext_ind.constprop.0+0x12>
		ctx->state = RP_CU_STATE_WAIT_TX_REJECT_EXT_IND;
 1019f14:	2306      	movs	r3, #6
 1019f16:	72a3      	strb	r3, [r4, #10]
	} else {
		rp_cu_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND);
		rp_cu_complete(conn, ctx);
	}
}
 1019f18:	bd70      	pop	{r4, r5, r6, pc}
 1019f1a:	4605      	mov	r5, r0
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 1019f1c:	4621      	mov	r1, r4
 1019f1e:	4630      	mov	r0, r6
 1019f20:	f7fd ffba 	bl	1017e98 <llcp_tx_alloc_peek>
 1019f24:	2800      	cmp	r0, #0
 1019f26:	d0f5      	beq.n	1019f14 <rp_cu_send_reject_ext_ind.constprop.0+0xc>
		rp_cu_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND);
 1019f28:	2211      	movs	r2, #17
 1019f2a:	4621      	mov	r1, r4
 1019f2c:	4630      	mov	r0, r6
 1019f2e:	f7ff fedf 	bl	1019cf0 <rp_cu_tx>
	llcp_rr_complete(conn);
 1019f32:	4630      	mov	r0, r6
 1019f34:	f000 fe52 	bl	101abdc <llcp_rr_complete>
	if (ctx->proc == PROC_CONN_PARAM_REQ) {
 1019f38:	7a23      	ldrb	r3, [r4, #8]
 1019f3a:	2b09      	cmp	r3, #9
 1019f3c:	d104      	bne.n	1019f48 <rp_cu_send_reject_ext_ind.constprop.0+0x40>
	if (conn == conn_upd_curr) {
 1019f3e:	4b04      	ldr	r3, [pc, #16]	; (1019f50 <rp_cu_send_reject_ext_ind.constprop.0+0x48>)
 1019f40:	681a      	ldr	r2, [r3, #0]
 1019f42:	4296      	cmp	r6, r2
		conn_upd_curr = NULL;
 1019f44:	bf08      	it	eq
 1019f46:	601d      	streq	r5, [r3, #0]
}
 1019f48:	2300      	movs	r3, #0
		ctx->state = RP_CU_STATE_WAIT_TX_REJECT_EXT_IND;
 1019f4a:	72a3      	strb	r3, [r4, #10]
}
 1019f4c:	bd70      	pop	{r4, r5, r6, pc}
 1019f4e:	bf00      	nop
 1019f50:	21007144 	.word	0x21007144

01019f54 <rp_cu_st_wait_conn_param_req_available.part.0.isra.0>:
		break;
	}
}

#if defined(CONFIG_BT_CTLR_CONN_PARAM_REQ)
static void rp_cu_st_wait_conn_param_req_available(struct ll_conn *conn, struct proc_ctx *ctx,
 1019f54:	b538      	push	{r3, r4, r5, lr}
	return conn_upd_curr && (conn_upd_curr != conn);
 1019f56:	4a1d      	ldr	r2, [pc, #116]	; (1019fcc <rp_cu_st_wait_conn_param_req_available.part.0.isra.0+0x78>)
 1019f58:	4605      	mov	r5, r0
 1019f5a:	6813      	ldr	r3, [r2, #0]
 1019f5c:	460c      	mov	r4, r1
 1019f5e:	b13b      	cbz	r3, 1019f70 <rp_cu_st_wait_conn_param_req_available.part.0.isra.0+0x1c>
 1019f60:	4283      	cmp	r3, r0
 1019f62:	d005      	beq.n	1019f70 <rp_cu_st_wait_conn_param_req_available.part.0.isra.0+0x1c>
	 */
	switch (evt) {
	case RP_CU_EVT_CONN_PARAM_REQ:
	case RP_CU_EVT_RUN:
		if (cpr_active_is_set(conn)) {
			ctx->state = RP_CU_STATE_WAIT_CONN_PARAM_REQ_AVAILABLE;
 1019f64:	2302      	movs	r3, #2
 1019f66:	728b      	strb	r3, [r1, #10]
			if (!llcp_rr_ispaused(conn) && llcp_tx_alloc_peek(conn, ctx)) {
 1019f68:	f000 fdb2 	bl	101aad0 <llcp_rr_ispaused>
 1019f6c:	b1b8      	cbz	r0, 1019f9e <rp_cu_st_wait_conn_param_req_available.part.0.isra.0+0x4a>
		}
	default:
		/* Ignore other evts */
		break;
	}
}
 1019f6e:	bd38      	pop	{r3, r4, r5, pc}
	if ((interval != lll->interval) || (latency != lll->latency) ||
 1019f70:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 1019f72:	8d6b      	ldrh	r3, [r5, #42]	; 0x2a
	conn_upd_curr = conn;
 1019f74:	6015      	str	r5, [r2, #0]
 1019f76:	4299      	cmp	r1, r3
				cu_have_params_changed(conn, ctx->data.cu.interval_max,
 1019f78:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 1019f7a:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
	if ((interval != lll->interval) || (latency != lll->latency) ||
 1019f7c:	d005      	beq.n	1019f8a <rp_cu_st_wait_conn_param_req_available.part.0.isra.0+0x36>
	if (!llcp_ntf_alloc_is_available()) {
 1019f7e:	f7fd ff9f 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 1019f82:	b9d8      	cbnz	r0, 1019fbc <rp_cu_st_wait_conn_param_req_available.part.0.isra.0+0x68>
		ctx->state = RP_CU_STATE_WAIT_NTF_CONN_PARAM_REQ;
 1019f84:	2303      	movs	r3, #3
 1019f86:	72a3      	strb	r3, [r4, #10]
}
 1019f88:	bd38      	pop	{r3, r4, r5, pc}
	if ((interval != lll->interval) || (latency != lll->latency) ||
 1019f8a:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
 1019f8c:	4293      	cmp	r3, r2
 1019f8e:	d1f6      	bne.n	1019f7e <rp_cu_st_wait_conn_param_req_available.part.0.isra.0+0x2a>
 1019f90:	f8b5 3184 	ldrh.w	r3, [r5, #388]	; 0x184
 1019f94:	4283      	cmp	r3, r0
 1019f96:	d1f2      	bne.n	1019f7e <rp_cu_st_wait_conn_param_req_available.part.0.isra.0+0x2a>
				ctx->state = RP_CU_STATE_WAIT_CONN_PARAM_REQ_REPLY_CONTINUE;
 1019f98:	2305      	movs	r3, #5
 1019f9a:	72a3      	strb	r3, [r4, #10]
}
 1019f9c:	bd38      	pop	{r3, r4, r5, pc}
			if (!llcp_rr_ispaused(conn) && llcp_tx_alloc_peek(conn, ctx)) {
 1019f9e:	4621      	mov	r1, r4
 1019fa0:	4628      	mov	r0, r5
 1019fa2:	f7fd ff79 	bl	1017e98 <llcp_tx_alloc_peek>
 1019fa6:	2800      	cmp	r0, #0
 1019fa8:	d0e1      	beq.n	1019f6e <rp_cu_st_wait_conn_param_req_available.part.0.isra.0+0x1a>
				ctx->data.cu.error = BT_HCI_ERR_UNSUPP_LL_PARAM_VAL;
 1019faa:	f44f 6372 	mov.w	r3, #3872	; 0xf20
 1019fae:	83a3      	strh	r3, [r4, #28]
				rp_cu_send_reject_ext_ind(conn, ctx, evt, param);
 1019fb0:	4621      	mov	r1, r4
 1019fb2:	4628      	mov	r0, r5
}
 1019fb4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				rp_cu_send_reject_ext_ind(conn, ctx, evt, param);
 1019fb8:	f7ff bfa6 	b.w	1019f08 <rp_cu_send_reject_ext_ind.constprop.0>
		rp_cu_conn_param_req_ntf(conn, ctx);
 1019fbc:	4621      	mov	r1, r4
 1019fbe:	4628      	mov	r0, r5
 1019fc0:	f7ff fe46 	bl	1019c50 <rp_cu_conn_param_req_ntf>
		ctx->state = RP_CU_STATE_WAIT_CONN_PARAM_REQ_REPLY;
 1019fc4:	2304      	movs	r3, #4
 1019fc6:	72a3      	strb	r3, [r4, #10]
}
 1019fc8:	bd38      	pop	{r3, r4, r5, pc}
 1019fca:	bf00      	nop
 1019fcc:	21007144 	.word	0x21007144

01019fd0 <rp_cu_check_instant.isra.0>:
		/* Ignore other evts */
		break;
	}
}

static void rp_cu_check_instant(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt,
 1019fd0:	b538      	push	{r3, r4, r5, lr}
 1019fd2:	460c      	mov	r4, r1
 1019fd4:	4605      	mov	r5, r0
				void *param)
{
	uint16_t event_counter = ull_conn_event_counter(conn);
 1019fd6:	f7fc fcff 	bl	10169d8 <ull_conn_event_counter>

	if (is_instant_reached_or_passed(ctx->data.cu.instant, event_counter)) {
 1019fda:	8c23      	ldrh	r3, [r4, #32]
 1019fdc:	1ac3      	subs	r3, r0, r3
 1019fde:	041b      	lsls	r3, r3, #16
 1019fe0:	d500      	bpl.n	1019fe4 <rp_cu_check_instant.isra.0+0x14>
			rp_cu_wait_complete(conn, ctx, evt, param);
		} else {
			rp_cu_complete(conn, ctx);
		}
	}
}
 1019fe2:	bd38      	pop	{r3, r4, r5, pc}
		cu_update_conn_parameters(conn, ctx);
 1019fe4:	4621      	mov	r1, r4
 1019fe6:	4628      	mov	r0, r5
 1019fe8:	f7ff fe5c 	bl	1019ca4 <cu_update_conn_parameters>
		if (ctx->proc == PROC_CONN_PARAM_REQ) {
 1019fec:	7a23      	ldrb	r3, [r4, #8]
 1019fee:	2b09      	cmp	r3, #9
 1019ff0:	d01d      	beq.n	101a02e <rp_cu_check_instant.isra.0+0x5e>
	return (((ctx->proc == PROC_CONN_PARAM_REQ) && (ctx->data.cu.error != 0U)) ||
 1019ff2:	7fa3      	ldrb	r3, [r4, #30]
 1019ff4:	b15b      	cbz	r3, 101a00e <rp_cu_check_instant.isra.0+0x3e>
			ctx->data.cu.error = BT_HCI_ERR_SUCCESS;
 1019ff6:	2300      	movs	r3, #0
 1019ff8:	7723      	strb	r3, [r4, #28]
	if (!llcp_ntf_alloc_is_available()) {
 1019ffa:	f7fd ff61 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 1019ffe:	b910      	cbnz	r0, 101a006 <rp_cu_check_instant.isra.0+0x36>
		ctx->state = RP_CU_STATE_WAIT_NTF;
 101a000:	230c      	movs	r3, #12
 101a002:	72a3      	strb	r3, [r4, #10]
}
 101a004:	bd38      	pop	{r3, r4, r5, pc}
		cu_ntf(conn, ctx);
 101a006:	4621      	mov	r1, r4
 101a008:	4628      	mov	r0, r5
 101a00a:	f7ff fded 	bl	1019be8 <cu_ntf>
	llcp_rr_complete(conn);
 101a00e:	4628      	mov	r0, r5
 101a010:	f000 fde4 	bl	101abdc <llcp_rr_complete>
	if (ctx->proc == PROC_CONN_PARAM_REQ) {
 101a014:	7a23      	ldrb	r3, [r4, #8]
 101a016:	2b09      	cmp	r3, #9
 101a018:	d002      	beq.n	101a020 <rp_cu_check_instant.isra.0+0x50>
	ctx->state = RP_CU_STATE_IDLE;
 101a01a:	2300      	movs	r3, #0
 101a01c:	72a3      	strb	r3, [r4, #10]
}
 101a01e:	bd38      	pop	{r3, r4, r5, pc}
	if (conn == conn_upd_curr) {
 101a020:	4b08      	ldr	r3, [pc, #32]	; (101a044 <rp_cu_check_instant.isra.0+0x74>)
 101a022:	681a      	ldr	r2, [r3, #0]
 101a024:	4295      	cmp	r5, r2
		conn_upd_curr = NULL;
 101a026:	bf04      	itt	eq
 101a028:	2200      	moveq	r2, #0
 101a02a:	601a      	streq	r2, [r3, #0]
 101a02c:	e7f5      	b.n	101a01a <rp_cu_check_instant.isra.0+0x4a>
			llcp_rr_prt_stop(conn);
 101a02e:	4628      	mov	r0, r5
 101a030:	f000 fd5c 	bl	101aaec <llcp_rr_prt_stop>
	return (((ctx->proc == PROC_CONN_PARAM_REQ) && (ctx->data.cu.error != 0U)) ||
 101a034:	7a23      	ldrb	r3, [r4, #8]
 101a036:	2b09      	cmp	r3, #9
 101a038:	d1db      	bne.n	1019ff2 <rp_cu_check_instant.isra.0+0x22>
 101a03a:	7f23      	ldrb	r3, [r4, #28]
 101a03c:	2b00      	cmp	r3, #0
 101a03e:	d1da      	bne.n	1019ff6 <rp_cu_check_instant.isra.0+0x26>
 101a040:	e7d7      	b.n	1019ff2 <rp_cu_check_instant.isra.0+0x22>
 101a042:	bf00      	nop
 101a044:	21007144 	.word	0x21007144

0101a048 <rp_cu_execute_fsm>:
		break;
	}
}

static void rp_cu_execute_fsm(struct ll_conn *conn, struct proc_ctx *ctx, uint8_t evt, void *param)
{
 101a048:	b570      	push	{r4, r5, r6, lr}
 101a04a:	460c      	mov	r4, r1
	switch (ctx->state) {
 101a04c:	7a89      	ldrb	r1, [r1, #10]
{
 101a04e:	4605      	mov	r5, r0
	switch (ctx->state) {
 101a050:	290c      	cmp	r1, #12
 101a052:	f200 80a9 	bhi.w	101a1a8 <rp_cu_execute_fsm+0x160>
 101a056:	e8df f001 	tbb	[pc, r1]
 101a05a:	170b      	.short	0x170b
 101a05c:	61584e46 	.word	0x61584e46
 101a060:	8379a771 	.word	0x8379a771
 101a064:	9e8b      	.short	0x9e8b
 101a066:	07          	.byte	0x07
 101a067:	00          	.byte	0x00
	switch (evt) {
 101a068:	2a00      	cmp	r2, #0
 101a06a:	f000 80ab 	beq.w	101a1c4 <rp_cu_execute_fsm+0x17c>
	default:
		/* Unknown state */
		LL_ASSERT(0);
		break;
	}
}
 101a06e:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 101a070:	2a00      	cmp	r2, #0
 101a072:	d1fc      	bne.n	101a06e <rp_cu_execute_fsm+0x26>
		switch (ctx->proc) {
 101a074:	7a23      	ldrb	r3, [r4, #8]
 101a076:	2b08      	cmp	r3, #8
 101a078:	f000 80b0 	beq.w	101a1dc <rp_cu_execute_fsm+0x194>
 101a07c:	2b09      	cmp	r3, #9
 101a07e:	f040 80aa 	bne.w	101a1d6 <rp_cu_execute_fsm+0x18e>
			ctx->state = RP_CU_STATE_WAIT_RX_CONN_PARAM_REQ;
 101a082:	2301      	movs	r3, #1
 101a084:	72a3      	strb	r3, [r4, #10]
}
 101a086:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 101a088:	2a01      	cmp	r2, #1
 101a08a:	d1f0      	bne.n	101a06e <rp_cu_execute_fsm+0x26>
		llcp_pdu_decode_conn_param_req(ctx, param);
 101a08c:	4619      	mov	r1, r3
 101a08e:	4620      	mov	r0, r4
 101a090:	f7ff fca6 	bl	10199e0 <llcp_pdu_decode_conn_param_req>
	const uint16_t interval_min = ctx->data.cu.interval_min;
 101a094:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
	const uint16_t interval_max = ctx->data.cu.interval_max; /* unit conn events (ie 1.25ms) */
 101a096:	8d22      	ldrh	r2, [r4, #40]	; 0x28
	     ((latency + 1) * interval_max)) ||
 101a098:	2b05      	cmp	r3, #5
	const uint16_t timeout = ctx->data.cu.timeout; /* unit 10ms */
 101a09a:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
	const uint16_t latency = ctx->data.cu.latency;
 101a09c:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
	const uint16_t preferred_periodicity = ctx->data.cu.preferred_periodicity;
 101a09e:	f894 602e 	ldrb.w	r6, [r4, #46]	; 0x2e
	     ((latency + 1) * interval_max)) ||
 101a0a2:	d917      	bls.n	101a0d4 <rp_cu_execute_fsm+0x8c>
	const bool invalid = ((interval_min < CONN_INTERVAL_MIN(conn)) ||
 101a0a4:	f5b2 6f48 	cmp.w	r2, #3200	; 0xc80
 101a0a8:	d814      	bhi.n	101a0d4 <rp_cu_execute_fsm+0x8c>
	    (interval_max > CONN_UPDATE_CONN_INTV_4SEC) ||
 101a0aa:	4293      	cmp	r3, r2
 101a0ac:	d812      	bhi.n	101a0d4 <rp_cu_execute_fsm+0x8c>
	    (interval_min > interval_max) ||
 101a0ae:	f5b1 7ffa 	cmp.w	r1, #500	; 0x1f4
 101a0b2:	d20f      	bcs.n	101a0d4 <rp_cu_execute_fsm+0x8c>
	    (latency > CONN_UPDATE_LATENCY_MAX) ||
 101a0b4:	f640 4c76 	movw	ip, #3190	; 0xc76
 101a0b8:	f1a0 030a 	sub.w	r3, r0, #10
 101a0bc:	b29b      	uxth	r3, r3
 101a0be:	4563      	cmp	r3, ip
 101a0c0:	d808      	bhi.n	101a0d4 <rp_cu_execute_fsm+0x8c>
	     ((latency + 1) * interval_max)) ||
 101a0c2:	1c4b      	adds	r3, r1, #1
 101a0c4:	b29b      	uxth	r3, r3
 101a0c6:	fb02 f303 	mul.w	r3, r2, r3
	    (timeout < CONN_UPDATE_TIMEOUT_100MS) || (timeout > CONN_UPDATE_TIMEOUT_32SEC) ||
 101a0ca:	ebb3 0f80 	cmp.w	r3, r0, lsl #2
 101a0ce:	d201      	bcs.n	101a0d4 <rp_cu_execute_fsm+0x8c>
	     ((latency + 1) * interval_max)) ||
 101a0d0:	42b2      	cmp	r2, r6
 101a0d2:	d20a      	bcs.n	101a0ea <rp_cu_execute_fsm+0xa2>
			ctx->data.cu.error = BT_HCI_ERR_INVALID_LL_PARAM;
 101a0d4:	f640 731e 	movw	r3, #3870	; 0xf1e
 101a0d8:	83a3      	strh	r3, [r4, #28]
			rp_cu_send_reject_ext_ind(conn, ctx, evt, param);
 101a0da:	4621      	mov	r1, r4
 101a0dc:	4628      	mov	r0, r5
}
 101a0de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			rp_cu_send_reject_ext_ind(conn, ctx, evt, param);
 101a0e2:	f7ff bf11 	b.w	1019f08 <rp_cu_send_reject_ext_ind.constprop.0>
	switch (evt) {
 101a0e6:	2a01      	cmp	r2, #1
 101a0e8:	d8c1      	bhi.n	101a06e <rp_cu_execute_fsm+0x26>
 101a0ea:	4621      	mov	r1, r4
 101a0ec:	4628      	mov	r0, r5
}
 101a0ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 101a0f2:	f7ff bf2f 	b.w	1019f54 <rp_cu_st_wait_conn_param_req_available.part.0.isra.0>
	switch (evt) {
 101a0f6:	2a00      	cmp	r2, #0
 101a0f8:	d1b9      	bne.n	101a06e <rp_cu_execute_fsm+0x26>
	if (!llcp_ntf_alloc_is_available()) {
 101a0fa:	f7fd fee1 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 101a0fe:	2800      	cmp	r0, #0
 101a100:	f040 8093 	bne.w	101a22a <rp_cu_execute_fsm+0x1e2>
		ctx->state = RP_CU_STATE_WAIT_NTF_CONN_PARAM_REQ;
 101a104:	2303      	movs	r3, #3
 101a106:	72a3      	strb	r3, [r4, #10]
}
 101a108:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 101a10a:	2a03      	cmp	r2, #3
 101a10c:	d060      	beq.n	101a1d0 <rp_cu_execute_fsm+0x188>
 101a10e:	2a04      	cmp	r2, #4
 101a110:	d1ad      	bne.n	101a06e <rp_cu_execute_fsm+0x26>
		ctx->data.cu.rejected_opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 101a112:	220f      	movs	r2, #15
		ctx->state = RP_CU_STATE_WAIT_TX_REJECT_EXT_IND;
 101a114:	2306      	movs	r3, #6
		ctx->data.cu.rejected_opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 101a116:	7762      	strb	r2, [r4, #29]
		ctx->state = RP_CU_STATE_WAIT_TX_REJECT_EXT_IND;
 101a118:	72a3      	strb	r3, [r4, #10]
}
 101a11a:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 101a11c:	2a00      	cmp	r2, #0
 101a11e:	d1a6      	bne.n	101a06e <rp_cu_execute_fsm+0x26>
		if (conn->lll.role == BT_HCI_ROLE_CENTRAL) {
 101a120:	f995 3039 	ldrsb.w	r3, [r5, #57]	; 0x39
 101a124:	2b00      	cmp	r3, #0
 101a126:	da1d      	bge.n	101a164 <rp_cu_execute_fsm+0x11c>
			if (!ctx->data.cu.error) {
 101a128:	7f23      	ldrb	r3, [r4, #28]
 101a12a:	b18b      	cbz	r3, 101a150 <rp_cu_execute_fsm+0x108>
				ctx->data.cu.rejected_opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 101a12c:	230f      	movs	r3, #15
 101a12e:	7763      	strb	r3, [r4, #29]
				rp_cu_send_reject_ext_ind(conn, ctx, evt, param);
 101a130:	4621      	mov	r1, r4
 101a132:	4628      	mov	r0, r5
}
 101a134:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				rp_cu_send_reject_ext_ind(conn, ctx, evt, param);
 101a138:	f7ff bee6 	b.w	1019f08 <rp_cu_send_reject_ext_ind.constprop.0>
	switch (evt) {
 101a13c:	2a00      	cmp	r2, #0
 101a13e:	d196      	bne.n	101a06e <rp_cu_execute_fsm+0x26>
		rp_cu_send_reject_ext_ind(conn, ctx, evt, param);
 101a140:	4621      	mov	r1, r4
 101a142:	4628      	mov	r0, r5
}
 101a144:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		rp_cu_send_reject_ext_ind(conn, ctx, evt, param);
 101a148:	f7ff bede 	b.w	1019f08 <rp_cu_send_reject_ext_ind.constprop.0>
	switch (evt) {
 101a14c:	2a00      	cmp	r2, #0
 101a14e:	d18e      	bne.n	101a06e <rp_cu_execute_fsm+0x26>
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 101a150:	4628      	mov	r0, r5
 101a152:	f000 fcbd 	bl	101aad0 <llcp_rr_ispaused>
 101a156:	2800      	cmp	r0, #0
 101a158:	d043      	beq.n	101a1e2 <rp_cu_execute_fsm+0x19a>
		ctx->state = RP_CU_STATE_WAIT_TX_CONN_PARAM_RSP;
 101a15a:	2308      	movs	r3, #8
 101a15c:	72a3      	strb	r3, [r4, #10]
}
 101a15e:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 101a160:	2a00      	cmp	r2, #0
 101a162:	d184      	bne.n	101a06e <rp_cu_execute_fsm+0x26>
		rp_cu_send_conn_update_ind(conn, ctx, evt, param);
 101a164:	4621      	mov	r1, r4
 101a166:	4628      	mov	r0, r5
}
 101a168:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		rp_cu_send_conn_update_ind(conn, ctx, evt, param);
 101a16c:	f7ff be1c 	b.w	1019da8 <rp_cu_send_conn_update_ind.constprop.0>
	switch (evt) {
 101a170:	2a02      	cmp	r2, #2
 101a172:	f47f af7c 	bne.w	101a06e <rp_cu_execute_fsm+0x26>
		switch (conn->lll.role) {
 101a176:	f895 2039 	ldrb.w	r2, [r5, #57]	; 0x39
 101a17a:	f3c2 11c0 	ubfx	r1, r2, #7, #1
 101a17e:	09d2      	lsrs	r2, r2, #7
 101a180:	d13d      	bne.n	101a1fe <rp_cu_execute_fsm+0x1b6>
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 101a182:	4628      	mov	r0, r5
			ctx->unknown_response.type = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
 101a184:	f884 1048 	strb.w	r1, [r4, #72]	; 0x48
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 101a188:	f000 fca2 	bl	101aad0 <llcp_rr_ispaused>
 101a18c:	2800      	cmp	r0, #0
 101a18e:	d06e      	beq.n	101a26e <rp_cu_execute_fsm+0x226>
		ctx->state = RP_CU_STATE_WAIT_TX_UNKNOWN_RSP;
 101a190:	230d      	movs	r3, #13
 101a192:	72a3      	strb	r3, [r4, #10]
}
 101a194:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 101a196:	2a00      	cmp	r2, #0
 101a198:	f47f af69 	bne.w	101a06e <rp_cu_execute_fsm+0x26>
		rp_cu_check_instant(conn, ctx, evt, param);
 101a19c:	4621      	mov	r1, r4
 101a19e:	4628      	mov	r0, r5
}
 101a1a0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		rp_cu_check_instant(conn, ctx, evt, param);
 101a1a4:	f7ff bf14 	b.w	1019fd0 <rp_cu_check_instant.isra.0>
		LL_ASSERT(0);
 101a1a8:	f240 43a7 	movw	r3, #1191	; 0x4a7
 101a1ac:	4a36      	ldr	r2, [pc, #216]	; (101a288 <rp_cu_execute_fsm+0x240>)
 101a1ae:	4937      	ldr	r1, [pc, #220]	; (101a28c <rp_cu_execute_fsm+0x244>)
 101a1b0:	4837      	ldr	r0, [pc, #220]	; (101a290 <rp_cu_execute_fsm+0x248>)
 101a1b2:	f00a fd10 	bl	1024bd6 <assert_print>
 101a1b6:	4040      	eors	r0, r0
 101a1b8:	f380 8811 	msr	BASEPRI, r0
 101a1bc:	f04f 0003 	mov.w	r0, #3
 101a1c0:	df02      	svc	2
}
 101a1c2:	bd70      	pop	{r4, r5, r6, pc}
	if (!llcp_ntf_alloc_is_available()) {
 101a1c4:	f7fd fe7c 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 101a1c8:	bbb0      	cbnz	r0, 101a238 <rp_cu_execute_fsm+0x1f0>
		ctx->state = RP_CU_STATE_WAIT_NTF;
 101a1ca:	230c      	movs	r3, #12
 101a1cc:	72a3      	strb	r3, [r4, #10]
}
 101a1ce:	bd70      	pop	{r4, r5, r6, pc}
		ctx->state = RP_CU_STATE_WAIT_CONN_PARAM_REQ_REPLY_CONTINUE;
 101a1d0:	2305      	movs	r3, #5
 101a1d2:	72a3      	strb	r3, [r4, #10]
}
 101a1d4:	bd70      	pop	{r4, r5, r6, pc}
			LL_ASSERT(0);
 101a1d6:	f44f 7356 	mov.w	r3, #856	; 0x358
 101a1da:	e7e7      	b.n	101a1ac <rp_cu_execute_fsm+0x164>
			ctx->state = RP_CU_STATE_WAIT_RX_CONN_UPDATE_IND;
 101a1dc:	230a      	movs	r3, #10
 101a1de:	72a3      	strb	r3, [r4, #10]
}
 101a1e0:	bd70      	pop	{r4, r5, r6, pc}
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 101a1e2:	4621      	mov	r1, r4
 101a1e4:	4628      	mov	r0, r5
 101a1e6:	f7fd fe57 	bl	1017e98 <llcp_tx_alloc_peek>
 101a1ea:	2800      	cmp	r0, #0
 101a1ec:	d0b5      	beq.n	101a15a <rp_cu_execute_fsm+0x112>
		rp_cu_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP);
 101a1ee:	2210      	movs	r2, #16
 101a1f0:	4621      	mov	r1, r4
 101a1f2:	4628      	mov	r0, r5
 101a1f4:	f7ff fd7c 	bl	1019cf0 <rp_cu_tx>
		ctx->state = RP_CU_STATE_WAIT_RX_CONN_UPDATE_IND;
 101a1f8:	230a      	movs	r3, #10
 101a1fa:	8163      	strh	r3, [r4, #10]
}
 101a1fc:	bd70      	pop	{r4, r5, r6, pc}
			llcp_pdu_decode_conn_update_ind(ctx, param);
 101a1fe:	4619      	mov	r1, r3
 101a200:	4620      	mov	r0, r4
 101a202:	f7ff fc37 	bl	1019a74 <llcp_pdu_decode_conn_update_ind>
			if (is_instant_not_passed(ctx->data.cu.instant,
 101a206:	4628      	mov	r0, r5
 101a208:	8c26      	ldrh	r6, [r4, #32]
 101a20a:	f7fc fbe5 	bl	10169d8 <ull_conn_event_counter>
 101a20e:	f647 72fe 	movw	r2, #32766	; 0x7ffe
 101a212:	1a33      	subs	r3, r6, r0
 101a214:	b29b      	uxth	r3, r3
 101a216:	4293      	cmp	r3, r2
 101a218:	d81b      	bhi.n	101a252 <rp_cu_execute_fsm+0x20a>
				ctx->state = RP_CU_STATE_WAIT_INSTANT;
 101a21a:	230b      	movs	r3, #11
 101a21c:	72a3      	strb	r3, [r4, #10]
				rp_cu_check_instant(conn, ctx, evt, param);
 101a21e:	4621      	mov	r1, r4
 101a220:	4628      	mov	r0, r5
}
 101a222:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				rp_cu_check_instant(conn, ctx, evt, param);
 101a226:	f7ff bed3 	b.w	1019fd0 <rp_cu_check_instant.isra.0>
		rp_cu_conn_param_req_ntf(conn, ctx);
 101a22a:	4621      	mov	r1, r4
 101a22c:	4628      	mov	r0, r5
 101a22e:	f7ff fd0f 	bl	1019c50 <rp_cu_conn_param_req_ntf>
		ctx->state = RP_CU_STATE_WAIT_CONN_PARAM_REQ_REPLY;
 101a232:	2304      	movs	r3, #4
 101a234:	72a3      	strb	r3, [r4, #10]
}
 101a236:	bd70      	pop	{r4, r5, r6, pc}
		cu_ntf(conn, ctx);
 101a238:	4621      	mov	r1, r4
 101a23a:	4628      	mov	r0, r5
 101a23c:	f7ff fcd4 	bl	1019be8 <cu_ntf>
	llcp_rr_complete(conn);
 101a240:	4628      	mov	r0, r5
 101a242:	f000 fccb 	bl	101abdc <llcp_rr_complete>
	if (ctx->proc == PROC_CONN_PARAM_REQ) {
 101a246:	7a23      	ldrb	r3, [r4, #8]
 101a248:	2b09      	cmp	r3, #9
 101a24a:	d009      	beq.n	101a260 <rp_cu_execute_fsm+0x218>
				ctx->state = RP_CU_STATE_IDLE;
 101a24c:	2300      	movs	r3, #0
 101a24e:	72a3      	strb	r3, [r4, #10]
}
 101a250:	bd70      	pop	{r4, r5, r6, pc}
				conn->llcp_terminate.reason_final = BT_HCI_ERR_INSTANT_PASSED;
 101a252:	2328      	movs	r3, #40	; 0x28
				llcp_rr_complete(conn);
 101a254:	4628      	mov	r0, r5
				conn->llcp_terminate.reason_final = BT_HCI_ERR_INSTANT_PASSED;
 101a256:	f885 3148 	strb.w	r3, [r5, #328]	; 0x148
				llcp_rr_complete(conn);
 101a25a:	f000 fcbf 	bl	101abdc <llcp_rr_complete>
 101a25e:	e7f5      	b.n	101a24c <rp_cu_execute_fsm+0x204>
	if (conn == conn_upd_curr) {
 101a260:	4b0c      	ldr	r3, [pc, #48]	; (101a294 <rp_cu_execute_fsm+0x24c>)
 101a262:	681a      	ldr	r2, [r3, #0]
 101a264:	4295      	cmp	r5, r2
 101a266:	d1f1      	bne.n	101a24c <rp_cu_execute_fsm+0x204>
		conn_upd_curr = NULL;
 101a268:	2200      	movs	r2, #0
 101a26a:	601a      	str	r2, [r3, #0]
	ctx->state = RP_CU_STATE_IDLE;
 101a26c:	e7ee      	b.n	101a24c <rp_cu_execute_fsm+0x204>
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 101a26e:	4621      	mov	r1, r4
 101a270:	4628      	mov	r0, r5
 101a272:	f7fd fe11 	bl	1017e98 <llcp_tx_alloc_peek>
 101a276:	2800      	cmp	r0, #0
 101a278:	d08a      	beq.n	101a190 <rp_cu_execute_fsm+0x148>
		rp_cu_tx(conn, ctx, PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP);
 101a27a:	2207      	movs	r2, #7
 101a27c:	4621      	mov	r1, r4
 101a27e:	4628      	mov	r0, r5
 101a280:	f7ff fd36 	bl	1019cf0 <rp_cu_tx>
 101a284:	e7dc      	b.n	101a240 <rp_cu_execute_fsm+0x1f8>
 101a286:	bf00      	nop
 101a288:	0102acd0 	.word	0x0102acd0
 101a28c:	0102a300 	.word	0x0102a300
 101a290:	0102a278 	.word	0x0102a278
 101a294:	21007144 	.word	0x21007144

0101a298 <lp_cu_execute_fsm>:
{
 101a298:	b570      	push	{r4, r5, r6, lr}
 101a29a:	4615      	mov	r5, r2
	switch (ctx->state) {
 101a29c:	7a8a      	ldrb	r2, [r1, #10]
{
 101a29e:	460c      	mov	r4, r1
 101a2a0:	4606      	mov	r6, r0
	switch (ctx->state) {
 101a2a2:	2a07      	cmp	r2, #7
 101a2a4:	d808      	bhi.n	101a2b8 <lp_cu_execute_fsm+0x20>
 101a2a6:	e8df f002 	tbb	[pc, r2]
 101a2aa:	1d15      	.short	0x1d15
 101a2ac:	25550707 	.word	0x25550707
 101a2b0:	042e      	.short	0x042e
	switch (evt) {
 101a2b2:	2d00      	cmp	r5, #0
 101a2b4:	d063      	beq.n	101a37e <lp_cu_execute_fsm+0xe6>
}
 101a2b6:	bd70      	pop	{r4, r5, r6, pc}
		LL_ASSERT(0);
 101a2b8:	f240 2382 	movw	r3, #642	; 0x282
 101a2bc:	4a5c      	ldr	r2, [pc, #368]	; (101a430 <lp_cu_execute_fsm+0x198>)
 101a2be:	495d      	ldr	r1, [pc, #372]	; (101a434 <lp_cu_execute_fsm+0x19c>)
 101a2c0:	485d      	ldr	r0, [pc, #372]	; (101a438 <lp_cu_execute_fsm+0x1a0>)
 101a2c2:	f00a fc88 	bl	1024bd6 <assert_print>
 101a2c6:	4040      	eors	r0, r0
 101a2c8:	f380 8811 	msr	BASEPRI, r0
 101a2cc:	f04f 0003 	mov.w	r0, #3
 101a2d0:	df02      	svc	2
}
 101a2d2:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 101a2d4:	2d00      	cmp	r5, #0
 101a2d6:	d1ee      	bne.n	101a2b6 <lp_cu_execute_fsm+0x1e>
		switch (ctx->proc) {
 101a2d8:	7a23      	ldrb	r3, [r4, #8]
 101a2da:	2b09      	cmp	r3, #9
 101a2dc:	d004      	beq.n	101a2e8 <lp_cu_execute_fsm+0x50>
			LL_ASSERT(0);
 101a2de:	f44f 73d2 	mov.w	r3, #420	; 0x1a4
 101a2e2:	e7eb      	b.n	101a2bc <lp_cu_execute_fsm+0x24>
	switch (evt) {
 101a2e4:	2d00      	cmp	r5, #0
 101a2e6:	d1e6      	bne.n	101a2b6 <lp_cu_execute_fsm+0x1e>
			lp_cu_send_conn_param_req(conn, ctx, evt, param);
 101a2e8:	4621      	mov	r1, r4
 101a2ea:	4630      	mov	r0, r6
}
 101a2ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			lp_cu_send_conn_param_req(conn, ctx, evt, param);
 101a2f0:	f7ff bd9a 	b.w	1019e28 <lp_cu_send_conn_param_req.constprop.0>
	switch (evt) {
 101a2f4:	2d00      	cmp	r5, #0
 101a2f6:	d1de      	bne.n	101a2b6 <lp_cu_execute_fsm+0x1e>
	if (llcp_lr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 101a2f8:	f7ff f848 	bl	101938c <llcp_lr_ispaused>
 101a2fc:	2800      	cmp	r0, #0
 101a2fe:	d057      	beq.n	101a3b0 <lp_cu_execute_fsm+0x118>
		ctx->state = LP_CU_STATE_WAIT_TX_REJECT_EXT_IND;
 101a300:	2305      	movs	r3, #5
 101a302:	72a3      	strb	r3, [r4, #10]
}
 101a304:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 101a306:	2d00      	cmp	r5, #0
 101a308:	d1d5      	bne.n	101a2b6 <lp_cu_execute_fsm+0x1e>
	uint16_t event_counter = ull_conn_event_counter(conn);
 101a30a:	f7fc fb65 	bl	10169d8 <ull_conn_event_counter>
	if (is_instant_reached_or_passed(ctx->data.cu.instant, event_counter)) {
 101a30e:	8c23      	ldrh	r3, [r4, #32]
 101a310:	1ac0      	subs	r0, r0, r3
 101a312:	0403      	lsls	r3, r0, #16
 101a314:	d4cf      	bmi.n	101a2b6 <lp_cu_execute_fsm+0x1e>
		llcp_rr_set_incompat(conn, INCOMPAT_NO_COLLISION);
 101a316:	4629      	mov	r1, r5
 101a318:	4630      	mov	r0, r6
 101a31a:	f000 fbc7 	bl	101aaac <llcp_rr_set_incompat>
		cu_update_conn_parameters(conn, ctx);
 101a31e:	4621      	mov	r1, r4
 101a320:	4630      	mov	r0, r6
 101a322:	f7ff fcbf 	bl	1019ca4 <cu_update_conn_parameters>
		if (ctx->proc == PROC_CONN_PARAM_REQ) {
 101a326:	7a23      	ldrb	r3, [r4, #8]
 101a328:	2b09      	cmp	r3, #9
 101a32a:	d063      	beq.n	101a3f4 <lp_cu_execute_fsm+0x15c>
	return (((ctx->proc == PROC_CONN_PARAM_REQ) && (ctx->data.cu.error != 0U)) ||
 101a32c:	7fa3      	ldrb	r3, [r4, #30]
 101a32e:	b143      	cbz	r3, 101a342 <lp_cu_execute_fsm+0xaa>
			ctx->data.cu.error = BT_HCI_ERR_SUCCESS;
 101a330:	2300      	movs	r3, #0
 101a332:	7723      	strb	r3, [r4, #28]
	if (!llcp_ntf_alloc_is_available()) {
 101a334:	f7fd fdc4 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 101a338:	b328      	cbz	r0, 101a386 <lp_cu_execute_fsm+0xee>
		cu_ntf(conn, ctx);
 101a33a:	4621      	mov	r1, r4
 101a33c:	4630      	mov	r0, r6
 101a33e:	f7ff fc53 	bl	1019be8 <cu_ntf>
	llcp_lr_complete(conn);
 101a342:	4630      	mov	r0, r6
 101a344:	f7ff f8b6 	bl	10194b4 <llcp_lr_complete>
	if (ctx->proc == PROC_CONN_PARAM_REQ &&
 101a348:	7a23      	ldrb	r3, [r4, #8]
 101a34a:	2b09      	cmp	r3, #9
 101a34c:	d025      	beq.n	101a39a <lp_cu_execute_fsm+0x102>
	ctx->state = LP_CU_STATE_IDLE;
 101a34e:	2300      	movs	r3, #0
 101a350:	72a3      	strb	r3, [r4, #10]
}
 101a352:	bd70      	pop	{r4, r5, r6, pc}
	switch (evt) {
 101a354:	2d03      	cmp	r5, #3
 101a356:	d019      	beq.n	101a38c <lp_cu_execute_fsm+0xf4>
 101a358:	2d04      	cmp	r5, #4
 101a35a:	d008      	beq.n	101a36e <lp_cu_execute_fsm+0xd6>
 101a35c:	2d02      	cmp	r5, #2
 101a35e:	d1aa      	bne.n	101a2b6 <lp_cu_execute_fsm+0x1e>
		llcp_pdu_decode_conn_update_ind(ctx, param);
 101a360:	4619      	mov	r1, r3
 101a362:	4620      	mov	r0, r4
 101a364:	f7ff fb86 	bl	1019a74 <llcp_pdu_decode_conn_update_ind>
		ctx->state = LP_CU_STATE_WAIT_INSTANT;
 101a368:	2306      	movs	r3, #6
 101a36a:	72a3      	strb	r3, [r4, #10]
}
 101a36c:	bd70      	pop	{r4, r5, r6, pc}
		ctx->data.cu.error = BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 101a36e:	221a      	movs	r2, #26
 101a370:	f8d0 3130 	ldr.w	r3, [r0, #304]	; 0x130
 101a374:	f023 0302 	bic.w	r3, r3, #2
 101a378:	f8c0 3130 	str.w	r3, [r0, #304]	; 0x130
 101a37c:	7722      	strb	r2, [r4, #28]
	if (!llcp_ntf_alloc_is_available()) {
 101a37e:	f7fd fd9f 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 101a382:	2800      	cmp	r0, #0
 101a384:	d1d9      	bne.n	101a33a <lp_cu_execute_fsm+0xa2>
		ctx->state = LP_CU_STATE_WAIT_NTF;
 101a386:	2307      	movs	r3, #7
 101a388:	72a3      	strb	r3, [r4, #10]
}
 101a38a:	bd70      	pop	{r4, r5, r6, pc}
		ctx->data.cu.error = pdu->llctrl.reject_ext_ind.error_code;
 101a38c:	795b      	ldrb	r3, [r3, #5]
 101a38e:	7723      	strb	r3, [r4, #28]
	if (!llcp_ntf_alloc_is_available()) {
 101a390:	f7fd fd96 	bl	1017ec0 <llcp_ntf_alloc_is_available>
 101a394:	2800      	cmp	r0, #0
 101a396:	d0f6      	beq.n	101a386 <lp_cu_execute_fsm+0xee>
 101a398:	e7cf      	b.n	101a33a <lp_cu_execute_fsm+0xa2>
	if (ctx->proc == PROC_CONN_PARAM_REQ &&
 101a39a:	f996 3039 	ldrsb.w	r3, [r6, #57]	; 0x39
 101a39e:	2b00      	cmp	r3, #0
 101a3a0:	db32      	blt.n	101a408 <lp_cu_execute_fsm+0x170>
	if (conn == conn_upd_curr) {
 101a3a2:	4b26      	ldr	r3, [pc, #152]	; (101a43c <lp_cu_execute_fsm+0x1a4>)
 101a3a4:	681a      	ldr	r2, [r3, #0]
 101a3a6:	4296      	cmp	r6, r2
 101a3a8:	d1d1      	bne.n	101a34e <lp_cu_execute_fsm+0xb6>
		conn_upd_curr = NULL;
 101a3aa:	2200      	movs	r2, #0
 101a3ac:	601a      	str	r2, [r3, #0]
 101a3ae:	e7ce      	b.n	101a34e <lp_cu_execute_fsm+0xb6>
	if (llcp_lr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 101a3b0:	4621      	mov	r1, r4
 101a3b2:	4630      	mov	r0, r6
 101a3b4:	f7fd fd70 	bl	1017e98 <llcp_tx_alloc_peek>
 101a3b8:	2800      	cmp	r0, #0
 101a3ba:	d0a1      	beq.n	101a300 <lp_cu_execute_fsm+0x68>
		llcp_rr_set_incompat(conn, INCOMPAT_NO_COLLISION);
 101a3bc:	4629      	mov	r1, r5
 101a3be:	4630      	mov	r0, r6
 101a3c0:	f000 fb74 	bl	101aaac <llcp_rr_set_incompat>
	tx = llcp_tx_alloc(conn, ctx);
 101a3c4:	4621      	mov	r1, r4
 101a3c6:	4630      	mov	r0, r6
 101a3c8:	f7fd fd6e 	bl	1017ea8 <llcp_tx_alloc>
	LL_ASSERT(tx);
 101a3cc:	4605      	mov	r5, r0
 101a3ce:	b308      	cbz	r0, 101a414 <lp_cu_execute_fsm+0x17c>
		llcp_pdu_encode_reject_ext_ind(pdu, ctx->data.cu.rejected_opcode,
 101a3d0:	7f22      	ldrb	r2, [r4, #28]
 101a3d2:	7f61      	ldrb	r1, [r4, #29]
 101a3d4:	1d28      	adds	r0, r5, #4
 101a3d6:	f7ff fa51 	bl	101987c <llcp_pdu_encode_reject_ext_ind>
	ctx->tx_opcode = pdu->llctrl.opcode;
 101a3da:	79eb      	ldrb	r3, [r5, #7]
	llcp_tx_enqueue(conn, tx);
 101a3dc:	4629      	mov	r1, r5
	ctx->tx_opcode = pdu->llctrl.opcode;
 101a3de:	7363      	strb	r3, [r4, #13]
	llcp_tx_enqueue(conn, tx);
 101a3e0:	4630      	mov	r0, r6
 101a3e2:	f7fd fd7f 	bl	1017ee4 <llcp_tx_enqueue>
	if (ctx->proc == PROC_CONN_PARAM_REQ) {
 101a3e6:	7a23      	ldrb	r3, [r4, #8]
 101a3e8:	2b09      	cmp	r3, #9
 101a3ea:	d1aa      	bne.n	101a342 <lp_cu_execute_fsm+0xaa>
		llcp_lr_prt_restart(conn);
 101a3ec:	4630      	mov	r0, r6
 101a3ee:	f7fe ffdd 	bl	10193ac <llcp_lr_prt_restart>
	llcp_lr_complete(conn);
 101a3f2:	e7a6      	b.n	101a342 <lp_cu_execute_fsm+0xaa>
			llcp_lr_prt_stop(conn);
 101a3f4:	4630      	mov	r0, r6
 101a3f6:	f7fe ffe3 	bl	10193c0 <llcp_lr_prt_stop>
	return (((ctx->proc == PROC_CONN_PARAM_REQ) && (ctx->data.cu.error != 0U)) ||
 101a3fa:	7a23      	ldrb	r3, [r4, #8]
 101a3fc:	2b09      	cmp	r3, #9
 101a3fe:	d195      	bne.n	101a32c <lp_cu_execute_fsm+0x94>
 101a400:	7f23      	ldrb	r3, [r4, #28]
 101a402:	2b00      	cmp	r3, #0
 101a404:	d194      	bne.n	101a330 <lp_cu_execute_fsm+0x98>
 101a406:	e791      	b.n	101a32c <lp_cu_execute_fsm+0x94>
	    !(conn->lll.role && ull_cp_remote_cpr_pending(conn))) {
 101a408:	4630      	mov	r0, r6
 101a40a:	f7fe f863 	bl	10184d4 <ull_cp_remote_cpr_pending>
 101a40e:	2800      	cmp	r0, #0
 101a410:	d0c7      	beq.n	101a3a2 <lp_cu_execute_fsm+0x10a>
 101a412:	e79c      	b.n	101a34e <lp_cu_execute_fsm+0xb6>
	LL_ASSERT(tx);
 101a414:	f44f 7387 	mov.w	r3, #270	; 0x10e
 101a418:	4a05      	ldr	r2, [pc, #20]	; (101a430 <lp_cu_execute_fsm+0x198>)
 101a41a:	4909      	ldr	r1, [pc, #36]	; (101a440 <lp_cu_execute_fsm+0x1a8>)
 101a41c:	4806      	ldr	r0, [pc, #24]	; (101a438 <lp_cu_execute_fsm+0x1a0>)
 101a41e:	f00a fbda 	bl	1024bd6 <assert_print>
 101a422:	4040      	eors	r0, r0
 101a424:	f380 8811 	msr	BASEPRI, r0
 101a428:	f04f 0003 	mov.w	r0, #3
 101a42c:	df02      	svc	2
 101a42e:	e7cf      	b.n	101a3d0 <lp_cu_execute_fsm+0x138>
 101a430:	0102acd0 	.word	0x0102acd0
 101a434:	0102a300 	.word	0x0102a300
 101a438:	0102a278 	.word	0x0102a278
 101a43c:	21007144 	.word	0x21007144
 101a440:	0102a920 	.word	0x0102a920

0101a444 <llcp_lp_cu_rx>:
{
 101a444:	b570      	push	{r4, r5, r6, lr}
 101a446:	460d      	mov	r5, r1
	switch (pdu->llctrl.opcode) {
 101a448:	7fd1      	ldrb	r1, [r2, #31]
{
 101a44a:	4604      	mov	r4, r0
	struct pdu_data *pdu = (struct pdu_data *)rx->pdu;
 101a44c:	f102 031c 	add.w	r3, r2, #28
	switch (pdu->llctrl.opcode) {
 101a450:	2911      	cmp	r1, #17
 101a452:	d80a      	bhi.n	101a46a <llcp_lp_cu_rx+0x26>
 101a454:	e8df f001 	tbb	[pc, r1]
 101a458:	09090926 	.word	0x09090926
 101a45c:	20090909 	.word	0x20090909
 101a460:	09090909 	.word	0x09090909
 101a464:	09090909 	.word	0x09090909
 101a468:	141a      	.short	0x141a
		conn->llcp_terminate.reason_final = BT_HCI_ERR_LMP_PDU_NOT_ALLOWED;
 101a46a:	2324      	movs	r3, #36	; 0x24
 101a46c:	f880 3148 	strb.w	r3, [r0, #328]	; 0x148
	llcp_lr_complete(conn);
 101a470:	f7ff f820 	bl	10194b4 <llcp_lr_complete>
	if (ctx->proc == PROC_CONN_PARAM_REQ &&
 101a474:	7a2b      	ldrb	r3, [r5, #8]
 101a476:	2b09      	cmp	r3, #9
 101a478:	d01a      	beq.n	101a4b0 <llcp_lp_cu_rx+0x6c>
	ctx->state = LP_CU_STATE_IDLE;
 101a47a:	2300      	movs	r3, #0
 101a47c:	72ab      	strb	r3, [r5, #10]
}
 101a47e:	bd70      	pop	{r4, r5, r6, pc}
		lp_cu_execute_fsm(conn, ctx, LP_CU_EVT_REJECT, pdu);
 101a480:	4629      	mov	r1, r5
}
 101a482:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		lp_cu_execute_fsm(conn, ctx, LP_CU_EVT_REJECT, pdu);
 101a486:	2203      	movs	r2, #3
 101a488:	f7ff bf06 	b.w	101a298 <lp_cu_execute_fsm>
		lp_cu_execute_fsm(conn, ctx, LP_CU_EVT_CONN_PARAM_RSP, pdu);
 101a48c:	4629      	mov	r1, r5
}
 101a48e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		lp_cu_execute_fsm(conn, ctx, LP_CU_EVT_CONN_PARAM_RSP, pdu);
 101a492:	2201      	movs	r2, #1
 101a494:	f7ff bf00 	b.w	101a298 <lp_cu_execute_fsm>
		lp_cu_execute_fsm(conn, ctx, LP_CU_EVT_UNKNOWN, pdu);
 101a498:	4629      	mov	r1, r5
}
 101a49a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		lp_cu_execute_fsm(conn, ctx, LP_CU_EVT_UNKNOWN, pdu);
 101a49e:	2204      	movs	r2, #4
 101a4a0:	f7ff befa 	b.w	101a298 <lp_cu_execute_fsm>
		lp_cu_execute_fsm(conn, ctx, LP_CU_EVT_CONN_UPDATE_IND, pdu);
 101a4a4:	4629      	mov	r1, r5
}
 101a4a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		lp_cu_execute_fsm(conn, ctx, LP_CU_EVT_CONN_UPDATE_IND, pdu);
 101a4aa:	2202      	movs	r2, #2
 101a4ac:	f7ff bef4 	b.w	101a298 <lp_cu_execute_fsm>
	if (ctx->proc == PROC_CONN_PARAM_REQ &&
 101a4b0:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
 101a4b4:	2b00      	cmp	r3, #0
 101a4b6:	db06      	blt.n	101a4c6 <llcp_lp_cu_rx+0x82>
	if (conn == conn_upd_curr) {
 101a4b8:	4b06      	ldr	r3, [pc, #24]	; (101a4d4 <llcp_lp_cu_rx+0x90>)
 101a4ba:	681a      	ldr	r2, [r3, #0]
 101a4bc:	4294      	cmp	r4, r2
 101a4be:	d1dc      	bne.n	101a47a <llcp_lp_cu_rx+0x36>
		conn_upd_curr = NULL;
 101a4c0:	2200      	movs	r2, #0
 101a4c2:	601a      	str	r2, [r3, #0]
 101a4c4:	e7d9      	b.n	101a47a <llcp_lp_cu_rx+0x36>
	    !(conn->lll.role && ull_cp_remote_cpr_pending(conn))) {
 101a4c6:	4620      	mov	r0, r4
 101a4c8:	f7fe f804 	bl	10184d4 <ull_cp_remote_cpr_pending>
 101a4cc:	2800      	cmp	r0, #0
 101a4ce:	d0f3      	beq.n	101a4b8 <llcp_lp_cu_rx+0x74>
 101a4d0:	e7d3      	b.n	101a47a <llcp_lp_cu_rx+0x36>
 101a4d2:	bf00      	nop
 101a4d4:	21007144 	.word	0x21007144

0101a4d8 <llcp_lp_cu_init_proc>:
	ctx->state = LP_CU_STATE_IDLE;
 101a4d8:	2300      	movs	r3, #0
 101a4da:	7283      	strb	r3, [r0, #10]
}
 101a4dc:	4770      	bx	lr
 101a4de:	bf00      	nop

0101a4e0 <llcp_lp_cu_run>:
{
 101a4e0:	4613      	mov	r3, r2
	lp_cu_execute_fsm(conn, ctx, LP_CU_EVT_RUN, param);
 101a4e2:	2200      	movs	r2, #0
 101a4e4:	f7ff bed8 	b.w	101a298 <lp_cu_execute_fsm>

0101a4e8 <llcp_rp_cu_rx>:

void llcp_rp_cu_rx(struct ll_conn *conn, struct proc_ctx *ctx, struct node_rx_pdu *rx)
{
 101a4e8:	b570      	push	{r4, r5, r6, lr}
	struct pdu_data *pdu = (struct pdu_data *)rx->pdu;

	switch (pdu->llctrl.opcode) {
 101a4ea:	7fd5      	ldrb	r5, [r2, #31]
	struct pdu_data *pdu = (struct pdu_data *)rx->pdu;
 101a4ec:	f102 031c 	add.w	r3, r2, #28
	switch (pdu->llctrl.opcode) {
 101a4f0:	b135      	cbz	r5, 101a500 <llcp_rp_cu_rx+0x18>
 101a4f2:	2d0f      	cmp	r5, #15
 101a4f4:	d109      	bne.n	101a50a <llcp_rp_cu_rx+0x22>
		/* Invalid PDU received so terminate connection */
		conn->llcp_terminate.reason_final = BT_HCI_ERR_LMP_PDU_NOT_ALLOWED;
		rp_cu_complete(conn, ctx);
		break;
	}
}
 101a4f6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		rp_cu_execute_fsm(conn, ctx, RP_CU_EVT_CONN_PARAM_REQ, pdu);
 101a4fa:	2201      	movs	r2, #1
 101a4fc:	f7ff bda4 	b.w	101a048 <rp_cu_execute_fsm>
		rp_cu_execute_fsm(conn, ctx, RP_CU_EVT_CONN_UPDATE_IND, pdu);
 101a500:	2202      	movs	r2, #2
}
 101a502:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		rp_cu_execute_fsm(conn, ctx, RP_CU_EVT_CONN_UPDATE_IND, pdu);
 101a506:	f7ff bd9f 	b.w	101a048 <rp_cu_execute_fsm>
		conn->llcp_terminate.reason_final = BT_HCI_ERR_LMP_PDU_NOT_ALLOWED;
 101a50a:	2324      	movs	r3, #36	; 0x24
 101a50c:	460e      	mov	r6, r1
 101a50e:	f880 3148 	strb.w	r3, [r0, #328]	; 0x148
		rp_cu_complete(conn, ctx);
 101a512:	4604      	mov	r4, r0
	llcp_rr_complete(conn);
 101a514:	f000 fb62 	bl	101abdc <llcp_rr_complete>
	if (ctx->proc == PROC_CONN_PARAM_REQ) {
 101a518:	7a33      	ldrb	r3, [r6, #8]
 101a51a:	2b09      	cmp	r3, #9
 101a51c:	d105      	bne.n	101a52a <llcp_rp_cu_rx+0x42>
	if (conn == conn_upd_curr) {
 101a51e:	4b04      	ldr	r3, [pc, #16]	; (101a530 <llcp_rp_cu_rx+0x48>)
 101a520:	681a      	ldr	r2, [r3, #0]
 101a522:	4294      	cmp	r4, r2
		conn_upd_curr = NULL;
 101a524:	bf04      	itt	eq
 101a526:	2200      	moveq	r2, #0
 101a528:	601a      	streq	r2, [r3, #0]
	ctx->state = RP_CU_STATE_IDLE;
 101a52a:	2300      	movs	r3, #0
 101a52c:	72b3      	strb	r3, [r6, #10]
}
 101a52e:	bd70      	pop	{r4, r5, r6, pc}
 101a530:	21007144 	.word	0x21007144

0101a534 <llcp_rp_cu_init_proc>:

void llcp_rp_cu_init_proc(struct proc_ctx *ctx)
 101a534:	2300      	movs	r3, #0
 101a536:	7283      	strb	r3, [r0, #10]
 101a538:	4770      	bx	lr
 101a53a:	bf00      	nop

0101a53c <llcp_rp_cu_run>:
{
	ctx->state = RP_CU_STATE_IDLE;
}

void llcp_rp_cu_run(struct ll_conn *conn, struct proc_ctx *ctx, void *param)
{
 101a53c:	4613      	mov	r3, r2
	rp_cu_execute_fsm(conn, ctx, RP_CU_EVT_RUN, param);
 101a53e:	2200      	movs	r2, #0
 101a540:	f7ff bd82 	b.w	101a048 <rp_cu_execute_fsm>

0101a544 <llcp_rp_conn_param_req_reply>:
}

#if defined(CONFIG_BT_CTLR_CONN_PARAM_REQ)
void llcp_rp_conn_param_req_reply(struct ll_conn *conn, struct proc_ctx *ctx)
{
	rp_cu_execute_fsm(conn, ctx, RP_CU_EVT_CONN_PARAM_REQ_REPLY, NULL);
 101a544:	2300      	movs	r3, #0
 101a546:	2203      	movs	r2, #3
 101a548:	f7ff bd7e 	b.w	101a048 <rp_cu_execute_fsm>

0101a54c <llcp_rp_conn_param_req_neg_reply>:
}

void llcp_rp_conn_param_req_neg_reply(struct ll_conn *conn, struct proc_ctx *ctx)
{
	rp_cu_execute_fsm(conn, ctx, RP_CU_EVT_CONN_PARAM_REQ_NEG_REPLY, NULL);
 101a54c:	2300      	movs	r3, #0
 101a54e:	2204      	movs	r2, #4
 101a550:	f7ff bd7a 	b.w	101a048 <rp_cu_execute_fsm>

0101a554 <llcp_rp_chmu_rx>:
		LL_ASSERT(0);
	}
}

void llcp_rp_chmu_rx(struct ll_conn *conn, struct proc_ctx *ctx, struct node_rx_pdu *rx)
{
 101a554:	b570      	push	{r4, r5, r6, lr}
	struct pdu_data *pdu = (struct pdu_data *)rx->pdu;

	switch (pdu->llctrl.opcode) {
 101a556:	7fd3      	ldrb	r3, [r2, #31]
{
 101a558:	4605      	mov	r5, r0
	switch (pdu->llctrl.opcode) {
 101a55a:	2b01      	cmp	r3, #1
{
 101a55c:	460c      	mov	r4, r1
	switch (pdu->llctrl.opcode) {
 101a55e:	d007      	beq.n	101a570 <llcp_rp_chmu_rx+0x1c>
		rp_chmu_execute_fsm(conn, ctx, RP_CHMU_EVT_RX_CHAN_MAP_IND, pdu);
		break;
	default:
		/* Invalid behaviour */
		/* Invalid PDU received so terminate connection */
		conn->llcp_terminate.reason_final = BT_HCI_ERR_LMP_PDU_NOT_ALLOWED;
 101a560:	2324      	movs	r3, #36	; 0x24
 101a562:	f880 3148 	strb.w	r3, [r0, #328]	; 0x148
		llcp_rr_complete(conn);
 101a566:	f000 fb39 	bl	101abdc <llcp_rr_complete>
		ctx->state = RP_CHMU_STATE_IDLE;
 101a56a:	2300      	movs	r3, #0
 101a56c:	72a3      	strb	r3, [r4, #10]
		break;
	}
}
 101a56e:	bd70      	pop	{r4, r5, r6, pc}
	switch (ctx->state) {
 101a570:	7a8b      	ldrb	r3, [r1, #10]
 101a572:	2b01      	cmp	r3, #1
 101a574:	d010      	beq.n	101a598 <llcp_rp_chmu_rx+0x44>
 101a576:	f013 0ffd 	tst.w	r3, #253	; 0xfd
 101a57a:	d0f8      	beq.n	101a56e <llcp_rp_chmu_rx+0x1a>
		LL_ASSERT(0);
 101a57c:	f44f 7392 	mov.w	r3, #292	; 0x124
 101a580:	4a13      	ldr	r2, [pc, #76]	; (101a5d0 <llcp_rp_chmu_rx+0x7c>)
 101a582:	4914      	ldr	r1, [pc, #80]	; (101a5d4 <llcp_rp_chmu_rx+0x80>)
 101a584:	4814      	ldr	r0, [pc, #80]	; (101a5d8 <llcp_rp_chmu_rx+0x84>)
 101a586:	f00a fb26 	bl	1024bd6 <assert_print>
 101a58a:	4040      	eors	r0, r0
 101a58c:	f380 8811 	msr	BASEPRI, r0
 101a590:	f04f 0003 	mov.w	r0, #3
 101a594:	df02      	svc	2
}
 101a596:	bd70      	pop	{r4, r5, r6, pc}
		llcp_pdu_decode_chan_map_update_ind(ctx, param);
 101a598:	4608      	mov	r0, r1
 101a59a:	f102 011c 	add.w	r1, r2, #28
 101a59e:	f7ff fa83 	bl	1019aa8 <llcp_pdu_decode_chan_map_update_ind>
		if (is_instant_not_passed(ctx->data.chmu.instant,
 101a5a2:	4628      	mov	r0, r5
 101a5a4:	8ba6      	ldrh	r6, [r4, #28]
 101a5a6:	f7fc fa17 	bl	10169d8 <ull_conn_event_counter>
 101a5aa:	f647 73fe 	movw	r3, #32766	; 0x7ffe
 101a5ae:	1a36      	subs	r6, r6, r0
 101a5b0:	b2b6      	uxth	r6, r6
 101a5b2:	429e      	cmp	r6, r3
 101a5b4:	d802      	bhi.n	101a5bc <llcp_rp_chmu_rx+0x68>
			ctx->state = RP_CHMU_STATE_WAIT_INSTANT;
 101a5b6:	2302      	movs	r3, #2
 101a5b8:	72a3      	strb	r3, [r4, #10]
}
 101a5ba:	bd70      	pop	{r4, r5, r6, pc}
			conn->llcp_terminate.reason_final = BT_HCI_ERR_INSTANT_PASSED;
 101a5bc:	2328      	movs	r3, #40	; 0x28
			llcp_rr_complete(conn);
 101a5be:	4628      	mov	r0, r5
			conn->llcp_terminate.reason_final = BT_HCI_ERR_INSTANT_PASSED;
 101a5c0:	f885 3148 	strb.w	r3, [r5, #328]	; 0x148
			llcp_rr_complete(conn);
 101a5c4:	f000 fb0a 	bl	101abdc <llcp_rr_complete>
			ctx->state = RP_CHMU_STATE_IDLE;
 101a5c8:	2300      	movs	r3, #0
 101a5ca:	72a3      	strb	r3, [r4, #10]
}
 101a5cc:	bd70      	pop	{r4, r5, r6, pc}
 101a5ce:	bf00      	nop
 101a5d0:	0102ad1c 	.word	0x0102ad1c
 101a5d4:	0102a300 	.word	0x0102a300
 101a5d8:	0102a278 	.word	0x0102a278

0101a5dc <llcp_rp_chmu_init_proc>:

void llcp_rp_chmu_init_proc(struct proc_ctx *ctx)
{
	ctx->state = RP_CHMU_STATE_IDLE;
 101a5dc:	2300      	movs	r3, #0
 101a5de:	7283      	strb	r3, [r0, #10]
}
 101a5e0:	4770      	bx	lr
 101a5e2:	bf00      	nop

0101a5e4 <llcp_rp_chmu_run>:

void llcp_rp_chmu_run(struct ll_conn *conn, struct proc_ctx *ctx, void *param)
{
 101a5e4:	b538      	push	{r3, r4, r5, lr}
	switch (ctx->state) {
 101a5e6:	7a8b      	ldrb	r3, [r1, #10]
 101a5e8:	2b01      	cmp	r3, #1
 101a5ea:	d010      	beq.n	101a60e <llcp_rp_chmu_run+0x2a>
 101a5ec:	2b02      	cmp	r3, #2
 101a5ee:	460c      	mov	r4, r1
 101a5f0:	d00e      	beq.n	101a610 <llcp_rp_chmu_run+0x2c>
 101a5f2:	b1fb      	cbz	r3, 101a634 <llcp_rp_chmu_run+0x50>
		LL_ASSERT(0);
 101a5f4:	f44f 7392 	mov.w	r3, #292	; 0x124
 101a5f8:	4a10      	ldr	r2, [pc, #64]	; (101a63c <llcp_rp_chmu_run+0x58>)
 101a5fa:	4911      	ldr	r1, [pc, #68]	; (101a640 <llcp_rp_chmu_run+0x5c>)
 101a5fc:	4811      	ldr	r0, [pc, #68]	; (101a644 <llcp_rp_chmu_run+0x60>)
 101a5fe:	f00a faea 	bl	1024bd6 <assert_print>
 101a602:	4040      	eors	r0, r0
 101a604:	f380 8811 	msr	BASEPRI, r0
 101a608:	f04f 0003 	mov.w	r0, #3
 101a60c:	df02      	svc	2
	rp_chmu_execute_fsm(conn, ctx, RP_CHMU_EVT_RUN, param);
}
 101a60e:	bd38      	pop	{r3, r4, r5, pc}
	uint16_t event_counter = ull_conn_event_counter(conn);
 101a610:	4605      	mov	r5, r0
 101a612:	f7fc f9e1 	bl	10169d8 <ull_conn_event_counter>
	if (((event_counter - ctx->data.chmu.instant) & 0xFFFF) <= 0x7FFF) {
 101a616:	8ba3      	ldrh	r3, [r4, #28]
 101a618:	1ac0      	subs	r0, r0, r3
 101a61a:	0403      	lsls	r3, r0, #16
 101a61c:	d4f7      	bmi.n	101a60e <llcp_rp_chmu_run+0x2a>
	ull_conn_chan_map_set(conn, ctx->data.chmu.chm);
 101a61e:	4628      	mov	r0, r5
 101a620:	f104 011e 	add.w	r1, r4, #30
 101a624:	f7fc f9e0 	bl	10169e8 <ull_conn_chan_map_set>
	llcp_rr_complete(conn);
 101a628:	4628      	mov	r0, r5
 101a62a:	f000 fad7 	bl	101abdc <llcp_rr_complete>
	ctx->state = RP_CHMU_STATE_IDLE;
 101a62e:	2300      	movs	r3, #0
 101a630:	72a3      	strb	r3, [r4, #10]
}
 101a632:	bd38      	pop	{r3, r4, r5, pc}
		ctx->state = RP_CHMU_STATE_WAIT_RX_CHAN_MAP_IND;
 101a634:	2301      	movs	r3, #1
 101a636:	728b      	strb	r3, [r1, #10]
}
 101a638:	bd38      	pop	{r3, r4, r5, pc}
 101a63a:	bf00      	nop
 101a63c:	0102ad1c 	.word	0x0102ad1c
 101a640:	0102a300 	.word	0x0102a300
 101a644:	0102a278 	.word	0x0102a278

0101a648 <rr_act_disconnect>:
{
	/* Empty on purpose */
}

static void rr_act_disconnect(struct ll_conn *conn)
{
 101a648:	b510      	push	{r4, lr}
 101a64a:	4604      	mov	r4, r0
 101a64c:	f8d0 00f8 	ldr.w	r0, [r0, #248]	; 0xf8
Z_GENLIST_GET(slist, snode)
 101a650:	b170      	cbz	r0, 101a670 <rr_act_disconnect+0x28>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 101a652:	f8d4 20fc 	ldr.w	r2, [r4, #252]	; 0xfc
	return node->next;
 101a656:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 101a658:	4290      	cmp	r0, r2
	list->head = node;
 101a65a:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
	list->tail = node;
 101a65e:	bf08      	it	eq
 101a660:	f8c4 30fc 	streq.w	r3, [r4, #252]	; 0xfc
	 * we may have been disconnected in the
	 * middle of a control procedure, in  which
	 * case we need to release all contexts
	 */
	while (ctx != NULL) {
		llcp_proc_ctx_release(ctx);
 101a664:	f7fd fbf6 	bl	1017e54 <llcp_proc_ctx_release>
	return list->head;
 101a668:	f8d4 00f8 	ldr.w	r0, [r4, #248]	; 0xf8
Z_GENLIST_GET(slist, snode)
 101a66c:	2800      	cmp	r0, #0
 101a66e:	d1f0      	bne.n	101a652 <rr_act_disconnect+0xa>
		ctx = rr_dequeue(conn);
	}
}
 101a670:	bd10      	pop	{r4, pc}
 101a672:	bf00      	nop

0101a674 <rr_check_done.part.0>:
static void rr_check_done(struct ll_conn *conn, struct proc_ctx *ctx)
 101a674:	b538      	push	{r3, r4, r5, lr}
		LL_ASSERT(ctx_header == ctx);
 101a676:	f8d0 30f8 	ldr.w	r3, [r0, #248]	; 0xf8
static void rr_check_done(struct ll_conn *conn, struct proc_ctx *ctx)
 101a67a:	4604      	mov	r4, r0
		LL_ASSERT(ctx_header == ctx);
 101a67c:	428b      	cmp	r3, r1
static void rr_check_done(struct ll_conn *conn, struct proc_ctx *ctx)
 101a67e:	460d      	mov	r5, r1
		LL_ASSERT(ctx_header == ctx);
 101a680:	d01c      	beq.n	101a6bc <rr_check_done.part.0+0x48>
 101a682:	2374      	movs	r3, #116	; 0x74
 101a684:	4a0e      	ldr	r2, [pc, #56]	; (101a6c0 <rr_check_done.part.0+0x4c>)
 101a686:	490f      	ldr	r1, [pc, #60]	; (101a6c4 <rr_check_done.part.0+0x50>)
 101a688:	480f      	ldr	r0, [pc, #60]	; (101a6c8 <rr_check_done.part.0+0x54>)
 101a68a:	f00a faa4 	bl	1024bd6 <assert_print>
 101a68e:	4040      	eors	r0, r0
 101a690:	f380 8811 	msr	BASEPRI, r0
 101a694:	f04f 0003 	mov.w	r0, #3
 101a698:	df02      	svc	2
	return list->head;
 101a69a:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
Z_GENLIST_GET(slist, snode)
 101a69e:	b143      	cbz	r3, 101a6b2 <rr_check_done.part.0+0x3e>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 101a6a0:	f8d4 10fc 	ldr.w	r1, [r4, #252]	; 0xfc
	return node->next;
 101a6a4:	681a      	ldr	r2, [r3, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 101a6a6:	4299      	cmp	r1, r3
	list->head = node;
 101a6a8:	f8c4 20f8 	str.w	r2, [r4, #248]	; 0xf8
	list->tail = node;
 101a6ac:	bf08      	it	eq
 101a6ae:	f8c4 20fc 	streq.w	r2, [r4, #252]	; 0xfc
		llcp_proc_ctx_release(ctx);
 101a6b2:	4628      	mov	r0, r5
}
 101a6b4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		llcp_proc_ctx_release(ctx);
 101a6b8:	f7fd bbcc 	b.w	1017e54 <llcp_proc_ctx_release>
 101a6bc:	460b      	mov	r3, r1
 101a6be:	e7ee      	b.n	101a69e <rr_check_done.part.0+0x2a>
 101a6c0:	0102ad64 	.word	0x0102ad64
 101a6c4:	0102acbc 	.word	0x0102acbc
 101a6c8:	0102a278 	.word	0x0102a278

0101a6cc <rr_act_run>:
{
 101a6cc:	b538      	push	{r3, r4, r5, lr}
	return list->head;
 101a6ce:	f8d0 50f8 	ldr.w	r5, [r0, #248]	; 0xf8
 101a6d2:	4604      	mov	r4, r0
	switch (ctx->proc) {
 101a6d4:	7a2b      	ldrb	r3, [r5, #8]
 101a6d6:	3b01      	subs	r3, #1
 101a6d8:	2b0b      	cmp	r3, #11
 101a6da:	d828      	bhi.n	101a72e <rr_act_run+0x62>
 101a6dc:	e8df f003 	tbb	[pc, r3]
 101a6e0:	06060606 	.word	0x06060606
 101a6e4:	131d1818 	.word	0x131d1818
 101a6e8:	06220613 	.word	0x06220613
		llcp_rp_comm_run(conn, ctx, NULL);
 101a6ec:	2200      	movs	r2, #0
 101a6ee:	4629      	mov	r1, r5
 101a6f0:	f7fe fca0 	bl	1019034 <llcp_rp_comm_run>
	if (ctx->done) {
 101a6f4:	69ab      	ldr	r3, [r5, #24]
 101a6f6:	b12b      	cbz	r3, 101a704 <rr_act_run+0x38>
 101a6f8:	4629      	mov	r1, r5
 101a6fa:	4620      	mov	r0, r4
}
 101a6fc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 101a700:	f7ff bfb8 	b.w	101a674 <rr_check_done.part.0>
 101a704:	bd38      	pop	{r3, r4, r5, pc}
		llcp_rp_cu_run(conn, ctx, NULL);
 101a706:	2200      	movs	r2, #0
 101a708:	4629      	mov	r1, r5
 101a70a:	f7ff ff17 	bl	101a53c <llcp_rp_cu_run>
		break;
 101a70e:	e7f1      	b.n	101a6f4 <rr_act_run+0x28>
		llcp_rp_enc_run(conn, ctx, NULL);
 101a710:	2200      	movs	r2, #0
 101a712:	4629      	mov	r1, r5
 101a714:	f7fd faa4 	bl	1017c60 <llcp_rp_enc_run>
		break;
 101a718:	e7ec      	b.n	101a6f4 <rr_act_run+0x28>
		llcp_rp_pu_run(conn, ctx, NULL);
 101a71a:	2200      	movs	r2, #0
 101a71c:	4629      	mov	r1, r5
 101a71e:	f7fc ffcd 	bl	10176bc <llcp_rp_pu_run>
		break;
 101a722:	e7e7      	b.n	101a6f4 <rr_act_run+0x28>
		llcp_rp_chmu_run(conn, ctx, NULL);
 101a724:	2200      	movs	r2, #0
 101a726:	4629      	mov	r1, r5
 101a728:	f7ff ff5c 	bl	101a5e4 <llcp_rp_chmu_run>
		break;
 101a72c:	e7e2      	b.n	101a6f4 <rr_act_run+0x28>
		LL_ASSERT(0);
 101a72e:	f240 13a1 	movw	r3, #417	; 0x1a1
 101a732:	4a06      	ldr	r2, [pc, #24]	; (101a74c <rr_act_run+0x80>)
 101a734:	4906      	ldr	r1, [pc, #24]	; (101a750 <rr_act_run+0x84>)
 101a736:	4807      	ldr	r0, [pc, #28]	; (101a754 <rr_act_run+0x88>)
 101a738:	f00a fa4d 	bl	1024bd6 <assert_print>
 101a73c:	4040      	eors	r0, r0
 101a73e:	f380 8811 	msr	BASEPRI, r0
 101a742:	f04f 0003 	mov.w	r0, #3
 101a746:	df02      	svc	2
		break;
 101a748:	e7d4      	b.n	101a6f4 <rr_act_run+0x28>
 101a74a:	bf00      	nop
 101a74c:	0102ad64 	.word	0x0102ad64
 101a750:	0102a300 	.word	0x0102a300
 101a754:	0102a278 	.word	0x0102a278

0101a758 <rr_st_active.constprop.0>:
	rr_act_unsupported(conn);
}

static void rr_st_active(struct ll_conn *conn, uint8_t evt, void *param)
{
	switch (evt) {
 101a758:	2902      	cmp	r1, #2
static void rr_st_active(struct ll_conn *conn, uint8_t evt, void *param)
 101a75a:	b538      	push	{r3, r4, r5, lr}
 101a75c:	4605      	mov	r5, r0
	switch (evt) {
 101a75e:	d012      	beq.n	101a786 <rr_st_active.constprop.0+0x2e>
 101a760:	2904      	cmp	r1, #4
 101a762:	460c      	mov	r4, r1
 101a764:	d00a      	beq.n	101a77c <rr_st_active.constprop.0+0x24>
 101a766:	2901      	cmp	r1, #1
 101a768:	d000      	beq.n	101a76c <rr_st_active.constprop.0+0x14>
		break;
	default:
		/* Ignore other evts */
		break;
	}
}
 101a76a:	bd38      	pop	{r3, r4, r5, pc}
		if (llcp_rr_peek(conn)) {
 101a76c:	f8d0 30f8 	ldr.w	r3, [r0, #248]	; 0xf8
 101a770:	2b00      	cmp	r3, #0
 101a772:	d0fa      	beq.n	101a76a <rr_st_active.constprop.0+0x12>
}
 101a774:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			rr_act_run(conn);
 101a778:	f7ff bfa8 	b.w	101a6cc <rr_act_run>
		rr_act_disconnect(conn);
 101a77c:	f7ff ff64 	bl	101a648 <rr_act_disconnect>
	conn->llcp.remote.state = state;
 101a780:	f885 4100 	strb.w	r4, [r5, #256]	; 0x100
}
 101a784:	bd38      	pop	{r3, r4, r5, pc}
	conn->llcp.remote.collision = collision;
 101a786:	2300      	movs	r3, #0
 101a788:	f8d0 40f8 	ldr.w	r4, [r0, #248]	; 0xf8
 101a78c:	f880 3105 	strb.w	r3, [r0, #261]	; 0x105
	LL_ASSERT(ctx != NULL);
 101a790:	b13c      	cbz	r4, 101a7a2 <rr_st_active.constprop.0+0x4a>
	conn->llcp.remote.prt_expire = 0U;
 101a792:	2300      	movs	r3, #0
	ctx->done = 1U;
 101a794:	2201      	movs	r2, #1
	conn->llcp.remote.prt_expire = 0U;
 101a796:	f8a5 3102 	strh.w	r3, [r5, #258]	; 0x102
	ctx->done = 1U;
 101a79a:	61a2      	str	r2, [r4, #24]
	conn->llcp.remote.state = state;
 101a79c:	f885 3100 	strb.w	r3, [r5, #256]	; 0x100
}
 101a7a0:	bd38      	pop	{r3, r4, r5, pc}
	LL_ASSERT(ctx != NULL);
 101a7a2:	f44f 73fe 	mov.w	r3, #508	; 0x1fc
 101a7a6:	4a06      	ldr	r2, [pc, #24]	; (101a7c0 <rr_st_active.constprop.0+0x68>)
 101a7a8:	4906      	ldr	r1, [pc, #24]	; (101a7c4 <rr_st_active.constprop.0+0x6c>)
 101a7aa:	4807      	ldr	r0, [pc, #28]	; (101a7c8 <rr_st_active.constprop.0+0x70>)
 101a7ac:	f00a fa13 	bl	1024bd6 <assert_print>
 101a7b0:	4040      	eors	r0, r0
 101a7b2:	f380 8811 	msr	BASEPRI, r0
 101a7b6:	f04f 0003 	mov.w	r0, #3
 101a7ba:	df02      	svc	2
 101a7bc:	e7e9      	b.n	101a792 <rr_st_active.constprop.0+0x3a>
 101a7be:	bf00      	nop
 101a7c0:	0102ad64 	.word	0x0102ad64
 101a7c4:	0102aca8 	.word	0x0102aca8
 101a7c8:	0102a278 	.word	0x0102a278

0101a7cc <rr_act_unsupported>:
{
 101a7cc:	b570      	push	{r4, r5, r6, lr}
 101a7ce:	f8d0 50f8 	ldr.w	r5, [r0, #248]	; 0xf8
 101a7d2:	4604      	mov	r4, r0
	LL_ASSERT(ctx != NULL);
 101a7d4:	b31d      	cbz	r5, 101a81e <rr_act_unsupported+0x52>
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 101a7d6:	f894 3104 	ldrb.w	r3, [r4, #260]	; 0x104
 101a7da:	2b01      	cmp	r3, #1
 101a7dc:	d103      	bne.n	101a7e6 <rr_act_unsupported+0x1a>
}
 101a7de:	2302      	movs	r3, #2
	conn->llcp.remote.state = state;
 101a7e0:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
}
 101a7e4:	bd70      	pop	{r4, r5, r6, pc}
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 101a7e6:	4629      	mov	r1, r5
 101a7e8:	4620      	mov	r0, r4
 101a7ea:	f7fd fb55 	bl	1017e98 <llcp_tx_alloc_peek>
 101a7ee:	2800      	cmp	r0, #0
 101a7f0:	d0f5      	beq.n	101a7de <rr_act_unsupported+0x12>
	tx = llcp_tx_alloc(conn, ctx);
 101a7f2:	4629      	mov	r1, r5
 101a7f4:	4620      	mov	r0, r4
 101a7f6:	f7fd fb57 	bl	1017ea8 <llcp_tx_alloc>
	LL_ASSERT(tx);
 101a7fa:	4606      	mov	r6, r0
 101a7fc:	b1e8      	cbz	r0, 101a83a <rr_act_unsupported+0x6e>
		llcp_pdu_encode_unknown_rsp(ctx, pdu);
 101a7fe:	4628      	mov	r0, r5
 101a800:	1d31      	adds	r1, r6, #4
 101a802:	f7fe fecf 	bl	10195a4 <llcp_pdu_encode_unknown_rsp>
	ctx->tx_opcode = pdu->llctrl.opcode;
 101a806:	79f3      	ldrb	r3, [r6, #7]
	llcp_tx_enqueue(conn, tx);
 101a808:	4631      	mov	r1, r6
	ctx->tx_opcode = pdu->llctrl.opcode;
 101a80a:	736b      	strb	r3, [r5, #13]
	llcp_tx_enqueue(conn, tx);
 101a80c:	4620      	mov	r0, r4
 101a80e:	f7fd fb69 	bl	1017ee4 <llcp_tx_enqueue>
		ctx->done = 1U;
 101a812:	2201      	movs	r2, #1
}
 101a814:	2300      	movs	r3, #0
		ctx->done = 1U;
 101a816:	61aa      	str	r2, [r5, #24]
	conn->llcp.remote.state = state;
 101a818:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
}
 101a81c:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(ctx != NULL);
 101a81e:	f240 13e9 	movw	r3, #489	; 0x1e9
 101a822:	4a0d      	ldr	r2, [pc, #52]	; (101a858 <rr_act_unsupported+0x8c>)
 101a824:	490d      	ldr	r1, [pc, #52]	; (101a85c <rr_act_unsupported+0x90>)
 101a826:	480e      	ldr	r0, [pc, #56]	; (101a860 <rr_act_unsupported+0x94>)
 101a828:	f00a f9d5 	bl	1024bd6 <assert_print>
 101a82c:	4040      	eors	r0, r0
 101a82e:	f380 8811 	msr	BASEPRI, r0
 101a832:	f04f 0003 	mov.w	r0, #3
 101a836:	df02      	svc	2
 101a838:	e7cd      	b.n	101a7d6 <rr_act_unsupported+0xa>
	LL_ASSERT(tx);
 101a83a:	f240 13b1 	movw	r3, #433	; 0x1b1
 101a83e:	4a06      	ldr	r2, [pc, #24]	; (101a858 <rr_act_unsupported+0x8c>)
 101a840:	4908      	ldr	r1, [pc, #32]	; (101a864 <rr_act_unsupported+0x98>)
 101a842:	4807      	ldr	r0, [pc, #28]	; (101a860 <rr_act_unsupported+0x94>)
 101a844:	f00a f9c7 	bl	1024bd6 <assert_print>
 101a848:	4040      	eors	r0, r0
 101a84a:	f380 8811 	msr	BASEPRI, r0
 101a84e:	f04f 0003 	mov.w	r0, #3
 101a852:	df02      	svc	2
 101a854:	e7d3      	b.n	101a7fe <rr_act_unsupported+0x32>
 101a856:	bf00      	nop
 101a858:	0102ad64 	.word	0x0102ad64
 101a85c:	0102aca8 	.word	0x0102aca8
 101a860:	0102a278 	.word	0x0102a278
 101a864:	0102a920 	.word	0x0102a920

0101a868 <rr_act_reject>:
{
 101a868:	b570      	push	{r4, r5, r6, lr}
 101a86a:	f8d0 50f8 	ldr.w	r5, [r0, #248]	; 0xf8
 101a86e:	4604      	mov	r4, r0
	LL_ASSERT(ctx != NULL);
 101a870:	b3b5      	cbz	r5, 101a8e0 <rr_act_reject+0x78>
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 101a872:	f894 3104 	ldrb.w	r3, [r4, #260]	; 0x104
 101a876:	2b01      	cmp	r3, #1
 101a878:	d103      	bne.n	101a882 <rr_act_reject+0x1a>
}
 101a87a:	2301      	movs	r3, #1
	conn->llcp.remote.state = state;
 101a87c:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
}
 101a880:	bd70      	pop	{r4, r5, r6, pc}
	if (llcp_rr_ispaused(conn) || !llcp_tx_alloc_peek(conn, ctx)) {
 101a882:	4629      	mov	r1, r5
 101a884:	4620      	mov	r0, r4
 101a886:	f7fd fb07 	bl	1017e98 <llcp_tx_alloc_peek>
 101a88a:	2800      	cmp	r0, #0
 101a88c:	d0f5      	beq.n	101a87a <rr_act_reject+0x12>
	tx = llcp_tx_alloc(conn, ctx);
 101a88e:	4629      	mov	r1, r5
 101a890:	4620      	mov	r0, r4
 101a892:	f7fd fb09 	bl	1017ea8 <llcp_tx_alloc>
	LL_ASSERT(tx);
 101a896:	4606      	mov	r6, r0
 101a898:	2800      	cmp	r0, #0
 101a89a:	d03d      	beq.n	101a918 <rr_act_reject+0xb0>
		ctx_local = llcp_lr_peek(conn);
 101a89c:	4620      	mov	r0, r4
 101a89e:	f7fe fca7 	bl	10191f0 <llcp_lr_peek>
		if (ctx_local->proc == ctx->proc ||
 101a8a2:	7a2a      	ldrb	r2, [r5, #8]
 101a8a4:	7a03      	ldrb	r3, [r0, #8]
	pdu = (struct pdu_data *)tx->pdu;
 101a8a6:	f106 0c04 	add.w	ip, r6, #4
		if (ctx_local->proc == ctx->proc ||
 101a8aa:	4293      	cmp	r3, r2
 101a8ac:	d026      	beq.n	101a8fc <rr_act_reject+0x94>
 101a8ae:	2b08      	cmp	r3, #8
 101a8b0:	d026      	beq.n	101a900 <rr_act_reject+0x98>
			reject_code = BT_HCI_ERR_DIFF_TRANS_COLLISION;
 101a8b2:	212a      	movs	r1, #42	; 0x2a
		if (conn->llcp.fex.valid && feature_ext_rej_ind(conn)) {
 101a8b4:	f894 3121 	ldrb.w	r3, [r4, #289]	; 0x121
 101a8b8:	b11b      	cbz	r3, 101a8c2 <rr_act_reject+0x5a>
	return (conn->llcp.fex.features_used & LL_FEAT_BIT_EXT_REJ_IND) != 0;
 101a8ba:	f8d4 3130 	ldr.w	r3, [r4, #304]	; 0x130
 101a8be:	075b      	lsls	r3, r3, #29
 101a8c0:	d423      	bmi.n	101a90a <rr_act_reject+0xa2>
			llcp_pdu_encode_reject_ind(pdu, reject_code);
 101a8c2:	4660      	mov	r0, ip
 101a8c4:	f7fe ffce 	bl	1019864 <llcp_pdu_encode_reject_ind>
	ctx->tx_opcode = pdu->llctrl.opcode;
 101a8c8:	79f3      	ldrb	r3, [r6, #7]
	llcp_tx_enqueue(conn, tx);
 101a8ca:	4631      	mov	r1, r6
	ctx->tx_opcode = pdu->llctrl.opcode;
 101a8cc:	736b      	strb	r3, [r5, #13]
	llcp_tx_enqueue(conn, tx);
 101a8ce:	4620      	mov	r0, r4
 101a8d0:	f7fd fb08 	bl	1017ee4 <llcp_tx_enqueue>
		ctx->done = 1U;
 101a8d4:	2201      	movs	r2, #1
}
 101a8d6:	2300      	movs	r3, #0
		ctx->done = 1U;
 101a8d8:	61aa      	str	r2, [r5, #24]
	conn->llcp.remote.state = state;
 101a8da:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
}
 101a8de:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(ctx != NULL);
 101a8e0:	f240 13d9 	movw	r3, #473	; 0x1d9
 101a8e4:	4a13      	ldr	r2, [pc, #76]	; (101a934 <rr_act_reject+0xcc>)
 101a8e6:	4914      	ldr	r1, [pc, #80]	; (101a938 <rr_act_reject+0xd0>)
 101a8e8:	4814      	ldr	r0, [pc, #80]	; (101a93c <rr_act_reject+0xd4>)
 101a8ea:	f00a f974 	bl	1024bd6 <assert_print>
 101a8ee:	4040      	eors	r0, r0
 101a8f0:	f380 8811 	msr	BASEPRI, r0
 101a8f4:	f04f 0003 	mov.w	r0, #3
 101a8f8:	df02      	svc	2
 101a8fa:	e7ba      	b.n	101a872 <rr_act_reject+0xa>
			reject_code = BT_HCI_ERR_LL_PROC_COLLISION;
 101a8fc:	2123      	movs	r1, #35	; 0x23
 101a8fe:	e7d9      	b.n	101a8b4 <rr_act_reject+0x4c>
 101a900:	2a09      	cmp	r2, #9
 101a902:	bf14      	ite	ne
 101a904:	212a      	movne	r1, #42	; 0x2a
 101a906:	2123      	moveq	r1, #35	; 0x23
 101a908:	e7d4      	b.n	101a8b4 <rr_act_reject+0x4c>
			llcp_pdu_encode_reject_ext_ind(pdu, conn->llcp.remote.reject_opcode,
 101a90a:	460a      	mov	r2, r1
 101a90c:	4660      	mov	r0, ip
 101a90e:	f894 1107 	ldrb.w	r1, [r4, #263]	; 0x107
 101a912:	f7fe ffb3 	bl	101987c <llcp_pdu_encode_reject_ext_ind>
 101a916:	e7d7      	b.n	101a8c8 <rr_act_reject+0x60>
	LL_ASSERT(tx);
 101a918:	f240 13b1 	movw	r3, #433	; 0x1b1
 101a91c:	4a05      	ldr	r2, [pc, #20]	; (101a934 <rr_act_reject+0xcc>)
 101a91e:	4908      	ldr	r1, [pc, #32]	; (101a940 <rr_act_reject+0xd8>)
 101a920:	4806      	ldr	r0, [pc, #24]	; (101a93c <rr_act_reject+0xd4>)
 101a922:	f00a f958 	bl	1024bd6 <assert_print>
 101a926:	4040      	eors	r0, r0
 101a928:	f380 8811 	msr	BASEPRI, r0
 101a92c:	f04f 0003 	mov.w	r0, #3
 101a930:	df02      	svc	2
 101a932:	e7b3      	b.n	101a89c <rr_act_reject+0x34>
 101a934:	0102ad64 	.word	0x0102ad64
 101a938:	0102aca8 	.word	0x0102aca8
 101a93c:	0102a278 	.word	0x0102a278
 101a940:	0102a920 	.word	0x0102a920

0101a944 <rr_execute_fsm>:
		break;
	}
}

static void rr_execute_fsm(struct ll_conn *conn, uint8_t evt, void *param)
{
 101a944:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	switch (conn->llcp.remote.state) {
 101a946:	f890 3100 	ldrb.w	r3, [r0, #256]	; 0x100
{
 101a94a:	4604      	mov	r4, r0
 101a94c:	460e      	mov	r6, r1
 101a94e:	4615      	mov	r5, r2
	switch (conn->llcp.remote.state) {
 101a950:	2b05      	cmp	r3, #5
 101a952:	f200 8094 	bhi.w	101aa7e <rr_execute_fsm+0x13a>
 101a956:	e8df f003 	tbb	[pc, r3]
 101a95a:	160e      	.short	0x160e
 101a95c:	030b0307 	.word	0x030b0307
		break;
	default:
		/* Unknown state */
		LL_ASSERT(0);
	}
}
 101a960:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		rr_st_active(conn, evt, param);
 101a964:	f7ff bef8 	b.w	101a758 <rr_st_active.constprop.0>
}
 101a968:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	rr_act_unsupported(conn);
 101a96c:	f7ff bf2e 	b.w	101a7cc <rr_act_unsupported>
	switch (evt) {
 101a970:	2903      	cmp	r1, #3
 101a972:	d00c      	beq.n	101a98e <rr_execute_fsm+0x4a>
}
 101a974:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	switch (evt) {
 101a976:	b171      	cbz	r1, 101a996 <rr_execute_fsm+0x52>
 101a978:	2904      	cmp	r1, #4
 101a97a:	d1fb      	bne.n	101a974 <rr_execute_fsm+0x30>
		rr_act_disconnect(conn);
 101a97c:	f7ff fe64 	bl	101a648 <rr_act_disconnect>
	conn->llcp.remote.state = state;
 101a980:	f884 6100 	strb.w	r6, [r4, #256]	; 0x100
}
 101a984:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 101a986:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	rr_act_reject(conn);
 101a98a:	f7ff bf6d 	b.w	101a868 <rr_act_reject>
	conn->llcp.remote.state = state;
 101a98e:	2300      	movs	r3, #0
 101a990:	f880 3100 	strb.w	r3, [r0, #256]	; 0x100
}
 101a994:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 101a996:	f8d0 70f8 	ldr.w	r7, [r0, #248]	; 0xf8
		if (ctx) {
 101a99a:	2f00      	cmp	r7, #0
 101a99c:	d0ea      	beq.n	101a974 <rr_execute_fsm+0x30>
	return conn->llcp.remote.incompat;
 101a99e:	7a3b      	ldrb	r3, [r7, #8]
 101a9a0:	f890 c106 	ldrb.w	ip, [r0, #262]	; 0x106
	switch (ctx->proc) {
 101a9a4:	2b10      	cmp	r3, #16
			const bool periph = !!(conn->lll.role == BT_HCI_ROLE_PERIPHERAL);
 101a9a6:	f890 e039 	ldrb.w	lr, [r0, #57]	; 0x39
	switch (ctx->proc) {
 101a9aa:	d811      	bhi.n	101a9d0 <rr_execute_fsm+0x8c>
 101a9ac:	2101      	movs	r1, #1
 101a9ae:	4a3b      	ldr	r2, [pc, #236]	; (101aa9c <rr_execute_fsm+0x158>)
 101a9b0:	fa01 f003 	lsl.w	r0, r1, r3
 101a9b4:	4002      	ands	r2, r0
 101a9b6:	b342      	cbz	r2, 101aa0a <rr_execute_fsm+0xc6>
			if (ctx->proc == PROC_TERMINATE) {
 101a9b8:	2b0a      	cmp	r3, #10
 101a9ba:	d01f      	beq.n	101a9fc <rr_execute_fsm+0xb8>
			} else if (ctx->proc == PROC_UNKNOWN) {
 101a9bc:	b1b3      	cbz	r3, 101a9ec <rr_execute_fsm+0xa8>
				rr_act_run(conn);
 101a9be:	4620      	mov	r0, r4
	conn->llcp.remote.collision = collision;
 101a9c0:	f884 6105 	strb.w	r6, [r4, #261]	; 0x105
				rr_act_run(conn);
 101a9c4:	f7ff fe82 	bl	101a6cc <rr_act_run>
	conn->llcp.remote.state = state;
 101a9c8:	2303      	movs	r3, #3
 101a9ca:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
}
 101a9ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		LL_ASSERT(0);
 101a9d0:	2367      	movs	r3, #103	; 0x67
 101a9d2:	4a33      	ldr	r2, [pc, #204]	; (101aaa0 <rr_execute_fsm+0x15c>)
 101a9d4:	4933      	ldr	r1, [pc, #204]	; (101aaa4 <rr_execute_fsm+0x160>)
 101a9d6:	4834      	ldr	r0, [pc, #208]	; (101aaa8 <rr_execute_fsm+0x164>)
 101a9d8:	f00a f8fd 	bl	1024bd6 <assert_print>
 101a9dc:	4040      	eors	r0, r0
 101a9de:	f380 8811 	msr	BASEPRI, r0
 101a9e2:	f04f 0003 	mov.w	r0, #3
 101a9e6:	df02      	svc	2
			if (ctx->proc == PROC_TERMINATE) {
 101a9e8:	7a3b      	ldrb	r3, [r7, #8]
 101a9ea:	e7e5      	b.n	101a9b8 <rr_execute_fsm+0x74>
				ctx->unknown_response.type = pdu->llctrl.opcode;
 101a9ec:	7feb      	ldrb	r3, [r5, #31]
				rr_act_unsupported(conn);
 101a9ee:	4620      	mov	r0, r4
				ctx->unknown_response.type = pdu->llctrl.opcode;
 101a9f0:	f887 3048 	strb.w	r3, [r7, #72]	; 0x48
}
 101a9f4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				rr_act_unsupported(conn);
 101a9f8:	f7ff bee8 	b.w	101a7cc <rr_act_unsupported>
				rr_act_run(conn);
 101a9fc:	4620      	mov	r0, r4
 101a9fe:	f7ff fe65 	bl	101a6cc <rr_act_run>
	conn->llcp.remote.state = state;
 101aa02:	2305      	movs	r3, #5
 101aa04:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
}
 101aa08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	switch (ctx->proc) {
 101aa0a:	f410 6f38 	tst.w	r0, #2944	; 0xb80
 101aa0e:	d0df      	beq.n	101a9d0 <rr_execute_fsm+0x8c>
			if (ctx->proc == PROC_TERMINATE) {
 101aa10:	2b0a      	cmp	r3, #10
 101aa12:	d0f3      	beq.n	101a9fc <rr_execute_fsm+0xb8>
			} else if (ctx->proc == PROC_UNKNOWN) {
 101aa14:	2b00      	cmp	r3, #0
 101aa16:	d0e9      	beq.n	101a9ec <rr_execute_fsm+0xa8>
			} else if (!with_instant || incompat == INCOMPAT_NO_COLLISION) {
 101aa18:	f1bc 0f00 	cmp.w	ip, #0
 101aa1c:	d101      	bne.n	101aa22 <rr_execute_fsm+0xde>
 101aa1e:	460e      	mov	r6, r1
 101aa20:	e7cd      	b.n	101a9be <rr_execute_fsm+0x7a>
			} else if (periph && incompat == INCOMPAT_RESOLVABLE) {
 101aa22:	f01e 0f80 	tst.w	lr, #128	; 0x80
 101aa26:	d112      	bne.n	101aa4e <rr_execute_fsm+0x10a>
			} else if (central && incompat == INCOMPAT_RESOLVABLE) {
 101aa28:	f1bc 0f01 	cmp.w	ip, #1
 101aa2c:	d019      	beq.n	101aa62 <rr_execute_fsm+0x11e>
			} else if (incompat == INCOMPAT_RESERVED) {
 101aa2e:	f1bc 0f02 	cmp.w	ip, #2
 101aa32:	d19f      	bne.n	101a974 <rr_execute_fsm+0x30>
				ctx_local = llcp_lr_peek(conn);
 101aa34:	4620      	mov	r0, r4
 101aa36:	f7fe fbdb 	bl	10191f0 <llcp_lr_peek>
				if (ctx_local->proc == ctx->proc ||
 101aa3a:	7a3b      	ldrb	r3, [r7, #8]
 101aa3c:	7a02      	ldrb	r2, [r0, #8]
 101aa3e:	429a      	cmp	r2, r3
 101aa40:	d019      	beq.n	101aa76 <rr_execute_fsm+0x132>
 101aa42:	2a08      	cmp	r2, #8
 101aa44:	d015      	beq.n	101aa72 <rr_execute_fsm+0x12e>
					conn->llcp_terminate.reason_final =
 101aa46:	232a      	movs	r3, #42	; 0x2a
 101aa48:	f884 3148 	strb.w	r3, [r4, #328]	; 0x148
}
 101aa4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			} else if (periph && incompat == INCOMPAT_RESOLVABLE) {
 101aa4e:	f1bc 0f01 	cmp.w	ip, #1
 101aa52:	d1ec      	bne.n	101aa2e <rr_execute_fsm+0xea>
				rr_act_run(conn);
 101aa54:	4620      	mov	r0, r4
 101aa56:	f7ff fe39 	bl	101a6cc <rr_act_run>
	conn->llcp.remote.state = state;
 101aa5a:	2303      	movs	r3, #3
 101aa5c:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
}
 101aa60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				conn->llcp.remote.reject_opcode = pdu->llctrl.opcode;
 101aa62:	7feb      	ldrb	r3, [r5, #31]
				rr_act_reject(conn);
 101aa64:	4620      	mov	r0, r4
				conn->llcp.remote.reject_opcode = pdu->llctrl.opcode;
 101aa66:	f884 3107 	strb.w	r3, [r4, #263]	; 0x107
}
 101aa6a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				rr_act_reject(conn);
 101aa6e:	f7ff befb 	b.w	101a868 <rr_act_reject>
				    (ctx_local->proc == PROC_CONN_UPDATE &&
 101aa72:	2b09      	cmp	r3, #9
 101aa74:	d1e7      	bne.n	101aa46 <rr_execute_fsm+0x102>
					conn->llcp_terminate.reason_final =
 101aa76:	2323      	movs	r3, #35	; 0x23
 101aa78:	f884 3148 	strb.w	r3, [r4, #328]	; 0x148
}
 101aa7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		LL_ASSERT(0);
 101aa7e:	f44f 7336 	mov.w	r3, #728	; 0x2d8
 101aa82:	4a07      	ldr	r2, [pc, #28]	; (101aaa0 <rr_execute_fsm+0x15c>)
 101aa84:	4907      	ldr	r1, [pc, #28]	; (101aaa4 <rr_execute_fsm+0x160>)
 101aa86:	4808      	ldr	r0, [pc, #32]	; (101aaa8 <rr_execute_fsm+0x164>)
 101aa88:	f00a f8a5 	bl	1024bd6 <assert_print>
 101aa8c:	4040      	eors	r0, r0
 101aa8e:	f380 8811 	msr	BASEPRI, r0
 101aa92:	f04f 0003 	mov.w	r0, #3
 101aa96:	df02      	svc	2
}
 101aa98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 101aa9a:	bf00      	nop
 101aa9c:	0001f47f 	.word	0x0001f47f
 101aaa0:	0102ad64 	.word	0x0102ad64
 101aaa4:	0102a300 	.word	0x0102a300
 101aaa8:	0102a278 	.word	0x0102a278

0101aaac <llcp_rr_set_incompat>:
	conn->llcp.remote.incompat = incompat;
 101aaac:	f880 1106 	strb.w	r1, [r0, #262]	; 0x106
}
 101aab0:	4770      	bx	lr
 101aab2:	bf00      	nop

0101aab4 <llcp_rr_set_paused_cmd>:
}
 101aab4:	4770      	bx	lr
 101aab6:	bf00      	nop

0101aab8 <llcp_rr_get_paused_cmd>:
}
 101aab8:	2000      	movs	r0, #0
 101aaba:	4770      	bx	lr

0101aabc <llcp_rr_get_collision>:
	return conn->llcp.remote.collision;
 101aabc:	f890 0105 	ldrb.w	r0, [r0, #261]	; 0x105
}
 101aac0:	3800      	subs	r0, #0
 101aac2:	bf18      	it	ne
 101aac4:	2001      	movne	r0, #1
 101aac6:	4770      	bx	lr

0101aac8 <llcp_rr_peek>:
}
 101aac8:	f8d0 00f8 	ldr.w	r0, [r0, #248]	; 0xf8
 101aacc:	4770      	bx	lr
 101aace:	bf00      	nop

0101aad0 <llcp_rr_ispaused>:
	return conn->llcp.remote.pause == 1U;
 101aad0:	f890 0104 	ldrb.w	r0, [r0, #260]	; 0x104
}
 101aad4:	f1a0 0001 	sub.w	r0, r0, #1
 101aad8:	fab0 f080 	clz	r0, r0
 101aadc:	0940      	lsrs	r0, r0, #5
 101aade:	4770      	bx	lr

0101aae0 <llcp_rr_prt_restart>:
	conn->llcp.remote.prt_expire = conn->llcp.prt_reload;
 101aae0:	f8b0 3108 	ldrh.w	r3, [r0, #264]	; 0x108
 101aae4:	f8a0 3102 	strh.w	r3, [r0, #258]	; 0x102
}
 101aae8:	4770      	bx	lr
 101aaea:	bf00      	nop

0101aaec <llcp_rr_prt_stop>:
	conn->llcp.remote.prt_expire = 0U;
 101aaec:	2300      	movs	r3, #0
 101aaee:	f8a0 3102 	strh.w	r3, [r0, #258]	; 0x102
}
 101aaf2:	4770      	bx	lr

0101aaf4 <llcp_rr_rx>:
{
 101aaf4:	b538      	push	{r3, r4, r5, lr}
	switch (ctx->proc) {
 101aaf6:	7a0b      	ldrb	r3, [r1, #8]
{
 101aaf8:	460c      	mov	r4, r1
 101aafa:	4605      	mov	r5, r0
	switch (ctx->proc) {
 101aafc:	2b0c      	cmp	r3, #12
 101aafe:	d824      	bhi.n	101ab4a <llcp_rr_rx+0x56>
 101ab00:	e8df f003 	tbb	[pc, r3]
 101ab04:	0707070a 	.word	0x0707070a
 101ab08:	1b171707 	.word	0x1b171707
 101ab0c:	1f071313 	.word	0x1f071313
 101ab10:	07          	.byte	0x07
 101ab11:	00          	.byte	0x00
		llcp_rp_comm_rx(conn, ctx, rx);
 101ab12:	4621      	mov	r1, r4
 101ab14:	f7fe fa7e 	bl	1019014 <llcp_rp_comm_rx>
	if (ctx->done) {
 101ab18:	69a3      	ldr	r3, [r4, #24]
 101ab1a:	b12b      	cbz	r3, 101ab28 <llcp_rr_rx+0x34>
 101ab1c:	4621      	mov	r1, r4
 101ab1e:	4628      	mov	r0, r5
}
 101ab20:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 101ab24:	f7ff bda6 	b.w	101a674 <rr_check_done.part.0>
 101ab28:	bd38      	pop	{r3, r4, r5, pc}
		llcp_rp_cu_rx(conn, ctx, rx);
 101ab2a:	4621      	mov	r1, r4
 101ab2c:	f7ff fcdc 	bl	101a4e8 <llcp_rp_cu_rx>
		break;
 101ab30:	e7f2      	b.n	101ab18 <llcp_rr_rx+0x24>
		llcp_rp_enc_rx(conn, ctx, rx);
 101ab32:	4621      	mov	r1, r4
 101ab34:	f7fd f844 	bl	1017bc0 <llcp_rp_enc_rx>
		break;
 101ab38:	e7ee      	b.n	101ab18 <llcp_rr_rx+0x24>
		llcp_rp_pu_rx(conn, ctx, rx);
 101ab3a:	4621      	mov	r1, r4
 101ab3c:	f7fc fd9c 	bl	1017678 <llcp_rp_pu_rx>
		break;
 101ab40:	e7ea      	b.n	101ab18 <llcp_rr_rx+0x24>
		llcp_rp_chmu_rx(conn, ctx, rx);
 101ab42:	4621      	mov	r1, r4
 101ab44:	f7ff fd06 	bl	101a554 <llcp_rp_chmu_rx>
		break;
 101ab48:	e7e6      	b.n	101ab18 <llcp_rr_rx+0x24>
		LL_ASSERT(0);
 101ab4a:	f44f 738f 	mov.w	r3, #286	; 0x11e
 101ab4e:	4a06      	ldr	r2, [pc, #24]	; (101ab68 <llcp_rr_rx+0x74>)
 101ab50:	4906      	ldr	r1, [pc, #24]	; (101ab6c <llcp_rr_rx+0x78>)
 101ab52:	4807      	ldr	r0, [pc, #28]	; (101ab70 <llcp_rr_rx+0x7c>)
 101ab54:	f00a f83f 	bl	1024bd6 <assert_print>
 101ab58:	4040      	eors	r0, r0
 101ab5a:	f380 8811 	msr	BASEPRI, r0
 101ab5e:	f04f 0003 	mov.w	r0, #3
 101ab62:	df02      	svc	2
		break;
 101ab64:	e7d8      	b.n	101ab18 <llcp_rr_rx+0x24>
 101ab66:	bf00      	nop
 101ab68:	0102ad64 	.word	0x0102ad64
 101ab6c:	0102a300 	.word	0x0102a300
 101ab70:	0102a278 	.word	0x0102a278

0101ab74 <llcp_rr_tx_ack>:
{
 101ab74:	b538      	push	{r3, r4, r5, lr}
	switch (ctx->proc) {
 101ab76:	7a0b      	ldrb	r3, [r1, #8]
{
 101ab78:	460c      	mov	r4, r1
	switch (ctx->proc) {
 101ab7a:	2b07      	cmp	r3, #7
{
 101ab7c:	4605      	mov	r5, r0
	switch (ctx->proc) {
 101ab7e:	d00c      	beq.n	101ab9a <llcp_rr_tx_ack+0x26>
 101ab80:	2b0c      	cmp	r3, #12
 101ab82:	d101      	bne.n	101ab88 <llcp_rr_tx_ack+0x14>
		llcp_rp_comm_tx_ack(conn, ctx, tx);
 101ab84:	f7fe fa4c 	bl	1019020 <llcp_rp_comm_tx_ack>
	if (ctx->done) {
 101ab88:	69a3      	ldr	r3, [r4, #24]
 101ab8a:	b12b      	cbz	r3, 101ab98 <llcp_rr_tx_ack+0x24>
 101ab8c:	4621      	mov	r1, r4
 101ab8e:	4628      	mov	r0, r5
}
 101ab90:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 101ab94:	f7ff bd6e 	b.w	101a674 <rr_check_done.part.0>
 101ab98:	bd38      	pop	{r3, r4, r5, pc}
		llcp_rp_pu_tx_ack(conn, ctx, tx);
 101ab9a:	f7fc fd93 	bl	10176c4 <llcp_rp_pu_tx_ack>
		break;
 101ab9e:	e7f3      	b.n	101ab88 <llcp_rr_tx_ack+0x14>

0101aba0 <llcp_rr_tx_ntf>:
{
 101aba0:	b538      	push	{r3, r4, r5, lr}
	switch (ctx->proc) {
 101aba2:	7a0b      	ldrb	r3, [r1, #8]
{
 101aba4:	460c      	mov	r4, r1
	switch (ctx->proc) {
 101aba6:	2b07      	cmp	r3, #7
{
 101aba8:	4605      	mov	r5, r0
	switch (ctx->proc) {
 101abaa:	d008      	beq.n	101abbe <llcp_rr_tx_ntf+0x1e>
	if (ctx->done) {
 101abac:	69a3      	ldr	r3, [r4, #24]
 101abae:	b12b      	cbz	r3, 101abbc <llcp_rr_tx_ntf+0x1c>
 101abb0:	4621      	mov	r1, r4
 101abb2:	4628      	mov	r0, r5
}
 101abb4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 101abb8:	f7ff bd5c 	b.w	101a674 <rr_check_done.part.0>
 101abbc:	bd38      	pop	{r3, r4, r5, pc}
		llcp_rp_pu_tx_ntf(conn, ctx);
 101abbe:	f7fc fd85 	bl	10176cc <llcp_rp_pu_tx_ntf>
		break;
 101abc2:	e7f3      	b.n	101abac <llcp_rr_tx_ntf+0xc>

0101abc4 <llcp_rr_init>:
	conn->llcp.remote.state = state;
 101abc4:	2204      	movs	r2, #4

void llcp_rr_init(struct ll_conn *conn)
{
	rr_set_state(conn, RR_STATE_DISCONNECT);
	conn->llcp.remote.prt_expire = 0U;
 101abc6:	2300      	movs	r3, #0
	conn->llcp.remote.state = state;
 101abc8:	f880 2100 	strb.w	r2, [r0, #256]	; 0x100
	conn->llcp.remote.prt_expire = 0U;
 101abcc:	f8a0 3102 	strh.w	r3, [r0, #258]	; 0x102
}
 101abd0:	4770      	bx	lr
 101abd2:	bf00      	nop

0101abd4 <llcp_rr_run>:
	rr_execute_fsm(conn, RR_EVT_PREPARE, rx);
}

void llcp_rr_run(struct ll_conn *conn)
{
	rr_execute_fsm(conn, RR_EVT_RUN, NULL);
 101abd4:	2200      	movs	r2, #0
 101abd6:	2101      	movs	r1, #1
 101abd8:	f7ff beb4 	b.w	101a944 <rr_execute_fsm>

0101abdc <llcp_rr_complete>:
}

void llcp_rr_complete(struct ll_conn *conn)
{
	rr_execute_fsm(conn, RR_EVT_COMPLETE, NULL);
 101abdc:	2200      	movs	r2, #0
 101abde:	2102      	movs	r1, #2
 101abe0:	f7ff beb0 	b.w	101a944 <rr_execute_fsm>

0101abe4 <llcp_rr_connect>:
}

void llcp_rr_connect(struct ll_conn *conn)
{
	rr_execute_fsm(conn, RR_EVT_CONNECT, NULL);
 101abe4:	2200      	movs	r2, #0
 101abe6:	2103      	movs	r1, #3
 101abe8:	f7ff beac 	b.w	101a944 <rr_execute_fsm>

0101abec <llcp_rr_disconnect>:
}

void llcp_rr_disconnect(struct ll_conn *conn)
{
	rr_execute_fsm(conn, RR_EVT_DISCONNECT, NULL);
 101abec:	2200      	movs	r2, #0
 101abee:	2104      	movs	r1, #4
 101abf0:	f7ff bea8 	b.w	101a944 <rr_execute_fsm>

0101abf4 <llcp_rr_new>:
	[PDU_DATA_LLCTRL_TYPE_CLOCK_ACCURACY_REQ] = { PROC_SCA_UPDATE, ACCEPT_ROLE_BOTH },
#endif /* CONFIG_BT_CTLR_SCA_UPDATE */
};

void llcp_rr_new(struct ll_conn *conn, struct node_rx_pdu *rx, bool valid_pdu)
{
 101abf4:	b570      	push	{r4, r5, r6, lr}
 101abf6:	4604      	mov	r4, r0
 101abf8:	460e      	mov	r6, r1
	uint8_t proc = PROC_UNKNOWN;

	pdu = (struct pdu_data *)rx->pdu;

	/* Is this a valid opcode */
	if (valid_pdu && pdu->llctrl.opcode < ARRAY_SIZE(new_proc_lut)) {
 101abfa:	b112      	cbz	r2, 101ac02 <llcp_rr_new+0xe>
 101abfc:	7fcb      	ldrb	r3, [r1, #31]
 101abfe:	2b1b      	cmp	r3, #27
 101ac00:	d923      	bls.n	101ac4a <llcp_rr_new+0x56>
	uint8_t proc = PROC_UNKNOWN;
 101ac02:	2500      	movs	r5, #0

	if (proc == PROC_TERMINATE) {
		rr_abort(conn);
	}

	ctx = llcp_create_remote_procedure(proc);
 101ac04:	4628      	mov	r0, r5
 101ac06:	f7fd f9db 	bl	1017fc0 <llcp_create_remote_procedure>
	if (!ctx) {
 101ac0a:	4605      	mov	r5, r0
 101ac0c:	b1e0      	cbz	r0, 101ac48 <llcp_rr_new+0x54>
	parent->next = child;
 101ac0e:	2300      	movs	r3, #0
 101ac10:	6003      	str	r3, [r0, #0]
	return list->tail;
 101ac12:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
Z_GENLIST_APPEND(slist, snode)
 101ac16:	2b00      	cmp	r3, #0
 101ac18:	d03f      	beq.n	101ac9a <llcp_rr_new+0xa6>
	parent->next = child;
 101ac1a:	6018      	str	r0, [r3, #0]
	list->tail = node;
 101ac1c:	f8c4 00fc 	str.w	r0, [r4, #252]	; 0xfc
	rr_execute_fsm(conn, RR_EVT_PREPARE, rx);
 101ac20:	4632      	mov	r2, r6
 101ac22:	2100      	movs	r1, #0
 101ac24:	4620      	mov	r0, r4
 101ac26:	f7ff fe8d 	bl	101a944 <rr_execute_fsm>
	if (ctx->done) {
 101ac2a:	69ab      	ldr	r3, [r5, #24]
 101ac2c:	b11b      	cbz	r3, 101ac36 <llcp_rr_new+0x42>
 101ac2e:	4629      	mov	r1, r5
 101ac30:	4620      	mov	r0, r4
 101ac32:	f7ff fd1f 	bl	101a674 <rr_check_done.part.0>
	return list->head;
 101ac36:	f8d4 10f8 	ldr.w	r1, [r4, #248]	; 0xf8

	rr_check_done(conn, ctx);

	/* Handle PDU */
	ctx = llcp_rr_peek(conn);
	if (ctx) {
 101ac3a:	b129      	cbz	r1, 101ac48 <llcp_rr_new+0x54>
		llcp_rr_rx(conn, ctx, rx);
 101ac3c:	4632      	mov	r2, r6
 101ac3e:	4620      	mov	r0, r4
	}
}
 101ac40:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		llcp_rr_rx(conn, ctx, rx);
 101ac44:	f7ff bf56 	b.w	101aaf4 <llcp_rr_rx>
}
 101ac48:	bd70      	pop	{r4, r5, r6, pc}
		uint8_t role_mask  = (1 << conn->lll.role);
 101ac4a:	2501      	movs	r5, #1
		struct proc_role pr = new_proc_lut[pdu->llctrl.opcode];
 101ac4c:	4819      	ldr	r0, [pc, #100]	; (101acb4 <llcp_rr_new+0xc0>)
 101ac4e:	eb00 0243 	add.w	r2, r0, r3, lsl #1
		if (pr.accept & role_mask) {
 101ac52:	7851      	ldrb	r1, [r2, #1]
		uint8_t role_mask  = (1 << conn->lll.role);
 101ac54:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 101ac58:	09d2      	lsrs	r2, r2, #7
 101ac5a:	4095      	lsls	r5, r2
		if (pr.accept & role_mask) {
 101ac5c:	400d      	ands	r5, r1
 101ac5e:	d0d1      	beq.n	101ac04 <llcp_rr_new+0x10>
		struct proc_role pr = new_proc_lut[pdu->llctrl.opcode];
 101ac60:	f810 5013 	ldrb.w	r5, [r0, r3, lsl #1]
	if (proc == PROC_TERMINATE) {
 101ac64:	2d0a      	cmp	r5, #10
 101ac66:	d1cd      	bne.n	101ac04 <llcp_rr_new+0x10>
 101ac68:	f8d4 00f8 	ldr.w	r0, [r4, #248]	; 0xf8
Z_GENLIST_GET(slist, snode)
 101ac6c:	b1d0      	cbz	r0, 101aca4 <llcp_rr_new+0xb0>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 101ac6e:	f8d4 20fc 	ldr.w	r2, [r4, #252]	; 0xfc
	return node->next;
 101ac72:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 101ac74:	4290      	cmp	r0, r2
	list->head = node;
 101ac76:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 101ac7a:	d00b      	beq.n	101ac94 <llcp_rr_new+0xa0>
	struct proc_ctx *ctx;

	/* Flush all pending procedures */
	ctx = rr_dequeue(conn);
	while (ctx) {
		llcp_proc_ctx_release(ctx);
 101ac7c:	f7fd f8ea 	bl	1017e54 <llcp_proc_ctx_release>
	return list->head;
 101ac80:	f8d4 00f8 	ldr.w	r0, [r4, #248]	; 0xf8
Z_GENLIST_GET(slist, snode)
 101ac84:	b170      	cbz	r0, 101aca4 <llcp_rr_new+0xb0>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 101ac86:	f8d4 20fc 	ldr.w	r2, [r4, #252]	; 0xfc
	return node->next;
 101ac8a:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 101ac8c:	4290      	cmp	r0, r2
	list->head = node;
 101ac8e:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 101ac92:	d1f3      	bne.n	101ac7c <llcp_rr_new+0x88>
	list->tail = node;
 101ac94:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
}
 101ac98:	e7f0      	b.n	101ac7c <llcp_rr_new+0x88>
	list->head = node;
 101ac9a:	f8c4 00f8 	str.w	r0, [r4, #248]	; 0xf8
 101ac9e:	f8c4 00fc 	str.w	r0, [r4, #252]	; 0xfc
}
 101aca2:	e7bd      	b.n	101ac20 <llcp_rr_new+0x2c>
	conn->llcp.remote.prt_expire = 0U;
 101aca4:	2300      	movs	r3, #0
 101aca6:	f8a4 3102 	strh.w	r3, [r4, #258]	; 0x102
	conn->llcp.remote.collision = collision;
 101acaa:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
	conn->llcp.remote.state = state;
 101acae:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
	}

	llcp_rr_prt_stop(conn);
	rr_set_collision(conn, 0U);
	rr_set_state(conn, RR_STATE_IDLE);
}
 101acb2:	e7a7      	b.n	101ac04 <llcp_rr_new+0x10>
 101acb4:	0102adac 	.word	0x0102adac

0101acb8 <ticker_update_latency_cancel_op_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
}

static void ticker_update_latency_cancel_op_cb(uint32_t ticker_status,
					       void *param)
{
 101acb8:	b510      	push	{r4, lr}
 101acba:	460c      	mov	r4, r1
	struct ll_conn *conn = param;

	LL_ASSERT(ticker_status == TICKER_STATUS_SUCCESS);
 101acbc:	b930      	cbnz	r0, 101accc <ticker_update_latency_cancel_op_cb+0x14>

	conn->periph.latency_cancel = 0U;
 101acbe:	f894 316c 	ldrb.w	r3, [r4, #364]	; 0x16c
 101acc2:	f36f 0300 	bfc	r3, #0, #1
 101acc6:	f884 316c 	strb.w	r3, [r4, #364]	; 0x16c
}
 101acca:	bd10      	pop	{r4, pc}
	LL_ASSERT(ticker_status == TICKER_STATUS_SUCCESS);
 101accc:	f240 23b6 	movw	r3, #694	; 0x2b6
 101acd0:	4a08      	ldr	r2, [pc, #32]	; (101acf4 <ticker_update_latency_cancel_op_cb+0x3c>)
 101acd2:	4909      	ldr	r1, [pc, #36]	; (101acf8 <ticker_update_latency_cancel_op_cb+0x40>)
 101acd4:	4809      	ldr	r0, [pc, #36]	; (101acfc <ticker_update_latency_cancel_op_cb+0x44>)
 101acd6:	f009 ff7e 	bl	1024bd6 <assert_print>
 101acda:	4040      	eors	r0, r0
 101acdc:	f380 8811 	msr	BASEPRI, r0
 101ace0:	f04f 0003 	mov.w	r0, #3
 101ace4:	df02      	svc	2
	conn->periph.latency_cancel = 0U;
 101ace6:	f894 316c 	ldrb.w	r3, [r4, #364]	; 0x16c
 101acea:	f36f 0300 	bfc	r3, #0, #1
 101acee:	f884 316c 	strb.w	r3, [r4, #364]	; 0x16c
}
 101acf2:	bd10      	pop	{r4, pc}
 101acf4:	0102ade4 	.word	0x0102ade4
 101acf8:	0102ae2c 	.word	0x0102ae2c
 101acfc:	0102a278 	.word	0x0102a278

0101ad00 <ticker_op_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 101ad00:	b900      	cbnz	r0, 101ad04 <ticker_op_cb+0x4>
 101ad02:	4770      	bx	lr
{
 101ad04:	b508      	push	{r3, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 101ad06:	4a07      	ldr	r2, [pc, #28]	; (101ad24 <ticker_op_cb+0x24>)
 101ad08:	f240 23ae 	movw	r3, #686	; 0x2ae
 101ad0c:	4906      	ldr	r1, [pc, #24]	; (101ad28 <ticker_op_cb+0x28>)
 101ad0e:	4807      	ldr	r0, [pc, #28]	; (101ad2c <ticker_op_cb+0x2c>)
 101ad10:	f009 ff61 	bl	1024bd6 <assert_print>
 101ad14:	4040      	eors	r0, r0
 101ad16:	f380 8811 	msr	BASEPRI, r0
 101ad1a:	f04f 0003 	mov.w	r0, #3
 101ad1e:	df02      	svc	2
}
 101ad20:	bd08      	pop	{r3, pc}
 101ad22:	bf00      	nop
 101ad24:	0102ade4 	.word	0x0102ade4
 101ad28:	0102a934 	.word	0x0102a934
 101ad2c:	0102a278 	.word	0x0102a278

0101ad30 <ticker_op_stop_adv_cb>:
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 101ad30:	2801      	cmp	r0, #1
 101ad32:	d000      	beq.n	101ad36 <ticker_op_stop_adv_cb+0x6>
 101ad34:	4770      	bx	lr
{
 101ad36:	b510      	push	{r4, lr}
 101ad38:	460c      	mov	r4, r1
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 101ad3a:	f7f9 fbb5 	bl	10144a8 <ull_disable_mark_get>
 101ad3e:	4284      	cmp	r4, r0
 101ad40:	d00c      	beq.n	101ad5c <ticker_op_stop_adv_cb+0x2c>
 101ad42:	f240 23a6 	movw	r3, #678	; 0x2a6
 101ad46:	4a06      	ldr	r2, [pc, #24]	; (101ad60 <ticker_op_stop_adv_cb+0x30>)
 101ad48:	4906      	ldr	r1, [pc, #24]	; (101ad64 <ticker_op_stop_adv_cb+0x34>)
 101ad4a:	4807      	ldr	r0, [pc, #28]	; (101ad68 <ticker_op_stop_adv_cb+0x38>)
 101ad4c:	f009 ff43 	bl	1024bd6 <assert_print>
 101ad50:	4040      	eors	r0, r0
 101ad52:	f380 8811 	msr	BASEPRI, r0
 101ad56:	f04f 0003 	mov.w	r0, #3
 101ad5a:	df02      	svc	2
}
 101ad5c:	bd10      	pop	{r4, pc}
 101ad5e:	bf00      	nop
 101ad60:	0102ade4 	.word	0x0102ade4
 101ad64:	0102ae40 	.word	0x0102ae40
 101ad68:	0102a278 	.word	0x0102a278

0101ad6c <ull_periph_ticker_cb>:
	if (unlikely(conn->lll.handle == 0xFFFF)) {
 101ad6c:	f64f 71ff 	movw	r1, #65535	; 0xffff
{
 101ad70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 101ad74:	9c07      	ldr	r4, [sp, #28]
 101ad76:	f89d 8018 	ldrb.w	r8, [sp, #24]
	if (unlikely(conn->lll.handle == 0xFFFF)) {
 101ad7a:	f8b4 c028 	ldrh.w	ip, [r4, #40]	; 0x28
 101ad7e:	458c      	cmp	ip, r1
 101ad80:	d027      	beq.n	101add2 <ull_periph_ticker_cb+0x66>
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
 101ad82:	4606      	mov	r6, r0
 101ad84:	4617      	mov	r7, r2
 101ad86:	4601      	mov	r1, r0
 101ad88:	461a      	mov	r2, r3
 101ad8a:	4620      	mov	r0, r4
 101ad8c:	461d      	mov	r5, r3
 101ad8e:	f7fb fa33 	bl	10161f8 <ull_conn_llcp>
		if (ret) {
 101ad92:	b9f0      	cbnz	r0, 101add2 <ull_periph_ticker_cb+0x66>
	return ++hdr->ref;
 101ad94:	7823      	ldrb	r3, [r4, #0]
 101ad96:	3301      	adds	r3, #1
 101ad98:	b2db      	uxtb	r3, r3
 101ad9a:	7023      	strb	r3, [r4, #0]
	LL_ASSERT(ref);
 101ad9c:	b34b      	cbz	r3, 101adf2 <ull_periph_ticker_cb+0x86>
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 101ad9e:	2200      	movs	r2, #0
	p.ticks_at_expire = ticks_at_expire;
 101ada0:	491b      	ldr	r1, [pc, #108]	; (101ae10 <ull_periph_ticker_cb+0xa4>)
	mfy.param = &p;
 101ada2:	4b1c      	ldr	r3, [pc, #112]	; (101ae14 <ull_periph_ticker_cb+0xa8>)
	p.param = &conn->lll;
 101ada4:	f104 001c 	add.w	r0, r4, #28
 101ada8:	60c8      	str	r0, [r1, #12]
	p.remainder = remainder;
 101adaa:	e9c1 6700 	strd	r6, r7, [r1]
	p.lazy = lazy;
 101adae:	810d      	strh	r5, [r1, #8]
	p.force = force;
 101adb0:	f881 800a 	strb.w	r8, [r1, #10]
	mfy.param = &p;
 101adb4:	6099      	str	r1, [r3, #8]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 101adb6:	2001      	movs	r0, #1
 101adb8:	4611      	mov	r1, r2
 101adba:	f7f6 f913 	bl	1010fe4 <mayfly_enqueue>
	LL_ASSERT(!err);
 101adbe:	b950      	cbnz	r0, 101add6 <ull_periph_ticker_cb+0x6a>
	ull_conn_tx_demux(UINT8_MAX);
 101adc0:	20ff      	movs	r0, #255	; 0xff
 101adc2:	f7fb fa4b 	bl	101625c <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
 101adc6:	4620      	mov	r0, r4
}
 101adc8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
 101adcc:	21ff      	movs	r1, #255	; 0xff
 101adce:	f7fb bc8f 	b.w	10166f0 <ull_conn_tx_lll_enqueue>
}
 101add2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	LL_ASSERT(!err);
 101add6:	f240 233e 	movw	r3, #574	; 0x23e
 101adda:	4a0f      	ldr	r2, [pc, #60]	; (101ae18 <ull_periph_ticker_cb+0xac>)
 101addc:	490f      	ldr	r1, [pc, #60]	; (101ae1c <ull_periph_ticker_cb+0xb0>)
 101adde:	4810      	ldr	r0, [pc, #64]	; (101ae20 <ull_periph_ticker_cb+0xb4>)
 101ade0:	f009 fef9 	bl	1024bd6 <assert_print>
 101ade4:	4040      	eors	r0, r0
 101ade6:	f380 8811 	msr	BASEPRI, r0
 101adea:	f04f 0003 	mov.w	r0, #3
 101adee:	df02      	svc	2
 101adf0:	e7e6      	b.n	101adc0 <ull_periph_ticker_cb+0x54>
	LL_ASSERT(ref);
 101adf2:	f240 2331 	movw	r3, #561	; 0x231
 101adf6:	4a08      	ldr	r2, [pc, #32]	; (101ae18 <ull_periph_ticker_cb+0xac>)
 101adf8:	490a      	ldr	r1, [pc, #40]	; (101ae24 <ull_periph_ticker_cb+0xb8>)
 101adfa:	4809      	ldr	r0, [pc, #36]	; (101ae20 <ull_periph_ticker_cb+0xb4>)
 101adfc:	f009 feeb 	bl	1024bd6 <assert_print>
 101ae00:	4040      	eors	r0, r0
 101ae02:	f380 8811 	msr	BASEPRI, r0
 101ae06:	f04f 0003 	mov.w	r0, #3
 101ae0a:	df02      	svc	2
 101ae0c:	e7c7      	b.n	101ad9e <ull_periph_ticker_cb+0x32>
 101ae0e:	bf00      	nop
 101ae10:	21007b90 	.word	0x21007b90
 101ae14:	21000994 	.word	0x21000994
 101ae18:	0102ade4 	.word	0x0102ade4
 101ae1c:	0102a594 	.word	0x0102a594
 101ae20:	0102a278 	.word	0x0102a278
 101ae24:	0102a82c 	.word	0x0102a82c

0101ae28 <ull_periph_latency_cancel>:
	if (conn->lll.latency_event && !conn->periph.latency_cancel) {
 101ae28:	8e03      	ldrh	r3, [r0, #48]	; 0x30
 101ae2a:	b123      	cbz	r3, 101ae36 <ull_periph_latency_cancel+0xe>
 101ae2c:	f890 216c 	ldrb.w	r2, [r0, #364]	; 0x16c
 101ae30:	f012 0301 	ands.w	r3, r2, #1
 101ae34:	d000      	beq.n	101ae38 <ull_periph_latency_cancel+0x10>
 101ae36:	4770      	bx	lr
{
 101ae38:	b530      	push	{r4, r5, lr}
			ticker_update(TICKER_INSTANCE_ID_CTLR,
 101ae3a:	2401      	movs	r4, #1
 101ae3c:	4d12      	ldr	r5, [pc, #72]	; (101ae88 <ull_periph_latency_cancel+0x60>)
{
 101ae3e:	b089      	sub	sp, #36	; 0x24
		conn->periph.latency_cancel = 1U;
 101ae40:	ea42 0c04 	orr.w	ip, r2, r4
			ticker_update(TICKER_INSTANCE_ID_CTLR,
 101ae44:	1cca      	adds	r2, r1, #3
 101ae46:	9505      	str	r5, [sp, #20]
 101ae48:	2103      	movs	r1, #3
		conn->periph.latency_cancel = 1U;
 101ae4a:	f880 c16c 	strb.w	ip, [r0, #364]	; 0x16c
			ticker_update(TICKER_INSTANCE_ID_CTLR,
 101ae4e:	b2d2      	uxtb	r2, r2
 101ae50:	e9cd 3301 	strd	r3, r3, [sp, #4]
 101ae54:	9006      	str	r0, [sp, #24]
 101ae56:	9304      	str	r3, [sp, #16]
 101ae58:	4618      	mov	r0, r3
 101ae5a:	9300      	str	r3, [sp, #0]
 101ae5c:	9403      	str	r4, [sp, #12]
 101ae5e:	f7f7 f98d 	bl	101217c <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 101ae62:	f030 0302 	bics.w	r3, r0, #2
 101ae66:	d00c      	beq.n	101ae82 <ull_periph_latency_cancel+0x5a>
 101ae68:	f240 13f7 	movw	r3, #503	; 0x1f7
 101ae6c:	4a07      	ldr	r2, [pc, #28]	; (101ae8c <ull_periph_latency_cancel+0x64>)
 101ae6e:	4908      	ldr	r1, [pc, #32]	; (101ae90 <ull_periph_latency_cancel+0x68>)
 101ae70:	4808      	ldr	r0, [pc, #32]	; (101ae94 <ull_periph_latency_cancel+0x6c>)
 101ae72:	f009 feb0 	bl	1024bd6 <assert_print>
 101ae76:	4040      	eors	r0, r0
 101ae78:	f380 8811 	msr	BASEPRI, r0
 101ae7c:	f04f 0003 	mov.w	r0, #3
 101ae80:	df02      	svc	2
}
 101ae82:	b009      	add	sp, #36	; 0x24
 101ae84:	bd30      	pop	{r4, r5, pc}
 101ae86:	bf00      	nop
 101ae88:	0101acb9 	.word	0x0101acb9
 101ae8c:	0102ade4 	.word	0x0102ade4
 101ae90:	0102a9a0 	.word	0x0102a9a0
 101ae94:	0102a278 	.word	0x0102a278

0101ae98 <ll_start_enc_req_send>:
{
 101ae98:	b538      	push	{r3, r4, r5, lr}
 101ae9a:	460c      	mov	r4, r1
 101ae9c:	4615      	mov	r5, r2
	conn = ll_connected_get(handle);
 101ae9e:	f7fa fe51 	bl	1015b44 <ll_connected_get>
	if (!conn) {
 101aea2:	b148      	cbz	r0, 101aeb8 <ll_start_enc_req_send+0x20>
	if (error_code) {
 101aea4:	b11c      	cbz	r4, 101aeae <ll_start_enc_req_send+0x16>
}
 101aea6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return ull_cp_ltk_req_neq_reply(conn);
 101aeaa:	f7fd ba51 	b.w	1018350 <ull_cp_ltk_req_neq_reply>
		return ull_cp_ltk_req_reply(conn, ltk);
 101aeae:	4629      	mov	r1, r5
}
 101aeb0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return ull_cp_ltk_req_reply(conn, ltk);
 101aeb4:	f7fd ba2c 	b.w	1018310 <ull_cp_ltk_req_reply>
}
 101aeb8:	2002      	movs	r0, #2
 101aeba:	bd38      	pop	{r3, r4, r5, pc}

0101aebc <ll_set_min_used_chans>:

#if !defined(CONFIG_BT_LL_SW_LLCP_LEGACY)
#if defined(CONFIG_BT_CTLR_MIN_USED_CHAN)
uint8_t ll_set_min_used_chans(uint16_t handle, uint8_t const phys,
			      uint8_t const min_used_chans)
{
 101aebc:	b538      	push	{r3, r4, r5, lr}
 101aebe:	460c      	mov	r4, r1
 101aec0:	4615      	mov	r5, r2
	struct ll_conn *conn;

	conn = ll_connected_get(handle);
 101aec2:	f7fa fe3f 	bl	1015b44 <ll_connected_get>
	if (!conn) {
 101aec6:	b158      	cbz	r0, 101aee0 <ll_set_min_used_chans+0x24>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
	}

	if (!conn->lll.role) {
 101aec8:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
 101aecc:	2b00      	cmp	r3, #0
 101aece:	da05      	bge.n	101aedc <ll_set_min_used_chans+0x20>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	return ull_cp_min_used_chans(conn, phys, min_used_chans);
 101aed0:	462a      	mov	r2, r5
 101aed2:	4621      	mov	r1, r4
}
 101aed4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return ull_cp_min_used_chans(conn, phys, min_used_chans);
 101aed8:	f7fd b97a 	b.w	10181d0 <ull_cp_min_used_chans>
		return BT_HCI_ERR_CMD_DISALLOWED;
 101aedc:	200c      	movs	r0, #12
}
 101aede:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 101aee0:	2002      	movs	r0, #2
}
 101aee2:	bd38      	pop	{r3, r4, r5, pc}

0101aee4 <lll_chan_sel_1>:
/* Refer to Bluetooth Specification v5.2 Vol 6, Part B, Section 4.5.8.2
 * Channel Selection algorithm #1
 */
uint8_t lll_chan_sel_1(uint8_t *chan_use, uint8_t hop, uint16_t latency, uint8_t *chan_map,
		    uint8_t chan_count)
{
 101aee4:	b530      	push	{r4, r5, lr}
 101aee6:	4605      	mov	r5, r0
	uint8_t chan_next;

	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
 101aee8:	fb02 1101 	mla	r1, r2, r1, r1
 101aeec:	7802      	ldrb	r2, [r0, #0]
 101aeee:	4c20      	ldr	r4, [pc, #128]	; (101af70 <lll_chan_sel_1+0x8c>)
 101aef0:	4411      	add	r1, r2
 101aef2:	fb84 0201 	smull	r0, r2, r4, r1
 101aef6:	440a      	add	r2, r1
 101aef8:	1152      	asrs	r2, r2, #5
 101aefa:	eb02 00c2 	add.w	r0, r2, r2, lsl #3
 101aefe:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 101af02:	1a8a      	subs	r2, r1, r2
 101af04:	b2d0      	uxtb	r0, r2
	*chan_use = chan_next;
 101af06:	7028      	strb	r0, [r5, #0]

	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 101af08:	08c1      	lsrs	r1, r0, #3
 101af0a:	5c59      	ldrb	r1, [r3, r1]
 101af0c:	f002 0207 	and.w	r2, r2, #7
 101af10:	fa41 f202 	asr.w	r2, r1, r2
 101af14:	f012 0101 	ands.w	r1, r2, #1
{
 101af18:	f89d c00c 	ldrb.w	ip, [sp, #12]
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 101af1c:	d11f      	bne.n	101af5e <lll_chan_sel_1+0x7a>
		uint8_t chan_index;

		chan_index = chan_next % chan_count;
 101af1e:	fbb0 f2fc 	udiv	r2, r0, ip
 101af22:	1e5c      	subs	r4, r3, #1
 101af24:	1d1d      	adds	r5, r3, #4
 101af26:	fb0c 0312 	mls	r3, ip, r2, r0
static uint8_t chan_sel_remap(uint8_t *chan_map, uint8_t chan_index)
{
	uint8_t chan_next;
	uint8_t byte_count;

	chan_next = 0U;
 101af2a:	4608      	mov	r0, r1
		chan_index = chan_next % chan_count;
 101af2c:	b2db      	uxtb	r3, r3
	byte_count = 5U;
	while (byte_count--) {
		uint8_t bite;
		uint8_t bit_count;

		bite = *chan_map;
 101af2e:	4602      	mov	r2, r0
 101af30:	f100 0e08 	add.w	lr, r0, #8
 101af34:	f814 1f01 	ldrb.w	r1, [r4, #1]!
		bit_count = 8U;
		while (bit_count--) {
 101af38:	fa5f fe8e 	uxtb.w	lr, lr
			if (bite & 0x01) {
 101af3c:	f011 0f01 	tst.w	r1, #1
				if (chan_index == 0U) {
					break;
				}
				chan_index--;
			}
			chan_next++;
 101af40:	f102 0c01 	add.w	ip, r2, #1
			bite >>= 1;
 101af44:	ea4f 0151 	mov.w	r1, r1, lsr #1
			if (bite & 0x01) {
 101af48:	d002      	beq.n	101af50 <lll_chan_sel_1+0x6c>
				if (chan_index == 0U) {
 101af4a:	b14b      	cbz	r3, 101af60 <lll_chan_sel_1+0x7c>
				chan_index--;
 101af4c:	3b01      	subs	r3, #1
 101af4e:	b2db      	uxtb	r3, r3
			chan_next++;
 101af50:	fa5f f28c 	uxtb.w	r2, ip
		while (bit_count--) {
 101af54:	4572      	cmp	r2, lr
 101af56:	d1f1      	bne.n	101af3c <lll_chan_sel_1+0x58>
			chan_next++;
 101af58:	4610      	mov	r0, r2
	while (byte_count--) {
 101af5a:	42ac      	cmp	r4, r5
 101af5c:	d1e7      	bne.n	101af2e <lll_chan_sel_1+0x4a>
}
 101af5e:	bd30      	pop	{r4, r5, pc}
		}

		if (bit_count < 8) {
 101af60:	1dc1      	adds	r1, r0, #7
 101af62:	1a89      	subs	r1, r1, r2
 101af64:	b2c9      	uxtb	r1, r1
 101af66:	2907      	cmp	r1, #7
 101af68:	4610      	mov	r0, r2
 101af6a:	d8f6      	bhi.n	101af5a <lll_chan_sel_1+0x76>
}
 101af6c:	bd30      	pop	{r4, r5, pc}
 101af6e:	bf00      	nop
 101af70:	dd67c8a7 	.word	0xdd67c8a7

0101af74 <lll_chan_id>:
	return aa_ms ^ aa_ls;
 101af74:	8842      	ldrh	r2, [r0, #2]
 101af76:	8800      	ldrh	r0, [r0, #0]
}
 101af78:	4050      	eors	r0, r2
 101af7a:	4770      	bx	lr

0101af7c <lll_chan_sel_2>:
static uint16_t chan_prn_s(uint16_t counter, uint16_t chan_id)
{
	uint8_t iterate;
	uint16_t prn_s;

	prn_s = counter ^ chan_id;
 101af7c:	f04f 0c03 	mov.w	ip, #3
{
 101af80:	b5f0      	push	{r4, r5, r6, r7, lr}
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
 101af82:	4d33      	ldr	r5, [pc, #204]	; (101b050 <lll_chan_sel_2+0xd4>)
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
 101af84:	4c33      	ldr	r4, [pc, #204]	; (101b054 <lll_chan_sel_2+0xd8>)
	prn_s = counter ^ chan_id;
 101af86:	4048      	eors	r0, r1
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
 101af88:	0a06      	lsrs	r6, r0, #8
 101af8a:	fa5f fe80 	uxtb.w	lr, r0
 101af8e:	eb0e 2e8e 	add.w	lr, lr, lr, lsl #10
 101af92:	eb06 2086 	add.w	r0, r6, r6, lsl #10
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
 101af96:	ea04 1740 	and.w	r7, r4, r0, lsl #5
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
 101af9a:	ea05 0640 	and.w	r6, r5, r0, lsl #1
 101af9e:	ea05 004e 	and.w	r0, r5, lr, lsl #1
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
 101afa2:	ea04 1e4e 	and.w	lr, r4, lr, lsl #5
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
 101afa6:	433e      	orrs	r6, r7
 101afa8:	ea40 000e 	orr.w	r0, r0, lr
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
 101afac:	eb00 2700 	add.w	r7, r0, r0, lsl #8
 101afb0:	eb06 2e06 	add.w	lr, r6, r6, lsl #8
 101afb4:	eb06 260e 	add.w	r6, r6, lr, lsl #8
 101afb8:	eb00 2007 	add.w	r0, r0, r7, lsl #8
 101afbc:	0c36      	lsrs	r6, r6, #16
	return (chan_rev_8((i >> 8) & 0xFF) << 8) | chan_rev_8(i & 0xFF);
 101afbe:	f3c0 4007 	ubfx	r0, r0, #16, #8
 101afc2:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
	return ((uint32_t)a * 17U + b) & 0xFFFF;
 101afc6:	eb00 1000 	add.w	r0, r0, r0, lsl #4

	for (iterate = 0U; iterate < 3; iterate++) {
 101afca:	f10c 3cff 	add.w	ip, ip, #4294967295
	return ((uint32_t)a * 17U + b) & 0xFFFF;
 101afce:	4408      	add	r0, r1
	for (iterate = 0U; iterate < 3; iterate++) {
 101afd0:	f01c 0cff 	ands.w	ip, ip, #255	; 0xff
	return ((uint32_t)a * 17U + b) & 0xFFFF;
 101afd4:	b280      	uxth	r0, r0
	for (iterate = 0U; iterate < 3; iterate++) {
 101afd6:	d1d7      	bne.n	101af88 <lll_chan_sel_2+0xc>
static uint16_t chan_prn_e(uint16_t counter, uint16_t chan_id)
{
	uint16_t prn_e;

	prn_e = chan_prn_s(counter, chan_id);
	prn_e ^= chan_id;
 101afd8:	4041      	eors	r1, r0
	chan_next = prn_e % 37;
 101afda:	481f      	ldr	r0, [pc, #124]	; (101b058 <lll_chan_sel_2+0xdc>)
 101afdc:	fba0 4001 	umull	r4, r0, r0, r1
 101afe0:	1a0c      	subs	r4, r1, r0
 101afe2:	eb00 0054 	add.w	r0, r0, r4, lsr #1
 101afe6:	0940      	lsrs	r0, r0, #5
 101afe8:	eb00 04c0 	add.w	r4, r0, r0, lsl #3
 101afec:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 101aff0:	1a08      	subs	r0, r1, r0
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 101aff2:	f3c0 04c4 	ubfx	r4, r0, #3, #5
 101aff6:	5d14      	ldrb	r4, [r2, r4]
 101aff8:	f000 0507 	and.w	r5, r0, #7
 101affc:	412c      	asrs	r4, r5
 101affe:	07e4      	lsls	r4, r4, #31
	chan_next = prn_e % 37;
 101b000:	b2c0      	uxtb	r0, r0
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 101b002:	d41c      	bmi.n	101b03e <lll_chan_sel_2+0xc2>
	chan_next = 0U;
 101b004:	4660      	mov	r0, ip
		chan_index = ((uint32_t)chan_count * prn_e) >> 16;
 101b006:	fb01 f303 	mul.w	r3, r1, r3
 101b00a:	1e56      	subs	r6, r2, #1
 101b00c:	f3c3 4307 	ubfx	r3, r3, #16, #8
	while (byte_count--) {
 101b010:	3204      	adds	r2, #4
		bite = *chan_map;
 101b012:	4601      	mov	r1, r0
 101b014:	f100 0508 	add.w	r5, r0, #8
 101b018:	f816 cf01 	ldrb.w	ip, [r6, #1]!
		while (bit_count--) {
 101b01c:	b2ed      	uxtb	r5, r5
			if (bite & 0x01) {
 101b01e:	f01c 0f01 	tst.w	ip, #1
			chan_next++;
 101b022:	f101 0401 	add.w	r4, r1, #1
			bite >>= 1;
 101b026:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
			if (bite & 0x01) {
 101b02a:	d002      	beq.n	101b032 <lll_chan_sel_2+0xb6>
				if (chan_index == 0U) {
 101b02c:	b143      	cbz	r3, 101b040 <lll_chan_sel_2+0xc4>
				chan_index--;
 101b02e:	3b01      	subs	r3, #1
 101b030:	b2db      	uxtb	r3, r3
			chan_next++;
 101b032:	b2e1      	uxtb	r1, r4
		while (bit_count--) {
 101b034:	42a9      	cmp	r1, r5
 101b036:	d1f2      	bne.n	101b01e <lll_chan_sel_2+0xa2>
			chan_next++;
 101b038:	4608      	mov	r0, r1
	while (byte_count--) {
 101b03a:	4296      	cmp	r6, r2
 101b03c:	d1e9      	bne.n	101b012 <lll_chan_sel_2+0x96>
}
 101b03e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (bit_count < 8) {
 101b040:	3007      	adds	r0, #7
 101b042:	1a40      	subs	r0, r0, r1
 101b044:	b2c0      	uxtb	r0, r0
 101b046:	2807      	cmp	r0, #7
 101b048:	4608      	mov	r0, r1
 101b04a:	d8f6      	bhi.n	101b03a <lll_chan_sel_2+0xbe>
}
 101b04c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 101b04e:	bf00      	nop
 101b050:	00022110 	.word	0x00022110
 101b054:	00088440 	.word	0x00088440
 101b058:	bacf914d 	.word	0xbacf914d

0101b05c <radio_nrf5_isr>:
ISR_DIRECT_DECLARE(radio_nrf5_isr)
 101b05c:	4668      	mov	r0, sp
 101b05e:	f020 0107 	bic.w	r1, r0, #7
 101b062:	468d      	mov	sp, r1
 101b064:	b501      	push	{r0, lr}
	isr_radio();
 101b066:	f002 f84f 	bl	101d108 <isr_radio>
{
#ifdef CONFIG_TRACING_ISR
	sys_trace_isr_exit();
#endif
	if (maybe_swap != 0) {
		z_arm_int_exit();
 101b06a:	f7ea ffd3 	bl	1006014 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(radio_nrf5_isr)
 101b06e:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
 101b072:	4685      	mov	sp, r0
 101b074:	4770      	bx	lr
 101b076:	bf00      	nop

0101b078 <rtc0_nrf5_isr>:
{
 101b078:	b508      	push	{r3, lr}
	if (NRF_RTC0->EVENTS_COMPARE[0]) {
 101b07a:	4b09      	ldr	r3, [pc, #36]	; (101b0a0 <rtc0_nrf5_isr+0x28>)
 101b07c:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
 101b080:	b93a      	cbnz	r2, 101b092 <rtc0_nrf5_isr+0x1a>
	mayfly_run(TICKER_USER_ID_ULL_HIGH);
 101b082:	2001      	movs	r0, #1
 101b084:	f7f6 f80c 	bl	10110a0 <mayfly_run>
}
 101b088:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	mayfly_run(TICKER_USER_ID_ULL_LOW);
 101b08c:	2002      	movs	r0, #2
 101b08e:	f7f6 b807 	b.w	10110a0 <mayfly_run>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;
 101b092:	2000      	movs	r0, #0
 101b094:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		ticker_trigger(0);
 101b098:	f7f6 ffa0 	bl	1011fdc <ticker_trigger>
 101b09c:	e7f1      	b.n	101b082 <rtc0_nrf5_isr+0xa>
 101b09e:	bf00      	nop
 101b0a0:	41011000 	.word	0x41011000

0101b0a4 <swi_lll_nrf5_isr>:
	mayfly_run(TICKER_USER_ID_LLL);
 101b0a4:	2000      	movs	r0, #0
 101b0a6:	f7f5 bffb 	b.w	10110a0 <mayfly_run>
 101b0aa:	bf00      	nop

0101b0ac <ticker_start_op_cb>:

	preempt_req = preempt_ack;
}

static void ticker_start_op_cb(uint32_t status, void *param)
{
 101b0ac:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(param);
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 101b0ae:	b9f8      	cbnz	r0, 101b0f0 <ticker_start_op_cb+0x44>

	LL_ASSERT(preempt_start_req != preempt_start_ack);
 101b0b0:	4b1e      	ldr	r3, [pc, #120]	; (101b12c <ticker_start_op_cb+0x80>)
 101b0b2:	4d1f      	ldr	r5, [pc, #124]	; (101b130 <ticker_start_op_cb+0x84>)
 101b0b4:	781a      	ldrb	r2, [r3, #0]
 101b0b6:	782b      	ldrb	r3, [r5, #0]
 101b0b8:	429a      	cmp	r2, r3
 101b0ba:	d027      	beq.n	101b10c <ticker_start_op_cb+0x60>
	preempt_start_ack++;

	LL_ASSERT(preempt_req == preempt_ack);
 101b0bc:	4a1d      	ldr	r2, [pc, #116]	; (101b134 <ticker_start_op_cb+0x88>)
 101b0be:	4c1e      	ldr	r4, [pc, #120]	; (101b138 <ticker_start_op_cb+0x8c>)
 101b0c0:	7812      	ldrb	r2, [r2, #0]
 101b0c2:	7821      	ldrb	r1, [r4, #0]
	preempt_start_ack++;
 101b0c4:	3301      	adds	r3, #1
	LL_ASSERT(preempt_req == preempt_ack);
 101b0c6:	4291      	cmp	r1, r2
	preempt_start_ack++;
 101b0c8:	702b      	strb	r3, [r5, #0]
	LL_ASSERT(preempt_req == preempt_ack);
 101b0ca:	b2d3      	uxtb	r3, r2
 101b0cc:	d00d      	beq.n	101b0ea <ticker_start_op_cb+0x3e>
 101b0ce:	f240 332f 	movw	r3, #815	; 0x32f
 101b0d2:	4a1a      	ldr	r2, [pc, #104]	; (101b13c <ticker_start_op_cb+0x90>)
 101b0d4:	491a      	ldr	r1, [pc, #104]	; (101b140 <ticker_start_op_cb+0x94>)
 101b0d6:	481b      	ldr	r0, [pc, #108]	; (101b144 <ticker_start_op_cb+0x98>)
 101b0d8:	f009 fd7d 	bl	1024bd6 <assert_print>
 101b0dc:	4040      	eors	r0, r0
 101b0de:	f380 8811 	msr	BASEPRI, r0
 101b0e2:	f04f 0003 	mov.w	r0, #3
 101b0e6:	df02      	svc	2
	preempt_req++;
 101b0e8:	7823      	ldrb	r3, [r4, #0]
 101b0ea:	3301      	adds	r3, #1
 101b0ec:	7023      	strb	r3, [r4, #0]
}
 101b0ee:	bd38      	pop	{r3, r4, r5, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 101b0f0:	f240 332a 	movw	r3, #810	; 0x32a
 101b0f4:	4a11      	ldr	r2, [pc, #68]	; (101b13c <ticker_start_op_cb+0x90>)
 101b0f6:	4914      	ldr	r1, [pc, #80]	; (101b148 <ticker_start_op_cb+0x9c>)
 101b0f8:	4812      	ldr	r0, [pc, #72]	; (101b144 <ticker_start_op_cb+0x98>)
 101b0fa:	f009 fd6c 	bl	1024bd6 <assert_print>
 101b0fe:	4040      	eors	r0, r0
 101b100:	f380 8811 	msr	BASEPRI, r0
 101b104:	f04f 0003 	mov.w	r0, #3
 101b108:	df02      	svc	2
 101b10a:	e7d1      	b.n	101b0b0 <ticker_start_op_cb+0x4>
	LL_ASSERT(preempt_start_req != preempt_start_ack);
 101b10c:	f44f 734b 	mov.w	r3, #812	; 0x32c
 101b110:	4a0a      	ldr	r2, [pc, #40]	; (101b13c <ticker_start_op_cb+0x90>)
 101b112:	490e      	ldr	r1, [pc, #56]	; (101b14c <ticker_start_op_cb+0xa0>)
 101b114:	480b      	ldr	r0, [pc, #44]	; (101b144 <ticker_start_op_cb+0x98>)
 101b116:	f009 fd5e 	bl	1024bd6 <assert_print>
 101b11a:	4040      	eors	r0, r0
 101b11c:	f380 8811 	msr	BASEPRI, r0
 101b120:	f04f 0003 	mov.w	r0, #3
 101b124:	df02      	svc	2
	preempt_start_ack++;
 101b126:	782b      	ldrb	r3, [r5, #0]
 101b128:	e7c8      	b.n	101b0bc <ticker_start_op_cb+0x10>
 101b12a:	bf00      	nop
 101b12c:	21008350 	.word	0x21008350
 101b130:	2100834f 	.word	0x2100834f
 101b134:	2100834b 	.word	0x2100834b
 101b138:	2100834c 	.word	0x2100834c
 101b13c:	0102ae70 	.word	0x0102ae70
 101b140:	0102aee0 	.word	0x0102aee0
 101b144:	0102a278 	.word	0x0102a278
 101b148:	0102a934 	.word	0x0102a934
 101b14c:	0102aeb8 	.word	0x0102aeb8

0101b150 <ticker_stop_op_cb>:
{
 101b150:	b510      	push	{r4, lr}
	LL_ASSERT(preempt_stop_req != preempt_stop_ack);
 101b152:	4b0e      	ldr	r3, [pc, #56]	; (101b18c <ticker_stop_op_cb+0x3c>)
 101b154:	4c0e      	ldr	r4, [pc, #56]	; (101b190 <ticker_stop_op_cb+0x40>)
 101b156:	781a      	ldrb	r2, [r3, #0]
 101b158:	7823      	ldrb	r3, [r4, #0]
 101b15a:	429a      	cmp	r2, r3
 101b15c:	d006      	beq.n	101b16c <ticker_stop_op_cb+0x1c>
	preempt_req = preempt_ack;
 101b15e:	490d      	ldr	r1, [pc, #52]	; (101b194 <ticker_stop_op_cb+0x44>)
 101b160:	4a0d      	ldr	r2, [pc, #52]	; (101b198 <ticker_stop_op_cb+0x48>)
 101b162:	7809      	ldrb	r1, [r1, #0]
	preempt_stop_ack++;
 101b164:	3301      	adds	r3, #1
 101b166:	7023      	strb	r3, [r4, #0]
	preempt_req = preempt_ack;
 101b168:	7011      	strb	r1, [r2, #0]
}
 101b16a:	bd10      	pop	{r4, pc}
	LL_ASSERT(preempt_stop_req != preempt_stop_ack);
 101b16c:	f240 3321 	movw	r3, #801	; 0x321
 101b170:	4a0a      	ldr	r2, [pc, #40]	; (101b19c <ticker_stop_op_cb+0x4c>)
 101b172:	490b      	ldr	r1, [pc, #44]	; (101b1a0 <ticker_stop_op_cb+0x50>)
 101b174:	480b      	ldr	r0, [pc, #44]	; (101b1a4 <ticker_stop_op_cb+0x54>)
 101b176:	f009 fd2e 	bl	1024bd6 <assert_print>
 101b17a:	4040      	eors	r0, r0
 101b17c:	f380 8811 	msr	BASEPRI, r0
 101b180:	f04f 0003 	mov.w	r0, #3
 101b184:	df02      	svc	2
	preempt_stop_ack++;
 101b186:	7823      	ldrb	r3, [r4, #0]
 101b188:	e7e9      	b.n	101b15e <ticker_stop_op_cb+0xe>
 101b18a:	bf00      	nop
 101b18c:	2100834e 	.word	0x2100834e
 101b190:	2100834d 	.word	0x2100834d
 101b194:	2100834b 	.word	0x2100834b
 101b198:	2100834c 	.word	0x2100834c
 101b19c:	0102ae70 	.word	0x0102ae70
 101b1a0:	0102aefc 	.word	0x0102aefc
 101b1a4:	0102a278 	.word	0x0102a278

0101b1a8 <isr_race>:
	radio_status_reset();
 101b1a8:	f002 b908 	b.w	101d3bc <radio_status_reset>

0101b1ac <preempt_ticker_cb>:
}

static void preempt_ticker_cb(uint32_t ticks_at_expire, uint32_t ticks_drift,
			      uint32_t remainder, uint16_t lazy, uint8_t force,
			      void *param)
{
 101b1ac:	b510      	push	{r4, lr}
	static memq_link_t link;
	static struct mayfly mfy = {0, 0, &link, NULL, preempt};
	uint32_t ret;

	LL_ASSERT(preempt_ack != preempt_req);
 101b1ae:	4a18      	ldr	r2, [pc, #96]	; (101b210 <preempt_ticker_cb+0x64>)
 101b1b0:	4c18      	ldr	r4, [pc, #96]	; (101b214 <preempt_ticker_cb+0x68>)
 101b1b2:	7812      	ldrb	r2, [r2, #0]
 101b1b4:	7823      	ldrb	r3, [r4, #0]
 101b1b6:	429a      	cmp	r2, r3
 101b1b8:	d01b      	beq.n	101b1f2 <preempt_ticker_cb+0x46>
	preempt_ack++;

	mfy.param = param;
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 101b1ba:	2200      	movs	r2, #0
	preempt_ack++;
 101b1bc:	7821      	ldrb	r1, [r4, #0]
	mfy.param = param;
 101b1be:	4b16      	ldr	r3, [pc, #88]	; (101b218 <preempt_ticker_cb+0x6c>)
	preempt_ack++;
 101b1c0:	3101      	adds	r1, #1
 101b1c2:	b2c9      	uxtb	r1, r1
 101b1c4:	7021      	strb	r1, [r4, #0]
	mfy.param = param;
 101b1c6:	9903      	ldr	r1, [sp, #12]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 101b1c8:	2001      	movs	r0, #1
	mfy.param = param;
 101b1ca:	6099      	str	r1, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 101b1cc:	4611      	mov	r1, r2
 101b1ce:	f7f5 ff09 	bl	1010fe4 <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
 101b1d2:	b900      	cbnz	r0, 101b1d6 <preempt_ticker_cb+0x2a>
}
 101b1d4:	bd10      	pop	{r4, pc}
	LL_ASSERT(!ret);
 101b1d6:	f240 33ad 	movw	r3, #941	; 0x3ad
 101b1da:	4a10      	ldr	r2, [pc, #64]	; (101b21c <preempt_ticker_cb+0x70>)
 101b1dc:	4910      	ldr	r1, [pc, #64]	; (101b220 <preempt_ticker_cb+0x74>)
 101b1de:	4811      	ldr	r0, [pc, #68]	; (101b224 <preempt_ticker_cb+0x78>)
 101b1e0:	f009 fcf9 	bl	1024bd6 <assert_print>
 101b1e4:	4040      	eors	r0, r0
 101b1e6:	f380 8811 	msr	BASEPRI, r0
 101b1ea:	f04f 0003 	mov.w	r0, #3
 101b1ee:	df02      	svc	2
}
 101b1f0:	bd10      	pop	{r4, pc}
	LL_ASSERT(preempt_ack != preempt_req);
 101b1f2:	f240 33a7 	movw	r3, #935	; 0x3a7
 101b1f6:	4a09      	ldr	r2, [pc, #36]	; (101b21c <preempt_ticker_cb+0x70>)
 101b1f8:	490b      	ldr	r1, [pc, #44]	; (101b228 <preempt_ticker_cb+0x7c>)
 101b1fa:	480a      	ldr	r0, [pc, #40]	; (101b224 <preempt_ticker_cb+0x78>)
 101b1fc:	f009 fceb 	bl	1024bd6 <assert_print>
 101b200:	4040      	eors	r0, r0
 101b202:	f380 8811 	msr	BASEPRI, r0
 101b206:	f04f 0003 	mov.w	r0, #3
 101b20a:	df02      	svc	2
 101b20c:	e7d5      	b.n	101b1ba <preempt_ticker_cb+0xe>
 101b20e:	bf00      	nop
 101b210:	2100834c 	.word	0x2100834c
 101b214:	2100834b 	.word	0x2100834b
 101b218:	210009a4 	.word	0x210009a4
 101b21c:	0102ae70 	.word	0x0102ae70
 101b220:	0102a694 	.word	0x0102a694
 101b224:	0102a278 	.word	0x0102a278
 101b228:	0102af24 	.word	0x0102af24

0101b22c <preempt_ticker_start>:
{
 101b22c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if ((preempt_start_req != preempt_start_ack) ||
 101b230:	4c51      	ldr	r4, [pc, #324]	; (101b378 <preempt_ticker_start+0x14c>)
 101b232:	f8df 8148 	ldr.w	r8, [pc, #328]	; 101b37c <preempt_ticker_start+0x150>
 101b236:	7826      	ldrb	r6, [r4, #0]
 101b238:	f898 3000 	ldrb.w	r3, [r8]
{
 101b23c:	460c      	mov	r4, r1
	if ((preempt_start_req != preempt_start_ack) ||
 101b23e:	429e      	cmp	r6, r3
{
 101b240:	4615      	mov	r5, r2
 101b242:	b08a      	sub	sp, #40	; 0x28
	if ((preempt_start_req != preempt_start_ack) ||
 101b244:	d04a      	beq.n	101b2dc <preempt_ticker_start+0xb0>
		if (!prev || prev->is_aborted ||
 101b246:	2c00      	cmp	r4, #0
 101b248:	d063      	beq.n	101b312 <preempt_ticker_start+0xe6>
 101b24a:	7f22      	ldrb	r2, [r4, #28]
 101b24c:	f012 0202 	ands.w	r2, r2, #2
 101b250:	d15f      	bne.n	101b312 <preempt_ticker_start+0xe6>
		ull = HDR_LLL2ULL(p->param);
 101b252:	68eb      	ldr	r3, [r5, #12]
		preempt_anchor = p->ticks_at_expire;
 101b254:	f8d5 a000 	ldr.w	sl, [r5]
		ull = HDR_LLL2ULL(p->param);
 101b258:	681b      	ldr	r3, [r3, #0]
		diff = ticks_at_preempt_new - ticks_at_preempt;
 101b25a:	f8df 9124 	ldr.w	r9, [pc, #292]	; 101b380 <preempt_ticker_start+0x154>
		preempt_to = MAX(ull->ticks_active_to_start,
 101b25e:	68df      	ldr	r7, [r3, #12]
 101b260:	e9d3 1001 	ldrd	r1, r0, [r3, #4]
 101b264:	4288      	cmp	r0, r1
 101b266:	bf2c      	ite	cs
 101b268:	ebc7 0700 	rsbcs	r7, r7, r0
 101b26c:	ebc7 0701 	rsbcc	r7, r7, r1
		diff = ticks_at_preempt_new - ticks_at_preempt;
 101b270:	f8d9 0000 	ldr.w	r0, [r9]
		ticks_at_preempt_new = preempt_anchor + preempt_to;
 101b274:	eb0a 0607 	add.w	r6, sl, r7
		ticks_at_preempt_new &= HAL_TICKER_CNTR_MASK;
 101b278:	f026 467f 	bic.w	r6, r6, #4278190080	; 0xff000000
		diff = ticks_at_preempt_new - ticks_at_preempt;
 101b27c:	1a30      	subs	r0, r6, r0
		if (!prev || prev->is_aborted ||
 101b27e:	f410 0000 	ands.w	r0, r0, #8388608	; 0x800000
 101b282:	d047      	beq.n	101b314 <preempt_ticker_start+0xe8>
	if ((preempt_stop_req != preempt_stop_ack) ||
 101b284:	493f      	ldr	r1, [pc, #252]	; (101b384 <preempt_ticker_start+0x158>)
 101b286:	4b40      	ldr	r3, [pc, #256]	; (101b388 <preempt_ticker_start+0x15c>)
 101b288:	7808      	ldrb	r0, [r1, #0]
 101b28a:	7819      	ldrb	r1, [r3, #0]
 101b28c:	4288      	cmp	r0, r1
 101b28e:	d044      	beq.n	101b31a <preempt_ticker_start+0xee>
		prev->is_aborted = 1U;
 101b290:	7f23      	ldrb	r3, [r4, #28]
		prev->abort_cb(&prev->prepare_param, prev->prepare_param.param);
 101b292:	4620      	mov	r0, r4
		prev->is_aborted = 1U;
 101b294:	f043 0302 	orr.w	r3, r3, #2
 101b298:	7723      	strb	r3, [r4, #28]
		prev->abort_cb(&prev->prepare_param, prev->prepare_param.param);
 101b29a:	68e1      	ldr	r1, [r4, #12]
 101b29c:	69a3      	ldr	r3, [r4, #24]
		ticks_at_preempt = ticks_at_preempt_new;
 101b29e:	f8c9 6000 	str.w	r6, [r9]
		prev->abort_cb(&prev->prepare_param, prev->prepare_param.param);
 101b2a2:	4798      	blx	r3
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 101b2a4:	4a39      	ldr	r2, [pc, #228]	; (101b38c <preempt_ticker_start+0x160>)
	ticks_at_preempt = ticks_at_preempt_new;
 101b2a6:	f8c9 6000 	str.w	r6, [r9]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 101b2aa:	e9cd 2507 	strd	r2, r5, [sp, #28]
 101b2ae:	2200      	movs	r2, #0
 101b2b0:	4937      	ldr	r1, [pc, #220]	; (101b390 <preempt_ticker_start+0x164>)
 101b2b2:	9700      	str	r7, [sp, #0]
 101b2b4:	e9cd 1505 	strd	r1, r5, [sp, #20]
	preempt_start_req++;
 101b2b8:	f898 1000 	ldrb.w	r1, [r8]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 101b2bc:	4653      	mov	r3, sl
	preempt_start_req++;
 101b2be:	3101      	adds	r1, #1
 101b2c0:	b2c9      	uxtb	r1, r1
 101b2c2:	f888 1000 	strb.w	r1, [r8]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 101b2c6:	4610      	mov	r0, r2
 101b2c8:	4611      	mov	r1, r2
 101b2ca:	e9cd 2203 	strd	r2, r2, [sp, #12]
 101b2ce:	e9cd 2201 	strd	r2, r2, [sp, #4]
 101b2d2:	f7f6 fee3 	bl	101209c <ticker_start>
}
 101b2d6:	b00a      	add	sp, #40	; 0x28
 101b2d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	    (preempt_req != preempt_ack)) {
 101b2dc:	4b2d      	ldr	r3, [pc, #180]	; (101b394 <preempt_ticker_start+0x168>)
 101b2de:	4a2e      	ldr	r2, [pc, #184]	; (101b398 <preempt_ticker_start+0x16c>)
 101b2e0:	781b      	ldrb	r3, [r3, #0]
	if ((preempt_start_req != preempt_start_ack) ||
 101b2e2:	7812      	ldrb	r2, [r2, #0]
 101b2e4:	429a      	cmp	r2, r3
 101b2e6:	d1ae      	bne.n	101b246 <preempt_ticker_start+0x1a>
		ull = HDR_LLL2ULL(p->param);
 101b2e8:	68c3      	ldr	r3, [r0, #12]
		preempt_anchor = p->ticks_at_expire;
 101b2ea:	f8d0 a000 	ldr.w	sl, [r0]
		ull = HDR_LLL2ULL(p->param);
 101b2ee:	681b      	ldr	r3, [r3, #0]
		ticks_at_preempt_new &= HAL_TICKER_CNTR_MASK;
 101b2f0:	4605      	mov	r5, r0
		preempt_to = MAX(ull->ticks_active_to_start,
 101b2f2:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
 101b2f6:	68df      	ldr	r7, [r3, #12]
 101b2f8:	f8df 9084 	ldr.w	r9, [pc, #132]	; 101b380 <preempt_ticker_start+0x154>
 101b2fc:	4291      	cmp	r1, r2
 101b2fe:	bf2c      	ite	cs
 101b300:	ebc7 0701 	rsbcs	r7, r7, r1
 101b304:	ebc7 0702 	rsbcc	r7, r7, r2
		ticks_at_preempt_new = preempt_anchor + preempt_to;
 101b308:	eb0a 0607 	add.w	r6, sl, r7
		ticks_at_preempt_new &= HAL_TICKER_CNTR_MASK;
 101b30c:	f026 467f 	bic.w	r6, r6, #4278190080	; 0xff000000
 101b310:	e7c8      	b.n	101b2a4 <preempt_ticker_start+0x78>
			return TICKER_STATUS_SUCCESS;
 101b312:	2000      	movs	r0, #0
}
 101b314:	b00a      	add	sp, #40	; 0x28
 101b316:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	    (preempt_req == preempt_ack)) {
 101b31a:	491e      	ldr	r1, [pc, #120]	; (101b394 <preempt_ticker_start+0x168>)
 101b31c:	481e      	ldr	r0, [pc, #120]	; (101b398 <preempt_ticker_start+0x16c>)
 101b31e:	7809      	ldrb	r1, [r1, #0]
	if ((preempt_stop_req != preempt_stop_ack) ||
 101b320:	7800      	ldrb	r0, [r0, #0]
 101b322:	4288      	cmp	r0, r1
 101b324:	d0b4      	beq.n	101b290 <preempt_ticker_start+0x64>
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 101b326:	9200      	str	r2, [sp, #0]
	preempt_stop_req++;
 101b328:	7819      	ldrb	r1, [r3, #0]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 101b32a:	4610      	mov	r0, r2
	preempt_stop_req++;
 101b32c:	3101      	adds	r1, #1
 101b32e:	b2c9      	uxtb	r1, r1
 101b330:	7019      	strb	r1, [r3, #0]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 101b332:	4b1a      	ldr	r3, [pc, #104]	; (101b39c <preempt_ticker_start+0x170>)
 101b334:	4611      	mov	r1, r2
 101b336:	f7f6 ff3d 	bl	10121b4 <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 101b33a:	f030 0302 	bics.w	r3, r0, #2
 101b33e:	d0a7      	beq.n	101b290 <preempt_ticker_start+0x64>
 101b340:	f240 3399 	movw	r3, #921	; 0x399
 101b344:	4a16      	ldr	r2, [pc, #88]	; (101b3a0 <preempt_ticker_start+0x174>)
 101b346:	4917      	ldr	r1, [pc, #92]	; (101b3a4 <preempt_ticker_start+0x178>)
 101b348:	4817      	ldr	r0, [pc, #92]	; (101b3a8 <preempt_ticker_start+0x17c>)
 101b34a:	f009 fc44 	bl	1024bd6 <assert_print>
 101b34e:	4040      	eors	r0, r0
 101b350:	f380 8811 	msr	BASEPRI, r0
 101b354:	f04f 0003 	mov.w	r0, #3
 101b358:	df02      	svc	2
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 101b35a:	f44f 7356 	mov.w	r3, #856	; 0x358
 101b35e:	4a10      	ldr	r2, [pc, #64]	; (101b3a0 <preempt_ticker_start+0x174>)
 101b360:	4910      	ldr	r1, [pc, #64]	; (101b3a4 <preempt_ticker_start+0x178>)
 101b362:	4811      	ldr	r0, [pc, #68]	; (101b3a8 <preempt_ticker_start+0x17c>)
 101b364:	f009 fc37 	bl	1024bd6 <assert_print>
 101b368:	4040      	eors	r0, r0
 101b36a:	f380 8811 	msr	BASEPRI, r0
 101b36e:	f04f 0003 	mov.w	r0, #3
 101b372:	df02      	svc	2
 101b374:	e78c      	b.n	101b290 <preempt_ticker_start+0x64>
 101b376:	bf00      	nop
 101b378:	2100834f 	.word	0x2100834f
 101b37c:	21008350 	.word	0x21008350
 101b380:	21007ba8 	.word	0x21007ba8
 101b384:	2100834d 	.word	0x2100834d
 101b388:	2100834e 	.word	0x2100834e
 101b38c:	0101b0ad 	.word	0x0101b0ad
 101b390:	0101b1ad 	.word	0x0101b1ad
 101b394:	2100834b 	.word	0x2100834b
 101b398:	2100834c 	.word	0x2100834c
 101b39c:	0101b151 	.word	0x0101b151
 101b3a0:	0102ae70 	.word	0x0102ae70
 101b3a4:	0102a768 	.word	0x0102a768
 101b3a8:	0102a278 	.word	0x0102a278

0101b3ac <preempt>:

static void preempt(void *param)
{
 101b3ac:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct lll_event *next;
	uint8_t idx;
	int err;

	/* No event to abort */
	if (!event.curr.abort_cb || !event.curr.param) {
 101b3ae:	4e4a      	ldr	r6, [pc, #296]	; (101b4d8 <preempt+0x12c>)
{
 101b3b0:	b089      	sub	sp, #36	; 0x24
	if (!event.curr.abort_cb || !event.curr.param) {
 101b3b2:	68b3      	ldr	r3, [r6, #8]
 101b3b4:	b153      	cbz	r3, 101b3cc <preempt+0x20>
 101b3b6:	6833      	ldr	r3, [r6, #0]
 101b3b8:	b143      	cbz	r3, 101b3cc <preempt+0x20>
		return;
	}

	/* Check if any prepare in pipeline */
	idx = UINT8_MAX;
 101b3ba:	23ff      	movs	r3, #255	; 0xff
 101b3bc:	4605      	mov	r5, r0
	next = ull_prepare_dequeue_iter(&idx);
 101b3be:	f10d 000a 	add.w	r0, sp, #10
	idx = UINT8_MAX;
 101b3c2:	f88d 300a 	strb.w	r3, [sp, #10]
	next = ull_prepare_dequeue_iter(&idx);
 101b3c6:	f7f9 f9bf 	bl	1014748 <ull_prepare_dequeue_iter>
	if (!next) {
 101b3ca:	b938      	cbnz	r0, 101b3dc <preempt+0x30>
		iter = resume_enqueue(resume_cb);
		LL_ASSERT(iter);
	} else {
		LL_ASSERT(err == -ECANCELED);
	}
}
 101b3cc:	b009      	add	sp, #36	; 0x24
 101b3ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = ull_prepare_dequeue_iter(&idx);
 101b3d0:	f10d 000a 	add.w	r0, sp, #10
 101b3d4:	f7f9 f9b8 	bl	1014748 <ull_prepare_dequeue_iter>
	while (next && (next->is_aborted || next->is_resume)) {
 101b3d8:	2800      	cmp	r0, #0
 101b3da:	d0f7      	beq.n	101b3cc <preempt+0x20>
 101b3dc:	7f01      	ldrb	r1, [r0, #28]
 101b3de:	f011 0403 	ands.w	r4, r1, #3
 101b3e2:	d1f5      	bne.n	101b3d0 <preempt+0x24>
	if (next != param) {
 101b3e4:	4285      	cmp	r5, r0
 101b3e6:	d126      	bne.n	101b436 <preempt+0x8a>
	err = event.curr.is_abort_cb(next->prepare_param.param,
 101b3e8:	6873      	ldr	r3, [r6, #4]
 101b3ea:	6831      	ldr	r1, [r6, #0]
 101b3ec:	68e8      	ldr	r0, [r5, #12]
 101b3ee:	aa03      	add	r2, sp, #12
 101b3f0:	4798      	blx	r3
	if (!err) {
 101b3f2:	4607      	mov	r7, r0
 101b3f4:	b1b0      	cbz	r0, 101b424 <preempt+0x78>
	event.curr.abort_cb(NULL, event.curr.param);
 101b3f6:	4620      	mov	r0, r4
 101b3f8:	68b3      	ldr	r3, [r6, #8]
 101b3fa:	6831      	ldr	r1, [r6, #0]
 101b3fc:	4798      	blx	r3
	if (err == -EAGAIN) {
 101b3fe:	f117 0f0b 	cmn.w	r7, #11
 101b402:	d02d      	beq.n	101b460 <preempt+0xb4>
		LL_ASSERT(err == -ECANCELED);
 101b404:	378c      	adds	r7, #140	; 0x8c
 101b406:	d0e1      	beq.n	101b3cc <preempt+0x20>
 101b408:	f240 4307 	movw	r3, #1031	; 0x407
 101b40c:	4a33      	ldr	r2, [pc, #204]	; (101b4dc <preempt+0x130>)
 101b40e:	4934      	ldr	r1, [pc, #208]	; (101b4e0 <preempt+0x134>)
 101b410:	4834      	ldr	r0, [pc, #208]	; (101b4e4 <preempt+0x138>)
 101b412:	f009 fbe0 	bl	1024bd6 <assert_print>
 101b416:	4040      	eors	r0, r0
 101b418:	f380 8811 	msr	BASEPRI, r0
 101b41c:	f04f 0003 	mov.w	r0, #3
 101b420:	df02      	svc	2
 101b422:	e7d3      	b.n	101b3cc <preempt+0x20>
		next->is_aborted = 1;
 101b424:	7f2b      	ldrb	r3, [r5, #28]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
 101b426:	4628      	mov	r0, r5
		next->is_aborted = 1;
 101b428:	f043 0302 	orr.w	r3, r3, #2
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
 101b42c:	69aa      	ldr	r2, [r5, #24]
 101b42e:	68e9      	ldr	r1, [r5, #12]
		next->is_aborted = 1;
 101b430:	772b      	strb	r3, [r5, #28]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
 101b432:	4790      	blx	r2
		return;
 101b434:	e7ca      	b.n	101b3cc <preempt+0x20>
		ret = preempt_ticker_start(next, NULL, next);
 101b436:	4602      	mov	r2, r0
 101b438:	4621      	mov	r1, r4
 101b43a:	f7ff fef7 	bl	101b22c <preempt_ticker_start>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 101b43e:	f030 0302 	bics.w	r3, r0, #2
 101b442:	d0c3      	beq.n	101b3cc <preempt+0x20>
 101b444:	f240 33d3 	movw	r3, #979	; 0x3d3
 101b448:	4a24      	ldr	r2, [pc, #144]	; (101b4dc <preempt+0x130>)
 101b44a:	4927      	ldr	r1, [pc, #156]	; (101b4e8 <preempt+0x13c>)
 101b44c:	4825      	ldr	r0, [pc, #148]	; (101b4e4 <preempt+0x138>)
 101b44e:	f009 fbc2 	bl	1024bd6 <assert_print>
 101b452:	4040      	eors	r0, r0
 101b454:	f380 8811 	msr	BASEPRI, r0
 101b458:	f04f 0003 	mov.w	r0, #3
 101b45c:	df02      	svc	2
 101b45e:	e7b5      	b.n	101b3cc <preempt+0x20>
		iter_idx = UINT8_MAX;
 101b460:	24ff      	movs	r4, #255	; 0xff
		iter = ull_prepare_dequeue_iter(&iter_idx);
 101b462:	f10d 000b 	add.w	r0, sp, #11
		iter_idx = UINT8_MAX;
 101b466:	f88d 400b 	strb.w	r4, [sp, #11]
		iter = ull_prepare_dequeue_iter(&iter_idx);
 101b46a:	f7f9 f96d 	bl	1014748 <ull_prepare_dequeue_iter>
		while (iter) {
 101b46e:	b928      	cbnz	r0, 101b47c <preempt+0xd0>
 101b470:	e013      	b.n	101b49a <preempt+0xee>
			iter = ull_prepare_dequeue_iter(&iter_idx);
 101b472:	f10d 000b 	add.w	r0, sp, #11
 101b476:	f7f9 f967 	bl	1014748 <ull_prepare_dequeue_iter>
		while (iter) {
 101b47a:	b170      	cbz	r0, 101b49a <preempt+0xee>
			if (!iter->is_aborted &&
 101b47c:	7f03      	ldrb	r3, [r0, #28]
 101b47e:	079a      	lsls	r2, r3, #30
 101b480:	d4f7      	bmi.n	101b472 <preempt+0xc6>
			    event.curr.param == iter->prepare_param.param) {
 101b482:	68c2      	ldr	r2, [r0, #12]
			if (!iter->is_aborted &&
 101b484:	6831      	ldr	r1, [r6, #0]
 101b486:	4291      	cmp	r1, r2
 101b488:	d1f3      	bne.n	101b472 <preempt+0xc6>
				iter->is_aborted = 1;
 101b48a:	f043 0302 	orr.w	r3, r3, #2
 101b48e:	7703      	strb	r3, [r0, #28]
				iter->abort_cb(&iter->prepare_param,
 101b490:	6983      	ldr	r3, [r0, #24]
 101b492:	4798      	blx	r3
				iter_idx = UINT8_MAX;
 101b494:	f88d 400b 	strb.w	r4, [sp, #11]
 101b498:	e7eb      	b.n	101b472 <preempt+0xc6>
	struct lll_prepare_param prepare_param = {0};
 101b49a:	2400      	movs	r4, #0
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
 101b49c:	e9d6 0101 	ldrd	r0, r1, [r6, #4]
 101b4a0:	2501      	movs	r5, #1
	prepare_param.param = event.curr.param;
 101b4a2:	6833      	ldr	r3, [r6, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
 101b4a4:	aa04      	add	r2, sp, #16
	prepare_param.param = event.curr.param;
 101b4a6:	9307      	str	r3, [sp, #28]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
 101b4a8:	9500      	str	r5, [sp, #0]
 101b4aa:	9b03      	ldr	r3, [sp, #12]
	event.curr.param = NULL;
 101b4ac:	6034      	str	r4, [r6, #0]
	struct lll_prepare_param prepare_param = {0};
 101b4ae:	e9cd 4405 	strd	r4, r4, [sp, #20]
 101b4b2:	9404      	str	r4, [sp, #16]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
 101b4b4:	f7f9 f906 	bl	10146c4 <ull_prepare_enqueue>
		LL_ASSERT(iter);
 101b4b8:	2800      	cmp	r0, #0
 101b4ba:	d187      	bne.n	101b3cc <preempt+0x20>
 101b4bc:	f240 4305 	movw	r3, #1029	; 0x405
 101b4c0:	4a06      	ldr	r2, [pc, #24]	; (101b4dc <preempt+0x130>)
 101b4c2:	490a      	ldr	r1, [pc, #40]	; (101b4ec <preempt+0x140>)
 101b4c4:	4807      	ldr	r0, [pc, #28]	; (101b4e4 <preempt+0x138>)
 101b4c6:	f009 fb86 	bl	1024bd6 <assert_print>
 101b4ca:	4040      	eors	r0, r0
 101b4cc:	f380 8811 	msr	BASEPRI, r0
 101b4d0:	f04f 0003 	mov.w	r0, #3
 101b4d4:	df02      	svc	2
 101b4d6:	e779      	b.n	101b3cc <preempt+0x20>
 101b4d8:	21007bac 	.word	0x21007bac
 101b4dc:	0102ae70 	.word	0x0102ae70
 101b4e0:	0102af48 	.word	0x0102af48
 101b4e4:	0102a278 	.word	0x0102a278
 101b4e8:	0102a768 	.word	0x0102a768
 101b4ec:	0102af40 	.word	0x0102af40

0101b4f0 <lll_init>:
{
 101b4f0:	b510      	push	{r4, lr}
 101b4f2:	4815      	ldr	r0, [pc, #84]	; (101b548 <lll_init+0x58>)
 101b4f4:	f00d fe98 	bl	1029228 <z_device_is_ready>
	if (!device_is_ready(dev_entropy)) {
 101b4f8:	b310      	cbz	r0, 101b540 <lll_init+0x50>
	event.curr.abort_cb = NULL;
 101b4fa:	2400      	movs	r4, #0
 101b4fc:	4b13      	ldr	r3, [pc, #76]	; (101b54c <lll_init+0x5c>)
 101b4fe:	609c      	str	r4, [r3, #8]
	err = lll_clock_init();
 101b500:	f000 fafe 	bl	101bb00 <lll_clock_init>
	if (err < 0) {
 101b504:	2800      	cmp	r0, #0
 101b506:	db1a      	blt.n	101b53e <lll_init+0x4e>
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
 101b508:	4621      	mov	r1, r4
 101b50a:	2008      	movs	r0, #8
 101b50c:	4622      	mov	r2, r4
 101b50e:	f7ea fc9b 	bl	1005e48 <z_arm_irq_priority_set>
	IRQ_CONNECT(RTC0_IRQn, CONFIG_BT_CTLR_ULL_HIGH_PRIO,
 101b512:	4622      	mov	r2, r4
 101b514:	2011      	movs	r0, #17
 101b516:	2101      	movs	r1, #1
 101b518:	f7ea fc96 	bl	1005e48 <z_arm_irq_priority_set>
	IRQ_CONNECT(HAL_SWI_RADIO_IRQ, CONFIG_BT_CTLR_LLL_PRIO,
 101b51c:	4622      	mov	r2, r4
 101b51e:	4621      	mov	r1, r4
 101b520:	201c      	movs	r0, #28
 101b522:	f7ea fc91 	bl	1005e48 <z_arm_irq_priority_set>
	irq_enable(RADIO_IRQn);
 101b526:	2008      	movs	r0, #8
 101b528:	f7ea fc5e 	bl	1005de8 <arch_irq_enable>
	irq_enable(RTC0_IRQn);
 101b52c:	2011      	movs	r0, #17
 101b52e:	f7ea fc5b 	bl	1005de8 <arch_irq_enable>
	irq_enable(HAL_SWI_RADIO_IRQ);
 101b532:	201c      	movs	r0, #28
 101b534:	f7ea fc58 	bl	1005de8 <arch_irq_enable>
	radio_setup();
 101b538:	f001 fe16 	bl	101d168 <radio_setup>
	return 0;
 101b53c:	4620      	mov	r0, r4
}
 101b53e:	bd10      	pop	{r4, pc}
		return -ENODEV;
 101b540:	f06f 0012 	mvn.w	r0, #18
}
 101b544:	bd10      	pop	{r4, pc}
 101b546:	bf00      	nop
 101b548:	01029730 	.word	0x01029730
 101b54c:	21007bac 	.word	0x21007bac

0101b550 <lll_deinit>:
{
 101b550:	b508      	push	{r3, lr}
	err = lll_clock_deinit();
 101b552:	f000 fae5 	bl	101bb20 <lll_clock_deinit>
	if (err < 0) {
 101b556:	2800      	cmp	r0, #0
 101b558:	db09      	blt.n	101b56e <lll_deinit+0x1e>
	irq_disable(RADIO_IRQn);
 101b55a:	2008      	movs	r0, #8
 101b55c:	f7ea fc52 	bl	1005e04 <arch_irq_disable>
	irq_disable(RTC0_IRQn);
 101b560:	2011      	movs	r0, #17
 101b562:	f7ea fc4f 	bl	1005e04 <arch_irq_disable>
	irq_disable(HAL_SWI_RADIO_IRQ);
 101b566:	201c      	movs	r0, #28
 101b568:	f7ea fc4c 	bl	1005e04 <arch_irq_disable>
	return 0;
 101b56c:	2000      	movs	r0, #0
}
 101b56e:	bd08      	pop	{r3, pc}

0101b570 <lll_csrand_get>:
{
 101b570:	460a      	mov	r2, r1
 101b572:	4601      	mov	r1, r0

static inline int z_impl_entropy_get_entropy(const struct device *dev,
					     uint8_t *buffer,
					     uint16_t length)
{
	const struct entropy_driver_api *api =
 101b574:	4809      	ldr	r0, [pc, #36]	; (101b59c <lll_csrand_get+0x2c>)
		(const struct entropy_driver_api *)dev->api;

	__ASSERT(api->get_entropy != NULL,
 101b576:	6883      	ldr	r3, [r0, #8]
 101b578:	681b      	ldr	r3, [r3, #0]
 101b57a:	b10b      	cbz	r3, 101b580 <lll_csrand_get+0x10>
 101b57c:	b292      	uxth	r2, r2
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
 101b57e:	4718      	bx	r3
	__ASSERT(api->get_entropy != NULL,
 101b580:	4907      	ldr	r1, [pc, #28]	; (101b5a0 <lll_csrand_get+0x30>)
 101b582:	234d      	movs	r3, #77	; 0x4d
 101b584:	b510      	push	{r4, lr}
 101b586:	4a07      	ldr	r2, [pc, #28]	; (101b5a4 <lll_csrand_get+0x34>)
 101b588:	4807      	ldr	r0, [pc, #28]	; (101b5a8 <lll_csrand_get+0x38>)
 101b58a:	f009 fb24 	bl	1024bd6 <assert_print>
 101b58e:	4807      	ldr	r0, [pc, #28]	; (101b5ac <lll_csrand_get+0x3c>)
 101b590:	f009 fb21 	bl	1024bd6 <assert_print>
 101b594:	214d      	movs	r1, #77	; 0x4d
 101b596:	4803      	ldr	r0, [pc, #12]	; (101b5a4 <lll_csrand_get+0x34>)
 101b598:	f009 fb16 	bl	1024bc8 <assert_post_action>
 101b59c:	01029730 	.word	0x01029730
 101b5a0:	0102af88 	.word	0x0102af88
 101b5a4:	0102af54 	.word	0x0102af54
 101b5a8:	0102a278 	.word	0x0102a278
 101b5ac:	0102afa8 	.word	0x0102afa8

0101b5b0 <lll_csrand_isr_get>:
{
 101b5b0:	b430      	push	{r4, r5}
static inline int entropy_get_entropy_isr(const struct device *dev,
					  uint8_t *buffer,
					  uint16_t length,
					  uint32_t flags)
{
	const struct entropy_driver_api *api =
 101b5b2:	4d07      	ldr	r5, [pc, #28]	; (101b5d0 <lll_csrand_isr_get+0x20>)
		(const struct entropy_driver_api *)dev->api;

	if (unlikely(!api->get_entropy_isr)) {
 101b5b4:	68ab      	ldr	r3, [r5, #8]
 101b5b6:	685c      	ldr	r4, [r3, #4]
 101b5b8:	b134      	cbz	r4, 101b5c8 <lll_csrand_isr_get+0x18>
		return -ENOTSUP;
	}

	return api->get_entropy_isr(dev, buffer, length, flags);
 101b5ba:	46a4      	mov	ip, r4
 101b5bc:	b28a      	uxth	r2, r1
 101b5be:	2300      	movs	r3, #0
 101b5c0:	4601      	mov	r1, r0
 101b5c2:	4628      	mov	r0, r5
}
 101b5c4:	bc30      	pop	{r4, r5}
 101b5c6:	4760      	bx	ip
 101b5c8:	f06f 0085 	mvn.w	r0, #133	; 0x85
 101b5cc:	bc30      	pop	{r4, r5}
 101b5ce:	4770      	bx	lr
 101b5d0:	01029730 	.word	0x01029730

0101b5d4 <lll_rand_isr_get>:
int lll_rand_isr_get(void *buf, size_t len)
 101b5d4:	b430      	push	{r4, r5}
 101b5d6:	4d07      	ldr	r5, [pc, #28]	; (101b5f4 <lll_rand_isr_get+0x20>)
 101b5d8:	68ab      	ldr	r3, [r5, #8]
 101b5da:	685c      	ldr	r4, [r3, #4]
 101b5dc:	b134      	cbz	r4, 101b5ec <lll_rand_isr_get+0x18>
 101b5de:	46a4      	mov	ip, r4
 101b5e0:	b28a      	uxth	r2, r1
 101b5e2:	2300      	movs	r3, #0
 101b5e4:	4601      	mov	r1, r0
 101b5e6:	4628      	mov	r0, r5
 101b5e8:	bc30      	pop	{r4, r5}
 101b5ea:	4760      	bx	ip
 101b5ec:	f06f 0085 	mvn.w	r0, #133	; 0x85
 101b5f0:	bc30      	pop	{r4, r5}
 101b5f2:	4770      	bx	lr
 101b5f4:	01029730 	.word	0x01029730

0101b5f8 <lll_reset>:
}
 101b5f8:	2000      	movs	r0, #0
 101b5fa:	4770      	bx	lr

0101b5fc <lll_disable>:
{
 101b5fc:	b530      	push	{r4, r5, lr}
	if (!param || (param == event.curr.param)) {
 101b5fe:	4604      	mov	r4, r0
{
 101b600:	b083      	sub	sp, #12
	if (!param || (param == event.curr.param)) {
 101b602:	b378      	cbz	r0, 101b664 <lll_disable+0x68>
 101b604:	4b23      	ldr	r3, [pc, #140]	; (101b694 <lll_disable+0x98>)
 101b606:	681a      	ldr	r2, [r3, #0]
 101b608:	4282      	cmp	r2, r0
 101b60a:	d025      	beq.n	101b658 <lll_disable+0x5c>
		idx = UINT8_MAX;
 101b60c:	25ff      	movs	r5, #255	; 0xff
		next = ull_prepare_dequeue_iter(&idx);
 101b60e:	f10d 0007 	add.w	r0, sp, #7
		idx = UINT8_MAX;
 101b612:	f88d 5007 	strb.w	r5, [sp, #7]
		next = ull_prepare_dequeue_iter(&idx);
 101b616:	f7f9 f897 	bl	1014748 <ull_prepare_dequeue_iter>
		while (next) {
 101b61a:	b938      	cbnz	r0, 101b62c <lll_disable+0x30>
 101b61c:	e01a      	b.n	101b654 <lll_disable+0x58>
			    (!param || (param == next->prepare_param.param))) {
 101b61e:	42a1      	cmp	r1, r4
 101b620:	d00a      	beq.n	101b638 <lll_disable+0x3c>
			next = ull_prepare_dequeue_iter(&idx);
 101b622:	f10d 0007 	add.w	r0, sp, #7
 101b626:	f7f9 f88f 	bl	1014748 <ull_prepare_dequeue_iter>
		while (next) {
 101b62a:	b198      	cbz	r0, 101b654 <lll_disable+0x58>
			if (!next->is_aborted &&
 101b62c:	7f03      	ldrb	r3, [r0, #28]
 101b62e:	079b      	lsls	r3, r3, #30
 101b630:	d4f7      	bmi.n	101b622 <lll_disable+0x26>
			    (!param || (param == next->prepare_param.param))) {
 101b632:	68c1      	ldr	r1, [r0, #12]
			if (!next->is_aborted &&
 101b634:	2c00      	cmp	r4, #0
 101b636:	d1f2      	bne.n	101b61e <lll_disable+0x22>
				next->is_aborted = 1;
 101b638:	7f03      	ldrb	r3, [r0, #28]
				next->abort_cb(&next->prepare_param,
 101b63a:	6982      	ldr	r2, [r0, #24]
				next->is_aborted = 1;
 101b63c:	f043 0302 	orr.w	r3, r3, #2
 101b640:	7703      	strb	r3, [r0, #28]
				next->abort_cb(&next->prepare_param,
 101b642:	4790      	blx	r2
			next = ull_prepare_dequeue_iter(&idx);
 101b644:	f10d 0007 	add.w	r0, sp, #7
				idx = UINT8_MAX;
 101b648:	f88d 5007 	strb.w	r5, [sp, #7]
			next = ull_prepare_dequeue_iter(&idx);
 101b64c:	f7f9 f87c 	bl	1014748 <ull_prepare_dequeue_iter>
		while (next) {
 101b650:	2800      	cmp	r0, #0
 101b652:	d1eb      	bne.n	101b62c <lll_disable+0x30>
}
 101b654:	b003      	add	sp, #12
 101b656:	bd30      	pop	{r4, r5, pc}
		if (event.curr.abort_cb && event.curr.param) {
 101b658:	689b      	ldr	r3, [r3, #8]
 101b65a:	b16b      	cbz	r3, 101b678 <lll_disable+0x7c>
 101b65c:	4601      	mov	r1, r0
			event.curr.abort_cb(NULL, event.curr.param);
 101b65e:	2000      	movs	r0, #0
 101b660:	4798      	blx	r3
 101b662:	e7d3      	b.n	101b60c <lll_disable+0x10>
		if (event.curr.abort_cb && event.curr.param) {
 101b664:	4a0b      	ldr	r2, [pc, #44]	; (101b694 <lll_disable+0x98>)
 101b666:	6893      	ldr	r3, [r2, #8]
 101b668:	2b00      	cmp	r3, #0
 101b66a:	d0cf      	beq.n	101b60c <lll_disable+0x10>
 101b66c:	6811      	ldr	r1, [r2, #0]
 101b66e:	2900      	cmp	r1, #0
 101b670:	d0cc      	beq.n	101b60c <lll_disable+0x10>
			event.curr.abort_cb(NULL, event.curr.param);
 101b672:	2000      	movs	r0, #0
 101b674:	4798      	blx	r3
 101b676:	e7c9      	b.n	101b60c <lll_disable+0x10>
			LL_ASSERT(!param);
 101b678:	f240 1311 	movw	r3, #273	; 0x111
 101b67c:	4a06      	ldr	r2, [pc, #24]	; (101b698 <lll_disable+0x9c>)
 101b67e:	4907      	ldr	r1, [pc, #28]	; (101b69c <lll_disable+0xa0>)
 101b680:	4807      	ldr	r0, [pc, #28]	; (101b6a0 <lll_disable+0xa4>)
 101b682:	f009 faa8 	bl	1024bd6 <assert_print>
 101b686:	4040      	eors	r0, r0
 101b688:	f380 8811 	msr	BASEPRI, r0
 101b68c:	f04f 0003 	mov.w	r0, #3
 101b690:	df02      	svc	2
 101b692:	e7bb      	b.n	101b60c <lll_disable+0x10>
 101b694:	21007bac 	.word	0x21007bac
 101b698:	0102ae70 	.word	0x0102ae70
 101b69c:	0102afd0 	.word	0x0102afd0
 101b6a0:	0102a278 	.word	0x0102a278

0101b6a4 <lll_prepare_done>:
}
 101b6a4:	2000      	movs	r0, #0
 101b6a6:	4770      	bx	lr

0101b6a8 <lll_done>:
{
 101b6a8:	b538      	push	{r3, r4, r5, lr}
 101b6aa:	4604      	mov	r4, r0
	next = ull_prepare_dequeue_get();
 101b6ac:	f7f9 f83e 	bl	101472c <ull_prepare_dequeue_get>
	LL_ASSERT(!param || next);
 101b6b0:	b154      	cbz	r4, 101b6c8 <lll_done+0x20>
 101b6b2:	b310      	cbz	r0, 101b6fa <lll_done+0x52>
			ull = HDR_LLL2ULL(param);
 101b6b4:	6824      	ldr	r4, [r4, #0]
	ull_prepare_dequeue(TICKER_USER_ID_LLL);
 101b6b6:	2000      	movs	r0, #0
 101b6b8:	f7f9 f866 	bl	1014788 <ull_prepare_dequeue>
	evdone = ull_event_done(ull);
 101b6bc:	4620      	mov	r0, r4
 101b6be:	f7f9 f8d7 	bl	1014870 <ull_event_done>
	LL_ASSERT(evdone);
 101b6c2:	b158      	cbz	r0, 101b6dc <lll_done+0x34>
}
 101b6c4:	2000      	movs	r0, #0
 101b6c6:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(event.curr.abort_cb);
 101b6c8:	4d1a      	ldr	r5, [pc, #104]	; (101b734 <lll_done+0x8c>)
 101b6ca:	68ab      	ldr	r3, [r5, #8]
 101b6cc:	b31b      	cbz	r3, 101b716 <lll_done+0x6e>
		event.curr.abort_cb = NULL;
 101b6ce:	2300      	movs	r3, #0
		param = event.curr.param;
 101b6d0:	682c      	ldr	r4, [r5, #0]
		event.curr.abort_cb = NULL;
 101b6d2:	60ab      	str	r3, [r5, #8]
		event.curr.param = NULL;
 101b6d4:	602b      	str	r3, [r5, #0]
		if (param) {
 101b6d6:	2c00      	cmp	r4, #0
 101b6d8:	d1ec      	bne.n	101b6b4 <lll_done+0xc>
 101b6da:	e7ec      	b.n	101b6b6 <lll_done+0xe>
	LL_ASSERT(evdone);
 101b6dc:	f44f 73c1 	mov.w	r3, #386	; 0x182
 101b6e0:	4a15      	ldr	r2, [pc, #84]	; (101b738 <lll_done+0x90>)
 101b6e2:	4916      	ldr	r1, [pc, #88]	; (101b73c <lll_done+0x94>)
 101b6e4:	4816      	ldr	r0, [pc, #88]	; (101b740 <lll_done+0x98>)
 101b6e6:	f009 fa76 	bl	1024bd6 <assert_print>
 101b6ea:	4040      	eors	r0, r0
 101b6ec:	f380 8811 	msr	BASEPRI, r0
 101b6f0:	f04f 0003 	mov.w	r0, #3
 101b6f4:	df02      	svc	2
}
 101b6f6:	2000      	movs	r0, #0
 101b6f8:	bd38      	pop	{r3, r4, r5, pc}
	LL_ASSERT(!param || next);
 101b6fa:	f240 134b 	movw	r3, #331	; 0x14b
 101b6fe:	4a0e      	ldr	r2, [pc, #56]	; (101b738 <lll_done+0x90>)
 101b700:	4910      	ldr	r1, [pc, #64]	; (101b744 <lll_done+0x9c>)
 101b702:	480f      	ldr	r0, [pc, #60]	; (101b740 <lll_done+0x98>)
 101b704:	f009 fa67 	bl	1024bd6 <assert_print>
 101b708:	4040      	eors	r0, r0
 101b70a:	f380 8811 	msr	BASEPRI, r0
 101b70e:	f04f 0003 	mov.w	r0, #3
 101b712:	df02      	svc	2
		ull = HDR_LLL2ULL(param);
 101b714:	e7ce      	b.n	101b6b4 <lll_done+0xc>
		LL_ASSERT(event.curr.abort_cb);
 101b716:	f44f 73a8 	mov.w	r3, #336	; 0x150
 101b71a:	4a07      	ldr	r2, [pc, #28]	; (101b738 <lll_done+0x90>)
 101b71c:	490a      	ldr	r1, [pc, #40]	; (101b748 <lll_done+0xa0>)
 101b71e:	4808      	ldr	r0, [pc, #32]	; (101b740 <lll_done+0x98>)
 101b720:	f009 fa59 	bl	1024bd6 <assert_print>
 101b724:	4040      	eors	r0, r0
 101b726:	f380 8811 	msr	BASEPRI, r0
 101b72a:	f04f 0003 	mov.w	r0, #3
 101b72e:	df02      	svc	2
 101b730:	e7cd      	b.n	101b6ce <lll_done+0x26>
 101b732:	bf00      	nop
 101b734:	21007bac 	.word	0x21007bac
 101b738:	0102ae70 	.word	0x0102ae70
 101b73c:	0102affc 	.word	0x0102affc
 101b740:	0102a278 	.word	0x0102a278
 101b744:	0102afd8 	.word	0x0102afd8
 101b748:	0102afe8 	.word	0x0102afe8

0101b74c <lll_is_abort_cb>:
}
 101b74c:	f06f 008b 	mvn.w	r0, #139	; 0x8b
 101b750:	4770      	bx	lr
 101b752:	bf00      	nop

0101b754 <lll_event_offset_get>:
		return MAX(ull->ticks_active_to_start,
 101b754:	e9d0 3201 	ldrd	r3, r2, [r0, #4]
	} else if (ull->ticks_prepare_to_start & XON_BITMASK) {
 101b758:	2a00      	cmp	r2, #0
 101b75a:	db04      	blt.n	101b766 <lll_event_offset_get+0x12>
		return MAX(ull->ticks_active_to_start,
 101b75c:	429a      	cmp	r2, r3
 101b75e:	bf38      	it	cc
 101b760:	461a      	movcc	r2, r3
 101b762:	4610      	mov	r0, r2
}
 101b764:	4770      	bx	lr
		return MAX(ull->ticks_active_to_start,
 101b766:	68c0      	ldr	r0, [r0, #12]
 101b768:	4298      	cmp	r0, r3
 101b76a:	bf38      	it	cc
 101b76c:	4618      	movcc	r0, r3
 101b76e:	4770      	bx	lr

0101b770 <lll_chan_set>:
	switch (chan) {
 101b770:	2826      	cmp	r0, #38	; 0x26
{
 101b772:	b510      	push	{r4, lr}
 101b774:	4604      	mov	r4, r0
	switch (chan) {
 101b776:	d01c      	beq.n	101b7b2 <lll_chan_set+0x42>
 101b778:	2827      	cmp	r0, #39	; 0x27
 101b77a:	d012      	beq.n	101b7a2 <lll_chan_set+0x32>
 101b77c:	2825      	cmp	r0, #37	; 0x25
 101b77e:	d008      	beq.n	101b792 <lll_chan_set+0x22>
		if (chan < 11) {
 101b780:	280a      	cmp	r0, #10
 101b782:	d91e      	bls.n	101b7c2 <lll_chan_set+0x52>
		} else if (chan < 40) {
 101b784:	2827      	cmp	r0, #39	; 0x27
 101b786:	d821      	bhi.n	101b7cc <lll_chan_set+0x5c>
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
 101b788:	3003      	adds	r0, #3
 101b78a:	0040      	lsls	r0, r0, #1
 101b78c:	f001 fd72 	bl	101d274 <radio_freq_chan_set>
 101b790:	e002      	b.n	101b798 <lll_chan_set+0x28>
		radio_freq_chan_set(2);
 101b792:	2002      	movs	r0, #2
 101b794:	f001 fd6e 	bl	101d274 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
 101b798:	4620      	mov	r0, r4
}
 101b79a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
 101b79e:	f001 bd6f 	b.w	101d280 <radio_whiten_iv_set>
		radio_freq_chan_set(80);
 101b7a2:	2050      	movs	r0, #80	; 0x50
 101b7a4:	f001 fd66 	bl	101d274 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
 101b7a8:	4620      	mov	r0, r4
}
 101b7aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
 101b7ae:	f001 bd67 	b.w	101d280 <radio_whiten_iv_set>
		radio_freq_chan_set(26);
 101b7b2:	201a      	movs	r0, #26
 101b7b4:	f001 fd5e 	bl	101d274 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
 101b7b8:	4620      	mov	r0, r4
}
 101b7ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
 101b7be:	f001 bd5f 	b.w	101d280 <radio_whiten_iv_set>
			radio_freq_chan_set(4 + (chan * 2U));
 101b7c2:	3002      	adds	r0, #2
 101b7c4:	0040      	lsls	r0, r0, #1
 101b7c6:	f001 fd55 	bl	101d274 <radio_freq_chan_set>
 101b7ca:	e7e5      	b.n	101b798 <lll_chan_set+0x28>
			LL_ASSERT(0);
 101b7cc:	f240 13f7 	movw	r3, #503	; 0x1f7
 101b7d0:	4a05      	ldr	r2, [pc, #20]	; (101b7e8 <lll_chan_set+0x78>)
 101b7d2:	4906      	ldr	r1, [pc, #24]	; (101b7ec <lll_chan_set+0x7c>)
 101b7d4:	4806      	ldr	r0, [pc, #24]	; (101b7f0 <lll_chan_set+0x80>)
 101b7d6:	f009 f9fe 	bl	1024bd6 <assert_print>
 101b7da:	4040      	eors	r0, r0
 101b7dc:	f380 8811 	msr	BASEPRI, r0
 101b7e0:	f04f 0003 	mov.w	r0, #3
 101b7e4:	df02      	svc	2
 101b7e6:	e7d7      	b.n	101b798 <lll_chan_set+0x28>
 101b7e8:	0102ae70 	.word	0x0102ae70
 101b7ec:	0102a300 	.word	0x0102a300
 101b7f0:	0102a278 	.word	0x0102a278

0101b7f4 <lll_radio_is_idle>:
	return radio_is_idle();
 101b7f4:	f001 be08 	b.w	101d408 <radio_is_idle>

0101b7f8 <lll_radio_rx_ready_delay_get>:
	return radio_rx_ready_delay_get(phy, flags);
 101b7f8:	f001 bda0 	b.w	101d33c <radio_rx_ready_delay_get>

0101b7fc <lll_isr_tx_status_reset>:
{
 101b7fc:	b508      	push	{r3, lr}
	radio_status_reset();
 101b7fe:	f001 fddd 	bl	101d3bc <radio_status_reset>
}
 101b802:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_status_reset();
 101b806:	f001 bf11 	b.w	101d62c <radio_tmr_status_reset>
 101b80a:	bf00      	nop

0101b80c <lll_isr_rx_status_reset>:
{
 101b80c:	b508      	push	{r3, lr}
	radio_status_reset();
 101b80e:	f001 fdd5 	bl	101d3bc <radio_status_reset>
	radio_tmr_status_reset();
 101b812:	f001 ff0b 	bl	101d62c <radio_tmr_status_reset>
}
 101b816:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_rssi_status_reset();
 101b81a:	f001 bed3 	b.w	101d5c4 <radio_rssi_status_reset>
 101b81e:	bf00      	nop

0101b820 <lll_isr_status_reset>:
{
 101b820:	b508      	push	{r3, lr}
	radio_status_reset();
 101b822:	f001 fdcb 	bl	101d3bc <radio_status_reset>
	radio_tmr_status_reset();
 101b826:	f001 ff01 	bl	101d62c <radio_tmr_status_reset>
	radio_filter_status_reset();
 101b82a:	f001 fee7 	bl	101d5fc <radio_filter_status_reset>
}
 101b82e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_rssi_status_reset();
 101b832:	f001 bec7 	b.w	101d5c4 <radio_rssi_status_reset>
 101b836:	bf00      	nop

0101b838 <lll_isr_cleanup>:
{
 101b838:	4601      	mov	r1, r0
 101b83a:	b508      	push	{r3, lr}
	radio_isr_set(isr_race, param);
 101b83c:	4817      	ldr	r0, [pc, #92]	; (101b89c <lll_isr_cleanup+0x64>)
 101b83e:	f001 fc73 	bl	101d128 <radio_isr_set>
	if (!radio_is_idle()) {
 101b842:	f001 fde1 	bl	101d408 <radio_is_idle>
 101b846:	b160      	cbz	r0, 101b862 <lll_isr_cleanup+0x2a>
	radio_tmr_stop();
 101b848:	f001 ff90 	bl	101d76c <radio_tmr_stop>
	radio_stop();
 101b84c:	f001 fcb4 	bl	101d1b8 <radio_stop>
	err = lll_hfclock_off();
 101b850:	f000 f99e 	bl	101bb90 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
 101b854:	2800      	cmp	r0, #0
 101b856:	db0e      	blt.n	101b876 <lll_isr_cleanup+0x3e>
}
 101b858:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
 101b85c:	2000      	movs	r0, #0
 101b85e:	f7ff bf23 	b.w	101b6a8 <lll_done>
		radio_disable();
 101b862:	f001 fd8d 	bl	101d380 <radio_disable>
	radio_tmr_stop();
 101b866:	f001 ff81 	bl	101d76c <radio_tmr_stop>
	radio_stop();
 101b86a:	f001 fca5 	bl	101d1b8 <radio_stop>
	err = lll_hfclock_off();
 101b86e:	f000 f98f 	bl	101bb90 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
 101b872:	2800      	cmp	r0, #0
 101b874:	daf0      	bge.n	101b858 <lll_isr_cleanup+0x20>
 101b876:	f240 235d 	movw	r3, #605	; 0x25d
 101b87a:	4a09      	ldr	r2, [pc, #36]	; (101b8a0 <lll_isr_cleanup+0x68>)
 101b87c:	4909      	ldr	r1, [pc, #36]	; (101b8a4 <lll_isr_cleanup+0x6c>)
 101b87e:	480a      	ldr	r0, [pc, #40]	; (101b8a8 <lll_isr_cleanup+0x70>)
 101b880:	f009 f9a9 	bl	1024bd6 <assert_print>
 101b884:	4040      	eors	r0, r0
 101b886:	f380 8811 	msr	BASEPRI, r0
 101b88a:	f04f 0003 	mov.w	r0, #3
 101b88e:	df02      	svc	2
}
 101b890:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
 101b894:	2000      	movs	r0, #0
 101b896:	f7ff bf07 	b.w	101b6a8 <lll_done>
 101b89a:	bf00      	nop
 101b89c:	0101b1a9 	.word	0x0101b1a9
 101b8a0:	0102ae70 	.word	0x0102ae70
 101b8a4:	0102b004 	.word	0x0102b004
 101b8a8:	0102a278 	.word	0x0102a278

0101b8ac <lll_isr_abort>:
{
 101b8ac:	b510      	push	{r4, lr}
 101b8ae:	4604      	mov	r4, r0
	radio_status_reset();
 101b8b0:	f001 fd84 	bl	101d3bc <radio_status_reset>
	radio_tmr_status_reset();
 101b8b4:	f001 feba 	bl	101d62c <radio_tmr_status_reset>
	radio_filter_status_reset();
 101b8b8:	f001 fea0 	bl	101d5fc <radio_filter_status_reset>
	radio_rssi_status_reset();
 101b8bc:	f001 fe82 	bl	101d5c4 <radio_rssi_status_reset>
	lll_isr_cleanup(param);
 101b8c0:	4620      	mov	r0, r4
}
 101b8c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
 101b8c6:	f7ff bfb7 	b.w	101b838 <lll_isr_cleanup>
 101b8ca:	bf00      	nop

0101b8cc <lll_isr_early_abort>:
{
 101b8cc:	4601      	mov	r1, r0
 101b8ce:	b508      	push	{r3, lr}
	radio_isr_set(isr_race, param);
 101b8d0:	4813      	ldr	r0, [pc, #76]	; (101b920 <lll_isr_early_abort+0x54>)
 101b8d2:	f001 fc29 	bl	101d128 <radio_isr_set>
	if (!radio_is_idle()) {
 101b8d6:	f001 fd97 	bl	101d408 <radio_is_idle>
 101b8da:	b140      	cbz	r0, 101b8ee <lll_isr_early_abort+0x22>
	err = lll_hfclock_off();
 101b8dc:	f000 f958 	bl	101bb90 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
 101b8e0:	2800      	cmp	r0, #0
 101b8e2:	db0a      	blt.n	101b8fa <lll_isr_early_abort+0x2e>
}
 101b8e4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
 101b8e8:	2000      	movs	r0, #0
 101b8ea:	f7ff bedd 	b.w	101b6a8 <lll_done>
		radio_disable();
 101b8ee:	f001 fd47 	bl	101d380 <radio_disable>
	err = lll_hfclock_off();
 101b8f2:	f000 f94d 	bl	101bb90 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
 101b8f6:	2800      	cmp	r0, #0
 101b8f8:	daf4      	bge.n	101b8e4 <lll_isr_early_abort+0x18>
 101b8fa:	f44f 731b 	mov.w	r3, #620	; 0x26c
 101b8fe:	4a09      	ldr	r2, [pc, #36]	; (101b924 <lll_isr_early_abort+0x58>)
 101b900:	4909      	ldr	r1, [pc, #36]	; (101b928 <lll_isr_early_abort+0x5c>)
 101b902:	480a      	ldr	r0, [pc, #40]	; (101b92c <lll_isr_early_abort+0x60>)
 101b904:	f009 f967 	bl	1024bd6 <assert_print>
 101b908:	4040      	eors	r0, r0
 101b90a:	f380 8811 	msr	BASEPRI, r0
 101b90e:	f04f 0003 	mov.w	r0, #3
 101b912:	df02      	svc	2
}
 101b914:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
 101b918:	2000      	movs	r0, #0
 101b91a:	f7ff bec5 	b.w	101b6a8 <lll_done>
 101b91e:	bf00      	nop
 101b920:	0101b1a9 	.word	0x0101b1a9
 101b924:	0102ae70 	.word	0x0102ae70
 101b928:	0102b004 	.word	0x0102b004
 101b92c:	0102a278 	.word	0x0102a278

0101b930 <lll_prepare_resolve>:
{
 101b930:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	idx = UINT8_MAX;
 101b934:	24ff      	movs	r4, #255	; 0xff
{
 101b936:	b084      	sub	sp, #16
 101b938:	4606      	mov	r6, r0
	p = ull_prepare_dequeue_iter(&idx);
 101b93a:	f10d 000f 	add.w	r0, sp, #15
	idx = UINT8_MAX;
 101b93e:	f88d 400f 	strb.w	r4, [sp, #15]
{
 101b942:	460f      	mov	r7, r1
 101b944:	4690      	mov	r8, r2
 101b946:	461d      	mov	r5, r3
 101b948:	f89d 9030 	ldrb.w	r9, [sp, #48]	; 0x30
	p = ull_prepare_dequeue_iter(&idx);
 101b94c:	f7f8 fefc 	bl	1014748 <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
 101b950:	4604      	mov	r4, r0
 101b952:	b938      	cbnz	r0, 101b964 <lll_prepare_resolve+0x34>
 101b954:	e03b      	b.n	101b9ce <lll_prepare_resolve+0x9e>
		p = ull_prepare_dequeue_iter(&idx);
 101b956:	f10d 000f 	add.w	r0, sp, #15
 101b95a:	f7f8 fef5 	bl	1014748 <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
 101b95e:	4604      	mov	r4, r0
 101b960:	2800      	cmp	r0, #0
 101b962:	d034      	beq.n	101b9ce <lll_prepare_resolve+0x9e>
 101b964:	f894 c01c 	ldrb.w	ip, [r4, #28]
 101b968:	f01c 0f03 	tst.w	ip, #3
 101b96c:	d1f3      	bne.n	101b956 <lll_prepare_resolve+0x26>
	    event.curr.abort_cb ||
 101b96e:	f8df a11c 	ldr.w	sl, [pc, #284]	; 101ba8c <lll_prepare_resolve+0x15c>
	if ((!is_dequeue && !is_done_sync()) ||
 101b972:	f8da 3008 	ldr.w	r3, [sl, #8]
 101b976:	2b00      	cmp	r3, #0
 101b978:	d130      	bne.n	101b9dc <lll_prepare_resolve+0xac>
	    (p && is_resume)) {
 101b97a:	f1b9 0f00 	cmp.w	r9, #0
 101b97e:	d16b      	bne.n	101ba58 <lll_prepare_resolve+0x128>
	LL_ASSERT(!p || &p->prepare_param == prepare_param);
 101b980:	42ac      	cmp	r4, r5
 101b982:	d00c      	beq.n	101b99e <lll_prepare_resolve+0x6e>
 101b984:	f240 23db 	movw	r3, #731	; 0x2db
 101b988:	4a41      	ldr	r2, [pc, #260]	; (101ba90 <lll_prepare_resolve+0x160>)
 101b98a:	4942      	ldr	r1, [pc, #264]	; (101ba94 <lll_prepare_resolve+0x164>)
 101b98c:	4842      	ldr	r0, [pc, #264]	; (101ba98 <lll_prepare_resolve+0x168>)
 101b98e:	f009 f922 	bl	1024bd6 <assert_print>
 101b992:	4040      	eors	r0, r0
 101b994:	f380 8811 	msr	BASEPRI, r0
 101b998:	f04f 0003 	mov.w	r0, #3
 101b99c:	df02      	svc	2
	event.curr.param = prepare_param->param;
 101b99e:	68eb      	ldr	r3, [r5, #12]
	err = prepare_cb(prepare_param);
 101b9a0:	4628      	mov	r0, r5
	event.curr.abort_cb = abort_cb;
 101b9a2:	e9ca 6701 	strd	r6, r7, [sl, #4]
	event.curr.param = prepare_param->param;
 101b9a6:	f8ca 3000 	str.w	r3, [sl]
	err = prepare_cb(prepare_param);
 101b9aa:	47c0      	blx	r8
 101b9ac:	4604      	mov	r4, r0
 101b9ae:	e003      	b.n	101b9b8 <lll_prepare_resolve+0x88>
	} while (p->is_aborted || p->is_resume);
 101b9b0:	7f01      	ldrb	r1, [r0, #28]
 101b9b2:	f011 0103 	ands.w	r1, r1, #3
 101b9b6:	d039      	beq.n	101ba2c <lll_prepare_resolve+0xfc>
		p = ull_prepare_dequeue_iter(&idx);
 101b9b8:	f10d 000f 	add.w	r0, sp, #15
 101b9bc:	f7f8 fec4 	bl	1014748 <ull_prepare_dequeue_iter>
 101b9c0:	4602      	mov	r2, r0
		if (!p) {
 101b9c2:	2800      	cmp	r0, #0
 101b9c4:	d1f4      	bne.n	101b9b0 <lll_prepare_resolve+0x80>
}
 101b9c6:	4620      	mov	r0, r4
 101b9c8:	b004      	add	sp, #16
 101b9ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	    event.curr.abort_cb ||
 101b9ce:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 101ba8c <lll_prepare_resolve+0x15c>
	if ((!is_dequeue && !is_done_sync()) ||
 101b9d2:	f8da 3008 	ldr.w	r3, [sl, #8]
 101b9d6:	2b00      	cmp	r3, #0
 101b9d8:	d0e1      	beq.n	101b99e <lll_prepare_resolve+0x6e>
{
 101b9da:	2400      	movs	r4, #0
		next = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
 101b9dc:	462a      	mov	r2, r5
 101b9de:	4643      	mov	r3, r8
 101b9e0:	4639      	mov	r1, r7
 101b9e2:	4630      	mov	r0, r6
 101b9e4:	f8cd 9000 	str.w	r9, [sp]
 101b9e8:	f7f8 fe6c 	bl	10146c4 <ull_prepare_enqueue>
		LL_ASSERT(next);
 101b9ec:	4602      	mov	r2, r0
 101b9ee:	2800      	cmp	r0, #0
 101b9f0:	d03c      	beq.n	101ba6c <lll_prepare_resolve+0x13c>
		if (is_resume) {
 101b9f2:	f1b9 0f00 	cmp.w	r9, #0
 101b9f6:	d116      	bne.n	101ba26 <lll_prepare_resolve+0xf6>
		ret  = preempt_ticker_start(first, p, next);
 101b9f8:	2c00      	cmp	r4, #0
 101b9fa:	bf14      	ite	ne
 101b9fc:	4620      	movne	r0, r4
 101b9fe:	4610      	moveq	r0, r2
 101ba00:	4621      	mov	r1, r4
 101ba02:	f7ff fc13 	bl	101b22c <preempt_ticker_start>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 101ba06:	f030 0302 	bics.w	r3, r0, #2
 101ba0a:	d00c      	beq.n	101ba26 <lll_prepare_resolve+0xf6>
 101ba0c:	f240 23b5 	movw	r3, #693	; 0x2b5
 101ba10:	4a1f      	ldr	r2, [pc, #124]	; (101ba90 <lll_prepare_resolve+0x160>)
 101ba12:	4922      	ldr	r1, [pc, #136]	; (101ba9c <lll_prepare_resolve+0x16c>)
 101ba14:	4820      	ldr	r0, [pc, #128]	; (101ba98 <lll_prepare_resolve+0x168>)
 101ba16:	f009 f8de 	bl	1024bd6 <assert_print>
 101ba1a:	4040      	eors	r0, r0
 101ba1c:	f380 8811 	msr	BASEPRI, r0
 101ba20:	f04f 0003 	mov.w	r0, #3
 101ba24:	df02      	svc	2
			return -EINPROGRESS;
 101ba26:	f06f 0476 	mvn.w	r4, #118	; 0x76
 101ba2a:	e7cc      	b.n	101b9c6 <lll_prepare_resolve+0x96>
	ret = preempt_ticker_start(p, NULL, p);
 101ba2c:	f7ff fbfe 	bl	101b22c <preempt_ticker_start>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 101ba30:	f030 0302 	bics.w	r3, r0, #2
 101ba34:	d0c7      	beq.n	101b9c6 <lll_prepare_resolve+0x96>
 101ba36:	f44f 733e 	mov.w	r3, #760	; 0x2f8
 101ba3a:	4a15      	ldr	r2, [pc, #84]	; (101ba90 <lll_prepare_resolve+0x160>)
 101ba3c:	4917      	ldr	r1, [pc, #92]	; (101ba9c <lll_prepare_resolve+0x16c>)
 101ba3e:	4816      	ldr	r0, [pc, #88]	; (101ba98 <lll_prepare_resolve+0x168>)
 101ba40:	f009 f8c9 	bl	1024bd6 <assert_print>
 101ba44:	4040      	eors	r0, r0
 101ba46:	f380 8811 	msr	BASEPRI, r0
 101ba4a:	f04f 0003 	mov.w	r0, #3
 101ba4e:	df02      	svc	2
}
 101ba50:	4620      	mov	r0, r4
 101ba52:	b004      	add	sp, #16
 101ba54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		next = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
 101ba58:	4643      	mov	r3, r8
 101ba5a:	462a      	mov	r2, r5
 101ba5c:	4639      	mov	r1, r7
 101ba5e:	4630      	mov	r0, r6
 101ba60:	f8cd 9000 	str.w	r9, [sp]
 101ba64:	f7f8 fe2e 	bl	10146c4 <ull_prepare_enqueue>
		LL_ASSERT(next);
 101ba68:	2800      	cmp	r0, #0
 101ba6a:	d1dc      	bne.n	101ba26 <lll_prepare_resolve+0xf6>
 101ba6c:	f44f 732a 	mov.w	r3, #680	; 0x2a8
 101ba70:	4a07      	ldr	r2, [pc, #28]	; (101ba90 <lll_prepare_resolve+0x160>)
 101ba72:	490b      	ldr	r1, [pc, #44]	; (101baa0 <lll_prepare_resolve+0x170>)
 101ba74:	4808      	ldr	r0, [pc, #32]	; (101ba98 <lll_prepare_resolve+0x168>)
 101ba76:	f009 f8ae 	bl	1024bd6 <assert_print>
 101ba7a:	4040      	eors	r0, r0
 101ba7c:	f380 8811 	msr	BASEPRI, r0
 101ba80:	f04f 0003 	mov.w	r0, #3
 101ba84:	df02      	svc	2
 101ba86:	2200      	movs	r2, #0
 101ba88:	e7b3      	b.n	101b9f2 <lll_prepare_resolve+0xc2>
 101ba8a:	bf00      	nop
 101ba8c:	21007bac 	.word	0x21007bac
 101ba90:	0102ae70 	.word	0x0102ae70
 101ba94:	0102b044 	.word	0x0102b044
 101ba98:	0102a278 	.word	0x0102a278
 101ba9c:	0102a768 	.word	0x0102a768
 101baa0:	0102b03c 	.word	0x0102b03c

0101baa4 <clock_ready>:
	z_impl_k_sem_give(sem);
 101baa4:	f101 0010 	add.w	r0, r1, #16
 101baa8:	f005 bdfa 	b.w	10216a0 <z_impl_k_sem_give>

0101baac <blocking_on>:

	k_sem_give(&clk_state->sem);
}

static int blocking_on(struct onoff_manager *mgr, uint32_t timeout)
{
 101baac:	b570      	push	{r4, r5, r6, lr}
 101baae:	4605      	mov	r5, r0
 101bab0:	460c      	mov	r4, r1
 101bab2:	b08a      	sub	sp, #40	; 0x28
	return z_impl_k_sem_init(sem, initial_count, limit);
 101bab4:	2201      	movs	r2, #1
 101bab6:	2100      	movs	r1, #0
 101bab8:	a804      	add	r0, sp, #16
 101baba:	f00d fc2c 	bl	1029316 <z_impl_k_sem_init>
					      sys_notify_generic_callback handler)
{
	__ASSERT_NO_MSG(notify != NULL);
	__ASSERT_NO_MSG(handler != NULL);

	*notify = (struct sys_notify){
 101babe:	2303      	movs	r3, #3
 101bac0:	2600      	movs	r6, #0
 101bac2:	9302      	str	r3, [sp, #8]
 101bac4:	4b0d      	ldr	r3, [pc, #52]	; (101bafc <blocking_on+0x50>)
	struct lll_clock_state state;
	int err;

	k_sem_init(&state.sem, 0, 1);
	sys_notify_init_callback(&state.cli.notify, clock_ready);
	err = onoff_request(mgr, &state.cli);
 101bac6:	4669      	mov	r1, sp
 101bac8:	4628      	mov	r0, r5
 101baca:	9603      	str	r6, [sp, #12]
 101bacc:	9301      	str	r3, [sp, #4]
 101bace:	f7e7 fb6b 	bl	10031a8 <onoff_request>
	if (err < 0) {
 101bad2:	2800      	cmp	r0, #0
 101bad4:	db10      	blt.n	101baf8 <blocking_on+0x4c>
 101bad6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 101bada:	4631      	mov	r1, r6
 101badc:	f240 30e7 	movw	r0, #999	; 0x3e7
 101bae0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 101bae4:	fbe4 0103 	umlal	r0, r1, r4, r3
 101bae8:	2300      	movs	r3, #0
 101baea:	f7e4 fae5 	bl	10000b8 <__aeabi_uldivmod>
 101baee:	4602      	mov	r2, r0
 101baf0:	460b      	mov	r3, r1
	return z_impl_k_sem_take(sem, timeout);
 101baf2:	a804      	add	r0, sp, #16
 101baf4:	f005 fe18 	bl	1021728 <z_impl_k_sem_take>
		return err;
	}

	return k_sem_take(&state.sem, K_MSEC(timeout));
}
 101baf8:	b00a      	add	sp, #40	; 0x28
 101bafa:	bd70      	pop	{r4, r5, r6, pc}
 101bafc:	0101baa5 	.word	0x0101baa5

0101bb00 <lll_clock_init>:

int lll_clock_init(void)
{
 101bb00:	b510      	push	{r4, lr}
	struct onoff_manager *mgr =
		z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_LF);
 101bb02:	2001      	movs	r0, #1
 101bb04:	f002 fd9c 	bl	101e640 <z_nrf_clock_control_get_onoff>
	*notify = (struct sys_notify){
 101bb08:	2401      	movs	r4, #1
 101bb0a:	2300      	movs	r3, #0
 101bb0c:	4903      	ldr	r1, [pc, #12]	; (101bb1c <lll_clock_init+0x1c>)
 101bb0e:	604b      	str	r3, [r1, #4]
 101bb10:	608c      	str	r4, [r1, #8]
 101bb12:	60cb      	str	r3, [r1, #12]

	sys_notify_init_spinwait(&lf_cli.notify);

	return onoff_request(mgr, &lf_cli);
}
 101bb14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return onoff_request(mgr, &lf_cli);
 101bb18:	f7e7 bb46 	b.w	10031a8 <onoff_request>
 101bb1c:	21007bbc 	.word	0x21007bbc

0101bb20 <lll_clock_deinit>:

int lll_clock_deinit(void)
{
 101bb20:	b508      	push	{r3, lr}
	struct onoff_manager *mgr =
		z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_LF);
 101bb22:	2001      	movs	r0, #1
 101bb24:	f002 fd8c 	bl	101e640 <z_nrf_clock_control_get_onoff>

	return onoff_release(mgr);
}
 101bb28:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return onoff_release(mgr);
 101bb2c:	f7e7 bbd4 	b.w	10032d8 <onoff_release>

0101bb30 <lll_clock_wait>:
{
	struct onoff_manager *mgr;
	static bool done;
	int err;

	if (done) {
 101bb30:	4b0c      	ldr	r3, [pc, #48]	; (101bb64 <lll_clock_wait+0x34>)
 101bb32:	781a      	ldrb	r2, [r3, #0]
 101bb34:	b10a      	cbz	r2, 101bb3a <lll_clock_wait+0xa>
		return 0;
 101bb36:	2000      	movs	r0, #0
	if (err != ONOFF_STATE_ON) {
		return -EIO;
	}

	return 0;
}
 101bb38:	4770      	bx	lr
	done = true;
 101bb3a:	2001      	movs	r0, #1
{
 101bb3c:	b510      	push	{r4, lr}
	done = true;
 101bb3e:	7018      	strb	r0, [r3, #0]
	mgr = z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_LF);
 101bb40:	f002 fd7e 	bl	101e640 <z_nrf_clock_control_get_onoff>
	err = blocking_on(mgr, LFCLOCK_TIMEOUT_MS);
 101bb44:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
	mgr = z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_LF);
 101bb48:	4604      	mov	r4, r0
	err = blocking_on(mgr, LFCLOCK_TIMEOUT_MS);
 101bb4a:	f7ff ffaf 	bl	101baac <blocking_on>
	if (err) {
 101bb4e:	b938      	cbnz	r0, 101bb60 <lll_clock_wait+0x30>
	err = onoff_release(mgr);
 101bb50:	4620      	mov	r0, r4
 101bb52:	f7e7 fbc1 	bl	10032d8 <onoff_release>
	if (err != ONOFF_STATE_ON) {
 101bb56:	2802      	cmp	r0, #2
		return 0;
 101bb58:	bf0c      	ite	eq
 101bb5a:	2000      	moveq	r0, #0
		return -EIO;
 101bb5c:	f06f 0004 	mvnne.w	r0, #4
}
 101bb60:	bd10      	pop	{r4, pc}
 101bb62:	bf00      	nop
 101bb64:	21008351 	.word	0x21008351

0101bb68 <lll_hfclock_on>:

int lll_hfclock_on(void)
{
 101bb68:	b508      	push	{r3, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 101bb6a:	4b08      	ldr	r3, [pc, #32]	; (101bb8c <lll_hfclock_on+0x24>)
 101bb6c:	e8d3 2fef 	ldaex	r2, [r3]
 101bb70:	1c51      	adds	r1, r2, #1
 101bb72:	e8c3 1fe0 	stlex	r0, r1, [r3]
 101bb76:	2800      	cmp	r0, #0
 101bb78:	d1f8      	bne.n	101bb6c <lll_hfclock_on+0x4>
	if (atomic_inc(&hf_refcnt) > 0) {
 101bb7a:	2a00      	cmp	r2, #0
 101bb7c:	dd01      	ble.n	101bb82 <lll_hfclock_on+0x1a>

	z_nrf_clock_bt_ctlr_hf_request();
	DEBUG_RADIO_XTAL(1);

	return 0;
}
 101bb7e:	2000      	movs	r0, #0
 101bb80:	bd08      	pop	{r3, pc}
	z_nrf_clock_bt_ctlr_hf_request();
 101bb82:	f002 fd65 	bl	101e650 <z_nrf_clock_bt_ctlr_hf_request>
}
 101bb86:	2000      	movs	r0, #0
 101bb88:	bd08      	pop	{r3, pc}
 101bb8a:	bf00      	nop
 101bb8c:	21007bb8 	.word	0x21007bb8

0101bb90 <lll_hfclock_off>:

	return err;
}

int lll_hfclock_off(void)
{
 101bb90:	b508      	push	{r3, lr}
	if (hf_refcnt < 1) {
 101bb92:	4b0a      	ldr	r3, [pc, #40]	; (101bbbc <lll_hfclock_off+0x2c>)
 101bb94:	681a      	ldr	r2, [r3, #0]
 101bb96:	2a00      	cmp	r2, #0
 101bb98:	dd0d      	ble.n	101bbb6 <lll_hfclock_off+0x26>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 101bb9a:	e8d3 2fef 	ldaex	r2, [r3]
 101bb9e:	1e51      	subs	r1, r2, #1
 101bba0:	e8c3 1fe0 	stlex	r0, r1, [r3]
 101bba4:	2800      	cmp	r0, #0
 101bba6:	d1f8      	bne.n	101bb9a <lll_hfclock_off+0xa>
		return -EALREADY;
	}

	if (atomic_dec(&hf_refcnt) > 1) {
 101bba8:	2a01      	cmp	r2, #1
 101bbaa:	dd01      	ble.n	101bbb0 <lll_hfclock_off+0x20>
		return 0;
 101bbac:	2000      	movs	r0, #0

	z_nrf_clock_bt_ctlr_hf_release();
	DEBUG_RADIO_XTAL(0);

	return 0;
}
 101bbae:	bd08      	pop	{r3, pc}
	z_nrf_clock_bt_ctlr_hf_release();
 101bbb0:	f002 fd60 	bl	101e674 <z_nrf_clock_bt_ctlr_hf_release>
	return 0;
 101bbb4:	e7fa      	b.n	101bbac <lll_hfclock_off+0x1c>
		return -EALREADY;
 101bbb6:	f06f 0077 	mvn.w	r0, #119	; 0x77
}
 101bbba:	bd08      	pop	{r3, pc}
 101bbbc:	21007bb8 	.word	0x21007bb8

0101bbc0 <lll_clock_ppm_local_get>:
}

uint32_t lll_clock_ppm_local_get(void)
{
	return sca_ppm_lut[CLOCK_CONTROL_NRF_K32SRC_ACCURACY];
}
 101bbc0:	2032      	movs	r0, #50	; 0x32
 101bbc2:	4770      	bx	lr

0101bbc4 <lll_clock_ppm_get>:

uint32_t lll_clock_ppm_get(uint8_t sca)
{
	return sca_ppm_lut[sca];
 101bbc4:	4b01      	ldr	r3, [pc, #4]	; (101bbcc <lll_clock_ppm_get+0x8>)
}
 101bbc6:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 101bbca:	4770      	bx	lr
 101bbcc:	0102b084 	.word	0x0102b084

0101bbd0 <isr_abort>:

	lll_isr_cleanup(param);
}

static void isr_abort(void *param)
{
 101bbd0:	b510      	push	{r4, lr}
 101bbd2:	4604      	mov	r4, r0
	/* Clear radio status and events */
	lll_isr_status_reset();
 101bbd4:	f7ff fe24 	bl	101b820 <lll_isr_status_reset>

	/* Disable any filter that was setup */
	radio_filter_disable();
 101bbd8:	f001 fd06 	bl	101d5e8 <radio_filter_disable>

	/* Current LLL radio event is done*/
	lll_isr_cleanup(param);
 101bbdc:	4620      	mov	r0, r4
}
 101bbde:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
 101bbe2:	f7ff be29 	b.w	101b838 <lll_isr_cleanup>
 101bbe6:	bf00      	nop

0101bbe8 <isr_tx>:
{
 101bbe8:	b538      	push	{r3, r4, r5, lr}
 101bbea:	4605      	mov	r5, r0
	lll_isr_tx_status_reset();
 101bbec:	f7ff fe06 	bl	101b7fc <lll_isr_tx_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
 101bbf0:	2096      	movs	r0, #150	; 0x96
 101bbf2:	f001 fd2b 	bl	101d64c <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(phy_p, 0, phy_p, phy_flags);
 101bbf6:	2300      	movs	r3, #0
 101bbf8:	4618      	mov	r0, r3
 101bbfa:	461a      	mov	r2, r3
 101bbfc:	4619      	mov	r1, r3
 101bbfe:	f001 fc6d 	bl	101d4dc <radio_switch_complete_and_tx>
	node_rx = ull_pdu_rx_alloc_peek(1);
 101bc02:	2001      	movs	r0, #1
 101bc04:	f7f8 fcf6 	bl	10145f4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 101bc08:	4604      	mov	r4, r0
 101bc0a:	b368      	cbz	r0, 101bc68 <isr_tx+0x80>
	radio_pkt_rx_set(node_rx->pdu);
 101bc0c:	f104 001c 	add.w	r0, r4, #28
 101bc10:	f001 fb86 	bl	101d320 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
 101bc14:	f001 fbe4 	bl	101d3e0 <radio_is_ready>
 101bc18:	b9c0      	cbnz	r0, 101bc4c <isr_tx+0x64>
	radio_isr_set(isr_rx, param);
 101bc1a:	4629      	mov	r1, r5
 101bc1c:	4819      	ldr	r0, [pc, #100]	; (101bc84 <isr_tx+0x9c>)
 101bc1e:	f001 fa83 	bl	101d128 <radio_isr_set>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
 101bc22:	f001 fe23 	bl	101d86c <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(phy_p, 0);
 101bc26:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
 101bc28:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(phy_p, 0);
 101bc2a:	4608      	mov	r0, r1
 101bc2c:	f001 fb88 	bl	101d340 <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(phy_p, 0);
 101bc30:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(phy_p, 0);
 101bc32:	4605      	mov	r5, r0
	hcto -= radio_tx_chain_delay_get(phy_p, 0);
 101bc34:	4608      	mov	r0, r1
 101bc36:	f001 fb7f 	bl	101d338 <radio_tx_chain_delay_get>
 101bc3a:	442c      	add	r4, r5
 101bc3c:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
 101bc3e:	1a20      	subs	r0, r4, r0
 101bc40:	f001 fda0 	bl	101d784 <radio_tmr_hcto_configure>
}
 101bc44:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_tmr_end_capture();
 101bc48:	f001 bdf2 	b.w	101d830 <radio_tmr_end_capture>
	LL_ASSERT(!radio_is_ready());
 101bc4c:	f240 4385 	movw	r3, #1157	; 0x485
 101bc50:	4a0d      	ldr	r2, [pc, #52]	; (101bc88 <isr_tx+0xa0>)
 101bc52:	490e      	ldr	r1, [pc, #56]	; (101bc8c <isr_tx+0xa4>)
 101bc54:	480e      	ldr	r0, [pc, #56]	; (101bc90 <isr_tx+0xa8>)
 101bc56:	f008 ffbe 	bl	1024bd6 <assert_print>
 101bc5a:	4040      	eors	r0, r0
 101bc5c:	f380 8811 	msr	BASEPRI, r0
 101bc60:	f04f 0003 	mov.w	r0, #3
 101bc64:	df02      	svc	2
 101bc66:	e7d8      	b.n	101bc1a <isr_tx+0x32>
	LL_ASSERT(node_rx);
 101bc68:	f240 4381 	movw	r3, #1153	; 0x481
 101bc6c:	4a06      	ldr	r2, [pc, #24]	; (101bc88 <isr_tx+0xa0>)
 101bc6e:	4909      	ldr	r1, [pc, #36]	; (101bc94 <isr_tx+0xac>)
 101bc70:	4807      	ldr	r0, [pc, #28]	; (101bc90 <isr_tx+0xa8>)
 101bc72:	f008 ffb0 	bl	1024bd6 <assert_print>
 101bc76:	4040      	eors	r0, r0
 101bc78:	f380 8811 	msr	BASEPRI, r0
 101bc7c:	f04f 0003 	mov.w	r0, #3
 101bc80:	df02      	svc	2
 101bc82:	e7c3      	b.n	101bc0c <isr_tx+0x24>
 101bc84:	0101c34d 	.word	0x0101c34d
 101bc88:	0102b094 	.word	0x0102b094
 101bc8c:	0102b0e8 	.word	0x0102b0e8
 101bc90:	0102a278 	.word	0x0102a278
 101bc94:	0102b0e0 	.word	0x0102b0e0

0101bc98 <is_abort_cb>:
	if (next != curr) {
 101bc98:	4281      	cmp	r1, r0
{
 101bc9a:	b508      	push	{r3, lr}
	if (next != curr) {
 101bc9c:	d00e      	beq.n	101bcbc <is_abort_cb+0x24>
		} else if (lll->is_hdcd) {
 101bc9e:	7a0b      	ldrb	r3, [r1, #8]
 101bca0:	07db      	lsls	r3, r3, #31
 101bca2:	d402      	bmi.n	101bcaa <is_abort_cb+0x12>
			return -ECANCELED;
 101bca4:	f06f 008b 	mvn.w	r0, #139	; 0x8b
}
 101bca8:	bd08      	pop	{r3, pc}
			*resume_cb = resume_prepare_cb;
 101bcaa:	4b12      	ldr	r3, [pc, #72]	; (101bcf4 <is_abort_cb+0x5c>)
 101bcac:	6013      	str	r3, [r2, #0]
			err = lll_hfclock_on();
 101bcae:	f7ff ff5b 	bl	101bb68 <lll_hfclock_on>
			LL_ASSERT(err >= 0);
 101bcb2:	2800      	cmp	r0, #0
 101bcb4:	db0f      	blt.n	101bcd6 <is_abort_cb+0x3e>
{
 101bcb6:	f06f 000a 	mvn.w	r0, #10
}
 101bcba:	bd08      	pop	{r3, pc}
	return (void *)lll->adv_data.pdu[lll->adv_data.first];
 101bcbc:	7b0b      	ldrb	r3, [r1, #12]
 101bcbe:	eb01 0183 	add.w	r1, r1, r3, lsl #2
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 101bcc2:	690b      	ldr	r3, [r1, #16]
 101bcc4:	781b      	ldrb	r3, [r3, #0]
 101bcc6:	f003 030f 	and.w	r3, r3, #15
		return 0;
 101bcca:	2b01      	cmp	r3, #1
 101bccc:	bf14      	ite	ne
 101bcce:	f06f 008b 	mvnne.w	r0, #139	; 0x8b
 101bcd2:	2000      	moveq	r0, #0
}
 101bcd4:	bd08      	pop	{r3, pc}
			LL_ASSERT(err >= 0);
 101bcd6:	f240 433a 	movw	r3, #1082	; 0x43a
 101bcda:	4a07      	ldr	r2, [pc, #28]	; (101bcf8 <is_abort_cb+0x60>)
 101bcdc:	4907      	ldr	r1, [pc, #28]	; (101bcfc <is_abort_cb+0x64>)
 101bcde:	4808      	ldr	r0, [pc, #32]	; (101bd00 <is_abort_cb+0x68>)
 101bce0:	f008 ff79 	bl	1024bd6 <assert_print>
 101bce4:	4040      	eors	r0, r0
 101bce6:	f380 8811 	msr	BASEPRI, r0
 101bcea:	f04f 0003 	mov.w	r0, #3
 101bcee:	df02      	svc	2
 101bcf0:	e7e1      	b.n	101bcb6 <is_abort_cb+0x1e>
 101bcf2:	bf00      	nop
 101bcf4:	0101c235 	.word	0x0101c235
 101bcf8:	0102b094 	.word	0x0102b094
 101bcfc:	0102b004 	.word	0x0102b004
 101bd00:	0102a278 	.word	0x0102a278

0101bd04 <isr_abort_all>:

#if defined(CONFIG_BT_PERIPHERAL)
static void isr_abort_all(void *param)
{
 101bd04:	b510      	push	{r4, lr}
 101bd06:	4604      	mov	r4, r0
	static memq_link_t link;
	static struct mayfly mfy = {0, 0, &link, NULL, lll_disable};
	uint32_t ret;

	/* Clear radio status and events */
	lll_isr_status_reset();
 101bd08:	f7ff fd8a 	bl	101b820 <lll_isr_status_reset>

	/* Disable any filter that was setup */
	radio_filter_disable();
 101bd0c:	f001 fc6c 	bl	101d5e8 <radio_filter_disable>

	/* Current LLL radio event is done*/
	lll_isr_cleanup(param);
 101bd10:	4620      	mov	r0, r4
 101bd12:	f7ff fd91 	bl	101b838 <lll_isr_cleanup>

	/* Abort any LLL prepare/resume enqueued in pipeline */
	mfy.param = param;
	ret = mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_LLL, 1U, &mfy);
 101bd16:	2100      	movs	r1, #0
	mfy.param = param;
 101bd18:	4b0a      	ldr	r3, [pc, #40]	; (101bd44 <isr_abort_all+0x40>)
	ret = mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_LLL, 1U, &mfy);
 101bd1a:	2201      	movs	r2, #1
 101bd1c:	4608      	mov	r0, r1
	mfy.param = param;
 101bd1e:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_LLL, 1U, &mfy);
 101bd20:	f7f5 f960 	bl	1010fe4 <mayfly_enqueue>
	LL_ASSERT(!ret);
 101bd24:	b900      	cbnz	r0, 101bd28 <isr_abort_all+0x24>
}
 101bd26:	bd10      	pop	{r4, pc}
	LL_ASSERT(!ret);
 101bd28:	f240 538e 	movw	r3, #1422	; 0x58e
 101bd2c:	4a06      	ldr	r2, [pc, #24]	; (101bd48 <isr_abort_all+0x44>)
 101bd2e:	4907      	ldr	r1, [pc, #28]	; (101bd4c <isr_abort_all+0x48>)
 101bd30:	4807      	ldr	r0, [pc, #28]	; (101bd50 <isr_abort_all+0x4c>)
 101bd32:	f008 ff50 	bl	1024bd6 <assert_print>
 101bd36:	4040      	eors	r0, r0
 101bd38:	f380 8811 	msr	BASEPRI, r0
 101bd3c:	f04f 0003 	mov.w	r0, #3
 101bd40:	df02      	svc	2
}
 101bd42:	bd10      	pop	{r4, pc}
 101bd44:	210009b4 	.word	0x210009b4
 101bd48:	0102b094 	.word	0x0102b094
 101bd4c:	0102a694 	.word	0x0102a694
 101bd50:	0102a278 	.word	0x0102a278

0101bd54 <abort_cb>:
{
 101bd54:	b510      	push	{r4, lr}
	if (!prepare_param) {
 101bd56:	b1d8      	cbz	r0, 101bd90 <abort_cb+0x3c>
	err = lll_hfclock_off();
 101bd58:	460c      	mov	r4, r1
 101bd5a:	f7ff ff19 	bl	101bb90 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
 101bd5e:	2800      	cmp	r0, #0
 101bd60:	db04      	blt.n	101bd6c <abort_cb+0x18>
	lll_done(param);
 101bd62:	4620      	mov	r0, r4
}
 101bd64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
 101bd68:	f7ff bc9e 	b.w	101b6a8 <lll_done>
	LL_ASSERT(err >= 0);
 101bd6c:	f44f 638c 	mov.w	r3, #1120	; 0x460
 101bd70:	4a0b      	ldr	r2, [pc, #44]	; (101bda0 <abort_cb+0x4c>)
 101bd72:	490c      	ldr	r1, [pc, #48]	; (101bda4 <abort_cb+0x50>)
 101bd74:	480c      	ldr	r0, [pc, #48]	; (101bda8 <abort_cb+0x54>)
 101bd76:	f008 ff2e 	bl	1024bd6 <assert_print>
 101bd7a:	4040      	eors	r0, r0
 101bd7c:	f380 8811 	msr	BASEPRI, r0
 101bd80:	f04f 0003 	mov.w	r0, #3
 101bd84:	df02      	svc	2
	lll_done(param);
 101bd86:	4620      	mov	r0, r4
}
 101bd88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
 101bd8c:	f7ff bc8c 	b.w	101b6a8 <lll_done>
		radio_isr_set(isr_abort, param);
 101bd90:	4806      	ldr	r0, [pc, #24]	; (101bdac <abort_cb+0x58>)
 101bd92:	f001 f9c9 	bl	101d128 <radio_isr_set>
}
 101bd96:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
 101bd9a:	f001 baf1 	b.w	101d380 <radio_disable>
 101bd9e:	bf00      	nop
 101bda0:	0102b094 	.word	0x0102b094
 101bda4:	0102b004 	.word	0x0102b004
 101bda8:	0102a278 	.word	0x0102a278
 101bdac:	0101bbd1 	.word	0x0101bbd1

0101bdb0 <lll_adv_init>:
	mem_init(mem_pdu.pool, PDU_MEM_SIZE,
 101bdb0:	2204      	movs	r2, #4
{
 101bdb2:	b510      	push	{r4, lr}
	MFIFO_INIT(pdu_free);
 101bdb4:	2400      	movs	r4, #0
	mem_init(mem_pdu.pool, PDU_MEM_SIZE,
 101bdb6:	4b07      	ldr	r3, [pc, #28]	; (101bdd4 <lll_adv_init+0x24>)
 101bdb8:	2128      	movs	r1, #40	; 0x28
 101bdba:	1898      	adds	r0, r3, r2
 101bdbc:	f7f5 f804 	bl	1010dc8 <mem_init>
	MFIFO_INIT(pdu_free);
 101bdc0:	4b05      	ldr	r3, [pc, #20]	; (101bdd8 <lll_adv_init+0x28>)
 101bdc2:	809c      	strh	r4, [r3, #4]
	return z_impl_k_sem_init(sem, initial_count, limit);
 101bdc4:	2202      	movs	r2, #2
 101bdc6:	4621      	mov	r1, r4
 101bdc8:	4804      	ldr	r0, [pc, #16]	; (101bddc <lll_adv_init+0x2c>)
 101bdca:	f00d faa4 	bl	1029316 <z_impl_k_sem_init>
}
 101bdce:	4620      	mov	r0, r4
 101bdd0:	bd10      	pop	{r4, pc}
 101bdd2:	bf00      	nop
 101bdd4:	21007bec 	.word	0x21007bec
 101bdd8:	210009c4 	.word	0x210009c4
 101bddc:	21007bd4 	.word	0x21007bd4

0101bde0 <lll_adv_reset>:
int lll_adv_reset(void)
 101bde0:	2204      	movs	r2, #4
 101bde2:	b510      	push	{r4, lr}
 101bde4:	2400      	movs	r4, #0
 101bde6:	4b07      	ldr	r3, [pc, #28]	; (101be04 <lll_adv_reset+0x24>)
 101bde8:	2128      	movs	r1, #40	; 0x28
 101bdea:	1898      	adds	r0, r3, r2
 101bdec:	f7f4 ffec 	bl	1010dc8 <mem_init>
 101bdf0:	4b05      	ldr	r3, [pc, #20]	; (101be08 <lll_adv_reset+0x28>)
 101bdf2:	809c      	strh	r4, [r3, #4]
 101bdf4:	2202      	movs	r2, #2
 101bdf6:	4621      	mov	r1, r4
 101bdf8:	4804      	ldr	r0, [pc, #16]	; (101be0c <lll_adv_reset+0x2c>)
 101bdfa:	f00d fa8c 	bl	1029316 <z_impl_k_sem_init>
 101bdfe:	4620      	mov	r0, r4
 101be00:	bd10      	pop	{r4, pc}
 101be02:	bf00      	nop
 101be04:	21007bec 	.word	0x21007bec
 101be08:	210009c4 	.word	0x210009c4
 101be0c:	21007bd4 	.word	0x21007bd4

0101be10 <lll_adv_data_init>:
{
 101be10:	b510      	push	{r4, lr}
 101be12:	4604      	mov	r4, r0
	p = mem_acquire(&mem_pdu.free);
 101be14:	4805      	ldr	r0, [pc, #20]	; (101be2c <lll_adv_data_init+0x1c>)
 101be16:	f7f5 f807 	bl	1010e28 <mem_acquire>
	if (!p) {
 101be1a:	b120      	cbz	r0, 101be26 <lll_adv_data_init+0x16>
 101be1c:	4603      	mov	r3, r0
	p->len = 0U;
 101be1e:	2000      	movs	r0, #0
 101be20:	7058      	strb	r0, [r3, #1]
	pdu->pdu[0] = (void *)p;
 101be22:	6063      	str	r3, [r4, #4]
}
 101be24:	bd10      	pop	{r4, pc}
		return -ENOMEM;
 101be26:	f06f 000b 	mvn.w	r0, #11
}
 101be2a:	bd10      	pop	{r4, pc}
 101be2c:	21007bec 	.word	0x21007bec

0101be30 <lll_adv_data_reset>:
	pdu->first = 0U;
 101be30:	2200      	movs	r2, #0
{
 101be32:	4603      	mov	r3, r0
}
 101be34:	4610      	mov	r0, r2
	pdu->first = 0U;
 101be36:	701a      	strb	r2, [r3, #0]
	pdu->last = 0U;
 101be38:	705a      	strb	r2, [r3, #1]
	pdu->pdu[1] = NULL;
 101be3a:	609a      	str	r2, [r3, #8]
}
 101be3c:	4770      	bx	lr
 101be3e:	bf00      	nop

0101be40 <lll_adv_pdu_alloc_pdu_adv>:
{
 101be40:	b538      	push	{r3, r4, r5, lr}
	p = MFIFO_DEQUEUE_PEEK(pdu_free);
 101be42:	4c2d      	ldr	r4, [pc, #180]	; (101bef8 <lll_adv_pdu_alloc_pdu_adv+0xb8>)
 101be44:	7922      	ldrb	r2, [r4, #4]
	if (first == last) {
 101be46:	7961      	ldrb	r1, [r4, #5]
 101be48:	7823      	ldrb	r3, [r4, #0]
 101be4a:	4291      	cmp	r1, r2
 101be4c:	d003      	beq.n	101be56 <lll_adv_pdu_alloc_pdu_adv+0x16>
	return *((void **)(fifo + first * size));
 101be4e:	fb02 4303 	mla	r3, r2, r3, r4
 101be52:	689d      	ldr	r5, [r3, #8]
	if (p) {
 101be54:	b935      	cbnz	r5, 101be64 <lll_adv_pdu_alloc_pdu_adv+0x24>
	p = mem_acquire(&mem_pdu.free);
 101be56:	4829      	ldr	r0, [pc, #164]	; (101befc <lll_adv_pdu_alloc_pdu_adv+0xbc>)
 101be58:	f7f4 ffe6 	bl	1010e28 <mem_acquire>
	if (p) {
 101be5c:	4605      	mov	r5, r0
 101be5e:	b188      	cbz	r0, 101be84 <lll_adv_pdu_alloc_pdu_adv+0x44>
}
 101be60:	4628      	mov	r0, r5
 101be62:	bd38      	pop	{r3, r4, r5, pc}
	z_impl_k_sem_reset(sem);
 101be64:	4826      	ldr	r0, [pc, #152]	; (101bf00 <lll_adv_pdu_alloc_pdu_adv+0xc0>)
 101be66:	f005 fcd9 	bl	102181c <z_impl_k_sem_reset>
	uint8_t _first = *first; /* Copy read-index */
 101be6a:	7923      	ldrb	r3, [r4, #4]
	if (_first == last) {
 101be6c:	7962      	ldrb	r2, [r4, #5]
		MFIFO_DEQUEUE(pdu_free);
 101be6e:	78a1      	ldrb	r1, [r4, #2]
 101be70:	429a      	cmp	r2, r3
 101be72:	d0f5      	beq.n	101be60 <lll_adv_pdu_alloc_pdu_adv+0x20>
	_first += 1U;
 101be74:	3301      	adds	r3, #1
 101be76:	b2db      	uxtb	r3, r3
		_first = 0U;
 101be78:	4299      	cmp	r1, r3
 101be7a:	bf08      	it	eq
 101be7c:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
 101be7e:	7123      	strb	r3, [r4, #4]
}
 101be80:	4628      	mov	r0, r5
 101be82:	bd38      	pop	{r3, r4, r5, pc}
	return z_impl_k_sem_take(sem, timeout);
 101be84:	f44f 3220 	mov.w	r2, #163840	; 0x28000
 101be88:	2300      	movs	r3, #0
 101be8a:	481d      	ldr	r0, [pc, #116]	; (101bf00 <lll_adv_pdu_alloc_pdu_adv+0xc0>)
 101be8c:	f005 fc4c 	bl	1021728 <z_impl_k_sem_take>
	LL_ASSERT(!err);
 101be90:	b9b0      	cbnz	r0, 101bec0 <lll_adv_pdu_alloc_pdu_adv+0x80>
	z_impl_k_sem_reset(sem);
 101be92:	481b      	ldr	r0, [pc, #108]	; (101bf00 <lll_adv_pdu_alloc_pdu_adv+0xc0>)
 101be94:	f005 fcc2 	bl	102181c <z_impl_k_sem_reset>
	uint8_t _first = *first; /* Copy read-index */
 101be98:	7923      	ldrb	r3, [r4, #4]
	if (_first == last) {
 101be9a:	7961      	ldrb	r1, [r4, #5]
	p = MFIFO_DEQUEUE(pdu_free);
 101be9c:	7822      	ldrb	r2, [r4, #0]
 101be9e:	4299      	cmp	r1, r3
 101bea0:	78a0      	ldrb	r0, [r4, #2]
 101bea2:	d01b      	beq.n	101bedc <lll_adv_pdu_alloc_pdu_adv+0x9c>
	mem = *((void **)(fifo + _first * size));
 101bea4:	fb03 f202 	mul.w	r2, r3, r2
	_first += 1U;
 101bea8:	3301      	adds	r3, #1
 101beaa:	b2db      	uxtb	r3, r3
		_first = 0U;
 101beac:	4298      	cmp	r0, r3
 101beae:	bf08      	it	eq
 101beb0:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
 101beb2:	4914      	ldr	r1, [pc, #80]	; (101bf04 <lll_adv_pdu_alloc_pdu_adv+0xc4>)
 101beb4:	588a      	ldr	r2, [r1, r2]
	*first = _first; /* Write back read-index */
 101beb6:	7123      	strb	r3, [r4, #4]
	LL_ASSERT(p);
 101beb8:	b182      	cbz	r2, 101bedc <lll_adv_pdu_alloc_pdu_adv+0x9c>
 101beba:	4615      	mov	r5, r2
}
 101bebc:	4628      	mov	r0, r5
 101bebe:	bd38      	pop	{r3, r4, r5, pc}
	LL_ASSERT(!err);
 101bec0:	f240 13b1 	movw	r3, #433	; 0x1b1
 101bec4:	4a10      	ldr	r2, [pc, #64]	; (101bf08 <lll_adv_pdu_alloc_pdu_adv+0xc8>)
 101bec6:	4911      	ldr	r1, [pc, #68]	; (101bf0c <lll_adv_pdu_alloc_pdu_adv+0xcc>)
 101bec8:	4811      	ldr	r0, [pc, #68]	; (101bf10 <lll_adv_pdu_alloc_pdu_adv+0xd0>)
 101beca:	f008 fe84 	bl	1024bd6 <assert_print>
 101bece:	4040      	eors	r0, r0
 101bed0:	f380 8811 	msr	BASEPRI, r0
 101bed4:	f04f 0003 	mov.w	r0, #3
 101bed8:	df02      	svc	2
 101beda:	e7da      	b.n	101be92 <lll_adv_pdu_alloc_pdu_adv+0x52>
	LL_ASSERT(p);
 101bedc:	f44f 73db 	mov.w	r3, #438	; 0x1b6
 101bee0:	4a09      	ldr	r2, [pc, #36]	; (101bf08 <lll_adv_pdu_alloc_pdu_adv+0xc8>)
 101bee2:	490c      	ldr	r1, [pc, #48]	; (101bf14 <lll_adv_pdu_alloc_pdu_adv+0xd4>)
 101bee4:	480a      	ldr	r0, [pc, #40]	; (101bf10 <lll_adv_pdu_alloc_pdu_adv+0xd0>)
 101bee6:	f008 fe76 	bl	1024bd6 <assert_print>
 101beea:	4040      	eors	r0, r0
 101beec:	f380 8811 	msr	BASEPRI, r0
 101bef0:	f04f 0003 	mov.w	r0, #3
 101bef4:	df02      	svc	2
 101bef6:	e7b3      	b.n	101be60 <lll_adv_pdu_alloc_pdu_adv+0x20>
 101bef8:	210009c4 	.word	0x210009c4
 101befc:	21007bec 	.word	0x21007bec
 101bf00:	21007bd4 	.word	0x21007bd4
 101bf04:	210009cc 	.word	0x210009cc
 101bf08:	0102b094 	.word	0x0102b094
 101bf0c:	0102a594 	.word	0x0102a594
 101bf10:	0102a278 	.word	0x0102a278
 101bf14:	0102b0fc 	.word	0x0102b0fc

0101bf18 <lll_adv_pdu_alloc>:
{
 101bf18:	b510      	push	{r4, lr}
	first = pdu->first;
 101bf1a:	7802      	ldrb	r2, [r0, #0]
	last = pdu->last;
 101bf1c:	7843      	ldrb	r3, [r0, #1]
	if (first == last) {
 101bf1e:	429a      	cmp	r2, r3
 101bf20:	d014      	beq.n	101bf4c <lll_adv_pdu_alloc+0x34>
		pdu->last = first;
 101bf22:	b2d4      	uxtb	r4, r2
 101bf24:	7044      	strb	r4, [r0, #1]
		first_latest = pdu->first;
 101bf26:	7802      	ldrb	r2, [r0, #0]
		if (first_latest != first) {
 101bf28:	4294      	cmp	r4, r2
 101bf2a:	d004      	beq.n	101bf36 <lll_adv_pdu_alloc+0x1e>
			last++;
 101bf2c:	1c5a      	adds	r2, r3, #1
			pdu->last = last;
 101bf2e:	7043      	strb	r3, [r0, #1]
			last++;
 101bf30:	b2d3      	uxtb	r3, r2
			if (last == DOUBLE_BUFFER_SIZE) {
 101bf32:	2b02      	cmp	r3, #2
 101bf34:	d00e      	beq.n	101bf54 <lll_adv_pdu_alloc+0x3c>
	p = (void *)pdu->pdu[last];
 101bf36:	461a      	mov	r2, r3
	*idx = last;
 101bf38:	700b      	strb	r3, [r1, #0]
	p = (void *)pdu->pdu[last];
 101bf3a:	eb00 0482 	add.w	r4, r0, r2, lsl #2
 101bf3e:	6860      	ldr	r0, [r4, #4]
	if (p) {
 101bf40:	b100      	cbz	r0, 101bf44 <lll_adv_pdu_alloc+0x2c>
}
 101bf42:	bd10      	pop	{r4, pc}
	p = lll_adv_pdu_alloc_pdu_adv();
 101bf44:	f7ff ff7c 	bl	101be40 <lll_adv_pdu_alloc_pdu_adv>
	pdu->pdu[last] = (void *)p;
 101bf48:	6060      	str	r0, [r4, #4]
}
 101bf4a:	bd10      	pop	{r4, pc}
		last++;
 101bf4c:	3301      	adds	r3, #1
 101bf4e:	b2db      	uxtb	r3, r3
		if (last == DOUBLE_BUFFER_SIZE) {
 101bf50:	2b02      	cmp	r3, #2
 101bf52:	d1f0      	bne.n	101bf36 <lll_adv_pdu_alloc+0x1e>
{
 101bf54:	2200      	movs	r2, #0
			last = 0U;
 101bf56:	4613      	mov	r3, r2
 101bf58:	e7ee      	b.n	101bf38 <lll_adv_pdu_alloc+0x20>
 101bf5a:	bf00      	nop

0101bf5c <lll_adv_pdu_latest_get>:
{
 101bf5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	first = pdu->first;
 101bf5e:	7802      	ldrb	r2, [r0, #0]
	if (first != pdu->last) {
 101bf60:	7843      	ldrb	r3, [r0, #1]
{
 101bf62:	4604      	mov	r4, r0
	if (first != pdu->last) {
 101bf64:	4293      	cmp	r3, r2
 101bf66:	d02d      	beq.n	101bfc4 <lll_adv_pdu_latest_get+0x68>
		pdu_idx = first;
 101bf68:	b2d5      	uxtb	r5, r2
			if (!MFIFO_ENQUEUE_IDX_GET(pdu_free, &free_idx)) {
 101bf6a:	4a19      	ldr	r2, [pc, #100]	; (101bfd0 <lll_adv_pdu_latest_get+0x74>)
 101bf6c:	eb00 0785 	add.w	r7, r0, r5, lsl #2
 101bf70:	f892 e005 	ldrb.w	lr, [r2, #5]
	if (last == count) {
 101bf74:	7890      	ldrb	r0, [r2, #2]
	last = last + 1;
 101bf76:	f10e 0301 	add.w	r3, lr, #1
 101bf7a:	b2db      	uxtb	r3, r3
		last = 0U;
 101bf7c:	4298      	cmp	r0, r3
 101bf7e:	bf08      	it	eq
 101bf80:	2300      	moveq	r3, #0
 101bf82:	7910      	ldrb	r0, [r2, #4]
 101bf84:	460e      	mov	r6, r1
	if (last == first) {
 101bf86:	4298      	cmp	r0, r3
		p = pdu->pdu[pdu_idx];
 101bf88:	6879      	ldr	r1, [r7, #4]
 101bf8a:	d00b      	beq.n	101bfa4 <lll_adv_pdu_latest_get+0x48>
			MFIFO_BY_IDX_ENQUEUE(pdu_free, free_idx, p);
 101bf8c:	4694      	mov	ip, r2
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 101bf8e:	f81c 0b08 	ldrb.w	r0, [ip], #8
 101bf92:	fb0e f000 	mul.w	r0, lr, r0
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 101bf96:	f84c 1000 	str.w	r1, [ip, r0]
	*last = idx; /* Commit: Update write index */
 101bf9a:	7153      	strb	r3, [r2, #5]
	z_impl_k_sem_give(sem);
 101bf9c:	480d      	ldr	r0, [pc, #52]	; (101bfd4 <lll_adv_pdu_latest_get+0x78>)
 101bf9e:	f005 fb7f 	bl	10216a0 <z_impl_k_sem_give>
			p = next;
 101bfa2:	2100      	movs	r1, #0
		first += 1U;
 101bfa4:	1c6b      	adds	r3, r5, #1
 101bfa6:	b2db      	uxtb	r3, r3
		if (first == DOUBLE_BUFFER_SIZE) {
 101bfa8:	2b02      	cmp	r3, #2
 101bfaa:	bf08      	it	eq
 101bfac:	2200      	moveq	r2, #0
		pdu->pdu[pdu_idx] = p;
 101bfae:	6079      	str	r1, [r7, #4]
	return (void *)pdu->pdu[first];
 101bfb0:	bf14      	ite	ne
 101bfb2:	461a      	movne	r2, r3
			first = 0U;
 101bfb4:	4613      	moveq	r3, r2
		*is_modified = 1U;
 101bfb6:	2101      	movs	r1, #1
		pdu->first = first;
 101bfb8:	7023      	strb	r3, [r4, #0]
		*is_modified = 1U;
 101bfba:	7031      	strb	r1, [r6, #0]
	return (void *)pdu->pdu[first];
 101bfbc:	eb04 0482 	add.w	r4, r4, r2, lsl #2
}
 101bfc0:	6860      	ldr	r0, [r4, #4]
 101bfc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		p = pdu->pdu[pdu_idx];
 101bfc4:	461a      	mov	r2, r3
	return (void *)pdu->pdu[first];
 101bfc6:	eb04 0482 	add.w	r4, r4, r2, lsl #2
}
 101bfca:	6860      	ldr	r0, [r4, #4]
 101bfcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 101bfce:	bf00      	nop
 101bfd0:	210009c4 	.word	0x210009c4
 101bfd4:	21007bd4 	.word	0x21007bd4

0101bfd8 <chan_prepare.isra.0>:
#endif /* CONFIG_BT_PERIPHERAL */

static struct pdu_adv *chan_prepare(struct lll_adv *lll)
 101bfd8:	b530      	push	{r4, r5, lr}
{
	struct pdu_adv *pdu;
	uint8_t chan;
	uint8_t upd;

	chan = find_lsb_set(lll->chan_map_curr);
 101bfda:	7a03      	ldrb	r3, [r0, #8]
static struct pdu_adv *chan_prepare(struct lll_adv *lll)
 101bfdc:	4604      	mov	r4, r0
	chan = find_lsb_set(lll->chan_map_curr);
 101bfde:	f3c3 1302 	ubfx	r3, r3, #4, #3
 101bfe2:	fa93 f0a3 	rbit	r0, r3
 101bfe6:	2b00      	cmp	r3, #0
 101bfe8:	fab0 f080 	clz	r0, r0
 101bfec:	bf08      	it	eq
 101bfee:	f04f 30ff 	moveq.w	r0, #4294967295
static struct pdu_adv *chan_prepare(struct lll_adv *lll)
 101bff2:	b083      	sub	sp, #12
 101bff4:	f100 0501 	add.w	r5, r0, #1
	LL_ASSERT(chan);
 101bff8:	d03b      	beq.n	101c072 <chan_prepare.isra.0+0x9a>

	lll->chan_map_curr &= (lll->chan_map_curr - 1);
 101bffa:	7a21      	ldrb	r1, [r4, #8]
 101bffc:	1e5a      	subs	r2, r3, #1
 101bffe:	4013      	ands	r3, r2
 101c000:	f363 1106 	bfi	r1, r3, #4, #3

	lll_chan_set(36 + chan);
 101c004:	f105 0024 	add.w	r0, r5, #36	; 0x24
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
 101c008:	7221      	strb	r1, [r4, #8]
	lll_chan_set(36 + chan);
 101c00a:	f7ff fbb1 	bl	101b770 <lll_chan_set>

	/* FIXME: get latest only when primary PDU without Aux PDUs */
	upd = 0U;
 101c00e:	2300      	movs	r3, #0
#endif /* CONFIG_BT_CTLR_ADV_EXT_PDU_EXTRA_DATA_MEMORY */

static inline struct pdu_adv *lll_adv_data_latest_get(struct lll_adv *lll,
						      uint8_t *is_modified)
{
	return lll_adv_pdu_latest_get(&lll->adv_data, is_modified);
 101c010:	f10d 0107 	add.w	r1, sp, #7
 101c014:	f104 000c 	add.w	r0, r4, #12
 101c018:	f88d 3007 	strb.w	r3, [sp, #7]
 101c01c:	f7ff ff9e 	bl	101bf5c <lll_adv_pdu_latest_get>
	pdu = lll_adv_data_latest_get(lll, &upd);
	LL_ASSERT(pdu);
 101c020:	4605      	mov	r5, r0
 101c022:	2800      	cmp	r0, #0
 101c024:	d036      	beq.n	101c094 <chan_prepare.isra.0+0xbc>

	radio_pkt_tx_set(pdu);
 101c026:	4628      	mov	r0, r5
 101c028:	f001 f980 	bl	101d32c <radio_pkt_tx_set>

	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
 101c02c:	782b      	ldrb	r3, [r5, #0]
 101c02e:	f003 030f 	and.w	r3, r3, #15
 101c032:	2b02      	cmp	r3, #2
 101c034:	d014      	beq.n	101c060 <chan_prepare.isra.0+0x88>
}

static inline struct pdu_adv *lll_adv_scan_rsp_latest_get(struct lll_adv *lll,
							  uint8_t *is_modified)
{
	return lll_adv_pdu_latest_get(&lll->scan_rsp, is_modified);
 101c036:	f10d 0107 	add.w	r1, sp, #7
 101c03a:	f104 0018 	add.w	r0, r4, #24
 101c03e:	f7ff ff8d 	bl	101bf5c <lll_adv_pdu_latest_get>
	    (!IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) ||
	     (pdu->type != PDU_ADV_TYPE_EXT_IND))) {
		struct pdu_adv *scan_pdu;

		scan_pdu = lll_adv_scan_rsp_latest_get(lll, &upd);
		LL_ASSERT(scan_pdu);
 101c042:	2800      	cmp	r0, #0
 101c044:	d034      	beq.n	101c0b0 <chan_prepare.isra.0+0xd8>
#else
		ARG_UNUSED(scan_pdu);
		ARG_UNUSED(upd);
#endif /* !CONFIG_BT_CTLR_PRIVACY */

		radio_isr_set(isr_tx, lll);
 101c046:	4621      	mov	r1, r4
 101c048:	4820      	ldr	r0, [pc, #128]	; (101c0cc <chan_prepare.isra.0+0xf4>)
 101c04a:	f001 f86d 	bl	101d128 <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
 101c04e:	2096      	movs	r0, #150	; 0x96
 101c050:	f001 fafc 	bl	101d64c <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
 101c054:	2000      	movs	r0, #0
		radio_isr_set(isr_done, lll);
		radio_switch_complete_and_disable();
	}

	return pdu;
}
 101c056:	b003      	add	sp, #12
 101c058:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		radio_switch_complete_and_rx(0);
 101c05c:	f001 b9fc 	b.w	101d458 <radio_switch_complete_and_rx>
		radio_isr_set(isr_done, lll);
 101c060:	4621      	mov	r1, r4
 101c062:	481b      	ldr	r0, [pc, #108]	; (101c0d0 <chan_prepare.isra.0+0xf8>)
 101c064:	f001 f860 	bl	101d128 <radio_isr_set>
}
 101c068:	b003      	add	sp, #12
 101c06a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		radio_switch_complete_and_disable();
 101c06e:	f001 ba91 	b.w	101d594 <radio_switch_complete_and_disable>
	LL_ASSERT(chan);
 101c072:	f240 5399 	movw	r3, #1433	; 0x599
 101c076:	4a17      	ldr	r2, [pc, #92]	; (101c0d4 <chan_prepare.isra.0+0xfc>)
 101c078:	4917      	ldr	r1, [pc, #92]	; (101c0d8 <chan_prepare.isra.0+0x100>)
 101c07a:	4818      	ldr	r0, [pc, #96]	; (101c0dc <chan_prepare.isra.0+0x104>)
 101c07c:	f008 fdab 	bl	1024bd6 <assert_print>
 101c080:	4040      	eors	r0, r0
 101c082:	f380 8811 	msr	BASEPRI, r0
 101c086:	f04f 0003 	mov.w	r0, #3
 101c08a:	df02      	svc	2
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
 101c08c:	7a23      	ldrb	r3, [r4, #8]
 101c08e:	f3c3 1302 	ubfx	r3, r3, #4, #3
 101c092:	e7b2      	b.n	101bffa <chan_prepare.isra.0+0x22>
	LL_ASSERT(pdu);
 101c094:	f240 53a2 	movw	r3, #1442	; 0x5a2
 101c098:	4a0e      	ldr	r2, [pc, #56]	; (101c0d4 <chan_prepare.isra.0+0xfc>)
 101c09a:	4911      	ldr	r1, [pc, #68]	; (101c0e0 <chan_prepare.isra.0+0x108>)
 101c09c:	480f      	ldr	r0, [pc, #60]	; (101c0dc <chan_prepare.isra.0+0x104>)
 101c09e:	f008 fd9a 	bl	1024bd6 <assert_print>
 101c0a2:	4040      	eors	r0, r0
 101c0a4:	f380 8811 	msr	BASEPRI, r0
 101c0a8:	f04f 0003 	mov.w	r0, #3
 101c0ac:	df02      	svc	2
 101c0ae:	e7ba      	b.n	101c026 <chan_prepare.isra.0+0x4e>
		LL_ASSERT(scan_pdu);
 101c0b0:	f240 53ac 	movw	r3, #1452	; 0x5ac
 101c0b4:	4a07      	ldr	r2, [pc, #28]	; (101c0d4 <chan_prepare.isra.0+0xfc>)
 101c0b6:	490b      	ldr	r1, [pc, #44]	; (101c0e4 <chan_prepare.isra.0+0x10c>)
 101c0b8:	4808      	ldr	r0, [pc, #32]	; (101c0dc <chan_prepare.isra.0+0x104>)
 101c0ba:	f008 fd8c 	bl	1024bd6 <assert_print>
 101c0be:	4040      	eors	r0, r0
 101c0c0:	f380 8811 	msr	BASEPRI, r0
 101c0c4:	f04f 0003 	mov.w	r0, #3
 101c0c8:	df02      	svc	2
 101c0ca:	e7bc      	b.n	101c046 <chan_prepare.isra.0+0x6e>
 101c0cc:	0101bbe9 	.word	0x0101bbe9
 101c0d0:	0101c0e9 	.word	0x0101c0e9
 101c0d4:	0102b094 	.word	0x0102b094
 101c0d8:	0102b100 	.word	0x0102b100
 101c0dc:	0102a278 	.word	0x0102a278
 101c0e0:	0102b108 	.word	0x0102b108
 101c0e4:	0102b10c 	.word	0x0102b10c

0101c0e8 <isr_done>:
{
 101c0e8:	b510      	push	{r4, lr}
 101c0ea:	4604      	mov	r4, r0
	lll_isr_status_reset();
 101c0ec:	f7ff fb98 	bl	101b820 <lll_isr_status_reset>
	if (!IS_ENABLED(CONFIG_BT_CTLR_LOW_LAT) && lll->is_hdcd &&
 101c0f0:	7a23      	ldrb	r3, [r4, #8]
 101c0f2:	f003 0271 	and.w	r2, r3, #113	; 0x71
 101c0f6:	2a01      	cmp	r2, #1
 101c0f8:	d106      	bne.n	101c108 <isr_done+0x20>
		lll->chan_map_curr = lll->chan_map;
 101c0fa:	461a      	mov	r2, r3
 101c0fc:	f3c3 0342 	ubfx	r3, r3, #1, #3
 101c100:	f363 1206 	bfi	r2, r3, #4, #3
 101c104:	7222      	strb	r2, [r4, #8]
	if (lll->chan_map_curr &&
 101c106:	b2d3      	uxtb	r3, r2
 101c108:	f013 0f70 	tst.w	r3, #112	; 0x70
 101c10c:	d005      	beq.n	101c11a <isr_done+0x32>
	    (!lll->conn || !lll->conn->periph.cancelled) &&
 101c10e:	6863      	ldr	r3, [r4, #4]
 101c110:	b153      	cbz	r3, 101c128 <isr_done+0x40>
 101c112:	f893 3020 	ldrb.w	r3, [r3, #32]
 101c116:	079b      	lsls	r3, r3, #30
 101c118:	d506      	bpl.n	101c128 <isr_done+0x40>
	radio_filter_disable();
 101c11a:	f001 fa65 	bl	101d5e8 <radio_filter_disable>
	lll_isr_cleanup(param);
 101c11e:	4620      	mov	r0, r4
}
 101c120:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
 101c124:	f7ff bb88 	b.w	101b838 <lll_isr_cleanup>
		pdu = chan_prepare(lll);
 101c128:	4620      	mov	r0, r4
 101c12a:	f7ff ff55 	bl	101bfd8 <chan_prepare.isra.0>
		radio_tx_enable();
 101c12e:	f001 f90d 	bl	101d34c <radio_tx_enable>
}
 101c132:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_tmr_end_capture();
 101c136:	f001 bb7b 	b.w	101d830 <radio_tmr_end_capture>
 101c13a:	bf00      	nop

0101c13c <prepare_cb>:
{
 101c13c:	b5f0      	push	{r4, r5, r6, r7, lr}
	lll = p->param;
 101c13e:	68c4      	ldr	r4, [r0, #12]
{
 101c140:	4605      	mov	r5, r0
	if (unlikely(lll->conn &&
 101c142:	6863      	ldr	r3, [r4, #4]
{
 101c144:	b083      	sub	sp, #12
	if (unlikely(lll->conn &&
 101c146:	2b00      	cmp	r3, #0
 101c148:	d15b      	bne.n	101c202 <prepare_cb+0xc6>
	radio_reset();
 101c14a:	f001 f80f 	bl	101d16c <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
 101c14e:	2000      	movs	r0, #0
 101c150:	f001 f858 	bl	101d204 <radio_tx_power_set>
	radio_phy_set(0, 0);
 101c154:	2100      	movs	r1, #0
 101c156:	4608      	mov	r0, r1
 101c158:	f001 f836 	bl	101d1c8 <radio_phy_set>
	radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, PDU_AC_LEG_PAYLOAD_SIZE_MAX,
 101c15c:	2200      	movs	r2, #0
 101c15e:	2125      	movs	r1, #37	; 0x25
 101c160:	2008      	movs	r0, #8
 101c162:	f001 f8b7 	bl	101d2d4 <radio_pkt_configure>
	aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
 101c166:	4b2c      	ldr	r3, [pc, #176]	; (101c218 <prepare_cb+0xdc>)
	radio_aa_set((uint8_t *)&aa);
 101c168:	a801      	add	r0, sp, #4
	aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
 101c16a:	9301      	str	r3, [sp, #4]
	radio_aa_set((uint8_t *)&aa);
 101c16c:	f001 f89a 	bl	101d2a4 <radio_aa_set>
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
 101c170:	492a      	ldr	r1, [pc, #168]	; (101c21c <prepare_cb+0xe0>)
 101c172:	f240 605b 	movw	r0, #1627	; 0x65b
 101c176:	f001 f951 	bl	101d41c <radio_crc_configure>
	lll->chan_map_curr = lll->chan_map;
 101c17a:	7a23      	ldrb	r3, [r4, #8]
	pdu = chan_prepare(lll);
 101c17c:	4620      	mov	r0, r4
	lll->chan_map_curr = lll->chan_map;
 101c17e:	461a      	mov	r2, r3
 101c180:	f3c3 0342 	ubfx	r3, r3, #1, #3
 101c184:	f363 1206 	bfi	r2, r3, #4, #3
 101c188:	7222      	strb	r2, [r4, #8]
	pdu = chan_prepare(lll);
 101c18a:	f7ff ff25 	bl	101bfd8 <chan_prepare.isra.0>
	ull = HDR_LLL2ULL(lll);
 101c18e:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = p->ticks_at_expire;
 101c190:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_event_offset_get(ull);
 101c192:	4638      	mov	r0, r7
 101c194:	f7ff fade 	bl	101b754 <lll_event_offset_get>
 101c198:	4603      	mov	r3, r0
 101c19a:	441e      	add	r6, r3
	start_us = radio_tmr_start(1, ticks_at_start, remainder);
 101c19c:	686a      	ldr	r2, [r5, #4]
 101c19e:	f106 0109 	add.w	r1, r6, #9
 101c1a2:	2001      	movs	r0, #1
 101c1a4:	f001 fa5e 	bl	101d664 <radio_tmr_start>
	radio_tmr_end_capture();
 101c1a8:	f001 fb42 	bl	101d830 <radio_tmr_end_capture>
				   ull_adv_lll_handle_get(lll)),
 101c1ac:	4620      	mov	r0, r4
 101c1ae:	f7f9 f9b3 	bl	1015518 <ull_adv_lll_handle_get>
 101c1b2:	4601      	mov	r1, r0
	if (lll_preempt_calc(ull, (TICKER_ID_ADV_BASE +
 101c1b4:	3102      	adds	r1, #2
 101c1b6:	4632      	mov	r2, r6
 101c1b8:	4638      	mov	r0, r7
 101c1ba:	b2c9      	uxtb	r1, r1
 101c1bc:	f7e5 f950 	bl	1001460 <lll_preempt_calc>
 101c1c0:	b930      	cbnz	r0, 101c1d0 <prepare_cb+0x94>
		ret = lll_prepare_done(lll);
 101c1c2:	4620      	mov	r0, r4
 101c1c4:	f7ff fa6e 	bl	101b6a4 <lll_prepare_done>
		LL_ASSERT(!ret);
 101c1c8:	b958      	cbnz	r0, 101c1e2 <prepare_cb+0xa6>
}
 101c1ca:	2000      	movs	r0, #0
 101c1cc:	b003      	add	sp, #12
 101c1ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
		radio_isr_set(isr_abort, lll);
 101c1d0:	4621      	mov	r1, r4
 101c1d2:	4813      	ldr	r0, [pc, #76]	; (101c220 <prepare_cb+0xe4>)
 101c1d4:	f000 ffa8 	bl	101d128 <radio_isr_set>
		radio_disable();
 101c1d8:	f001 f8d2 	bl	101d380 <radio_disable>
}
 101c1dc:	2000      	movs	r0, #0
 101c1de:	b003      	add	sp, #12
 101c1e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LL_ASSERT(!ret);
 101c1e2:	f240 4311 	movw	r3, #1041	; 0x411
 101c1e6:	4a0f      	ldr	r2, [pc, #60]	; (101c224 <prepare_cb+0xe8>)
 101c1e8:	490f      	ldr	r1, [pc, #60]	; (101c228 <prepare_cb+0xec>)
 101c1ea:	4810      	ldr	r0, [pc, #64]	; (101c22c <prepare_cb+0xf0>)
 101c1ec:	f008 fcf3 	bl	1024bd6 <assert_print>
 101c1f0:	4040      	eors	r0, r0
 101c1f2:	f380 8811 	msr	BASEPRI, r0
 101c1f6:	f04f 0003 	mov.w	r0, #3
 101c1fa:	df02      	svc	2
}
 101c1fc:	2000      	movs	r0, #0
 101c1fe:	b003      	add	sp, #12
 101c200:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (unlikely(lll->conn &&
 101c202:	f893 3020 	ldrb.w	r3, [r3, #32]
 101c206:	079b      	lsls	r3, r3, #30
 101c208:	d09f      	beq.n	101c14a <prepare_cb+0xe>
		radio_isr_set(lll_isr_early_abort, lll);
 101c20a:	4621      	mov	r1, r4
 101c20c:	4808      	ldr	r0, [pc, #32]	; (101c230 <prepare_cb+0xf4>)
 101c20e:	f000 ff8b 	bl	101d128 <radio_isr_set>
		radio_disable();
 101c212:	f001 f8b5 	bl	101d380 <radio_disable>
		return 0;
 101c216:	e7d8      	b.n	101c1ca <prepare_cb+0x8e>
 101c218:	8e89bed6 	.word	0x8e89bed6
 101c21c:	00555555 	.word	0x00555555
 101c220:	0101bbd1 	.word	0x0101bbd1
 101c224:	0102b094 	.word	0x0102b094
 101c228:	0102a694 	.word	0x0102a694
 101c22c:	0102a278 	.word	0x0102a278
 101c230:	0101b8cd 	.word	0x0101b8cd

0101c234 <resume_prepare_cb>:
{
 101c234:	b570      	push	{r4, r5, r6, lr}
	ull = HDR_LLL2ULL(p->param);
 101c236:	68c3      	ldr	r3, [r0, #12]
{
 101c238:	4604      	mov	r4, r0
	ull = HDR_LLL2ULL(p->param);
 101c23a:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_event_offset_get(ull);
 101c23c:	f7f6 f828 	bl	1012290 <ticker_ticks_now_get>
 101c240:	4605      	mov	r5, r0
 101c242:	4630      	mov	r0, r6
 101c244:	f7ff fa86 	bl	101b754 <lll_event_offset_get>
 101c248:	4602      	mov	r2, r0
	p->remainder = 0;
 101c24a:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_event_offset_get(ull);
 101c24c:	1aad      	subs	r5, r5, r2
	p->remainder = 0;
 101c24e:	e9c4 5300 	strd	r5, r3, [r4]
	p->lazy = 0;
 101c252:	8123      	strh	r3, [r4, #8]
	return prepare_cb(p);
 101c254:	4620      	mov	r0, r4
}
 101c256:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
 101c25a:	f7ff bf6f 	b.w	101c13c <prepare_cb>
 101c25e:	bf00      	nop

0101c260 <lll_adv_prepare>:
{
 101c260:	b510      	push	{r4, lr}
 101c262:	b082      	sub	sp, #8
 101c264:	4604      	mov	r4, r0
	err = lll_hfclock_on();
 101c266:	f7ff fc7f 	bl	101bb68 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
 101c26a:	2800      	cmp	r0, #0
 101c26c:	db1a      	blt.n	101c2a4 <lll_adv_prepare+0x44>
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, param);
 101c26e:	2300      	movs	r3, #0
 101c270:	4a13      	ldr	r2, [pc, #76]	; (101c2c0 <lll_adv_prepare+0x60>)
 101c272:	4914      	ldr	r1, [pc, #80]	; (101c2c4 <lll_adv_prepare+0x64>)
 101c274:	4814      	ldr	r0, [pc, #80]	; (101c2c8 <lll_adv_prepare+0x68>)
 101c276:	9400      	str	r4, [sp, #0]
 101c278:	f7f8 fd0a 	bl	1014c90 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
 101c27c:	b108      	cbz	r0, 101c282 <lll_adv_prepare+0x22>
 101c27e:	3077      	adds	r0, #119	; 0x77
 101c280:	d101      	bne.n	101c286 <lll_adv_prepare+0x26>
}
 101c282:	b002      	add	sp, #8
 101c284:	bd10      	pop	{r4, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
 101c286:	f240 23aa 	movw	r3, #682	; 0x2aa
 101c28a:	4a10      	ldr	r2, [pc, #64]	; (101c2cc <lll_adv_prepare+0x6c>)
 101c28c:	4910      	ldr	r1, [pc, #64]	; (101c2d0 <lll_adv_prepare+0x70>)
 101c28e:	4811      	ldr	r0, [pc, #68]	; (101c2d4 <lll_adv_prepare+0x74>)
 101c290:	f008 fca1 	bl	1024bd6 <assert_print>
 101c294:	4040      	eors	r0, r0
 101c296:	f380 8811 	msr	BASEPRI, r0
 101c29a:	f04f 0003 	mov.w	r0, #3
 101c29e:	df02      	svc	2
}
 101c2a0:	b002      	add	sp, #8
 101c2a2:	bd10      	pop	{r4, pc}
	LL_ASSERT(err >= 0);
 101c2a4:	f240 23a7 	movw	r3, #679	; 0x2a7
 101c2a8:	4a08      	ldr	r2, [pc, #32]	; (101c2cc <lll_adv_prepare+0x6c>)
 101c2aa:	490b      	ldr	r1, [pc, #44]	; (101c2d8 <lll_adv_prepare+0x78>)
 101c2ac:	4809      	ldr	r0, [pc, #36]	; (101c2d4 <lll_adv_prepare+0x74>)
 101c2ae:	f008 fc92 	bl	1024bd6 <assert_print>
 101c2b2:	4040      	eors	r0, r0
 101c2b4:	f380 8811 	msr	BASEPRI, r0
 101c2b8:	f04f 0003 	mov.w	r0, #3
 101c2bc:	df02      	svc	2
 101c2be:	e7d6      	b.n	101c26e <lll_adv_prepare+0xe>
 101c2c0:	0101c13d 	.word	0x0101c13d
 101c2c4:	0101bd55 	.word	0x0101bd55
 101c2c8:	0101bc99 	.word	0x0101bc99
 101c2cc:	0102b094 	.word	0x0102b094
 101c2d0:	0102b118 	.word	0x0102b118
 101c2d4:	0102a278 	.word	0x0102a278
 101c2d8:	0102b004 	.word	0x0102b004

0101c2dc <lll_adv_connect_ind_check>:
{
 101c2dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 101c2de:	9e07      	ldr	r6, [sp, #28]
 101c2e0:	460d      	mov	r5, r1
 101c2e2:	f89d 7018 	ldrb.w	r7, [sp, #24]
 101c2e6:	f89d 4020 	ldrb.w	r4, [sp, #32]
	if (tgt_addr) {
 101c2ea:	b95e      	cbnz	r6, 101c304 <lll_adv_connect_ind_check+0x28>
	return (((lll->filter_policy & BT_LE_ADV_FP_FILTER_CONN_IND) == 0) ||
 101c2ec:	7a41      	ldrb	r1, [r0, #9]
		(devmatch_ok)) &&
 101c2ee:	f001 0103 	and.w	r1, r1, #3
 101c2f2:	2901      	cmp	r1, #1
 101c2f4:	d900      	bls.n	101c2f8 <lll_adv_connect_ind_check+0x1c>
	return (((lll->filter_policy & BT_LE_ADV_FP_FILTER_CONN_IND) == 0) ||
 101c2f6:	b11c      	cbz	r4, 101c300 <lll_adv_connect_ind_check+0x24>
}

static bool isr_rx_sr_adva_check(uint8_t tx_addr, uint8_t *addr,
				 struct pdu_adv *sr)
{
	return (tx_addr == sr->rx_addr) &&
 101c2f8:	7829      	ldrb	r1, [r5, #0]
 101c2fa:	ebb2 1fd1 	cmp.w	r2, r1, lsr #7
 101c2fe:	d01b      	beq.n	101c338 <lll_adv_connect_ind_check+0x5c>
 101c300:	2000      	movs	r0, #0
}
 101c302:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (tx_addr == sr->rx_addr) &&
 101c304:	7809      	ldrb	r1, [r1, #0]
 101c306:	ebb2 1fd1 	cmp.w	r2, r1, lsr #7
 101c30a:	d1f9      	bne.n	101c300 <lll_adv_connect_ind_check+0x24>
		!memcmp(addr, sr->scan_req.adv_addr, BDADDR_SIZE);
 101c30c:	2206      	movs	r2, #6
 101c30e:	4618      	mov	r0, r3
 101c310:	f105 0108 	add.w	r1, r5, #8
 101c314:	f00a fb1e 	bl	1026954 <memcmp>
	return (tx_addr == sr->rx_addr) &&
 101c318:	2800      	cmp	r0, #0
 101c31a:	d1f1      	bne.n	101c300 <lll_adv_connect_ind_check+0x24>
#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (rl_idx != FILTER_IDX_NONE && lll->rl_idx != FILTER_IDX_NONE) {
		return rl_idx == lll->rl_idx;
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */
	return (rx_addr == ci->tx_addr) &&
 101c31c:	782b      	ldrb	r3, [r5, #0]
 101c31e:	f3c3 1380 	ubfx	r3, r3, #6, #1
 101c322:	42bb      	cmp	r3, r7
 101c324:	d1ec      	bne.n	101c300 <lll_adv_connect_ind_check+0x24>
	       !memcmp(tgt_addr, ci->connect_ind.init_addr, BDADDR_SIZE);
 101c326:	2206      	movs	r2, #6
 101c328:	4630      	mov	r0, r6
 101c32a:	1ca9      	adds	r1, r5, #2
 101c32c:	f00a fb12 	bl	1026954 <memcmp>
	return (rx_addr == ci->tx_addr) &&
 101c330:	fab0 f080 	clz	r0, r0
 101c334:	0940      	lsrs	r0, r0, #5
}
 101c336:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		!memcmp(addr, sr->scan_req.adv_addr, BDADDR_SIZE);
 101c338:	2206      	movs	r2, #6
 101c33a:	4618      	mov	r0, r3
 101c33c:	f105 0108 	add.w	r1, r5, #8
 101c340:	f00a fb08 	bl	1026954 <memcmp>
	return (tx_addr == sr->rx_addr) &&
 101c344:	fab0 f080 	clz	r0, r0
 101c348:	0940      	lsrs	r0, r0, #5
}
 101c34a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0101c34c <isr_rx>:
{
 101c34c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 101c350:	b088      	sub	sp, #32
 101c352:	4604      	mov	r4, r0
	trx_done = radio_is_done();
 101c354:	f001 f84e 	bl	101d3f4 <radio_is_done>
	if (trx_done) {
 101c358:	b2c0      	uxtb	r0, r0
 101c35a:	b950      	cbnz	r0, 101c372 <isr_rx+0x26>
	lll_isr_status_reset();
 101c35c:	f7ff fa60 	bl	101b820 <lll_isr_status_reset>
	radio_isr_set(isr_done, param);
 101c360:	4621      	mov	r1, r4
 101c362:	4873      	ldr	r0, [pc, #460]	; (101c530 <isr_rx+0x1e4>)
 101c364:	f000 fee0 	bl	101d128 <radio_isr_set>
}
 101c368:	b008      	add	sp, #32
 101c36a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	radio_disable();
 101c36e:	f001 b807 	b.w	101d380 <radio_disable>
		crc_ok = radio_crc_is_valid();
 101c372:	f001 f85f 	bl	101d434 <radio_crc_is_valid>
 101c376:	4605      	mov	r5, r0
		devmatch_ok = radio_filter_has_match();
 101c378:	f001 f948 	bl	101d60c <radio_filter_has_match>
	if (crc_ok) {
 101c37c:	b2ed      	uxtb	r5, r5
		devmatch_ok = radio_filter_has_match();
 101c37e:	4606      	mov	r6, r0
		devmatch_id = radio_filter_match_get();
 101c380:	f001 f94e 	bl	101d620 <radio_filter_match_get>
		rssi_ready = radio_rssi_is_ready();
 101c384:	f001 f926 	bl	101d5d4 <radio_rssi_is_ready>
	lll_isr_status_reset();
 101c388:	f7ff fa4a 	bl	101b820 <lll_isr_status_reset>
	if (crc_ok) {
 101c38c:	2d00      	cmp	r5, #0
 101c38e:	d0e7      	beq.n	101c360 <isr_rx+0x14>
	uint8_t rl_idx = FILTER_IDX_NONE;
 101c390:	23ff      	movs	r3, #255	; 0xff
	node_rx = ull_pdu_rx_alloc_peek(1);
 101c392:	2001      	movs	r0, #1
	uint8_t rl_idx = FILTER_IDX_NONE;
 101c394:	f88d 301f 	strb.w	r3, [sp, #31]
	node_rx = ull_pdu_rx_alloc_peek(1);
 101c398:	f7f8 f92c 	bl	10145f4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 101c39c:	4605      	mov	r5, r0
 101c39e:	2800      	cmp	r0, #0
 101c3a0:	f000 8098 	beq.w	101c4d4 <isr_rx+0x188>
 101c3a4:	7b23      	ldrb	r3, [r4, #12]
	pdu_rx = (void *)node_rx->pdu;
 101c3a6:	f105 091c 	add.w	r9, r5, #28
 101c3aa:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 101c3ae:	6919      	ldr	r1, [r3, #16]
		devmatch_ok = radio_filter_has_match();
 101c3b0:	b2f6      	uxtb	r6, r6
	addr = pdu_adv->adv_ind.addr;
 101c3b2:	460b      	mov	r3, r1
	tx_addr = pdu_adv->tx_addr;
 101c3b4:	f813 2b02 	ldrb.w	r2, [r3], #2
	if (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND) {
 101c3b8:	f002 000f 	and.w	r0, r2, #15
 101c3bc:	2801      	cmp	r0, #1
		tgt_addr = pdu_adv->direct_ind.tgt_addr;
 101c3be:	bf08      	it	eq
 101c3c0:	f101 0808 	addeq.w	r8, r1, #8
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
 101c3c4:	7f29      	ldrb	r1, [r5, #28]
	tx_addr = pdu_adv->tx_addr;
 101c3c6:	f3c2 1a80 	ubfx	sl, r2, #6, #1
	rx_addr = pdu_adv->rx_addr;
 101c3ca:	ea4f 17d2 	mov.w	r7, r2, lsr #7
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
 101c3ce:	f001 020f 	and.w	r2, r1, #15
		tgt_addr = NULL;
 101c3d2:	bf18      	it	ne
 101c3d4:	f04f 0800 	movne.w	r8, #0
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
 101c3d8:	2a03      	cmp	r2, #3
 101c3da:	d04e      	beq.n	101c47a <isr_rx+0x12e>
	} else if ((pdu_rx->type == PDU_ADV_TYPE_CONNECT_IND) &&
 101c3dc:	2a05      	cmp	r2, #5
 101c3de:	d1bf      	bne.n	101c360 <isr_rx+0x14>
 101c3e0:	7f6a      	ldrb	r2, [r5, #29]
 101c3e2:	2a22      	cmp	r2, #34	; 0x22
 101c3e4:	d1bc      	bne.n	101c360 <isr_rx+0x14>
		   lll->conn && !lll->conn->periph.cancelled &&
 101c3e6:	6862      	ldr	r2, [r4, #4]
		   (pdu_rx->len == sizeof(struct pdu_adv_connect_ind)) &&
 101c3e8:	2a00      	cmp	r2, #0
 101c3ea:	d0b9      	beq.n	101c360 <isr_rx+0x14>
		   lll->conn && !lll->conn->periph.cancelled &&
 101c3ec:	f892 2020 	ldrb.w	r2, [r2, #32]
 101c3f0:	0792      	lsls	r2, r2, #30
 101c3f2:	d4b5      	bmi.n	101c360 <isr_rx+0x14>
		   lll_adv_connect_ind_check(lll, pdu_rx, tx_addr, addr,
 101c3f4:	f10d 051f 	add.w	r5, sp, #31
 101c3f8:	4652      	mov	r2, sl
 101c3fa:	4649      	mov	r1, r9
 101c3fc:	4620      	mov	r0, r4
 101c3fe:	e9cd 8601 	strd	r8, r6, [sp, #4]
 101c402:	9700      	str	r7, [sp, #0]
 101c404:	9503      	str	r5, [sp, #12]
 101c406:	f7ff ff69 	bl	101c2dc <lll_adv_connect_ind_check>
		   lll->conn && !lll->conn->periph.cancelled &&
 101c40a:	2800      	cmp	r0, #0
 101c40c:	d0a8      	beq.n	101c360 <isr_rx+0x14>
			rx = ull_pdu_rx_alloc_peek(4);
 101c40e:	2004      	movs	r0, #4
 101c410:	f7f8 f8f0 	bl	10145f4 <ull_pdu_rx_alloc_peek>
		if (!rx) {
 101c414:	2800      	cmp	r0, #0
 101c416:	d0a3      	beq.n	101c360 <isr_rx+0x14>
		radio_isr_set(isr_abort_all, lll);
 101c418:	4621      	mov	r1, r4
 101c41a:	4846      	ldr	r0, [pc, #280]	; (101c534 <isr_rx+0x1e8>)
 101c41c:	f000 fe84 	bl	101d128 <radio_isr_set>
		radio_disable();
 101c420:	f000 ffae 	bl	101d380 <radio_disable>
		LL_ASSERT(!radio_is_ready());
 101c424:	f000 ffdc 	bl	101d3e0 <radio_is_ready>
 101c428:	2800      	cmp	r0, #0
 101c42a:	d145      	bne.n	101c4b8 <isr_rx+0x16c>
		lll->conn->periph.initiated = 1;
 101c42c:	6862      	ldr	r2, [r4, #4]
 101c42e:	f892 3020 	ldrb.w	r3, [r2, #32]
 101c432:	f043 0301 	orr.w	r3, r3, #1
 101c436:	f882 3020 	strb.w	r3, [r2, #32]
		rx = ull_pdu_rx_alloc();
 101c43a:	f7f8 f8fd 	bl	1014638 <ull_pdu_rx_alloc>
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 101c43e:	2217      	movs	r2, #23
		rx->hdr.handle = 0xffff;
 101c440:	f64f 73ff 	movw	r3, #65535	; 0xffff
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 101c444:	7102      	strb	r2, [r0, #4]
		rx->hdr.handle = 0xffff;
 101c446:	80c3      	strh	r3, [r0, #6]
		ftr->param = lll;
 101c448:	6084      	str	r4, [r0, #8]
		rx = ull_pdu_rx_alloc();
 101c44a:	4605      	mov	r5, r0
		ftr->ticks_anchor = radio_tmr_start_get();
 101c44c:	f001 f988 	bl	101d760 <radio_tmr_start_get>
 101c450:	6128      	str	r0, [r5, #16]
		ftr->radio_end_us = radio_tmr_end_get() -
 101c452:	f001 fa05 	bl	101d860 <radio_tmr_end_get>
				    radio_rx_chain_delay_get(0, 0);
 101c456:	2100      	movs	r1, #0
		ftr->radio_end_us = radio_tmr_end_get() -
 101c458:	4604      	mov	r4, r0
				    radio_rx_chain_delay_get(0, 0);
 101c45a:	4608      	mov	r0, r1
 101c45c:	f000 ff70 	bl	101d340 <radio_rx_chain_delay_get>
		ftr->radio_end_us = radio_tmr_end_get() -
 101c460:	1a24      	subs	r4, r4, r0
 101c462:	616c      	str	r4, [r5, #20]
			ftr->extra = ull_pdu_rx_alloc();
 101c464:	f7f8 f8e8 	bl	1014638 <ull_pdu_rx_alloc>
		ull_rx_put_sched(rx->hdr.link, rx);
 101c468:	4629      	mov	r1, r5
			ftr->extra = ull_pdu_rx_alloc();
 101c46a:	4603      	mov	r3, r0
		ull_rx_put_sched(rx->hdr.link, rx);
 101c46c:	6828      	ldr	r0, [r5, #0]
			ftr->extra = ull_pdu_rx_alloc();
 101c46e:	60eb      	str	r3, [r5, #12]
}
 101c470:	b008      	add	sp, #32
 101c472:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		ull_rx_put_sched(rx->hdr.link, rx);
 101c476:	f7f8 b90d 	b.w	1014694 <ull_rx_put_sched>
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
 101c47a:	7f6a      	ldrb	r2, [r5, #29]
 101c47c:	2a0c      	cmp	r2, #12
 101c47e:	f47f af6f 	bne.w	101c360 <isr_rx+0x14>
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
 101c482:	f1b8 0f00 	cmp.w	r8, #0
 101c486:	f47f af6b 	bne.w	101c360 <isr_rx+0x14>
	return (((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) == 0U) ||
 101c48a:	7a62      	ldrb	r2, [r4, #9]
		 devmatch_ok) &&
 101c48c:	07d0      	lsls	r0, r2, #31
 101c48e:	d502      	bpl.n	101c496 <isr_rx+0x14a>
	return (((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) == 0U) ||
 101c490:	2e00      	cmp	r6, #0
 101c492:	f43f af65 	beq.w	101c360 <isr_rx+0x14>
	return (tx_addr == sr->rx_addr) &&
 101c496:	ebba 1fd1 	cmp.w	sl, r1, lsr #7
 101c49a:	f47f af61 	bne.w	101c360 <isr_rx+0x14>
		!memcmp(addr, sr->scan_req.adv_addr, BDADDR_SIZE);
 101c49e:	2206      	movs	r2, #6
 101c4a0:	4618      	mov	r0, r3
 101c4a2:	f105 0124 	add.w	r1, r5, #36	; 0x24
 101c4a6:	9305      	str	r3, [sp, #20]
 101c4a8:	f00a fa54 	bl	1026954 <memcmp>
	return (tx_addr == sr->rx_addr) &&
 101c4ac:	b300      	cbz	r0, 101c4f0 <isr_rx+0x1a4>
	} else if ((pdu_rx->type == PDU_ADV_TYPE_CONNECT_IND) &&
 101c4ae:	7f2a      	ldrb	r2, [r5, #28]
 101c4b0:	9b05      	ldr	r3, [sp, #20]
 101c4b2:	f002 020f 	and.w	r2, r2, #15
 101c4b6:	e791      	b.n	101c3dc <isr_rx+0x90>
		LL_ASSERT(!radio_is_ready());
 101c4b8:	f240 633c 	movw	r3, #1596	; 0x63c
 101c4bc:	4a1e      	ldr	r2, [pc, #120]	; (101c538 <isr_rx+0x1ec>)
 101c4be:	491f      	ldr	r1, [pc, #124]	; (101c53c <isr_rx+0x1f0>)
 101c4c0:	481f      	ldr	r0, [pc, #124]	; (101c540 <isr_rx+0x1f4>)
 101c4c2:	f008 fb88 	bl	1024bd6 <assert_print>
 101c4c6:	4040      	eors	r0, r0
 101c4c8:	f380 8811 	msr	BASEPRI, r0
 101c4cc:	f04f 0003 	mov.w	r0, #3
 101c4d0:	df02      	svc	2
 101c4d2:	e7ab      	b.n	101c42c <isr_rx+0xe0>
	LL_ASSERT(node_rx);
 101c4d4:	f240 53dc 	movw	r3, #1500	; 0x5dc
 101c4d8:	4a17      	ldr	r2, [pc, #92]	; (101c538 <isr_rx+0x1ec>)
 101c4da:	491a      	ldr	r1, [pc, #104]	; (101c544 <isr_rx+0x1f8>)
 101c4dc:	4818      	ldr	r0, [pc, #96]	; (101c540 <isr_rx+0x1f4>)
 101c4de:	f008 fb7a 	bl	1024bd6 <assert_print>
 101c4e2:	4040      	eors	r0, r0
 101c4e4:	f380 8811 	msr	BASEPRI, r0
 101c4e8:	f04f 0003 	mov.w	r0, #3
 101c4ec:	df02      	svc	2
 101c4ee:	e759      	b.n	101c3a4 <isr_rx+0x58>
		radio_isr_set(isr_done, lll);
 101c4f0:	4621      	mov	r1, r4
 101c4f2:	480f      	ldr	r0, [pc, #60]	; (101c530 <isr_rx+0x1e4>)
 101c4f4:	f000 fe18 	bl	101d128 <radio_isr_set>
		radio_switch_complete_and_disable();
 101c4f8:	f001 f84c 	bl	101d594 <radio_switch_complete_and_disable>
}

static inline struct pdu_adv *lll_adv_scan_rsp_curr_get(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.first];
 101c4fc:	7e23      	ldrb	r3, [r4, #24]
 101c4fe:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		radio_pkt_tx_set(lll_adv_scan_rsp_curr_get(lll));
 101c502:	69d8      	ldr	r0, [r3, #28]
 101c504:	f000 ff12 	bl	101d32c <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
 101c508:	f000 ff6a 	bl	101d3e0 <radio_is_ready>
 101c50c:	b910      	cbnz	r0, 101c514 <isr_rx+0x1c8>
}
 101c50e:	b008      	add	sp, #32
 101c510:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		LL_ASSERT(!radio_is_ready());
 101c514:	f240 53f5 	movw	r3, #1525	; 0x5f5
 101c518:	4a07      	ldr	r2, [pc, #28]	; (101c538 <isr_rx+0x1ec>)
 101c51a:	4908      	ldr	r1, [pc, #32]	; (101c53c <isr_rx+0x1f0>)
 101c51c:	4808      	ldr	r0, [pc, #32]	; (101c540 <isr_rx+0x1f4>)
 101c51e:	f008 fb5a 	bl	1024bd6 <assert_print>
 101c522:	4040      	eors	r0, r0
 101c524:	f380 8811 	msr	BASEPRI, r0
 101c528:	f04f 0003 	mov.w	r0, #3
 101c52c:	df02      	svc	2
		if (!err) {
 101c52e:	e7ee      	b.n	101c50e <isr_rx+0x1c2>
 101c530:	0101c0e9 	.word	0x0101c0e9
 101c534:	0101bd05 	.word	0x0101bd05
 101c538:	0102b094 	.word	0x0102b094
 101c53c:	0102b0e8 	.word	0x0102b0e8
 101c540:	0102a278 	.word	0x0102a278
 101c544:	0102b0e0 	.word	0x0102b0e0

0101c548 <isr_done>:
{
	return 0;
}

static void isr_done(void *param)
{
 101c548:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 101c54a:	4605      	mov	r5, r0
	struct event_done_extra *e;

	lll_isr_status_reset();
 101c54c:	f7ff f968 	bl	101b820 <lll_isr_status_reset>

	e = ull_event_done_extra_get();
 101c550:	f7f8 f97e 	bl	1014850 <ull_event_done_extra_get>
	LL_ASSERT(e);
 101c554:	4604      	mov	r4, r0
 101c556:	2800      	cmp	r0, #0
 101c558:	d036      	beq.n	101c5c8 <isr_done+0x80>

	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
 101c55a:	2101      	movs	r1, #1
	e->trx_cnt = trx_cnt;
	e->crc_valid = crc_valid;
 101c55c:	4a21      	ldr	r2, [pc, #132]	; (101c5e4 <isr_done+0x9c>)
	e->trx_cnt = trx_cnt;
 101c55e:	4b22      	ldr	r3, [pc, #136]	; (101c5e8 <isr_done+0xa0>)
	e->crc_valid = crc_valid;
 101c560:	7810      	ldrb	r0, [r2, #0]

#if defined(CONFIG_BT_CTLR_LE_ENC)
	e->mic_state = mic_state;
 101c562:	4a22      	ldr	r2, [pc, #136]	; (101c5ec <isr_done+0xa4>)
	e->trx_cnt = trx_cnt;
 101c564:	881b      	ldrh	r3, [r3, #0]
	e->mic_state = mic_state;
 101c566:	7812      	ldrb	r2, [r2, #0]
	e->trx_cnt = trx_cnt;
 101c568:	80a3      	strh	r3, [r4, #4]
	e->mic_state = mic_state;
 101c56a:	7262      	strb	r2, [r4, #9]
	e->crc_valid = crc_valid;
 101c56c:	7a22      	ldrb	r2, [r4, #8]
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
 101c56e:	7021      	strb	r1, [r4, #0]
	e->crc_valid = crc_valid;
 101c570:	f360 0200 	bfi	r2, r0, #0, #1
 101c574:	7222      	strb	r2, [r4, #8]
#endif /* CONFIG_BT_CTLR_LE_ENC */

#if defined(CONFIG_BT_PERIPHERAL)
	if (trx_cnt) {
 101c576:	b11b      	cbz	r3, 101c580 <isr_done+0x38>
		struct lll_conn *lll = param;

		if (lll->role) {
 101c578:	f995 301d 	ldrsb.w	r3, [r5, #29]
 101c57c:	2b00      	cmp	r3, #0
 101c57e:	db04      	blt.n	101c58a <isr_done+0x42>
			lll->periph.window_size_event_us = 0;
		}
	}
#endif /* CONFIG_BT_PERIPHERAL */

	lll_isr_cleanup(param);
 101c580:	4628      	mov	r0, r5
}
 101c582:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	lll_isr_cleanup(param);
 101c586:	f7ff b957 	b.w	101b838 <lll_isr_cleanup>
				addr_us_get(lll->phy_rx);
 101c58a:	f895 305b 	ldrb.w	r3, [r5, #91]	; 0x5b
 101c58e:	f003 0307 	and.w	r3, r3, #7
 */
#define HCTO_START_DELAY_US 1U

static inline uint32_t addr_us_get(uint8_t phy)
{
	switch (phy) {
 101c592:	2b02      	cmp	r3, #2
 101c594:	d016      	beq.n	101c5c4 <isr_done+0x7c>
	default:
	case BIT(0):
		return 40;
 101c596:	2b04      	cmp	r3, #4
 101c598:	bf0c      	ite	eq
 101c59a:	f44f 77bc 	moveq.w	r7, #376	; 0x178
 101c59e:	2728      	movne	r7, #40	; 0x28
				radio_tmr_aa_restore() - radio_tmr_ready_get();
 101c5a0:	f001 f93a 	bl	101d818 <radio_tmr_aa_restore>
 101c5a4:	4606      	mov	r6, r0
 101c5a6:	f001 f93d 	bl	101d824 <radio_tmr_ready_get>
			lll->periph.window_widening_event_us = 0;
 101c5aa:	2300      	movs	r3, #0
				radio_tmr_aa_restore() - radio_tmr_ready_get();
 101c5ac:	1a36      	subs	r6, r6, r0
			e->drift.start_to_address_actual_us =
 101c5ae:	60e6      	str	r6, [r4, #12]
				lll->periph.window_widening_event_us;
 101c5b0:	6b2a      	ldr	r2, [r5, #48]	; 0x30
	lll_isr_cleanup(param);
 101c5b2:	4628      	mov	r0, r5
			e->drift.window_widening_event_us =
 101c5b4:	e9c4 2704 	strd	r2, r7, [r4, #16]
			lll->periph.window_widening_event_us = 0;
 101c5b8:	632b      	str	r3, [r5, #48]	; 0x30
			lll->periph.window_size_event_us = 0;
 101c5ba:	63ab      	str	r3, [r5, #56]	; 0x38
}
 101c5bc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	lll_isr_cleanup(param);
 101c5c0:	f7ff b93a 	b.w	101b838 <lll_isr_cleanup>
	switch (phy) {
 101c5c4:	2718      	movs	r7, #24
 101c5c6:	e7eb      	b.n	101c5a0 <isr_done+0x58>
	LL_ASSERT(e);
 101c5c8:	f44f 7354 	mov.w	r3, #848	; 0x350
 101c5cc:	4a08      	ldr	r2, [pc, #32]	; (101c5f0 <isr_done+0xa8>)
 101c5ce:	4909      	ldr	r1, [pc, #36]	; (101c5f4 <isr_done+0xac>)
 101c5d0:	4809      	ldr	r0, [pc, #36]	; (101c5f8 <isr_done+0xb0>)
 101c5d2:	f008 fb00 	bl	1024bd6 <assert_print>
 101c5d6:	4040      	eors	r0, r0
 101c5d8:	f380 8811 	msr	BASEPRI, r0
 101c5dc:	f04f 0003 	mov.w	r0, #3
 101c5e0:	df02      	svc	2
 101c5e2:	e7ba      	b.n	101c55a <isr_done+0x12>
 101c5e4:	21008353 	.word	0x21008353
 101c5e8:	210081d8 	.word	0x210081d8
 101c5ec:	21008352 	.word	0x21008352
 101c5f0:	0102b12c 	.word	0x0102b12c
 101c5f4:	0102a794 	.word	0x0102a794
 101c5f8:	0102a278 	.word	0x0102a278

0101c5fc <lll_conn_init>:
{
 101c5fc:	b508      	push	{r3, lr}

static void empty_tx_init(void)
{
	struct pdu_data *p;

	p = (void *)radio_pkt_empty_get();
 101c5fe:	f000 ff23 	bl	101d448 <radio_pkt_empty_get>
 101c602:	4603      	mov	r3, r0
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
 101c604:	2101      	movs	r1, #1
 101c606:	781a      	ldrb	r2, [r3, #0]
}
 101c608:	2000      	movs	r0, #0
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
 101c60a:	f361 0201 	bfi	r2, r1, #0, #2
 101c60e:	701a      	strb	r2, [r3, #0]
}
 101c610:	bd08      	pop	{r3, pc}
 101c612:	bf00      	nop

0101c614 <lll_conn_reset>:
}
 101c614:	2000      	movs	r0, #0
 101c616:	4770      	bx	lr

0101c618 <lll_conn_flush>:
}
 101c618:	4770      	bx	lr
 101c61a:	bf00      	nop

0101c61c <lll_conn_prepare_reset>:
	trx_cnt = 0U;
 101c61c:	2300      	movs	r3, #0
{
 101c61e:	b410      	push	{r4}
	crc_valid = 0U;
 101c620:	4804      	ldr	r0, [pc, #16]	; (101c634 <lll_conn_prepare_reset+0x18>)
	trx_cnt = 0U;
 101c622:	4c05      	ldr	r4, [pc, #20]	; (101c638 <lll_conn_prepare_reset+0x1c>)
	crc_expire = 0U;
 101c624:	4905      	ldr	r1, [pc, #20]	; (101c63c <lll_conn_prepare_reset+0x20>)
	mic_state = LLL_CONN_MIC_NONE;
 101c626:	4a06      	ldr	r2, [pc, #24]	; (101c640 <lll_conn_prepare_reset+0x24>)
	trx_cnt = 0U;
 101c628:	8023      	strh	r3, [r4, #0]
	crc_valid = 0U;
 101c62a:	7003      	strb	r3, [r0, #0]
	crc_expire = 0U;
 101c62c:	700b      	strb	r3, [r1, #0]
	mic_state = LLL_CONN_MIC_NONE;
 101c62e:	7013      	strb	r3, [r2, #0]
}
 101c630:	bc10      	pop	{r4}
 101c632:	4770      	bx	lr
 101c634:	21008353 	.word	0x21008353
 101c638:	210081d8 	.word	0x210081d8
 101c63c:	21008354 	.word	0x21008354
 101c640:	21008352 	.word	0x21008352

0101c644 <lll_conn_abort_cb>:
{
 101c644:	b538      	push	{r3, r4, r5, lr}
	if (!prepare_param) {
 101c646:	b348      	cbz	r0, 101c69c <lll_conn_abort_cb+0x58>
	err = lll_hfclock_off();
 101c648:	4604      	mov	r4, r0
 101c64a:	460d      	mov	r5, r1
 101c64c:	f7ff faa0 	bl	101bb90 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
 101c650:	2800      	cmp	r0, #0
 101c652:	db16      	blt.n	101c682 <lll_conn_abort_cb+0x3e>
	lll = prepare_param->param;
 101c654:	68e2      	ldr	r2, [r4, #12]
	lll->latency_prepare += (prepare_param->lazy + 1);
 101c656:	8923      	ldrh	r3, [r4, #8]
 101c658:	8a51      	ldrh	r1, [r2, #18]
 101c65a:	3301      	adds	r3, #1
 101c65c:	440b      	add	r3, r1
 101c65e:	8253      	strh	r3, [r2, #18]
	e = ull_event_done_extra_get();
 101c660:	f7f8 f8f6 	bl	1014850 <ull_event_done_extra_get>
	LL_ASSERT(e);
 101c664:	4604      	mov	r4, r0
 101c666:	b300      	cbz	r0, 101c6aa <lll_conn_abort_cb+0x66>
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
 101c668:	2101      	movs	r1, #1
	e->trx_cnt = 0U;
 101c66a:	2200      	movs	r2, #0
	e->crc_valid = 0U;
 101c66c:	8923      	ldrh	r3, [r4, #8]
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
 101c66e:	7021      	strb	r1, [r4, #0]
	e->crc_valid = 0U;
 101c670:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 101c674:	8123      	strh	r3, [r4, #8]
	e->trx_cnt = 0U;
 101c676:	80a2      	strh	r2, [r4, #4]
	lll_done(param);
 101c678:	4628      	mov	r0, r5
}
 101c67a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lll_done(param);
 101c67e:	f7ff b813 	b.w	101b6a8 <lll_done>
	LL_ASSERT(err >= 0);
 101c682:	23aa      	movs	r3, #170	; 0xaa
 101c684:	4a0f      	ldr	r2, [pc, #60]	; (101c6c4 <lll_conn_abort_cb+0x80>)
 101c686:	4910      	ldr	r1, [pc, #64]	; (101c6c8 <lll_conn_abort_cb+0x84>)
 101c688:	4810      	ldr	r0, [pc, #64]	; (101c6cc <lll_conn_abort_cb+0x88>)
 101c68a:	f008 faa4 	bl	1024bd6 <assert_print>
 101c68e:	4040      	eors	r0, r0
 101c690:	f380 8811 	msr	BASEPRI, r0
 101c694:	f04f 0003 	mov.w	r0, #3
 101c698:	df02      	svc	2
 101c69a:	e7db      	b.n	101c654 <lll_conn_abort_cb+0x10>
		radio_isr_set(isr_done, param);
 101c69c:	480c      	ldr	r0, [pc, #48]	; (101c6d0 <lll_conn_abort_cb+0x8c>)
 101c69e:	f000 fd43 	bl	101d128 <radio_isr_set>
}
 101c6a2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		radio_disable();
 101c6a6:	f000 be6b 	b.w	101d380 <radio_disable>
	LL_ASSERT(e);
 101c6aa:	23b2      	movs	r3, #178	; 0xb2
 101c6ac:	4a05      	ldr	r2, [pc, #20]	; (101c6c4 <lll_conn_abort_cb+0x80>)
 101c6ae:	4909      	ldr	r1, [pc, #36]	; (101c6d4 <lll_conn_abort_cb+0x90>)
 101c6b0:	4806      	ldr	r0, [pc, #24]	; (101c6cc <lll_conn_abort_cb+0x88>)
 101c6b2:	f008 fa90 	bl	1024bd6 <assert_print>
 101c6b6:	4040      	eors	r0, r0
 101c6b8:	f380 8811 	msr	BASEPRI, r0
 101c6bc:	f04f 0003 	mov.w	r0, #3
 101c6c0:	df02      	svc	2
 101c6c2:	e7d1      	b.n	101c668 <lll_conn_abort_cb+0x24>
 101c6c4:	0102b12c 	.word	0x0102b12c
 101c6c8:	0102b004 	.word	0x0102b004
 101c6cc:	0102a278 	.word	0x0102a278
 101c6d0:	0101c549 	.word	0x0101c549
 101c6d4:	0102a794 	.word	0x0102a794

0101c6d8 <lll_conn_rx_pkt_set>:
{
 101c6d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 101c6da:	4605      	mov	r5, r0
	node_rx = ull_pdu_rx_alloc_peek(1);
 101c6dc:	2001      	movs	r0, #1
 101c6de:	f7f7 ff89 	bl	10145f4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 101c6e2:	4604      	mov	r4, r0
 101c6e4:	b350      	cbz	r0, 101c73c <lll_conn_rx_pkt_set+0x64>
	phy = lll->phy_rx;
 101c6e6:	f895 605b 	ldrb.w	r6, [r5, #91]	; 0x5b
	radio_phy_set(phy, 0);
 101c6ea:	2100      	movs	r1, #0
	phy = lll->phy_rx;
 101c6ec:	f006 0607 	and.w	r6, r6, #7
	radio_phy_set(phy, 0);
 101c6f0:	4630      	mov	r0, r6
	max_rx_octets = lll->dle.eff.max_rx_octets;
 101c6f2:	f8b5 704e 	ldrh.w	r7, [r5, #78]	; 0x4e
	radio_phy_set(phy, 0);
 101c6f6:	f000 fd67 	bl	101d1c8 <radio_phy_set>
	} else if (lll->enc_rx) {
 101c6fa:	f895 3072 	ldrb.w	r3, [r5, #114]	; 0x72
				    RADIO_PKT_CONF_FLAGS(RADIO_PKT_CONF_PDU_TYPE_DC, phy,
 101c6fe:	0072      	lsls	r2, r6, #1
	} else if (lll->enc_rx) {
 101c700:	071b      	lsls	r3, r3, #28
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, (max_rx_octets + PDU_MIC_SIZE),
 101c702:	b2f9      	uxtb	r1, r7
 101c704:	f042 0201 	orr.w	r2, r2, #1
						      node_rx->pdu));
 101c708:	f104 041c 	add.w	r4, r4, #28
	} else if (lll->enc_rx) {
 101c70c:	d50e      	bpl.n	101c72c <lll_conn_rx_pkt_set+0x54>
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, (max_rx_octets + PDU_MIC_SIZE),
 101c70e:	3104      	adds	r1, #4
 101c710:	2008      	movs	r0, #8
 101c712:	b2c9      	uxtb	r1, r1
 101c714:	f000 fdde 	bl	101d2d4 <radio_pkt_configure>
		radio_pkt_rx_set(radio_ccm_rx_pkt_set(&lll->ccm_rx, phy,
 101c718:	4622      	mov	r2, r4
 101c71a:	4631      	mov	r1, r6
 101c71c:	f105 0073 	add.w	r0, r5, #115	; 0x73
 101c720:	f001 f8aa 	bl	101d878 <radio_ccm_rx_pkt_set>
}
 101c724:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_rx_set(radio_ccm_rx_pkt_set(&lll->ccm_rx, phy,
 101c728:	f000 bdfa 	b.w	101d320 <radio_pkt_rx_set>
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, max_rx_octets,
 101c72c:	2008      	movs	r0, #8
 101c72e:	f000 fdd1 	bl	101d2d4 <radio_pkt_configure>
		radio_pkt_rx_set(node_rx->pdu);
 101c732:	4620      	mov	r0, r4
}
 101c734:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_rx_set(node_rx->pdu);
 101c738:	f000 bdf2 	b.w	101d320 <radio_pkt_rx_set>
	LL_ASSERT(node_rx);
 101c73c:	f240 2387 	movw	r3, #647	; 0x287
 101c740:	4a05      	ldr	r2, [pc, #20]	; (101c758 <lll_conn_rx_pkt_set+0x80>)
 101c742:	4906      	ldr	r1, [pc, #24]	; (101c75c <lll_conn_rx_pkt_set+0x84>)
 101c744:	4806      	ldr	r0, [pc, #24]	; (101c760 <lll_conn_rx_pkt_set+0x88>)
 101c746:	f008 fa46 	bl	1024bd6 <assert_print>
 101c74a:	4040      	eors	r0, r0
 101c74c:	f380 8811 	msr	BASEPRI, r0
 101c750:	f04f 0003 	mov.w	r0, #3
 101c754:	df02      	svc	2
 101c756:	e7c6      	b.n	101c6e6 <lll_conn_rx_pkt_set+0xe>
 101c758:	0102b12c 	.word	0x0102b12c
 101c75c:	0102b0e0 	.word	0x0102b0e0
 101c760:	0102a278 	.word	0x0102a278

0101c764 <lll_conn_isr_tx>:
{
 101c764:	b538      	push	{r3, r4, r5, lr}
 101c766:	4604      	mov	r4, r0
	lll_isr_tx_status_reset();
 101c768:	f7ff f848 	bl	101b7fc <lll_isr_tx_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
 101c76c:	2096      	movs	r0, #150	; 0x96
 101c76e:	f000 ff6d 	bl	101d64c <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx, lll->phy_flags);
 101c772:	f894 205a 	ldrb.w	r2, [r4, #90]	; 0x5a
 101c776:	f894 005b 	ldrb.w	r0, [r4, #91]	; 0x5b
 101c77a:	f3c2 03c0 	ubfx	r3, r2, #3, #1
 101c77e:	2100      	movs	r1, #0
 101c780:	f002 0207 	and.w	r2, r2, #7
 101c784:	f000 0007 	and.w	r0, r0, #7
 101c788:	f000 fea8 	bl	101d4dc <radio_switch_complete_and_tx>
	lll_conn_rx_pkt_set(lll);
 101c78c:	4620      	mov	r0, r4
 101c78e:	f7ff ffa3 	bl	101c6d8 <lll_conn_rx_pkt_set>
	LL_ASSERT(!radio_is_ready());
 101c792:	f000 fe25 	bl	101d3e0 <radio_is_ready>
 101c796:	bb58      	cbnz	r0, 101c7f0 <lll_conn_isr_tx+0x8c>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + (EVENT_CLOCK_JITTER_US << 1) +
 101c798:	f001 f868 	bl	101d86c <radio_tmr_tifs_base_get>
 101c79c:	4605      	mov	r5, r0
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 101c79e:	f894 005b 	ldrb.w	r0, [r4, #91]	; 0x5b
 101c7a2:	2101      	movs	r1, #1
 101c7a4:	f000 0007 	and.w	r0, r0, #7
 101c7a8:	f000 fdca 	bl	101d340 <radio_rx_chain_delay_get>
	hcto += addr_us_get(lll->phy_rx);
 101c7ac:	f894 305b 	ldrb.w	r3, [r4, #91]	; 0x5b
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 101c7b0:	4405      	add	r5, r0
	hcto += addr_us_get(lll->phy_rx);
 101c7b2:	f003 0307 	and.w	r3, r3, #7
 101c7b6:	2b02      	cmp	r3, #2
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 101c7b8:	f105 05a3 	add.w	r5, r5, #163	; 0xa3
 101c7bc:	d016      	beq.n	101c7ec <lll_conn_isr_tx+0x88>
		return 40;
 101c7be:	2b04      	cmp	r3, #4
 101c7c0:	bf0c      	ite	eq
 101c7c2:	f44f 73bc 	moveq.w	r3, #376	; 0x178
 101c7c6:	2328      	movne	r3, #40	; 0x28
	hcto -= radio_tx_chain_delay_get(lll->phy_tx, lll->phy_flags);
 101c7c8:	f894 005a 	ldrb.w	r0, [r4, #90]	; 0x5a
	hcto += addr_us_get(lll->phy_rx);
 101c7cc:	441d      	add	r5, r3
	hcto -= radio_tx_chain_delay_get(lll->phy_tx, lll->phy_flags);
 101c7ce:	f3c0 01c0 	ubfx	r1, r0, #3, #1
 101c7d2:	f000 0007 	and.w	r0, r0, #7
 101c7d6:	f000 fdaf 	bl	101d338 <radio_tx_chain_delay_get>
	radio_tmr_hcto_configure(hcto);
 101c7da:	1a28      	subs	r0, r5, r0
 101c7dc:	f000 ffd2 	bl	101d784 <radio_tmr_hcto_configure>
	radio_isr_set(lll_conn_isr_rx, param);
 101c7e0:	4621      	mov	r1, r4
}
 101c7e2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_isr_set(lll_conn_isr_rx, param);
 101c7e6:	4809      	ldr	r0, [pc, #36]	; (101c80c <lll_conn_isr_tx+0xa8>)
 101c7e8:	f000 bc9e 	b.w	101d128 <radio_isr_set>
	switch (phy) {
 101c7ec:	2318      	movs	r3, #24
 101c7ee:	e7eb      	b.n	101c7c8 <lll_conn_isr_tx+0x64>
	LL_ASSERT(!radio_is_ready());
 101c7f0:	f44f 730f 	mov.w	r3, #572	; 0x23c
 101c7f4:	4a06      	ldr	r2, [pc, #24]	; (101c810 <lll_conn_isr_tx+0xac>)
 101c7f6:	4907      	ldr	r1, [pc, #28]	; (101c814 <lll_conn_isr_tx+0xb0>)
 101c7f8:	4807      	ldr	r0, [pc, #28]	; (101c818 <lll_conn_isr_tx+0xb4>)
 101c7fa:	f008 f9ec 	bl	1024bd6 <assert_print>
 101c7fe:	4040      	eors	r0, r0
 101c800:	f380 8811 	msr	BASEPRI, r0
 101c804:	f04f 0003 	mov.w	r0, #3
 101c808:	df02      	svc	2
 101c80a:	e7c5      	b.n	101c798 <lll_conn_isr_tx+0x34>
 101c80c:	0101c931 	.word	0x0101c931
 101c810:	0102b12c 	.word	0x0102b12c
 101c814:	0102b0e8 	.word	0x0102b0e8
 101c818:	0102a278 	.word	0x0102a278

0101c81c <lll_conn_tx_pkt_set>:
{
 101c81c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 101c81e:	4605      	mov	r5, r0
 101c820:	460f      	mov	r7, r1
	phy = lll->phy_tx;
 101c822:	f890 105a 	ldrb.w	r1, [r0, #90]	; 0x5a
	max_tx_octets = lll->dle.eff.max_tx_octets;
 101c826:	f8b0 604c 	ldrh.w	r6, [r0, #76]	; 0x4c
	phy = lll->phy_tx;
 101c82a:	f001 0407 	and.w	r4, r1, #7
	radio_phy_set(phy, flags);
 101c82e:	4620      	mov	r0, r4
 101c830:	f3c1 01c0 	ubfx	r1, r1, #3, #1
 101c834:	f000 fcc8 	bl	101d1c8 <radio_phy_set>
	} else if (lll->enc_tx) {
 101c838:	f895 3072 	ldrb.w	r3, [r5, #114]	; 0x72
		pkt_flags = RADIO_PKT_CONF_FLAGS(RADIO_PKT_CONF_PDU_TYPE_DC, phy,
 101c83c:	0062      	lsls	r2, r4, #1
	} else if (lll->enc_tx) {
 101c83e:	06db      	lsls	r3, r3, #27
		pkt_flags = RADIO_PKT_CONF_FLAGS(RADIO_PKT_CONF_PDU_TYPE_DC, phy,
 101c840:	f042 0201 	orr.w	r2, r2, #1
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, (max_tx_octets + PDU_MIC_SIZE),
 101c844:	b2f1      	uxtb	r1, r6
	} else if (lll->enc_tx) {
 101c846:	d50d      	bpl.n	101c864 <lll_conn_tx_pkt_set+0x48>
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, (max_tx_octets + PDU_MIC_SIZE),
 101c848:	3104      	adds	r1, #4
 101c84a:	2008      	movs	r0, #8
 101c84c:	b2c9      	uxtb	r1, r1
 101c84e:	f000 fd41 	bl	101d2d4 <radio_pkt_configure>
		radio_pkt_tx_set(radio_ccm_tx_pkt_set(&lll->ccm_tx, pdu_data_tx));
 101c852:	4639      	mov	r1, r7
 101c854:	f105 0094 	add.w	r0, r5, #148	; 0x94
 101c858:	f001 f854 	bl	101d904 <radio_ccm_tx_pkt_set>
}
 101c85c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_tx_set(radio_ccm_tx_pkt_set(&lll->ccm_tx, pdu_data_tx));
 101c860:	f000 bd64 	b.w	101d32c <radio_pkt_tx_set>
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, max_tx_octets, pkt_flags);
 101c864:	2008      	movs	r0, #8
 101c866:	f000 fd35 	bl	101d2d4 <radio_pkt_configure>
		radio_pkt_tx_set(pdu_data_tx);
 101c86a:	4638      	mov	r0, r7
}
 101c86c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_tx_set(pdu_data_tx);
 101c870:	f000 bd5c 	b.w	101d32c <radio_pkt_tx_set>

0101c874 <lll_conn_pdu_tx_prep>:
{
 101c874:	b5f0      	push	{r4, r5, r6, r7, lr}
 101c876:	4605      	mov	r5, r0
 101c878:	b083      	sub	sp, #12
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
 101c87a:	aa01      	add	r2, sp, #4
{
 101c87c:	460f      	mov	r7, r1
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
 101c87e:	e9d0 0117 	ldrd	r0, r1, [r0, #92]	; 0x5c
 101c882:	f7f4 fb41 	bl	1010f08 <memq_peek>
	if (lll->empty || !link) {
 101c886:	f895 3072 	ldrb.w	r3, [r5, #114]	; 0x72
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
 101c88a:	4606      	mov	r6, r0
	if (lll->empty || !link) {
 101c88c:	075a      	lsls	r2, r3, #29
 101c88e:	d438      	bmi.n	101c902 <lll_conn_pdu_tx_prep+0x8e>
 101c890:	b348      	cbz	r0, 101c8e6 <lll_conn_pdu_tx_prep+0x72>
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
 101c892:	9c01      	ldr	r4, [sp, #4]
 101c894:	f895 3071 	ldrb.w	r3, [r5, #113]	; 0x71
		if (!lll->packet_tx_head_len) {
 101c898:	f895 2070 	ldrb.w	r2, [r5, #112]	; 0x70
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
 101c89c:	3404      	adds	r4, #4
 101c89e:	441c      	add	r4, r3
		if (!lll->packet_tx_head_len) {
 101c8a0:	b912      	cbnz	r2, 101c8a8 <lll_conn_pdu_tx_prep+0x34>
			lll->packet_tx_head_len = p->len;
 101c8a2:	7862      	ldrb	r2, [r4, #1]
 101c8a4:	f885 2070 	strb.w	r2, [r5, #112]	; 0x70
		if (lll->packet_tx_head_offset) {
 101c8a8:	b133      	cbz	r3, 101c8b8 <lll_conn_pdu_tx_prep+0x44>
			p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
 101c8aa:	2201      	movs	r2, #1
 101c8ac:	7823      	ldrb	r3, [r4, #0]
 101c8ae:	f362 0301 	bfi	r3, r2, #0, #2
 101c8b2:	7023      	strb	r3, [r4, #0]
		p->len = lll->packet_tx_head_len - lll->packet_tx_head_offset;
 101c8b4:	f895 3071 	ldrb.w	r3, [r5, #113]	; 0x71
 101c8b8:	f895 2070 	ldrb.w	r2, [r5, #112]	; 0x70
		max_tx_octets = ull_conn_lll_max_tx_octets_get(lll);
 101c8bc:	4628      	mov	r0, r5
		p->len = lll->packet_tx_head_len - lll->packet_tx_head_offset;
 101c8be:	1ad3      	subs	r3, r2, r3
 101c8c0:	7063      	strb	r3, [r4, #1]
		max_tx_octets = ull_conn_lll_max_tx_octets_get(lll);
 101c8c2:	f7fa f85b 	bl	101697c <ull_conn_lll_max_tx_octets_get>
		if (((PDU_DC_CTRL_TX_SIZE_MAX <= PDU_DC_PAYLOAD_SIZE_MIN) ||
 101c8c6:	7863      	ldrb	r3, [r4, #1]
 101c8c8:	4283      	cmp	r3, r0
 101c8ca:	d92a      	bls.n	101c922 <lll_conn_pdu_tx_prep+0xae>
			p->len = max_tx_octets;
 101c8cc:	7060      	strb	r0, [r4, #1]
{
 101c8ce:	2101      	movs	r1, #1
		p->resv = 0U;
 101c8d0:	2200      	movs	r2, #0
			p->md = 1U;
 101c8d2:	7823      	ldrb	r3, [r4, #0]
		p->resv = 0U;
 101c8d4:	70a2      	strb	r2, [r4, #2]
			p->md = 1U;
 101c8d6:	f003 030f 	and.w	r3, r3, #15
 101c8da:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 101c8de:	7023      	strb	r3, [r4, #0]
	*pdu_data_tx = p;
 101c8e0:	603c      	str	r4, [r7, #0]
}
 101c8e2:	b003      	add	sp, #12
 101c8e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		lll->empty = 1U;
 101c8e6:	f043 0304 	orr.w	r3, r3, #4
 101c8ea:	f885 3072 	strb.w	r3, [r5, #114]	; 0x72
		p = (void *)radio_pkt_empty_get();
 101c8ee:	f000 fdab 	bl	101d448 <radio_pkt_empty_get>
 101c8f2:	4604      	mov	r4, r0
			p->md = 0U;
 101c8f4:	7823      	ldrb	r3, [r4, #0]
 101c8f6:	f36f 1304 	bfc	r3, #4, #1
 101c8fa:	7023      	strb	r3, [r4, #0]
	*pdu_data_tx = p;
 101c8fc:	603c      	str	r4, [r7, #0]
}
 101c8fe:	b003      	add	sp, #12
 101c900:	bdf0      	pop	{r4, r5, r6, r7, pc}
		lll->empty = 1U;
 101c902:	f043 0304 	orr.w	r3, r3, #4
 101c906:	f885 3072 	strb.w	r3, [r5, #114]	; 0x72
		p = (void *)radio_pkt_empty_get();
 101c90a:	f000 fd9d 	bl	101d448 <radio_pkt_empty_get>
 101c90e:	4604      	mov	r4, r0
		if (link || FORCE_MD_CNT_GET()) {
 101c910:	2e00      	cmp	r6, #0
 101c912:	d0ef      	beq.n	101c8f4 <lll_conn_pdu_tx_prep+0x80>
			p->md = 1U;
 101c914:	7803      	ldrb	r3, [r0, #0]
 101c916:	f043 0310 	orr.w	r3, r3, #16
 101c91a:	7003      	strb	r3, [r0, #0]
	*pdu_data_tx = p;
 101c91c:	603c      	str	r4, [r7, #0]
}
 101c91e:	b003      	add	sp, #12
 101c920:	bdf0      	pop	{r4, r5, r6, r7, pc}
		} else if ((link->next != lll->memq_tx.tail) ||
 101c922:	6832      	ldr	r2, [r6, #0]
 101c924:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 101c926:	429a      	cmp	r2, r3
 101c928:	d1d1      	bne.n	101c8ce <lll_conn_pdu_tx_prep+0x5a>
 101c92a:	2100      	movs	r1, #0
 101c92c:	e7d0      	b.n	101c8d0 <lll_conn_pdu_tx_prep+0x5c>
 101c92e:	bf00      	nop

0101c930 <lll_conn_isr_rx>:
{
 101c930:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 101c934:	b082      	sub	sp, #8
 101c936:	4604      	mov	r4, r0
	trx_done = radio_is_done();
 101c938:	f000 fd5c 	bl	101d3f4 <radio_is_done>
	if (trx_done) {
 101c93c:	b2c0      	uxtb	r0, r0
 101c93e:	b950      	cbnz	r0, 101c956 <lll_conn_isr_rx+0x26>
	lll_isr_rx_status_reset();
 101c940:	f7fe ff64 	bl	101b80c <lll_isr_rx_status_reset>
		radio_isr_set(isr_done, param);
 101c944:	4621      	mov	r1, r4
 101c946:	48b8      	ldr	r0, [pc, #736]	; (101cc28 <lll_conn_isr_rx+0x2f8>)
 101c948:	f000 fbee 	bl	101d128 <radio_isr_set>
}
 101c94c:	b002      	add	sp, #8
 101c94e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		radio_disable();
 101c952:	f000 bd15 	b.w	101d380 <radio_disable>
		crc_ok = radio_crc_is_valid();
 101c956:	f000 fd6d 	bl	101d434 <radio_crc_is_valid>
 101c95a:	b2c5      	uxtb	r5, r0
		rssi_ready = radio_rssi_is_ready();
 101c95c:	f000 fe3a 	bl	101d5d4 <radio_rssi_is_ready>
	lll_isr_rx_status_reset();
 101c960:	f7fe ff54 	bl	101b80c <lll_isr_rx_status_reset>
	node_rx = ull_pdu_rx_alloc_peek(1);
 101c964:	2001      	movs	r0, #1
	trx_cnt++;
 101c966:	4ab1      	ldr	r2, [pc, #708]	; (101cc2c <lll_conn_isr_rx+0x2fc>)
 101c968:	8813      	ldrh	r3, [r2, #0]
 101c96a:	4403      	add	r3, r0
 101c96c:	8013      	strh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
 101c96e:	f7f7 fe41 	bl	10145f4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 101c972:	4680      	mov	r8, r0
 101c974:	2800      	cmp	r0, #0
 101c976:	f000 80dd 	beq.w	101cb34 <lll_conn_isr_rx+0x204>
	if (crc_ok) {
 101c97a:	2d00      	cmp	r5, #0
 101c97c:	d149      	bne.n	101ca12 <lll_conn_isr_rx+0xe2>
		if (crc_expire == 0U) {
 101c97e:	4bac      	ldr	r3, [pc, #688]	; (101cc30 <lll_conn_isr_rx+0x300>)
 101c980:	781e      	ldrb	r6, [r3, #0]
 101c982:	2e00      	cmp	r6, #0
 101c984:	f040 80a4 	bne.w	101cad0 <lll_conn_isr_rx+0x1a0>
		crc_expire--;
 101c988:	2201      	movs	r2, #1
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 101c98a:	4620      	mov	r0, r4
 101c98c:	a901      	add	r1, sp, #4
		crc_expire--;
 101c98e:	701a      	strb	r2, [r3, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 101c990:	f7ff ff70 	bl	101c874 <lll_conn_pdu_tx_prep>
	pdu_data_tx->sn = lll->sn;
 101c994:	2600      	movs	r6, #0
 101c996:	4635      	mov	r5, r6
 101c998:	9f01      	ldr	r7, [sp, #4]
		radio_tmr_tifs_set(EVENT_IFS_US);
 101c99a:	2096      	movs	r0, #150	; 0x96
 101c99c:	f000 fe56 	bl	101d64c <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(lll->phy_rx);
 101c9a0:	f894 005b 	ldrb.w	r0, [r4, #91]	; 0x5b
 101c9a4:	f000 0007 	and.w	r0, r0, #7
 101c9a8:	f000 fd56 	bl	101d458 <radio_switch_complete_and_rx>
		radio_isr_set(lll_conn_isr_tx, param);
 101c9ac:	4621      	mov	r1, r4
 101c9ae:	48a1      	ldr	r0, [pc, #644]	; (101cc34 <lll_conn_isr_rx+0x304>)
 101c9b0:	f000 fbba 	bl	101d128 <radio_isr_set>
		radio_tmr_end_capture();
 101c9b4:	f000 ff3c 	bl	101d830 <radio_tmr_end_capture>
	pdu_data_tx->sn = lll->sn;
 101c9b8:	f894 2072 	ldrb.w	r2, [r4, #114]	; 0x72
 101c9bc:	783b      	ldrb	r3, [r7, #0]
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
 101c9be:	4639      	mov	r1, r7
	pdu_data_tx->sn = lll->sn;
 101c9c0:	f362 03c3 	bfi	r3, r2, #3, #1
 101c9c4:	703b      	strb	r3, [r7, #0]
	pdu_data_tx->nesn = lll->nesn;
 101c9c6:	f894 3072 	ldrb.w	r3, [r4, #114]	; 0x72
 101c9ca:	783a      	ldrb	r2, [r7, #0]
 101c9cc:	f3c3 0340 	ubfx	r3, r3, #1, #1
 101c9d0:	f363 0282 	bfi	r2, r3, #2, #1
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
 101c9d4:	4620      	mov	r0, r4
	pdu_data_tx->nesn = lll->nesn;
 101c9d6:	703a      	strb	r2, [r7, #0]
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
 101c9d8:	f7ff ff20 	bl	101c81c <lll_conn_tx_pkt_set>
	LL_ASSERT(!radio_is_ready());
 101c9dc:	f000 fd00 	bl	101d3e0 <radio_is_ready>
 101c9e0:	2800      	cmp	r0, #0
 101c9e2:	f040 8099 	bne.w	101cb18 <lll_conn_isr_rx+0x1e8>
	if (!radio_tmr_aa_restore()) {
 101c9e6:	f000 ff17 	bl	101d818 <radio_tmr_aa_restore>
 101c9ea:	2800      	cmp	r0, #0
 101c9ec:	d066      	beq.n	101cabc <lll_conn_isr_rx+0x18c>
	if (tx_release) {
 101c9ee:	2d00      	cmp	r5, #0
 101c9f0:	d06a      	beq.n	101cac8 <lll_conn_isr_rx+0x198>
		LL_ASSERT(lll->handle != 0xFFFF);
 101c9f2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 101c9f6:	89a0      	ldrh	r0, [r4, #12]
 101c9f8:	4298      	cmp	r0, r3
 101c9fa:	f000 80cc 	beq.w	101cb96 <lll_conn_isr_rx+0x266>
		ull_conn_lll_ack_enqueue(lll->handle, tx_release);
 101c9fe:	4629      	mov	r1, r5
 101ca00:	f7f9 ff20 	bl	1016844 <ull_conn_lll_ack_enqueue>
	if (is_rx_enqueue) {
 101ca04:	2e00      	cmp	r6, #0
 101ca06:	d175      	bne.n	101caf4 <lll_conn_isr_rx+0x1c4>
}
 101ca08:	b002      	add	sp, #8
 101ca0a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		ull_rx_sched();
 101ca0e:	f7f7 be39 	b.w	1014684 <ull_rx_sched>
	if (pdu_data_rx->nesn != lll->sn) {
 101ca12:	f894 3072 	ldrb.w	r3, [r4, #114]	; 0x72
 101ca16:	f898 201c 	ldrb.w	r2, [r8, #28]
 101ca1a:	f003 0101 	and.w	r1, r3, #1
 101ca1e:	f3c2 0080 	ubfx	r0, r2, #2, #1
 101ca22:	4288      	cmp	r0, r1
 101ca24:	f000 8096 	beq.w	101cb54 <lll_conn_isr_rx+0x224>
		if (lll->role) {
 101ca28:	f994 201d 	ldrsb.w	r2, [r4, #29]
		lll->sn++;
 101ca2c:	f081 0101 	eor.w	r1, r1, #1
 101ca30:	f361 0300 	bfi	r3, r1, #0, #1
		if (lll->role) {
 101ca34:	2a00      	cmp	r2, #0
		lll->sn++;
 101ca36:	f884 3072 	strb.w	r3, [r4, #114]	; 0x72
		if (lll->role) {
 101ca3a:	da05      	bge.n	101ca48 <lll_conn_isr_rx+0x118>
			lll->periph.latency_enabled = 1;
 101ca3c:	f894 3020 	ldrb.w	r3, [r4, #32]
 101ca40:	f043 0304 	orr.w	r3, r3, #4
 101ca44:	f884 3020 	strb.w	r3, [r4, #32]
		if (!lll->empty) {
 101ca48:	f894 3072 	ldrb.w	r3, [r4, #114]	; 0x72
 101ca4c:	075d      	lsls	r5, r3, #29
 101ca4e:	f100 80b3 	bmi.w	101cbb8 <lll_conn_isr_rx+0x288>
			link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail,
 101ca52:	e9d4 0117 	ldrd	r0, r1, [r4, #92]	; 0x5c
 101ca56:	aa01      	add	r2, sp, #4
 101ca58:	f7f4 fa56 	bl	1010f08 <memq_peek>
		if (link) {
 101ca5c:	4605      	mov	r5, r0
 101ca5e:	2800      	cmp	r0, #0
 101ca60:	f000 80b0 	beq.w	101cbc4 <lll_conn_isr_rx+0x294>
					       lll->packet_tx_head_offset);
 101ca64:	f894 2071 	ldrb.w	r2, [r4, #113]	; 0x71
			pdu_data_tx_len = pdu_data_tx->len;
 101ca68:	9b01      	ldr	r3, [sp, #4]
 101ca6a:	4413      	add	r3, r2
 101ca6c:	7959      	ldrb	r1, [r3, #5]
			if (pdu_data_tx_len != 0U) {
 101ca6e:	b171      	cbz	r1, 101ca8e <lll_conn_isr_rx+0x15e>
				if (lll->enc_tx) {
 101ca70:	f894 3072 	ldrb.w	r3, [r4, #114]	; 0x72
 101ca74:	06d8      	lsls	r0, r3, #27
 101ca76:	d50a      	bpl.n	101ca8e <lll_conn_isr_rx+0x15e>
					lll->ccm_tx.counter++;
 101ca78:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 101ca7c:	3301      	adds	r3, #1
 101ca7e:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
 101ca82:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 101ca86:	f143 0300 	adc.w	r3, r3, #0
 101ca8a:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
			if (offset < lll->packet_tx_head_len) {
 101ca8e:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
			offset = lll->packet_tx_head_offset + pdu_data_tx_len;
 101ca92:	440a      	add	r2, r1
 101ca94:	b2d2      	uxtb	r2, r2
			if (offset < lll->packet_tx_head_len) {
 101ca96:	429a      	cmp	r2, r3
 101ca98:	f0c0 809a 	bcc.w	101cbd0 <lll_conn_isr_rx+0x2a0>
			} else if (offset == lll->packet_tx_head_len) {
 101ca9c:	f000 80b0 	beq.w	101cc00 <lll_conn_isr_rx+0x2d0>
				LL_ASSERT(0);
 101caa0:	f44f 7377 	mov.w	r3, #988	; 0x3dc
 101caa4:	4a64      	ldr	r2, [pc, #400]	; (101cc38 <lll_conn_isr_rx+0x308>)
 101caa6:	4965      	ldr	r1, [pc, #404]	; (101cc3c <lll_conn_isr_rx+0x30c>)
 101caa8:	4865      	ldr	r0, [pc, #404]	; (101cc40 <lll_conn_isr_rx+0x310>)
 101caaa:	f008 f894 	bl	1024bd6 <assert_print>
 101caae:	4040      	eors	r0, r0
 101cab0:	f380 8811 	msr	BASEPRI, r0
 101cab4:	f04f 0003 	mov.w	r0, #3
 101cab8:	df02      	svc	2
 101caba:	e083      	b.n	101cbc4 <lll_conn_isr_rx+0x294>
		radio_tmr_aa_save(radio_tmr_aa_get());
 101cabc:	f000 fea0 	bl	101d800 <radio_tmr_aa_get>
 101cac0:	f000 fea4 	bl	101d80c <radio_tmr_aa_save>
	if (tx_release) {
 101cac4:	2d00      	cmp	r5, #0
 101cac6:	d194      	bne.n	101c9f2 <lll_conn_isr_rx+0xc2>
	if (is_rx_enqueue) {
 101cac8:	b9a6      	cbnz	r6, 101caf4 <lll_conn_isr_rx+0x1c4>
}
 101caca:	b002      	add	sp, #8
 101cacc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		crc_expire--;
 101cad0:	3e01      	subs	r6, #1
 101cad2:	b2f6      	uxtb	r6, r6
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 101cad4:	4620      	mov	r0, r4
 101cad6:	a901      	add	r1, sp, #4
		crc_expire--;
 101cad8:	701e      	strb	r6, [r3, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 101cada:	f7ff fecb 	bl	101c874 <lll_conn_pdu_tx_prep>
	is_done = is_done || ((crc_ok) && (pdu_data_rx->md == 0) &&
 101cade:	2e00      	cmp	r6, #0
 101cae0:	f47f af58 	bne.w	101c994 <lll_conn_isr_rx+0x64>
	pdu_data_tx->sn = lll->sn;
 101cae4:	9f01      	ldr	r7, [sp, #4]
		radio_isr_set(isr_done, param);
 101cae6:	4621      	mov	r1, r4
 101cae8:	484f      	ldr	r0, [pc, #316]	; (101cc28 <lll_conn_isr_rx+0x2f8>)
 101caea:	f000 fb1d 	bl	101d128 <radio_isr_set>
			radio_switch_complete_and_disable();
 101caee:	f000 fd51 	bl	101d594 <radio_switch_complete_and_disable>
 101caf2:	e761      	b.n	101c9b8 <lll_conn_isr_rx+0x88>
		ull_pdu_rx_alloc();
 101caf4:	f7f7 fda0 	bl	1014638 <ull_pdu_rx_alloc>
		node_rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 101caf8:	2303      	movs	r3, #3
 101cafa:	f888 3004 	strb.w	r3, [r8, #4]
		node_rx->hdr.handle = lll->handle;
 101cafe:	89a3      	ldrh	r3, [r4, #12]
		ull_rx_put(node_rx->hdr.link, node_rx);
 101cb00:	4641      	mov	r1, r8
 101cb02:	f8d8 0000 	ldr.w	r0, [r8]
		node_rx->hdr.handle = lll->handle;
 101cb06:	f8a8 3006 	strh.w	r3, [r8, #6]
		ull_rx_put(node_rx->hdr.link, node_rx);
 101cb0a:	f7f7 fdab 	bl	1014664 <ull_rx_put>
}
 101cb0e:	b002      	add	sp, #8
 101cb10:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		ull_rx_sched();
 101cb14:	f7f7 bdb6 	b.w	1014684 <ull_rx_sched>
	LL_ASSERT(!radio_is_ready());
 101cb18:	f240 138b 	movw	r3, #395	; 0x18b
 101cb1c:	4a46      	ldr	r2, [pc, #280]	; (101cc38 <lll_conn_isr_rx+0x308>)
 101cb1e:	4949      	ldr	r1, [pc, #292]	; (101cc44 <lll_conn_isr_rx+0x314>)
 101cb20:	4847      	ldr	r0, [pc, #284]	; (101cc40 <lll_conn_isr_rx+0x310>)
 101cb22:	f008 f858 	bl	1024bd6 <assert_print>
 101cb26:	4040      	eors	r0, r0
 101cb28:	f380 8811 	msr	BASEPRI, r0
 101cb2c:	f04f 0003 	mov.w	r0, #3
 101cb30:	df02      	svc	2
 101cb32:	e758      	b.n	101c9e6 <lll_conn_isr_rx+0xb6>
	LL_ASSERT(node_rx);
 101cb34:	23fd      	movs	r3, #253	; 0xfd
 101cb36:	4a40      	ldr	r2, [pc, #256]	; (101cc38 <lll_conn_isr_rx+0x308>)
 101cb38:	4943      	ldr	r1, [pc, #268]	; (101cc48 <lll_conn_isr_rx+0x318>)
 101cb3a:	4841      	ldr	r0, [pc, #260]	; (101cc40 <lll_conn_isr_rx+0x310>)
 101cb3c:	f008 f84b 	bl	1024bd6 <assert_print>
 101cb40:	4040      	eors	r0, r0
 101cb42:	f380 8811 	msr	BASEPRI, r0
 101cb46:	f04f 0003 	mov.w	r0, #3
 101cb4a:	df02      	svc	2
	if (crc_ok) {
 101cb4c:	2d00      	cmp	r5, #0
 101cb4e:	f43f af16 	beq.w	101c97e <lll_conn_isr_rx+0x4e>
 101cb52:	e75e      	b.n	101ca12 <lll_conn_isr_rx+0xe2>
	tx_release = NULL;
 101cb54:	2500      	movs	r5, #0
	if ((pdu_data_rx->sn == lll->nesn) &&
 101cb56:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 101cb5a:	f3c3 0340 	ubfx	r3, r3, #1, #1
 101cb5e:	429a      	cmp	r2, r3
 101cb60:	d039      	beq.n	101cbd6 <lll_conn_isr_rx+0x2a6>
	is_rx_enqueue = 0U;
 101cb62:	2600      	movs	r6, #0
		crc_expire = 0U;
 101cb64:	2200      	movs	r2, #0
 101cb66:	4b32      	ldr	r3, [pc, #200]	; (101cc30 <lll_conn_isr_rx+0x300>)
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 101cb68:	4620      	mov	r0, r4
		crc_expire = 0U;
 101cb6a:	701a      	strb	r2, [r3, #0]
		crc_valid = 1U;
 101cb6c:	2201      	movs	r2, #1
 101cb6e:	4b37      	ldr	r3, [pc, #220]	; (101cc4c <lll_conn_isr_rx+0x31c>)
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 101cb70:	a901      	add	r1, sp, #4
		crc_valid = 1U;
 101cb72:	701a      	strb	r2, [r3, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 101cb74:	f7ff fe7e 	bl	101c874 <lll_conn_pdu_tx_prep>
	is_done = is_done || ((crc_ok) && (pdu_data_rx->md == 0) &&
 101cb78:	f898 301c 	ldrb.w	r3, [r8, #28]
 101cb7c:	06da      	lsls	r2, r3, #27
 101cb7e:	d419      	bmi.n	101cbb4 <lll_conn_isr_rx+0x284>
			      (pdu_data_tx->md == 0) &&
 101cb80:	9f01      	ldr	r7, [sp, #4]
 101cb82:	783b      	ldrb	r3, [r7, #0]
	is_done = is_done || ((crc_ok) && (pdu_data_rx->md == 0) &&
 101cb84:	06db      	lsls	r3, r3, #27
 101cb86:	f53f af08 	bmi.w	101c99a <lll_conn_isr_rx+0x6a>
			      (pdu_data_tx->md == 0) &&
 101cb8a:	787b      	ldrb	r3, [r7, #1]
 101cb8c:	2b00      	cmp	r3, #0
 101cb8e:	f47f af04 	bne.w	101c99a <lll_conn_isr_rx+0x6a>
 101cb92:	e7a8      	b.n	101cae6 <lll_conn_isr_rx+0x1b6>
	pdu_data_tx->sn = lll->sn;
 101cb94:	2600      	movs	r6, #0
		LL_ASSERT(lll->handle != 0xFFFF);
 101cb96:	f240 13a1 	movw	r3, #417	; 0x1a1
 101cb9a:	4a27      	ldr	r2, [pc, #156]	; (101cc38 <lll_conn_isr_rx+0x308>)
 101cb9c:	492c      	ldr	r1, [pc, #176]	; (101cc50 <lll_conn_isr_rx+0x320>)
 101cb9e:	4828      	ldr	r0, [pc, #160]	; (101cc40 <lll_conn_isr_rx+0x310>)
 101cba0:	f008 f819 	bl	1024bd6 <assert_print>
 101cba4:	4040      	eors	r0, r0
 101cba6:	f380 8811 	msr	BASEPRI, r0
 101cbaa:	f04f 0003 	mov.w	r0, #3
 101cbae:	df02      	svc	2
		ull_conn_lll_ack_enqueue(lll->handle, tx_release);
 101cbb0:	89a0      	ldrh	r0, [r4, #12]
 101cbb2:	e724      	b.n	101c9fe <lll_conn_isr_rx+0xce>
			      (pdu_data_tx->md == 0) &&
 101cbb4:	9f01      	ldr	r7, [sp, #4]
 101cbb6:	e6f0      	b.n	101c99a <lll_conn_isr_rx+0x6a>
			lll->empty = 0;
 101cbb8:	f36f 0382 	bfc	r3, #2, #1
 101cbbc:	f884 3072 	strb.w	r3, [r4, #114]	; 0x72
			pdu_data_tx = (void *)radio_pkt_empty_get();
 101cbc0:	f000 fc42 	bl	101d448 <radio_pkt_empty_get>
	tx_release = NULL;
 101cbc4:	2500      	movs	r5, #0
 101cbc6:	f894 3072 	ldrb.w	r3, [r4, #114]	; 0x72
 101cbca:	f898 201c 	ldrb.w	r2, [r8, #28]
 101cbce:	e7c2      	b.n	101cb56 <lll_conn_isr_rx+0x226>
				lll->packet_tx_head_offset = offset;
 101cbd0:	f884 2071 	strb.w	r2, [r4, #113]	; 0x71
 101cbd4:	e7f6      	b.n	101cbc4 <lll_conn_isr_rx+0x294>
	    (ull_pdu_rx_alloc_peek(3) != 0)) {
 101cbd6:	2003      	movs	r0, #3
 101cbd8:	f7f7 fd0c 	bl	10145f4 <ull_pdu_rx_alloc_peek>
	if ((pdu_data_rx->sn == lll->nesn) &&
 101cbdc:	2800      	cmp	r0, #0
 101cbde:	d0c0      	beq.n	101cb62 <lll_conn_isr_rx+0x232>
		lll->nesn++;
 101cbe0:	f894 3072 	ldrb.w	r3, [r4, #114]	; 0x72
 101cbe4:	f083 0302 	eor.w	r3, r3, #2
 101cbe8:	f884 3072 	strb.w	r3, [r4, #114]	; 0x72
		if (pdu_data_rx->len != 0) {
 101cbec:	f898 301d 	ldrb.w	r3, [r8, #29]
 101cbf0:	2b00      	cmp	r3, #0
 101cbf2:	d0b6      	beq.n	101cb62 <lll_conn_isr_rx+0x232>
			if (lll->enc_rx) {
 101cbf4:	f894 3072 	ldrb.w	r3, [r4, #114]	; 0x72
 101cbf8:	0719      	lsls	r1, r3, #28
 101cbfa:	d42b      	bmi.n	101cc54 <lll_conn_isr_rx+0x324>
			*is_rx_enqueue = 1U;
 101cbfc:	2601      	movs	r6, #1
 101cbfe:	e7b1      	b.n	101cb64 <lll_conn_isr_rx+0x234>
				lll->packet_tx_head_len = 0;
 101cc00:	2200      	movs	r2, #0
				memq_dequeue(lll->memq_tx.tail,
 101cc02:	6e20      	ldr	r0, [r4, #96]	; 0x60
				lll->packet_tx_head_len = 0;
 101cc04:	f8a4 2070 	strh.w	r2, [r4, #112]	; 0x70
				memq_dequeue(lll->memq_tx.tail,
 101cc08:	f104 015c 	add.w	r1, r4, #92	; 0x5c
 101cc0c:	f7f4 f984 	bl	1010f18 <memq_dequeue>
				link->next = tx->next; /* Indicates ctrl or data
 101cc10:	9b01      	ldr	r3, [sp, #4]
 101cc12:	681b      	ldr	r3, [r3, #0]
 101cc14:	602b      	str	r3, [r5, #0]
				tx->next = link;
 101cc16:	9b01      	ldr	r3, [sp, #4]
 101cc18:	601d      	str	r5, [r3, #0]
				*tx_release = tx;
 101cc1a:	9d01      	ldr	r5, [sp, #4]
				FORCE_MD_CNT_SET();
 101cc1c:	f894 3072 	ldrb.w	r3, [r4, #114]	; 0x72
 101cc20:	f898 201c 	ldrb.w	r2, [r8, #28]
 101cc24:	e797      	b.n	101cb56 <lll_conn_isr_rx+0x226>
 101cc26:	bf00      	nop
 101cc28:	0101c549 	.word	0x0101c549
 101cc2c:	210081d8 	.word	0x210081d8
 101cc30:	21008354 	.word	0x21008354
 101cc34:	0101c765 	.word	0x0101c765
 101cc38:	0102b12c 	.word	0x0102b12c
 101cc3c:	0102a300 	.word	0x0102a300
 101cc40:	0102a278 	.word	0x0102a278
 101cc44:	0102b0e8 	.word	0x0102b0e8
 101cc48:	0102b0e0 	.word	0x0102b0e0
 101cc4c:	21008353 	.word	0x21008353
 101cc50:	0102b180 	.word	0x0102b180
				done = radio_ccm_is_done();
 101cc54:	f000 fe80 	bl	101d958 <radio_ccm_is_done>
				LL_ASSERT(done);
 101cc58:	2800      	cmp	r0, #0
 101cc5a:	d067      	beq.n	101cd2c <lll_conn_isr_rx+0x3fc>
				bool mic_failure = !radio_ccm_mic_is_valid();
 101cc5c:	f000 fe9e 	bl	101d99c <radio_ccm_mic_is_valid>
				if (mic_failure &&
 101cc60:	2800      	cmp	r0, #0
 101cc62:	d153      	bne.n	101cd0c <lll_conn_isr_rx+0x3dc>
				    lll->ccm_rx.counter == 0 &&
 101cc64:	f8d4 3083 	ldr.w	r3, [r4, #131]	; 0x83
 101cc68:	f8d4 2087 	ldr.w	r2, [r4, #135]	; 0x87
				if (mic_failure &&
 101cc6c:	4313      	orrs	r3, r2
 101cc6e:	d105      	bne.n	101cc7c <lll_conn_isr_rx+0x34c>
				    (pdu_data_rx->ll_id ==
 101cc70:	f898 301c 	ldrb.w	r3, [r8, #28]
				    lll->ccm_rx.counter == 0 &&
 101cc74:	f003 0303 	and.w	r3, r3, #3
 101cc78:	2b03      	cmp	r3, #3
 101cc7a:	d030      	beq.n	101ccde <lll_conn_isr_rx+0x3ae>
					mic_state = LLL_CONN_MIC_FAIL;
 101cc7c:	2202      	movs	r2, #2
 101cc7e:	4b32      	ldr	r3, [pc, #200]	; (101cd48 <lll_conn_isr_rx+0x418>)
			radio_isr_set(isr_done, param);
 101cc80:	4621      	mov	r1, r4
 101cc82:	4832      	ldr	r0, [pc, #200]	; (101cd4c <lll_conn_isr_rx+0x41c>)
					mic_state = LLL_CONN_MIC_FAIL;
 101cc84:	701a      	strb	r2, [r3, #0]
			radio_isr_set(isr_done, param);
 101cc86:	f000 fa4f 	bl	101d128 <radio_isr_set>
			radio_disable();
 101cc8a:	f000 fb79 	bl	101d380 <radio_disable>
			LL_ASSERT(!radio_is_ready());
 101cc8e:	f000 fba7 	bl	101d3e0 <radio_is_ready>
 101cc92:	b978      	cbnz	r0, 101ccb4 <lll_conn_isr_rx+0x384>
	if (!radio_tmr_aa_restore()) {
 101cc94:	f000 fdc0 	bl	101d818 <radio_tmr_aa_restore>
 101cc98:	b1d0      	cbz	r0, 101ccd0 <lll_conn_isr_rx+0x3a0>
	if (tx_release) {
 101cc9a:	2d00      	cmp	r5, #0
 101cc9c:	f43f af15 	beq.w	101caca <lll_conn_isr_rx+0x19a>
		LL_ASSERT(lll->handle != 0xFFFF);
 101cca0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 101cca4:	89a0      	ldrh	r0, [r4, #12]
 101cca6:	4298      	cmp	r0, r3
 101cca8:	f43f af74 	beq.w	101cb94 <lll_conn_isr_rx+0x264>
		ull_conn_lll_ack_enqueue(lll->handle, tx_release);
 101ccac:	4629      	mov	r1, r5
 101ccae:	f7f9 fdc9 	bl	1016844 <ull_conn_lll_ack_enqueue>
	if (is_rx_enqueue) {
 101ccb2:	e6a9      	b.n	101ca08 <lll_conn_isr_rx+0xd8>
			LL_ASSERT(!radio_is_ready());
 101ccb4:	f44f 7387 	mov.w	r3, #270	; 0x10e
 101ccb8:	4a25      	ldr	r2, [pc, #148]	; (101cd50 <lll_conn_isr_rx+0x420>)
 101ccba:	4926      	ldr	r1, [pc, #152]	; (101cd54 <lll_conn_isr_rx+0x424>)
 101ccbc:	4826      	ldr	r0, [pc, #152]	; (101cd58 <lll_conn_isr_rx+0x428>)
 101ccbe:	f007 ff8a 	bl	1024bd6 <assert_print>
 101ccc2:	4040      	eors	r0, r0
 101ccc4:	f380 8811 	msr	BASEPRI, r0
 101ccc8:	f04f 0003 	mov.w	r0, #3
 101cccc:	df02      	svc	2
 101ccce:	e7e1      	b.n	101cc94 <lll_conn_isr_rx+0x364>
		radio_tmr_aa_save(radio_tmr_aa_get());
 101ccd0:	f000 fd96 	bl	101d800 <radio_tmr_aa_get>
 101ccd4:	f000 fd9a 	bl	101d80c <radio_tmr_aa_save>
	if (tx_release) {
 101ccd8:	2d00      	cmp	r5, #0
 101ccda:	d1e1      	bne.n	101cca0 <lll_conn_isr_rx+0x370>
 101ccdc:	e6f5      	b.n	101caca <lll_conn_isr_rx+0x19a>
						radio_pkt_scratch_get();
 101ccde:	f000 fbb7 	bl	101d450 <radio_pkt_scratch_get>
					if (ctrl_pdu_len_check(
 101cce2:	7843      	ldrb	r3, [r0, #1]
						radio_pkt_scratch_get();
 101cce4:	4601      	mov	r1, r0
					if (ctrl_pdu_len_check(
 101cce6:	2b27      	cmp	r3, #39	; 0x27
 101cce8:	d8c8      	bhi.n	101cc7c <lll_conn_isr_rx+0x34c>
						memcpy(pdu_data_rx,
 101ccea:	3303      	adds	r3, #3
 101ccec:	b2da      	uxtb	r2, r3
 101ccee:	f108 001c 	add.w	r0, r8, #28
 101ccf2:	f009 fe3f 	bl	1026974 <memcpy>
						lll->ccm_rx.counter--;
 101ccf6:	f8d4 3083 	ldr.w	r3, [r4, #131]	; 0x83
 101ccfa:	f8d4 2087 	ldr.w	r2, [r4, #135]	; 0x87
 101ccfe:	3b01      	subs	r3, #1
 101cd00:	f8c4 3083 	str.w	r3, [r4, #131]	; 0x83
 101cd04:	f142 33ff 	adc.w	r3, r2, #4294967295
 101cd08:	f8c4 3087 	str.w	r3, [r4, #135]	; 0x87
				mic_state = LLL_CONN_MIC_PASS;
 101cd0c:	2101      	movs	r1, #1
				lll->ccm_rx.counter++;
 101cd0e:	f8d4 3083 	ldr.w	r3, [r4, #131]	; 0x83
				mic_state = LLL_CONN_MIC_PASS;
 101cd12:	4a0d      	ldr	r2, [pc, #52]	; (101cd48 <lll_conn_isr_rx+0x418>)
				lll->ccm_rx.counter++;
 101cd14:	3301      	adds	r3, #1
 101cd16:	f8c4 3083 	str.w	r3, [r4, #131]	; 0x83
 101cd1a:	f8d4 3087 	ldr.w	r3, [r4, #135]	; 0x87
						lll->ccm_rx.counter--;
 101cd1e:	f104 0083 	add.w	r0, r4, #131	; 0x83
				lll->ccm_rx.counter++;
 101cd22:	f143 0300 	adc.w	r3, r3, #0
				mic_state = LLL_CONN_MIC_PASS;
 101cd26:	7011      	strb	r1, [r2, #0]
				lll->ccm_rx.counter++;
 101cd28:	6043      	str	r3, [r0, #4]
		if (err) {
 101cd2a:	e767      	b.n	101cbfc <lll_conn_isr_rx+0x2cc>
				LL_ASSERT(done);
 101cd2c:	f240 33f7 	movw	r3, #1015	; 0x3f7
 101cd30:	4a07      	ldr	r2, [pc, #28]	; (101cd50 <lll_conn_isr_rx+0x420>)
 101cd32:	490a      	ldr	r1, [pc, #40]	; (101cd5c <lll_conn_isr_rx+0x42c>)
 101cd34:	4808      	ldr	r0, [pc, #32]	; (101cd58 <lll_conn_isr_rx+0x428>)
 101cd36:	f007 ff4e 	bl	1024bd6 <assert_print>
 101cd3a:	4040      	eors	r0, r0
 101cd3c:	f380 8811 	msr	BASEPRI, r0
 101cd40:	f04f 0003 	mov.w	r0, #3
 101cd44:	df02      	svc	2
 101cd46:	e789      	b.n	101cc5c <lll_conn_isr_rx+0x32c>
 101cd48:	21008352 	.word	0x21008352
 101cd4c:	0101c549 	.word	0x0101c549
 101cd50:	0102b12c 	.word	0x0102b12c
 101cd54:	0102b0e8 	.word	0x0102b0e8
 101cd58:	0102a278 	.word	0x0102a278
 101cd5c:	0102b178 	.word	0x0102b178

0101cd60 <prepare_cb>:

	lll = p->param;

	/* Check if stopped (on disconnection between prepare and pre-empt)
	 */
	if (unlikely(lll->handle == 0xFFFF)) {
 101cd60:	f64f 73ff 	movw	r3, #65535	; 0xffff
{
 101cd64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	lll = p->param;
 101cd68:	68c4      	ldr	r4, [r0, #12]
{
 101cd6a:	b082      	sub	sp, #8
	if (unlikely(lll->handle == 0xFFFF)) {
 101cd6c:	89a2      	ldrh	r2, [r4, #12]
 101cd6e:	429a      	cmp	r2, r3
 101cd70:	f000 80d2 	beq.w	101cf18 <prepare_cb+0x1b8>

		return 0;
	}

	/* Reset connection event global variables */
	lll_conn_prepare_reset();
 101cd74:	4605      	mov	r5, r0
 101cd76:	f7ff fc51 	bl	101c61c <lll_conn_prepare_reset>

	/* Calculate the current event latency */
	lll->latency_event = lll->latency_prepare + p->lazy;
 101cd7a:	892b      	ldrh	r3, [r5, #8]
 101cd7c:	8a62      	ldrh	r2, [r4, #18]

	/* Calculate the current event counter value */
	event_counter = lll->event_counter + lll->latency_event;
 101cd7e:	8ae0      	ldrh	r0, [r4, #22]
	lll->latency_event = lll->latency_prepare + p->lazy;
 101cd80:	441a      	add	r2, r3

	/* Update event counter to next value */
	lll->event_counter = (event_counter + 1);

	/* Reset accumulated latencies */
	lll->latency_prepare = 0;
 101cd82:	2300      	movs	r3, #0
	lll->latency_event = lll->latency_prepare + p->lazy;
 101cd84:	b292      	uxth	r2, r2
	event_counter = lll->event_counter + lll->latency_event;
 101cd86:	4410      	add	r0, r2

	if (lll->data_chan_sel) {
 101cd88:	7f61      	ldrb	r1, [r4, #29]
	event_counter = lll->event_counter + lll->latency_event;
 101cd8a:	b280      	uxth	r0, r0
	lll->event_counter = (event_counter + 1);
 101cd8c:	1c46      	adds	r6, r0, #1
 101cd8e:	82e6      	strh	r6, [r4, #22]
	if (lll->data_chan_sel) {
 101cd90:	064e      	lsls	r6, r1, #25
	lll->latency_prepare = 0;
 101cd92:	8263      	strh	r3, [r4, #18]
	lll->latency_event = lll->latency_prepare + p->lazy;
 101cd94:	82a2      	strh	r2, [r4, #20]
#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
		data_chan_use = lll_chan_sel_2(event_counter, lll->data_chan_id,
 101cd96:	f104 0318 	add.w	r3, r4, #24
	if (lll->data_chan_sel) {
 101cd9a:	f100 808f 	bmi.w	101cebc <prepare_cb+0x15c>
#else /* !CONFIG_BT_CTLR_CHAN_SEL_2 */
		data_chan_use = 0;
		LL_ASSERT(0);
#endif /* !CONFIG_BT_CTLR_CHAN_SEL_2 */
	} else {
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
 101cd9e:	f001 003f 	and.w	r0, r1, #63	; 0x3f
 101cda2:	7fa1      	ldrb	r1, [r4, #30]
 101cda4:	9000      	str	r0, [sp, #0]
 101cda6:	f104 001f 	add.w	r0, r4, #31
 101cdaa:	f7fe f89b 	bl	101aee4 <lll_chan_sel_1>
 101cdae:	4606      	mov	r6, r0
					       &lll->data_chan_map[0],
					       lll->data_chan_count);
	}

	/* current window widening */
	lll->periph.window_widening_event_us +=
 101cdb0:	e9d4 230b 	ldrd	r2, r3, [r4, #44]	; 0x2c
 101cdb4:	4413      	add	r3, r2
		lll->periph.window_widening_prepare_us;
	lll->periph.window_widening_prepare_us = 0;
 101cdb6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 101cdb8:	2100      	movs	r1, #0
 101cdba:	4293      	cmp	r3, r2
 101cdbc:	bf28      	it	cs
 101cdbe:	4613      	movcs	r3, r2
		lll->periph.window_widening_event_us =
			lll->periph.window_widening_max_us;
	}

	/* current window size */
	lll->periph.window_size_event_us +=
 101cdc0:	e9d4 020d 	ldrd	r0, r2, [r4, #52]	; 0x34
 101cdc4:	4402      	add	r2, r0
 101cdc6:	63a2      	str	r2, [r4, #56]	; 0x38
	/* Ensure that empty flag reflects the state of the Tx queue, as a
	 * peripheral if this is the first connection event and as no prior PDU
	 * is transmitted, an incorrect acknowledgment by peer should not
	 * dequeue a PDU that has not been transmitted on air.
	 */
	if (!lll->empty) {
 101cdc8:	f894 2072 	ldrb.w	r2, [r4, #114]	; 0x72
 101cdcc:	e9c4 310c 	strd	r3, r1, [r4, #48]	; 0x30
 101cdd0:	f012 0204 	ands.w	r2, r2, #4
	lll->periph.window_widening_prepare_us = 0;
 101cdd4:	62e1      	str	r1, [r4, #44]	; 0x2c
	if (!lll->empty) {
 101cdd6:	f000 8091 	beq.w	101cefc <prepare_cb+0x19c>
			lll->empty = 1U;
		}
	}

	/* Start setting up Radio h/w */
	radio_reset();
 101cdda:	f000 f9c7 	bl	101d16c <radio_reset>
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	radio_tx_power_set(lll->tx_pwr_lvl);
#else
	radio_tx_power_set(RADIO_TXP_DEFAULT);
 101cdde:	2000      	movs	r0, #0
 101cde0:	f000 fa10 	bl	101d204 <radio_tx_power_set>
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */

	radio_aa_set(lll->access_addr);
 101cde4:	1d20      	adds	r0, r4, #4
 101cde6:	f000 fa5d 	bl	101d2a4 <radio_aa_set>
	return ((uint32_t)src[2] << 16) | sys_get_le16(&src[0]);
 101cdea:	8923      	ldrh	r3, [r4, #8]
 101cdec:	7aa1      	ldrb	r1, [r4, #10]
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
 101cdee:	f240 605b 	movw	r0, #1627	; 0x65b
 101cdf2:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 101cdf6:	f000 fb11 	bl	101d41c <radio_crc_configure>
				sys_get_le24(lll->crc_init));

	lll_chan_set(data_chan_use);
 101cdfa:	4630      	mov	r0, r6
 101cdfc:	f7fe fcb8 	bl	101b770 <lll_chan_set>

	radio_isr_set(lll_conn_isr_rx, lll);
 101ce00:	4621      	mov	r1, r4
 101ce02:	484a      	ldr	r0, [pc, #296]	; (101cf2c <prepare_cb+0x1cc>)
 101ce04:	f000 f990 	bl	101d128 <radio_isr_set>

	radio_tmr_tifs_set(EVENT_IFS_US);
 101ce08:	2096      	movs	r0, #150	; 0x96
 101ce0a:	f000 fc1f 	bl	101d64c <radio_tmr_tifs_set>
	 * - CTE RX is not enabled,
	 * - SOC does not require compensation for PHYEND event delay.
	 */
	if (!IS_ENABLED(CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE)) {
#if defined(CONFIG_BT_CTLR_PHY)
		radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx, lll->phy_flags);
 101ce0e:	f894 205a 	ldrb.w	r2, [r4, #90]	; 0x5a
 101ce12:	f894 005b 	ldrb.w	r0, [r4, #91]	; 0x5b
 101ce16:	f3c2 03c0 	ubfx	r3, r2, #3, #1
 101ce1a:	2100      	movs	r1, #0
 101ce1c:	f002 0207 	and.w	r2, r2, #7
 101ce20:	f000 0007 	and.w	r0, r0, #7
 101ce24:	f000 fb5a 	bl	101d4dc <radio_switch_complete_and_tx>
	}

	/* The call can use Radio interface that alternates NRF_RADIO->SHORTS. The register is
	 * set by radio_switch_complete_XXX functions, hence any changes done before are cleared.
	 */
	lll_conn_rx_pkt_set(lll);
 101ce28:	4620      	mov	r0, r4
 101ce2a:	f7ff fc55 	bl	101c6d8 <lll_conn_rx_pkt_set>

	ticks_at_event = p->ticks_at_expire;
	ull = HDR_LLL2ULL(lll);
 101ce2e:	6826      	ldr	r6, [r4, #0]
	ticks_at_event = p->ticks_at_expire;
 101ce30:	682f      	ldr	r7, [r5, #0]
	ticks_at_event += lll_event_offset_get(ull);
 101ce32:	4630      	mov	r0, r6
 101ce34:	f7fe fc8e 	bl	101b754 <lll_event_offset_get>
 101ce38:	4603      	mov	r3, r0
 101ce3a:	441f      	add	r7, r3

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = p->remainder;
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
 101ce3c:	686a      	ldr	r2, [r5, #4]
 101ce3e:	f107 0109 	add.w	r1, r7, #9
 101ce42:	2000      	movs	r0, #0
 101ce44:	f000 fc0e 	bl	101d664 <radio_tmr_start>
 101ce48:	4680      	mov	r8, r0

	radio_tmr_aa_capture();
 101ce4a:	f000 fcbb 	bl	101d7c4 <radio_tmr_aa_capture>
	radio_tmr_aa_save(0);
 101ce4e:	2000      	movs	r0, #0
 101ce50:	f000 fcdc 	bl	101d80c <radio_tmr_aa_save>

	hcto = remainder_us +
	       ((EVENT_JITTER_US + EVENT_TICKER_RES_MARGIN_US +
 101ce54:	6b23      	ldr	r3, [r4, #48]	; 0x30
		 lll->periph.window_widening_event_us) << 1) +
	       lll->periph.window_size_event_us;

#if defined(CONFIG_BT_CTLR_PHY)
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
 101ce56:	f894 005b 	ldrb.w	r0, [r4, #91]	; 0x5b
	       ((EVENT_JITTER_US + EVENT_TICKER_RES_MARGIN_US +
 101ce5a:	f103 0230 	add.w	r2, r3, #48	; 0x30
	hcto = remainder_us +
 101ce5e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
 101ce60:	2101      	movs	r1, #1
 101ce62:	f000 0007 	and.w	r0, r0, #7
	hcto = remainder_us +
 101ce66:	eb03 0542 	add.w	r5, r3, r2, lsl #1
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
 101ce6a:	f000 fa67 	bl	101d33c <radio_rx_ready_delay_get>
	hcto += addr_us_get(lll->phy_rx);
 101ce6e:	f894 305b 	ldrb.w	r3, [r4, #91]	; 0x5b
	hcto = remainder_us +
 101ce72:	4445      	add	r5, r8
	hcto += addr_us_get(lll->phy_rx);
 101ce74:	f003 0307 	and.w	r3, r3, #7
 101ce78:	2b02      	cmp	r3, #2
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
 101ce7a:	4405      	add	r5, r0
 101ce7c:	d03c      	beq.n	101cef8 <prepare_cb+0x198>
		return 40;
 101ce7e:	2b04      	cmp	r3, #4
 101ce80:	bf0c      	ite	eq
 101ce82:	f44f 72bc 	moveq.w	r2, #376	; 0x178
 101ce86:	2228      	movne	r2, #40	; 0x28
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 101ce88:	2101      	movs	r1, #1
 101ce8a:	4618      	mov	r0, r3
	hcto += addr_us_get(lll->phy_rx);
 101ce8c:	4415      	add	r5, r2
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 101ce8e:	f000 fa57 	bl	101d340 <radio_rx_chain_delay_get>
	hcto += radio_rx_ready_delay_get(0, 0);
	hcto += addr_us_get(0);
	hcto += radio_rx_chain_delay_get(0, 0);
#endif /* !CONFIG_BT_CTLR_PHY */

	radio_tmr_hcto_configure(hcto);
 101ce92:	4428      	add	r0, r5
 101ce94:	f000 fc76 	bl	101d784 <radio_tmr_hcto_configure>
#endif /* CONFIG_BT_CTLR_CONN_RSSI */

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(ull, (TICKER_ID_CONN_BASE + lll->handle),
 101ce98:	89a1      	ldrh	r1, [r4, #12]
 101ce9a:	463a      	mov	r2, r7
 101ce9c:	3103      	adds	r1, #3
 101ce9e:	4630      	mov	r0, r6
 101cea0:	b2c9      	uxtb	r1, r1
 101cea2:	f7e4 fadd 	bl	1001460 <lll_preempt_calc>
 101cea6:	b188      	cbz	r0, 101cecc <prepare_cb+0x16c>
			     ticks_at_event)) {
		radio_isr_set(lll_isr_abort, lll);
 101cea8:	4621      	mov	r1, r4
 101ceaa:	4821      	ldr	r0, [pc, #132]	; (101cf30 <prepare_cb+0x1d0>)
 101ceac:	f000 f93c 	bl	101d128 <radio_isr_set>
		radio_disable();
 101ceb0:	f000 fa66 	bl	101d380 <radio_disable>
	}

	DEBUG_RADIO_START_S(1);

	return 0;
}
 101ceb4:	2000      	movs	r0, #0
 101ceb6:	b002      	add	sp, #8
 101ceb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		data_chan_use = lll_chan_sel_2(event_counter, lll->data_chan_id,
 101cebc:	461a      	mov	r2, r3
 101cebe:	f001 033f 	and.w	r3, r1, #63	; 0x3f
 101cec2:	8be1      	ldrh	r1, [r4, #30]
 101cec4:	f7fe f85a 	bl	101af7c <lll_chan_sel_2>
 101cec8:	4606      	mov	r6, r0
 101ceca:	e771      	b.n	101cdb0 <prepare_cb+0x50>
		ret = lll_prepare_done(lll);
 101cecc:	4620      	mov	r0, r4
 101cece:	f7fe fbe9 	bl	101b6a4 <lll_prepare_done>
		LL_ASSERT(!ret);
 101ced2:	2800      	cmp	r0, #0
 101ced4:	d0ee      	beq.n	101ceb4 <prepare_cb+0x154>
 101ced6:	f44f 73a7 	mov.w	r3, #334	; 0x14e
 101ceda:	4a16      	ldr	r2, [pc, #88]	; (101cf34 <prepare_cb+0x1d4>)
 101cedc:	4916      	ldr	r1, [pc, #88]	; (101cf38 <prepare_cb+0x1d8>)
 101cede:	4817      	ldr	r0, [pc, #92]	; (101cf3c <prepare_cb+0x1dc>)
 101cee0:	f007 fe79 	bl	1024bd6 <assert_print>
 101cee4:	4040      	eors	r0, r0
 101cee6:	f380 8811 	msr	BASEPRI, r0
 101ceea:	f04f 0003 	mov.w	r0, #3
 101ceee:	df02      	svc	2
}
 101cef0:	2000      	movs	r0, #0
 101cef2:	b002      	add	sp, #8
 101cef4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (phy) {
 101cef8:	2218      	movs	r2, #24
 101cefa:	e7c5      	b.n	101ce88 <prepare_cb+0x128>
		link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, NULL);
 101cefc:	e9d4 0117 	ldrd	r0, r1, [r4, #92]	; 0x5c
 101cf00:	f7f4 f802 	bl	1010f08 <memq_peek>
		if (!link) {
 101cf04:	2800      	cmp	r0, #0
 101cf06:	f47f af68 	bne.w	101cdda <prepare_cb+0x7a>
			lll->empty = 1U;
 101cf0a:	f894 3072 	ldrb.w	r3, [r4, #114]	; 0x72
 101cf0e:	f043 0304 	orr.w	r3, r3, #4
 101cf12:	f884 3072 	strb.w	r3, [r4, #114]	; 0x72
 101cf16:	e760      	b.n	101cdda <prepare_cb+0x7a>
		radio_isr_set(lll_isr_early_abort, lll);
 101cf18:	4621      	mov	r1, r4
 101cf1a:	4809      	ldr	r0, [pc, #36]	; (101cf40 <prepare_cb+0x1e0>)
 101cf1c:	f000 f904 	bl	101d128 <radio_isr_set>
		radio_disable();
 101cf20:	f000 fa2e 	bl	101d380 <radio_disable>
}
 101cf24:	2000      	movs	r0, #0
 101cf26:	b002      	add	sp, #8
 101cf28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 101cf2c:	0101c931 	.word	0x0101c931
 101cf30:	0101b8ad 	.word	0x0101b8ad
 101cf34:	0102b198 	.word	0x0102b198
 101cf38:	0102a694 	.word	0x0102a694
 101cf3c:	0102a278 	.word	0x0102a278
 101cf40:	0101b8cd 	.word	0x0101b8cd

0101cf44 <lll_periph_prepare>:
{
 101cf44:	b570      	push	{r4, r5, r6, lr}
 101cf46:	b082      	sub	sp, #8
 101cf48:	4605      	mov	r5, r0
	err = lll_hfclock_on();
 101cf4a:	f7fe fe0d 	bl	101bb68 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
 101cf4e:	2800      	cmp	r0, #0
 101cf50:	db25      	blt.n	101cf9e <lll_periph_prepare+0x5a>
	lll = p->param;
 101cf52:	68ee      	ldr	r6, [r5, #12]
	    lll->periph.window_widening_periodic_us * (p->lazy + 1);
 101cf54:	8929      	ldrh	r1, [r5, #8]
 101cf56:	6a73      	ldr	r3, [r6, #36]	; 0x24
	lll->periph.window_widening_prepare_us +=
 101cf58:	6af2      	ldr	r2, [r6, #44]	; 0x2c
	    lll->periph.window_widening_periodic_us * (p->lazy + 1);
 101cf5a:	fb01 3303 	mla	r3, r1, r3, r3
	lll->periph.window_widening_prepare_us +=
 101cf5e:	189c      	adds	r4, r3, r2
 101cf60:	6ab2      	ldr	r2, [r6, #40]	; 0x28
	err = lll_prepare(lll_is_abort_cb, lll_conn_abort_cb, prepare_cb, 0, p);
 101cf62:	2300      	movs	r3, #0
 101cf64:	4294      	cmp	r4, r2
 101cf66:	bf28      	it	cs
 101cf68:	4614      	movcs	r4, r2
 101cf6a:	4913      	ldr	r1, [pc, #76]	; (101cfb8 <lll_periph_prepare+0x74>)
 101cf6c:	62f4      	str	r4, [r6, #44]	; 0x2c
 101cf6e:	4a13      	ldr	r2, [pc, #76]	; (101cfbc <lll_periph_prepare+0x78>)
 101cf70:	4813      	ldr	r0, [pc, #76]	; (101cfc0 <lll_periph_prepare+0x7c>)
 101cf72:	9500      	str	r5, [sp, #0]
 101cf74:	f7f7 fe8c 	bl	1014c90 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
 101cf78:	b108      	cbz	r0, 101cf7e <lll_periph_prepare+0x3a>
 101cf7a:	3077      	adds	r0, #119	; 0x77
 101cf7c:	d101      	bne.n	101cf82 <lll_periph_prepare+0x3e>
}
 101cf7e:	b002      	add	sp, #8
 101cf80:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
 101cf82:	235b      	movs	r3, #91	; 0x5b
 101cf84:	4a0f      	ldr	r2, [pc, #60]	; (101cfc4 <lll_periph_prepare+0x80>)
 101cf86:	4910      	ldr	r1, [pc, #64]	; (101cfc8 <lll_periph_prepare+0x84>)
 101cf88:	4810      	ldr	r0, [pc, #64]	; (101cfcc <lll_periph_prepare+0x88>)
 101cf8a:	f007 fe24 	bl	1024bd6 <assert_print>
 101cf8e:	4040      	eors	r0, r0
 101cf90:	f380 8811 	msr	BASEPRI, r0
 101cf94:	f04f 0003 	mov.w	r0, #3
 101cf98:	df02      	svc	2
}
 101cf9a:	b002      	add	sp, #8
 101cf9c:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(err >= 0);
 101cf9e:	234a      	movs	r3, #74	; 0x4a
 101cfa0:	4a08      	ldr	r2, [pc, #32]	; (101cfc4 <lll_periph_prepare+0x80>)
 101cfa2:	490b      	ldr	r1, [pc, #44]	; (101cfd0 <lll_periph_prepare+0x8c>)
 101cfa4:	4809      	ldr	r0, [pc, #36]	; (101cfcc <lll_periph_prepare+0x88>)
 101cfa6:	f007 fe16 	bl	1024bd6 <assert_print>
 101cfaa:	4040      	eors	r0, r0
 101cfac:	f380 8811 	msr	BASEPRI, r0
 101cfb0:	f04f 0003 	mov.w	r0, #3
 101cfb4:	df02      	svc	2
 101cfb6:	e7cc      	b.n	101cf52 <lll_periph_prepare+0xe>
 101cfb8:	0101c645 	.word	0x0101c645
 101cfbc:	0101cd61 	.word	0x0101cd61
 101cfc0:	0101b74d 	.word	0x0101b74d
 101cfc4:	0102b198 	.word	0x0102b198
 101cfc8:	0102b118 	.word	0x0102b118
 101cfcc:	0102a278 	.word	0x0102a278
 101cfd0:	0102b004 	.word	0x0102b004

0101cfd4 <cntr_init>:
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
 101cfd4:	f44f 3280 	mov.w	r2, #65536	; 0x10000

static uint8_t _refcount;

void cntr_init(void)
{
	NRF_RTC->PRESCALER = 0;
 101cfd8:	2100      	movs	r1, #0
 101cfda:	4b04      	ldr	r3, [pc, #16]	; (101cfec <cntr_init+0x18>)
 101cfdc:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
 101cfe0:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
    p_reg->INTENSET = mask;
 101cfe4:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_rtc_event_enable(NRF_RTC, RTC_EVTENSET_COMPARE0_Msk);
	nrf_rtc_int_enable(NRF_RTC, RTC_INTENSET_COMPARE0_Msk);
}
 101cfe8:	4770      	bx	lr
 101cfea:	bf00      	nop
 101cfec:	41011000 	.word	0x41011000

0101cff0 <cntr_start>:

uint32_t cntr_start(void)
{
	if (_refcount++) {
 101cff0:	4b05      	ldr	r3, [pc, #20]	; (101d008 <cntr_start+0x18>)
 101cff2:	7818      	ldrb	r0, [r3, #0]
 101cff4:	1c42      	adds	r2, r0, #1
 101cff6:	701a      	strb	r2, [r3, #0]
 101cff8:	b918      	cbnz	r0, 101d002 <cntr_start+0x12>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
 101cffa:	2201      	movs	r2, #1
 101cffc:	4b03      	ldr	r3, [pc, #12]	; (101d00c <cntr_start+0x1c>)
 101cffe:	601a      	str	r2, [r3, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_START);

	return 0;
 101d000:	4770      	bx	lr
		return 1;
 101d002:	2001      	movs	r0, #1
}
 101d004:	4770      	bx	lr
 101d006:	bf00      	nop
 101d008:	21008355 	.word	0x21008355
 101d00c:	41011000 	.word	0x41011000

0101d010 <cntr_stop>:

uint32_t cntr_stop(void)
{
 101d010:	b510      	push	{r4, lr}
	LL_ASSERT(_refcount);
 101d012:	4c0d      	ldr	r4, [pc, #52]	; (101d048 <cntr_stop+0x38>)
 101d014:	7820      	ldrb	r0, [r4, #0]
 101d016:	b148      	cbz	r0, 101d02c <cntr_stop+0x1c>

	if (--_refcount) {
 101d018:	3801      	subs	r0, #1
 101d01a:	b2c0      	uxtb	r0, r0
 101d01c:	7020      	strb	r0, [r4, #0]
 101d01e:	b918      	cbnz	r0, 101d028 <cntr_stop+0x18>
 101d020:	2201      	movs	r2, #1
 101d022:	4b0a      	ldr	r3, [pc, #40]	; (101d04c <cntr_stop+0x3c>)
 101d024:	605a      	str	r2, [r3, #4]
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_STOP);

	return 0;
}
 101d026:	bd10      	pop	{r4, pc}
		return 1;
 101d028:	2001      	movs	r0, #1
}
 101d02a:	bd10      	pop	{r4, pc}
	LL_ASSERT(_refcount);
 101d02c:	232a      	movs	r3, #42	; 0x2a
 101d02e:	4a08      	ldr	r2, [pc, #32]	; (101d050 <cntr_stop+0x40>)
 101d030:	4908      	ldr	r1, [pc, #32]	; (101d054 <cntr_stop+0x44>)
 101d032:	4809      	ldr	r0, [pc, #36]	; (101d058 <cntr_stop+0x48>)
 101d034:	f007 fdcf 	bl	1024bd6 <assert_print>
 101d038:	4040      	eors	r0, r0
 101d03a:	f380 8811 	msr	BASEPRI, r0
 101d03e:	f04f 0003 	mov.w	r0, #3
 101d042:	df02      	svc	2
	if (--_refcount) {
 101d044:	7820      	ldrb	r0, [r4, #0]
 101d046:	e7e7      	b.n	101d018 <cntr_stop+0x8>
 101d048:	21008355 	.word	0x21008355
 101d04c:	41011000 	.word	0x41011000
 101d050:	0102b1ec 	.word	0x0102b1ec
 101d054:	0102b238 	.word	0x0102b238
 101d058:	0102a278 	.word	0x0102a278

0101d05c <cntr_cnt_get>:
     return p_reg->COUNTER;
 101d05c:	4b01      	ldr	r3, [pc, #4]	; (101d064 <cntr_cnt_get+0x8>)
 101d05e:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

uint32_t cntr_cnt_get(void)
{
	return nrf_rtc_counter_get(NRF_RTC);
}
 101d062:	4770      	bx	lr
 101d064:	41011000 	.word	0x41011000

0101d068 <cntr_cmp_set>:
    p_reg->CC[ch] = cc_val;
 101d068:	4b02      	ldr	r3, [pc, #8]	; (101d074 <cntr_cmp_set+0xc>)
 101d06a:	f500 70a8 	add.w	r0, r0, #336	; 0x150
 101d06e:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

void cntr_cmp_set(uint8_t cmp, uint32_t value)
{
	nrf_rtc_cc_set(NRF_RTC, cmp, value);
}
 101d072:	4770      	bx	lr
 101d074:	41011000 	.word	0x41011000

0101d078 <do_ecb>:
	uint8_t clear_text[16];
	uint8_t cipher_text[16];
} __packed;

static void do_ecb(struct ecb_param *ecb)
{
 101d078:	b430      	push	{r4, r5}

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ecb_task_trigger(NRF_ECB_Type * p_reg, nrf_ecb_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101d07a:	2101      	movs	r1, #1
	do {
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
		NRF_ECB->ECBDATAPTR = (uint32_t)ecb;
		NRF_ECB->EVENTS_ENDECB = 0;
 101d07c:	2400      	movs	r4, #0
 101d07e:	4b10      	ldr	r3, [pc, #64]	; (101d0c0 <do_ecb+0x48>)
 101d080:	6059      	str	r1, [r3, #4]
		NRF_ECB->ECBDATAPTR = (uint32_t)ecb;
 101d082:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
		NRF_ECB->EVENTS_ENDECB = 0;
 101d086:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
		NRF_ECB->EVENTS_ERRORECB = 0;
 101d08a:	f8c3 4104 	str.w	r4, [r3, #260]	; 0x104
 101d08e:	6019      	str	r1, [r3, #0]
}
 101d090:	e005      	b.n	101d09e <do_ecb+0x26>
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STARTECB);
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
 101d092:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
 101d096:	b932      	cbnz	r2, 101d0a6 <do_ecb+0x2e>
		       (NRF_ECB->ECBDATAPTR != 0)) {
 101d098:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
 101d09c:	b11a      	cbz	r2, 101d0a6 <do_ecb+0x2e>
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
 101d09e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
 101d0a2:	2a00      	cmp	r2, #0
 101d0a4:	d0f5      	beq.n	101d092 <do_ecb+0x1a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101d0a6:	6059      	str	r1, [r3, #4]
#else
			/*__WFE();*/
#endif
		}
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
	} while ((NRF_ECB->EVENTS_ERRORECB != 0) || (NRF_ECB->ECBDATAPTR == 0));
 101d0a8:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 101d0ac:	2a00      	cmp	r2, #0
 101d0ae:	d1e7      	bne.n	101d080 <do_ecb+0x8>
 101d0b0:	f8d3 5504 	ldr.w	r5, [r3, #1284]	; 0x504
 101d0b4:	2d00      	cmp	r5, #0
 101d0b6:	d0e3      	beq.n	101d080 <do_ecb+0x8>

	NRF_ECB->ECBDATAPTR = 0;
 101d0b8:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
 101d0bc:	bc30      	pop	{r4, r5}
 101d0be:	4770      	bx	lr
 101d0c0:	4100d000 	.word	0x4100d000

0101d0c4 <ecb_encrypt>:
	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
}

void ecb_encrypt(uint8_t const *const key_le, uint8_t const *const clear_text_le,
		 uint8_t * const cipher_text_le, uint8_t * const cipher_text_be)
{
 101d0c4:	b570      	push	{r4, r5, r6, lr}
 101d0c6:	b08c      	sub	sp, #48	; 0x30
 101d0c8:	460e      	mov	r6, r1
 101d0ca:	4615      	mov	r5, r2
 101d0cc:	4601      	mov	r1, r0
	struct ecb_param ecb;

	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
 101d0ce:	2210      	movs	r2, #16
 101d0d0:	4668      	mov	r0, sp
{
 101d0d2:	461c      	mov	r4, r3
	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
 101d0d4:	f7f3 fee6 	bl	1010ea4 <mem_rcopy>
	mem_rcopy(&ecb.clear_text[0], clear_text_le, sizeof(ecb.clear_text));
 101d0d8:	2210      	movs	r2, #16
 101d0da:	4631      	mov	r1, r6
 101d0dc:	eb0d 0002 	add.w	r0, sp, r2
 101d0e0:	f7f3 fee0 	bl	1010ea4 <mem_rcopy>

	do_ecb(&ecb);
 101d0e4:	4668      	mov	r0, sp
 101d0e6:	f7ff ffc7 	bl	101d078 <do_ecb>

	if (cipher_text_le) {
 101d0ea:	b125      	cbz	r5, 101d0f6 <ecb_encrypt+0x32>
		mem_rcopy(cipher_text_le, &ecb.cipher_text[0],
 101d0ec:	2210      	movs	r2, #16
 101d0ee:	4628      	mov	r0, r5
 101d0f0:	a908      	add	r1, sp, #32
 101d0f2:	f7f3 fed7 	bl	1010ea4 <mem_rcopy>
			  sizeof(ecb.cipher_text));
	}

	if (cipher_text_be) {
 101d0f6:	b124      	cbz	r4, 101d102 <ecb_encrypt+0x3e>
		memcpy(cipher_text_be, &ecb.cipher_text[0],
 101d0f8:	2210      	movs	r2, #16
 101d0fa:	4620      	mov	r0, r4
 101d0fc:	a908      	add	r1, sp, #32
 101d0fe:	f009 fc39 	bl	1026974 <memcpy>
			 sizeof(ecb.cipher_text));
	}
}
 101d102:	b00c      	add	sp, #48	; 0x30
 101d104:	bd70      	pop	{r4, r5, r6, pc}
 101d106:	bf00      	nop

0101d108 <isr_radio>:
}
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

uint32_t radio_has_disabled(void)
{
	return (NRF_RADIO->EVENTS_DISABLED != 0);
 101d108:	4b04      	ldr	r3, [pc, #16]	; (101d11c <isr_radio+0x14>)
 101d10a:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
	if (radio_has_disabled()) {
 101d10e:	b123      	cbz	r3, 101d11a <isr_radio+0x12>
		isr_cb(isr_cb_param);
 101d110:	4a03      	ldr	r2, [pc, #12]	; (101d120 <isr_radio+0x18>)
 101d112:	4b04      	ldr	r3, [pc, #16]	; (101d124 <isr_radio+0x1c>)
 101d114:	6810      	ldr	r0, [r2, #0]
 101d116:	681b      	ldr	r3, [r3, #0]
 101d118:	4718      	bx	r3
}
 101d11a:	4770      	bx	lr
 101d11c:	41008000 	.word	0x41008000
 101d120:	21007ea8 	.word	0x21007ea8
 101d124:	21007eac 	.word	0x21007eac

0101d128 <radio_isr_set>:
{
 101d128:	b538      	push	{r3, r4, r5, lr}
 101d12a:	4605      	mov	r5, r0
	irq_disable(RADIO_IRQn);
 101d12c:	2008      	movs	r0, #8
{
 101d12e:	460c      	mov	r4, r1
	irq_disable(RADIO_IRQn);
 101d130:	f7e8 fe68 	bl	1005e04 <arch_irq_disable>
    return p_reg->SHORTS;
}

NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
 101d134:	2110      	movs	r1, #16
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 101d136:	f44f 7280 	mov.w	r2, #256	; 0x100
	isr_cb = cb;
 101d13a:	4b07      	ldr	r3, [pc, #28]	; (101d158 <radio_isr_set+0x30>)
	isr_cb_param = param;
 101d13c:	4807      	ldr	r0, [pc, #28]	; (101d15c <radio_isr_set+0x34>)
	isr_cb = cb;
 101d13e:	601d      	str	r5, [r3, #0]
 101d140:	4b07      	ldr	r3, [pc, #28]	; (101d160 <radio_isr_set+0x38>)
	isr_cb_param = param;
 101d142:	6004      	str	r4, [r0, #0]
 101d144:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
 101d148:	4b06      	ldr	r3, [pc, #24]	; (101d164 <radio_isr_set+0x3c>)
	irq_enable(RADIO_IRQn);
 101d14a:	2008      	movs	r0, #8
 101d14c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
 101d150:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	irq_enable(RADIO_IRQn);
 101d154:	f7e8 be48 	b.w	1005de8 <arch_irq_enable>
 101d158:	21007eac 	.word	0x21007eac
 101d15c:	21007ea8 	.word	0x21007ea8
 101d160:	41008000 	.word	0x41008000
 101d164:	e000e100 	.word	0xe000e100

0101d168 <radio_setup>:
}
 101d168:	4770      	bx	lr
 101d16a:	bf00      	nop

0101d16c <radio_reset>:
{
 101d16c:	b538      	push	{r3, r4, r5, lr}
	irq_disable(RADIO_IRQn);
 101d16e:	2008      	movs	r0, #8
 101d170:	f7e8 fe48 	bl	1005e04 <arch_irq_disable>

	NRF_DPPIC->TASKS_CHG[SW_SWITCH_TIMER_TASK_GROUP(0)].DIS = 1;
	NRF_DPPIC->TASKS_CHG[SW_SWITCH_TIMER_TASK_GROUP(1)].DIS = 1;

	/* Include the appropriate PPI channels in the two PPI Groups. */
	NRF_DPPIC->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
 101d174:	f44f 4580 	mov.w	r5, #16384	; 0x4000
	NRF_RADIO->PCNF1 = HAL_RADIO_RESET_VALUE_PCNF1;
 101d178:	2200      	movs	r2, #0
	NRF_DPPIC->TASKS_CHG[SW_SWITCH_TIMER_TASK_GROUP(0)].DIS = 1;
 101d17a:	2001      	movs	r0, #1
		BIT(HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI(0)) |
		BIT(HAL_SW_SWITCH_RADIO_ENABLE_PPI(0));
	NRF_DPPIC->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
 101d17c:	f44f 4400 	mov.w	r4, #32768	; 0x8000
	NRF_DPPIC->SUBSCRIBE_CHG[SW_SWITCH_TIMER_TASK_GROUP(0)].EN = 0;
 101d180:	4b0b      	ldr	r3, [pc, #44]	; (101d1b0 <radio_reset+0x44>)
 101d182:	490c      	ldr	r1, [pc, #48]	; (101d1b4 <radio_reset+0x48>)
 101d184:	f8c1 2518 	str.w	r2, [r1, #1304]	; 0x518
 101d188:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	NRF_DPPIC->SUBSCRIBE_CHG[SW_SWITCH_TIMER_TASK_GROUP(0)].DIS = 0;
 101d18c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	NRF_DPPIC->SUBSCRIBE_CHG[SW_SWITCH_TIMER_TASK_GROUP(1)].EN = 0;
 101d190:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	NRF_DPPIC->SUBSCRIBE_CHG[SW_SWITCH_TIMER_TASK_GROUP(1)].DIS = 0;
 101d194:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	NRF_DPPIC->TASKS_CHG[SW_SWITCH_TIMER_TASK_GROUP(0)].DIS = 1;
 101d198:	6058      	str	r0, [r3, #4]
	NRF_DPPIC->TASKS_CHG[SW_SWITCH_TIMER_TASK_GROUP(1)].DIS = 1;
 101d19a:	60d8      	str	r0, [r3, #12]
	NRF_DPPIC->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
 101d19c:	f8c3 5800 	str.w	r5, [r3, #2048]	; 0x800
	NRF_DPPIC->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
 101d1a0:	f8c3 4804 	str.w	r4, [r3, #2052]	; 0x804
}

NRF_STATIC_INLINE void nrf_radio_subscribe_clear(NRF_RADIO_Type * p_reg,
                                                 nrf_radio_task_t task)
{
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
 101d1a4:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
 101d1a8:	f8c1 2084 	str.w	r2, [r1, #132]	; 0x84
}
 101d1ac:	bd38      	pop	{r3, r4, r5, pc}
 101d1ae:	bf00      	nop
 101d1b0:	4100f000 	.word	0x4100f000
 101d1b4:	41008000 	.word	0x41008000

0101d1b8 <radio_stop>:

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_vreqctrl_radio_high_voltage_set(NRF_VREQCTRL_Type * p_reg, bool enable)
{
    p_reg->VREGRADIO.VREQH =
 101d1b8:	2200      	movs	r2, #0
 101d1ba:	4b02      	ldr	r3, [pc, #8]	; (101d1c4 <radio_stop+0xc>)
 101d1bc:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
 101d1c0:	4770      	bx	lr
 101d1c2:	bf00      	nop
 101d1c4:	41004000 	.word	0x41004000

0101d1c8 <radio_phy_set>:

static inline uint32_t hal_radio_phy_mode_get(uint8_t phy, uint8_t flags)
{
	uint32_t mode;

	switch (phy) {
 101d1c8:	2802      	cmp	r0, #2
 101d1ca:	d00e      	beq.n	101d1ea <radio_phy_set+0x22>
	case BIT(0):
	default:
		mode = RADIO_MODE_MODE_Ble_1Mbit;
 101d1cc:	2103      	movs	r1, #3

		/* Workaround: nRF5340 Revision 1 Errata 117 */
		*((volatile uint32_t *)0x41008588) =
			*((volatile uint32_t *)0x01FF0080); /* non-2M mode */
 101d1ce:	4a0b      	ldr	r2, [pc, #44]	; (101d1fc <radio_phy_set+0x34>)
		*((volatile uint32_t *)0x41008588) =
 101d1d0:	4b0b      	ldr	r3, [pc, #44]	; (101d200 <radio_phy_set+0x38>)
			*((volatile uint32_t *)0x01FF0080); /* non-2M mode */
 101d1d2:	f8d2 2080 	ldr.w	r2, [r2, #128]	; 0x80
		*((volatile uint32_t *)0x41008588) =
 101d1d6:	f8c3 2588 	str.w	r2, [r3, #1416]	; 0x588
	NRF_RADIO->MODECNF0 = ((RADIO_MODECNF0_DTX_Center <<
 101d1da:	f240 2201 	movw	r2, #513	; 0x201
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
 101d1de:	4b08      	ldr	r3, [pc, #32]	; (101d200 <radio_phy_set+0x38>)
 101d1e0:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
	NRF_RADIO->MODECNF0 = ((RADIO_MODECNF0_DTX_Center <<
 101d1e4:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
}
 101d1e8:	4770      	bx	lr
	case BIT(1):
		mode = RADIO_MODE_MODE_Ble_2Mbit;

		/* Workaround: nRF5340 Revision 1 Errata 117 */
		*((volatile uint32_t *)0x41008588) =
			*((volatile uint32_t *)0x01FF0084); /* 2M mode */
 101d1ea:	4a04      	ldr	r2, [pc, #16]	; (101d1fc <radio_phy_set+0x34>)
		*((volatile uint32_t *)0x41008588) =
 101d1ec:	4b04      	ldr	r3, [pc, #16]	; (101d200 <radio_phy_set+0x38>)
			*((volatile uint32_t *)0x01FF0084); /* 2M mode */
 101d1ee:	f8d2 2084 	ldr.w	r2, [r2, #132]	; 0x84
		mode = RADIO_MODE_MODE_Ble_2Mbit;
 101d1f2:	2104      	movs	r1, #4
		*((volatile uint32_t *)0x41008588) =
 101d1f4:	f8c3 2588 	str.w	r2, [r3, #1416]	; 0x588
		break;
 101d1f8:	e7ef      	b.n	101d1da <radio_phy_set+0x12>
 101d1fa:	bf00      	nop
 101d1fc:	01ff0000 	.word	0x01ff0000
 101d200:	41008000 	.word	0x41008000

0101d204 <radio_tx_power_set>:
	return RADIO_TXPOWER_TXPOWER_Neg40dBm;
}

static inline uint32_t hal_radio_tx_power_floor(int8_t tx_power_lvl)
{
	if (tx_power_lvl >= (int8_t)RADIO_TXPOWER_TXPOWER_0dBm) {
 101d204:	2800      	cmp	r0, #0
 101d206:	da17      	bge.n	101d238 <radio_tx_power_set+0x34>
		return RADIO_TXPOWER_TXPOWER_0dBm;
	}

	if (tx_power_lvl >= (int8_t)RADIO_TXPOWER_TXPOWER_Neg1dBm) {
 101d208:	f100 0308 	add.w	r3, r0, #8
 101d20c:	b2db      	uxtb	r3, r3
 101d20e:	2b07      	cmp	r3, #7
 101d210:	d90c      	bls.n	101d22c <radio_tx_power_set+0x28>

	if (tx_power_lvl >= (int8_t)RADIO_TXPOWER_TXPOWER_Neg8dBm) {
		return RADIO_TXPOWER_TXPOWER_Neg8dBm;
	}

	if (tx_power_lvl >= (int8_t)RADIO_TXPOWER_TXPOWER_Neg12dBm) {
 101d212:	f110 0f0c 	cmn.w	r0, #12
 101d216:	da1b      	bge.n	101d250 <radio_tx_power_set+0x4c>
		return RADIO_TXPOWER_TXPOWER_Neg12dBm;
	}

	if (tx_power_lvl >= (int8_t)RADIO_TXPOWER_TXPOWER_Neg16dBm) {
 101d218:	f110 0f10 	cmn.w	r0, #16
 101d21c:	da22      	bge.n	101d264 <radio_tx_power_set+0x60>
		return RADIO_TXPOWER_TXPOWER_Neg16dBm;
	}

	if (tx_power_lvl >= (int8_t)RADIO_TXPOWER_TXPOWER_Neg20dBm) {
 101d21e:	3014      	adds	r0, #20
 101d220:	da1b      	bge.n	101d25a <radio_tx_power_set+0x56>
	NRF_RADIO->TXPOWER = value;
 101d222:	22d8      	movs	r2, #216	; 0xd8
 101d224:	4b12      	ldr	r3, [pc, #72]	; (101d270 <radio_tx_power_set+0x6c>)
 101d226:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
	return RADIO_TXPOWER_TXPOWER_Neg40dBm;
}

static inline void hal_radio_tx_power_high_voltage_set(int8_t tx_power_lvl)
{
	if (tx_power_lvl >= (int8_t)RADIO_TXPOWER_TXPOWER_Pos3dBm) {
 101d22a:	4770      	bx	lr
 101d22c:	4b10      	ldr	r3, [pc, #64]	; (101d270 <radio_tx_power_set+0x6c>)
 101d22e:	f500 7080 	add.w	r0, r0, #256	; 0x100
 101d232:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
 101d236:	4770      	bx	lr
 101d238:	2200      	movs	r2, #0
 101d23a:	4b0d      	ldr	r3, [pc, #52]	; (101d270 <radio_tx_power_set+0x6c>)
 101d23c:	2802      	cmp	r0, #2
 101d23e:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
 101d242:	dd04      	ble.n	101d24e <radio_tx_power_set+0x4a>
 101d244:	2201      	movs	r2, #1
 101d246:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 101d24a:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
 101d24e:	4770      	bx	lr
	NRF_RADIO->TXPOWER = value;
 101d250:	22f4      	movs	r2, #244	; 0xf4
 101d252:	4b07      	ldr	r3, [pc, #28]	; (101d270 <radio_tx_power_set+0x6c>)
 101d254:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
 101d258:	4770      	bx	lr
 101d25a:	22ec      	movs	r2, #236	; 0xec
 101d25c:	4b04      	ldr	r3, [pc, #16]	; (101d270 <radio_tx_power_set+0x6c>)
 101d25e:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
 101d262:	4770      	bx	lr
 101d264:	22f0      	movs	r2, #240	; 0xf0
 101d266:	4b02      	ldr	r3, [pc, #8]	; (101d270 <radio_tx_power_set+0x6c>)
 101d268:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
 101d26c:	4770      	bx	lr
 101d26e:	bf00      	nop
 101d270:	41008000 	.word	0x41008000

0101d274 <radio_freq_chan_set>:
	NRF_RADIO->FREQUENCY = chan;
 101d274:	4b01      	ldr	r3, [pc, #4]	; (101d27c <radio_freq_chan_set+0x8>)
 101d276:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
}
 101d27a:	4770      	bx	lr
 101d27c:	41008000 	.word	0x41008000

0101d280 <radio_whiten_iv_set>:
	NRF_RADIO->DATAWHITEIV = iv;
 101d280:	4b07      	ldr	r3, [pc, #28]	; (101d2a0 <radio_whiten_iv_set+0x20>)
 101d282:	f8c3 0554 	str.w	r0, [r3, #1364]	; 0x554
	NRF_RADIO->PCNF1 &= ~RADIO_PCNF1_WHITEEN_Msk;
 101d286:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
 101d28a:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 101d28e:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((1UL) << RADIO_PCNF1_WHITEEN_Pos) &
 101d292:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
 101d296:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 101d29a:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
 101d29e:	4770      	bx	lr
 101d2a0:	41008000 	.word	0x41008000

0101d2a4 <radio_aa_set>:
	NRF_RADIO->TXADDRESS =
 101d2a4:	2100      	movs	r1, #0
	NRF_RADIO->RXADDRESSES =
 101d2a6:	2301      	movs	r3, #1
	NRF_RADIO->TXADDRESS =
 101d2a8:	4a09      	ldr	r2, [pc, #36]	; (101d2d0 <radio_aa_set+0x2c>)
 101d2aa:	f8c2 152c 	str.w	r1, [r2, #1324]	; 0x52c
	NRF_RADIO->RXADDRESSES =
 101d2ae:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
	NRF_RADIO->PREFIX0 = aa[3];
 101d2b2:	78c3      	ldrb	r3, [r0, #3]
 101d2b4:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
 101d2b8:	7843      	ldrb	r3, [r0, #1]
 101d2ba:	f890 c002 	ldrb.w	ip, [r0, #2]
 101d2be:	7801      	ldrb	r1, [r0, #0]
 101d2c0:	041b      	lsls	r3, r3, #16
 101d2c2:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
 101d2c6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 101d2ca:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
}
 101d2ce:	4770      	bx	lr
 101d2d0:	41008000 	.word	0x41008000

0101d2d4 <radio_pkt_configure>:
	switch (phy) {
 101d2d4:	f3c2 0342 	ubfx	r3, r2, #1, #3
 101d2d8:	f1a3 0302 	sub.w	r3, r3, #2
 101d2dc:	fab3 f383 	clz	r3, r3
 101d2e0:	095b      	lsrs	r3, r3, #5
 101d2e2:	061b      	lsls	r3, r3, #24
	if (pdu_type == RADIO_PKT_CONF_PDU_TYPE_DC) {
 101d2e4:	07d2      	lsls	r2, r2, #31
		extra |= (RADIO_PCNF0_S1INCL_Include <<
 101d2e6:	bf48      	it	mi
 101d2e8:	f443 1380 	orrmi.w	r3, r3, #1048576	; 0x100000
		((((uint32_t)bits_len) << RADIO_PCNF0_LFLEN_Pos) & RADIO_PCNF0_LFLEN_Msk) |
 101d2ec:	f000 000f 	and.w	r0, r0, #15
	NRF_RADIO->PCNF0 =
 101d2f0:	4a09      	ldr	r2, [pc, #36]	; (101d318 <radio_pkt_configure+0x44>)
		((((uint32_t)bits_s1) << RADIO_PCNF0_S1LEN_Pos) & RADIO_PCNF0_S1LEN_Msk) | extra;
 101d2f2:	4318      	orrs	r0, r3
 101d2f4:	f440 7080 	orr.w	r0, r0, #256	; 0x100
	NRF_RADIO->PCNF0 =
 101d2f8:	f8c2 0514 	str.w	r0, [r2, #1300]	; 0x514
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
 101d2fc:	f8d2 0518 	ldr.w	r0, [r2, #1304]	; 0x518
 101d300:	4b06      	ldr	r3, [pc, #24]	; (101d31c <radio_pkt_configure+0x48>)
 101d302:	4003      	ands	r3, r0
 101d304:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
	NRF_RADIO->PCNF1 |=
 101d308:	f8d2 3518 	ldr.w	r3, [r2, #1304]	; 0x518
 101d30c:	4319      	orrs	r1, r3
 101d30e:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
 101d312:	f8c2 1518 	str.w	r1, [r2, #1304]	; 0x518
}
 101d316:	4770      	bx	lr
 101d318:	41008000 	.word	0x41008000
 101d31c:	fef80000 	.word	0xfef80000

0101d320 <radio_pkt_rx_set>:
	NRF_RADIO->PACKETPTR = (uint32_t)rx_packet;
 101d320:	4b01      	ldr	r3, [pc, #4]	; (101d328 <radio_pkt_rx_set+0x8>)
 101d322:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
 101d326:	4770      	bx	lr
 101d328:	41008000 	.word	0x41008000

0101d32c <radio_pkt_tx_set>:
void radio_pkt_tx_set(void *tx_packet)
 101d32c:	4b01      	ldr	r3, [pc, #4]	; (101d334 <radio_pkt_tx_set+0x8>)
 101d32e:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
 101d332:	4770      	bx	lr
 101d334:	41008000 	.word	0x41008000

0101d338 <radio_tx_chain_delay_get>:
}
 101d338:	2001      	movs	r0, #1
 101d33a:	4770      	bx	lr

0101d33c <radio_rx_ready_delay_get>:
}
 101d33c:	2029      	movs	r0, #41	; 0x29
 101d33e:	4770      	bx	lr

0101d340 <radio_rx_chain_delay_get>:
static inline uint32_t hal_radio_rx_chain_delay_us_get(uint8_t phy, uint8_t flags)
{
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF5340_RX_CHAIN_DELAY_1M_US;
 101d340:	2802      	cmp	r0, #2
}
 101d342:	bf0c      	ite	eq
 101d344:	2005      	moveq	r0, #5
 101d346:	200a      	movne	r0, #10
 101d348:	4770      	bx	lr
 101d34a:	bf00      	nop

0101d34c <radio_tx_enable>:
    p_reg->CHENCLR = 0xFFFFFFFFuL;
}

NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask)
{
    p_reg->CHENSET = mask;
 101d34c:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101d350:	2101      	movs	r1, #1
{
 101d352:	b410      	push	{r4}

NRF_STATIC_INLINE void nrf_radio_publish_set(NRF_RADIO_Type *  p_reg,
                                             nrf_radio_event_t event,
                                             uint8_t           channel)
{
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
 101d354:	4a06      	ldr	r2, [pc, #24]	; (101d370 <radio_tx_enable+0x24>)
 101d356:	4b07      	ldr	r3, [pc, #28]	; (101d374 <radio_tx_enable+0x28>)
#if defined(DPPI_PRESENT)
NRF_STATIC_INLINE void nrf_timer_subscribe_set(NRF_TIMER_Type * p_reg,
                                               nrf_timer_task_t task,
                                               uint8_t          channel)
{
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
 101d358:	4c07      	ldr	r4, [pc, #28]	; (101d378 <radio_tx_enable+0x2c>)
 101d35a:	f8c3 21ec 	str.w	r2, [r3, #492]	; 0x1ec
 101d35e:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
 101d362:	4a06      	ldr	r2, [pc, #24]	; (101d37c <radio_tx_enable+0x30>)
 101d364:	f8c2 0504 	str.w	r0, [r2, #1284]	; 0x504
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101d368:	6019      	str	r1, [r3, #0]
}
 101d36a:	bc10      	pop	{r4}
 101d36c:	4770      	bx	lr
 101d36e:	bf00      	nop
 101d370:	80000018 	.word	0x80000018
 101d374:	41008000 	.word	0x41008000
 101d378:	41018000 	.word	0x41018000
 101d37c:	4100f000 	.word	0x4100f000

0101d380 <radio_disable>:
{
 101d380:	b430      	push	{r4, r5}
}

NRF_STATIC_INLINE void nrf_timer_subscribe_clear(NRF_TIMER_Type * p_reg,
                                                 nrf_timer_task_t task)
{
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
 101d382:	2200      	movs	r2, #0
}

NRF_STATIC_INLINE void nrf_dppi_group_disable(NRF_DPPIC_Type *         p_reg,
                                              nrf_dppi_channel_group_t group)
{
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1;
 101d384:	2101      	movs	r1, #1
    p_reg->CHENCLR = mask;
 101d386:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(0) = 0;
 101d38a:	4b09      	ldr	r3, [pc, #36]	; (101d3b0 <radio_disable+0x30>)
	NRF_RADIO->SHORTS = 0;
 101d38c:	4809      	ldr	r0, [pc, #36]	; (101d3b4 <radio_disable+0x34>)
 101d38e:	4d0a      	ldr	r5, [pc, #40]	; (101d3b8 <radio_disable+0x38>)
 101d390:	f8c5 208c 	str.w	r2, [r5, #140]	; 0x8c
 101d394:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(1) = 0;
 101d398:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 101d39c:	f8c3 4508 	str.w	r4, [r3, #1288]	; 0x508
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1;
 101d3a0:	6059      	str	r1, [r3, #4]
 101d3a2:	60d9      	str	r1, [r3, #12]
 101d3a4:	f8c0 2200 	str.w	r2, [r0, #512]	; 0x200
 101d3a8:	6101      	str	r1, [r0, #16]
}
 101d3aa:	bc30      	pop	{r4, r5}
 101d3ac:	4770      	bx	lr
 101d3ae:	bf00      	nop
 101d3b0:	4100f000 	.word	0x4100f000
 101d3b4:	41008000 	.word	0x41008000
 101d3b8:	41018000 	.word	0x41018000

0101d3bc <radio_status_reset>:
	NRF_RADIO->EVENTS_READY = 0;
 101d3bc:	2200      	movs	r2, #0
 101d3be:	4b07      	ldr	r3, [pc, #28]	; (101d3dc <radio_status_reset+0x20>)
 101d3c0:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_RADIO->EVENTS_END = 0;
 101d3c4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_RADIO->EVENTS_PHYEND = 0;
 101d3c8:	f8c3 216c 	str.w	r2, [r3, #364]	; 0x16c
	NRF_RADIO->EVENTS_CTEPRESENT = 0;
 101d3cc:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
	NRF_RADIO->EVENTS_BCMATCH = 0;
 101d3d0:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
	NRF_RADIO->EVENTS_DISABLED = 0;
 101d3d4:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
 101d3d8:	4770      	bx	lr
 101d3da:	bf00      	nop
 101d3dc:	41008000 	.word	0x41008000

0101d3e0 <radio_is_ready>:
	return (NRF_RADIO->EVENTS_READY != 0);
 101d3e0:	4b03      	ldr	r3, [pc, #12]	; (101d3f0 <radio_is_ready+0x10>)
 101d3e2:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
 101d3e6:	3800      	subs	r0, #0
 101d3e8:	bf18      	it	ne
 101d3ea:	2001      	movne	r0, #1
 101d3ec:	4770      	bx	lr
 101d3ee:	bf00      	nop
 101d3f0:	41008000 	.word	0x41008000

0101d3f4 <radio_is_done>:
	return (NRF_RADIO->NRF_RADIO_TXRX_END_EVENT != 0);
 101d3f4:	4b03      	ldr	r3, [pc, #12]	; (101d404 <radio_is_done+0x10>)
 101d3f6:	f8d3 016c 	ldr.w	r0, [r3, #364]	; 0x16c
}
 101d3fa:	3800      	subs	r0, #0
 101d3fc:	bf18      	it	ne
 101d3fe:	2001      	movne	r0, #1
 101d400:	4770      	bx	lr
 101d402:	bf00      	nop
 101d404:	41008000 	.word	0x41008000

0101d408 <radio_is_idle>:
}

uint32_t radio_is_idle(void)
{
	return (NRF_RADIO->STATE == 0);
 101d408:	4b03      	ldr	r3, [pc, #12]	; (101d418 <radio_is_idle+0x10>)
 101d40a:	f8d3 0550 	ldr.w	r0, [r3, #1360]	; 0x550
}
 101d40e:	fab0 f080 	clz	r0, r0
 101d412:	0940      	lsrs	r0, r0, #5
 101d414:	4770      	bx	lr
 101d416:	bf00      	nop
 101d418:	41008000 	.word	0x41008000

0101d41c <radio_crc_configure>:

void radio_crc_configure(uint32_t polynomial, uint32_t iv)
{
	NRF_RADIO->CRCCNF =
 101d41c:	f240 1203 	movw	r2, #259	; 0x103
 101d420:	4b03      	ldr	r3, [pc, #12]	; (101d430 <radio_crc_configure+0x14>)
 101d422:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
	    (((RADIO_CRCCNF_SKIPADDR_Skip) << RADIO_CRCCNF_SKIPADDR_Pos) &
	     RADIO_CRCCNF_SKIPADDR_Msk) |
	    (((RADIO_CRCCNF_LEN_Three) << RADIO_CRCCNF_LEN_Pos) &
	       RADIO_CRCCNF_LEN_Msk);
	NRF_RADIO->CRCPOLY = polynomial;
 101d426:	f8c3 0538 	str.w	r0, [r3, #1336]	; 0x538
	NRF_RADIO->CRCINIT = iv;
 101d42a:	f8c3 153c 	str.w	r1, [r3, #1340]	; 0x53c
}
 101d42e:	4770      	bx	lr
 101d430:	41008000 	.word	0x41008000

0101d434 <radio_crc_is_valid>:

uint32_t radio_crc_is_valid(void)
{
	return (NRF_RADIO->CRCSTATUS != 0);
 101d434:	4b03      	ldr	r3, [pc, #12]	; (101d444 <radio_crc_is_valid+0x10>)
 101d436:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
 101d43a:	3800      	subs	r0, #0
 101d43c:	bf18      	it	ne
 101d43e:	2001      	movne	r0, #1
 101d440:	4770      	bx	lr
 101d442:	bf00      	nop
 101d444:	41008000 	.word	0x41008000

0101d448 <radio_pkt_empty_get>:
				       PDU_AC_LL_SIZE_MAX)];

void *radio_pkt_empty_get(void)
{
	return _pkt_empty;
}
 101d448:	4800      	ldr	r0, [pc, #0]	; (101d44c <radio_pkt_empty_get+0x4>)
 101d44a:	4770      	bx	lr
 101d44c:	21007ea4 	.word	0x21007ea4

0101d450 <radio_pkt_scratch_get>:

void *radio_pkt_scratch_get(void)
{
	return _pkt_scratch;
}
 101d450:	4800      	ldr	r0, [pc, #0]	; (101d454 <radio_pkt_scratch_get+0x4>)
 101d452:	4770      	bx	lr
 101d454:	21007da0 	.word	0x21007da0

0101d458 <radio_switch_complete_and_rx>:
		(ppi_group_index + 1) & 0x01) = 0;
 101d458:	f04f 0c00 	mov.w	ip, #0
	sw_tifs_toggle &= 1U;
}
#endif /* CONFIG_BT_CTLR_TIFS_HW */

void radio_switch_complete_and_rx(uint8_t phy_rx)
{
 101d45c:	b4f0      	push	{r4, r5, r6, r7}
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_RXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE;
 101d45e:	4b1a      	ldr	r3, [pc, #104]	; (101d4c8 <radio_switch_complete_and_rx+0x70>)
 101d460:	4c1a      	ldr	r4, [pc, #104]	; (101d4cc <radio_switch_complete_and_rx+0x74>)
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
 101d462:	4d1b      	ldr	r5, [pc, #108]	; (101d4d0 <radio_switch_complete_and_rx+0x78>)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE;
 101d464:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
 101d468:	7829      	ldrb	r1, [r5, #0]
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_EVT =
 101d46a:	4f1a      	ldr	r7, [pc, #104]	; (101d4d4 <radio_switch_complete_and_rx+0x7c>)
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(ppi_group_index) =
 101d46c:	4e1a      	ldr	r6, [pc, #104]	; (101d4d8 <radio_switch_complete_and_rx+0x80>)
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(
 101d46e:	1c48      	adds	r0, r1, #1
 101d470:	f101 020e 	add.w	r2, r1, #14
 101d474:	008b      	lsls	r3, r1, #2
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(ppi_group_index) =
 101d476:	3110      	adds	r1, #16
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_EVT =
 101d478:	f8c4 71ec 	str.w	r7, [r4, #492]	; 0x1ec
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(radio_enable_ppi);
 101d47c:	b2d2      	uxtb	r2, r2
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(ppi_group_index) =
 101d47e:	f846 7031 	str.w	r7, [r6, r1, lsl #3]
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(
 101d482:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 101d486:	f000 0101 	and.w	r1, r0, #1
 101d48a:	f503 33c0 	add.w	r3, r3, #98304	; 0x18000
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(radio_enable_ppi);
 101d48e:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
		(ppi_group_index + 1) & 0x01) = 0;
 101d492:	3110      	adds	r1, #16
 101d494:	f846 c031 	str.w	ip, [r6, r1, lsl #3]
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_EVT(compare_reg) =
 101d498:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
 101d49c:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
	if (delay < SW_SWITCH_TIMER->CC[cc]) {
 101d4a0:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
	sw_tifs_toggle &= 1U;
 101d4a4:	f000 0001 	and.w	r0, r0, #1
	if (delay < SW_SWITCH_TIMER->CC[cc]) {
 101d4a8:	2a2d      	cmp	r2, #45	; 0x2d

NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
                                        nrf_timer_cc_channel_t cc_channel,
                                        uint32_t               cc_value)
{
    p_reg->CC[cc_channel] = cc_value;
 101d4aa:	bf92      	itee	ls
 101d4ac:	2201      	movls	r2, #1
				 (SW_SWITCH_TIMER->CC[cc] - delay));
 101d4ae:	f8d3 2540 	ldrhi.w	r2, [r3, #1344]	; 0x540
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
 101d4b2:	3a2d      	subhi	r2, #45	; 0x2d
 101d4b4:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    p_reg->CHENSET = mask;
 101d4b8:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 101d4bc:	4b06      	ldr	r3, [pc, #24]	; (101d4d8 <radio_switch_complete_and_rx+0x80>)
 101d4be:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	sw_tifs_toggle &= 1U;
 101d4c2:	7028      	strb	r0, [r5, #0]
	 *       calculations.
	 */
	sw_switch(SW_SWITCH_TX, SW_SWITCH_RX, SW_SWITCH_PHY_1M, SW_SWITCH_FLAGS_DONTCARE, phy_rx,
		  SW_SWITCH_FLAGS_DONTCARE, END_EVT_DELAY_DISABLED);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 101d4c4:	bcf0      	pop	{r4, r5, r6, r7}
 101d4c6:	4770      	bx	lr
 101d4c8:	00100001 	.word	0x00100001
 101d4cc:	41008000 	.word	0x41008000
 101d4d0:	21008356 	.word	0x21008356
 101d4d4:	80000018 	.word	0x80000018
 101d4d8:	4100f000 	.word	0x4100f000

0101d4dc <radio_switch_complete_and_tx>:

void radio_switch_complete_and_tx(uint8_t phy_rx, uint8_t flags_rx,
				  uint8_t phy_tx, uint8_t flags_tx)
{
 101d4dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_TXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE;
 101d4e0:	4b26      	ldr	r3, [pc, #152]	; (101d57c <radio_switch_complete_and_tx+0xa0>)
 101d4e2:	4d27      	ldr	r5, [pc, #156]	; (101d580 <radio_switch_complete_and_tx+0xa4>)
	}
}

static inline uint32_t hal_radio_tx_ready_delay_ns_get(uint8_t phy, uint8_t flags)
{
	switch (phy) {
 101d4e4:	f649 6134 	movw	r1, #40500	; 0x9e34
 101d4e8:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
 101d4ec:	f24a 13b8 	movw	r3, #41400	; 0xa1b8
 101d4f0:	2a02      	cmp	r2, #2
 101d4f2:	bf18      	it	ne
 101d4f4:	4619      	movne	r1, r3
static inline uint32_t hal_radio_rx_chain_delay_ns_get(uint8_t phy, uint8_t flags)
{
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF5340_RX_CHAIN_DELAY_1M_NS;
 101d4f6:	f242 42b8 	movw	r2, #9400	; 0x24b8
 101d4fa:	f241 3388 	movw	r3, #5000	; 0x1388
 101d4fe:	2802      	cmp	r0, #2
 101d500:	bf18      	it	ne
 101d502:	4613      	movne	r3, r2
		(ppi_group_index + 1) & 0x01) = 0;
 101d504:	2000      	movs	r0, #0
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
 101d506:	4c1f      	ldr	r4, [pc, #124]	; (101d584 <radio_switch_complete_and_tx+0xa8>)
			delay = HAL_RADIO_NS2US_ROUND(
 101d508:	440b      	add	r3, r1
 101d50a:	4a1f      	ldr	r2, [pc, #124]	; (101d588 <radio_switch_complete_and_tx+0xac>)
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
 101d50c:	7821      	ldrb	r1, [r4, #0]
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_EVT =
 101d50e:	f8df 807c 	ldr.w	r8, [pc, #124]	; 101d58c <radio_switch_complete_and_tx+0xb0>
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(ppi_group_index) =
 101d512:	4f1f      	ldr	r7, [pc, #124]	; (101d590 <radio_switch_complete_and_tx+0xb4>)
			delay = HAL_RADIO_NS2US_ROUND(
 101d514:	fba2 3e03 	umull	r3, lr, r2, r3
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(
 101d518:	f101 0c01 	add.w	ip, r1, #1
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
 101d51c:	f101 020e 	add.w	r2, r1, #14
 101d520:	008b      	lsls	r3, r1, #2
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(ppi_group_index) =
 101d522:	3110      	adds	r1, #16
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_EVT =
 101d524:	f8c5 81ec 	str.w	r8, [r5, #492]	; 0x1ec
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(radio_enable_ppi);
 101d528:	b2d2      	uxtb	r2, r2
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(ppi_group_index) =
 101d52a:	f847 8031 	str.w	r8, [r7, r1, lsl #3]
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(
 101d52e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 101d532:	f00c 0101 	and.w	r1, ip, #1
 101d536:	f503 33c0 	add.w	r3, r3, #98304	; 0x18000
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(radio_enable_ppi);
 101d53a:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
		(ppi_group_index + 1) & 0x01) = 0;
 101d53e:	3110      	adds	r1, #16
 101d540:	f847 0031 	str.w	r0, [r7, r1, lsl #3]
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_EVT(compare_reg) =
 101d544:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
 101d548:	f8c5 2080 	str.w	r2, [r5, #128]	; 0x80
	if (delay < SW_SWITCH_TIMER->CC[cc]) {
 101d54c:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
 101d550:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
 101d554:	ebb2 1f9e 	cmp.w	r2, lr, lsr #6
 101d558:	bf91      	iteee	ls
 101d55a:	2201      	movls	r2, #1
				 (SW_SWITCH_TIMER->CC[cc] - delay));
 101d55c:	f8d3 2540 	ldrhi.w	r2, [r3, #1344]	; 0x540
 101d560:	ea4f 169e 	movhi.w	r6, lr, lsr #6
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
 101d564:	1b92      	subhi	r2, r2, r6
 101d566:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
 101d56a:	4a09      	ldr	r2, [pc, #36]	; (101d590 <radio_switch_complete_and_tx+0xb4>)
	sw_tifs_toggle &= 1U;
 101d56c:	f00c 0301 	and.w	r3, ip, #1
 101d570:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
 101d574:	7023      	strb	r3, [r4, #0]

	sw_switch(SW_SWITCH_RX, SW_SWITCH_TX, phy_rx, flags_rx, phy_tx, flags_tx,
		  END_EVT_DELAY_DISABLED);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 101d576:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 101d57a:	bf00      	nop
 101d57c:	00100001 	.word	0x00100001
 101d580:	41008000 	.word	0x41008000
 101d584:	21008356 	.word	0x21008356
 101d588:	10624dd3 	.word	0x10624dd3
 101d58c:	80000018 	.word	0x80000018
 101d590:	4100f000 	.word	0x4100f000

0101d594 <radio_switch_complete_and_disable>:
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
 101d594:	2300      	movs	r3, #0
		  END_EVT_DELAY_DISABLED);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}

void radio_switch_complete_and_disable(void)
{
 101d596:	b410      	push	{r4}
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(0) = 0;
 101d598:	4a06      	ldr	r2, [pc, #24]	; (101d5b4 <radio_switch_complete_and_disable+0x20>)
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = (RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_DISABLE_Msk);
#else /* CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = (RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE);
 101d59a:	4c07      	ldr	r4, [pc, #28]	; (101d5b8 <radio_switch_complete_and_disable+0x24>)
 101d59c:	4807      	ldr	r0, [pc, #28]	; (101d5bc <radio_switch_complete_and_disable+0x28>)
 101d59e:	4908      	ldr	r1, [pc, #32]	; (101d5c0 <radio_switch_complete_and_disable+0x2c>)
 101d5a0:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
 101d5a4:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
 101d5a8:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(1) = 0;
 101d5ac:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
	hal_radio_sw_switch_disable();
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 101d5b0:	bc10      	pop	{r4}
 101d5b2:	4770      	bx	lr
 101d5b4:	4100f000 	.word	0x4100f000
 101d5b8:	00100001 	.word	0x00100001
 101d5bc:	41008000 	.word	0x41008000
 101d5c0:	41018000 	.word	0x41018000

0101d5c4 <radio_rssi_status_reset>:
	return NRF_RADIO->RSSISAMPLE;
}

void radio_rssi_status_reset(void)
{
	NRF_RADIO->EVENTS_RSSIEND = 0;
 101d5c4:	2200      	movs	r2, #0
 101d5c6:	4b02      	ldr	r3, [pc, #8]	; (101d5d0 <radio_rssi_status_reset+0xc>)
 101d5c8:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
}
 101d5cc:	4770      	bx	lr
 101d5ce:	bf00      	nop
 101d5d0:	41008000 	.word	0x41008000

0101d5d4 <radio_rssi_is_ready>:

uint32_t radio_rssi_is_ready(void)
{
	return (NRF_RADIO->EVENTS_RSSIEND != 0);
 101d5d4:	4b03      	ldr	r3, [pc, #12]	; (101d5e4 <radio_rssi_is_ready+0x10>)
 101d5d6:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
 101d5da:	3800      	subs	r0, #0
 101d5dc:	bf18      	it	ne
 101d5de:	2001      	movne	r0, #1
 101d5e0:	4770      	bx	lr
 101d5e2:	bf00      	nop
 101d5e4:	41008000 	.word	0x41008000

0101d5e8 <radio_filter_disable>:
	NRF_RADIO->DACNF = ((uint32_t)bitmask_addr_type << 8) | bitmask_enable;
}

void radio_filter_disable(void)
{
	NRF_RADIO->DACNF &= ~(0x000000FF);
 101d5e8:	4a03      	ldr	r2, [pc, #12]	; (101d5f8 <radio_filter_disable+0x10>)
 101d5ea:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
 101d5ee:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 101d5f2:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
}
 101d5f6:	4770      	bx	lr
 101d5f8:	41008000 	.word	0x41008000

0101d5fc <radio_filter_status_reset>:

void radio_filter_status_reset(void)
{
	NRF_RADIO->EVENTS_DEVMATCH = 0;
 101d5fc:	2200      	movs	r2, #0
 101d5fe:	4b02      	ldr	r3, [pc, #8]	; (101d608 <radio_filter_status_reset+0xc>)
 101d600:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
 101d604:	4770      	bx	lr
 101d606:	bf00      	nop
 101d608:	41008000 	.word	0x41008000

0101d60c <radio_filter_has_match>:

uint32_t radio_filter_has_match(void)
{
	return (NRF_RADIO->EVENTS_DEVMATCH != 0);
 101d60c:	4b03      	ldr	r3, [pc, #12]	; (101d61c <radio_filter_has_match+0x10>)
 101d60e:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
 101d612:	3800      	subs	r0, #0
 101d614:	bf18      	it	ne
 101d616:	2001      	movne	r0, #1
 101d618:	4770      	bx	lr
 101d61a:	bf00      	nop
 101d61c:	41008000 	.word	0x41008000

0101d620 <radio_filter_match_get>:

uint32_t radio_filter_match_get(void)
{
	return NRF_RADIO->DAI;
 101d620:	4b01      	ldr	r3, [pc, #4]	; (101d628 <radio_filter_match_get+0x8>)
 101d622:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
}
 101d626:	4770      	bx	lr
 101d628:	41008000 	.word	0x41008000

0101d62c <radio_tmr_status_reset>:
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
 101d62c:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 101d630:	4903      	ldr	r1, [pc, #12]	; (101d640 <radio_tmr_status_reset+0x14>)
    p_reg->CHENCLR = mask;
 101d632:	4b04      	ldr	r3, [pc, #16]	; (101d644 <radio_tmr_status_reset+0x18>)
 101d634:	4a04      	ldr	r2, [pc, #16]	; (101d648 <radio_tmr_status_reset+0x1c>)
 101d636:	f8c1 0348 	str.w	r0, [r1, #840]	; 0x348
 101d63a:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
#endif /* CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE */
#if defined(CONFIG_BT_CTLR_DF_CONN_CTE_RX)
			BIT(HAL_TRIGGER_CRYPT_DELAY_PPI) |
#endif /* CONFIG_BT_CTLR_DF_CONN_CTE_RX */
			BIT(HAL_TRIGGER_CRYPT_PPI));
}
 101d63e:	4770      	bx	lr
 101d640:	41011000 	.word	0x41011000
 101d644:	4100f000 	.word	0x4100f000
 101d648:	01000fc0 	.word	0x01000fc0

0101d64c <radio_tmr_tifs_set>:
void radio_tmr_tifs_set(uint32_t tifs)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->TIFS = tifs;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	nrf_timer_cc_set(SW_SWITCH_TIMER,
 101d64c:	4b03      	ldr	r3, [pc, #12]	; (101d65c <radio_tmr_tifs_set+0x10>)
    p_reg->CC[cc_channel] = cc_value;
 101d64e:	4a04      	ldr	r2, [pc, #16]	; (101d660 <radio_tmr_tifs_set+0x14>)
 101d650:	781b      	ldrb	r3, [r3, #0]
 101d652:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 101d656:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			 SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle), tifs);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 101d65a:	4770      	bx	lr
 101d65c:	21008356 	.word	0x21008356
 101d660:	41018000 	.word	0x41018000

0101d664 <radio_tmr_start>:

uint32_t radio_tmr_start(uint8_t trx, uint32_t ticks_start, uint32_t remainder)
{
 101d664:	b5f0      	push	{r4, r5, r6, r7, lr}
/* Remove ticks and return positive remainder value in microseconds */
static inline void hal_ticker_remove_jitter(uint32_t *ticks,
					    uint32_t *remainder)
{
	/* Is remainder less than 1 us */
	if ((*remainder & BIT(31)) || !(*remainder / 1000000UL)) {
 101d666:	f5a2 2374 	sub.w	r3, r2, #999424	; 0xf4000
 101d66a:	4d32      	ldr	r5, [pc, #200]	; (101d734 <radio_tmr_start+0xd0>)
 101d66c:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
 101d670:	42ab      	cmp	r3, r5
 101d672:	4604      	mov	r4, r0
 101d674:	d906      	bls.n	101d684 <radio_tmr_start+0x20>
		*ticks -= 1U;
		*remainder += HAL_TICKER_CNTR_CLK_UNIT_FS / 1000UL;
 101d676:	f102 72e8 	add.w	r2, r2, #30408704	; 0x1d00000
 101d67a:	f502 32d4 	add.w	r2, r2, #108544	; 0x1a800
		*ticks -= 1U;
 101d67e:	3901      	subs	r1, #1
		*remainder += HAL_TICKER_CNTR_CLK_UNIT_FS / 1000UL;
 101d680:	f502 72a5 	add.w	r2, r2, #330	; 0x14a
	}

	/* pico seconds to micro seconds unit */
	*remainder /= 1000000UL;
 101d684:	4b2c      	ldr	r3, [pc, #176]	; (101d738 <radio_tmr_start+0xd4>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101d686:	f04f 0e01 	mov.w	lr, #1
 101d68a:	fba3 3202 	umull	r3, r2, r3, r2
	hal_ticker_remove_jitter(&ticks_start, &remainder);

	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CLEAR);
	EVENT_TIMER->MODE = 0;
 101d68e:	f04f 0c00 	mov.w	ip, #0
 101d692:	0c90      	lsrs	r0, r2, #18
	EVENT_TIMER->PRESCALER = 4;
 101d694:	2704      	movs	r7, #4
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
 101d696:	2202      	movs	r2, #2
    p_reg->EVTENSET = mask;
 101d698:	f44f 2680 	mov.w	r6, #262144	; 0x40000
    p_reg->CHENSET = mask;
 101d69c:	2580      	movs	r5, #128	; 0x80
 101d69e:	4b27      	ldr	r3, [pc, #156]	; (101d73c <radio_tmr_start+0xd8>)
 101d6a0:	f8c3 e00c 	str.w	lr, [r3, #12]
	EVENT_TIMER->MODE = 0;
 101d6a4:	f8c3 c504 	str.w	ip, [r3, #1284]	; 0x504
	EVENT_TIMER->PRESCALER = 4;
 101d6a8:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
 101d6ac:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
 101d6b0:	4a23      	ldr	r2, [pc, #140]	; (101d740 <radio_tmr_start+0xdc>)
    p_reg->CC[cc_channel] = cc_value;
 101d6b2:	f8c3 0540 	str.w	r0, [r3, #1344]	; 0x540
 101d6b6:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
 101d6ba:	4922      	ldr	r1, [pc, #136]	; (101d744 <radio_tmr_start+0xe0>)
    p_reg->EVTENSET = mask;
 101d6bc:	f8c2 6344 	str.w	r6, [r2, #836]	; 0x344
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
 101d6c0:	f8c2 11c8 	str.w	r1, [r2, #456]	; 0x1c8
 101d6c4:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
 101d6c8:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
 101d6cc:	f8c2 5504 	str.w	r5, [r2, #1284]	; 0x504
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
 101d6d0:	4a1d      	ldr	r2, [pc, #116]	; (101d748 <radio_tmr_start+0xe4>)
 101d6d2:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
	if (trx) {
 101d6d6:	b344      	cbz	r4, 101d72a <radio_tmr_start+0xc6>
 101d6d8:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 101d6dc:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101d6e0:	2401      	movs	r4, #1
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	last_pdu_end_us = 0U;

#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_CLEAR);
	SW_SWITCH_TIMER->MODE = 0;
 101d6e2:	2100      	movs	r1, #0
 101d6e4:	2640      	movs	r6, #64	; 0x40
	SW_SWITCH_TIMER->PRESCALER = 4;
 101d6e6:	2504      	movs	r5, #4
 101d6e8:	4b18      	ldr	r3, [pc, #96]	; (101d74c <radio_tmr_start+0xe8>)
 101d6ea:	4a19      	ldr	r2, [pc, #100]	; (101d750 <radio_tmr_start+0xec>)
 101d6ec:	f8c2 6504 	str.w	r6, [r2, #1284]	; 0x504
 101d6f0:	60dc      	str	r4, [r3, #12]
	SW_SWITCH_TIMER->MODE = 0;
 101d6f2:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
	SW_SWITCH_TIMER->PRESCALER = 4;
 101d6f6:	f8c3 5510 	str.w	r5, [r3, #1296]	; 0x510
	SW_SWITCH_TIMER->BITMODE = 0; /* 16 bit */
 101d6fa:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
 101d6fe:	4d15      	ldr	r5, [pc, #84]	; (101d754 <radio_tmr_start+0xf0>)
 101d700:	4915      	ldr	r1, [pc, #84]	; (101d758 <radio_tmr_start+0xf4>)
 101d702:	601c      	str	r4, [r3, #0]
 101d704:	f8c5 11ec 	str.w	r1, [r5, #492]	; 0x1ec
 101d708:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000

	/* Wire SW SWITCH TIMER EVENTS COMPARE event <cc index-0> to
	 * PPI Group TASK [<index-0>] DISABLE task, over PPI<index-0>.
	 */
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_EVT(
		SW_SWITCH_TIMER_EVTS_COMP(0)) =
 101d70c:	4c13      	ldr	r4, [pc, #76]	; (101d75c <radio_tmr_start+0xf8>)
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
 101d70e:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c

	/* Wire SW SWITCH TIMER event <compare index-1> to
	 * PPI Group[<index-1>] Disable Task, over PPI<index-1>.
	 */
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_EVT(
		SW_SWITCH_TIMER_EVTS_COMP(1)) =
 101d712:	3909      	subs	r1, #9
 101d714:	f8c2 5504 	str.w	r5, [r2, #1284]	; 0x504
		SW_SWITCH_TIMER_EVTS_COMP(0)) =
 101d718:	f8c3 41c0 	str.w	r4, [r3, #448]	; 0x1c0
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_TASK(0) =
 101d71c:	f8c2 4084 	str.w	r4, [r2, #132]	; 0x84
		SW_SWITCH_TIMER_EVTS_COMP(1)) =
 101d720:	f8c3 11c4 	str.w	r1, [r3, #452]	; 0x1c4
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_EVT(
			HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI(1));
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_TASK(1) =
 101d724:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
	 */
#endif /* CONFIG_BT_CTLR_PHY_CODED && CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder;
}
 101d728:	bdf0      	pop	{r4, r5, r6, r7, pc}
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
 101d72a:	4b0a      	ldr	r3, [pc, #40]	; (101d754 <radio_tmr_start+0xf0>)
 101d72c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 101d730:	e7d6      	b.n	101d6e0 <radio_tmr_start+0x7c>
 101d732:	bf00      	nop
 101d734:	7ff0bdbf 	.word	0x7ff0bdbf
 101d738:	431bde83 	.word	0x431bde83
 101d73c:	4100c000 	.word	0x4100c000
 101d740:	41011000 	.word	0x41011000
 101d744:	80000007 	.word	0x80000007
 101d748:	80000006 	.word	0x80000006
 101d74c:	41018000 	.word	0x41018000
 101d750:	4100f000 	.word	0x4100f000
 101d754:	41008000 	.word	0x41008000
 101d758:	80000018 	.word	0x80000018
 101d75c:	8000000e 	.word	0x8000000e

0101d760 <radio_tmr_start_get>:
    return p_reg->CC[ch];
 101d760:	4b01      	ldr	r3, [pc, #4]	; (101d768 <radio_tmr_start_get+0x8>)
 101d762:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}

uint32_t radio_tmr_start_get(void)
{
	return nrf_rtc_cc_get(NRF_RTC0, 2);
}
 101d766:	4770      	bx	lr
 101d768:	41011000 	.word	0x41011000

0101d76c <radio_tmr_stop>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101d76c:	2301      	movs	r3, #1
 101d76e:	4903      	ldr	r1, [pc, #12]	; (101d77c <radio_tmr_stop+0x10>)
 101d770:	4a03      	ldr	r2, [pc, #12]	; (101d780 <radio_tmr_stop+0x14>)
 101d772:	604b      	str	r3, [r1, #4]
 101d774:	610b      	str	r3, [r1, #16]
 101d776:	6053      	str	r3, [r2, #4]
 101d778:	6113      	str	r3, [r2, #16]

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_STOP);
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_SHUTDOWN);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 101d77a:	4770      	bx	lr
 101d77c:	4100c000 	.word	0x4100c000
 101d780:	41018000 	.word	0x41018000

0101d784 <radio_tmr_hcto_configure>:

void radio_tmr_hcto_configure(uint32_t hcto)
{
 101d784:	b470      	push	{r4, r5, r6}
 101d786:	f44f 66c0 	mov.w	r6, #1536	; 0x600
    p_reg->CC[cc_channel] = cc_value;
 101d78a:	4b09      	ldr	r3, [pc, #36]	; (101d7b0 <radio_tmr_hcto_configure+0x2c>)
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
 101d78c:	4c09      	ldr	r4, [pc, #36]	; (101d7b4 <radio_tmr_hcto_configure+0x30>)
 101d78e:	4a0a      	ldr	r2, [pc, #40]	; (101d7b8 <radio_tmr_hcto_configure+0x34>)
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
 101d790:	490a      	ldr	r1, [pc, #40]	; (101d7bc <radio_tmr_hcto_configure+0x38>)
 101d792:	4d0b      	ldr	r5, [pc, #44]	; (101d7c0 <radio_tmr_hcto_configure+0x3c>)
    p_reg->CC[cc_channel] = cc_value;
 101d794:	f8c3 0544 	str.w	r0, [r3, #1348]	; 0x544
 101d798:	f8c2 4184 	str.w	r4, [r2, #388]	; 0x184
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
 101d79c:	f8c3 40c4 	str.w	r4, [r3, #196]	; 0xc4
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
 101d7a0:	f8c3 11c4 	str.w	r1, [r3, #452]	; 0x1c4
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
 101d7a4:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
 101d7a8:	f8c5 6504 	str.w	r6, [r5, #1284]	; 0x504
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_disable_on_hcto_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI) |
		BIT(HAL_RADIO_DISABLE_ON_HCTO_PPI));
}
 101d7ac:	bc70      	pop	{r4, r5, r6}
 101d7ae:	4770      	bx	lr
 101d7b0:	4100c000 	.word	0x4100c000
 101d7b4:	80000009 	.word	0x80000009
 101d7b8:	41008000 	.word	0x41008000
 101d7bc:	8000000a 	.word	0x8000000a
 101d7c0:	4100f000 	.word	0x4100f000

0101d7c4 <radio_tmr_aa_capture>:
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
 101d7c4:	4909      	ldr	r1, [pc, #36]	; (101d7ec <radio_tmr_aa_capture+0x28>)
 101d7c6:	480a      	ldr	r0, [pc, #40]	; (101d7f0 <radio_tmr_aa_capture+0x2c>)
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
 101d7c8:	4b0a      	ldr	r3, [pc, #40]	; (101d7f4 <radio_tmr_aa_capture+0x30>)
 101d7ca:	4a0b      	ldr	r2, [pc, #44]	; (101d7f8 <radio_tmr_aa_capture+0x34>)

void radio_tmr_aa_capture(void)
{
 101d7cc:	b410      	push	{r4}
 101d7ce:	f8c1 0180 	str.w	r0, [r1, #384]	; 0x180
 101d7d2:	f8c3 00c0 	str.w	r0, [r3, #192]	; 0xc0
 101d7d6:	f8c1 2184 	str.w	r2, [r1, #388]	; 0x184
 101d7da:	f44f 7140 	mov.w	r1, #768	; 0x300
 101d7de:	4c07      	ldr	r4, [pc, #28]	; (101d7fc <radio_tmr_aa_capture+0x38>)
 101d7e0:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
 101d7e4:	f8c4 1504 	str.w	r1, [r4, #1284]	; 0x504
	hal_radio_ready_time_capture_ppi_config();
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_READY_TIME_CAPTURE_PPI) |
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI));
}
 101d7e8:	bc10      	pop	{r4}
 101d7ea:	4770      	bx	lr
 101d7ec:	41008000 	.word	0x41008000
 101d7f0:	80000008 	.word	0x80000008
 101d7f4:	4100c000 	.word	0x4100c000
 101d7f8:	80000009 	.word	0x80000009
 101d7fc:	4100f000 	.word	0x4100f000

0101d800 <radio_tmr_aa_get>:

uint32_t radio_tmr_aa_get(void)
{
	return EVENT_TIMER->CC[1];
 101d800:	4b01      	ldr	r3, [pc, #4]	; (101d808 <radio_tmr_aa_get+0x8>)
 101d802:	f8d3 0544 	ldr.w	r0, [r3, #1348]	; 0x544
}
 101d806:	4770      	bx	lr
 101d808:	4100c000 	.word	0x4100c000

0101d80c <radio_tmr_aa_save>:

static uint32_t radio_tmr_aa;

void radio_tmr_aa_save(uint32_t aa)
{
	radio_tmr_aa = aa;
 101d80c:	4b01      	ldr	r3, [pc, #4]	; (101d814 <radio_tmr_aa_save+0x8>)
 101d80e:	6018      	str	r0, [r3, #0]
}
 101d810:	4770      	bx	lr
 101d812:	bf00      	nop
 101d814:	21007d9c 	.word	0x21007d9c

0101d818 <radio_tmr_aa_restore>:

uint32_t radio_tmr_aa_restore(void)
{
	/* NOTE: we dont need to restore for now, but return the saved value. */
	return radio_tmr_aa;
 101d818:	4b01      	ldr	r3, [pc, #4]	; (101d820 <radio_tmr_aa_restore+0x8>)
}
 101d81a:	6818      	ldr	r0, [r3, #0]
 101d81c:	4770      	bx	lr
 101d81e:	bf00      	nop
 101d820:	21007d9c 	.word	0x21007d9c

0101d824 <radio_tmr_ready_get>:

uint32_t radio_tmr_ready_get(void)
{
	return EVENT_TIMER->CC[0];
 101d824:	4b01      	ldr	r3, [pc, #4]	; (101d82c <radio_tmr_ready_get+0x8>)
 101d826:	f8d3 0540 	ldr.w	r0, [r3, #1344]	; 0x540
}
 101d82a:	4770      	bx	lr
 101d82c:	4100c000 	.word	0x4100c000

0101d830 <radio_tmr_end_capture>:
 101d830:	f44f 6100 	mov.w	r1, #2048	; 0x800
{
	return radio_tmr_ready;
}

void radio_tmr_end_capture(void)
{
 101d834:	b410      	push	{r4}
 101d836:	4b06      	ldr	r3, [pc, #24]	; (101d850 <radio_tmr_end_capture+0x20>)
 101d838:	4c06      	ldr	r4, [pc, #24]	; (101d854 <radio_tmr_end_capture+0x24>)
 101d83a:	4807      	ldr	r0, [pc, #28]	; (101d858 <radio_tmr_end_capture+0x28>)
 101d83c:	4a07      	ldr	r2, [pc, #28]	; (101d85c <radio_tmr_end_capture+0x2c>)
 101d83e:	f8c4 318c 	str.w	r3, [r4, #396]	; 0x18c
 101d842:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8
 101d846:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
	hal_radio_end_time_capture_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
#endif /* !CONFIG_SOC_SERIES_NRF53X ||
	* (CONFIG_SOC_SERIES_NRF53X && !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	*/
}
 101d84a:	bc10      	pop	{r4}
 101d84c:	4770      	bx	lr
 101d84e:	bf00      	nop
 101d850:	8000000b 	.word	0x8000000b
 101d854:	41008000 	.word	0x41008000
 101d858:	4100c000 	.word	0x4100c000
 101d85c:	4100f000 	.word	0x4100f000

0101d860 <radio_tmr_end_get>:
uint32_t radio_tmr_end_get(void)
{
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	return last_pdu_end_us;
#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	return EVENT_TIMER->CC[2];
 101d860:	4b01      	ldr	r3, [pc, #4]	; (101d868 <radio_tmr_end_get+0x8>)
 101d862:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
}
 101d866:	4770      	bx	lr
 101d868:	4100c000 	.word	0x4100c000

0101d86c <radio_tmr_tifs_base_get>:

uint32_t radio_tmr_tifs_base_get(void)
 101d86c:	4b01      	ldr	r3, [pc, #4]	; (101d874 <radio_tmr_tifs_base_get+0x8>)
 101d86e:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
 101d872:	4770      	bx	lr
 101d874:	4100c000 	.word	0x4100c000

0101d878 <radio_ccm_rx_pkt_set>:
#endif /* HAL_RADIO_GPIO_HAVE_PA_PIN || HAL_RADIO_GPIO_HAVE_LNA_PIN */

static uint8_t MALIGN(4) _ccm_scratch[(HAL_RADIO_PDU_LEN_MAX - 4) + 16];

void *radio_ccm_rx_pkt_set(struct ccm *ccm, uint8_t phy, void *pkt)
{
 101d878:	b430      	push	{r4, r5}
	uint32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
 101d87a:	2402      	movs	r4, #2
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 101d87c:	2500      	movs	r5, #0
 101d87e:	4b19      	ldr	r3, [pc, #100]	; (101d8e4 <radio_ccm_rx_pkt_set+0x6c>)
	/* Enable CCM support for 8-bit length field PDUs. */
	mode |= (CCM_MODE_LENGTH_Extended << CCM_MODE_LENGTH_Pos) &
		CCM_MODE_LENGTH_Msk;

	/* Select CCM data rate based on current PHY in use. */
	switch (phy) {
 101d880:	42a1      	cmp	r1, r4
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 101d882:	f8c3 5500 	str.w	r5, [r3, #1280]	; 0x500
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
 101d886:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
 101d88a:	f44f 7400 	mov.w	r4, #512	; 0x200
 101d88e:	4d16      	ldr	r5, [pc, #88]	; (101d8e8 <radio_ccm_rx_pkt_set+0x70>)
 101d890:	4916      	ldr	r1, [pc, #88]	; (101d8ec <radio_ccm_rx_pkt_set+0x74>)
 101d892:	f8c5 1184 	str.w	r1, [r5, #388]	; 0x184
#if defined(DPPI_PRESENT)
NRF_STATIC_INLINE void nrf_ccm_subscribe_set(NRF_CCM_Type * p_reg,
                                             nrf_ccm_task_t task,
                                             uint8_t        channel)
{
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
 101d896:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
 101d89a:	bf0c      	ite	eq
 101d89c:	4b14      	ldreq	r3, [pc, #80]	; (101d8f0 <radio_ccm_rx_pkt_set+0x78>)
 101d89e:	f503 5380 	addne.w	r3, r3, #4096	; 0x1000
 101d8a2:	f8c3 4504 	str.w	r4, [r3, #1284]	; 0x504
	NRF_CCM->MODE = mode;
	NRF_CCM->CNFPTR = (uint32_t)ccm;
	NRF_CCM->INPTR = (uint32_t)_pkt_scratch;
	NRF_CCM->OUTPTR = (uint32_t)pkt;
	NRF_CCM->SCRATCHPTR = (uint32_t)_ccm_scratch;
	NRF_CCM->SHORTS = 0;
 101d8a6:	f04f 0100 	mov.w	r1, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101d8aa:	f04f 0401 	mov.w	r4, #1
	NRF_CCM->MODE = mode;
 101d8ae:	4b0d      	ldr	r3, [pc, #52]	; (101d8e4 <radio_ccm_rx_pkt_set+0x6c>)
		mode |= (CCM_MODE_DATARATE_1Mbit <<
 101d8b0:	bf14      	ite	ne
 101d8b2:	4d10      	ldrne	r5, [pc, #64]	; (101d8f4 <radio_ccm_rx_pkt_set+0x7c>)
		mode |= (CCM_MODE_DATARATE_2Mbit <<
 101d8b4:	4d10      	ldreq	r5, [pc, #64]	; (101d8f8 <radio_ccm_rx_pkt_set+0x80>)
	NRF_CCM->MODE = mode;
 101d8b6:	f8c3 5504 	str.w	r5, [r3, #1284]	; 0x504
	NRF_CCM->CNFPTR = (uint32_t)ccm;
 101d8ba:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
	NRF_CCM->INPTR = (uint32_t)_pkt_scratch;
 101d8be:	480f      	ldr	r0, [pc, #60]	; (101d8fc <radio_ccm_rx_pkt_set+0x84>)
 101d8c0:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
	NRF_CCM->OUTPTR = (uint32_t)pkt;
 101d8c4:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_CCM->SCRATCHPTR = (uint32_t)_ccm_scratch;
 101d8c8:	4a0d      	ldr	r2, [pc, #52]	; (101d900 <radio_ccm_rx_pkt_set+0x88>)
 101d8ca:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
	NRF_CCM->SHORTS = 0;
 101d8ce:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
	NRF_CCM->EVENTS_ENDKSGEN = 0;
 101d8d2:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
	NRF_CCM->EVENTS_ENDCRYPT = 0;
 101d8d6:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
 101d8da:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
 101d8de:	601c      	str	r4, [r3, #0]

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
 101d8e0:	bc30      	pop	{r4, r5}
 101d8e2:	4770      	bx	lr
 101d8e4:	4100e000 	.word	0x4100e000
 101d8e8:	41008000 	.word	0x41008000
 101d8ec:	80000009 	.word	0x80000009
 101d8f0:	4100f000 	.word	0x4100f000
 101d8f4:	01000001 	.word	0x01000001
 101d8f8:	01010001 	.word	0x01010001
 101d8fc:	21007da0 	.word	0x21007da0
 101d900:	21007c90 	.word	0x21007c90

0101d904 <radio_ccm_tx_pkt_set>:

void *radio_ccm_tx_pkt_set(struct ccm *ccm, void *pkt)
{
 101d904:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 101d906:	2200      	movs	r2, #0
	NRF_CCM->MODE = mode;
	NRF_CCM->CNFPTR = (uint32_t)ccm;
	NRF_CCM->INPTR = (uint32_t)pkt;
	NRF_CCM->OUTPTR = (uint32_t)_pkt_scratch;
	NRF_CCM->SCRATCHPTR = (uint32_t)_ccm_scratch;
	NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
 101d908:	2401      	movs	r4, #1
{
 101d90a:	4684      	mov	ip, r0
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
 101d90c:	2702      	movs	r7, #2
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 101d90e:	4b0e      	ldr	r3, [pc, #56]	; (101d948 <radio_ccm_tx_pkt_set+0x44>)
	NRF_CCM->OUTPTR = (uint32_t)_pkt_scratch;
 101d910:	480e      	ldr	r0, [pc, #56]	; (101d94c <radio_ccm_tx_pkt_set+0x48>)
	NRF_CCM->MODE = mode;
 101d912:	4e0f      	ldr	r6, [pc, #60]	; (101d950 <radio_ccm_tx_pkt_set+0x4c>)
	NRF_CCM->SCRATCHPTR = (uint32_t)_ccm_scratch;
 101d914:	4d0f      	ldr	r5, [pc, #60]	; (101d954 <radio_ccm_tx_pkt_set+0x50>)
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 101d916:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
 101d91a:	f8c3 7500 	str.w	r7, [r3, #1280]	; 0x500
	NRF_CCM->MODE = mode;
 101d91e:	f8c3 6504 	str.w	r6, [r3, #1284]	; 0x504
	NRF_CCM->CNFPTR = (uint32_t)ccm;
 101d922:	f8c3 c508 	str.w	ip, [r3, #1288]	; 0x508
	NRF_CCM->INPTR = (uint32_t)pkt;
 101d926:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
	NRF_CCM->OUTPTR = (uint32_t)_pkt_scratch;
 101d92a:	f8c3 0510 	str.w	r0, [r3, #1296]	; 0x510
	NRF_CCM->SCRATCHPTR = (uint32_t)_ccm_scratch;
 101d92e:	f8c3 5514 	str.w	r5, [r3, #1300]	; 0x514
	NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
 101d932:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
	NRF_CCM->EVENTS_ENDKSGEN = 0;
 101d936:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_CCM->EVENTS_ENDCRYPT = 0;
 101d93a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
 101d93e:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
 101d942:	601c      	str	r4, [r3, #0]

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
 101d944:	bcf0      	pop	{r4, r5, r6, r7}
 101d946:	4770      	bx	lr
 101d948:	4100e000 	.word	0x4100e000
 101d94c:	21007da0 	.word	0x21007da0
 101d950:	01010000 	.word	0x01010000
 101d954:	21007c90 	.word	0x21007c90

0101d958 <radio_ccm_is_done>:
    p_reg->INTENSET = mask;
 101d958:	2302      	movs	r3, #2
 101d95a:	4a0e      	ldr	r2, [pc, #56]	; (101d994 <radio_ccm_is_done+0x3c>)
 101d95c:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304

uint32_t radio_ccm_is_done(void)
{
	nrf_ccm_int_enable(NRF_CCM, CCM_INTENSET_ENDCRYPT_Msk);
	while (NRF_CCM->EVENTS_ENDCRYPT == 0) {
 101d960:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 101d964:	b933      	cbnz	r3, 101d974 <radio_ccm_is_done+0x1c>
		__WFE();
 101d966:	bf20      	wfe
		__SEV();
 101d968:	bf40      	sev
		__WFE();
 101d96a:	bf20      	wfe
	while (NRF_CCM->EVENTS_ENDCRYPT == 0) {
 101d96c:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 101d970:	2b00      	cmp	r3, #0
 101d972:	d0f8      	beq.n	101d966 <radio_ccm_is_done+0xe>
    p_reg->INTENCLR = mask;
 101d974:	2002      	movs	r0, #2
 101d976:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 101d97a:	4b06      	ldr	r3, [pc, #24]	; (101d994 <radio_ccm_is_done+0x3c>)
 101d97c:	4a06      	ldr	r2, [pc, #24]	; (101d998 <radio_ccm_is_done+0x40>)
 101d97e:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
 101d982:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
	}
	nrf_ccm_int_disable(NRF_CCM, CCM_INTENCLR_ENDCRYPT_Msk);
	NVIC_ClearPendingIRQ(nrfx_get_irq_number(NRF_CCM));

	return (NRF_CCM->EVENTS_ERROR == 0);
 101d986:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
}
 101d98a:	fab0 f080 	clz	r0, r0
 101d98e:	0940      	lsrs	r0, r0, #5
 101d990:	4770      	bx	lr
 101d992:	bf00      	nop
 101d994:	4100e000 	.word	0x4100e000
 101d998:	e000e100 	.word	0xe000e100

0101d99c <radio_ccm_mic_is_valid>:

uint32_t radio_ccm_mic_is_valid(void)
{
	return (NRF_CCM->MICSTATUS != 0);
 101d99c:	4b03      	ldr	r3, [pc, #12]	; (101d9ac <radio_ccm_mic_is_valid+0x10>)
 101d99e:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
 101d9a2:	3800      	subs	r0, #0
 101d9a4:	bf18      	it	ne
 101d9a6:	2001      	movne	r0, #1
 101d9a8:	4770      	bx	lr
 101d9aa:	bf00      	nop
 101d9ac:	4100e000 	.word	0x4100e000

0101d9b0 <mayfly_enable_cb>:

void mayfly_enable_cb(uint8_t caller_id, uint8_t callee_id, uint8_t enable)
{
	(void)caller_id;

	switch (callee_id) {
 101d9b0:	3901      	subs	r1, #1
 101d9b2:	2901      	cmp	r1, #1
 101d9b4:	d805      	bhi.n	101d9c2 <mayfly_enable_cb+0x12>
	case MAYFLY_CALL_ID_WORKER:
		if (enable) {
			irq_enable(HAL_SWI_WORKER_IRQ);
 101d9b6:	2011      	movs	r0, #17
		if (enable) {
 101d9b8:	b10a      	cbz	r2, 101d9be <mayfly_enable_cb+0xe>
			irq_enable(HAL_SWI_WORKER_IRQ);
 101d9ba:	f7e8 ba15 	b.w	1005de8 <arch_irq_enable>
		} else {
			irq_disable(HAL_SWI_WORKER_IRQ);
 101d9be:	f7e8 ba21 	b.w	1005e04 <arch_irq_disable>
{
 101d9c2:	b508      	push	{r3, lr}
			irq_disable(HAL_SWI_JOB_IRQ);
		}
		break;

	default:
		LL_ASSERT(0);
 101d9c4:	4a06      	ldr	r2, [pc, #24]	; (101d9e0 <mayfly_enable_cb+0x30>)
 101d9c6:	232d      	movs	r3, #45	; 0x2d
 101d9c8:	4906      	ldr	r1, [pc, #24]	; (101d9e4 <mayfly_enable_cb+0x34>)
 101d9ca:	4807      	ldr	r0, [pc, #28]	; (101d9e8 <mayfly_enable_cb+0x38>)
 101d9cc:	f007 f903 	bl	1024bd6 <assert_print>
 101d9d0:	4040      	eors	r0, r0
 101d9d2:	f380 8811 	msr	BASEPRI, r0
 101d9d6:	f04f 0003 	mov.w	r0, #3
 101d9da:	df02      	svc	2
		break;
	}
}
 101d9dc:	bd08      	pop	{r3, pc}
 101d9de:	bf00      	nop
 101d9e0:	0102b244 	.word	0x0102b244
 101d9e4:	0102a300 	.word	0x0102a300
 101d9e8:	0102a278 	.word	0x0102a278

0101d9ec <mayfly_is_enabled>:

uint32_t mayfly_is_enabled(uint8_t caller_id, uint8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
 101d9ec:	b129      	cbz	r1, 101d9fa <mayfly_is_enabled+0xe>
 101d9ee:	3901      	subs	r1, #1
 101d9f0:	2901      	cmp	r1, #1
 101d9f2:	d805      	bhi.n	101da00 <mayfly_is_enabled+0x14>
	case MAYFLY_CALL_ID_LLL:
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);

	case MAYFLY_CALL_ID_WORKER:
		return irq_is_enabled(HAL_SWI_WORKER_IRQ);
 101d9f4:	2011      	movs	r0, #17
 101d9f6:	f7e8 ba19 	b.w	1005e2c <arch_irq_is_enabled>
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
 101d9fa:	201c      	movs	r0, #28
 101d9fc:	f7e8 ba16 	b.w	1005e2c <arch_irq_is_enabled>
{
 101da00:	b508      	push	{r3, lr}

	case MAYFLY_CALL_ID_JOB:
		return irq_is_enabled(HAL_SWI_JOB_IRQ);

	default:
		LL_ASSERT(0);
 101da02:	4a07      	ldr	r2, [pc, #28]	; (101da20 <mayfly_is_enabled+0x34>)
 101da04:	2341      	movs	r3, #65	; 0x41
 101da06:	4907      	ldr	r1, [pc, #28]	; (101da24 <mayfly_is_enabled+0x38>)
 101da08:	4807      	ldr	r0, [pc, #28]	; (101da28 <mayfly_is_enabled+0x3c>)
 101da0a:	f007 f8e4 	bl	1024bd6 <assert_print>
 101da0e:	4040      	eors	r0, r0
 101da10:	f380 8811 	msr	BASEPRI, r0
 101da14:	f04f 0003 	mov.w	r0, #3
 101da18:	df02      	svc	2
		break;
	}

	return 0;
}
 101da1a:	2000      	movs	r0, #0
 101da1c:	bd08      	pop	{r3, pc}
 101da1e:	bf00      	nop
 101da20:	0102b244 	.word	0x0102b244
 101da24:	0102a300 	.word	0x0102a300
 101da28:	0102a278 	.word	0x0102a278

0101da2c <mayfly_prio_is_equal>:
#endif
#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
		(callee_id == MAYFLY_CALL_ID_JOB)) ||
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
 101da2c:	4288      	cmp	r0, r1
 101da2e:	d00f      	beq.n	101da50 <mayfly_prio_is_equal+0x24>
	return (caller_id == callee_id) ||
 101da30:	2801      	cmp	r0, #1
 101da32:	d007      	beq.n	101da44 <mayfly_prio_is_equal+0x18>
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
 101da34:	2802      	cmp	r0, #2
 101da36:	d10d      	bne.n	101da54 <mayfly_prio_is_equal+0x28>
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
 101da38:	f1a1 0001 	sub.w	r0, r1, #1
 101da3c:	fab0 f080 	clz	r0, r0
 101da40:	0940      	lsrs	r0, r0, #5
 101da42:	4770      	bx	lr
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
 101da44:	f1a1 0002 	sub.w	r0, r1, #2
 101da48:	fab0 f080 	clz	r0, r0
 101da4c:	0940      	lsrs	r0, r0, #5
 101da4e:	4770      	bx	lr
 101da50:	2001      	movs	r0, #1
 101da52:	4770      	bx	lr
 101da54:	2000      	movs	r0, #0
#endif
	       0;
}
 101da56:	4770      	bx	lr

0101da58 <mayfly_pend>:

void mayfly_pend(uint8_t caller_id, uint8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
 101da58:	2901      	cmp	r1, #1
{
 101da5a:	b508      	push	{r3, lr}
	switch (callee_id) {
 101da5c:	d00f      	beq.n	101da7e <mayfly_pend+0x26>
 101da5e:	2902      	cmp	r1, #2
 101da60:	d00d      	beq.n	101da7e <mayfly_pend+0x26>
 101da62:	b191      	cbz	r1, 101da8a <mayfly_pend+0x32>
	case MAYFLY_CALL_ID_JOB:
		hal_swi_job_pend();
		break;

	default:
		LL_ASSERT(0);
 101da64:	2372      	movs	r3, #114	; 0x72
 101da66:	4a0c      	ldr	r2, [pc, #48]	; (101da98 <mayfly_pend+0x40>)
 101da68:	490c      	ldr	r1, [pc, #48]	; (101da9c <mayfly_pend+0x44>)
 101da6a:	480d      	ldr	r0, [pc, #52]	; (101daa0 <mayfly_pend+0x48>)
 101da6c:	f007 f8b3 	bl	1024bd6 <assert_print>
 101da70:	4040      	eors	r0, r0
 101da72:	f380 8811 	msr	BASEPRI, r0
 101da76:	f04f 0003 	mov.w	r0, #3
 101da7a:	df02      	svc	2
		break;
	}
}
 101da7c:	bd08      	pop	{r3, pc}
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 101da7e:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 101da82:	4b08      	ldr	r3, [pc, #32]	; (101daa4 <mayfly_pend+0x4c>)
 101da84:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 101da88:	bd08      	pop	{r3, pc}
 101da8a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 101da8e:	4b05      	ldr	r3, [pc, #20]	; (101daa4 <mayfly_pend+0x4c>)
 101da90:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 101da94:	bd08      	pop	{r3, pc}
 101da96:	bf00      	nop
 101da98:	0102b244 	.word	0x0102b244
 101da9c:	0102a300 	.word	0x0102a300
 101daa0:	0102a278 	.word	0x0102a278
 101daa4:	e000e100 	.word	0xe000e100

0101daa8 <mayfly_is_running>:

uint32_t mayfly_is_running(void)
{
 101daa8:	b508      	push	{r3, lr}
	return k_is_in_isr();
 101daaa:	f00b fbea 	bl	1029282 <k_is_in_isr>
}
 101daae:	bd08      	pop	{r3, pc}

0101dab0 <hal_ticker_instance0_caller_id_get>:

uint8_t hal_ticker_instance0_caller_id_get(uint8_t user_id)
{
	uint8_t caller_id;

	LL_ASSERT(user_id < sizeof(caller_id_lut));
 101dab0:	2803      	cmp	r0, #3
{
 101dab2:	b510      	push	{r4, lr}
 101dab4:	4604      	mov	r4, r0
	LL_ASSERT(user_id < sizeof(caller_id_lut));
 101dab6:	d804      	bhi.n	101dac2 <hal_ticker_instance0_caller_id_get+0x12>

	caller_id = caller_id_lut[user_id];
 101dab8:	4b11      	ldr	r3, [pc, #68]	; (101db00 <hal_ticker_instance0_caller_id_get+0x50>)
 101daba:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
 101dabc:	b18c      	cbz	r4, 101dae2 <hal_ticker_instance0_caller_id_get+0x32>

	return caller_id;
}
 101dabe:	4620      	mov	r0, r4
 101dac0:	bd10      	pop	{r4, pc}
	LL_ASSERT(user_id < sizeof(caller_id_lut));
 101dac2:	2328      	movs	r3, #40	; 0x28
 101dac4:	4a0f      	ldr	r2, [pc, #60]	; (101db04 <hal_ticker_instance0_caller_id_get+0x54>)
 101dac6:	4910      	ldr	r1, [pc, #64]	; (101db08 <hal_ticker_instance0_caller_id_get+0x58>)
 101dac8:	4810      	ldr	r0, [pc, #64]	; (101db0c <hal_ticker_instance0_caller_id_get+0x5c>)
 101daca:	f007 f884 	bl	1024bd6 <assert_print>
 101dace:	4040      	eors	r0, r0
 101dad0:	f380 8811 	msr	BASEPRI, r0
 101dad4:	f04f 0003 	mov.w	r0, #3
 101dad8:	df02      	svc	2
	caller_id = caller_id_lut[user_id];
 101dada:	4b09      	ldr	r3, [pc, #36]	; (101db00 <hal_ticker_instance0_caller_id_get+0x50>)
 101dadc:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
 101dade:	2c00      	cmp	r4, #0
 101dae0:	d1ed      	bne.n	101dabe <hal_ticker_instance0_caller_id_get+0xe>
 101dae2:	232b      	movs	r3, #43	; 0x2b
 101dae4:	4a07      	ldr	r2, [pc, #28]	; (101db04 <hal_ticker_instance0_caller_id_get+0x54>)
 101dae6:	490a      	ldr	r1, [pc, #40]	; (101db10 <hal_ticker_instance0_caller_id_get+0x60>)
 101dae8:	4808      	ldr	r0, [pc, #32]	; (101db0c <hal_ticker_instance0_caller_id_get+0x5c>)
 101daea:	f007 f874 	bl	1024bd6 <assert_print>
 101daee:	4040      	eors	r0, r0
 101daf0:	f380 8811 	msr	BASEPRI, r0
 101daf4:	f04f 0003 	mov.w	r0, #3
 101daf8:	df02      	svc	2
}
 101dafa:	4620      	mov	r0, r4
 101dafc:	bd10      	pop	{r4, pc}
 101dafe:	bf00      	nop
 101db00:	0102b314 	.word	0x0102b314
 101db04:	0102b294 	.word	0x0102b294
 101db08:	0102b2e4 	.word	0x0102b2e4
 101db0c:	0102a278 	.word	0x0102a278
 101db10:	0102b304 	.word	0x0102b304

0101db14 <hal_ticker_instance0_sched>:
{
	/* return value not checked as we allow multiple calls to schedule
	 * before being actually needing the work to complete before new
	 * schedule.
	 */
	switch (caller_id) {
 101db14:	3801      	subs	r0, #1
{
 101db16:	b510      	push	{r4, lr}
 101db18:	461c      	mov	r4, r3
	switch (caller_id) {
 101db1a:	2804      	cmp	r0, #4
 101db1c:	d855      	bhi.n	101dbca <hal_ticker_instance0_sched+0xb6>
 101db1e:	e8df f000 	tbb	[pc, r0]
 101db22:	1a12      	.short	0x1a12
 101db24:	1e16      	.short	0x1e16
 101db26:	03          	.byte	0x03
 101db27:	00          	.byte	0x00
			break;
		}
		break;

	case TICKER_CALL_ID_PROGRAM:
		switch (callee_id) {
 101db28:	2904      	cmp	r1, #4
 101db2a:	d01e      	beq.n	101db6a <hal_ticker_instance0_sched+0x56>
				       &m);
		}
		break;

		default:
			LL_ASSERT(0);
 101db2c:	23b7      	movs	r3, #183	; 0xb7
			break;
		}
		break;

	default:
		LL_ASSERT(0);
 101db2e:	4a28      	ldr	r2, [pc, #160]	; (101dbd0 <hal_ticker_instance0_sched+0xbc>)
 101db30:	4928      	ldr	r1, [pc, #160]	; (101dbd4 <hal_ticker_instance0_sched+0xc0>)
 101db32:	4829      	ldr	r0, [pc, #164]	; (101dbd8 <hal_ticker_instance0_sched+0xc4>)
 101db34:	f007 f84f 	bl	1024bd6 <assert_print>
 101db38:	4040      	eors	r0, r0
 101db3a:	f380 8811 	msr	BASEPRI, r0
 101db3e:	f04f 0003 	mov.w	r0, #3
 101db42:	df02      	svc	2
		break;
	}
}
 101db44:	bd10      	pop	{r4, pc}
		switch (callee_id) {
 101db46:	2904      	cmp	r1, #4
 101db48:	d01f      	beq.n	101db8a <hal_ticker_instance0_sched+0x76>
			LL_ASSERT(0);
 101db4a:	234b      	movs	r3, #75	; 0x4b
 101db4c:	e7ef      	b.n	101db2e <hal_ticker_instance0_sched+0x1a>
		switch (callee_id) {
 101db4e:	2904      	cmp	r1, #4
 101db50:	d013      	beq.n	101db7a <hal_ticker_instance0_sched+0x66>
			LL_ASSERT(0);
 101db52:	2379      	movs	r3, #121	; 0x79
 101db54:	e7eb      	b.n	101db2e <hal_ticker_instance0_sched+0x1a>
		switch (callee_id) {
 101db56:	2903      	cmp	r1, #3
 101db58:	d01f      	beq.n	101db9a <hal_ticker_instance0_sched+0x86>
			LL_ASSERT(0);
 101db5a:	2362      	movs	r3, #98	; 0x62
 101db5c:	e7e7      	b.n	101db2e <hal_ticker_instance0_sched+0x1a>
		switch (callee_id) {
 101db5e:	2903      	cmp	r1, #3
 101db60:	d02b      	beq.n	101dbba <hal_ticker_instance0_sched+0xa6>
 101db62:	2904      	cmp	r1, #4
 101db64:	d021      	beq.n	101dbaa <hal_ticker_instance0_sched+0x96>
			LL_ASSERT(0);
 101db66:	239f      	movs	r3, #159	; 0x9f
 101db68:	e7e1      	b.n	101db2e <hal_ticker_instance0_sched+0x1a>
			m.param = instance;
 101db6a:	4b1c      	ldr	r3, [pc, #112]	; (101dbdc <hal_ticker_instance0_sched+0xc8>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
 101db6c:	2102      	movs	r1, #2
			m.param = instance;
 101db6e:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
 101db70:	2003      	movs	r0, #3
}
 101db72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
 101db76:	f7f3 ba35 	b.w	1010fe4 <mayfly_enqueue>
			m.param = instance;
 101db7a:	4b19      	ldr	r3, [pc, #100]	; (101dbe0 <hal_ticker_instance0_sched+0xcc>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
 101db7c:	2102      	movs	r1, #2
			m.param = instance;
 101db7e:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
 101db80:	2001      	movs	r0, #1
}
 101db82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
 101db86:	f7f3 ba2d 	b.w	1010fe4 <mayfly_enqueue>
			m.param = instance;
 101db8a:	4b16      	ldr	r3, [pc, #88]	; (101dbe4 <hal_ticker_instance0_sched+0xd0>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
 101db8c:	2102      	movs	r1, #2
			m.param = instance;
 101db8e:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
 101db90:	2000      	movs	r0, #0
}
 101db92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
 101db96:	f7f3 ba25 	b.w	1010fe4 <mayfly_enqueue>
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
 101db9a:	2101      	movs	r1, #1
			m.param = instance;
 101db9c:	4b12      	ldr	r3, [pc, #72]	; (101dbe8 <hal_ticker_instance0_sched+0xd4>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
 101db9e:	4608      	mov	r0, r1
			m.param = instance;
 101dba0:	609c      	str	r4, [r3, #8]
}
 101dba2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
 101dba6:	f7f3 ba1d 	b.w	1010fe4 <mayfly_enqueue>
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 101dbaa:	2102      	movs	r1, #2
			m.param = instance;
 101dbac:	4b0f      	ldr	r3, [pc, #60]	; (101dbec <hal_ticker_instance0_sched+0xd8>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 101dbae:	4608      	mov	r0, r1
			m.param = instance;
 101dbb0:	609c      	str	r4, [r3, #8]
}
 101dbb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 101dbb6:	f7f3 ba15 	b.w	1010fe4 <mayfly_enqueue>
			m.param = instance;
 101dbba:	4b0d      	ldr	r3, [pc, #52]	; (101dbf0 <hal_ticker_instance0_sched+0xdc>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 101dbbc:	2101      	movs	r1, #1
			m.param = instance;
 101dbbe:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 101dbc0:	2002      	movs	r0, #2
}
 101dbc2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 101dbc6:	f7f3 ba0d 	b.w	1010fe4 <mayfly_enqueue>
		LL_ASSERT(0);
 101dbca:	23bd      	movs	r3, #189	; 0xbd
 101dbcc:	e7af      	b.n	101db2e <hal_ticker_instance0_sched+0x1a>
 101dbce:	bf00      	nop
 101dbd0:	0102b294 	.word	0x0102b294
 101dbd4:	0102a300 	.word	0x0102a300
 101dbd8:	0102a278 	.word	0x0102a278
 101dbdc:	210009d8 	.word	0x210009d8
 101dbe0:	21000a08 	.word	0x21000a08
 101dbe4:	21000a28 	.word	0x21000a28
 101dbe8:	21000a18 	.word	0x21000a18
 101dbec:	210009e8 	.word	0x210009e8
 101dbf0:	210009f8 	.word	0x210009f8

0101dbf4 <hal_ticker_instance0_trigger_set>:

void hal_ticker_instance0_trigger_set(uint32_t value)
{
 101dbf4:	4601      	mov	r1, r0
	cntr_cmp_set(0, value);
 101dbf6:	2000      	movs	r0, #0
 101dbf8:	f7ff ba36 	b.w	101d068 <cntr_cmp_set>

0101dbfc <hci_vendor_read_static_addr>:

#include <soc.h>

uint8_t hci_vendor_read_static_addr(struct bt_hci_vs_static_addr addrs[],
				 uint8_t size)
{
 101dbfc:	b508      	push	{r3, lr}
	/* only one supported */
	ARG_UNUSED(size);

	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
 101dbfe:	4b26      	ldr	r3, [pc, #152]	; (101dc98 <hci_vendor_read_static_addr+0x9c>)
{
 101dc00:	4684      	mov	ip, r0
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
 101dc02:	f8d3 22a4 	ldr.w	r2, [r3, #676]	; 0x2a4
 101dc06:	3201      	adds	r2, #1
 101dc08:	d03d      	beq.n	101dc86 <hci_vendor_read_static_addr+0x8a>
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
	     (NRF_FICR->DEVICEADDRTYPE & 0x01)) {
 101dc0a:	4a23      	ldr	r2, [pc, #140]	; (101dc98 <hci_vendor_read_static_addr+0x9c>)
 101dc0c:	f8d2 02a0 	ldr.w	r0, [r2, #672]	; 0x2a0
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
 101dc10:	f010 0001 	ands.w	r0, r0, #1
 101dc14:	d100      	bne.n	101dc18 <hci_vendor_read_static_addr+0x1c>

		return 1;
	}

	return 0;
}
 101dc16:	bd08      	pop	{r3, pc}
		sys_put_le32(NRF_FICR->DEVICEADDR[0], &addrs[0].bdaddr.val[0]);
 101dc18:	f8d2 32a4 	ldr.w	r3, [r2, #676]	; 0x2a4
	dst[0] = val;
 101dc1c:	f8cc 3000 	str.w	r3, [ip]
		sys_put_le16(NRF_FICR->DEVICEADDR[1], &addrs[0].bdaddr.val[4]);
 101dc20:	f8d2 12a8 	ldr.w	r1, [r2, #680]	; 0x2a8
	dst[1] = val >> 8;
 101dc24:	f3c1 2307 	ubfx	r3, r1, #8, #8
		BT_ADDR_SET_STATIC(&addrs[0].bdaddr);
 101dc28:	f063 033f 	orn	r3, r3, #63	; 0x3f
	dst[0] = val;
 101dc2c:	f88c 1004 	strb.w	r1, [ip, #4]
 101dc30:	f88c 3005 	strb.w	r3, [ip, #5]
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
 101dc34:	f8d2 3290 	ldr.w	r3, [r2, #656]	; 0x290
 101dc38:	3301      	adds	r3, #1
 101dc3a:	d01c      	beq.n	101dc76 <hci_vendor_read_static_addr+0x7a>
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
 101dc3c:	f8d2 3294 	ldr.w	r3, [r2, #660]	; 0x294
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
 101dc40:	3301      	adds	r3, #1
 101dc42:	d018      	beq.n	101dc76 <hci_vendor_read_static_addr+0x7a>
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
 101dc44:	f8d2 3298 	ldr.w	r3, [r2, #664]	; 0x298
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
 101dc48:	3301      	adds	r3, #1
 101dc4a:	d014      	beq.n	101dc76 <hci_vendor_read_static_addr+0x7a>
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
 101dc4c:	f8d2 329c 	ldr.w	r3, [r2, #668]	; 0x29c
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
 101dc50:	3301      	adds	r3, #1
 101dc52:	d010      	beq.n	101dc76 <hci_vendor_read_static_addr+0x7a>
			sys_put_le32(NRF_FICR->IR[0], &addrs[0].ir[0]);
 101dc54:	f8d2 3290 	ldr.w	r3, [r2, #656]	; 0x290
 101dc58:	f8cc 3006 	str.w	r3, [ip, #6]
			sys_put_le32(NRF_FICR->IR[1], &addrs[0].ir[4]);
 101dc5c:	f8d2 3294 	ldr.w	r3, [r2, #660]	; 0x294
 101dc60:	f8cc 300a 	str.w	r3, [ip, #10]
			sys_put_le32(NRF_FICR->IR[2], &addrs[0].ir[8]);
 101dc64:	f8d2 3298 	ldr.w	r3, [r2, #664]	; 0x298
 101dc68:	f8cc 300e 	str.w	r3, [ip, #14]
			sys_put_le32(NRF_FICR->IR[3], &addrs[0].ir[12]);
 101dc6c:	f8d2 329c 	ldr.w	r3, [r2, #668]	; 0x29c
 101dc70:	f8cc 3012 	str.w	r3, [ip, #18]
}
 101dc74:	e005      	b.n	101dc82 <hci_vendor_read_static_addr+0x86>
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
 101dc76:	2210      	movs	r2, #16
 101dc78:	2100      	movs	r1, #0
 101dc7a:	f10c 0006 	add.w	r0, ip, #6
 101dc7e:	f008 fe84 	bl	102698a <memset>
		return 1;
 101dc82:	2001      	movs	r0, #1
}
 101dc84:	bd08      	pop	{r3, pc}
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
 101dc86:	f64f 72ff 	movw	r2, #65535	; 0xffff
 101dc8a:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
 101dc8e:	b29b      	uxth	r3, r3
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
 101dc90:	4293      	cmp	r3, r2
 101dc92:	d1ba      	bne.n	101dc0a <hci_vendor_read_static_addr+0xe>
	return 0;
 101dc94:	2000      	movs	r0, #0
}
 101dc96:	bd08      	pop	{r3, pc}
 101dc98:	01ff0000 	.word	0x01ff0000

0101dc9c <hci_vendor_read_key_hierarchy_roots>:
{
	/* Mark IR as invalid.
	 * No public address is available, and static address IR should be read
	 * using Read Static Addresses command.
	 */
	(void)memset(ir, 0x00, 16);
 101dc9c:	2210      	movs	r2, #16
{
 101dc9e:	b510      	push	{r4, lr}
 101dca0:	460c      	mov	r4, r1
	(void)memset(ir, 0x00, 16);
 101dca2:	2100      	movs	r1, #0
 101dca4:	f008 fe71 	bl	102698a <memset>

	/* Fill in ER if present */
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
 101dca8:	4b12      	ldr	r3, [pc, #72]	; (101dcf4 <hci_vendor_read_key_hierarchy_roots+0x58>)
 101dcaa:	f8d3 2280 	ldr.w	r2, [r3, #640]	; 0x280
 101dcae:	3201      	adds	r2, #1
 101dcb0:	d018      	beq.n	101dce4 <hci_vendor_read_key_hierarchy_roots+0x48>
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
 101dcb2:	f8d3 2284 	ldr.w	r2, [r3, #644]	; 0x284
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
 101dcb6:	3201      	adds	r2, #1
 101dcb8:	d014      	beq.n	101dce4 <hci_vendor_read_key_hierarchy_roots+0x48>
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
 101dcba:	f8d3 2288 	ldr.w	r2, [r3, #648]	; 0x288
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
 101dcbe:	3201      	adds	r2, #1
 101dcc0:	d010      	beq.n	101dce4 <hci_vendor_read_key_hierarchy_roots+0x48>
	    (NRF_FICR->ER[3] != UINT32_MAX)) {
 101dcc2:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
 101dcc6:	3201      	adds	r2, #1
 101dcc8:	d00c      	beq.n	101dce4 <hci_vendor_read_key_hierarchy_roots+0x48>
		sys_put_le32(NRF_FICR->ER[0], &er[0]);
 101dcca:	f8d3 2280 	ldr.w	r2, [r3, #640]	; 0x280
	dst[0] = val;
 101dcce:	6022      	str	r2, [r4, #0]
		sys_put_le32(NRF_FICR->ER[1], &er[4]);
 101dcd0:	f8d3 2284 	ldr.w	r2, [r3, #644]	; 0x284
 101dcd4:	6062      	str	r2, [r4, #4]
		sys_put_le32(NRF_FICR->ER[2], &er[8]);
 101dcd6:	f8d3 2288 	ldr.w	r2, [r3, #648]	; 0x288
 101dcda:	60a2      	str	r2, [r4, #8]
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
 101dcdc:	f8d3 328c 	ldr.w	r3, [r3, #652]	; 0x28c
 101dce0:	60e3      	str	r3, [r4, #12]
	} else {
		/* Mark ER as invalid */
		(void)memset(er, 0x00, 16);
	}
}
 101dce2:	bd10      	pop	{r4, pc}
		(void)memset(er, 0x00, 16);
 101dce4:	4620      	mov	r0, r4
}
 101dce6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		(void)memset(er, 0x00, 16);
 101dcea:	2210      	movs	r2, #16
 101dcec:	2100      	movs	r1, #0
 101dcee:	f008 be4c 	b.w	102698a <memset>
 101dcf2:	bf00      	nop
 101dcf4:	01ff0000 	.word	0x01ff0000

0101dcf8 <net_buf_pool_get>:
extern struct net_buf_pool _net_buf_pool_list[];

struct net_buf_pool *net_buf_pool_get(int id)
{
	return &_net_buf_pool_list[id];
}
 101dcf8:	2234      	movs	r2, #52	; 0x34
 101dcfa:	4b02      	ldr	r3, [pc, #8]	; (101dd04 <net_buf_pool_get+0xc>)
 101dcfc:	fb02 3000 	mla	r0, r2, r0, r3
 101dd00:	4770      	bx	lr
 101dd02:	bf00      	nop
 101dd04:	21000d7c 	.word	0x21000d7c

0101dd08 <net_buf_id>:
int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
				__alignof__(struct net_buf));
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
 101dd08:	2134      	movs	r1, #52	; 0x34
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 101dd0a:	7a82      	ldrb	r2, [r0, #10]
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
 101dd0c:	4b06      	ldr	r3, [pc, #24]	; (101dd28 <net_buf_id+0x20>)
 101dd0e:	fb01 3302 	mla	r3, r1, r2, r3
 101dd12:	6b1a      	ldr	r2, [r3, #48]	; 0x30
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
 101dd14:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
 101dd18:	1a80      	subs	r0, r0, r2
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
 101dd1a:	331b      	adds	r3, #27
 101dd1c:	f023 0303 	bic.w	r3, r3, #3

	return offset / struct_size;
}
 101dd20:	fbb0 f0f3 	udiv	r0, r0, r3
 101dd24:	4770      	bx	lr
 101dd26:	bf00      	nop
 101dd28:	21000d7c 	.word	0x21000d7c

0101dd2c <fixed_data_alloc>:
	.unref = mem_pool_data_unref,
};

static uint8_t *fixed_data_alloc(struct net_buf *buf, size_t *size,
			      k_timeout_t timeout)
{
 101dd2c:	b538      	push	{r3, r4, r5, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 101dd2e:	2434      	movs	r4, #52	; 0x34
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 101dd30:	7a82      	ldrb	r2, [r0, #10]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 101dd32:	4b09      	ldr	r3, [pc, #36]	; (101dd58 <fixed_data_alloc+0x2c>)
 101dd34:	fb04 3302 	mla	r3, r4, r2, r3
 101dd38:	6adb      	ldr	r3, [r3, #44]	; 0x2c

	*size = MIN(fixed->data_size, *size);
 101dd3a:	680c      	ldr	r4, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 101dd3c:	685b      	ldr	r3, [r3, #4]
	*size = MIN(fixed->data_size, *size);
 101dd3e:	681a      	ldr	r2, [r3, #0]
 101dd40:	4294      	cmp	r4, r2
 101dd42:	bf94      	ite	ls
 101dd44:	600c      	strls	r4, [r1, #0]
 101dd46:	600a      	strhi	r2, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
 101dd48:	e9d3 5400 	ldrd	r5, r4, [r3]
 101dd4c:	f7ff ffdc 	bl	101dd08 <net_buf_id>
}
 101dd50:	fb05 4000 	mla	r0, r5, r0, r4
 101dd54:	bd38      	pop	{r3, r4, r5, pc}
 101dd56:	bf00      	nop
 101dd58:	21000d7c 	.word	0x21000d7c

0101dd5c <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
 101dd5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 101dd60:	b085      	sub	sp, #20
 101dd62:	9103      	str	r1, [sp, #12]
 101dd64:	4605      	mov	r5, r0
	uint64_t end = sys_clock_timeout_end_calc(timeout);
 101dd66:	4619      	mov	r1, r3
 101dd68:	4610      	mov	r0, r2
{
 101dd6a:	4692      	mov	sl, r2
 101dd6c:	4699      	mov	r9, r3
 101dd6e:	4690      	mov	r8, r2
 101dd70:	461f      	mov	r7, r3
	uint64_t end = sys_clock_timeout_end_calc(timeout);
 101dd72:	f00b fb7f 	bl	1029474 <sys_clock_timeout_end_calc>
 101dd76:	e9cd 0101 	strd	r0, r1, [sp, #4]
	struct net_buf *buf;
	k_spinlock_key_t key;

	__ASSERT_NO_MSG(pool);
 101dd7a:	b945      	cbnz	r5, 101dd8e <net_buf_alloc_len+0x32>
 101dd7c:	4966      	ldr	r1, [pc, #408]	; (101df18 <net_buf_alloc_len+0x1bc>)
 101dd7e:	23f4      	movs	r3, #244	; 0xf4
 101dd80:	4a66      	ldr	r2, [pc, #408]	; (101df1c <net_buf_alloc_len+0x1c0>)
 101dd82:	4867      	ldr	r0, [pc, #412]	; (101df20 <net_buf_alloc_len+0x1c4>)
 101dd84:	f006 ff27 	bl	1024bd6 <assert_print>
 101dd88:	21f4      	movs	r1, #244	; 0xf4
			net_buf_destroy(buf);
			return NULL;
		}

#if __ASSERT_ON
		NET_BUF_ASSERT(req_size <= size);
 101dd8a:	4864      	ldr	r0, [pc, #400]	; (101df1c <net_buf_alloc_len+0x1c0>)
 101dd8c:	e019      	b.n	101ddc2 <net_buf_alloc_len+0x66>
	key = k_spin_lock(&pool->lock);
 101dd8e:	f105 061c 	add.w	r6, r5, #28
	__asm__ volatile(
 101dd92:	f04f 0320 	mov.w	r3, #32
 101dd96:	f3ef 8b11 	mrs	fp, BASEPRI
 101dd9a:	f383 8812 	msr	BASEPRI_MAX, r3
 101dd9e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 101dda2:	4630      	mov	r0, r6
 101dda4:	f003 f994 	bl	10210d0 <z_spin_lock_valid>
 101dda8:	b968      	cbnz	r0, 101ddc6 <net_buf_alloc_len+0x6a>
 101ddaa:	2394      	movs	r3, #148	; 0x94
 101ddac:	4a5d      	ldr	r2, [pc, #372]	; (101df24 <net_buf_alloc_len+0x1c8>)
 101ddae:	495e      	ldr	r1, [pc, #376]	; (101df28 <net_buf_alloc_len+0x1cc>)
 101ddb0:	485b      	ldr	r0, [pc, #364]	; (101df20 <net_buf_alloc_len+0x1c4>)
 101ddb2:	f006 ff10 	bl	1024bd6 <assert_print>
 101ddb6:	4631      	mov	r1, r6
 101ddb8:	485c      	ldr	r0, [pc, #368]	; (101df2c <net_buf_alloc_len+0x1d0>)
 101ddba:	f006 ff0c 	bl	1024bd6 <assert_print>
 101ddbe:	2194      	movs	r1, #148	; 0x94
 101ddc0:	4858      	ldr	r0, [pc, #352]	; (101df24 <net_buf_alloc_len+0x1c8>)
 101ddc2:	f006 ff01 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 101ddc6:	4630      	mov	r0, r6
 101ddc8:	f003 f99e 	bl	1021108 <z_spin_lock_set_owner>
	if (pool->uninit_count) {
 101ddcc:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
 101ddce:	2b00      	cmp	r3, #0
 101ddd0:	d070      	beq.n	101deb4 <net_buf_alloc_len+0x158>
		if (pool->uninit_count < pool->buf_count) {
 101ddd2:	8c2a      	ldrh	r2, [r5, #32]
 101ddd4:	429a      	cmp	r2, r3
 101ddd6:	d94d      	bls.n	101de74 <net_buf_alloc_len+0x118>
	return z_impl_k_queue_get(queue, timeout);
 101ddd8:	2200      	movs	r2, #0
 101ddda:	2300      	movs	r3, #0
 101dddc:	4628      	mov	r0, r5
 101ddde:	f003 fbf5 	bl	10215cc <z_impl_k_queue_get>
			if (buf) {
 101dde2:	4604      	mov	r4, r0
 101dde4:	2800      	cmp	r0, #0
 101dde6:	d045      	beq.n	101de74 <net_buf_alloc_len+0x118>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 101dde8:	4630      	mov	r0, r6
 101ddea:	f003 f97f 	bl	10210ec <z_spin_unlock_valid>
 101ddee:	b958      	cbnz	r0, 101de08 <net_buf_alloc_len+0xac>
 101ddf0:	23c2      	movs	r3, #194	; 0xc2
 101ddf2:	4a4c      	ldr	r2, [pc, #304]	; (101df24 <net_buf_alloc_len+0x1c8>)
 101ddf4:	494e      	ldr	r1, [pc, #312]	; (101df30 <net_buf_alloc_len+0x1d4>)
 101ddf6:	484a      	ldr	r0, [pc, #296]	; (101df20 <net_buf_alloc_len+0x1c4>)
 101ddf8:	f006 feed 	bl	1024bd6 <assert_print>
 101ddfc:	4631      	mov	r1, r6
 101ddfe:	484d      	ldr	r0, [pc, #308]	; (101df34 <net_buf_alloc_len+0x1d8>)
 101de00:	f006 fee9 	bl	1024bd6 <assert_print>
 101de04:	21c2      	movs	r1, #194	; 0xc2
 101de06:	e7db      	b.n	101ddc0 <net_buf_alloc_len+0x64>
	__asm__ volatile(
 101de08:	f38b 8811 	msr	BASEPRI, fp
 101de0c:	f3bf 8f6f 	isb	sy
	if (size) {
 101de10:	9d03      	ldr	r5, [sp, #12]
 101de12:	2d00      	cmp	r5, #0
 101de14:	d074      	beq.n	101df00 <net_buf_alloc_len+0x1a4>
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
 101de16:	ea59 030a 	orrs.w	r3, r9, sl
 101de1a:	d012      	beq.n	101de42 <net_buf_alloc_len+0xe6>
 101de1c:	f1b9 3fff 	cmp.w	r9, #4294967295
 101de20:	bf08      	it	eq
 101de22:	f1ba 3fff 	cmpeq.w	sl, #4294967295
 101de26:	d00c      	beq.n	101de42 <net_buf_alloc_len+0xe6>
			int64_t remaining = end - sys_clock_tick_get();
 101de28:	f005 febc 	bl	1023ba4 <sys_clock_tick_get>
 101de2c:	9b01      	ldr	r3, [sp, #4]
 101de2e:	ebb3 0800 	subs.w	r8, r3, r0
 101de32:	9b02      	ldr	r3, [sp, #8]
 101de34:	eb63 0701 	sbc.w	r7, r3, r1
			if (remaining <= 0) {
 101de38:	2f00      	cmp	r7, #0
 101de3a:	bfbc      	itt	lt
 101de3c:	f04f 0800 	movlt.w	r8, #0
 101de40:	4647      	movlt	r7, r8
	return pool->alloc->cb->alloc(buf, size, timeout);
 101de42:	f04f 0934 	mov.w	r9, #52	; 0x34
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 101de46:	7aa3      	ldrb	r3, [r4, #10]
	return pool->alloc->cb->alloc(buf, size, timeout);
 101de48:	4e3b      	ldr	r6, [pc, #236]	; (101df38 <net_buf_alloc_len+0x1dc>)
 101de4a:	4642      	mov	r2, r8
 101de4c:	fb09 6303 	mla	r3, r9, r3, r6
 101de50:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 101de52:	4620      	mov	r0, r4
 101de54:	681b      	ldr	r3, [r3, #0]
 101de56:	a903      	add	r1, sp, #12
 101de58:	f8d3 a000 	ldr.w	sl, [r3]
 101de5c:	463b      	mov	r3, r7
 101de5e:	47d0      	blx	sl
		buf->__buf = data_alloc(buf, &size, timeout);
 101de60:	6160      	str	r0, [r4, #20]
		if (!buf->__buf) {
 101de62:	2800      	cmp	r0, #0
 101de64:	d13c      	bne.n	101dee0 <net_buf_alloc_len+0x184>
	k_lifo_put(&pool->free, buf);
 101de66:	7aa0      	ldrb	r0, [r4, #10]
 101de68:	4621      	mov	r1, r4
 101de6a:	fb09 6000 	mla	r0, r9, r0, r6
 101de6e:	f00b fa48 	bl	1029302 <k_queue_prepend>
}
 101de72:	e030      	b.n	101ded6 <net_buf_alloc_len+0x17a>
		uninit_count = pool->uninit_count--;
 101de74:	8c6c      	ldrh	r4, [r5, #34]	; 0x22
 101de76:	4630      	mov	r0, r6
 101de78:	1e63      	subs	r3, r4, #1
 101de7a:	846b      	strh	r3, [r5, #34]	; 0x22
 101de7c:	f003 f936 	bl	10210ec <z_spin_unlock_valid>
 101de80:	2800      	cmp	r0, #0
 101de82:	d0b5      	beq.n	101ddf0 <net_buf_alloc_len+0x94>
 101de84:	f38b 8811 	msr	BASEPRI, fp
 101de88:	f3bf 8f6f 	isb	sy
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
 101de8c:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
 101de90:	8c2a      	ldrh	r2, [r5, #32]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
 101de92:	331b      	adds	r3, #27
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
 101de94:	1b12      	subs	r2, r2, r4
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
 101de96:	6b2c      	ldr	r4, [r5, #48]	; 0x30
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
 101de98:	f023 0303 	bic.w	r3, r3, #3
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
 101de9c:	fb02 4403 	mla	r4, r2, r3, r4
	return pool - _net_buf_pool_list;
 101dea0:	4b25      	ldr	r3, [pc, #148]	; (101df38 <net_buf_alloc_len+0x1dc>)
 101dea2:	4a26      	ldr	r2, [pc, #152]	; (101df3c <net_buf_alloc_len+0x1e0>)
 101dea4:	1aeb      	subs	r3, r5, r3
 101dea6:	109b      	asrs	r3, r3, #2
 101dea8:	4353      	muls	r3, r2
	buf->pool_id = pool_id(pool);
 101deaa:	72a3      	strb	r3, [r4, #10]
	buf->user_data_size = pool->user_data_size;
 101deac:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
 101deb0:	72e3      	strb	r3, [r4, #11]
		goto success;
 101deb2:	e7ad      	b.n	101de10 <net_buf_alloc_len+0xb4>
 101deb4:	4630      	mov	r0, r6
 101deb6:	f003 f919 	bl	10210ec <z_spin_unlock_valid>
 101deba:	2800      	cmp	r0, #0
 101debc:	d098      	beq.n	101ddf0 <net_buf_alloc_len+0x94>
 101debe:	f38b 8811 	msr	BASEPRI, fp
 101dec2:	f3bf 8f6f 	isb	sy
 101dec6:	4652      	mov	r2, sl
 101dec8:	464b      	mov	r3, r9
 101deca:	4628      	mov	r0, r5
 101decc:	f003 fb7e 	bl	10215cc <z_impl_k_queue_get>
	if (!buf) {
 101ded0:	4604      	mov	r4, r0
 101ded2:	2800      	cmp	r0, #0
 101ded4:	d19c      	bne.n	101de10 <net_buf_alloc_len+0xb4>
		return NULL;
 101ded6:	2400      	movs	r4, #0
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
 101ded8:	4620      	mov	r0, r4
 101deda:	b005      	add	sp, #20
 101dedc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		NET_BUF_ASSERT(req_size <= size);
 101dee0:	9b03      	ldr	r3, [sp, #12]
 101dee2:	429d      	cmp	r5, r3
 101dee4:	d90d      	bls.n	101df02 <net_buf_alloc_len+0x1a6>
 101dee6:	4916      	ldr	r1, [pc, #88]	; (101df40 <net_buf_alloc_len+0x1e4>)
 101dee8:	f240 1355 	movw	r3, #341	; 0x155
 101deec:	4a0b      	ldr	r2, [pc, #44]	; (101df1c <net_buf_alloc_len+0x1c0>)
 101deee:	480c      	ldr	r0, [pc, #48]	; (101df20 <net_buf_alloc_len+0x1c4>)
 101def0:	f006 fe71 	bl	1024bd6 <assert_print>
 101def4:	4813      	ldr	r0, [pc, #76]	; (101df44 <net_buf_alloc_len+0x1e8>)
 101def6:	f006 fe6e 	bl	1024bd6 <assert_print>
 101defa:	f240 1155 	movw	r1, #341	; 0x155
 101defe:	e744      	b.n	101dd8a <net_buf_alloc_len+0x2e>
		buf->__buf = NULL;
 101df00:	6165      	str	r5, [r4, #20]
	buf->frags = NULL;
 101df02:	2300      	movs	r3, #0
	buf->ref   = 1U;
 101df04:	2201      	movs	r2, #1
	buf->frags = NULL;
 101df06:	6063      	str	r3, [r4, #4]
	buf->ref   = 1U;
 101df08:	8122      	strh	r2, [r4, #8]
	buf->len  = 0U;
 101df0a:	8223      	strh	r3, [r4, #16]
	buf->size  = size;
 101df0c:	9a03      	ldr	r2, [sp, #12]
	buf->data = buf->__buf;
 101df0e:	6963      	ldr	r3, [r4, #20]
 101df10:	8262      	strh	r2, [r4, #18]
 101df12:	60e3      	str	r3, [r4, #12]
}
 101df14:	e7e0      	b.n	101ded8 <net_buf_alloc_len+0x17c>
 101df16:	bf00      	nop
 101df18:	0102ee6e 	.word	0x0102ee6e
 101df1c:	0102ee1f 	.word	0x0102ee1f
 101df20:	0102b695 	.word	0x0102b695
 101df24:	0102bd8a 	.word	0x0102bd8a
 101df28:	0102bde3 	.word	0x0102bde3
 101df2c:	0102bdf8 	.word	0x0102bdf8
 101df30:	0102bdb7 	.word	0x0102bdb7
 101df34:	0102bdce 	.word	0x0102bdce
 101df38:	21000d7c 	.word	0x21000d7c
 101df3c:	c4ec4ec5 	.word	0xc4ec4ec5
 101df40:	0102ee73 	.word	0x0102ee73
 101df44:	0102ee84 	.word	0x0102ee84

0101df48 <net_buf_simple_reserve>:
	buf->size  = size;
	buf->len   = size;
}

void net_buf_simple_reserve(struct net_buf_simple *buf, size_t reserve)
{
 101df48:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(buf);
 101df4a:	b958      	cbnz	r0, 101df64 <net_buf_simple_reserve+0x1c>
 101df4c:	490d      	ldr	r1, [pc, #52]	; (101df84 <net_buf_simple_reserve+0x3c>)
 101df4e:	f44f 73dc 	mov.w	r3, #440	; 0x1b8
 101df52:	4a0d      	ldr	r2, [pc, #52]	; (101df88 <net_buf_simple_reserve+0x40>)
 101df54:	480d      	ldr	r0, [pc, #52]	; (101df8c <net_buf_simple_reserve+0x44>)
 101df56:	f006 fe3e 	bl	1024bd6 <assert_print>
 101df5a:	f44f 71dc 	mov.w	r1, #440	; 0x1b8
	__ASSERT_NO_MSG(buf->len == 0U);
 101df5e:	480a      	ldr	r0, [pc, #40]	; (101df88 <net_buf_simple_reserve+0x40>)
 101df60:	f006 fe32 	bl	1024bc8 <assert_post_action>
 101df64:	8883      	ldrh	r3, [r0, #4]
 101df66:	b14b      	cbz	r3, 101df7c <net_buf_simple_reserve+0x34>
 101df68:	4909      	ldr	r1, [pc, #36]	; (101df90 <net_buf_simple_reserve+0x48>)
 101df6a:	f240 13b9 	movw	r3, #441	; 0x1b9
 101df6e:	4a06      	ldr	r2, [pc, #24]	; (101df88 <net_buf_simple_reserve+0x40>)
 101df70:	4806      	ldr	r0, [pc, #24]	; (101df8c <net_buf_simple_reserve+0x44>)
 101df72:	f006 fe30 	bl	1024bd6 <assert_print>
 101df76:	f240 11b9 	movw	r1, #441	; 0x1b9
 101df7a:	e7f0      	b.n	101df5e <net_buf_simple_reserve+0x16>
	NET_BUF_DBG("buf %p reserve %zu", buf, reserve);

	buf->data = buf->__buf + reserve;
 101df7c:	6883      	ldr	r3, [r0, #8]
 101df7e:	440b      	add	r3, r1
 101df80:	6003      	str	r3, [r0, #0]
}
 101df82:	bd08      	pop	{r3, pc}
 101df84:	0102ef22 	.word	0x0102ef22
 101df88:	0102ee1f 	.word	0x0102ee1f
 101df8c:	0102b695 	.word	0x0102b695
 101df90:	0102ee87 	.word	0x0102ee87

0101df94 <net_buf_put>:

	return buf;
}

void net_buf_put(struct k_fifo *fifo, struct net_buf *buf)
{
 101df94:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(fifo);
 101df96:	b958      	cbnz	r0, 101dfb0 <net_buf_put+0x1c>
 101df98:	490d      	ldr	r1, [pc, #52]	; (101dfd0 <net_buf_put+0x3c>)
 101df9a:	f240 13df 	movw	r3, #479	; 0x1df
 101df9e:	4a0d      	ldr	r2, [pc, #52]	; (101dfd4 <net_buf_put+0x40>)
 101dfa0:	480d      	ldr	r0, [pc, #52]	; (101dfd8 <net_buf_put+0x44>)
 101dfa2:	f006 fe18 	bl	1024bd6 <assert_print>
 101dfa6:	f240 11df 	movw	r1, #479	; 0x1df
	__ASSERT_NO_MSG(buf);
 101dfaa:	480a      	ldr	r0, [pc, #40]	; (101dfd4 <net_buf_put+0x40>)
 101dfac:	f006 fe0c 	bl	1024bc8 <assert_post_action>
 101dfb0:	b949      	cbnz	r1, 101dfc6 <net_buf_put+0x32>
 101dfb2:	490a      	ldr	r1, [pc, #40]	; (101dfdc <net_buf_put+0x48>)
 101dfb4:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 101dfb8:	4a06      	ldr	r2, [pc, #24]	; (101dfd4 <net_buf_put+0x40>)
 101dfba:	4807      	ldr	r0, [pc, #28]	; (101dfd8 <net_buf_put+0x44>)
 101dfbc:	f006 fe0b 	bl	1024bd6 <assert_print>
 101dfc0:	f44f 71f0 	mov.w	r1, #480	; 0x1e0
 101dfc4:	e7f1      	b.n	101dfaa <net_buf_put+0x16>

	k_fifo_put(fifo, buf);
}
 101dfc6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	k_fifo_put(fifo, buf);
 101dfca:	f00b b98f 	b.w	10292ec <k_queue_append>
 101dfce:	bf00      	nop
 101dfd0:	0102ee96 	.word	0x0102ee96
 101dfd4:	0102ee1f 	.word	0x0102ee1f
 101dfd8:	0102b695 	.word	0x0102b695
 101dfdc:	0102ef22 	.word	0x0102ef22

0101dfe0 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
 101dfe0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(buf);
 101dfe4:	4605      	mov	r5, r0
 101dfe6:	b328      	cbz	r0, 101e034 <net_buf_unref+0x54>
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
 101dfe8:	2600      	movs	r6, #0
	pool->alloc->cb->unref(buf, data);
 101dfea:	f04f 0834 	mov.w	r8, #52	; 0x34
 101dfee:	4f19      	ldr	r7, [pc, #100]	; (101e054 <net_buf_unref+0x74>)
		struct net_buf *frags = buf->frags;
 101dff0:	462c      	mov	r4, r5
		if (--buf->ref > 0) {
 101dff2:	7a23      	ldrb	r3, [r4, #8]
		struct net_buf *frags = buf->frags;
 101dff4:	686d      	ldr	r5, [r5, #4]
		if (--buf->ref > 0) {
 101dff6:	3b01      	subs	r3, #1
 101dff8:	b2db      	uxtb	r3, r3
 101dffa:	7223      	strb	r3, [r4, #8]
 101dffc:	b9c3      	cbnz	r3, 101e030 <net_buf_unref+0x50>
		if (buf->__buf) {
 101dffe:	6961      	ldr	r1, [r4, #20]
 101e000:	b159      	cbz	r1, 101e01a <net_buf_unref+0x3a>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
 101e002:	7a63      	ldrb	r3, [r4, #9]
 101e004:	07db      	lsls	r3, r3, #31
 101e006:	d407      	bmi.n	101e018 <net_buf_unref+0x38>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 101e008:	7aa3      	ldrb	r3, [r4, #10]
	pool->alloc->cb->unref(buf, data);
 101e00a:	4620      	mov	r0, r4
 101e00c:	fb08 7303 	mla	r3, r8, r3, r7
 101e010:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 101e012:	681b      	ldr	r3, [r3, #0]
 101e014:	689b      	ldr	r3, [r3, #8]
 101e016:	4798      	blx	r3
			buf->__buf = NULL;
 101e018:	6166      	str	r6, [r4, #20]
		}

		buf->data = NULL;
		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
 101e01a:	7aa0      	ldrb	r0, [r4, #10]
		buf->data = NULL;
 101e01c:	60e6      	str	r6, [r4, #12]
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		atomic_inc(&pool->avail_count);
		__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);
#endif

		if (pool->destroy) {
 101e01e:	fb08 7000 	mla	r0, r8, r0, r7
		buf->frags = NULL;
 101e022:	6066      	str	r6, [r4, #4]
		if (pool->destroy) {
 101e024:	6a83      	ldr	r3, [r0, #40]	; 0x28
 101e026:	b18b      	cbz	r3, 101e04c <net_buf_unref+0x6c>
			pool->destroy(buf);
 101e028:	4620      	mov	r0, r4
 101e02a:	4798      	blx	r3
	while (buf) {
 101e02c:	2d00      	cmp	r5, #0
 101e02e:	d1df      	bne.n	101dff0 <net_buf_unref+0x10>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
 101e030:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT_NO_MSG(buf);
 101e034:	4908      	ldr	r1, [pc, #32]	; (101e058 <net_buf_unref+0x78>)
 101e036:	4809      	ldr	r0, [pc, #36]	; (101e05c <net_buf_unref+0x7c>)
 101e038:	f240 13eb 	movw	r3, #491	; 0x1eb
 101e03c:	4a08      	ldr	r2, [pc, #32]	; (101e060 <net_buf_unref+0x80>)
 101e03e:	f006 fdca 	bl	1024bd6 <assert_print>
 101e042:	f240 11eb 	movw	r1, #491	; 0x1eb
 101e046:	4806      	ldr	r0, [pc, #24]	; (101e060 <net_buf_unref+0x80>)
 101e048:	f006 fdbe 	bl	1024bc8 <assert_post_action>
	k_lifo_put(&pool->free, buf);
 101e04c:	4621      	mov	r1, r4
 101e04e:	f00b f958 	bl	1029302 <k_queue_prepend>
}
 101e052:	e7eb      	b.n	101e02c <net_buf_unref+0x4c>
 101e054:	21000d7c 	.word	0x21000d7c
 101e058:	0102ef22 	.word	0x0102ef22
 101e05c:	0102b695 	.word	0x0102b695
 101e060:	0102ee1f 	.word	0x0102ee1f

0101e064 <net_buf_ref>:

struct net_buf *net_buf_ref(struct net_buf *buf)
{
 101e064:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(buf);
 101e066:	b958      	cbnz	r0, 101e080 <net_buf_ref+0x1c>
 101e068:	4907      	ldr	r1, [pc, #28]	; (101e088 <net_buf_ref+0x24>)
 101e06a:	4808      	ldr	r0, [pc, #32]	; (101e08c <net_buf_ref+0x28>)
 101e06c:	f240 231a 	movw	r3, #538	; 0x21a
 101e070:	4a07      	ldr	r2, [pc, #28]	; (101e090 <net_buf_ref+0x2c>)
 101e072:	f006 fdb0 	bl	1024bd6 <assert_print>
 101e076:	f240 211a 	movw	r1, #538	; 0x21a
 101e07a:	4805      	ldr	r0, [pc, #20]	; (101e090 <net_buf_ref+0x2c>)
 101e07c:	f006 fda4 	bl	1024bc8 <assert_post_action>

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
 101e080:	7a02      	ldrb	r2, [r0, #8]
 101e082:	3201      	adds	r2, #1
 101e084:	7202      	strb	r2, [r0, #8]
	return buf;
}
 101e086:	bd08      	pop	{r3, pc}
 101e088:	0102ef22 	.word	0x0102ef22
 101e08c:	0102b695 	.word	0x0102b695
 101e090:	0102ee1f 	.word	0x0102ee1f

0101e094 <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
 101e094:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(buf);
 101e096:	4603      	mov	r3, r0
 101e098:	b958      	cbnz	r0, 101e0b2 <net_buf_frag_last+0x1e>
 101e09a:	4908      	ldr	r1, [pc, #32]	; (101e0bc <net_buf_frag_last+0x28>)
 101e09c:	4808      	ldr	r0, [pc, #32]	; (101e0c0 <net_buf_frag_last+0x2c>)
 101e09e:	f240 2357 	movw	r3, #599	; 0x257
 101e0a2:	4a08      	ldr	r2, [pc, #32]	; (101e0c4 <net_buf_frag_last+0x30>)
 101e0a4:	f006 fd97 	bl	1024bd6 <assert_print>
 101e0a8:	f240 2157 	movw	r1, #599	; 0x257
 101e0ac:	4805      	ldr	r0, [pc, #20]	; (101e0c4 <net_buf_frag_last+0x30>)
 101e0ae:	f006 fd8b 	bl	1024bc8 <assert_post_action>

	while (buf->frags) {
 101e0b2:	4618      	mov	r0, r3
 101e0b4:	685b      	ldr	r3, [r3, #4]
 101e0b6:	2b00      	cmp	r3, #0
 101e0b8:	d1fb      	bne.n	101e0b2 <net_buf_frag_last+0x1e>
		buf = buf->frags;
	}

	return buf;
}
 101e0ba:	bd08      	pop	{r3, pc}
 101e0bc:	0102ef22 	.word	0x0102ef22
 101e0c0:	0102b695 	.word	0x0102b695
 101e0c4:	0102ee1f 	.word	0x0102ee1f

0101e0c8 <net_buf_frag_insert>:

void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
 101e0c8:	b570      	push	{r4, r5, r6, lr}
 101e0ca:	460d      	mov	r5, r1
	__ASSERT_NO_MSG(parent);
 101e0cc:	4604      	mov	r4, r0
 101e0ce:	b958      	cbnz	r0, 101e0e8 <net_buf_frag_insert+0x20>
 101e0d0:	490f      	ldr	r1, [pc, #60]	; (101e110 <net_buf_frag_insert+0x48>)
 101e0d2:	f240 2362 	movw	r3, #610	; 0x262
 101e0d6:	4a0f      	ldr	r2, [pc, #60]	; (101e114 <net_buf_frag_insert+0x4c>)
 101e0d8:	480f      	ldr	r0, [pc, #60]	; (101e118 <net_buf_frag_insert+0x50>)
 101e0da:	f006 fd7c 	bl	1024bd6 <assert_print>
 101e0de:	f240 2162 	movw	r1, #610	; 0x262
	__ASSERT_NO_MSG(frag);
 101e0e2:	480c      	ldr	r0, [pc, #48]	; (101e114 <net_buf_frag_insert+0x4c>)
 101e0e4:	f006 fd70 	bl	1024bc8 <assert_post_action>
 101e0e8:	b949      	cbnz	r1, 101e0fe <net_buf_frag_insert+0x36>
 101e0ea:	490c      	ldr	r1, [pc, #48]	; (101e11c <net_buf_frag_insert+0x54>)
 101e0ec:	f240 2363 	movw	r3, #611	; 0x263
 101e0f0:	4a08      	ldr	r2, [pc, #32]	; (101e114 <net_buf_frag_insert+0x4c>)
 101e0f2:	4809      	ldr	r0, [pc, #36]	; (101e118 <net_buf_frag_insert+0x50>)
 101e0f4:	f006 fd6f 	bl	1024bd6 <assert_print>
 101e0f8:	f240 2163 	movw	r1, #611	; 0x263
 101e0fc:	e7f1      	b.n	101e0e2 <net_buf_frag_insert+0x1a>

	if (parent->frags) {
 101e0fe:	6846      	ldr	r6, [r0, #4]
 101e100:	b11e      	cbz	r6, 101e10a <net_buf_frag_insert+0x42>
		net_buf_frag_last(frag)->frags = parent->frags;
 101e102:	4608      	mov	r0, r1
 101e104:	f7ff ffc6 	bl	101e094 <net_buf_frag_last>
 101e108:	6046      	str	r6, [r0, #4]
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
 101e10a:	6065      	str	r5, [r4, #4]
}
 101e10c:	bd70      	pop	{r4, r5, r6, pc}
 101e10e:	bf00      	nop
 101e110:	0102ee9b 	.word	0x0102ee9b
 101e114:	0102ee1f 	.word	0x0102ee1f
 101e118:	0102b695 	.word	0x0102b695
 101e11c:	0102eec1 	.word	0x0102eec1

0101e120 <net_buf_frag_add>:

struct net_buf *net_buf_frag_add(struct net_buf *head, struct net_buf *frag)
{
 101e120:	b538      	push	{r3, r4, r5, lr}
 101e122:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(frag);
 101e124:	460c      	mov	r4, r1
 101e126:	b959      	cbnz	r1, 101e140 <net_buf_frag_add+0x20>
 101e128:	490c      	ldr	r1, [pc, #48]	; (101e15c <net_buf_frag_add+0x3c>)
 101e12a:	480d      	ldr	r0, [pc, #52]	; (101e160 <net_buf_frag_add+0x40>)
 101e12c:	f240 236e 	movw	r3, #622	; 0x26e
 101e130:	4a0c      	ldr	r2, [pc, #48]	; (101e164 <net_buf_frag_add+0x44>)
 101e132:	f006 fd50 	bl	1024bd6 <assert_print>
 101e136:	f240 216e 	movw	r1, #622	; 0x26e
 101e13a:	480a      	ldr	r0, [pc, #40]	; (101e164 <net_buf_frag_add+0x44>)
 101e13c:	f006 fd44 	bl	1024bc8 <assert_post_action>

	if (!head) {
 101e140:	b920      	cbnz	r0, 101e14c <net_buf_frag_add+0x2c>
	}

	net_buf_frag_insert(net_buf_frag_last(head), frag);

	return head;
}
 101e142:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return net_buf_ref(frag);
 101e146:	4608      	mov	r0, r1
 101e148:	f7ff bf8c 	b.w	101e064 <net_buf_ref>
	net_buf_frag_insert(net_buf_frag_last(head), frag);
 101e14c:	f7ff ffa2 	bl	101e094 <net_buf_frag_last>
 101e150:	4621      	mov	r1, r4
 101e152:	f7ff ffb9 	bl	101e0c8 <net_buf_frag_insert>
}
 101e156:	4628      	mov	r0, r5
 101e158:	bd38      	pop	{r3, r4, r5, pc}
 101e15a:	bf00      	nop
 101e15c:	0102eec1 	.word	0x0102eec1
 101e160:	0102b695 	.word	0x0102b695
 101e164:	0102ee1f 	.word	0x0102ee1f

0101e168 <net_buf_frag_del>:
				       struct net_buf *frag,
				       const char *func, int line)
#else
struct net_buf *net_buf_frag_del(struct net_buf *parent, struct net_buf *frag)
#endif
{
 101e168:	4603      	mov	r3, r0
 101e16a:	b510      	push	{r4, lr}
	struct net_buf *next_frag;

	__ASSERT_NO_MSG(frag);
 101e16c:	4608      	mov	r0, r1
 101e16e:	b959      	cbnz	r1, 101e188 <net_buf_frag_del+0x20>
 101e170:	4916      	ldr	r1, [pc, #88]	; (101e1cc <net_buf_frag_del+0x64>)
 101e172:	f240 2383 	movw	r3, #643	; 0x283
 101e176:	4a16      	ldr	r2, [pc, #88]	; (101e1d0 <net_buf_frag_del+0x68>)
 101e178:	4816      	ldr	r0, [pc, #88]	; (101e1d4 <net_buf_frag_del+0x6c>)
 101e17a:	f006 fd2c 	bl	1024bd6 <assert_print>
 101e17e:	f240 2183 	movw	r1, #643	; 0x283

	if (parent) {
		__ASSERT_NO_MSG(parent->frags);
 101e182:	4813      	ldr	r0, [pc, #76]	; (101e1d0 <net_buf_frag_del+0x68>)
 101e184:	f006 fd20 	bl	1024bc8 <assert_post_action>
	if (parent) {
 101e188:	b1cb      	cbz	r3, 101e1be <net_buf_frag_del+0x56>
		__ASSERT_NO_MSG(parent->frags);
 101e18a:	685a      	ldr	r2, [r3, #4]
 101e18c:	b94a      	cbnz	r2, 101e1a2 <net_buf_frag_del+0x3a>
 101e18e:	4912      	ldr	r1, [pc, #72]	; (101e1d8 <net_buf_frag_del+0x70>)
 101e190:	f240 2386 	movw	r3, #646	; 0x286
 101e194:	4a0e      	ldr	r2, [pc, #56]	; (101e1d0 <net_buf_frag_del+0x68>)
 101e196:	480f      	ldr	r0, [pc, #60]	; (101e1d4 <net_buf_frag_del+0x6c>)
 101e198:	f006 fd1d 	bl	1024bd6 <assert_print>
 101e19c:	f240 2186 	movw	r1, #646	; 0x286
 101e1a0:	e7ef      	b.n	101e182 <net_buf_frag_del+0x1a>
		__ASSERT_NO_MSG(parent->frags == frag);
 101e1a2:	428a      	cmp	r2, r1
 101e1a4:	d009      	beq.n	101e1ba <net_buf_frag_del+0x52>
 101e1a6:	490d      	ldr	r1, [pc, #52]	; (101e1dc <net_buf_frag_del+0x74>)
 101e1a8:	f240 2387 	movw	r3, #647	; 0x287
 101e1ac:	4a08      	ldr	r2, [pc, #32]	; (101e1d0 <net_buf_frag_del+0x68>)
 101e1ae:	4809      	ldr	r0, [pc, #36]	; (101e1d4 <net_buf_frag_del+0x6c>)
 101e1b0:	f006 fd11 	bl	1024bd6 <assert_print>
 101e1b4:	f240 2187 	movw	r1, #647	; 0x287
 101e1b8:	e7e3      	b.n	101e182 <net_buf_frag_del+0x1a>
		parent->frags = frag->frags;
 101e1ba:	684a      	ldr	r2, [r1, #4]
 101e1bc:	605a      	str	r2, [r3, #4]
	}

	next_frag = frag->frags;

	frag->frags = NULL;
 101e1be:	2300      	movs	r3, #0
	next_frag = frag->frags;
 101e1c0:	6844      	ldr	r4, [r0, #4]
	frag->frags = NULL;
 101e1c2:	6043      	str	r3, [r0, #4]

#if defined(CONFIG_NET_BUF_LOG)
	net_buf_unref_debug(frag, func, line);
#else
	net_buf_unref(frag);
 101e1c4:	f7ff ff0c 	bl	101dfe0 <net_buf_unref>
#endif

	return next_frag;
}
 101e1c8:	4620      	mov	r0, r4
 101e1ca:	bd10      	pop	{r4, pc}
 101e1cc:	0102eec1 	.word	0x0102eec1
 101e1d0:	0102ee1f 	.word	0x0102ee1f
 101e1d4:	0102b695 	.word	0x0102b695
 101e1d8:	0102eea2 	.word	0x0102eea2
 101e1dc:	0102eeb0 	.word	0x0102eeb0

0101e1e0 <net_buf_simple_push>:

	return sys_be64_to_cpu(val);
}

void *net_buf_simple_push(struct net_buf_simple *buf, size_t len)
{
 101e1e0:	b508      	push	{r3, lr}
 101e1e2:	4603      	mov	r3, r0
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
 101e1e4:	6800      	ldr	r0, [r0, #0]
 101e1e6:	689a      	ldr	r2, [r3, #8]
 101e1e8:	1a82      	subs	r2, r0, r2
	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);
 101e1ea:	4291      	cmp	r1, r2
 101e1ec:	d90b      	bls.n	101e206 <net_buf_simple_push+0x26>
 101e1ee:	4909      	ldr	r1, [pc, #36]	; (101e214 <net_buf_simple_push+0x34>)
 101e1f0:	4809      	ldr	r0, [pc, #36]	; (101e218 <net_buf_simple_push+0x38>)
 101e1f2:	f240 33f2 	movw	r3, #1010	; 0x3f2
 101e1f6:	4a09      	ldr	r2, [pc, #36]	; (101e21c <net_buf_simple_push+0x3c>)
 101e1f8:	f006 fced 	bl	1024bd6 <assert_print>
 101e1fc:	f240 31f2 	movw	r1, #1010	; 0x3f2
 101e200:	4806      	ldr	r0, [pc, #24]	; (101e21c <net_buf_simple_push+0x3c>)
 101e202:	f006 fce1 	bl	1024bc8 <assert_post_action>
	buf->len += len;
 101e206:	889a      	ldrh	r2, [r3, #4]
	buf->data -= len;
 101e208:	1a40      	subs	r0, r0, r1
	buf->len += len;
 101e20a:	4411      	add	r1, r2
	buf->data -= len;
 101e20c:	6018      	str	r0, [r3, #0]
	buf->len += len;
 101e20e:	8099      	strh	r1, [r3, #4]
}
 101e210:	bd08      	pop	{r3, pc}
 101e212:	bf00      	nop
 101e214:	0102eed6 	.word	0x0102eed6
 101e218:	0102b695 	.word	0x0102b695
 101e21c:	0102ee1f 	.word	0x0102ee1f

0101e220 <net_buf_simple_pull>:
{
 101e220:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(buf->len >= len);
 101e222:	8882      	ldrh	r2, [r0, #4]
{
 101e224:	4603      	mov	r3, r0
	__ASSERT_NO_MSG(buf->len >= len);
 101e226:	428a      	cmp	r2, r1
 101e228:	d20b      	bcs.n	101e242 <net_buf_simple_pull+0x22>
 101e22a:	4909      	ldr	r1, [pc, #36]	; (101e250 <net_buf_simple_pull+0x30>)
 101e22c:	4809      	ldr	r0, [pc, #36]	; (101e254 <net_buf_simple_pull+0x34>)
 101e22e:	f240 4352 	movw	r3, #1106	; 0x452
 101e232:	4a09      	ldr	r2, [pc, #36]	; (101e258 <net_buf_simple_pull+0x38>)
 101e234:	f006 fccf 	bl	1024bd6 <assert_print>
 101e238:	f240 4152 	movw	r1, #1106	; 0x452
 101e23c:	4806      	ldr	r0, [pc, #24]	; (101e258 <net_buf_simple_pull+0x38>)
 101e23e:	f006 fcc3 	bl	1024bc8 <assert_post_action>
	buf->len -= len;
 101e242:	1a52      	subs	r2, r2, r1
 101e244:	8082      	strh	r2, [r0, #4]
	return buf->data += len;
 101e246:	6800      	ldr	r0, [r0, #0]
 101e248:	4408      	add	r0, r1
 101e24a:	6018      	str	r0, [r3, #0]
}
 101e24c:	bd08      	pop	{r3, pc}
 101e24e:	bf00      	nop
 101e250:	0102eec6 	.word	0x0102eec6
 101e254:	0102b695 	.word	0x0102b695
 101e258:	0102ee1f 	.word	0x0102ee1f

0101e25c <net_buf_simple_pull_mem>:
{
 101e25c:	b508      	push	{r3, lr}
 101e25e:	4603      	mov	r3, r0
	__ASSERT_NO_MSG(buf->len >= len);
 101e260:	889a      	ldrh	r2, [r3, #4]
	void *data = buf->data;
 101e262:	6800      	ldr	r0, [r0, #0]
	__ASSERT_NO_MSG(buf->len >= len);
 101e264:	428a      	cmp	r2, r1
 101e266:	d20b      	bcs.n	101e280 <net_buf_simple_pull_mem+0x24>
 101e268:	4908      	ldr	r1, [pc, #32]	; (101e28c <net_buf_simple_pull_mem+0x30>)
 101e26a:	4809      	ldr	r0, [pc, #36]	; (101e290 <net_buf_simple_pull_mem+0x34>)
 101e26c:	f240 435e 	movw	r3, #1118	; 0x45e
 101e270:	4a08      	ldr	r2, [pc, #32]	; (101e294 <net_buf_simple_pull_mem+0x38>)
 101e272:	f006 fcb0 	bl	1024bd6 <assert_print>
 101e276:	f240 415e 	movw	r1, #1118	; 0x45e
 101e27a:	4806      	ldr	r0, [pc, #24]	; (101e294 <net_buf_simple_pull_mem+0x38>)
 101e27c:	f006 fca4 	bl	1024bc8 <assert_post_action>
	buf->len -= len;
 101e280:	1a52      	subs	r2, r2, r1
	buf->data += len;
 101e282:	4401      	add	r1, r0
	buf->len -= len;
 101e284:	809a      	strh	r2, [r3, #4]
	buf->data += len;
 101e286:	6019      	str	r1, [r3, #0]
}
 101e288:	bd08      	pop	{r3, pc}
 101e28a:	bf00      	nop
 101e28c:	0102eec6 	.word	0x0102eec6
 101e290:	0102b695 	.word	0x0102b695
 101e294:	0102ee1f 	.word	0x0102ee1f

0101e298 <net_buf_simple_add>:
{
 101e298:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return buf->data + buf->len;
 101e29a:	8885      	ldrh	r5, [r0, #4]
 101e29c:	6803      	ldr	r3, [r0, #0]
 101e29e:	460e      	mov	r6, r1
 101e2a0:	4604      	mov	r4, r0
 101e2a2:	195f      	adds	r7, r3, r5
	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);
 101e2a4:	f00a fd6c 	bl	1028d80 <net_buf_simple_tailroom>
 101e2a8:	42b0      	cmp	r0, r6
 101e2aa:	d20b      	bcs.n	101e2c4 <net_buf_simple_add+0x2c>
 101e2ac:	4907      	ldr	r1, [pc, #28]	; (101e2cc <net_buf_simple_add+0x34>)
 101e2ae:	4808      	ldr	r0, [pc, #32]	; (101e2d0 <net_buf_simple_add+0x38>)
 101e2b0:	f240 3303 	movw	r3, #771	; 0x303
 101e2b4:	4a07      	ldr	r2, [pc, #28]	; (101e2d4 <net_buf_simple_add+0x3c>)
 101e2b6:	f006 fc8e 	bl	1024bd6 <assert_print>
 101e2ba:	f240 3103 	movw	r1, #771	; 0x303
 101e2be:	4805      	ldr	r0, [pc, #20]	; (101e2d4 <net_buf_simple_add+0x3c>)
 101e2c0:	f006 fc82 	bl	1024bc8 <assert_post_action>
	buf->len += len;
 101e2c4:	4435      	add	r5, r6
 101e2c6:	80a5      	strh	r5, [r4, #4]
}
 101e2c8:	4638      	mov	r0, r7
 101e2ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 101e2cc:	0102eefa 	.word	0x0102eefa
 101e2d0:	0102b695 	.word	0x0102b695
 101e2d4:	0102ee1f 	.word	0x0102ee1f

0101e2d8 <net_buf_append_bytes>:
{
 101e2d8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 101e2dc:	4606      	mov	r6, r0
 101e2de:	460c      	mov	r4, r1
 101e2e0:	4615      	mov	r5, r2
	struct net_buf *frag = net_buf_frag_last(buf);
 101e2e2:	f7ff fed7 	bl	101e094 <net_buf_frag_last>
	size_t added_len = 0;
 101e2e6:	2700      	movs	r7, #0
	struct net_buf *frag = net_buf_frag_last(buf);
 101e2e8:	4683      	mov	fp, r0
	return &_net_buf_pool_list[id];
 101e2ea:	f04f 0934 	mov.w	r9, #52	; 0x34
 101e2ee:	f8df a060 	ldr.w	sl, [pc, #96]	; 101e350 <net_buf_append_bytes+0x78>
	return net_buf_simple_tailroom(&buf->b);
 101e2f2:	f10b 0b0c 	add.w	fp, fp, #12
 101e2f6:	4658      	mov	r0, fp
 101e2f8:	f00a fd42 	bl	1028d80 <net_buf_simple_tailroom>
		uint16_t count = MIN(len, net_buf_tailroom(frag));
 101e2fc:	4284      	cmp	r4, r0
 101e2fe:	bf2c      	ite	cs
 101e300:	fa1f f880 	uxthcs.w	r8, r0
 101e304:	fa1f f884 	uxthcc.w	r8, r4
	return net_buf_simple_add_mem(&buf->b, mem, len);
 101e308:	4629      	mov	r1, r5
 101e30a:	4642      	mov	r2, r8
 101e30c:	4658      	mov	r0, fp
 101e30e:	f00a fd3f 	bl	1028d90 <net_buf_simple_add_mem>
		if (len == 0) {
 101e312:	ebb4 0408 	subs.w	r4, r4, r8
		added_len += count;
 101e316:	4447      	add	r7, r8
		value8 += count;
 101e318:	4445      	add	r5, r8
		if (len == 0) {
 101e31a:	d015      	beq.n	101e348 <net_buf_append_bytes+0x70>
		if (allocate_cb) {
 101e31c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 101e31e:	b153      	cbz	r3, 101e336 <net_buf_append_bytes+0x5e>
			frag = allocate_cb(timeout, user_data);
 101e320:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 101e324:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 101e326:	4798      	blx	r3
			frag = net_buf_alloc_len(pool, len, timeout);
 101e328:	4683      	mov	fp, r0
		if (!frag) {
 101e32a:	b168      	cbz	r0, 101e348 <net_buf_append_bytes+0x70>
		net_buf_frag_add(buf, frag);
 101e32c:	4601      	mov	r1, r0
 101e32e:	4630      	mov	r0, r6
 101e330:	f7ff fef6 	bl	101e120 <net_buf_frag_add>
	do {
 101e334:	e7dd      	b.n	101e2f2 <net_buf_append_bytes+0x1a>
	return &_net_buf_pool_list[id];
 101e336:	7ab0      	ldrb	r0, [r6, #10]
			frag = net_buf_alloc_len(pool, len, timeout);
 101e338:	4621      	mov	r1, r4
 101e33a:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 101e33e:	fb09 a000 	mla	r0, r9, r0, sl
 101e342:	f7ff fd0b 	bl	101dd5c <net_buf_alloc_len>
 101e346:	e7ef      	b.n	101e328 <net_buf_append_bytes+0x50>
}
 101e348:	4638      	mov	r0, r7
 101e34a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 101e34e:	bf00      	nop
 101e350:	21000d7c 	.word	0x21000d7c

0101e354 <xoshiro128_initialize>:
{
	return (x << k) | (x >> (32 - k));
}

static int xoshiro128_initialize(const struct device *dev)
{
 101e354:	b508      	push	{r3, lr}
 101e356:	4804      	ldr	r0, [pc, #16]	; (101e368 <xoshiro128_initialize+0x14>)
 101e358:	f00a ff66 	bl	1029228 <z_device_is_ready>
	if (!device_is_ready(entropy_driver)) {
		return -ENODEV;
	}
	return 0;
 101e35c:	2800      	cmp	r0, #0
}
 101e35e:	bf0c      	ite	eq
 101e360:	f06f 0012 	mvneq.w	r0, #18
 101e364:	2000      	movne	r0, #0
 101e366:	bd08      	pop	{r3, pc}
 101e368:	01029730 	.word	0x01029730

0101e36c <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
 101e36c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 101e36e:	2340      	movs	r3, #64	; 0x40
{
 101e370:	460c      	mov	r4, r1
	size_t offset = (size_t)(mgr - data->mgr);
 101e372:	490a      	ldr	r1, [pc, #40]	; (101e39c <onoff_start+0x30>)
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 101e374:	9300      	str	r3, [sp, #0]
	size_t offset = (size_t)(mgr - data->mgr);
 101e376:	1a41      	subs	r1, r0, r1
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 101e378:	1149      	asrs	r1, r1, #5
{
 101e37a:	4605      	mov	r5, r0
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 101e37c:	4623      	mov	r3, r4
 101e37e:	4a08      	ldr	r2, [pc, #32]	; (101e3a0 <onoff_start+0x34>)
 101e380:	4808      	ldr	r0, [pc, #32]	; (101e3a4 <onoff_start+0x38>)
 101e382:	f00a fd34 	bl	1028dee <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
 101e386:	1e01      	subs	r1, r0, #0
 101e388:	da05      	bge.n	101e396 <onoff_start+0x2a>
		notify(mgr, err);
 101e38a:	4628      	mov	r0, r5
 101e38c:	4623      	mov	r3, r4
	}
}
 101e38e:	b003      	add	sp, #12
 101e390:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		notify(mgr, err);
 101e394:	4718      	bx	r3
}
 101e396:	b003      	add	sp, #12
 101e398:	bd30      	pop	{r4, r5, pc}
 101e39a:	bf00      	nop
 101e39c:	21007ef4 	.word	0x21007ef4
 101e3a0:	01028e59 	.word	0x01028e59
 101e3a4:	010296e8 	.word	0x010296e8

0101e3a8 <get_status>:
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
 101e3a8:	b2c9      	uxtb	r1, r1
 101e3aa:	2901      	cmp	r1, #1
{
 101e3ac:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
 101e3ae:	d909      	bls.n	101e3c4 <get_status+0x1c>
 101e3b0:	4908      	ldr	r1, [pc, #32]	; (101e3d4 <get_status+0x2c>)
 101e3b2:	4809      	ldr	r0, [pc, #36]	; (101e3d8 <get_status+0x30>)
 101e3b4:	237a      	movs	r3, #122	; 0x7a
 101e3b6:	4a09      	ldr	r2, [pc, #36]	; (101e3dc <get_status+0x34>)
 101e3b8:	f006 fc0d 	bl	1024bd6 <assert_print>
 101e3bc:	217a      	movs	r1, #122	; 0x7a
 101e3be:	4807      	ldr	r0, [pc, #28]	; (101e3dc <get_status+0x34>)
 101e3c0:	f006 fc02 	bl	1024bc8 <assert_post_action>
	return GET_STATUS(get_sub_data(dev, type)->flags);
 101e3c4:	220c      	movs	r2, #12
 101e3c6:	6903      	ldr	r3, [r0, #16]
 101e3c8:	fb01 3302 	mla	r3, r1, r2, r3
 101e3cc:	6c98      	ldr	r0, [r3, #72]	; 0x48
}
 101e3ce:	f000 0007 	and.w	r0, r0, #7
 101e3d2:	bd08      	pop	{r3, pc}
 101e3d4:	0102ef63 	.word	0x0102ef63
 101e3d8:	0102b695 	.word	0x0102b695
 101e3dc:	0102ef26 	.word	0x0102ef26

0101e3e0 <stop>:
{
 101e3e0:	b570      	push	{r4, r5, r6, lr}
 101e3e2:	b2c9      	uxtb	r1, r1
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
 101e3e4:	2901      	cmp	r1, #1
	struct nrf_clock_control_data *data = dev->data;
 101e3e6:	6903      	ldr	r3, [r0, #16]
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
 101e3e8:	d90b      	bls.n	101e402 <stop+0x22>
 101e3ea:	4919      	ldr	r1, [pc, #100]	; (101e450 <stop+0x70>)
 101e3ec:	4819      	ldr	r0, [pc, #100]	; (101e454 <stop+0x74>)
 101e3ee:	f240 135d 	movw	r3, #349	; 0x15d
 101e3f2:	4a19      	ldr	r2, [pc, #100]	; (101e458 <stop+0x78>)
 101e3f4:	f006 fbef 	bl	1024bd6 <assert_print>
 101e3f8:	f240 115d 	movw	r1, #349	; 0x15d
 101e3fc:	4816      	ldr	r0, [pc, #88]	; (101e458 <stop+0x78>)
 101e3fe:	f006 fbe3 	bl	1024bc8 <assert_post_action>
	__asm__ volatile(
 101e402:	f04f 0420 	mov.w	r4, #32
 101e406:	f3ef 8511 	mrs	r5, BASEPRI
 101e40a:	f384 8812 	msr	BASEPRI_MAX, r4
 101e40e:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
 101e412:	260c      	movs	r6, #12
 101e414:	fb06 3401 	mla	r4, r6, r1, r3
 101e418:	6ca4      	ldr	r4, [r4, #72]	; 0x48
	if ((current_ctx != 0) && (current_ctx != ctx)) {
 101e41a:	f014 04c0 	ands.w	r4, r4, #192	; 0xc0
 101e41e:	d008      	beq.n	101e432 <stop+0x52>
 101e420:	42a2      	cmp	r2, r4
 101e422:	d006      	beq.n	101e432 <stop+0x52>
	__asm__ volatile(
 101e424:	f385 8811 	msr	BASEPRI, r5
 101e428:	f3bf 8f6f 	isb	sy
		err = -EPERM;
 101e42c:	f04f 30ff 	mov.w	r0, #4294967295
}
 101e430:	bd70      	pop	{r4, r5, r6, pc}
		*flags = CLOCK_CONTROL_STATUS_OFF;
 101e432:	2201      	movs	r2, #1
 101e434:	4371      	muls	r1, r6
 101e436:	440b      	add	r3, r1
 101e438:	649a      	str	r2, [r3, #72]	; 0x48
 101e43a:	f385 8811 	msr	BASEPRI, r5
 101e43e:	f3bf 8f6f 	isb	sy
	get_sub_config(dev, type)->stop();
 101e442:	6843      	ldr	r3, [r0, #4]
 101e444:	440b      	add	r3, r1
 101e446:	685b      	ldr	r3, [r3, #4]
 101e448:	4798      	blx	r3
	return 0;
 101e44a:	2000      	movs	r0, #0
 101e44c:	e7f0      	b.n	101e430 <stop+0x50>
 101e44e:	bf00      	nop
 101e450:	0102ef63 	.word	0x0102ef63
 101e454:	0102b695 	.word	0x0102b695
 101e458:	0102ef26 	.word	0x0102ef26

0101e45c <onoff_stop>:
{
 101e45c:	b570      	push	{r4, r5, r6, lr}
 101e45e:	460d      	mov	r5, r1
	size_t offset = (size_t)(mgr - data->mgr);
 101e460:	4906      	ldr	r1, [pc, #24]	; (101e47c <onoff_stop+0x20>)
{
 101e462:	4604      	mov	r4, r0
	size_t offset = (size_t)(mgr - data->mgr);
 101e464:	1a41      	subs	r1, r0, r1
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
 101e466:	1149      	asrs	r1, r1, #5
 101e468:	2240      	movs	r2, #64	; 0x40
 101e46a:	4805      	ldr	r0, [pc, #20]	; (101e480 <onoff_stop+0x24>)
 101e46c:	f7ff ffb8 	bl	101e3e0 <stop>
	notify(mgr, res);
 101e470:	462b      	mov	r3, r5
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
 101e472:	4601      	mov	r1, r0
	notify(mgr, res);
 101e474:	4620      	mov	r0, r4
}
 101e476:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
 101e47a:	4718      	bx	r3
 101e47c:	21007ef4 	.word	0x21007ef4
 101e480:	010296e8 	.word	0x010296e8

0101e484 <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
 101e484:	b570      	push	{r4, r5, r6, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
 101e486:	2200      	movs	r2, #0
 101e488:	2101      	movs	r1, #1
{
 101e48a:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
 101e48c:	2005      	movs	r0, #5
 101e48e:	f7e7 fcdb 	bl	1005e48 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);

	nrfx_err = nrfx_clock_init(clock_event_handler);
 101e492:	480f      	ldr	r0, [pc, #60]	; (101e4d0 <clk_init+0x4c>)
 101e494:	f001 facc 	bl	101fa30 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
 101e498:	4b0e      	ldr	r3, [pc, #56]	; (101e4d4 <clk_init+0x50>)
 101e49a:	4298      	cmp	r0, r3
 101e49c:	d115      	bne.n	101e4ca <clk_init+0x46>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
 101e49e:	f001 faeb 	bl	101fa78 <nrfx_clock_enable>
	struct nrf_clock_control_data *data = dev->data;
 101e4a2:	6926      	ldr	r6, [r4, #16]
	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);

		err = onoff_manager_init(get_onoff_manager(dev, i),
 101e4a4:	490c      	ldr	r1, [pc, #48]	; (101e4d8 <clk_init+0x54>)
 101e4a6:	4630      	mov	r0, r6
 101e4a8:	f006 fb0a 	bl	1024ac0 <onoff_manager_init>
					 &transitions);
		if (err < 0) {
 101e4ac:	2800      	cmp	r0, #0
 101e4ae:	db0b      	blt.n	101e4c8 <clk_init+0x44>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
 101e4b0:	2501      	movs	r5, #1
 101e4b2:	64b5      	str	r5, [r6, #72]	; 0x48
	struct nrf_clock_control_data *data = dev->data;
 101e4b4:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
 101e4b6:	4908      	ldr	r1, [pc, #32]	; (101e4d8 <clk_init+0x54>)
 101e4b8:	f104 0020 	add.w	r0, r4, #32
 101e4bc:	f006 fb00 	bl	1024ac0 <onoff_manager_init>
		if (err < 0) {
 101e4c0:	2800      	cmp	r0, #0
 101e4c2:	db01      	blt.n	101e4c8 <clk_init+0x44>
	}

	return 0;
 101e4c4:	2000      	movs	r0, #0
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
 101e4c6:	6565      	str	r5, [r4, #84]	; 0x54
}
 101e4c8:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
 101e4ca:	f06f 0004 	mvn.w	r0, #4
 101e4ce:	e7fb      	b.n	101e4c8 <clk_init+0x44>
 101e4d0:	0101e511 	.word	0x0101e511
 101e4d4:	0bad0000 	.word	0x0bad0000
 101e4d8:	0102b324 	.word	0x0102b324

0101e4dc <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
 101e4dc:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
 101e4de:	230c      	movs	r3, #12
	sub_data->cb = NULL;
 101e4e0:	2200      	movs	r2, #0
static void clkstarted_handle(const struct device *dev,
 101e4e2:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
 101e4e4:	434b      	muls	r3, r1
 101e4e6:	4808      	ldr	r0, [pc, #32]	; (101e508 <clkstarted_handle.constprop.0+0x2c>)
 101e4e8:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
 101e4ea:	3348      	adds	r3, #72	; 0x48
	void *user_data = sub_data->user_data;
 101e4ec:	e9d4 5610 	ldrd	r5, r6, [r4, #64]	; 0x40
	set_on_state(&sub_data->flags);
 101e4f0:	4418      	add	r0, r3
	sub_data->cb = NULL;
 101e4f2:	6422      	str	r2, [r4, #64]	; 0x40
	set_on_state(&sub_data->flags);
 101e4f4:	f00a fc68 	bl	1028dc8 <set_on_state>
	if (callback) {
 101e4f8:	b12d      	cbz	r5, 101e506 <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
 101e4fa:	4632      	mov	r2, r6
 101e4fc:	462b      	mov	r3, r5
}
 101e4fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
 101e502:	4802      	ldr	r0, [pc, #8]	; (101e50c <clkstarted_handle.constprop.0+0x30>)
 101e504:	4718      	bx	r3
}
 101e506:	bd70      	pop	{r4, r5, r6, pc}
 101e508:	21007ef4 	.word	0x21007ef4
 101e50c:	010296e8 	.word	0x010296e8

0101e510 <clock_event_handler>:
	switch (event) {
 101e510:	2801      	cmp	r0, #1
{
 101e512:	b508      	push	{r3, lr}
	switch (event) {
 101e514:	d006      	beq.n	101e524 <clock_event_handler+0x14>
 101e516:	2803      	cmp	r0, #3
 101e518:	d008      	beq.n	101e52c <clock_event_handler+0x1c>
 101e51a:	b998      	cbnz	r0, 101e544 <clock_event_handler+0x34>
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
 101e51c:	4b0f      	ldr	r3, [pc, #60]	; (101e55c <clock_event_handler+0x4c>)
 101e51e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 101e520:	075b      	lsls	r3, r3, #29
 101e522:	d119      	bne.n	101e558 <clock_event_handler+0x48>
}
 101e524:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
 101e528:	f7ff bfd8 	b.w	101e4dc <clkstarted_handle.constprop.0>
			__ASSERT_NO_MSG(false);
 101e52c:	490c      	ldr	r1, [pc, #48]	; (101e560 <clock_event_handler+0x50>)
 101e52e:	f240 236e 	movw	r3, #622	; 0x26e
 101e532:	4a0c      	ldr	r2, [pc, #48]	; (101e564 <clock_event_handler+0x54>)
 101e534:	480c      	ldr	r0, [pc, #48]	; (101e568 <clock_event_handler+0x58>)
 101e536:	f006 fb4e 	bl	1024bd6 <assert_print>
 101e53a:	f240 216e 	movw	r1, #622	; 0x26e
		__ASSERT_NO_MSG(0);
 101e53e:	4809      	ldr	r0, [pc, #36]	; (101e564 <clock_event_handler+0x54>)
 101e540:	f006 fb42 	bl	1024bc8 <assert_post_action>
 101e544:	4906      	ldr	r1, [pc, #24]	; (101e560 <clock_event_handler+0x50>)
 101e546:	f240 2372 	movw	r3, #626	; 0x272
 101e54a:	4a06      	ldr	r2, [pc, #24]	; (101e564 <clock_event_handler+0x54>)
 101e54c:	4806      	ldr	r0, [pc, #24]	; (101e568 <clock_event_handler+0x58>)
 101e54e:	f006 fb42 	bl	1024bd6 <assert_print>
 101e552:	f240 2172 	movw	r1, #626	; 0x272
 101e556:	e7f2      	b.n	101e53e <clock_event_handler+0x2e>
}
 101e558:	bd08      	pop	{r3, pc}
 101e55a:	bf00      	nop
 101e55c:	21007ef4 	.word	0x21007ef4
 101e560:	0102ff6e 	.word	0x0102ff6e
 101e564:	0102ef26 	.word	0x0102ef26
 101e568:	0102b695 	.word	0x0102b695

0101e56c <generic_hfclk_start>:
{
 101e56c:	b508      	push	{r3, lr}
	__asm__ volatile(
 101e56e:	f04f 0320 	mov.w	r3, #32
 101e572:	f3ef 8111 	mrs	r1, BASEPRI
 101e576:	f383 8812 	msr	BASEPRI_MAX, r3
 101e57a:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
 101e57e:	4a11      	ldr	r2, [pc, #68]	; (101e5c4 <generic_hfclk_start+0x58>)
 101e580:	6813      	ldr	r3, [r2, #0]
 101e582:	f043 0002 	orr.w	r0, r3, #2
 101e586:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
 101e588:	07da      	lsls	r2, r3, #31
 101e58a:	d408      	bmi.n	101e59e <generic_hfclk_start+0x32>
	__asm__ volatile(
 101e58c:	f381 8811 	msr	BASEPRI, r1
 101e590:	f3bf 8f6f 	isb	sy
}
 101e594:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
 101e598:	2001      	movs	r0, #1
 101e59a:	f001 ba95 	b.w	101fac8 <nrfx_clock_start>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
 101e59e:	4b0a      	ldr	r3, [pc, #40]	; (101e5c8 <generic_hfclk_start+0x5c>)
 101e5a0:	f8d3 240c 	ldr.w	r2, [r3, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
 101e5a4:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
 101e5a8:	07d3      	lsls	r3, r2, #31
 101e5aa:	d5ef      	bpl.n	101e58c <generic_hfclk_start+0x20>
			set_on_state(get_hf_flags());
 101e5ac:	4807      	ldr	r0, [pc, #28]	; (101e5cc <generic_hfclk_start+0x60>)
 101e5ae:	f00a fc0b 	bl	1028dc8 <set_on_state>
 101e5b2:	f381 8811 	msr	BASEPRI, r1
 101e5b6:	f3bf 8f6f 	isb	sy
}
 101e5ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
 101e5be:	2000      	movs	r0, #0
 101e5c0:	f7ff bf8c 	b.w	101e4dc <clkstarted_handle.constprop.0>
 101e5c4:	21007f4c 	.word	0x21007f4c
 101e5c8:	41005000 	.word	0x41005000
 101e5cc:	21007f3c 	.word	0x21007f3c

0101e5d0 <api_blocking_start>:
{
 101e5d0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
 101e5d2:	2200      	movs	r2, #0
 101e5d4:	2301      	movs	r3, #1
 101e5d6:	e9cd 2302 	strd	r2, r3, [sp, #8]
 101e5da:	ab04      	add	r3, sp, #16
 101e5dc:	e9cd 3304 	strd	r3, r3, [sp, #16]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
 101e5e0:	4a09      	ldr	r2, [pc, #36]	; (101e608 <api_blocking_start+0x38>)
 101e5e2:	466b      	mov	r3, sp
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
 101e5e4:	f8cd d000 	str.w	sp, [sp]
 101e5e8:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
 101e5ec:	f00a fc2d 	bl	1028e4a <api_start>
	if (err < 0) {
 101e5f0:	2800      	cmp	r0, #0
 101e5f2:	db05      	blt.n	101e600 <api_blocking_start+0x30>
	return z_impl_k_sem_take(sem, timeout);
 101e5f4:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 101e5f8:	2300      	movs	r3, #0
 101e5fa:	4668      	mov	r0, sp
 101e5fc:	f003 f894 	bl	1021728 <z_impl_k_sem_take>
}
 101e600:	b007      	add	sp, #28
 101e602:	f85d fb04 	ldr.w	pc, [sp], #4
 101e606:	bf00      	nop
 101e608:	01028e71 	.word	0x01028e71

0101e60c <generic_hfclk_stop>:
{
 101e60c:	b510      	push	{r4, lr}
	__asm__ volatile(
 101e60e:	f04f 0320 	mov.w	r3, #32
 101e612:	f3ef 8411 	mrs	r4, BASEPRI
 101e616:	f383 8812 	msr	BASEPRI_MAX, r3
 101e61a:	f3bf 8f6f 	isb	sy
	hfclk_users &= ~HF_USER_GENERIC;
 101e61e:	4a07      	ldr	r2, [pc, #28]	; (101e63c <generic_hfclk_stop+0x30>)
 101e620:	6813      	ldr	r3, [r2, #0]
 101e622:	f023 0102 	bic.w	r1, r3, #2
	if (!(hfclk_users & HF_USER_BT)) {
 101e626:	07db      	lsls	r3, r3, #31
	hfclk_users &= ~HF_USER_GENERIC;
 101e628:	6011      	str	r1, [r2, #0]
	if (!(hfclk_users & HF_USER_BT)) {
 101e62a:	d402      	bmi.n	101e632 <generic_hfclk_stop+0x26>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
 101e62c:	2001      	movs	r0, #1
 101e62e:	f001 faad 	bl	101fb8c <nrfx_clock_stop>
	__asm__ volatile(
 101e632:	f384 8811 	msr	BASEPRI, r4
 101e636:	f3bf 8f6f 	isb	sy
}
 101e63a:	bd10      	pop	{r4, pc}
 101e63c:	21007f4c 	.word	0x21007f4c

0101e640 <z_nrf_clock_control_get_onoff>:
}
 101e640:	4b02      	ldr	r3, [pc, #8]	; (101e64c <z_nrf_clock_control_get_onoff+0xc>)
	return &data->mgr[type];
 101e642:	b2c0      	uxtb	r0, r0
}
 101e644:	eb03 1040 	add.w	r0, r3, r0, lsl #5
 101e648:	4770      	bx	lr
 101e64a:	bf00      	nop
 101e64c:	21007ef4 	.word	0x21007ef4

0101e650 <z_nrf_clock_bt_ctlr_hf_request>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 101e650:	4b07      	ldr	r3, [pc, #28]	; (101e670 <z_nrf_clock_bt_ctlr_hf_request+0x20>)
 101e652:	e8d3 2fef 	ldaex	r2, [r3]
 101e656:	f042 0101 	orr.w	r1, r2, #1
 101e65a:	e8c3 1fe0 	stlex	r0, r1, [r3]
 101e65e:	2800      	cmp	r0, #0
 101e660:	d1f7      	bne.n	101e652 <z_nrf_clock_bt_ctlr_hf_request+0x2>
	if (atomic_or(&hfclk_users, HF_USER_BT) & HF_USER_GENERIC) {
 101e662:	0793      	lsls	r3, r2, #30
 101e664:	d402      	bmi.n	101e66c <z_nrf_clock_bt_ctlr_hf_request+0x1c>
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
 101e666:	2001      	movs	r0, #1
 101e668:	f001 ba2e 	b.w	101fac8 <nrfx_clock_start>
}
 101e66c:	4770      	bx	lr
 101e66e:	bf00      	nop
 101e670:	21007f4c 	.word	0x21007f4c

0101e674 <z_nrf_clock_bt_ctlr_hf_release>:
{
 101e674:	b510      	push	{r4, lr}
	__asm__ volatile(
 101e676:	f04f 0320 	mov.w	r3, #32
 101e67a:	f3ef 8411 	mrs	r4, BASEPRI
 101e67e:	f383 8812 	msr	BASEPRI_MAX, r3
 101e682:	f3bf 8f6f 	isb	sy
	hfclk_users &= ~HF_USER_BT;
 101e686:	4a07      	ldr	r2, [pc, #28]	; (101e6a4 <z_nrf_clock_bt_ctlr_hf_release+0x30>)
 101e688:	6813      	ldr	r3, [r2, #0]
 101e68a:	f023 0101 	bic.w	r1, r3, #1
	if (!(hfclk_users & HF_USER_GENERIC)) {
 101e68e:	079b      	lsls	r3, r3, #30
	hfclk_users &= ~HF_USER_BT;
 101e690:	6011      	str	r1, [r2, #0]
	if (!(hfclk_users & HF_USER_GENERIC)) {
 101e692:	d402      	bmi.n	101e69a <z_nrf_clock_bt_ctlr_hf_release+0x26>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
 101e694:	2001      	movs	r0, #1
 101e696:	f001 fa79 	bl	101fb8c <nrfx_clock_stop>
	__asm__ volatile(
 101e69a:	f384 8811 	msr	BASEPRI, r4
 101e69e:	f3bf 8f6f 	isb	sy
}
 101e6a2:	bd10      	pop	{r4, pc}
 101e6a4:	21007f4c 	.word	0x21007f4c

0101e6a8 <z_nrf_clock_control_lf_on>:
{
 101e6a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 101e6ac:	2201      	movs	r2, #1
 101e6ae:	4606      	mov	r6, r0
 101e6b0:	4941      	ldr	r1, [pc, #260]	; (101e7b8 <z_nrf_clock_control_lf_on+0x110>)
 101e6b2:	e8d1 3fef 	ldaex	r3, [r1]
 101e6b6:	e8c1 2fe0 	stlex	r0, r2, [r1]
 101e6ba:	2800      	cmp	r0, #0
 101e6bc:	d1f9      	bne.n	101e6b2 <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
 101e6be:	b9a3      	cbnz	r3, 101e6ea <z_nrf_clock_control_lf_on+0x42>
 101e6c0:	493e      	ldr	r1, [pc, #248]	; (101e7bc <z_nrf_clock_control_lf_on+0x114>)
		err = onoff_request(mgr, &cli);
 101e6c2:	483f      	ldr	r0, [pc, #252]	; (101e7c0 <z_nrf_clock_control_lf_on+0x118>)
 101e6c4:	604b      	str	r3, [r1, #4]
 101e6c6:	60cb      	str	r3, [r1, #12]
 101e6c8:	608a      	str	r2, [r1, #8]
 101e6ca:	f7e4 fd6d 	bl	10031a8 <onoff_request>
		__ASSERT_NO_MSG(err >= 0);
 101e6ce:	2800      	cmp	r0, #0
 101e6d0:	da0b      	bge.n	101e6ea <z_nrf_clock_control_lf_on+0x42>
 101e6d2:	493c      	ldr	r1, [pc, #240]	; (101e7c4 <z_nrf_clock_control_lf_on+0x11c>)
 101e6d4:	f44f 730c 	mov.w	r3, #560	; 0x230
 101e6d8:	4a3b      	ldr	r2, [pc, #236]	; (101e7c8 <z_nrf_clock_control_lf_on+0x120>)
 101e6da:	483c      	ldr	r0, [pc, #240]	; (101e7cc <z_nrf_clock_control_lf_on+0x124>)
 101e6dc:	f006 fa7b 	bl	1024bd6 <assert_print>
 101e6e0:	f44f 710c 	mov.w	r1, #560	; 0x230
		__ASSERT_NO_MSG(false);
 101e6e4:	4838      	ldr	r0, [pc, #224]	; (101e7c8 <z_nrf_clock_control_lf_on+0x120>)
 101e6e6:	f006 fa6f 	bl	1024bc8 <assert_post_action>
	switch (start_mode) {
 101e6ea:	b35e      	cbz	r6, 101e744 <z_nrf_clock_control_lf_on+0x9c>
 101e6ec:	1e73      	subs	r3, r6, #1
 101e6ee:	2b01      	cmp	r3, #1
 101e6f0:	d858      	bhi.n	101e7a4 <z_nrf_clock_control_lf_on+0xfc>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
 101e6f2:	2e01      	cmp	r6, #1
 101e6f4:	d106      	bne.n	101e704 <z_nrf_clock_control_lf_on+0x5c>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
 101e6f6:	4b36      	ldr	r3, [pc, #216]	; (101e7d0 <z_nrf_clock_control_lf_on+0x128>)
 101e6f8:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
 101e6fc:	f003 0303 	and.w	r3, r3, #3
 101e700:	2b02      	cmp	r3, #2
 101e702:	d01f      	beq.n	101e744 <z_nrf_clock_control_lf_on+0x9c>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
 101e704:	f00a fdbd 	bl	1029282 <k_is_in_isr>
 101e708:	4605      	mov	r5, r0
 101e70a:	b9e8      	cbnz	r0, 101e748 <z_nrf_clock_control_lf_on+0xa0>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
 101e70c:	4b31      	ldr	r3, [pc, #196]	; (101e7d4 <z_nrf_clock_control_lf_on+0x12c>)
 101e70e:	781b      	ldrb	r3, [r3, #0]
 101e710:	b1d3      	cbz	r3, 101e748 <z_nrf_clock_control_lf_on+0xa0>
    p_reg->INTENCLR = mask;
 101e712:	2202      	movs	r2, #2
	int key = isr_mode ? irq_lock() : 0;
 101e714:	4607      	mov	r7, r0
 101e716:	4b2e      	ldr	r3, [pc, #184]	; (101e7d0 <z_nrf_clock_control_lf_on+0x128>)
 101e718:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 101e71c:	4c2c      	ldr	r4, [pc, #176]	; (101e7d0 <z_nrf_clock_control_lf_on+0x128>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 101e71e:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 101e7d8 <z_nrf_clock_control_lf_on+0x130>
 101e722:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 101e726:	f8d4 2418 	ldr.w	r2, [r4, #1048]	; 0x418
 101e72a:	03d2      	lsls	r2, r2, #15
 101e72c:	d516      	bpl.n	101e75c <z_nrf_clock_control_lf_on+0xb4>
	while (!(nrfx_clock_is_running(d, (void *)&type)
 101e72e:	f003 0303 	and.w	r3, r3, #3
 101e732:	2b02      	cmp	r3, #2
 101e734:	d001      	beq.n	101e73a <z_nrf_clock_control_lf_on+0x92>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
 101e736:	2e01      	cmp	r6, #1
 101e738:	d110      	bne.n	101e75c <z_nrf_clock_control_lf_on+0xb4>
	if (isr_mode) {
 101e73a:	b375      	cbz	r5, 101e79a <z_nrf_clock_control_lf_on+0xf2>
 101e73c:	f387 8811 	msr	BASEPRI, r7
 101e740:	f3bf 8f6f 	isb	sy
}
 101e744:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__asm__ volatile(
 101e748:	f04f 0320 	mov.w	r3, #32
 101e74c:	f3ef 8711 	mrs	r7, BASEPRI
 101e750:	f383 8812 	msr	BASEPRI_MAX, r3
 101e754:	f3bf 8f6f 	isb	sy
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
 101e758:	2501      	movs	r5, #1
 101e75a:	e7df      	b.n	101e71c <z_nrf_clock_control_lf_on+0x74>
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
 101e75c:	b1c5      	cbz	r5, 101e790 <z_nrf_clock_control_lf_on+0xe8>
 *
 * @param key Interrupt locking key obtained from irq_lock().
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
 101e75e:	4638      	mov	r0, r7
 101e760:	f7e7 fad2 	bl	1005d08 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
 101e764:	f8d4 3518 	ldr.w	r3, [r4, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
 101e768:	b2db      	uxtb	r3, r3
 101e76a:	2b01      	cmp	r3, #1
 101e76c:	d1d9      	bne.n	101e722 <z_nrf_clock_control_lf_on+0x7a>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
 101e76e:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
 101e772:	2a00      	cmp	r2, #0
 101e774:	d0d5      	beq.n	101e722 <z_nrf_clock_control_lf_on+0x7a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 101e776:	2200      	movs	r2, #0
 101e778:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
 101e77c:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
 101e780:	2202      	movs	r2, #2
 101e782:	f8c4 2518 	str.w	r2, [r4, #1304]	; 0x518
 101e786:	2220      	movs	r2, #32
 101e788:	f8c8 2180 	str.w	r2, [r8, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101e78c:	60a3      	str	r3, [r4, #8]
}
 101e78e:	e7c8      	b.n	101e722 <z_nrf_clock_control_lf_on+0x7a>
	return z_impl_k_sleep(timeout);
 101e790:	2100      	movs	r1, #0
 101e792:	2021      	movs	r0, #33	; 0x21
 101e794:	f004 fe2a 	bl	10233ec <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
 101e798:	e7e4      	b.n	101e764 <z_nrf_clock_control_lf_on+0xbc>
    p_reg->INTENSET = mask;
 101e79a:	2202      	movs	r2, #2
 101e79c:	4b0c      	ldr	r3, [pc, #48]	; (101e7d0 <z_nrf_clock_control_lf_on+0x128>)
 101e79e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
 101e7a2:	e7cf      	b.n	101e744 <z_nrf_clock_control_lf_on+0x9c>
		__ASSERT_NO_MSG(false);
 101e7a4:	490d      	ldr	r1, [pc, #52]	; (101e7dc <z_nrf_clock_control_lf_on+0x134>)
 101e7a6:	f240 2342 	movw	r3, #578	; 0x242
 101e7aa:	4a07      	ldr	r2, [pc, #28]	; (101e7c8 <z_nrf_clock_control_lf_on+0x120>)
 101e7ac:	4807      	ldr	r0, [pc, #28]	; (101e7cc <z_nrf_clock_control_lf_on+0x124>)
 101e7ae:	f006 fa12 	bl	1024bd6 <assert_print>
 101e7b2:	f240 2142 	movw	r1, #578	; 0x242
 101e7b6:	e795      	b.n	101e6e4 <z_nrf_clock_control_lf_on+0x3c>
 101e7b8:	21007ef0 	.word	0x21007ef0
 101e7bc:	21007ee0 	.word	0x21007ee0
 101e7c0:	21007f14 	.word	0x21007f14
 101e7c4:	0102c0b8 	.word	0x0102c0b8
 101e7c8:	0102ef26 	.word	0x0102ef26
 101e7cc:	0102b695 	.word	0x0102b695
 101e7d0:	41005000 	.word	0x41005000
 101e7d4:	21008768 	.word	0x21008768
 101e7d8:	e000e100 	.word	0xe000e100
 101e7dc:	0102ff6e 	.word	0x0102ff6e

0101e7e0 <rtt_console_init>:

	return character;
}

static int rtt_console_init(const struct device *d)
{
 101e7e0:	b510      	push	{r4, lr}
	ARG_UNUSED(d);

#ifdef CONFIG_PRINTK
	__printk_hook_install(rtt_console_out);
 101e7e2:	4c04      	ldr	r4, [pc, #16]	; (101e7f4 <rtt_console_init+0x14>)
 101e7e4:	4620      	mov	r0, r4
 101e7e6:	f7e4 f96b 	bl	1002ac0 <__printk_hook_install>
#endif
	__stdout_hook_install(rtt_console_out);
 101e7ea:	4620      	mov	r0, r4
 101e7ec:	f7e8 f9ec 	bl	1006bc8 <__stdout_hook_install>

	return 0;
}
 101e7f0:	2000      	movs	r0, #0
 101e7f2:	bd10      	pop	{r4, pc}
 101e7f4:	0101e7f9 	.word	0x0101e7f9

0101e7f8 <rtt_console_out>:
{
 101e7f8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 101e7fa:	4604      	mov	r4, r0
	char c = (char)character;
 101e7fc:	2503      	movs	r5, #3
 101e7fe:	4e12      	ldr	r6, [pc, #72]	; (101e848 <rtt_console_out+0x50>)
 101e800:	f88d 0007 	strb.w	r0, [sp, #7]
		SEGGER_RTT_LOCK();
 101e804:	f001 ff76 	bl	10206f4 <zephyr_rtt_mutex_lock>
		cnt = SEGGER_RTT_WriteNoLock(0, &c, 1);
 101e808:	2201      	movs	r2, #1
 101e80a:	2000      	movs	r0, #0
 101e80c:	f10d 0107 	add.w	r1, sp, #7
 101e810:	f001 ff3a 	bl	1020688 <SEGGER_RTT_WriteNoLock>
 101e814:	4607      	mov	r7, r0
		SEGGER_RTT_UNLOCK();
 101e816:	f001 ff77 	bl	1020708 <zephyr_rtt_mutex_unlock>
		if (cnt) {
 101e81a:	b127      	cbz	r7, 101e826 <rtt_console_out+0x2e>
			host_present = true;
 101e81c:	2301      	movs	r3, #1
 101e81e:	7033      	strb	r3, [r6, #0]
}
 101e820:	4620      	mov	r0, r4
 101e822:	b003      	add	sp, #12
 101e824:	bdf0      	pop	{r4, r5, r6, r7, pc}
		} else if (host_present) {
 101e826:	7833      	ldrb	r3, [r6, #0]
 101e828:	2b00      	cmp	r3, #0
 101e82a:	d0f9      	beq.n	101e820 <rtt_console_out+0x28>
			if (max_cnt) {
 101e82c:	3d01      	subs	r5, #1
 101e82e:	d008      	beq.n	101e842 <rtt_console_out+0x4a>
	if (!IS_ENABLED(CONFIG_MULTITHREADING) || k_is_in_isr()) {
 101e830:	f00a fd27 	bl	1029282 <k_is_in_isr>
 101e834:	2800      	cmp	r0, #0
 101e836:	d1e5      	bne.n	101e804 <rtt_console_out+0xc>
 101e838:	2100      	movs	r1, #0
 101e83a:	2042      	movs	r0, #66	; 0x42
 101e83c:	f004 fdd6 	bl	10233ec <z_impl_k_sleep>
		SEGGER_RTT_LOCK();
 101e840:	e7e0      	b.n	101e804 <rtt_console_out+0xc>
				host_present = false;
 101e842:	7035      	strb	r5, [r6, #0]
 101e844:	e7ec      	b.n	101e820 <rtt_console_out+0x28>
 101e846:	bf00      	nop
 101e848:	21008357 	.word	0x21008357

0101e84c <gpio_nrfx_manage_callback>:
}

static int gpio_nrfx_manage_callback(const struct device *port,
				     struct gpio_callback *callback,
				     bool set)
{
 101e84c:	b510      	push	{r4, lr}
	return port->data;
 101e84e:	6903      	ldr	r3, [r0, #16]
 */
static inline int gpio_manage_callback(sys_slist_t *callbacks,
					struct gpio_callback *callback,
					bool set)
{
	__ASSERT(callback, "No callback!");
 101e850:	b961      	cbnz	r1, 101e86c <gpio_nrfx_manage_callback+0x20>
 101e852:	4920      	ldr	r1, [pc, #128]	; (101e8d4 <gpio_nrfx_manage_callback+0x88>)
 101e854:	232a      	movs	r3, #42	; 0x2a
 101e856:	4a20      	ldr	r2, [pc, #128]	; (101e8d8 <gpio_nrfx_manage_callback+0x8c>)
 101e858:	4820      	ldr	r0, [pc, #128]	; (101e8dc <gpio_nrfx_manage_callback+0x90>)
 101e85a:	f006 f9bc 	bl	1024bd6 <assert_print>
 101e85e:	4820      	ldr	r0, [pc, #128]	; (101e8e0 <gpio_nrfx_manage_callback+0x94>)
 101e860:	f006 f9b9 	bl	1024bd6 <assert_print>
 101e864:	212a      	movs	r1, #42	; 0x2a
	__ASSERT(callback->handler, "No callback handler!");
 101e866:	481c      	ldr	r0, [pc, #112]	; (101e8d8 <gpio_nrfx_manage_callback+0x8c>)
 101e868:	f006 f9ae 	bl	1024bc8 <assert_post_action>
 101e86c:	6848      	ldr	r0, [r1, #4]
 101e86e:	b950      	cbnz	r0, 101e886 <gpio_nrfx_manage_callback+0x3a>
 101e870:	491c      	ldr	r1, [pc, #112]	; (101e8e4 <gpio_nrfx_manage_callback+0x98>)
 101e872:	232b      	movs	r3, #43	; 0x2b
 101e874:	4a18      	ldr	r2, [pc, #96]	; (101e8d8 <gpio_nrfx_manage_callback+0x8c>)
 101e876:	4819      	ldr	r0, [pc, #100]	; (101e8dc <gpio_nrfx_manage_callback+0x90>)
 101e878:	f006 f9ad 	bl	1024bd6 <assert_print>
 101e87c:	481a      	ldr	r0, [pc, #104]	; (101e8e8 <gpio_nrfx_manage_callback+0x9c>)
 101e87e:	f006 f9aa 	bl	1024bd6 <assert_print>
 101e882:	212b      	movs	r1, #43	; 0x2b
 101e884:	e7ef      	b.n	101e866 <gpio_nrfx_manage_callback+0x1a>
	return list->head;
 101e886:	6858      	ldr	r0, [r3, #4]

	if (!sys_slist_is_empty(callbacks)) {
 101e888:	b1f8      	cbz	r0, 101e8ca <gpio_nrfx_manage_callback+0x7e>
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 101e88a:	4288      	cmp	r0, r1
 101e88c:	d119      	bne.n	101e8c2 <gpio_nrfx_manage_callback+0x76>
Z_GENLIST_REMOVE(slist, snode)
 101e88e:	689c      	ldr	r4, [r3, #8]
	return node->next;
 101e890:	6808      	ldr	r0, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
 101e892:	42a1      	cmp	r1, r4
	list->head = node;
 101e894:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
 101e896:	d100      	bne.n	101e89a <gpio_nrfx_manage_callback+0x4e>
	list->tail = node;
 101e898:	6098      	str	r0, [r3, #8]
	parent->next = child;
 101e89a:	2000      	movs	r0, #0
 101e89c:	6008      	str	r0, [r1, #0]
		}
	} else if (!set) {
		return -EINVAL;
	}

	if (set) {
 101e89e:	b12a      	cbz	r2, 101e8ac <gpio_nrfx_manage_callback+0x60>
	return list->head;
 101e8a0:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
 101e8a2:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
 101e8a4:	689a      	ldr	r2, [r3, #8]
	list->head = node;
 101e8a6:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
 101e8a8:	b902      	cbnz	r2, 101e8ac <gpio_nrfx_manage_callback+0x60>
	list->tail = node;
 101e8aa:	6099      	str	r1, [r3, #8]
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
 101e8ac:	2000      	movs	r0, #0
	return gpio_manage_callback(&get_port_data(port)->callbacks,
 101e8ae:	e010      	b.n	101e8d2 <gpio_nrfx_manage_callback+0x86>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 101e8b0:	4281      	cmp	r1, r0
 101e8b2:	d106      	bne.n	101e8c2 <gpio_nrfx_manage_callback+0x76>
	return node->next;
 101e8b4:	6808      	ldr	r0, [r1, #0]
	parent->next = child;
 101e8b6:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
 101e8b8:	6898      	ldr	r0, [r3, #8]
 101e8ba:	4281      	cmp	r1, r0
 101e8bc:	d1ed      	bne.n	101e89a <gpio_nrfx_manage_callback+0x4e>
	list->tail = node;
 101e8be:	609c      	str	r4, [r3, #8]
}
 101e8c0:	e7eb      	b.n	101e89a <gpio_nrfx_manage_callback+0x4e>
	return node->next;
 101e8c2:	4604      	mov	r4, r0
 101e8c4:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 101e8c6:	2800      	cmp	r0, #0
 101e8c8:	d1f2      	bne.n	101e8b0 <gpio_nrfx_manage_callback+0x64>
			if (!set) {
 101e8ca:	2a00      	cmp	r2, #0
 101e8cc:	d1e8      	bne.n	101e8a0 <gpio_nrfx_manage_callback+0x54>
				return -EINVAL;
 101e8ce:	f06f 0015 	mvn.w	r0, #21
				     callback, set);
}
 101e8d2:	bd10      	pop	{r4, pc}
 101e8d4:	0102efec 	.word	0x0102efec
 101e8d8:	0102efb0 	.word	0x0102efb0
 101e8dc:	0102b695 	.word	0x0102b695
 101e8e0:	0102eff5 	.word	0x0102eff5
 101e8e4:	0102f004 	.word	0x0102f004
 101e8e8:	0102f016 	.word	0x0102f016

0101e8ec <gpio_nrfx_pin_interrupt_configure>:
{
 101e8ec:	b530      	push	{r4, r5, lr}
	return port->config;
 101e8ee:	6840      	ldr	r0, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
 101e8f0:	f001 041f 	and.w	r4, r1, #31
 101e8f4:	7b05      	ldrb	r5, [r0, #12]
	if (mode == GPIO_INT_MODE_DISABLED) {
 101e8f6:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
{
 101e8fa:	b085      	sub	sp, #20
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
 101e8fc:	ea44 1445 	orr.w	r4, r4, r5, lsl #5
	if (mode == GPIO_INT_MODE_DISABLED) {
 101e900:	d105      	bne.n	101e90e <gpio_nrfx_pin_interrupt_configure+0x22>
		nrfx_gpiote_trigger_disable(abs_pin);
 101e902:	4620      	mov	r0, r4
 101e904:	f001 fc58 	bl	10201b8 <nrfx_gpiote_trigger_disable>
		return 0;
 101e908:	2000      	movs	r0, #0
}
 101e90a:	b005      	add	sp, #20
 101e90c:	bd30      	pop	{r4, r5, pc}
	nrfx_gpiote_trigger_config_t trigger_config = {
 101e90e:	2500      	movs	r5, #0
	if (mode == GPIO_INT_MODE_LEVEL) {
 101e910:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
	nrfx_gpiote_trigger_config_t trigger_config = {
 101e914:	e9cd 5502 	strd	r5, r5, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
 101e918:	d114      	bne.n	101e944 <gpio_nrfx_pin_interrupt_configure+0x58>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
 101e91a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
	nrfx_gpiote_trigger_config_t trigger_config = {
 101e91e:	bf0c      	ite	eq
 101e920:	2304      	moveq	r3, #4
 101e922:	2305      	movne	r3, #5
 101e924:	f88d 3008 	strb.w	r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
 101e928:	2300      	movs	r3, #0
 101e92a:	4620      	mov	r0, r4
 101e92c:	4619      	mov	r1, r3
 101e92e:	aa02      	add	r2, sp, #8
 101e930:	f001 fa4a 	bl	101fdc8 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
 101e934:	4b2a      	ldr	r3, [pc, #168]	; (101e9e0 <gpio_nrfx_pin_interrupt_configure+0xf4>)
 101e936:	4298      	cmp	r0, r3
 101e938:	d14f      	bne.n	101e9da <gpio_nrfx_pin_interrupt_configure+0xee>
	nrfx_gpiote_trigger_enable(abs_pin, true);
 101e93a:	2101      	movs	r1, #1
 101e93c:	4620      	mov	r0, r4
 101e93e:	f001 fbcf 	bl	10200e0 <nrfx_gpiote_trigger_enable>
	return 0;
 101e942:	e7e1      	b.n	101e908 <gpio_nrfx_pin_interrupt_configure+0x1c>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
 101e944:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
 101e948:	d024      	beq.n	101e994 <gpio_nrfx_pin_interrupt_configure+0xa8>
 101e94a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 101e94e:	bf14      	ite	ne
 101e950:	2301      	movne	r3, #1
 101e952:	2302      	moveq	r3, #2
	nrfx_gpiote_trigger_config_t trigger_config = {
 101e954:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
 101e958:	6883      	ldr	r3, [r0, #8]
 101e95a:	40cb      	lsrs	r3, r1
 101e95c:	07d8      	lsls	r0, r3, #31
 101e95e:	d4e3      	bmi.n	101e928 <gpio_nrfx_pin_interrupt_configure+0x3c>
 101e960:	f1b2 7fa0 	cmp.w	r2, #20971520	; 0x1400000
 101e964:	d1e0      	bne.n	101e928 <gpio_nrfx_pin_interrupt_configure+0x3c>
NRF_STATIC_INLINE bool nrf_gpio_pin_present_check(uint32_t pin_number)
{
    uint32_t port = pin_number >> 5;
    uint32_t mask = 0;

    switch (port)
 101e966:	0962      	lsrs	r2, r4, #5
 101e968:	f004 031f 	and.w	r3, r4, #31
 101e96c:	d014      	beq.n	101e998 <gpio_nrfx_pin_interrupt_configure+0xac>
 101e96e:	2a01      	cmp	r2, #1
 101e970:	d104      	bne.n	101e97c <gpio_nrfx_pin_interrupt_configure+0x90>
#endif
    }

    pin_number &= 0x1F;

    return (mask & (1UL << pin_number)) ? true : false;
 101e972:	f64f 72ff 	movw	r2, #65535	; 0xffff
 101e976:	40da      	lsrs	r2, r3
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
 101e978:	07d1      	lsls	r1, r2, #31
 101e97a:	d414      	bmi.n	101e9a6 <gpio_nrfx_pin_interrupt_configure+0xba>
 101e97c:	4919      	ldr	r1, [pc, #100]	; (101e9e4 <gpio_nrfx_pin_interrupt_configure+0xf8>)
 101e97e:	481a      	ldr	r0, [pc, #104]	; (101e9e8 <gpio_nrfx_pin_interrupt_configure+0xfc>)
 101e980:	f240 2347 	movw	r3, #583	; 0x247
 101e984:	4a19      	ldr	r2, [pc, #100]	; (101e9ec <gpio_nrfx_pin_interrupt_configure+0x100>)
 101e986:	f006 f926 	bl	1024bd6 <assert_print>
 101e98a:	f240 2147 	movw	r1, #583	; 0x247
 101e98e:	4817      	ldr	r0, [pc, #92]	; (101e9ec <gpio_nrfx_pin_interrupt_configure+0x100>)
 101e990:	f006 f91a 	bl	1024bc8 <assert_post_action>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
 101e994:	2303      	movs	r3, #3
 101e996:	e7dd      	b.n	101e954 <gpio_nrfx_pin_interrupt_configure+0x68>
    return (mask & (1UL << pin_number)) ? true : false;
 101e998:	f04f 32ff 	mov.w	r2, #4294967295
 101e99c:	40da      	lsrs	r2, r3
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
 101e99e:	07d2      	lsls	r2, r2, #31
 101e9a0:	d5ec      	bpl.n	101e97c <gpio_nrfx_pin_interrupt_configure+0x90>
        case 0: return NRF_P0;
 101e9a2:	4a13      	ldr	r2, [pc, #76]	; (101e9f0 <gpio_nrfx_pin_interrupt_configure+0x104>)
 101e9a4:	e000      	b.n	101e9a8 <gpio_nrfx_pin_interrupt_configure+0xbc>
        case 1: return NRF_P1;
 101e9a6:	4a13      	ldr	r2, [pc, #76]	; (101e9f4 <gpio_nrfx_pin_interrupt_configure+0x108>)
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
 101e9a8:	3380      	adds	r3, #128	; 0x80
 101e9aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
 101e9ae:	07db      	lsls	r3, r3, #31
 101e9b0:	d4ba      	bmi.n	101e928 <gpio_nrfx_pin_interrupt_configure+0x3c>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
 101e9b2:	f10d 0507 	add.w	r5, sp, #7
 101e9b6:	4629      	mov	r1, r5
 101e9b8:	4620      	mov	r0, r4
 101e9ba:	f001 fb2b 	bl	1020014 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
 101e9be:	4b0e      	ldr	r3, [pc, #56]	; (101e9f8 <gpio_nrfx_pin_interrupt_configure+0x10c>)
 101e9c0:	4298      	cmp	r0, r3
 101e9c2:	d001      	beq.n	101e9c8 <gpio_nrfx_pin_interrupt_configure+0xdc>
		trigger_config.p_in_channel = &ch;
 101e9c4:	9503      	str	r5, [sp, #12]
 101e9c6:	e7af      	b.n	101e928 <gpio_nrfx_pin_interrupt_configure+0x3c>
			err = nrfx_gpiote_channel_alloc(&ch);
 101e9c8:	4628      	mov	r0, r5
 101e9ca:	f001 fb83 	bl	10200d4 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
 101e9ce:	4b04      	ldr	r3, [pc, #16]	; (101e9e0 <gpio_nrfx_pin_interrupt_configure+0xf4>)
 101e9d0:	4298      	cmp	r0, r3
 101e9d2:	d0f7      	beq.n	101e9c4 <gpio_nrfx_pin_interrupt_configure+0xd8>
				return -ENOMEM;
 101e9d4:	f06f 000b 	mvn.w	r0, #11
 101e9d8:	e797      	b.n	101e90a <gpio_nrfx_pin_interrupt_configure+0x1e>
		return -EINVAL;
 101e9da:	f06f 0015 	mvn.w	r0, #21
 101e9de:	e794      	b.n	101e90a <gpio_nrfx_pin_interrupt_configure+0x1e>
 101e9e0:	0bad0000 	.word	0x0bad0000
 101e9e4:	0102f060 	.word	0x0102f060
 101e9e8:	0102b695 	.word	0x0102b695
 101e9ec:	0102f02d 	.word	0x0102f02d
 101e9f0:	418c0500 	.word	0x418c0500
 101e9f4:	418c0800 	.word	0x418c0800
 101e9f8:	0bad0004 	.word	0x0bad0004

0101e9fc <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
 101e9fc:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
 101e9fe:	f001 fb59 	bl	10200b4 <nrfx_gpiote_is_init>
 101ea02:	4604      	mov	r4, r0
 101ea04:	b968      	cbnz	r0, 101ea22 <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
 101ea06:	f001 fb2d 	bl	1020064 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
 101ea0a:	4b08      	ldr	r3, [pc, #32]	; (101ea2c <gpio_nrfx_init+0x30>)
 101ea0c:	4298      	cmp	r0, r3
 101ea0e:	d10a      	bne.n	101ea26 <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
 101ea10:	4621      	mov	r1, r4
 101ea12:	4807      	ldr	r0, [pc, #28]	; (101ea30 <gpio_nrfx_init+0x34>)
 101ea14:	f001 faf8 	bl	1020008 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
 101ea18:	4622      	mov	r2, r4
 101ea1a:	2105      	movs	r1, #5
 101ea1c:	200a      	movs	r0, #10
 101ea1e:	f7e7 fa13 	bl	1005e48 <z_arm_irq_priority_set>
		return 0;
 101ea22:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
 101ea24:	bd10      	pop	{r4, pc}
		return -EIO;
 101ea26:	f06f 0004 	mvn.w	r0, #4
 101ea2a:	e7fb      	b.n	101ea24 <gpio_nrfx_init+0x28>
 101ea2c:	0bad0000 	.word	0x0bad0000
 101ea30:	0101ea35 	.word	0x0101ea35

0101ea34 <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
 101ea34:	0942      	lsrs	r2, r0, #5
{
 101ea36:	4603      	mov	r3, r0
 101ea38:	b570      	push	{r4, r5, r6, lr}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
 101ea3a:	d002      	beq.n	101ea42 <nrfx_gpio_handler+0xe>
 101ea3c:	2a01      	cmp	r2, #1
 101ea3e:	d01e      	beq.n	101ea7e <nrfx_gpio_handler+0x4a>
}
 101ea40:	bd70      	pop	{r4, r5, r6, pc}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
 101ea42:	4e14      	ldr	r6, [pc, #80]	; (101ea94 <nrfx_gpio_handler+0x60>)
	gpio_fire_callbacks(list, port, BIT(pin));
 101ea44:	6932      	ldr	r2, [r6, #16]
 101ea46:	6851      	ldr	r1, [r2, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 101ea48:	2900      	cmp	r1, #0
 101ea4a:	d0f9      	beq.n	101ea40 <nrfx_gpio_handler+0xc>
 101ea4c:	2501      	movs	r5, #1
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
 101ea4e:	f003 031f 	and.w	r3, r3, #31
	return node->next;
 101ea52:	680c      	ldr	r4, [r1, #0]
 101ea54:	409d      	lsls	r5, r3
 101ea56:	2900      	cmp	r1, #0
 101ea58:	d0f2      	beq.n	101ea40 <nrfx_gpio_handler+0xc>
		if (cb->pin_mask & pins) {
 101ea5a:	688a      	ldr	r2, [r1, #8]
 101ea5c:	402a      	ands	r2, r5
 101ea5e:	d012      	beq.n	101ea86 <nrfx_gpio_handler+0x52>
			__ASSERT(cb->handler, "No callback handler!");
 101ea60:	684b      	ldr	r3, [r1, #4]
 101ea62:	b973      	cbnz	r3, 101ea82 <nrfx_gpio_handler+0x4e>
 101ea64:	490c      	ldr	r1, [pc, #48]	; (101ea98 <nrfx_gpio_handler+0x64>)
 101ea66:	234d      	movs	r3, #77	; 0x4d
 101ea68:	4a0c      	ldr	r2, [pc, #48]	; (101ea9c <nrfx_gpio_handler+0x68>)
 101ea6a:	480d      	ldr	r0, [pc, #52]	; (101eaa0 <nrfx_gpio_handler+0x6c>)
 101ea6c:	f006 f8b3 	bl	1024bd6 <assert_print>
 101ea70:	480c      	ldr	r0, [pc, #48]	; (101eaa4 <nrfx_gpio_handler+0x70>)
 101ea72:	f006 f8b0 	bl	1024bd6 <assert_print>
 101ea76:	214d      	movs	r1, #77	; 0x4d
 101ea78:	4808      	ldr	r0, [pc, #32]	; (101ea9c <nrfx_gpio_handler+0x68>)
 101ea7a:	f006 f8a5 	bl	1024bc8 <assert_post_action>
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
 101ea7e:	4e0a      	ldr	r6, [pc, #40]	; (101eaa8 <nrfx_gpio_handler+0x74>)
 101ea80:	e7e0      	b.n	101ea44 <nrfx_gpio_handler+0x10>
			cb->handler(port, cb, cb->pin_mask & pins);
 101ea82:	4630      	mov	r0, r6
 101ea84:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 101ea86:	b11c      	cbz	r4, 101ea90 <nrfx_gpio_handler+0x5c>
 101ea88:	6823      	ldr	r3, [r4, #0]
 101ea8a:	4621      	mov	r1, r4
 101ea8c:	461c      	mov	r4, r3
 101ea8e:	e7e2      	b.n	101ea56 <nrfx_gpio_handler+0x22>
 101ea90:	4623      	mov	r3, r4
 101ea92:	e7fa      	b.n	101ea8a <nrfx_gpio_handler+0x56>
 101ea94:	01029718 	.word	0x01029718
 101ea98:	0102f083 	.word	0x0102f083
 101ea9c:	0102efb0 	.word	0x0102efb0
 101eaa0:	0102b695 	.word	0x0102b695
 101eaa4:	0102f016 	.word	0x0102f016
 101eaa8:	01029700 	.word	0x01029700

0101eaac <gpio_nrfx_pin_configure>:
{
 101eaac:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	return port->config;
 101eab0:	f8d0 8004 	ldr.w	r8, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 101eab4:	f001 051f 	and.w	r5, r1, #31
 101eab8:	f898 300c 	ldrb.w	r3, [r8, #12]
{
 101eabc:	4614      	mov	r4, r2
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 101eabe:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
{
 101eac2:	460f      	mov	r7, r1
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
 101eac4:	4628      	mov	r0, r5
 101eac6:	f10d 0103 	add.w	r1, sp, #3
 101eaca:	f001 faa3 	bl	1020014 <nrfx_gpiote_channel_get>
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
 101eace:	f414 3f40 	tst.w	r4, #196608	; 0x30000
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
 101ead2:	4606      	mov	r6, r0
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
 101ead4:	d115      	bne.n	101eb02 <gpio_nrfx_pin_configure+0x56>
		(void)nrfx_gpiote_pin_uninit(abs_pin);
 101ead6:	4628      	mov	r0, r5
 101ead8:	f001 fb98 	bl	102020c <nrfx_gpiote_pin_uninit>
		if (free_ch) {
 101eadc:	4b48      	ldr	r3, [pc, #288]	; (101ec00 <gpio_nrfx_pin_configure+0x154>)
 101eade:	429e      	cmp	r6, r3
 101eae0:	d170      	bne.n	101ebc4 <gpio_nrfx_pin_configure+0x118>
			err = nrfx_gpiote_channel_free(ch);
 101eae2:	f89d 0003 	ldrb.w	r0, [sp, #3]
 101eae6:	f001 faef 	bl	10200c8 <nrfx_gpiote_channel_free>
			__ASSERT_NO_MSG(err == NRFX_SUCCESS);
 101eaea:	42b0      	cmp	r0, r6
 101eaec:	d06a      	beq.n	101ebc4 <gpio_nrfx_pin_configure+0x118>
 101eaee:	4945      	ldr	r1, [pc, #276]	; (101ec04 <gpio_nrfx_pin_configure+0x158>)
 101eaf0:	236a      	movs	r3, #106	; 0x6a
 101eaf2:	4a45      	ldr	r2, [pc, #276]	; (101ec08 <gpio_nrfx_pin_configure+0x15c>)
 101eaf4:	4845      	ldr	r0, [pc, #276]	; (101ec0c <gpio_nrfx_pin_configure+0x160>)
 101eaf6:	f006 f86e 	bl	1024bd6 <assert_print>
 101eafa:	216a      	movs	r1, #106	; 0x6a
		__ASSERT_NO_MSG(err == NRFX_SUCCESS);
 101eafc:	4842      	ldr	r0, [pc, #264]	; (101ec08 <gpio_nrfx_pin_configure+0x15c>)
 101eafe:	f006 f863 	bl	1024bc8 <assert_post_action>
	nrfx_gpiote_trigger_config_t trigger_config = {
 101eb02:	2300      	movs	r3, #0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
 101eb04:	4628      	mov	r0, r5
 101eb06:	4619      	mov	r1, r3
 101eb08:	aa02      	add	r2, sp, #8
	nrfx_gpiote_trigger_config_t trigger_config = {
 101eb0a:	e9cd 3302 	strd	r3, r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
 101eb0e:	f001 f95b 	bl	101fdc8 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
 101eb12:	4b3b      	ldr	r3, [pc, #236]	; (101ec00 <gpio_nrfx_pin_configure+0x154>)
 101eb14:	4298      	cmp	r0, r3
 101eb16:	d004      	beq.n	101eb22 <gpio_nrfx_pin_configure+0x76>
		return NRF_GPIO_PIN_PULLUP;
 101eb18:	f06f 0015 	mvn.w	r0, #21
}
 101eb1c:	b004      	add	sp, #16
 101eb1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (free_ch) {
 101eb22:	4286      	cmp	r6, r0
 101eb24:	d10d      	bne.n	101eb42 <gpio_nrfx_pin_configure+0x96>
		err = nrfx_gpiote_channel_free(ch);
 101eb26:	f89d 0003 	ldrb.w	r0, [sp, #3]
 101eb2a:	f001 facd 	bl	10200c8 <nrfx_gpiote_channel_free>
		__ASSERT_NO_MSG(err == NRFX_SUCCESS);
 101eb2e:	42b0      	cmp	r0, r6
 101eb30:	d007      	beq.n	101eb42 <gpio_nrfx_pin_configure+0x96>
 101eb32:	4934      	ldr	r1, [pc, #208]	; (101ec04 <gpio_nrfx_pin_configure+0x158>)
 101eb34:	237c      	movs	r3, #124	; 0x7c
 101eb36:	4a34      	ldr	r2, [pc, #208]	; (101ec08 <gpio_nrfx_pin_configure+0x15c>)
 101eb38:	4834      	ldr	r0, [pc, #208]	; (101ec0c <gpio_nrfx_pin_configure+0x160>)
 101eb3a:	f006 f84c 	bl	1024bd6 <assert_print>
 101eb3e:	217c      	movs	r1, #124	; 0x7c
 101eb40:	e7dc      	b.n	101eafc <gpio_nrfx_pin_configure+0x50>
	if (flags & GPIO_OUTPUT) {
 101eb42:	03a6      	lsls	r6, r4, #14
 101eb44:	d54c      	bpl.n	101ebe0 <gpio_nrfx_pin_configure+0x134>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
 101eb46:	f240 3306 	movw	r3, #774	; 0x306
 101eb4a:	4023      	ands	r3, r4
 101eb4c:	f5b3 7f83 	cmp.w	r3, #262	; 0x106
 101eb50:	d019      	beq.n	101eb86 <gpio_nrfx_pin_configure+0xda>
 101eb52:	d80c      	bhi.n	101eb6e <gpio_nrfx_pin_configure+0xc2>
 101eb54:	2b06      	cmp	r3, #6
 101eb56:	d017      	beq.n	101eb88 <gpio_nrfx_pin_configure+0xdc>
 101eb58:	d804      	bhi.n	101eb64 <gpio_nrfx_pin_configure+0xb8>
 101eb5a:	b1ab      	cbz	r3, 101eb88 <gpio_nrfx_pin_configure+0xdc>
 101eb5c:	2b02      	cmp	r3, #2
 101eb5e:	d1db      	bne.n	101eb18 <gpio_nrfx_pin_configure+0x6c>
		*drive = NRF_GPIO_PIN_D0S1;
 101eb60:	2304      	movs	r3, #4
 101eb62:	e011      	b.n	101eb88 <gpio_nrfx_pin_configure+0xdc>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
 101eb64:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 101eb68:	d1d6      	bne.n	101eb18 <gpio_nrfx_pin_configure+0x6c>
		*drive = NRF_GPIO_PIN_H0S1;
 101eb6a:	2301      	movs	r3, #1
 101eb6c:	e00c      	b.n	101eb88 <gpio_nrfx_pin_configure+0xdc>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
 101eb6e:	f240 2202 	movw	r2, #514	; 0x202
 101eb72:	4293      	cmp	r3, r2
 101eb74:	d028      	beq.n	101ebc8 <gpio_nrfx_pin_configure+0x11c>
 101eb76:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 101eb7a:	d027      	beq.n	101ebcc <gpio_nrfx_pin_configure+0x120>
 101eb7c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 101eb80:	d1ca      	bne.n	101eb18 <gpio_nrfx_pin_configure+0x6c>
		*drive = NRF_GPIO_PIN_S0H1;
 101eb82:	2302      	movs	r3, #2
 101eb84:	e000      	b.n	101eb88 <gpio_nrfx_pin_configure+0xdc>
		*drive = NRF_GPIO_PIN_H0D1;
 101eb86:	2307      	movs	r3, #7
		nrfx_gpiote_output_config_t output_config = {
 101eb88:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
 101eb8c:	f484 3380 	eor.w	r3, r4, #65536	; 0x10000
 101eb90:	f3c3 4300 	ubfx	r3, r3, #16, #1
	if (flags & GPIO_PULL_UP) {
 101eb94:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
 101eb96:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLUP;
 101eb9a:	bf4c      	ite	mi
 101eb9c:	2303      	movmi	r3, #3
	} else if (flags & GPIO_PULL_DOWN) {
 101eb9e:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
 101eba2:	0321      	lsls	r1, r4, #12
		nrfx_gpiote_output_config_t output_config = {
 101eba4:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
 101eba8:	d512      	bpl.n	101ebd0 <gpio_nrfx_pin_configure+0x124>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
 101ebaa:	2301      	movs	r3, #1
 101ebac:	f8d8 2004 	ldr.w	r2, [r8, #4]
 101ebb0:	40bb      	lsls	r3, r7
    p_reg->OUTSET = set_mask;
 101ebb2:	6093      	str	r3, [r2, #8]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
 101ebb4:	2200      	movs	r2, #0
 101ebb6:	4628      	mov	r0, r5
 101ebb8:	a901      	add	r1, sp, #4
 101ebba:	f001 f9ad 	bl	101ff18 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
 101ebbe:	4b10      	ldr	r3, [pc, #64]	; (101ec00 <gpio_nrfx_pin_configure+0x154>)
 101ebc0:	4298      	cmp	r0, r3
 101ebc2:	d1a9      	bne.n	101eb18 <gpio_nrfx_pin_configure+0x6c>
 101ebc4:	2000      	movs	r0, #0
 101ebc6:	e7a9      	b.n	101eb1c <gpio_nrfx_pin_configure+0x70>
		*drive = NRF_GPIO_PIN_D0H1;
 101ebc8:	2305      	movs	r3, #5
 101ebca:	e7dd      	b.n	101eb88 <gpio_nrfx_pin_configure+0xdc>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
 101ebcc:	2303      	movs	r3, #3
 101ebce:	e7db      	b.n	101eb88 <gpio_nrfx_pin_configure+0xdc>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
 101ebd0:	0362      	lsls	r2, r4, #13
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
 101ebd2:	bf41      	itttt	mi
 101ebd4:	2301      	movmi	r3, #1
 101ebd6:	f8d8 2004 	ldrmi.w	r2, [r8, #4]
 101ebda:	40bb      	lslmi	r3, r7
    p_reg->OUTCLR = clr_mask;
 101ebdc:	60d3      	strmi	r3, [r2, #12]
}
 101ebde:	e7e9      	b.n	101ebb4 <gpio_nrfx_pin_configure+0x108>
	if (flags & GPIO_PULL_UP) {
 101ebe0:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
 101ebe2:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
 101ebe6:	bf4c      	ite	mi
 101ebe8:	2403      	movmi	r4, #3
	} else if (flags & GPIO_PULL_DOWN) {
 101ebea:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
 101ebee:	461a      	mov	r2, r3
 101ebf0:	4628      	mov	r0, r5
 101ebf2:	a901      	add	r1, sp, #4
	nrfx_gpiote_input_config_t input_config = {
 101ebf4:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
 101ebf8:	f001 f8e6 	bl	101fdc8 <nrfx_gpiote_input_configure>
 101ebfc:	e7df      	b.n	101ebbe <gpio_nrfx_pin_configure+0x112>
 101ebfe:	bf00      	nop
 101ec00:	0bad0000 	.word	0x0bad0000
 101ec04:	0102f0bb 	.word	0x0102f0bb
 101ec08:	0102f08f 	.word	0x0102f08f
 101ec0c:	0102b695 	.word	0x0102b695

0101ec10 <flash_nrf_pages_layout>:

static void flash_nrf_pages_layout(const struct device *dev,
				     const struct flash_pages_layout **layout,
				     size_t *layout_size)
{
	*layout = &dev_layout;
 101ec10:	4b02      	ldr	r3, [pc, #8]	; (101ec1c <flash_nrf_pages_layout+0xc>)
 101ec12:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
 101ec14:	2301      	movs	r3, #1
 101ec16:	6013      	str	r3, [r2, #0]
}
 101ec18:	4770      	bx	lr
 101ec1a:	bf00      	nop
 101ec1c:	21007f68 	.word	0x21007f68

0101ec20 <flash_nrf_get_parameters>:
flash_nrf_get_parameters(const struct device *dev)
{
	ARG_UNUSED(dev);

	return &flash_nrf_parameters;
}
 101ec20:	4800      	ldr	r0, [pc, #0]	; (101ec24 <flash_nrf_get_parameters+0x4>)
 101ec22:	4770      	bx	lr
 101ec24:	0102b3bc 	.word	0x0102b3bc

0101ec28 <flash_nrf_read.part.0>:
static int flash_nrf_read(const struct device *dev, off_t addr,
 101ec28:	b580      	push	{r7, lr}
 101ec2a:	af00      	add	r7, sp, #0
		LOG_ERR("invalid address: 0x%08lx:%zu",
 101ec2c:	b088      	sub	sp, #32
 101ec2e:	466a      	mov	r2, sp
 101ec30:	4b08      	ldr	r3, [pc, #32]	; (101ec54 <flash_nrf_read.part.0+0x2c>)
 101ec32:	61d1      	str	r1, [r2, #28]
 101ec34:	e9c2 3005 	strd	r3, r0, [r2, #20]
 101ec38:	2304      	movs	r3, #4
 101ec3a:	f842 3f10 	str.w	r3, [r2, #16]!
 101ec3e:	2300      	movs	r3, #0
 101ec40:	f44f 5101 	mov.w	r1, #8256	; 0x2040
 101ec44:	4804      	ldr	r0, [pc, #16]	; (101ec58 <flash_nrf_read.part.0+0x30>)
 101ec46:	f7e5 fd5f 	bl	1004708 <z_impl_z_log_msg_static_create>
}
 101ec4a:	f06f 0015 	mvn.w	r0, #21
 101ec4e:	46bd      	mov	sp, r7
 101ec50:	bd80      	pop	{r7, pc}
 101ec52:	bf00      	nop
 101ec54:	0102f0dd 	.word	0x0102f0dd
 101ec58:	01029a04 	.word	0x01029a04

0101ec5c <nrf_flash_init>:
	.page_layout = flash_nrf_pages_layout,
#endif
};

static int nrf_flash_init(const struct device *dev)
{
 101ec5c:	b510      	push	{r4, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
 101ec5e:	2201      	movs	r2, #1
 101ec60:	4807      	ldr	r0, [pc, #28]	; (101ec80 <nrf_flash_init+0x24>)
 101ec62:	4611      	mov	r1, r2
 101ec64:	f00a fb57 	bl	1029316 <z_impl_k_sem_init>
	SYNC_INIT();

#ifndef CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE
	nrf_flash_sync_init();
 101ec68:	f000 fa36 	bl	101f0d8 <nrf_flash_sync_init>
#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */

#if defined(CONFIG_FLASH_PAGE_LAYOUT)
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
 101ec6c:	f00a fa85 	bl	102917a <nrfx_nvmc_flash_page_count_get>
 101ec70:	4c04      	ldr	r4, [pc, #16]	; (101ec84 <nrf_flash_init+0x28>)
 101ec72:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
 101ec74:	f00a fa7e 	bl	1029174 <nrfx_nvmc_flash_page_size_get>
 101ec78:	6060      	str	r0, [r4, #4]
#endif

	return 0;
}
 101ec7a:	2000      	movs	r0, #0
 101ec7c:	bd10      	pop	{r4, pc}
 101ec7e:	bf00      	nop
 101ec80:	21007f70 	.word	0x21007f70
 101ec84:	21007f68 	.word	0x21007f68

0101ec88 <write_op>:
	w_ctx->data_addr += shift;
	w_ctx->len -= shift;
}

static int write_op(void *context)
{
 101ec88:	b538      	push	{r3, r4, r5, lr}
	struct flash_context *w_ctx = context;

#ifndef CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE
	uint32_t i = 1U;

	if (w_ctx->enable_time_limit) {
 101ec8a:	7b03      	ldrb	r3, [r0, #12]
{
 101ec8c:	4604      	mov	r4, r0
	if (w_ctx->enable_time_limit) {
 101ec8e:	b10b      	cbz	r3, 101ec94 <write_op+0xc>
		nrf_flash_sync_get_timestamp_begin();
 101ec90:	f000 fa34 	bl	101f0fc <nrf_flash_sync_get_timestamp_begin>
{
 101ec94:	2501      	movs	r5, #1
		}
#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */
	}
#endif /* CONFIG_SOC_FLASH_NRF_EMULATE_ONE_BYTE_WRITE_ACCESS */
	/* Write all the 4-byte aligned data */
	while (w_ctx->len >= sizeof(uint32_t)) {
 101ec96:	68a3      	ldr	r3, [r4, #8]
 101ec98:	2b03      	cmp	r3, #3
 101ec9a:	d806      	bhi.n	101ecaa <write_op+0x22>
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
 101ec9c:	4a12      	ldr	r2, [pc, #72]	; (101ece8 <write_op+0x60>)
 101ec9e:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
 101eca2:	07db      	lsls	r3, r3, #31
 101eca4:	d5fb      	bpl.n	101ec9e <write_op+0x16>
		shift_write_context(w_ctx->len, w_ctx);
	}
#endif /* CONFIG_SOC_FLASH_NRF_EMULATE_ONE_BYTE_WRITE_ACCESS */
	nvmc_wait_ready();

	return FLASH_OP_DONE;
 101eca6:	2000      	movs	r0, #0
}
 101eca8:	bd38      	pop	{r3, r4, r5, pc}
				     UNALIGNED_GET((uint32_t *)w_ctx->data_addr));
 101ecaa:	6823      	ldr	r3, [r4, #0]
		nrfx_nvmc_word_write(w_ctx->flash_addr,
 101ecac:	6860      	ldr	r0, [r4, #4]
 101ecae:	6819      	ldr	r1, [r3, #0]
 101ecb0:	f001 fc3e 	bl	1020530 <nrfx_nvmc_word_write>
	w_ctx->flash_addr += shift;
 101ecb4:	6863      	ldr	r3, [r4, #4]
		i++;
 101ecb6:	3501      	adds	r5, #1
	w_ctx->flash_addr += shift;
 101ecb8:	3304      	adds	r3, #4
 101ecba:	6063      	str	r3, [r4, #4]
	w_ctx->data_addr += shift;
 101ecbc:	6823      	ldr	r3, [r4, #0]
 101ecbe:	3304      	adds	r3, #4
 101ecc0:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
 101ecc2:	68a3      	ldr	r3, [r4, #8]
 101ecc4:	3b04      	subs	r3, #4
 101ecc6:	60a3      	str	r3, [r4, #8]
		if (w_ctx->enable_time_limit) {
 101ecc8:	7b23      	ldrb	r3, [r4, #12]
 101ecca:	2b00      	cmp	r3, #0
 101eccc:	d0e3      	beq.n	101ec96 <write_op+0xe>
			if (nrf_flash_sync_check_time_limit(i)) {
 101ecce:	4628      	mov	r0, r5
 101ecd0:	f7e2 fc9a 	bl	1001608 <nrf_flash_sync_check_time_limit>
 101ecd4:	2800      	cmp	r0, #0
 101ecd6:	d0de      	beq.n	101ec96 <write_op+0xe>
 101ecd8:	4a03      	ldr	r2, [pc, #12]	; (101ece8 <write_op+0x60>)
 101ecda:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
 101ecde:	07d9      	lsls	r1, r3, #31
 101ece0:	d5fb      	bpl.n	101ecda <write_op+0x52>
				return FLASH_OP_ONGOING;
 101ece2:	2001      	movs	r0, #1
 101ece4:	e7e0      	b.n	101eca8 <write_op+0x20>
 101ece6:	bf00      	nop
 101ece8:	41080000 	.word	0x41080000

0101ecec <flash_nrf_erase>:
{
 101ecec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 101ecf0:	b086      	sub	sp, #24
 101ecf2:	af00      	add	r7, sp, #0
 101ecf4:	460d      	mov	r5, r1
 101ecf6:	4616      	mov	r6, r2
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
 101ecf8:	f00a fa3c 	bl	1029174 <nrfx_nvmc_flash_page_size_get>
	if (is_regular_addr_valid(addr, size)) {
 101ecfc:	4631      	mov	r1, r6
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
 101ecfe:	4680      	mov	r8, r0
	if (is_regular_addr_valid(addr, size)) {
 101ed00:	4628      	mov	r0, r5
 101ed02:	f00a f903 	bl	1028f0c <is_regular_addr_valid>
 101ed06:	4603      	mov	r3, r0
 101ed08:	2800      	cmp	r0, #0
 101ed0a:	d03b      	beq.n	101ed84 <flash_nrf_erase+0x98>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
 101ed0c:	fbb5 f3f8 	udiv	r3, r5, r8
 101ed10:	fb08 5313 	mls	r3, r8, r3, r5
 101ed14:	b923      	cbnz	r3, 101ed20 <flash_nrf_erase+0x34>
 101ed16:	fbb6 f4f8 	udiv	r4, r6, r8
 101ed1a:	fb08 6414 	mls	r4, r8, r4, r6
 101ed1e:	b1bc      	cbz	r4, 101ed50 <flash_nrf_erase+0x64>
			LOG_ERR("unaligned address: 0x%08lx:%zu",
 101ed20:	466c      	mov	r4, sp
 101ed22:	b088      	sub	sp, #32
 101ed24:	466a      	mov	r2, sp
 101ed26:	4b28      	ldr	r3, [pc, #160]	; (101edc8 <flash_nrf_erase+0xdc>)
 101ed28:	61d6      	str	r6, [r2, #28]
 101ed2a:	e9c2 3505 	strd	r3, r5, [r2, #20]
 101ed2e:	2304      	movs	r3, #4
 101ed30:	f842 3f10 	str.w	r3, [r2, #16]!
 101ed34:	2300      	movs	r3, #0
 101ed36:	f44f 5101 	mov.w	r1, #8256	; 0x2040
 101ed3a:	4824      	ldr	r0, [pc, #144]	; (101edcc <flash_nrf_erase+0xe0>)
 101ed3c:	f7e5 fce4 	bl	1004708 <z_impl_z_log_msg_static_create>
 101ed40:	46a5      	mov	sp, r4
			return -EINVAL;
 101ed42:	f06f 0415 	mvn.w	r4, #21
}
 101ed46:	4620      	mov	r0, r4
 101ed48:	3718      	adds	r7, #24
 101ed4a:	46bd      	mov	sp, r7
 101ed4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!n_pages) {
 101ed50:	45b0      	cmp	r8, r6
 101ed52:	d8f8      	bhi.n	101ed46 <flash_nrf_erase+0x5a>
	return z_impl_k_sem_take(sem, timeout);
 101ed54:	f04f 33ff 	mov.w	r3, #4294967295
 101ed58:	f04f 32ff 	mov.w	r2, #4294967295
 101ed5c:	481c      	ldr	r0, [pc, #112]	; (101edd0 <flash_nrf_erase+0xe4>)
 101ed5e:	f002 fce3 	bl	1021728 <z_impl_k_sem_take>
	if (nrf_flash_sync_is_required()) {
 101ed62:	f00a f8fc 	bl	1028f5e <nrf_flash_sync_is_required>
		addr += DT_REG_ADDR(SOC_NV_FLASH_NODE);
 101ed66:	f105 7580 	add.w	r5, r5, #16777216	; 0x1000000
	if (nrf_flash_sync_is_required()) {
 101ed6a:	4601      	mov	r1, r0
 101ed6c:	f107 0308 	add.w	r3, r7, #8
 101ed70:	b998      	cbnz	r0, 101ed9a <flash_nrf_erase+0xae>

static int erase(uint32_t addr, uint32_t size)
{
	struct flash_context context = {
 101ed72:	2210      	movs	r2, #16
 101ed74:	4618      	mov	r0, r3
 101ed76:	f007 fe08 	bl	102698a <memset>
 101ed7a:	e9c7 5603 	strd	r5, r6, [r7, #12]
#if defined(CONFIG_SOC_FLASH_NRF_PARTIAL_ERASE)
		.flash_addr_next = addr
#endif
	};

	return	erase_op(&context);
 101ed7e:	f00a f8a1 	bl	1028ec4 <erase_op>
 101ed82:	e01c      	b.n	101edbe <flash_nrf_erase+0xd2>
		LOG_ERR("invalid address: 0x%08lx:%zu",
 101ed84:	466c      	mov	r4, sp
 101ed86:	b088      	sub	sp, #32
 101ed88:	466a      	mov	r2, sp
 101ed8a:	4912      	ldr	r1, [pc, #72]	; (101edd4 <flash_nrf_erase+0xe8>)
 101ed8c:	61d6      	str	r6, [r2, #28]
 101ed8e:	e9c2 1505 	strd	r1, r5, [r2, #20]
 101ed92:	2104      	movs	r1, #4
 101ed94:	f842 1f10 	str.w	r1, [r2, #16]!
	compiler_barrier();
 101ed98:	e7cd      	b.n	101ed36 <flash_nrf_erase+0x4a>
	struct flash_context context = {
 101ed9a:	2210      	movs	r2, #16
 101ed9c:	4621      	mov	r1, r4
 101ed9e:	4618      	mov	r0, r3
 101eda0:	f007 fdf3 	bl	102698a <memset>
 101eda4:	2201      	movs	r2, #1
 101eda6:	753a      	strb	r2, [r7, #20]
	struct flash_op_desc flash_op_desc = {
 101eda8:	4a0b      	ldr	r2, [pc, #44]	; (101edd8 <flash_nrf_erase+0xec>)
	struct flash_context context = {
 101edaa:	e9c7 5603 	strd	r5, r6, [r7, #12]
	struct flash_op_desc flash_op_desc = {
 101edae:	e9c7 2000 	strd	r2, r0, [r7]
	nrf_flash_sync_set_context(FLASH_SLOT_ERASE);
 101edb2:	480a      	ldr	r0, [pc, #40]	; (101eddc <flash_nrf_erase+0xf0>)
 101edb4:	f000 f99a 	bl	101f0ec <nrf_flash_sync_set_context>
	return nrf_flash_sync_exe(&flash_op_desc);
 101edb8:	4638      	mov	r0, r7
 101edba:	f7e2 fb91 	bl	10014e0 <nrf_flash_sync_exe>
	return	erase_op(&context);
 101edbe:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
 101edc0:	4803      	ldr	r0, [pc, #12]	; (101edd0 <flash_nrf_erase+0xe4>)
 101edc2:	f002 fc6d 	bl	10216a0 <z_impl_k_sem_give>
}
 101edc6:	e7be      	b.n	101ed46 <flash_nrf_erase+0x5a>
 101edc8:	0102f0fa 	.word	0x0102f0fa
 101edcc:	01029a04 	.word	0x01029a04
 101edd0:	21007f70 	.word	0x21007f70
 101edd4:	0102f0dd 	.word	0x0102f0dd
 101edd8:	01028ec5 	.word	0x01028ec5
 101eddc:	00015e64 	.word	0x00015e64

0101ede0 <flash_nrf_write>:
{
 101ede0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 101ede4:	460d      	mov	r5, r1
 101ede6:	b086      	sub	sp, #24
	if (is_regular_addr_valid(addr, len)) {
 101ede8:	4619      	mov	r1, r3
 101edea:	4628      	mov	r0, r5
{
 101edec:	af00      	add	r7, sp, #0
 101edee:	461c      	mov	r4, r3
 101edf0:	4616      	mov	r6, r2
	if (is_regular_addr_valid(addr, len)) {
 101edf2:	f00a f88b 	bl	1028f0c <is_regular_addr_valid>
 101edf6:	4603      	mov	r3, r0
 101edf8:	b1b0      	cbz	r0, 101ee28 <flash_nrf_write+0x48>
		addr += DT_REG_ADDR(SOC_NV_FLASH_NODE);
 101edfa:	f105 7880 	add.w	r8, r5, #16777216	; 0x1000000
	if (!is_aligned_32(addr) || (len % sizeof(uint32_t))) {
 101edfe:	4325      	orrs	r5, r4
 101ee00:	07ab      	lsls	r3, r5, #30
 101ee02:	d028      	beq.n	101ee56 <flash_nrf_write+0x76>
		LOG_ERR("not word-aligned: 0x%08lx:%zu",
 101ee04:	466d      	mov	r5, sp
 101ee06:	b088      	sub	sp, #32
 101ee08:	466a      	mov	r2, sp
 101ee0a:	4b26      	ldr	r3, [pc, #152]	; (101eea4 <flash_nrf_write+0xc4>)
 101ee0c:	61d4      	str	r4, [r2, #28]
 101ee0e:	e9c2 3805 	strd	r3, r8, [r2, #20]
 101ee12:	2304      	movs	r3, #4
 101ee14:	f842 3f10 	str.w	r3, [r2, #16]!
	z_impl_z_log_msg_static_create(source, desc, package, data);
 101ee18:	2300      	movs	r3, #0
 101ee1a:	f44f 5101 	mov.w	r1, #8256	; 0x2040
 101ee1e:	4822      	ldr	r0, [pc, #136]	; (101eea8 <flash_nrf_write+0xc8>)
 101ee20:	f7e5 fc72 	bl	1004708 <z_impl_z_log_msg_static_create>
 101ee24:	46ad      	mov	sp, r5
		return -EINVAL;
 101ee26:	e00f      	b.n	101ee48 <flash_nrf_write+0x68>
		LOG_ERR("invalid address: 0x%08lx:%zu",
 101ee28:	466e      	mov	r6, sp
 101ee2a:	b088      	sub	sp, #32
 101ee2c:	466a      	mov	r2, sp
 101ee2e:	491f      	ldr	r1, [pc, #124]	; (101eeac <flash_nrf_write+0xcc>)
 101ee30:	61d4      	str	r4, [r2, #28]
 101ee32:	e9c2 1505 	strd	r1, r5, [r2, #20]
 101ee36:	2104      	movs	r1, #4
 101ee38:	f842 1f10 	str.w	r1, [r2, #16]!
 101ee3c:	f44f 5101 	mov.w	r1, #8256	; 0x2040
 101ee40:	4819      	ldr	r0, [pc, #100]	; (101eea8 <flash_nrf_write+0xc8>)
 101ee42:	f7e5 fc61 	bl	1004708 <z_impl_z_log_msg_static_create>
 101ee46:	46b5      	mov	sp, r6
		return -EINVAL;
 101ee48:	f06f 0415 	mvn.w	r4, #21
}
 101ee4c:	4620      	mov	r0, r4
 101ee4e:	3718      	adds	r7, #24
 101ee50:	46bd      	mov	sp, r7
 101ee52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!len) {
 101ee56:	2c00      	cmp	r4, #0
 101ee58:	d0f8      	beq.n	101ee4c <flash_nrf_write+0x6c>
	return z_impl_k_sem_take(sem, timeout);
 101ee5a:	f04f 33ff 	mov.w	r3, #4294967295
 101ee5e:	f04f 32ff 	mov.w	r2, #4294967295
 101ee62:	4813      	ldr	r0, [pc, #76]	; (101eeb0 <flash_nrf_write+0xd0>)
 101ee64:	f002 fc60 	bl	1021728 <z_impl_k_sem_take>
	if (nrf_flash_sync_is_required()) {
 101ee68:	f00a f879 	bl	1028f5e <nrf_flash_sync_is_required>
 101ee6c:	4603      	mov	r3, r0
	struct flash_context context = {
 101ee6e:	e9c7 6802 	strd	r6, r8, [r7, #8]
 101ee72:	f107 0008 	add.w	r0, r7, #8
 101ee76:	613c      	str	r4, [r7, #16]
	if (nrf_flash_sync_is_required()) {
 101ee78:	b183      	cbz	r3, 101ee9c <flash_nrf_write+0xbc>
	struct flash_context context = {
 101ee7a:	2301      	movs	r3, #1
 101ee7c:	753b      	strb	r3, [r7, #20]
	struct flash_op_desc flash_op_desc = {
 101ee7e:	4b0d      	ldr	r3, [pc, #52]	; (101eeb4 <flash_nrf_write+0xd4>)
 101ee80:	e9c7 3000 	strd	r3, r0, [r7]
	nrf_flash_sync_set_context(FLASH_SLOT_WRITE);
 101ee84:	f641 504c 	movw	r0, #7500	; 0x1d4c
 101ee88:	f000 f930 	bl	101f0ec <nrf_flash_sync_set_context>
	return nrf_flash_sync_exe(&flash_op_desc);
 101ee8c:	4638      	mov	r0, r7
 101ee8e:	f7e2 fb27 	bl	10014e0 <nrf_flash_sync_exe>
#ifndef CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE
		.enable_time_limit = 0 /* disable time limit */
#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */
	};

	return write_op(&context);
 101ee92:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
 101ee94:	4806      	ldr	r0, [pc, #24]	; (101eeb0 <flash_nrf_write+0xd0>)
 101ee96:	f002 fc03 	bl	10216a0 <z_impl_k_sem_give>
}
 101ee9a:	e7d7      	b.n	101ee4c <flash_nrf_write+0x6c>
	struct flash_context context = {
 101ee9c:	753b      	strb	r3, [r7, #20]
	return write_op(&context);
 101ee9e:	f7ff fef3 	bl	101ec88 <write_op>
 101eea2:	e7f6      	b.n	101ee92 <flash_nrf_write+0xb2>
 101eea4:	0102f119 	.word	0x0102f119
 101eea8:	01029a04 	.word	0x01029a04
 101eeac:	0102f0dd 	.word	0x0102f0dd
 101eeb0:	21007f70 	.word	0x21007f70
 101eeb4:	0101ec89 	.word	0x0101ec89

0101eeb8 <ticker_stop_prepare_cb>:
{
 101eeb8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	__ASSERT(status == TICKER_STATUS_SUCCESS,
 101eeba:	4604      	mov	r4, r0
 101eebc:	b160      	cbz	r0, 101eed8 <ticker_stop_prepare_cb+0x20>
 101eebe:	4917      	ldr	r1, [pc, #92]	; (101ef1c <ticker_stop_prepare_cb+0x64>)
 101eec0:	2339      	movs	r3, #57	; 0x39
 101eec2:	4a17      	ldr	r2, [pc, #92]	; (101ef20 <ticker_stop_prepare_cb+0x68>)
 101eec4:	4817      	ldr	r0, [pc, #92]	; (101ef24 <ticker_stop_prepare_cb+0x6c>)
 101eec6:	f005 fe86 	bl	1024bd6 <assert_print>
 101eeca:	4817      	ldr	r0, [pc, #92]	; (101ef28 <ticker_stop_prepare_cb+0x70>)
 101eecc:	f005 fe83 	bl	1024bd6 <assert_print>
 101eed0:	2139      	movs	r1, #57	; 0x39
	__ASSERT((ret == TICKER_STATUS_SUCCESS ||
 101eed2:	4813      	ldr	r0, [pc, #76]	; (101ef20 <ticker_stop_prepare_cb+0x68>)
 101eed4:	f005 fe78 	bl	1024bc8 <assert_post_action>
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
 101eed8:	f10d 010f 	add.w	r1, sp, #15
 101eedc:	f10d 000e 	add.w	r0, sp, #14
 101eee0:	f7f5 fa7a 	bl	10143d8 <ll_timeslice_ticker_id_get>
	ret = ticker_stop(instance_index, 2U, (ticker_id + 1U),
 101eee4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 101eee8:	4b10      	ldr	r3, [pc, #64]	; (101ef2c <ticker_stop_prepare_cb+0x74>)
 101eeea:	3201      	adds	r2, #1
 101eeec:	2102      	movs	r1, #2
 101eeee:	f89d 000e 	ldrb.w	r0, [sp, #14]
 101eef2:	9400      	str	r4, [sp, #0]
 101eef4:	b2d2      	uxtb	r2, r2
 101eef6:	f7f3 f95d 	bl	10121b4 <ticker_stop>
	__ASSERT((ret == TICKER_STATUS_SUCCESS ||
 101eefa:	f030 0302 	bics.w	r3, r0, #2
 101eefe:	d00a      	beq.n	101ef16 <ticker_stop_prepare_cb+0x5e>
 101ef00:	490b      	ldr	r1, [pc, #44]	; (101ef30 <ticker_stop_prepare_cb+0x78>)
 101ef02:	2342      	movs	r3, #66	; 0x42
 101ef04:	4a06      	ldr	r2, [pc, #24]	; (101ef20 <ticker_stop_prepare_cb+0x68>)
 101ef06:	4807      	ldr	r0, [pc, #28]	; (101ef24 <ticker_stop_prepare_cb+0x6c>)
 101ef08:	f005 fe65 	bl	1024bd6 <assert_print>
 101ef0c:	4809      	ldr	r0, [pc, #36]	; (101ef34 <ticker_stop_prepare_cb+0x7c>)
 101ef0e:	f005 fe62 	bl	1024bd6 <assert_print>
 101ef12:	2142      	movs	r1, #66	; 0x42
 101ef14:	e7dd      	b.n	101eed2 <ticker_stop_prepare_cb+0x1a>
}
 101ef16:	b004      	add	sp, #16
 101ef18:	bd10      	pop	{r4, pc}
 101ef1a:	bf00      	nop
 101ef1c:	0102f193 	.word	0x0102f193
 101ef20:	0102f15b 	.word	0x0102f15b
 101ef24:	0102b695 	.word	0x0102b695
 101ef28:	0102f19f 	.word	0x0102f19f
 101ef2c:	0101f099 	.word	0x0101f099
 101ef30:	0102f1c1 	.word	0x0102f1c1
 101ef34:	0102f1d8 	.word	0x0102f1d8

0101ef38 <time_slot_delay>:
{
 101ef38:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 101ef3c:	4690      	mov	r8, r2
 101ef3e:	4699      	mov	r9, r3
	ret = ticker_start(instance_index, /* Radio instance ticker */
 101ef40:	2400      	movs	r4, #0
{
 101ef42:	4606      	mov	r6, r0
 101ef44:	460f      	mov	r7, r1
 101ef46:	b08d      	sub	sp, #52	; 0x34
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
 101ef48:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
 101ef4c:	f10d 002e 	add.w	r0, sp, #46	; 0x2e
 101ef50:	f7f5 fa42 	bl	10143d8 <ll_timeslice_ticker_id_get>
	ret = ticker_start(instance_index, /* Radio instance ticker */
 101ef54:	f89d 502f 	ldrb.w	r5, [sp, #47]	; 0x2f
 101ef58:	4633      	mov	r3, r6
 101ef5a:	3501      	adds	r5, #1
 101ef5c:	2101      	movs	r1, #1
 101ef5e:	e9cd 4407 	strd	r4, r4, [sp, #28]
 101ef62:	e9cd 8905 	strd	r8, r9, [sp, #20]
 101ef66:	e9cd 4403 	strd	r4, r4, [sp, #12]
 101ef6a:	e9cd 4401 	strd	r4, r4, [sp, #4]
 101ef6e:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
 101ef72:	9700      	str	r7, [sp, #0]
 101ef74:	b2ea      	uxtb	r2, r5
 101ef76:	f7f3 f891 	bl	101209c <ticker_start>
	if (ret != TICKER_STATUS_SUCCESS && ret != TICKER_STATUS_BUSY) {
 101ef7a:	f030 0302 	bics.w	r3, r0, #2
 101ef7e:	d01a      	beq.n	101efb6 <time_slot_delay+0x7e>
		_ticker_sync_context.result = 0;
 101ef80:	4b0e      	ldr	r3, [pc, #56]	; (101efbc <time_slot_delay+0x84>)
		ret = ticker_stop(instance_index, 1U, ticker_id,
 101ef82:	2101      	movs	r1, #1
		_ticker_sync_context.result = 0;
 101ef84:	60dc      	str	r4, [r3, #12]
		ret = ticker_stop(instance_index, 1U, ticker_id,
 101ef86:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
 101ef8a:	4b0d      	ldr	r3, [pc, #52]	; (101efc0 <time_slot_delay+0x88>)
 101ef8c:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
 101ef90:	9400      	str	r4, [sp, #0]
 101ef92:	f7f3 f90f 	bl	10121b4 <ticker_stop>
		__ASSERT((ret == TICKER_STATUS_SUCCESS ||
 101ef96:	f030 0302 	bics.w	r3, r0, #2
 101ef9a:	d00c      	beq.n	101efb6 <time_slot_delay+0x7e>
 101ef9c:	4909      	ldr	r1, [pc, #36]	; (101efc4 <time_slot_delay+0x8c>)
 101ef9e:	238d      	movs	r3, #141	; 0x8d
 101efa0:	4a09      	ldr	r2, [pc, #36]	; (101efc8 <time_slot_delay+0x90>)
 101efa2:	480a      	ldr	r0, [pc, #40]	; (101efcc <time_slot_delay+0x94>)
 101efa4:	f005 fe17 	bl	1024bd6 <assert_print>
 101efa8:	4809      	ldr	r0, [pc, #36]	; (101efd0 <time_slot_delay+0x98>)
 101efaa:	f005 fe14 	bl	1024bd6 <assert_print>
 101efae:	218d      	movs	r1, #141	; 0x8d
 101efb0:	4805      	ldr	r0, [pc, #20]	; (101efc8 <time_slot_delay+0x90>)
 101efb2:	f005 fe09 	bl	1024bc8 <assert_post_action>
}
 101efb6:	b00d      	add	sp, #52	; 0x34
 101efb8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 101efbc:	21007fa0 	.word	0x21007fa0
 101efc0:	0101eeb9 	.word	0x0101eeb9
 101efc4:	0102f1c1 	.word	0x0102f1c1
 101efc8:	0102f15b 	.word	0x0102f15b
 101efcc:	0102b695 	.word	0x0102b695
 101efd0:	0102f206 	.word	0x0102f206

0101efd4 <time_slot_callback_prepare>:
	time_slot_delay(ticks_at_expire,
 101efd4:	2131      	movs	r1, #49	; 0x31
 101efd6:	9b01      	ldr	r3, [sp, #4]
 101efd8:	4a01      	ldr	r2, [pc, #4]	; (101efe0 <time_slot_callback_prepare+0xc>)
 101efda:	f7ff bfad 	b.w	101ef38 <time_slot_delay>
 101efde:	bf00      	nop
 101efe0:	0101efe5 	.word	0x0101efe5

0101efe4 <time_slot_callback_abort>:
{
 101efe4:	b570      	push	{r4, r5, r6, lr}
 101efe6:	4604      	mov	r4, r0
 101efe8:	9d05      	ldr	r5, [sp, #20]
	ll_radio_state_abort();
 101efea:	f7f5 f9fb 	bl	10143e4 <ll_radio_state_abort>
	time_slot_delay(ticks_at_expire,
 101efee:	462b      	mov	r3, r5
 101eff0:	4620      	mov	r0, r4
}
 101eff2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	time_slot_delay(ticks_at_expire,
 101eff6:	2106      	movs	r1, #6
 101eff8:	4a01      	ldr	r2, [pc, #4]	; (101f000 <time_slot_callback_abort+0x1c>)
 101effa:	f7ff bf9d 	b.w	101ef38 <time_slot_delay>
 101effe:	bf00      	nop
 101f000:	0101f005 	.word	0x0101f005

0101f004 <time_slot_callback_work>:
{
 101f004:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 101f006:	9c07      	ldr	r4, [sp, #28]
	__ASSERT(ll_radio_state_is_idle(),
 101f008:	f7f5 fa0c 	bl	1014424 <ll_radio_state_is_idle>
 101f00c:	b960      	cbnz	r0, 101f028 <time_slot_callback_work+0x24>
 101f00e:	491a      	ldr	r1, [pc, #104]	; (101f078 <time_slot_callback_work+0x74>)
 101f010:	2350      	movs	r3, #80	; 0x50
 101f012:	4a1a      	ldr	r2, [pc, #104]	; (101f07c <time_slot_callback_work+0x78>)
 101f014:	481a      	ldr	r0, [pc, #104]	; (101f080 <time_slot_callback_work+0x7c>)
 101f016:	f005 fdde 	bl	1024bd6 <assert_print>
 101f01a:	481a      	ldr	r0, [pc, #104]	; (101f084 <time_slot_callback_work+0x80>)
 101f01c:	f005 fddb 	bl	1024bd6 <assert_print>
 101f020:	2150      	movs	r1, #80	; 0x50
		__ASSERT((ret == TICKER_STATUS_SUCCESS ||
 101f022:	4816      	ldr	r0, [pc, #88]	; (101f07c <time_slot_callback_work+0x78>)
 101f024:	f005 fdd0 	bl	1024bc8 <assert_post_action>
	rc = op_desc->handler(op_desc->context);
 101f028:	e9d4 3000 	ldrd	r3, r0, [r4]
 101f02c:	4798      	blx	r3
	if (rc != FLASH_OP_ONGOING) {
 101f02e:	2801      	cmp	r0, #1
	rc = op_desc->handler(op_desc->context);
 101f030:	4604      	mov	r4, r0
	if (rc != FLASH_OP_ONGOING) {
 101f032:	d01f      	beq.n	101f074 <time_slot_callback_work+0x70>
		ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
 101f034:	f10d 010f 	add.w	r1, sp, #15
 101f038:	f10d 000e 	add.w	r0, sp, #14
 101f03c:	f7f5 f9cc 	bl	10143d8 <ll_timeslice_ticker_id_get>
		ret = ticker_stop(instance_index, 1U, ticker_id,
 101f040:	2300      	movs	r3, #0
 101f042:	2101      	movs	r1, #1
 101f044:	9300      	str	r3, [sp, #0]
 101f046:	f89d 200f 	ldrb.w	r2, [sp, #15]
 101f04a:	4b0f      	ldr	r3, [pc, #60]	; (101f088 <time_slot_callback_work+0x84>)
 101f04c:	f89d 000e 	ldrb.w	r0, [sp, #14]
 101f050:	f7f3 f8b0 	bl	10121b4 <ticker_stop>
		__ASSERT((ret == TICKER_STATUS_SUCCESS ||
 101f054:	f030 0302 	bics.w	r3, r0, #2
 101f058:	d00a      	beq.n	101f070 <time_slot_callback_work+0x6c>
 101f05a:	490c      	ldr	r1, [pc, #48]	; (101f08c <time_slot_callback_work+0x88>)
 101f05c:	2360      	movs	r3, #96	; 0x60
 101f05e:	4a07      	ldr	r2, [pc, #28]	; (101f07c <time_slot_callback_work+0x78>)
 101f060:	4807      	ldr	r0, [pc, #28]	; (101f080 <time_slot_callback_work+0x7c>)
 101f062:	f005 fdb8 	bl	1024bd6 <assert_print>
 101f066:	480a      	ldr	r0, [pc, #40]	; (101f090 <time_slot_callback_work+0x8c>)
 101f068:	f005 fdb5 	bl	1024bd6 <assert_print>
 101f06c:	2160      	movs	r1, #96	; 0x60
 101f06e:	e7d8      	b.n	101f022 <time_slot_callback_work+0x1e>
		_ticker_sync_context.result = (rc == FLASH_OP_DONE) ? 0 : rc;
 101f070:	4b08      	ldr	r3, [pc, #32]	; (101f094 <time_slot_callback_work+0x90>)
 101f072:	60dc      	str	r4, [r3, #12]
}
 101f074:	b004      	add	sp, #16
 101f076:	bd10      	pop	{r4, pc}
 101f078:	0102f220 	.word	0x0102f220
 101f07c:	0102f15b 	.word	0x0102f15b
 101f080:	0102b695 	.word	0x0102b695
 101f084:	0102f239 	.word	0x0102f239
 101f088:	0101eeb9 	.word	0x0101eeb9
 101f08c:	0102f1c1 	.word	0x0102f1c1
 101f090:	0102f206 	.word	0x0102f206
 101f094:	21007fa0 	.word	0x21007fa0

0101f098 <ticker_stop_work_cb>:
	__ASSERT((status == TICKER_STATUS_SUCCESS ||
 101f098:	2801      	cmp	r0, #1
{
 101f09a:	b508      	push	{r3, lr}
	__ASSERT((status == TICKER_STATUS_SUCCESS ||
 101f09c:	d90c      	bls.n	101f0b8 <ticker_stop_work_cb+0x20>
 101f09e:	4909      	ldr	r1, [pc, #36]	; (101f0c4 <ticker_stop_work_cb+0x2c>)
 101f0a0:	232b      	movs	r3, #43	; 0x2b
 101f0a2:	4a09      	ldr	r2, [pc, #36]	; (101f0c8 <ticker_stop_work_cb+0x30>)
 101f0a4:	4809      	ldr	r0, [pc, #36]	; (101f0cc <ticker_stop_work_cb+0x34>)
 101f0a6:	f005 fd96 	bl	1024bd6 <assert_print>
 101f0aa:	4809      	ldr	r0, [pc, #36]	; (101f0d0 <ticker_stop_work_cb+0x38>)
 101f0ac:	f005 fd93 	bl	1024bd6 <assert_print>
 101f0b0:	212b      	movs	r1, #43	; 0x2b
 101f0b2:	4805      	ldr	r0, [pc, #20]	; (101f0c8 <ticker_stop_work_cb+0x30>)
 101f0b4:	f005 fd88 	bl	1024bc8 <assert_post_action>
	z_impl_k_sem_give(sem);
 101f0b8:	4806      	ldr	r0, [pc, #24]	; (101f0d4 <ticker_stop_work_cb+0x3c>)
}
 101f0ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 101f0be:	f002 baef 	b.w	10216a0 <z_impl_k_sem_give>
 101f0c2:	bf00      	nop
 101f0c4:	0102f260 	.word	0x0102f260
 101f0c8:	0102f15b 	.word	0x0102f15b
 101f0cc:	0102b695 	.word	0x0102b695
 101f0d0:	0102f27d 	.word	0x0102f27d
 101f0d4:	21007f88 	.word	0x21007f88

0101f0d8 <nrf_flash_sync_init>:
{
 101f0d8:	b508      	push	{r3, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
 101f0da:	2201      	movs	r2, #1
 101f0dc:	2100      	movs	r1, #0
 101f0de:	4802      	ldr	r0, [pc, #8]	; (101f0e8 <nrf_flash_sync_init+0x10>)
 101f0e0:	f00a f919 	bl	1029316 <z_impl_k_sem_init>
}
 101f0e4:	2000      	movs	r0, #0
 101f0e6:	bd08      	pop	{r3, pc}
 101f0e8:	21007f88 	.word	0x21007f88

0101f0ec <nrf_flash_sync_set_context>:
	_ticker_sync_context.interval = duration - FLASH_SYNC_SWITCHING_TIME;
 101f0ec:	4b02      	ldr	r3, [pc, #8]	; (101f0f8 <nrf_flash_sync_set_context+0xc>)
 101f0ee:	f2a0 62a4 	subw	r2, r0, #1700	; 0x6a4
	_ticker_sync_context.slot = duration;
 101f0f2:	e9c3 2000 	strd	r2, r0, [r3]
}
 101f0f6:	4770      	bx	lr
 101f0f8:	21007fa0 	.word	0x21007fa0

0101f0fc <nrf_flash_sync_get_timestamp_begin>:
{
 101f0fc:	b508      	push	{r3, lr}
	_ticker_sync_context.ticks_begin = ticker_ticks_now_get();
 101f0fe:	f7f3 f8c7 	bl	1012290 <ticker_ticks_now_get>
 101f102:	4b01      	ldr	r3, [pc, #4]	; (101f108 <nrf_flash_sync_get_timestamp_begin+0xc>)
 101f104:	6098      	str	r0, [r3, #8]
}
 101f106:	bd08      	pop	{r3, pc}
 101f108:	21007fa0 	.word	0x21007fa0

0101f10c <random_byte_get>:
 101f10c:	f04f 0320 	mov.w	r3, #32
 101f110:	f3ef 8211 	mrs	r2, BASEPRI
 101f114:	f383 8812 	msr	BASEPRI_MAX, r3
 101f118:	f3bf 8f6f 	isb	sy
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)rng_event);
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
 101f11c:	4b09      	ldr	r3, [pc, #36]	; (101f144 <random_byte_get+0x38>)
 101f11e:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
	int retval = -EAGAIN;
	unsigned int key;

	key = irq_lock();

	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
 101f122:	b161      	cbz	r1, 101f13e <random_byte_get+0x32>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
 101f124:	2100      	movs	r1, #0
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
 101f126:	f8d3 0508 	ldr.w	r0, [r3, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
 101f12a:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
 101f12e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
		retval = nrf_rng_random_value_get(NRF_RNG);
 101f132:	b2c0      	uxtb	r0, r0
	__asm__ volatile(
 101f134:	f382 8811 	msr	BASEPRI, r2
 101f138:	f3bf 8f6f 	isb	sy
	}

	irq_unlock(key);

	return retval;
}
 101f13c:	4770      	bx	lr
	int retval = -EAGAIN;
 101f13e:	f06f 000a 	mvn.w	r0, #10
 101f142:	e7f7      	b.n	101f134 <random_byte_get+0x28>
 101f144:	41009000 	.word	0x41009000

0101f148 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static uint16_t rng_pool_get(struct rng_pool *rngp, uint8_t *buf, uint16_t len)
{
 101f148:	4603      	mov	r3, r0
 101f14a:	b5f0      	push	{r4, r5, r6, r7, lr}
 101f14c:	4610      	mov	r0, r2
	uint32_t last  = rngp->last;
 101f14e:	789c      	ldrb	r4, [r3, #2]
	uint32_t mask  = rngp->mask;
 101f150:	f893 c003 	ldrb.w	ip, [r3, #3]
	__asm__ volatile(
 101f154:	f04f 0520 	mov.w	r5, #32
 101f158:	f3ef 8211 	mrs	r2, BASEPRI
 101f15c:	f385 8812 	msr	BASEPRI_MAX, r5
 101f160:	f3bf 8f6f 	isb	sy
	uint32_t first, available;
	uint32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
 101f164:	781f      	ldrb	r7, [r3, #0]
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
 101f166:	f893 e001 	ldrb.w	lr, [r3, #1]

	available = (last - first) & mask;
 101f16a:	1be4      	subs	r4, r4, r7
 101f16c:	ea04 040c 	and.w	r4, r4, ip
	if (available < len) {
 101f170:	42a0      	cmp	r0, r4
		len = available;
 101f172:	bf88      	it	hi
 101f174:	b2a0      	uxthhi	r0, r4

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
 101f176:	183e      	adds	r6, r7, r0
 101f178:	ea0c 0606 	and.w	r6, ip, r6
	first = rngp->first_alloc;
 101f17c:	463d      	mov	r5, r7
	rngp->first_alloc = (first + len) & mask;
 101f17e:	701e      	strb	r6, [r3, #0]
	__asm__ volatile(
 101f180:	f382 8811 	msr	BASEPRI, r2
 101f184:	f3bf 8f6f 	isb	sy
 101f188:	180a      	adds	r2, r1, r0
	irq_unlock(key);

	while (likely(len--)) {
 101f18a:	428a      	cmp	r2, r1
 101f18c:	d117      	bne.n	101f1be <rng_pool_get+0x76>
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
 101f18e:	4577      	cmp	r7, lr
 101f190:	d10d      	bne.n	101f1ae <rng_pool_get+0x66>
	__asm__ volatile(
 101f192:	f04f 0120 	mov.w	r1, #32
 101f196:	f3ef 8211 	mrs	r2, BASEPRI
 101f19a:	f381 8812 	msr	BASEPRI_MAX, r1
 101f19e:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
 101f1a2:	7819      	ldrb	r1, [r3, #0]
 101f1a4:	7059      	strb	r1, [r3, #1]
	__asm__ volatile(
 101f1a6:	f382 8811 	msr	BASEPRI, r2
 101f1aa:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
	available = available - len;
	if (available <= rngp->threshold) {
 101f1ae:	791b      	ldrb	r3, [r3, #4]
	available = available - len;
 101f1b0:	1a24      	subs	r4, r4, r0
	if (available <= rngp->threshold) {
 101f1b2:	42a3      	cmp	r3, r4
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
 101f1b4:	bf22      	ittt	cs
 101f1b6:	2201      	movcs	r2, #1
 101f1b8:	4b05      	ldrcs	r3, [pc, #20]	; (101f1d0 <rng_pool_get+0x88>)
 101f1ba:	601a      	strcs	r2, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
 101f1bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*dst++ = rngp->buffer[first];
 101f1be:	195e      	adds	r6, r3, r5
 101f1c0:	7976      	ldrb	r6, [r6, #5]
		first = (first + 1) & mask;
 101f1c2:	3501      	adds	r5, #1
		*dst++ = rngp->buffer[first];
 101f1c4:	f801 6b01 	strb.w	r6, [r1], #1
		first = (first + 1) & mask;
 101f1c8:	ea05 050c 	and.w	r5, r5, ip
 101f1cc:	e7dd      	b.n	101f18a <rng_pool_get+0x42>
 101f1ce:	bf00      	nop
 101f1d0:	41009000 	.word	0x41009000

0101f1d4 <entropy_nrf5_get_entropy_isr>:
}

static int entropy_nrf5_get_entropy_isr(const struct device *dev,
					uint8_t *buf, uint16_t len,
					uint32_t flags)
{
 101f1d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);
 101f1d8:	4d2c      	ldr	r5, [pc, #176]	; (101f28c <entropy_nrf5_get_entropy_isr+0xb8>)
 101f1da:	6900      	ldr	r0, [r0, #16]
{
 101f1dc:	460e      	mov	r6, r1
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);
 101f1de:	42a8      	cmp	r0, r5
{
 101f1e0:	4614      	mov	r4, r2
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);
 101f1e2:	d00b      	beq.n	101f1fc <entropy_nrf5_get_entropy_isr+0x28>
 101f1e4:	492a      	ldr	r1, [pc, #168]	; (101f290 <entropy_nrf5_get_entropy_isr+0xbc>)
 101f1e6:	482b      	ldr	r0, [pc, #172]	; (101f294 <entropy_nrf5_get_entropy_isr+0xc0>)
 101f1e8:	f240 1307 	movw	r3, #263	; 0x107
 101f1ec:	4a2a      	ldr	r2, [pc, #168]	; (101f298 <entropy_nrf5_get_entropy_isr+0xc4>)
 101f1ee:	f005 fcf2 	bl	1024bd6 <assert_print>
 101f1f2:	f240 1107 	movw	r1, #263	; 0x107
 101f1f6:	4828      	ldr	r0, [pc, #160]	; (101f298 <entropy_nrf5_get_entropy_isr+0xc4>)
 101f1f8:	f005 fce6 	bl	1024bc8 <assert_post_action>

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
 101f1fc:	43db      	mvns	r3, r3
 101f1fe:	f013 0501 	ands.w	r5, r3, #1
 101f202:	d004      	beq.n	101f20e <entropy_nrf5_get_entropy_isr+0x3a>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
 101f204:	3030      	adds	r0, #48	; 0x30
 101f206:	f7ff ff9f 	bl	101f148 <rng_pool_get>
			irq_enable(IRQN);
		}
	}

	return cnt;
}
 101f20a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
 101f20e:	b3a2      	cbz	r2, 101f27a <entropy_nrf5_get_entropy_isr+0xa6>
	__asm__ volatile(
 101f210:	f04f 0320 	mov.w	r3, #32
 101f214:	f3ef 8811 	mrs	r8, BASEPRI
 101f218:	f383 8812 	msr	BASEPRI_MAX, r3
 101f21c:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(IRQN);
 101f220:	2009      	movs	r0, #9
 101f222:	f7e6 fe03 	bl	1005e2c <arch_irq_is_enabled>
 101f226:	4607      	mov	r7, r0
		irq_disable(IRQN);
 101f228:	2009      	movs	r0, #9
 101f22a:	f7e6 fdeb 	bl	1005e04 <arch_irq_disable>
	__asm__ volatile(
 101f22e:	f388 8811 	msr	BASEPRI, r8
 101f232:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
 101f236:	f8df 8064 	ldr.w	r8, [pc, #100]	; 101f29c <entropy_nrf5_get_entropy_isr+0xc8>
 101f23a:	f44f 7a00 	mov.w	sl, #512	; 0x200
 101f23e:	f8c8 5100 	str.w	r5, [r8, #256]	; 0x100
 101f242:	f8d8 3100 	ldr.w	r3, [r8, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
 101f246:	2301      	movs	r3, #1
 101f248:	4625      	mov	r5, r4
 101f24a:	f8df 9054 	ldr.w	r9, [pc, #84]	; 101f2a0 <entropy_nrf5_get_entropy_isr+0xcc>
 101f24e:	f8c8 3000 	str.w	r3, [r8]
 101f252:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
 101f256:	f8d8 3100 	ldr.w	r3, [r8, #256]	; 0x100
			while (!nrf_rng_event_check(NRF_RNG,
 101f25a:	b183      	cbz	r3, 101f27e <entropy_nrf5_get_entropy_isr+0xaa>
			byte = random_byte_get();
 101f25c:	f7ff ff56 	bl	101f10c <random_byte_get>
			if (byte < 0) {
 101f260:	1e03      	subs	r3, r0, #0
 101f262:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
 101f266:	dbf6      	blt.n	101f256 <entropy_nrf5_get_entropy_isr+0x82>
			buf[--len] = byte;
 101f268:	3d01      	subs	r5, #1
 101f26a:	b2ad      	uxth	r5, r5
 101f26c:	5573      	strb	r3, [r6, r5]
		} while (len);
 101f26e:	2d00      	cmp	r5, #0
 101f270:	d1f1      	bne.n	101f256 <entropy_nrf5_get_entropy_isr+0x82>
		if (irq_enabled) {
 101f272:	b117      	cbz	r7, 101f27a <entropy_nrf5_get_entropy_isr+0xa6>
			irq_enable(IRQN);
 101f274:	2009      	movs	r0, #9
 101f276:	f7e6 fdb7 	bl	1005de8 <arch_irq_enable>
	return cnt;
 101f27a:	4620      	mov	r0, r4
 101f27c:	e7c5      	b.n	101f20a <entropy_nrf5_get_entropy_isr+0x36>
  __ASM volatile ("dsb 0xF":::"memory");
 101f27e:	f3bf 8f4f 	dsb	sy
				__WFE();
 101f282:	bf20      	wfe
				__SEV();
 101f284:	bf40      	sev
				__WFE();
 101f286:	bf20      	wfe
 101f288:	e7e5      	b.n	101f256 <entropy_nrf5_get_entropy_isr+0x82>
 101f28a:	bf00      	nop
 101f28c:	21007fb0 	.word	0x21007fb0
 101f290:	0102f2df 	.word	0x0102f2df
 101f294:	0102b695 	.word	0x0102b695
 101f298:	0102f2ad 	.word	0x0102f2ad
 101f29c:	41009000 	.word	0x41009000
 101f2a0:	e000e100 	.word	0xe000e100

0101f2a4 <entropy_nrf5_get_entropy>:
{
 101f2a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);
 101f2a8:	4b19      	ldr	r3, [pc, #100]	; (101f310 <entropy_nrf5_get_entropy+0x6c>)
 101f2aa:	6907      	ldr	r7, [r0, #16]
{
 101f2ac:	460d      	mov	r5, r1
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);
 101f2ae:	429f      	cmp	r7, r3
{
 101f2b0:	4614      	mov	r4, r2
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);
 101f2b2:	d105      	bne.n	101f2c0 <entropy_nrf5_get_entropy+0x1c>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
 101f2b4:	f107 0845 	add.w	r8, r7, #69	; 0x45
	while (len) {
 101f2b8:	b964      	cbnz	r4, 101f2d4 <entropy_nrf5_get_entropy+0x30>
}
 101f2ba:	4620      	mov	r0, r4
 101f2bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);
 101f2c0:	4914      	ldr	r1, [pc, #80]	; (101f314 <entropy_nrf5_get_entropy+0x70>)
 101f2c2:	4815      	ldr	r0, [pc, #84]	; (101f318 <entropy_nrf5_get_entropy+0x74>)
 101f2c4:	23e9      	movs	r3, #233	; 0xe9
 101f2c6:	4a15      	ldr	r2, [pc, #84]	; (101f31c <entropy_nrf5_get_entropy+0x78>)
 101f2c8:	f005 fc85 	bl	1024bd6 <assert_print>
 101f2cc:	21e9      	movs	r1, #233	; 0xe9
 101f2ce:	4813      	ldr	r0, [pc, #76]	; (101f31c <entropy_nrf5_get_entropy+0x78>)
 101f2d0:	f005 fc7a 	bl	1024bc8 <assert_post_action>
	return z_impl_k_sem_take(sem, timeout);
 101f2d4:	f04f 33ff 	mov.w	r3, #4294967295
 101f2d8:	f04f 32ff 	mov.w	r2, #4294967295
 101f2dc:	4638      	mov	r0, r7
 101f2de:	f002 fa23 	bl	1021728 <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
 101f2e2:	4622      	mov	r2, r4
 101f2e4:	4629      	mov	r1, r5
 101f2e6:	4640      	mov	r0, r8
 101f2e8:	f7ff ff2e 	bl	101f148 <rng_pool_get>
 101f2ec:	4606      	mov	r6, r0
	z_impl_k_sem_give(sem);
 101f2ee:	4638      	mov	r0, r7
 101f2f0:	f002 f9d6 	bl	10216a0 <z_impl_k_sem_give>
		if (bytes == 0U) {
 101f2f4:	b93e      	cbnz	r6, 101f306 <entropy_nrf5_get_entropy+0x62>
	return z_impl_k_sem_take(sem, timeout);
 101f2f6:	f04f 32ff 	mov.w	r2, #4294967295
 101f2fa:	f04f 33ff 	mov.w	r3, #4294967295
 101f2fe:	4808      	ldr	r0, [pc, #32]	; (101f320 <entropy_nrf5_get_entropy+0x7c>)
 101f300:	f002 fa12 	bl	1021728 <z_impl_k_sem_take>
	while (len) {
 101f304:	e7e6      	b.n	101f2d4 <entropy_nrf5_get_entropy+0x30>
		len -= bytes;
 101f306:	1ba4      	subs	r4, r4, r6
 101f308:	b2a4      	uxth	r4, r4
		buf += bytes;
 101f30a:	4435      	add	r5, r6
 101f30c:	e7d4      	b.n	101f2b8 <entropy_nrf5_get_entropy+0x14>
 101f30e:	bf00      	nop
 101f310:	21007fb0 	.word	0x21007fb0
 101f314:	0102f2df 	.word	0x0102f2df
 101f318:	0102b695 	.word	0x0102b695
 101f31c:	0102f2ad 	.word	0x0102f2ad
 101f320:	21007fc8 	.word	0x21007fc8

0101f324 <entropy_nrf5_init>:
		    &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_ENTROPY_INIT_PRIORITY,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(const struct device *dev)
{
 101f324:	b538      	push	{r3, r4, r5, lr}
	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);
 101f326:	4b21      	ldr	r3, [pc, #132]	; (101f3ac <entropy_nrf5_init+0x88>)
 101f328:	6904      	ldr	r4, [r0, #16]
 101f32a:	429c      	cmp	r4, r3
 101f32c:	d00b      	beq.n	101f346 <entropy_nrf5_init+0x22>
 101f32e:	4920      	ldr	r1, [pc, #128]	; (101f3b0 <entropy_nrf5_init+0x8c>)
 101f330:	4820      	ldr	r0, [pc, #128]	; (101f3b4 <entropy_nrf5_init+0x90>)
 101f332:	f44f 73ab 	mov.w	r3, #342	; 0x156
 101f336:	4a20      	ldr	r2, [pc, #128]	; (101f3b8 <entropy_nrf5_init+0x94>)
 101f338:	f005 fc4d 	bl	1024bd6 <assert_print>
 101f33c:	f44f 71ab 	mov.w	r1, #342	; 0x156
 101f340:	481d      	ldr	r0, [pc, #116]	; (101f3b8 <entropy_nrf5_init+0x94>)
 101f342:	f005 fc41 	bl	1024bc8 <assert_post_action>
	return z_impl_k_sem_init(sem, initial_count, limit);
 101f346:	2201      	movs	r2, #1
 101f348:	4620      	mov	r0, r4
 101f34a:	4611      	mov	r1, r2
 101f34c:	f009 ffe3 	bl	1029316 <z_impl_k_sem_init>
 101f350:	2201      	movs	r2, #1
 101f352:	2100      	movs	r1, #0
 101f354:	f104 0018 	add.w	r0, r4, #24
 101f358:	f009 ffdd 	bl	1029316 <z_impl_k_sem_init>
	rngp->mask	  = size - 1;
 101f35c:	f240 4307 	movw	r3, #1031	; 0x407
 101f360:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	rngp->first_alloc = 0U;
 101f364:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 101f368:	6323      	str	r3, [r4, #48]	; 0x30
	rngp->threshold	  = threshold;
 101f36a:	230c      	movs	r3, #12
	rngp->first_alloc = 0U;
 101f36c:	2500      	movs	r5, #0
    p_reg->INTENSET = mask;
 101f36e:	2101      	movs	r1, #1
	rngp->threshold	  = threshold;
 101f370:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}

NRF_STATIC_INLINE void nrf_rng_error_correction_enable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
 101f374:	4b11      	ldr	r3, [pc, #68]	; (101f3bc <entropy_nrf5_init+0x98>)
	rngp->first_alloc = 0U;
 101f376:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	rngp->first_read  = 0U;
 101f37a:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
 101f37e:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(IRQN, IRQ_PRIO, isr, &entropy_nrf5_data, 0);
 101f382:	2009      	movs	r0, #9
 101f384:	f042 0201 	orr.w	r2, r2, #1
 101f388:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
 101f38c:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
 101f390:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
 101f394:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
 101f398:	462a      	mov	r2, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
 101f39a:	6019      	str	r1, [r3, #0]
 101f39c:	f7e6 fd54 	bl	1005e48 <z_arm_irq_priority_set>
	irq_enable(IRQN);
 101f3a0:	2009      	movs	r0, #9
 101f3a2:	f7e6 fd21 	bl	1005de8 <arch_irq_enable>

	return 0;
}
 101f3a6:	4628      	mov	r0, r5
 101f3a8:	bd38      	pop	{r3, r4, r5, pc}
 101f3aa:	bf00      	nop
 101f3ac:	21007fb0 	.word	0x21007fb0
 101f3b0:	0102f2df 	.word	0x0102f2df
 101f3b4:	0102b695 	.word	0x0102b695
 101f3b8:	0102f2ad 	.word	0x0102f2ad
 101f3bc:	41009000 	.word	0x41009000

0101f3c0 <isr>:
{
 101f3c0:	b510      	push	{r4, lr}
	byte = random_byte_get();
 101f3c2:	f7ff fea3 	bl	101f10c <random_byte_get>
	if (byte < 0) {
 101f3c6:	2800      	cmp	r0, #0
 101f3c8:	db20      	blt.n	101f40c <isr+0x4c>
	uint8_t last  = rngp->last;
 101f3ca:	4b17      	ldr	r3, [pc, #92]	; (101f428 <isr+0x68>)
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
 101f3cc:	b2c0      	uxtb	r0, r0
	uint8_t last  = rngp->last;
 101f3ce:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	if (((last - first) & mask) == mask) {
 101f3d2:	f893 4031 	ldrb.w	r4, [r3, #49]	; 0x31
	uint8_t mask  = rngp->mask;
 101f3d6:	f893 1033 	ldrb.w	r1, [r3, #51]	; 0x33
	if (((last - first) & mask) == mask) {
 101f3da:	1b14      	subs	r4, r2, r4
 101f3dc:	ea31 0404 	bics.w	r4, r1, r4
 101f3e0:	d10d      	bne.n	101f3fe <isr+0x3e>
	uint8_t last  = rngp->last;
 101f3e2:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	if (((last - first) & mask) == mask) {
 101f3e6:	f893 4046 	ldrb.w	r4, [r3, #70]	; 0x46
	uint8_t mask  = rngp->mask;
 101f3ea:	f893 1048 	ldrb.w	r1, [r3, #72]	; 0x48
	if (((last - first) & mask) == mask) {
 101f3ee:	1b14      	subs	r4, r2, r4
 101f3f0:	ea31 0404 	bics.w	r4, r1, r4
 101f3f4:	d10b      	bne.n	101f40e <isr+0x4e>
 101f3f6:	2201      	movs	r2, #1
 101f3f8:	4b0c      	ldr	r3, [pc, #48]	; (101f42c <isr+0x6c>)
 101f3fa:	605a      	str	r2, [r3, #4]
}
 101f3fc:	e00e      	b.n	101f41c <isr+0x5c>
	rngp->buffer[last] = byte;
 101f3fe:	189c      	adds	r4, r3, r2
	rngp->last = (last + 1) & mask;
 101f400:	3201      	adds	r2, #1
 101f402:	4011      	ands	r1, r2
	rngp->buffer[last] = byte;
 101f404:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
	rngp->last = (last + 1) & mask;
 101f408:	f883 1032 	strb.w	r1, [r3, #50]	; 0x32
}
 101f40c:	bd10      	pop	{r4, pc}
	rngp->buffer[last] = byte;
 101f40e:	189c      	adds	r4, r3, r2
	rngp->last = (last + 1) & mask;
 101f410:	3201      	adds	r2, #1
 101f412:	4011      	ands	r1, r2
	rngp->buffer[last] = byte;
 101f414:	f884 004a 	strb.w	r0, [r4, #74]	; 0x4a
	rngp->last = (last + 1) & mask;
 101f418:	f883 1047 	strb.w	r1, [r3, #71]	; 0x47
	z_impl_k_sem_give(sem);
 101f41c:	4804      	ldr	r0, [pc, #16]	; (101f430 <isr+0x70>)
}
 101f41e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 101f422:	f002 b93d 	b.w	10216a0 <z_impl_k_sem_give>
 101f426:	bf00      	nop
 101f428:	21007fb0 	.word	0x21007fb0
 101f42c:	41009000 	.word	0x41009000
 101f430:	21007fc8 	.word	0x21007fc8

0101f434 <sys_clock_timeout_handler>:
}

static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
 101f434:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
 101f436:	491b      	ldr	r1, [pc, #108]	; (101f4a4 <sys_clock_timeout_handler+0x70>)
{
 101f438:	4604      	mov	r4, r0
	return absolute_time & COUNTER_MAX;
 101f43a:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
 101f43e:	6808      	ldr	r0, [r1, #0]

	last_count += dticks * CYC_PER_TICK;
 101f440:	e9c1 2300 	strd	r2, r3, [r1]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
 101f444:	f5a5 1300 	sub.w	r3, r5, #2097152	; 0x200000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
 101f448:	1a10      	subs	r0, r2, r0
	if (in_anchor_range(cc_value)) {
 101f44a:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 101f44e:	d30f      	bcc.n	101f470 <sys_clock_timeout_handler+0x3c>
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
 101f450:	f004 fb08 	bl	1023a64 <sys_clock_announce>
 101f454:	00a3      	lsls	r3, r4, #2
 101f456:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 101f45a:	f503 33b0 	add.w	r3, r3, #90112	; 0x16000
 101f45e:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
			   (int32_t)dticks : (dticks > 0));

	if (cc_value == get_comparator(chan)) {
 101f462:	4295      	cmp	r5, r2
 101f464:	d11d      	bne.n	101f4a2 <sys_clock_timeout_handler+0x6e>
    p_reg->CC[ch] = cc_val;
 101f466:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 101f46a:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
}
 101f46e:	e012      	b.n	101f496 <sys_clock_timeout_handler+0x62>
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
 101f470:	4b0d      	ldr	r3, [pc, #52]	; (101f4a8 <sys_clock_timeout_handler+0x74>)
 101f472:	681b      	ldr	r3, [r3, #0]
 101f474:	0a1a      	lsrs	r2, r3, #8
 101f476:	061b      	lsls	r3, r3, #24
 101f478:	195e      	adds	r6, r3, r5
 101f47a:	4b0c      	ldr	r3, [pc, #48]	; (101f4ac <sys_clock_timeout_handler+0x78>)
 101f47c:	f142 0700 	adc.w	r7, r2, #0
 101f480:	e9c3 6700 	strd	r6, r7, [r3]
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
 101f484:	f004 faee 	bl	1023a64 <sys_clock_announce>
    return p_reg->CC[ch];
 101f488:	4a09      	ldr	r2, [pc, #36]	; (101f4b0 <sys_clock_timeout_handler+0x7c>)
 101f48a:	f504 73a8 	add.w	r3, r4, #336	; 0x150
 101f48e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	if (cc_value == get_comparator(chan)) {
 101f492:	429d      	cmp	r5, r3
 101f494:	d105      	bne.n	101f4a2 <sys_clock_timeout_handler+0x6e>
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
 101f496:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->EVTENSET = mask;
 101f49a:	4a05      	ldr	r2, [pc, #20]	; (101f4b0 <sys_clock_timeout_handler+0x7c>)
 101f49c:	40a3      	lsls	r3, r4
 101f49e:	f8c2 3344 	str.w	r3, [r2, #836]	; 0x344
		if (!anchor_updated) {
			set_comparator(chan, COUNTER_HALF_SPAN);
		}
		event_enable(chan);
	}
}
 101f4a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 101f4a4:	21004400 	.word	0x21004400
 101f4a8:	2100800c 	.word	0x2100800c
 101f4ac:	21004408 	.word	0x21004408
 101f4b0:	41016000 	.word	0x41016000

0101f4b4 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
 101f4b4:	4b0d      	ldr	r3, [pc, #52]	; (101f4ec <z_nrf_rtc_timer_read+0x38>)
 101f4b6:	6818      	ldr	r0, [r3, #0]
 101f4b8:	0a01      	lsrs	r1, r0, #8
 101f4ba:	0600      	lsls	r0, r0, #24
  __ASM volatile ("dmb 0xF":::"memory");
 101f4bc:	f3bf 8f5f 	dmb	sy
     return p_reg->COUNTER;
 101f4c0:	4b0b      	ldr	r3, [pc, #44]	; (101f4f0 <z_nrf_rtc_timer_read+0x3c>)
 101f4c2:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
 101f4c6:	1818      	adds	r0, r3, r0
 101f4c8:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
 101f4cc:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 101f4d0:	d20a      	bcs.n	101f4e8 <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
 101f4d2:	4b08      	ldr	r3, [pc, #32]	; (101f4f4 <z_nrf_rtc_timer_read+0x40>)
 101f4d4:	e9d3 2300 	ldrd	r2, r3, [r3]
 101f4d8:	4290      	cmp	r0, r2
 101f4da:	eb71 0303 	sbcs.w	r3, r1, r3
 101f4de:	d203      	bcs.n	101f4e8 <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
 101f4e0:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
 101f4e4:	f141 0100 	adc.w	r1, r1, #0
}
 101f4e8:	4770      	bx	lr
 101f4ea:	bf00      	nop
 101f4ec:	2100800c 	.word	0x2100800c
 101f4f0:	41016000 	.word	0x41016000
 101f4f4:	21004408 	.word	0x21004408

0101f4f8 <rtc_nrf_isr>:
 * probably better abstract that at some point (e.g. query and reset
 * it by pointer at runtime, maybe?) so we don't have this leaky
 * symbol.
 */
void rtc_nrf_isr(const void *arg)
{
 101f4f8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    return p_reg->INTENSET & mask;
 101f4fc:	4b31      	ldr	r3, [pc, #196]	; (101f5c4 <rtc_nrf_isr+0xcc>)
 101f4fe:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	ARG_UNUSED(arg);

	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
 101f502:	0792      	lsls	r2, r2, #30
 101f504:	d50b      	bpl.n	101f51e <rtc_nrf_isr+0x26>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 101f506:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 101f50a:	b142      	cbz	r2, 101f51e <rtc_nrf_isr+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 101f50c:	2200      	movs	r2, #0
 101f50e:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	    nrf_rtc_event_check(RTC, NRF_RTC_EVENT_OVERFLOW)) {
		nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_OVERFLOW);
		overflow_cnt++;
 101f512:	4a2d      	ldr	r2, [pc, #180]	; (101f5c8 <rtc_nrf_isr+0xd0>)
 101f514:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 101f518:	6813      	ldr	r3, [r2, #0]
 101f51a:	3301      	adds	r3, #1
 101f51c:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
 101f51e:	f04f 0320 	mov.w	r3, #32
 101f522:	f3ef 8211 	mrs	r2, BASEPRI
 101f526:	f383 8812 	msr	BASEPRI_MAX, r3
 101f52a:	f3bf 8f6f 	isb	sy
    return p_reg->INTENSET & mask;
 101f52e:	4c25      	ldr	r4, [pc, #148]	; (101f5c4 <rtc_nrf_isr+0xcc>)
 101f530:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
 101f534:	03db      	lsls	r3, r3, #15
 101f536:	d525      	bpl.n	101f584 <rtc_nrf_isr+0x8c>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 101f538:	4b24      	ldr	r3, [pc, #144]	; (101f5cc <rtc_nrf_isr+0xd4>)
 101f53a:	e8d3 1fef 	ldaex	r1, [r3]
 101f53e:	f021 0001 	bic.w	r0, r1, #1
 101f542:	e8c3 0fe5 	stlex	r5, r0, [r3]
 101f546:	2d00      	cmp	r5, #0
 101f548:	d1f7      	bne.n	101f53a <rtc_nrf_isr+0x42>
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
 101f54a:	b911      	cbnz	r1, 101f552 <rtc_nrf_isr+0x5a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 101f54c:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
 101f550:	b1c3      	cbz	r3, 101f584 <rtc_nrf_isr+0x8c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 101f552:	2500      	movs	r5, #0
 101f554:	f8c4 5140 	str.w	r5, [r4, #320]	; 0x140
 101f558:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
	__asm__ volatile(
 101f55c:	f382 8811 	msr	BASEPRI, r2
 101f560:	f3bf 8f6f 	isb	sy
		curr_time = z_nrf_rtc_timer_read();
 101f564:	f7ff ffa6 	bl	101f4b4 <z_nrf_rtc_timer_read>
	__asm__ volatile(
 101f568:	f04f 0320 	mov.w	r3, #32
 101f56c:	f3ef 8211 	mrs	r2, BASEPRI
 101f570:	f383 8812 	msr	BASEPRI_MAX, r3
 101f574:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
 101f578:	4b15      	ldr	r3, [pc, #84]	; (101f5d0 <rtc_nrf_isr+0xd8>)
 101f57a:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
		if (curr_time >= expire_time) {
 101f57e:	42b0      	cmp	r0, r6
 101f580:	41b9      	sbcs	r1, r7
 101f582:	d206      	bcs.n	101f592 <rtc_nrf_isr+0x9a>
	__asm__ volatile(
 101f584:	f382 8811 	msr	BASEPRI, r2
 101f588:	f3bf 8f6f 	isb	sy
	}

	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		process_channel(chan);
	}
}
 101f58c:	b003      	add	sp, #12
 101f58e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			cc_data[chan].target_time = TARGET_TIME_INVALID;
 101f592:	f04f 38ff 	mov.w	r8, #4294967295
			user_context = cc_data[chan].user_context;
 101f596:	e9d3 1000 	ldrd	r1, r0, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
 101f59a:	f04f 39ff 	mov.w	r9, #4294967295
			cc_data[chan].callback = NULL;
 101f59e:	601d      	str	r5, [r3, #0]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
 101f5a0:	e9c3 8902 	strd	r8, r9, [r3, #8]
    p_reg->EVTENCLR = mask;
 101f5a4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 101f5a8:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
 101f5ac:	f382 8811 	msr	BASEPRI, r2
 101f5b0:	f3bf 8f6f 	isb	sy
		if (handler) {
 101f5b4:	2900      	cmp	r1, #0
 101f5b6:	d0e9      	beq.n	101f58c <rtc_nrf_isr+0x94>
			handler(chan, expire_time, user_context);
 101f5b8:	9000      	str	r0, [sp, #0]
 101f5ba:	4632      	mov	r2, r6
 101f5bc:	463b      	mov	r3, r7
 101f5be:	4628      	mov	r0, r5
 101f5c0:	4788      	blx	r1
}
 101f5c2:	e7e3      	b.n	101f58c <rtc_nrf_isr+0x94>
 101f5c4:	41016000 	.word	0x41016000
 101f5c8:	2100800c 	.word	0x2100800c
 101f5cc:	21008004 	.word	0x21008004
 101f5d0:	210043f0 	.word	0x210043f0

0101f5d4 <compare_set.constprop.0.isra.0>:
static int compare_set(int32_t chan, uint64_t target_time,
 101f5d4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 101f5d8:	4604      	mov	r4, r0
 101f5da:	460d      	mov	r5, r1
 101f5dc:	4f51      	ldr	r7, [pc, #324]	; (101f724 <compare_set.constprop.0.isra.0+0x150>)
 101f5de:	e8d7 8fef 	ldaex	r8, [r7]
 101f5e2:	f028 0301 	bic.w	r3, r8, #1
 101f5e6:	e8c7 3fe2 	stlex	r2, r3, [r7]
 101f5ea:	2a00      	cmp	r2, #0
 101f5ec:	d1f7      	bne.n	101f5de <compare_set.constprop.0.isra.0+0xa>
    p_reg->INTENCLR = mask;
 101f5ee:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 101f5f2:	f8df 9134 	ldr.w	r9, [pc, #308]	; 101f728 <compare_set.constprop.0.isra.0+0x154>
 101f5f6:	f8c9 3308 	str.w	r3, [r9, #776]	; 0x308
 101f5fa:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
 101f5fe:	f3bf 8f6f 	isb	sy
	return prev & BIT(chan);
 101f602:	f008 0301 	and.w	r3, r8, #1
 101f606:	9300      	str	r3, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
 101f608:	f7ff ff54 	bl	101f4b4 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
 101f60c:	42a0      	cmp	r0, r4
 101f60e:	eb71 0305 	sbcs.w	r3, r1, r5
 101f612:	d27c      	bcs.n	101f70e <compare_set.constprop.0.isra.0+0x13a>
		if (target_time - curr_time > COUNTER_SPAN) {
 101f614:	4b45      	ldr	r3, [pc, #276]	; (101f72c <compare_set.constprop.0.isra.0+0x158>)
 101f616:	1a20      	subs	r0, r4, r0
 101f618:	eb65 0101 	sbc.w	r1, r5, r1
 101f61c:	4298      	cmp	r0, r3
 101f61e:	f171 0100 	sbcs.w	r1, r1, #0
 101f622:	d256      	bcs.n	101f6d2 <compare_set.constprop.0.isra.0+0xfe>
		if (target_time != cc_data[chan].target_time) {
 101f624:	4b42      	ldr	r3, [pc, #264]	; (101f730 <compare_set.constprop.0.isra.0+0x15c>)
 101f626:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 101f62a:	429d      	cmp	r5, r3
 101f62c:	bf08      	it	eq
 101f62e:	4294      	cmpeq	r4, r2
 101f630:	d048      	beq.n	101f6c4 <compare_set.constprop.0.isra.0+0xf0>
	return absolute_time & COUNTER_MAX;
 101f632:	f024 4b7f 	bic.w	fp, r4, #4278190080	; 0xff000000
	uint32_t cc_val = abs_val & COUNTER_MAX;
 101f636:	465e      	mov	r6, fp
	uint32_t tick_inc = 2;
 101f638:	f04f 0a02 	mov.w	sl, #2
	return (a - b) & COUNTER_MAX;
 101f63c:	f06f 0801 	mvn.w	r8, #1
    return p_reg->CC[ch];
 101f640:	f8d9 3540 	ldr.w	r3, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
 101f644:	f8d9 1504 	ldr.w	r1, [r9, #1284]	; 0x504
 101f648:	1a5b      	subs	r3, r3, r1
 101f64a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
 101f64e:	f021 407f 	bic.w	r0, r1, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
 101f652:	2b01      	cmp	r3, #1
    p_reg->CC[ch] = cc_val;
 101f654:	f8c9 0540 	str.w	r0, [r9, #1344]	; 0x540
 101f658:	d104      	bne.n	101f664 <compare_set.constprop.0.isra.0+0x90>
 101f65a:	9101      	str	r1, [sp, #4]
	z_impl_k_busy_wait(usec_to_wait);
 101f65c:	2013      	movs	r0, #19
 101f65e:	f009 ff05 	bl	102946c <z_impl_k_busy_wait>
 101f662:	9901      	ldr	r1, [sp, #4]
	return (a - b) & COUNTER_MAX;
 101f664:	eba8 0301 	sub.w	r3, r8, r1
 101f668:	4433      	add	r3, r6
 101f66a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
 101f66e:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 101f672:	f04f 0300 	mov.w	r3, #0
 101f676:	f8c9 3140 	str.w	r3, [r9, #320]	; 0x140
 101f67a:	f8d9 3140 	ldr.w	r3, [r9, #320]	; 0x140
    p_reg->EVTENSET = mask;
 101f67e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
			cc_val = now + tick_inc;
 101f682:	bf88      	it	hi
 101f684:	eb01 060a 	addhi.w	r6, r1, sl
 101f688:	f8c9 3344 	str.w	r3, [r9, #836]	; 0x344
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
 101f68c:	f026 437f 	bic.w	r3, r6, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
 101f690:	f8c9 3540 	str.w	r3, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
 101f694:	f8d9 3504 	ldr.w	r3, [r9, #1284]	; 0x504
			tick_inc++;
 101f698:	bf88      	it	hi
 101f69a:	f10a 0a01 	addhi.w	sl, sl, #1
	} while ((now2 != now) &&
 101f69e:	4299      	cmp	r1, r3
 101f6a0:	d007      	beq.n	101f6b2 <compare_set.constprop.0.isra.0+0xde>
	return (a - b) & COUNTER_MAX;
 101f6a2:	eba8 0303 	sub.w	r3, r8, r3
 101f6a6:	4433      	add	r3, r6
 101f6a8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	} while ((now2 != now) &&
 101f6ac:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 101f6b0:	d82b      	bhi.n	101f70a <compare_set.constprop.0.isra.0+0x136>
	return (a - b) & COUNTER_MAX;
 101f6b2:	eba6 060b 	sub.w	r6, r6, fp
 101f6b6:	f026 467f 	bic.w	r6, r6, #4278190080	; 0xff000000
			target_time += counter_sub(cc_set, cc_value);
 101f6ba:	1936      	adds	r6, r6, r4
 101f6bc:	f145 0300 	adc.w	r3, r5, #0
 101f6c0:	4634      	mov	r4, r6
 101f6c2:	461d      	mov	r5, r3
	cc_data[chan].target_time = target_time;
 101f6c4:	4b1a      	ldr	r3, [pc, #104]	; (101f730 <compare_set.constprop.0.isra.0+0x15c>)
	cc_data[chan].callback = handler;
 101f6c6:	4a1b      	ldr	r2, [pc, #108]	; (101f734 <compare_set.constprop.0.isra.0+0x160>)
	cc_data[chan].target_time = target_time;
 101f6c8:	e9c3 4502 	strd	r4, r5, [r3, #8]
	cc_data[chan].callback = handler;
 101f6cc:	601a      	str	r2, [r3, #0]
	cc_data[chan].user_context = user_data;
 101f6ce:	2200      	movs	r2, #0
 101f6d0:	605a      	str	r2, [r3, #4]
	if (key) {
 101f6d2:	9b00      	ldr	r3, [sp, #0]
 101f6d4:	b1b3      	cbz	r3, 101f704 <compare_set.constprop.0.isra.0+0x130>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 101f6d6:	e8d7 3fef 	ldaex	r3, [r7]
 101f6da:	f043 0301 	orr.w	r3, r3, #1
 101f6de:	e8c7 3fe2 	stlex	r2, r3, [r7]
 101f6e2:	2a00      	cmp	r2, #0
 101f6e4:	d1f7      	bne.n	101f6d6 <compare_set.constprop.0.isra.0+0x102>
    p_reg->INTENSET = mask;
 101f6e6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 101f6ea:	4b0f      	ldr	r3, [pc, #60]	; (101f728 <compare_set.constprop.0.isra.0+0x154>)
 101f6ec:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 101f6f0:	4b11      	ldr	r3, [pc, #68]	; (101f738 <compare_set.constprop.0.isra.0+0x164>)
 101f6f2:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
 101f6f6:	07db      	lsls	r3, r3, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 101f6f8:	bf42      	ittt	mi
 101f6fa:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
 101f6fe:	4b0f      	ldrmi	r3, [pc, #60]	; (101f73c <compare_set.constprop.0.isra.0+0x168>)
 101f700:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
 101f704:	b003      	add	sp, #12
 101f706:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 101f70a:	4633      	mov	r3, r6
 101f70c:	e79a      	b.n	101f644 <compare_set.constprop.0.isra.0+0x70>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 101f70e:	4b0a      	ldr	r3, [pc, #40]	; (101f738 <compare_set.constprop.0.isra.0+0x164>)
 101f710:	e8d3 1fef 	ldaex	r1, [r3]
 101f714:	f041 0101 	orr.w	r1, r1, #1
 101f718:	e8c3 1fe2 	stlex	r2, r1, [r3]
 101f71c:	2a00      	cmp	r2, #0
 101f71e:	d0d1      	beq.n	101f6c4 <compare_set.constprop.0.isra.0+0xf0>
 101f720:	e7f6      	b.n	101f710 <compare_set.constprop.0.isra.0+0x13c>
 101f722:	bf00      	nop
 101f724:	21008008 	.word	0x21008008
 101f728:	41016000 	.word	0x41016000
 101f72c:	01000001 	.word	0x01000001
 101f730:	210043f0 	.word	0x210043f0
 101f734:	0101f435 	.word	0x0101f435
 101f738:	21008004 	.word	0x21008004
 101f73c:	e000e100 	.word	0xe000e100

0101f740 <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
 101f740:	b570      	push	{r4, r5, r6, lr}
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
 101f742:	f04f 30ff 	mov.w	r0, #4294967295
    p_reg->PRESCALER = val;
 101f746:	2500      	movs	r5, #0
 101f748:	f04f 31ff 	mov.w	r1, #4294967295
 101f74c:	4c13      	ldr	r4, [pc, #76]	; (101f79c <sys_clock_driver_init+0x5c>)
 101f74e:	4b14      	ldr	r3, [pc, #80]	; (101f7a0 <sys_clock_driver_init+0x60>)
 101f750:	f8c4 5508 	str.w	r5, [r4, #1288]	; 0x508
 101f754:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
 101f758:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 101f75c:	2602      	movs	r6, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 101f75e:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 101f762:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
 101f766:	4b0f      	ldr	r3, [pc, #60]	; (101f7a4 <sys_clock_driver_init+0x64>)

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
 101f768:	2101      	movs	r1, #1
 101f76a:	f8c4 6304 	str.w	r6, [r4, #772]	; 0x304
 101f76e:	2016      	movs	r0, #22
 101f770:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
 101f774:	462a      	mov	r2, r5
 101f776:	f7e6 fb67 	bl	1005e48 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
 101f77a:	2016      	movs	r0, #22
 101f77c:	f7e6 fb34 	bl	1005de8 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
 101f780:	2301      	movs	r3, #1

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
 101f782:	4a09      	ldr	r2, [pc, #36]	; (101f7a8 <sys_clock_driver_init+0x68>)
 101f784:	60a3      	str	r3, [r4, #8]
	}

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		MAX_TICKS : (counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
 101f786:	2100      	movs	r1, #0
 101f788:	6023      	str	r3, [r4, #0]
 101f78a:	4808      	ldr	r0, [pc, #32]	; (101f7ac <sys_clock_driver_init+0x6c>)
	int_mask = BIT_MASK(CHAN_COUNT);
 101f78c:	6013      	str	r3, [r2, #0]
	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
 101f78e:	f7ff ff21 	bl	101f5d4 <compare_set.constprop.0.isra.0>

	z_nrf_clock_control_lf_on(mode);
 101f792:	4630      	mov	r0, r6
 101f794:	f7fe ff88 	bl	101e6a8 <z_nrf_clock_control_lf_on>

	return 0;
}
 101f798:	4628      	mov	r0, r5
 101f79a:	bd70      	pop	{r4, r5, r6, pc}
 101f79c:	41016000 	.word	0x41016000
 101f7a0:	210043f0 	.word	0x210043f0
 101f7a4:	e000e100 	.word	0xe000e100
 101f7a8:	21008008 	.word	0x21008008
 101f7ac:	007fffff 	.word	0x007fffff

0101f7b0 <sys_clock_set_timeout>:
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 101f7b0:	1c43      	adds	r3, r0, #1
{
 101f7b2:	b510      	push	{r4, lr}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 101f7b4:	d01c      	beq.n	101f7f0 <sys_clock_set_timeout+0x40>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
 101f7b6:	2801      	cmp	r0, #1
 101f7b8:	dd1c      	ble.n	101f7f4 <sys_clock_set_timeout+0x44>
 101f7ba:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 101f7be:	da1b      	bge.n	101f7f8 <sys_clock_set_timeout+0x48>
 101f7c0:	1e44      	subs	r4, r0, #1
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
 101f7c2:	f7ff fe77 	bl	101f4b4 <z_nrf_rtc_timer_read>
 101f7c6:	4a0d      	ldr	r2, [pc, #52]	; (101f7fc <sys_clock_set_timeout+0x4c>)
 101f7c8:	e9d2 3100 	ldrd	r3, r1, [r2]
 101f7cc:	1ac0      	subs	r0, r0, r3
		ticks = 0;
 101f7ce:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 101f7d2:	bf28      	it	cs
 101f7d4:	2400      	movcs	r4, #0
	if (cyc > MAX_CYCLES) {
 101f7d6:	4a0a      	ldr	r2, [pc, #40]	; (101f800 <sys_clock_set_timeout+0x50>)
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
 101f7d8:	3001      	adds	r0, #1
 101f7da:	4420      	add	r0, r4
	if (cyc > MAX_CYCLES) {
 101f7dc:	4290      	cmp	r0, r2
 101f7de:	bf28      	it	cs
 101f7e0:	4610      	movcs	r0, r2
}
 101f7e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	uint64_t target_time = cyc + last_count;
 101f7e6:	18c0      	adds	r0, r0, r3
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
 101f7e8:	f141 0100 	adc.w	r1, r1, #0
 101f7ec:	f7ff bef2 	b.w	101f5d4 <compare_set.constprop.0.isra.0>
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 101f7f0:	4803      	ldr	r0, [pc, #12]	; (101f800 <sys_clock_set_timeout+0x50>)
 101f7f2:	e7e5      	b.n	101f7c0 <sys_clock_set_timeout+0x10>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
 101f7f4:	2400      	movs	r4, #0
 101f7f6:	e7e4      	b.n	101f7c2 <sys_clock_set_timeout+0x12>
 101f7f8:	4c01      	ldr	r4, [pc, #4]	; (101f800 <sys_clock_set_timeout+0x50>)
 101f7fa:	e7e2      	b.n	101f7c2 <sys_clock_set_timeout+0x12>
 101f7fc:	21004400 	.word	0x21004400
 101f800:	007fffff 	.word	0x007fffff

0101f804 <sys_clock_elapsed>:
{
 101f804:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
 101f806:	f7ff fe55 	bl	101f4b4 <z_nrf_rtc_timer_read>
 101f80a:	4b02      	ldr	r3, [pc, #8]	; (101f814 <sys_clock_elapsed+0x10>)
 101f80c:	681b      	ldr	r3, [r3, #0]
}
 101f80e:	1ac0      	subs	r0, r0, r3
 101f810:	bd08      	pop	{r3, pc}
 101f812:	bf00      	nop
 101f814:	21004400 	.word	0x21004400

0101f818 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
 101f818:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	z_impl_log_panic();
 101f81a:	f7e4 fe0f 	bl	100443c <z_impl_log_panic>
	ARG_UNUSED(reason);

	LOG_PANIC();

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
 101f81e:	4b07      	ldr	r3, [pc, #28]	; (101f83c <k_sys_fatal_error_handler+0x24>)
 101f820:	9305      	str	r3, [sp, #20]
 101f822:	2302      	movs	r3, #2
 101f824:	9304      	str	r3, [sp, #16]
 101f826:	4806      	ldr	r0, [pc, #24]	; (101f840 <k_sys_fatal_error_handler+0x28>)
 101f828:	2300      	movs	r3, #0
 101f82a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 101f82e:	aa04      	add	r2, sp, #16
 101f830:	f7e4 ff6a 	bl	1004708 <z_impl_z_log_msg_static_create>
		sys_arch_reboot(0);
 101f834:	2000      	movs	r0, #0
 101f836:	f7e6 ff49 	bl	10066cc <sys_arch_reboot>
		for (;;) {
			/* Spin endlessly */
		}
	}

	CODE_UNREACHABLE;
 101f83a:	bf00      	nop
 101f83c:	0102f31e 	.word	0x0102f31e
 101f840:	010299fc 	.word	0x010299fc

0101f844 <SystemInit>:
void SystemInit(void)
{
    /* Trimming of the device. Copy all the trimming values from FICR into the target addresses. Trim
     until one ADDR is not initialized. */
    uint32_t index = 0;
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 101f844:	2200      	movs	r2, #0
 101f846:	00d3      	lsls	r3, r2, #3
 101f848:	f103 73ff 	add.w	r3, r3, #33423360	; 0x1fe0000
 101f84c:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 101f850:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
 101f854:	3101      	adds	r1, #1
 101f856:	d007      	beq.n	101f868 <SystemInit+0x24>
        #if defined ( __ICCARM__ )
            /* IAR will complain about the order of volatile pointer accesses. */
            #pragma diag_suppress=Pa082
        #endif
        *((volatile uint32_t *)NRF_FICR_NS->TRIMCNF[index].ADDR) = NRF_FICR_NS->TRIMCNF[index].DATA;
 101f858:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 101f85c:	3201      	adds	r2, #1
        *((volatile uint32_t *)NRF_FICR_NS->TRIMCNF[index].ADDR) = NRF_FICR_NS->TRIMCNF[index].DATA;
 101f85e:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 101f862:	2a20      	cmp	r2, #32
        *((volatile uint32_t *)NRF_FICR_NS->TRIMCNF[index].ADDR) = NRF_FICR_NS->TRIMCNF[index].DATA;
 101f864:	600b      	str	r3, [r1, #0]
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 101f866:	d1ee      	bne.n	101f846 <SystemInit+0x2>
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
                #endif
            #elif defined(NRF_NETWORK)
                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
 101f868:	4b14      	ldr	r3, [pc, #80]	; (101f8bc <SystemInit+0x78>)
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)\
             || defined (NRF_NETWORK)
                if (var1 == 0x07)
 101f86a:	e9d3 324c 	ldrd	r3, r2, [r3, #304]	; 0x130
 101f86e:	2b07      	cmp	r3, #7
 101f870:	d107      	bne.n	101f882 <SystemInit+0x3e>
                {
                    switch(var2)
 101f872:	3a02      	subs	r2, #2
 101f874:	2a03      	cmp	r2, #3
 101f876:	4b12      	ldr	r3, [pc, #72]	; (101f8c0 <SystemInit+0x7c>)
 101f878:	d90c      	bls.n	101f894 <SystemInit+0x50>

    /* Workaround for Errata 55 "Bits in RESETREAS are set when they should not be" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf53_errata_55())
    {
        if (NRF_RESET_NS->RESETREAS & RESET_RESETREAS_RESETPIN_Msk){
 101f87a:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 101f87e:	07d1      	lsls	r1, r2, #31
 101f880:	d416      	bmi.n	101f8b0 <SystemInit+0x6c>
                /* Do nothing, allow user code to handle APPROTECT. Use this if you want to enable authenticated debug. */

        #else
            /* Load APPROTECT soft branch from UICR.
               If UICR->APPROTECT is disabled, CTRLAP->APPROTECT will be disabled. */
            NRF_CTRLAP_NS->APPROTECT.DISABLE = NRF_UICR_NS->APPROTECT;
 101f882:	4b10      	ldr	r3, [pc, #64]	; (101f8c4 <SystemInit+0x80>)
 101f884:	681a      	ldr	r2, [r3, #0]
 101f886:	4b10      	ldr	r3, [pc, #64]	; (101f8c8 <SystemInit+0x84>)
 101f888:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    SystemCoreClock = __SYSTEM_CLOCK;
 101f88c:	4b0f      	ldr	r3, [pc, #60]	; (101f8cc <SystemInit+0x88>)
 101f88e:	4a10      	ldr	r2, [pc, #64]	; (101f8d0 <SystemInit+0x8c>)
 101f890:	601a      	str	r2, [r3, #0]

    /* Handle fw-branch APPROTECT setup. */
    nrf53_handle_approtect();

    SystemCoreClockUpdate();
}
 101f892:	4770      	bx	lr
    if (nrf53_errata_49())
 101f894:	490f      	ldr	r1, [pc, #60]	; (101f8d4 <SystemInit+0x90>)
 101f896:	5c8a      	ldrb	r2, [r1, r2]
 101f898:	2a00      	cmp	r2, #0
 101f89a:	d0ee      	beq.n	101f87a <SystemInit+0x36>
        if (NRF_RESET_NS->RESETREAS & RESET_RESETREAS_RESETPIN_Msk)
 101f89c:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 101f8a0:	07d2      	lsls	r2, r2, #31
 101f8a2:	d5ea      	bpl.n	101f87a <SystemInit+0x36>
            NRF_POWER_NS->EVENTS_SLEEPENTER = 0;
 101f8a4:	2200      	movs	r2, #0
 101f8a6:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
            NRF_POWER_NS->EVENTS_SLEEPEXIT = 0;
 101f8aa:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)\
             || defined (NRF_NETWORK)
                if (var1 == 0x07)
 101f8ae:	e7e4      	b.n	101f87a <SystemInit+0x36>
            NRF_RESET_NS->RESETREAS = ~RESET_RESETREAS_RESETPIN_Msk;
 101f8b0:	f06f 0201 	mvn.w	r2, #1
 101f8b4:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
 101f8b8:	e7e3      	b.n	101f882 <SystemInit+0x3e>
 101f8ba:	bf00      	nop
 101f8bc:	01ff0000 	.word	0x01ff0000
 101f8c0:	41005000 	.word	0x41005000
 101f8c4:	01ff8000 	.word	0x01ff8000
 101f8c8:	41006000 	.word	0x41006000
 101f8cc:	21000a38 	.word	0x21000a38
 101f8d0:	03d09000 	.word	0x03d09000
 101f8d4:	0102f33b 	.word	0x0102f33b

0101f8d8 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
 101f8d8:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
 101f8da:	2501      	movs	r5, #1
        prev_mask = *p_mask;
 101f8dc:	6802      	ldr	r2, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
 101f8de:	fab2 f382 	clz	r3, r2
 101f8e2:	f1c3 031f 	rsb	r3, r3, #31
 101f8e6:	b2db      	uxtb	r3, r3
        new_mask = prev_mask & ~NRFX_BIT(idx);
 101f8e8:	fa05 f403 	lsl.w	r4, r5, r3
 101f8ec:	ea22 0404 	bic.w	r4, r2, r4
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 101f8f0:	e8d0 6fef 	ldaex	r6, [r0]
 101f8f4:	4296      	cmp	r6, r2
 101f8f6:	d104      	bne.n	101f902 <nrfx_flag32_alloc+0x2a>
 101f8f8:	e8c0 4fec 	stlex	ip, r4, [r0]
 101f8fc:	f1bc 0f00 	cmp.w	ip, #0
 101f900:	d1f6      	bne.n	101f8f0 <nrfx_flag32_alloc+0x18>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
 101f902:	d1eb      	bne.n	101f8dc <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
}
 101f904:	4801      	ldr	r0, [pc, #4]	; (101f90c <nrfx_flag32_alloc+0x34>)
    *p_flag = idx;
 101f906:	700b      	strb	r3, [r1, #0]
}
 101f908:	bd70      	pop	{r4, r5, r6, pc}
 101f90a:	bf00      	nop
 101f90c:	0bad0000 	.word	0x0bad0000

0101f910 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
 101f910:	b510      	push	{r4, lr}
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
 101f912:	6803      	ldr	r3, [r0, #0]
 101f914:	40cb      	lsrs	r3, r1
 101f916:	07db      	lsls	r3, r3, #31
 101f918:	d410      	bmi.n	101f93c <nrfx_flag32_free+0x2c>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
 101f91a:	2301      	movs	r3, #1
 101f91c:	408b      	lsls	r3, r1
        prev_mask = *p_mask;
 101f91e:	6802      	ldr	r2, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
 101f920:	ea43 0102 	orr.w	r1, r3, r2
 101f924:	e8d0 4fef 	ldaex	r4, [r0]
 101f928:	4294      	cmp	r4, r2
 101f92a:	d104      	bne.n	101f936 <nrfx_flag32_free+0x26>
 101f92c:	e8c0 1fec 	stlex	ip, r1, [r0]
 101f930:	f1bc 0f00 	cmp.w	ip, #0
 101f934:	d1f6      	bne.n	101f924 <nrfx_flag32_free+0x14>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
 101f936:	d1f2      	bne.n	101f91e <nrfx_flag32_free+0xe>

    return NRFX_SUCCESS;
 101f938:	4801      	ldr	r0, [pc, #4]	; (101f940 <nrfx_flag32_free+0x30>)
}
 101f93a:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
 101f93c:	4801      	ldr	r0, [pc, #4]	; (101f944 <nrfx_flag32_free+0x34>)
 101f93e:	e7fc      	b.n	101f93a <nrfx_flag32_free+0x2a>
 101f940:	0bad0000 	.word	0x0bad0000
 101f944:	0bad0004 	.word	0x0bad0004

0101f948 <clock_stop>:
    CoreDebug->DEMCR = core_debug;
}
#endif // NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_132)

static void clock_stop(nrf_clock_domain_t domain)
{
 101f948:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 101f94a:	4b34      	ldr	r3, [pc, #208]	; (101fa1c <clock_stop+0xd4>)
    switch (domain)
 101f94c:	4604      	mov	r4, r0
 101f94e:	b158      	cbz	r0, 101f968 <clock_stop+0x20>
 101f950:	2801      	cmp	r0, #1
 101f952:	d027      	beq.n	101f9a4 <clock_stop+0x5c>
            nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED);
            nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_HFCLKAUDIOSTOP);
            break;
#endif
        default:
            NRFX_ASSERT(0);
 101f954:	4932      	ldr	r1, [pc, #200]	; (101fa20 <clock_stop+0xd8>)
 101f956:	4833      	ldr	r0, [pc, #204]	; (101fa24 <clock_stop+0xdc>)
 101f958:	23d8      	movs	r3, #216	; 0xd8
 101f95a:	4a33      	ldr	r2, [pc, #204]	; (101fa28 <clock_stop+0xe0>)
 101f95c:	f005 f93b 	bl	1024bd6 <assert_print>
 101f960:	21d8      	movs	r1, #216	; 0xd8
 101f962:	4831      	ldr	r0, [pc, #196]	; (101fa28 <clock_stop+0xe0>)
            NRFX_ASSERT(0);
 101f964:	f005 f930 	bl	1024bc8 <assert_post_action>
    p_reg->INTENCLR = mask;
 101f968:	2202      	movs	r2, #2
 101f96a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 101f96e:	f8c3 0104 	str.w	r0, [r3, #260]	; 0x104
 101f972:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101f976:	2201      	movs	r2, #1
            return;
    }

    bool stopped;
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
 101f978:	4607      	mov	r7, r0
 101f97a:	60da      	str	r2, [r3, #12]
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
 101f97c:	2301      	movs	r3, #1
 101f97e:	f242 7510 	movw	r5, #10000	; 0x2710
 101f982:	4e26      	ldr	r6, [pc, #152]	; (101fa1c <clock_stop+0xd4>)
 101f984:	f88d 3007 	strb.w	r3, [sp, #7]
    switch (domain)
 101f988:	b1bc      	cbz	r4, 101f9ba <clock_stop+0x72>
 101f98a:	2c01      	cmp	r4, #1
 101f98c:	d033      	beq.n	101f9f6 <clock_stop+0xae>
            NRFX_ASSERT(0);
 101f98e:	4924      	ldr	r1, [pc, #144]	; (101fa20 <clock_stop+0xd8>)
 101f990:	4824      	ldr	r0, [pc, #144]	; (101fa24 <clock_stop+0xdc>)
 101f992:	f240 3347 	movw	r3, #839	; 0x347
 101f996:	4a25      	ldr	r2, [pc, #148]	; (101fa2c <clock_stop+0xe4>)
 101f998:	f005 f91d 	bl	1024bd6 <assert_print>
 101f99c:	f240 3147 	movw	r1, #839	; 0x347
 101f9a0:	4822      	ldr	r0, [pc, #136]	; (101fa2c <clock_stop+0xe4>)
 101f9a2:	e7df      	b.n	101f964 <clock_stop+0x1c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 101f9a4:	2200      	movs	r2, #0
    p_reg->INTENCLR = mask;
 101f9a6:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 101f9aa:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 101f9ae:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
 101f9b2:	f10d 0707 	add.w	r7, sp, #7
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101f9b6:	6058      	str	r0, [r3, #4]
 101f9b8:	e7e0      	b.n	101f97c <clock_stop+0x34>
            if (p_clk_src != NULL)
 101f9ba:	b18f      	cbz	r7, 101f9e0 <clock_stop+0x98>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 101f9bc:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
 101f9c0:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
 101f9c4:	703b      	strb	r3, [r7, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 101f9c6:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
 101f9ca:	03da      	lsls	r2, r3, #15
 101f9cc:	d511      	bpl.n	101f9f2 <clock_stop+0xaa>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
 101f9ce:	f89d 0007 	ldrb.w	r0, [sp, #7]
 101f9d2:	2801      	cmp	r0, #1
 101f9d4:	d10d      	bne.n	101f9f2 <clock_stop+0xaa>
 101f9d6:	f009 fb3c 	bl	1029052 <nrfx_busy_wait>
 101f9da:	3d01      	subs	r5, #1
 101f9dc:	d1d4      	bne.n	101f988 <clock_stop+0x40>
 101f9de:	e008      	b.n	101f9f2 <clock_stop+0xaa>
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 101f9e0:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
 101f9e4:	03d9      	lsls	r1, r3, #15
 101f9e6:	d504      	bpl.n	101f9f2 <clock_stop+0xaa>
 101f9e8:	2001      	movs	r0, #1
 101f9ea:	f009 fb32 	bl	1029052 <nrfx_busy_wait>
 101f9ee:	3d01      	subs	r5, #1
 101f9f0:	d1f6      	bne.n	101f9e0 <clock_stop+0x98>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
 101f9f2:	b003      	add	sp, #12
 101f9f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if (p_clk_src != NULL)
 101f9f6:	b13f      	cbz	r7, 101fa08 <clock_stop+0xc0>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
 101f9f8:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
 101f9fc:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
 101fa00:	703b      	strb	r3, [r7, #0]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
 101fa02:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
 101fa06:	e7e0      	b.n	101f9ca <clock_stop+0x82>
 101fa08:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
 101fa0c:	03db      	lsls	r3, r3, #15
 101fa0e:	d5f0      	bpl.n	101f9f2 <clock_stop+0xaa>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
 101fa10:	2001      	movs	r0, #1
 101fa12:	f009 fb1e 	bl	1029052 <nrfx_busy_wait>
 101fa16:	3d01      	subs	r5, #1
 101fa18:	d1f6      	bne.n	101fa08 <clock_stop+0xc0>
 101fa1a:	e7ea      	b.n	101f9f2 <clock_stop+0xaa>
 101fa1c:	41005000 	.word	0x41005000
 101fa20:	0102ff6e 	.word	0x0102ff6e
 101fa24:	0102b695 	.word	0x0102b695
 101fa28:	0102f33f 	.word	0x0102f33f
 101fa2c:	0102f37c 	.word	0x0102f37c

0101fa30 <nrfx_clock_init>:
    }
    return is_correct_clk;
}

nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
 101fa30:	b508      	push	{r3, lr}
    NRFX_ASSERT(event_handler);
 101fa32:	b958      	cbnz	r0, 101fa4c <nrfx_clock_init+0x1c>
 101fa34:	490a      	ldr	r1, [pc, #40]	; (101fa60 <nrfx_clock_init+0x30>)
 101fa36:	480b      	ldr	r0, [pc, #44]	; (101fa64 <nrfx_clock_init+0x34>)
 101fa38:	f240 1315 	movw	r3, #277	; 0x115
 101fa3c:	4a0a      	ldr	r2, [pc, #40]	; (101fa68 <nrfx_clock_init+0x38>)
 101fa3e:	f005 f8ca 	bl	1024bd6 <assert_print>
 101fa42:	f240 1115 	movw	r1, #277	; 0x115
 101fa46:	4808      	ldr	r0, [pc, #32]	; (101fa68 <nrfx_clock_init+0x38>)
 101fa48:	f005 f8be 	bl	1024bc8 <assert_post_action>

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
 101fa4c:	4b07      	ldr	r3, [pc, #28]	; (101fa6c <nrfx_clock_init+0x3c>)
 101fa4e:	791a      	ldrb	r2, [r3, #4]
 101fa50:	b922      	cbnz	r2, 101fa5c <nrfx_clock_init+0x2c>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
 101fa52:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
 101fa54:	6018      	str	r0, [r3, #0]
    nrfx_err_t err_code = NRFX_SUCCESS;
 101fa56:	4806      	ldr	r0, [pc, #24]	; (101fa70 <nrfx_clock_init+0x40>)
        m_clock_cb.module_initialized = true;
 101fa58:	711a      	strb	r2, [r3, #4]
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
 101fa5a:	bd08      	pop	{r3, pc}
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
 101fa5c:	4805      	ldr	r0, [pc, #20]	; (101fa74 <nrfx_clock_init+0x44>)
    return err_code;
 101fa5e:	e7fc      	b.n	101fa5a <nrfx_clock_init+0x2a>
 101fa60:	0102f3b0 	.word	0x0102f3b0
 101fa64:	0102b695 	.word	0x0102b695
 101fa68:	0102f33f 	.word	0x0102f33f
 101fa6c:	21008010 	.word	0x21008010
 101fa70:	0bad0000 	.word	0x0bad0000
 101fa74:	0bad000c 	.word	0x0bad000c

0101fa78 <nrfx_clock_enable>:

void nrfx_clock_enable(void)
{
 101fa78:	b508      	push	{r3, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
 101fa7a:	4b0e      	ldr	r3, [pc, #56]	; (101fab4 <nrfx_clock_enable+0x3c>)
 101fa7c:	791b      	ldrb	r3, [r3, #4]
 101fa7e:	b95b      	cbnz	r3, 101fa98 <nrfx_clock_enable+0x20>
 101fa80:	490d      	ldr	r1, [pc, #52]	; (101fab8 <nrfx_clock_enable+0x40>)
 101fa82:	480e      	ldr	r0, [pc, #56]	; (101fabc <nrfx_clock_enable+0x44>)
 101fa84:	f44f 7397 	mov.w	r3, #302	; 0x12e
 101fa88:	4a0d      	ldr	r2, [pc, #52]	; (101fac0 <nrfx_clock_enable+0x48>)
 101fa8a:	f005 f8a4 	bl	1024bd6 <assert_print>
 101fa8e:	f44f 7197 	mov.w	r1, #302	; 0x12e
 101fa92:	480b      	ldr	r0, [pc, #44]	; (101fac0 <nrfx_clock_enable+0x48>)
 101fa94:	f005 f898 	bl	1024bc8 <assert_post_action>
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
 101fa98:	2005      	movs	r0, #5
 101fa9a:	f7e6 f9c7 	bl	1005e2c <arch_irq_is_enabled>
 101fa9e:	b910      	cbnz	r0, 101faa6 <nrfx_clock_enable+0x2e>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
 101faa0:	2005      	movs	r0, #5
 101faa2:	f7e6 f9a1 	bl	1005de8 <arch_irq_enable>
    p_reg->LFCLKSRC = (uint32_t)(source);
 101faa6:	2201      	movs	r2, #1
 101faa8:	4b06      	ldr	r3, [pc, #24]	; (101fac4 <nrfx_clock_enable+0x4c>)
 101faaa:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}

#if NRF_CLOCK_HAS_HFCLKSRC
NRF_STATIC_INLINE void nrf_clock_hf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
{
    p_reg->HFCLKSRC = (uint32_t)(source);
 101faae:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
#if NRFX_CHECK(NRFX_POWER_ENABLED)
    nrfx_clock_irq_enabled = true;
#endif

    NRFX_LOG_INFO("Module enabled.");
}
 101fab2:	bd08      	pop	{r3, pc}
 101fab4:	21008010 	.word	0x21008010
 101fab8:	0102f3be 	.word	0x0102f3be
 101fabc:	0102b695 	.word	0x0102b695
 101fac0:	0102f33f 	.word	0x0102f33f
 101fac4:	41005000 	.word	0x41005000

0101fac8 <nrfx_clock_start>:
    m_clock_cb.module_initialized = false;
    NRFX_LOG_INFO("Uninitialized.");
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
 101fac8:	b508      	push	{r3, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
 101faca:	4b2a      	ldr	r3, [pc, #168]	; (101fb74 <nrfx_clock_start+0xac>)
 101facc:	791b      	ldrb	r3, [r3, #4]
 101face:	b95b      	cbnz	r3, 101fae8 <nrfx_clock_start+0x20>
 101fad0:	4929      	ldr	r1, [pc, #164]	; (101fb78 <nrfx_clock_start+0xb0>)
 101fad2:	f44f 73b4 	mov.w	r3, #360	; 0x168
 101fad6:	4a29      	ldr	r2, [pc, #164]	; (101fb7c <nrfx_clock_start+0xb4>)
 101fad8:	4829      	ldr	r0, [pc, #164]	; (101fb80 <nrfx_clock_start+0xb8>)
 101fada:	f005 f87c 	bl	1024bd6 <assert_print>
 101fade:	f44f 71b4 	mov.w	r1, #360	; 0x168
            nrf_clock_int_enable(NRF_CLOCK, NRF_CLOCK_INT_HFAUDIO_STARTED_MASK);
            nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_HFCLKAUDIOSTART);
            break;
#endif
        default:
            NRFX_ASSERT(0);
 101fae2:	4826      	ldr	r0, [pc, #152]	; (101fb7c <nrfx_clock_start+0xb4>)
 101fae4:	f005 f870 	bl	1024bc8 <assert_post_action>
    switch (domain)
 101fae8:	4b26      	ldr	r3, [pc, #152]	; (101fb84 <nrfx_clock_start+0xbc>)
 101faea:	b158      	cbz	r0, 101fb04 <nrfx_clock_start+0x3c>
 101faec:	2801      	cmp	r0, #1
 101faee:	d037      	beq.n	101fb60 <nrfx_clock_start+0x98>
            NRFX_ASSERT(0);
 101faf0:	4925      	ldr	r1, [pc, #148]	; (101fb88 <nrfx_clock_start+0xc0>)
 101faf2:	f44f 73d3 	mov.w	r3, #422	; 0x1a6
 101faf6:	4a21      	ldr	r2, [pc, #132]	; (101fb7c <nrfx_clock_start+0xb4>)
 101faf8:	4821      	ldr	r0, [pc, #132]	; (101fb80 <nrfx_clock_start+0xb8>)
 101fafa:	f005 f86c 	bl	1024bd6 <assert_print>
 101fafe:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
 101fb02:	e7ee      	b.n	101fae2 <nrfx_clock_start+0x1a>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 101fb04:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 101fb08:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
 101fb0c:	03c9      	lsls	r1, r1, #15
 101fb0e:	d511      	bpl.n	101fb34 <nrfx_clock_start+0x6c>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 101fb10:	f002 0303 	and.w	r3, r2, #3
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
 101fb14:	2b02      	cmp	r3, #2
 101fb16:	d11c      	bne.n	101fb52 <nrfx_clock_start+0x8a>
    p_reg->LFCLKSRC = (uint32_t)(source);
 101fb18:	4a1a      	ldr	r2, [pc, #104]	; (101fb84 <nrfx_clock_start+0xbc>)
 101fb1a:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 101fb1e:	2300      	movs	r3, #0
 101fb20:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
 101fb24:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
    p_reg->INTENSET = mask;
 101fb28:	2302      	movs	r3, #2
 101fb2a:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101fb2e:	2301      	movs	r3, #1
 101fb30:	6093      	str	r3, [r2, #8]
}
 101fb32:	e00d      	b.n	101fb50 <nrfx_clock_start+0x88>
            return ((p_reg->LFCLKRUN & CLOCK_LFCLKRUN_STATUS_Msk)
 101fb34:	f8d3 2414 	ldr.w	r2, [r3, #1044]	; 0x414
                else if (nrf_clock_start_task_check(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK))
 101fb38:	07d2      	lsls	r2, r2, #31
 101fb3a:	d50f      	bpl.n	101fb5c <nrfx_clock_start+0x94>
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
 101fb3c:	f8d3 241c 	ldr.w	r2, [r3, #1052]	; 0x41c
 101fb40:	f002 0203 	and.w	r2, r2, #3
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
 101fb44:	3a01      	subs	r2, #1
 101fb46:	2a01      	cmp	r2, #1
 101fb48:	d805      	bhi.n	101fb56 <nrfx_clock_start+0x8e>
    p_reg->INTENSET = mask;
 101fb4a:	2202      	movs	r2, #2
 101fb4c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
            break;
    }
}
 101fb50:	bd08      	pop	{r3, pc}
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
 101fb52:	2b01      	cmp	r3, #1
 101fb54:	d002      	beq.n	101fb5c <nrfx_clock_start+0x94>
        clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
 101fb56:	2000      	movs	r0, #0
 101fb58:	f7ff fef6 	bl	101f948 <clock_stop>
        *p_lfclksrc = clock_initial_lfclksrc_get();
 101fb5c:	2301      	movs	r3, #1
 101fb5e:	e7db      	b.n	101fb18 <nrfx_clock_start+0x50>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 101fb60:	2200      	movs	r2, #0
 101fb62:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 101fb66:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
 101fb6a:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101fb6e:	6018      	str	r0, [r3, #0]
}
 101fb70:	e7ee      	b.n	101fb50 <nrfx_clock_start+0x88>
 101fb72:	bf00      	nop
 101fb74:	21008010 	.word	0x21008010
 101fb78:	0102f3be 	.word	0x0102f3be
 101fb7c:	0102f33f 	.word	0x0102f33f
 101fb80:	0102b695 	.word	0x0102b695
 101fb84:	41005000 	.word	0x41005000
 101fb88:	0102ff6e 	.word	0x0102ff6e

0101fb8c <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
 101fb8c:	b508      	push	{r3, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
 101fb8e:	4b09      	ldr	r3, [pc, #36]	; (101fbb4 <nrfx_clock_stop+0x28>)
 101fb90:	791b      	ldrb	r3, [r3, #4]
 101fb92:	b95b      	cbnz	r3, 101fbac <nrfx_clock_stop+0x20>
 101fb94:	4908      	ldr	r1, [pc, #32]	; (101fbb8 <nrfx_clock_stop+0x2c>)
 101fb96:	4809      	ldr	r0, [pc, #36]	; (101fbbc <nrfx_clock_stop+0x30>)
 101fb98:	f240 13ad 	movw	r3, #429	; 0x1ad
 101fb9c:	4a08      	ldr	r2, [pc, #32]	; (101fbc0 <nrfx_clock_stop+0x34>)
 101fb9e:	f005 f81a 	bl	1024bd6 <assert_print>
 101fba2:	f240 11ad 	movw	r1, #429	; 0x1ad
 101fba6:	4806      	ldr	r0, [pc, #24]	; (101fbc0 <nrfx_clock_stop+0x34>)
 101fba8:	f005 f80e 	bl	1024bc8 <assert_post_action>
    clock_stop(domain);
}
 101fbac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    clock_stop(domain);
 101fbb0:	f7ff beca 	b.w	101f948 <clock_stop>
 101fbb4:	21008010 	.word	0x21008010
 101fbb8:	0102f3be 	.word	0x0102f3be
 101fbbc:	0102b695 	.word	0x0102b695
 101fbc0:	0102f33f 	.word	0x0102f33f

0101fbc4 <nrfx_power_clock_irq_handler>:
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
 101fbc4:	b510      	push	{r4, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
 101fbc6:	4b17      	ldr	r3, [pc, #92]	; (101fc24 <nrfx_power_clock_irq_handler+0x60>)
 101fbc8:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
 101fbcc:	b152      	cbz	r2, 101fbe4 <nrfx_power_clock_irq_handler+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 101fbce:	2000      	movs	r0, #0
 101fbd0:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
 101fbd4:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
 101fbd8:	2201      	movs	r2, #1
 101fbda:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
 101fbde:	4b12      	ldr	r3, [pc, #72]	; (101fc28 <nrfx_power_clock_irq_handler+0x64>)
 101fbe0:	681b      	ldr	r3, [r3, #0]
 101fbe2:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
 101fbe4:	4b0f      	ldr	r3, [pc, #60]	; (101fc24 <nrfx_power_clock_irq_handler+0x60>)
 101fbe6:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
 101fbea:	b18a      	cbz	r2, 101fc10 <nrfx_power_clock_irq_handler+0x4c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 101fbec:	2200      	movs	r2, #0
 101fbee:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
 101fbf2:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 101fbf6:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 101fbfa:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
 101fbfe:	f002 0203 	and.w	r2, r2, #3
 101fc02:	2a01      	cmp	r2, #1
 101fc04:	f04f 0102 	mov.w	r1, #2
 101fc08:	d103      	bne.n	101fc12 <nrfx_power_clock_irq_handler+0x4e>
    p_reg->LFCLKSRC = (uint32_t)(source);
 101fc0a:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101fc0e:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
 101fc10:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
 101fc12:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
 101fc16:	4b04      	ldr	r3, [pc, #16]	; (101fc28 <nrfx_power_clock_irq_handler+0x64>)
 101fc18:	2001      	movs	r0, #1
}
 101fc1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
 101fc1e:	681b      	ldr	r3, [r3, #0]
 101fc20:	4718      	bx	r3
 101fc22:	bf00      	nop
 101fc24:	41005000 	.word	0x41005000
 101fc28:	21008010 	.word	0x21008010

0101fc2c <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
 101fc2c:	4b03      	ldr	r3, [pc, #12]	; (101fc3c <pin_in_use_by_te+0x10>)
 101fc2e:	3008      	adds	r0, #8
 101fc30:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
 101fc34:	f3c0 1040 	ubfx	r0, r0, #5, #1
 101fc38:	4770      	bx	lr
 101fc3a:	bf00      	nop
 101fc3c:	21000a3c 	.word	0x21000a3c

0101fc40 <pin_has_trigger>:
 *
 * @return True if pin has trigger.
 */
static bool pin_has_trigger(uint32_t pin)
{
    return PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]) != NRFX_GPIOTE_TRIGGER_NONE;
 101fc40:	4b04      	ldr	r3, [pc, #16]	; (101fc54 <pin_has_trigger+0x14>)
 101fc42:	3008      	adds	r0, #8
 101fc44:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
 101fc48:	f010 001c 	ands.w	r0, r0, #28
 101fc4c:	bf18      	it	ne
 101fc4e:	2001      	movne	r0, #1
 101fc50:	4770      	bx	lr
 101fc52:	bf00      	nop
 101fc54:	21000a3c 	.word	0x21000a3c

0101fc58 <pin_is_output>:
 *
 * @return True if pin is output.
 */
static bool pin_is_output(uint32_t pin)
{
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
 101fc58:	4b03      	ldr	r3, [pc, #12]	; (101fc68 <pin_is_output+0x10>)
 101fc5a:	3008      	adds	r0, #8
 101fc5c:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
 101fc60:	f3c0 0040 	ubfx	r0, r0, #1, #1
 101fc64:	4770      	bx	lr
 101fc66:	bf00      	nop
 101fc68:	21000a3c 	.word	0x21000a3c

0101fc6c <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
 101fc6c:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
 101fc6e:	4c0d      	ldr	r4, [pc, #52]	; (101fca4 <call_handler+0x38>)
 101fc70:	f100 0308 	add.w	r3, r0, #8
 101fc74:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
{
 101fc78:	4605      	mov	r5, r0
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
 101fc7a:	05da      	lsls	r2, r3, #23
{
 101fc7c:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
 101fc7e:	d507      	bpl.n	101fc90 <call_handler+0x24>
 101fc80:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
 101fc84:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
 101fc88:	6852      	ldr	r2, [r2, #4]
 101fc8a:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
 101fc8e:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
 101fc90:	68a3      	ldr	r3, [r4, #8]
 101fc92:	b12b      	cbz	r3, 101fca0 <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
 101fc94:	4631      	mov	r1, r6
 101fc96:	4628      	mov	r0, r5
 101fc98:	68e2      	ldr	r2, [r4, #12]
    }
}
 101fc9a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
 101fc9e:	4718      	bx	r3
}
 101fca0:	bd70      	pop	{r4, r5, r6, pc}
 101fca2:	bf00      	nop
 101fca4:	21000a3c 	.word	0x21000a3c

0101fca8 <release_handler>:
{
 101fca8:	b510      	push	{r4, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
 101fcaa:	4a18      	ldr	r2, [pc, #96]	; (101fd0c <release_handler+0x64>)
 101fcac:	3008      	adds	r0, #8
 101fcae:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
 101fcb2:	05d9      	lsls	r1, r3, #23
 101fcb4:	d51d      	bpl.n	101fcf2 <release_handler+0x4a>
 101fcb6:	f3c3 2143 	ubfx	r1, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
 101fcba:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 101fcbe:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
 101fcc2:	2000      	movs	r0, #0
 101fcc4:	f102 040e 	add.w	r4, r2, #14
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
 101fcc8:	f834 3f02 	ldrh.w	r3, [r4, #2]!
 101fccc:	f413 7f80 	tst.w	r3, #256	; 0x100
 101fcd0:	d003      	beq.n	101fcda <release_handler+0x32>
 101fcd2:	f3c3 2343 	ubfx	r3, r3, #9, #4
 101fcd6:	4299      	cmp	r1, r3
 101fcd8:	d00b      	beq.n	101fcf2 <release_handler+0x4a>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
 101fcda:	3001      	adds	r0, #1
 101fcdc:	2830      	cmp	r0, #48	; 0x30
 101fcde:	d1f3      	bne.n	101fcc8 <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
 101fce0:	2300      	movs	r3, #0
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
 101fce2:	480b      	ldr	r0, [pc, #44]	; (101fd10 <release_handler+0x68>)
        m_cb.handlers[handler_id].handler = NULL;
 101fce4:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
 101fce8:	f7ff fe12 	bl	101f910 <nrfx_flag32_free>
        NRFX_ASSERT(err == NRFX_SUCCESS);
 101fcec:	4b09      	ldr	r3, [pc, #36]	; (101fd14 <release_handler+0x6c>)
 101fcee:	4298      	cmp	r0, r3
 101fcf0:	d100      	bne.n	101fcf4 <release_handler+0x4c>
}
 101fcf2:	bd10      	pop	{r4, pc}
        NRFX_ASSERT(err == NRFX_SUCCESS);
 101fcf4:	4908      	ldr	r1, [pc, #32]	; (101fd18 <release_handler+0x70>)
 101fcf6:	4809      	ldr	r0, [pc, #36]	; (101fd1c <release_handler+0x74>)
 101fcf8:	f44f 7399 	mov.w	r3, #306	; 0x132
 101fcfc:	4a08      	ldr	r2, [pc, #32]	; (101fd20 <release_handler+0x78>)
 101fcfe:	f004 ff6a 	bl	1024bd6 <assert_print>
 101fd02:	f44f 7199 	mov.w	r1, #306	; 0x132
 101fd06:	4806      	ldr	r0, [pc, #24]	; (101fd20 <release_handler+0x78>)
 101fd08:	f004 ff5e 	bl	1024bc8 <assert_post_action>
 101fd0c:	21000a3c 	.word	0x21000a3c
 101fd10:	21000ab0 	.word	0x21000ab0
 101fd14:	0bad0000 	.word	0x0bad0000
 101fd18:	0102f0bb 	.word	0x0102f0bb
 101fd1c:	0102b695 	.word	0x0102b695
 101fd20:	0102f3e7 	.word	0x0102f3e7

0101fd24 <pin_handler_trigger_uninit>:
{
 101fd24:	b538      	push	{r3, r4, r5, lr}
 101fd26:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
 101fd28:	f7ff ff80 	bl	101fc2c <pin_in_use_by_te>
 101fd2c:	4c0b      	ldr	r4, [pc, #44]	; (101fd5c <pin_handler_trigger_uninit+0x38>)
 101fd2e:	f102 0508 	add.w	r5, r2, #8
 101fd32:	b160      	cbz	r0, 101fd4e <pin_handler_trigger_uninit+0x2a>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
 101fd34:	2100      	movs	r1, #0
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
 101fd36:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
 101fd3a:	0b5b      	lsrs	r3, r3, #13
 101fd3c:	009b      	lsls	r3, r3, #2
 101fd3e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 101fd42:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
 101fd46:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
 101fd4a:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
    release_handler(pin);
 101fd4e:	4610      	mov	r0, r2
 101fd50:	f7ff ffaa 	bl	101fca8 <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
 101fd54:	2300      	movs	r3, #0
 101fd56:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
 101fd5a:	bd38      	pop	{r3, r4, r5, pc}
 101fd5c:	21000a3c 	.word	0x21000a3c

0101fd60 <nrf_gpio_pin_port_decode>:
{
 101fd60:	b508      	push	{r3, lr}
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
 101fd62:	6802      	ldr	r2, [r0, #0]
{
 101fd64:	4601      	mov	r1, r0
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
 101fd66:	4610      	mov	r0, r2
 101fd68:	f009 f975 	bl	1029056 <nrf_gpio_pin_present_check>
 101fd6c:	b958      	cbnz	r0, 101fd86 <nrf_gpio_pin_port_decode+0x26>
 101fd6e:	4910      	ldr	r1, [pc, #64]	; (101fdb0 <nrf_gpio_pin_port_decode+0x50>)
 101fd70:	f240 2347 	movw	r3, #583	; 0x247
 101fd74:	4a0f      	ldr	r2, [pc, #60]	; (101fdb4 <nrf_gpio_pin_port_decode+0x54>)
 101fd76:	4810      	ldr	r0, [pc, #64]	; (101fdb8 <nrf_gpio_pin_port_decode+0x58>)
 101fd78:	f004 ff2d 	bl	1024bd6 <assert_print>
 101fd7c:	f240 2147 	movw	r1, #583	; 0x247
            NRFX_ASSERT(0);
 101fd80:	480c      	ldr	r0, [pc, #48]	; (101fdb4 <nrf_gpio_pin_port_decode+0x54>)
 101fd82:	f004 ff21 	bl	1024bc8 <assert_post_action>
    *p_pin = pin_number & 0x1F;
 101fd86:	f002 031f 	and.w	r3, r2, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
 101fd8a:	0952      	lsrs	r2, r2, #5
    *p_pin = pin_number & 0x1F;
 101fd8c:	600b      	str	r3, [r1, #0]
    switch (nrf_gpio_pin_port_number_extract(p_pin))
 101fd8e:	d00b      	beq.n	101fda8 <nrf_gpio_pin_port_decode+0x48>
 101fd90:	2a01      	cmp	r2, #1
 101fd92:	d00b      	beq.n	101fdac <nrf_gpio_pin_port_decode+0x4c>
            NRFX_ASSERT(0);
 101fd94:	4909      	ldr	r1, [pc, #36]	; (101fdbc <nrf_gpio_pin_port_decode+0x5c>)
 101fd96:	f44f 7313 	mov.w	r3, #588	; 0x24c
 101fd9a:	4a06      	ldr	r2, [pc, #24]	; (101fdb4 <nrf_gpio_pin_port_decode+0x54>)
 101fd9c:	4806      	ldr	r0, [pc, #24]	; (101fdb8 <nrf_gpio_pin_port_decode+0x58>)
 101fd9e:	f004 ff1a 	bl	1024bd6 <assert_print>
 101fda2:	f44f 7113 	mov.w	r1, #588	; 0x24c
 101fda6:	e7eb      	b.n	101fd80 <nrf_gpio_pin_port_decode+0x20>
        case 0: return NRF_P0;
 101fda8:	4805      	ldr	r0, [pc, #20]	; (101fdc0 <nrf_gpio_pin_port_decode+0x60>)
}
 101fdaa:	bd08      	pop	{r3, pc}
    switch (nrf_gpio_pin_port_number_extract(p_pin))
 101fdac:	4805      	ldr	r0, [pc, #20]	; (101fdc4 <nrf_gpio_pin_port_decode+0x64>)
 101fdae:	e7fc      	b.n	101fdaa <nrf_gpio_pin_port_decode+0x4a>
 101fdb0:	0102f060 	.word	0x0102f060
 101fdb4:	0102f02d 	.word	0x0102f02d
 101fdb8:	0102b695 	.word	0x0102b695
 101fdbc:	0102ff6e 	.word	0x0102ff6e
 101fdc0:	418c0500 	.word	0x418c0500
 101fdc4:	418c0800 	.word	0x418c0800

0101fdc8 <nrfx_gpiote_input_configure>:
{
 101fdc8:	b5f0      	push	{r4, r5, r6, r7, lr}
 101fdca:	4604      	mov	r4, r0
 101fdcc:	4617      	mov	r7, r2
 101fdce:	461d      	mov	r5, r3
 101fdd0:	b085      	sub	sp, #20
    if (p_input_config)
 101fdd2:	b1d9      	cbz	r1, 101fe0c <nrfx_gpiote_input_configure+0x44>
        if (pin_is_task_output(pin))
 101fdd4:	f009 f950 	bl	1029078 <pin_is_task_output>
 101fdd8:	bb00      	cbnz	r0, 101fe1c <nrfx_gpiote_input_configure+0x54>
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
 101fdda:	460b      	mov	r3, r1
 101fddc:	e9cd 0000 	strd	r0, r0, [sp]
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
 101fde0:	f88d 000e 	strb.w	r0, [sp, #14]
        nrf_gpio_pin_input_t input_connect = NRF_GPIO_PIN_INPUT_CONNECT;
 101fde4:	f88d 000f 	strb.w	r0, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
 101fde8:	f10d 020f 	add.w	r2, sp, #15
 101fdec:	f10d 010e 	add.w	r1, sp, #14
 101fdf0:	4620      	mov	r0, r4
 101fdf2:	f009 f94c 	bl	102908e <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
 101fdf6:	4a44      	ldr	r2, [pc, #272]	; (101ff08 <nrfx_gpiote_input_configure+0x140>)
 101fdf8:	f104 0108 	add.w	r1, r4, #8
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
 101fdfc:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
 101fe00:	f023 0302 	bic.w	r3, r3, #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
 101fe04:	f043 0301 	orr.w	r3, r3, #1
 101fe08:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_trigger_config)
 101fe0c:	b36f      	cbz	r7, 101fe6a <nrfx_gpiote_input_configure+0xa2>
        if (pin_is_output(pin))
 101fe0e:	4620      	mov	r0, r4
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
 101fe10:	783e      	ldrb	r6, [r7, #0]
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
 101fe12:	687a      	ldr	r2, [r7, #4]
        if (pin_is_output(pin))
 101fe14:	f7ff ff20 	bl	101fc58 <pin_is_output>
 101fe18:	b110      	cbz	r0, 101fe20 <nrfx_gpiote_input_configure+0x58>
            if (use_evt)
 101fe1a:	b1da      	cbz	r2, 101fe54 <nrfx_gpiote_input_configure+0x8c>
            return NRFX_ERROR_INVALID_PARAM;
 101fe1c:	483b      	ldr	r0, [pc, #236]	; (101ff0c <nrfx_gpiote_input_configure+0x144>)
 101fe1e:	e026      	b.n	101fe6e <nrfx_gpiote_input_configure+0xa6>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
 101fe20:	4839      	ldr	r0, [pc, #228]	; (101ff08 <nrfx_gpiote_input_configure+0x140>)
 101fe22:	f104 0c08 	add.w	ip, r4, #8
 101fe26:	f830 301c 	ldrh.w	r3, [r0, ip, lsl #1]
 101fe2a:	f023 0320 	bic.w	r3, r3, #32
 101fe2e:	04db      	lsls	r3, r3, #19
 101fe30:	0cdb      	lsrs	r3, r3, #19
 101fe32:	f820 301c 	strh.w	r3, [r0, ip, lsl #1]
            if (use_evt)
 101fe36:	b16a      	cbz	r2, 101fe54 <nrfx_gpiote_input_configure+0x8c>
                if (!edge)
 101fe38:	2e03      	cmp	r6, #3
 101fe3a:	d8ef      	bhi.n	101fe1c <nrfx_gpiote_input_configure+0x54>
                uint8_t ch = *p_trigger_config->p_in_channel;
 101fe3c:	687a      	ldr	r2, [r7, #4]
 101fe3e:	7817      	ldrb	r7, [r2, #0]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
 101fe40:	00ba      	lsls	r2, r7, #2
 101fe42:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
 101fe46:	f502 4220 	add.w	r2, r2, #40960	; 0xa000
 101fe4a:	b996      	cbnz	r6, 101fe72 <nrfx_gpiote_input_configure+0xaa>
    p_reg->CONFIG[idx] = 0;
 101fe4c:	f8c2 6510 	str.w	r6, [r2, #1296]	; 0x510
    p_reg->CONFIG[idx] = 0;
 101fe50:	f8c2 6510 	str.w	r6, [r2, #1296]	; 0x510
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
 101fe54:	4a2c      	ldr	r2, [pc, #176]	; (101ff08 <nrfx_gpiote_input_configure+0x140>)
 101fe56:	f104 0108 	add.w	r1, r4, #8
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
 101fe5a:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
 101fe5e:	f023 031c 	bic.w	r3, r3, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
 101fe62:	ea43 0386 	orr.w	r3, r3, r6, lsl #2
 101fe66:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_handler_config)
 101fe6a:	bb15      	cbnz	r5, 101feb2 <nrfx_gpiote_input_configure+0xea>
        err = NRFX_SUCCESS;
 101fe6c:	4828      	ldr	r0, [pc, #160]	; (101ff10 <nrfx_gpiote_input_configure+0x148>)
}
 101fe6e:	b005      	add	sp, #20
 101fe70:	bdf0      	pop	{r4, r5, r6, r7, pc}
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
 101fe72:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
 101fe76:	ea43 3347 	orr.w	r3, r3, r7, lsl #13
 101fe7a:	f021 0103 	bic.w	r1, r1, #3
 101fe7e:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
 101fe82:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
 101fe86:	f043 0320 	orr.w	r3, r3, #32
 101fe8a:	f421 314f 	bic.w	r1, r1, #211968	; 0x33c00
 101fe8e:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 101fe92:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 101fe96:	0221      	lsls	r1, r4, #8
 101fe98:	f8d2 e510 	ldr.w	lr, [r2, #1296]	; 0x510
 101fe9c:	f401 517c 	and.w	r1, r1, #16128	; 0x3f00
 101fea0:	ea41 4106 	orr.w	r1, r1, r6, lsl #16
 101fea4:	ea41 010e 	orr.w	r1, r1, lr
 101fea8:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
 101feac:	f820 301c 	strh.w	r3, [r0, ip, lsl #1]
 101feb0:	e7d0      	b.n	101fe54 <nrfx_gpiote_input_configure+0x8c>
    release_handler(pin);
 101feb2:	4620      	mov	r0, r4
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
 101feb4:	e9d5 6700 	ldrd	r6, r7, [r5]
    release_handler(pin);
 101feb8:	f7ff fef6 	bl	101fca8 <release_handler>
    if (!handler)
 101febc:	2e00      	cmp	r6, #0
 101febe:	d0d5      	beq.n	101fe6c <nrfx_gpiote_input_configure+0xa4>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
 101fec0:	4d11      	ldr	r5, [pc, #68]	; (101ff08 <nrfx_gpiote_input_configure+0x140>)
 101fec2:	e9d5 2300 	ldrd	r2, r3, [r5]
 101fec6:	4296      	cmp	r6, r2
 101fec8:	d101      	bne.n	101fece <nrfx_gpiote_input_configure+0x106>
 101feca:	429f      	cmp	r7, r3
 101fecc:	d019      	beq.n	101ff02 <nrfx_gpiote_input_configure+0x13a>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
 101fece:	4811      	ldr	r0, [pc, #68]	; (101ff14 <nrfx_gpiote_input_configure+0x14c>)
 101fed0:	f10d 010f 	add.w	r1, sp, #15
 101fed4:	f7ff fd00 	bl	101f8d8 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
 101fed8:	4b0d      	ldr	r3, [pc, #52]	; (101ff10 <nrfx_gpiote_input_configure+0x148>)
 101feda:	4298      	cmp	r0, r3
 101fedc:	d1c7      	bne.n	101fe6e <nrfx_gpiote_input_configure+0xa6>
        handler_id = (int32_t)id;
 101fede:	f89d 200f 	ldrb.w	r2, [sp, #15]
    m_cb.handlers[handler_id].p_context = p_context;
 101fee2:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
 101fee6:	f104 0008 	add.w	r0, r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
 101feea:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
 101feec:	f835 3010 	ldrh.w	r3, [r5, r0, lsl #1]
    m_cb.handlers[handler_id].handler = handler;
 101fef0:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
 101fef4:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
 101fef8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 101fefc:	f825 3010 	strh.w	r3, [r5, r0, lsl #1]
    return NRFX_SUCCESS;
 101ff00:	e7b4      	b.n	101fe6c <nrfx_gpiote_input_configure+0xa4>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
 101ff02:	2200      	movs	r2, #0
 101ff04:	e7ed      	b.n	101fee2 <nrfx_gpiote_input_configure+0x11a>
 101ff06:	bf00      	nop
 101ff08:	21000a3c 	.word	0x21000a3c
 101ff0c:	0bad0004 	.word	0x0bad0004
 101ff10:	0bad0000 	.word	0x0bad0000
 101ff14:	21000ab0 	.word	0x21000ab0

0101ff18 <nrfx_gpiote_output_configure>:
{
 101ff18:	b5f0      	push	{r4, r5, r6, r7, lr}
 101ff1a:	4604      	mov	r4, r0
 101ff1c:	4616      	mov	r6, r2
 101ff1e:	b085      	sub	sp, #20
    if (p_config)
 101ff20:	b321      	cbz	r1, 101ff6c <nrfx_gpiote_output_configure+0x54>
    return !pin_is_output(pin);
 101ff22:	f7ff fe99 	bl	101fc58 <pin_is_output>
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
 101ff26:	b920      	cbnz	r0, 101ff32 <nrfx_gpiote_output_configure+0x1a>
 101ff28:	4620      	mov	r0, r4
 101ff2a:	f7ff fe7f 	bl	101fc2c <pin_in_use_by_te>
 101ff2e:	2800      	cmp	r0, #0
 101ff30:	d161      	bne.n	101fff6 <nrfx_gpiote_output_configure+0xde>
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
 101ff32:	4620      	mov	r0, r4
 101ff34:	f7ff fe84 	bl	101fc40 <pin_has_trigger>
 101ff38:	b110      	cbz	r0, 101ff40 <nrfx_gpiote_output_configure+0x28>
 101ff3a:	784b      	ldrb	r3, [r1, #1]
 101ff3c:	2b01      	cmp	r3, #1
 101ff3e:	d05a      	beq.n	101fff6 <nrfx_gpiote_output_configure+0xde>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_OUTPUT;
 101ff40:	2301      	movs	r3, #1
 101ff42:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
 101ff46:	2300      	movs	r3, #0
 101ff48:	1c4a      	adds	r2, r1, #1
 101ff4a:	e9cd 1300 	strd	r1, r3, [sp]
 101ff4e:	4620      	mov	r0, r4
 101ff50:	1c8b      	adds	r3, r1, #2
 101ff52:	f10d 010f 	add.w	r1, sp, #15
 101ff56:	f009 f89a 	bl	102908e <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
 101ff5a:	4a28      	ldr	r2, [pc, #160]	; (101fffc <nrfx_gpiote_output_configure+0xe4>)
 101ff5c:	f104 0108 	add.w	r1, r4, #8
 101ff60:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
 101ff64:	f043 0303 	orr.w	r3, r3, #3
 101ff68:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_task_config)
 101ff6c:	b916      	cbnz	r6, 101ff74 <nrfx_gpiote_output_configure+0x5c>
    return NRFX_SUCCESS;
 101ff6e:	4824      	ldr	r0, [pc, #144]	; (1020000 <nrfx_gpiote_output_configure+0xe8>)
}
 101ff70:	b005      	add	sp, #20
 101ff72:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return !pin_is_output(pin);
 101ff74:	4620      	mov	r0, r4
 101ff76:	f7ff fe6f 	bl	101fc58 <pin_is_output>
        if (pin_is_input(pin))
 101ff7a:	2800      	cmp	r0, #0
 101ff7c:	d03b      	beq.n	101fff6 <nrfx_gpiote_output_configure+0xde>
    p_reg->CONFIG[idx] = 0;
 101ff7e:	2300      	movs	r3, #0
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
 101ff80:	4a1e      	ldr	r2, [pc, #120]	; (101fffc <nrfx_gpiote_output_configure+0xe4>)
 101ff82:	f104 0708 	add.w	r7, r4, #8
        uint32_t ch = p_task_config->task_ch;
 101ff86:	f896 c000 	ldrb.w	ip, [r6]
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
 101ff8a:	f832 0017 	ldrh.w	r0, [r2, r7, lsl #1]
 101ff8e:	ea4f 018c 	mov.w	r1, ip, lsl #2
 101ff92:	f020 0020 	bic.w	r0, r0, #32
 101ff96:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
 101ff9a:	04c0      	lsls	r0, r0, #19
 101ff9c:	f501 4120 	add.w	r1, r1, #40960	; 0xa000
 101ffa0:	0cc0      	lsrs	r0, r0, #19
 101ffa2:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
 101ffa6:	f822 0017 	strh.w	r0, [r2, r7, lsl #1]
    p_reg->CONFIG[idx] = 0;
 101ffaa:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
 101ffae:	7875      	ldrb	r5, [r6, #1]
 101ffb0:	2d00      	cmp	r5, #0
 101ffb2:	d0dc      	beq.n	101ff6e <nrfx_gpiote_output_configure+0x56>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
 101ffb4:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
                                      p_task_config->init_val);
 101ffb8:	78b6      	ldrb	r6, [r6, #2]
 101ffba:	f423 1399 	bic.w	r3, r3, #1253376	; 0x132000
 101ffbe:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 101ffc2:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 101ffc6:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
 101ffca:	0223      	lsls	r3, r4, #8
 101ffcc:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
 101ffd0:	042d      	lsls	r5, r5, #16
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 101ffd2:	ea43 030e 	orr.w	r3, r3, lr
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
 101ffd6:	f405 3540 	and.w	r5, r5, #196608	; 0x30000
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
 101ffda:	0534      	lsls	r4, r6, #20
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 101ffdc:	432b      	orrs	r3, r5
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
 101ffde:	f404 1480 	and.w	r4, r4, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
 101ffe2:	ea40 304c 	orr.w	r0, r0, ip, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 101ffe6:	4323      	orrs	r3, r4
 101ffe8:	f040 0020 	orr.w	r0, r0, #32
 101ffec:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
 101fff0:	f822 0017 	strh.w	r0, [r2, r7, lsl #1]
 101fff4:	e7bb      	b.n	101ff6e <nrfx_gpiote_output_configure+0x56>
{
 101fff6:	4803      	ldr	r0, [pc, #12]	; (1020004 <nrfx_gpiote_output_configure+0xec>)
 101fff8:	e7ba      	b.n	101ff70 <nrfx_gpiote_output_configure+0x58>
 101fffa:	bf00      	nop
 101fffc:	21000a3c 	.word	0x21000a3c
 1020000:	0bad0000 	.word	0x0bad0000
 1020004:	0bad0004 	.word	0x0bad0004

01020008 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
 1020008:	4b01      	ldr	r3, [pc, #4]	; (1020010 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
 102000a:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
 102000e:	4770      	bx	lr
 1020010:	21000a3c 	.word	0x21000a3c

01020014 <nrfx_gpiote_channel_get>:
{
 1020014:	4602      	mov	r2, r0
 1020016:	b508      	push	{r3, lr}
    NRFX_ASSERT(p_channel);
 1020018:	b959      	cbnz	r1, 1020032 <nrfx_gpiote_channel_get+0x1e>
 102001a:	490c      	ldr	r1, [pc, #48]	; (102004c <nrfx_gpiote_channel_get+0x38>)
 102001c:	480c      	ldr	r0, [pc, #48]	; (1020050 <nrfx_gpiote_channel_get+0x3c>)
 102001e:	f240 2335 	movw	r3, #565	; 0x235
 1020022:	4a0c      	ldr	r2, [pc, #48]	; (1020054 <nrfx_gpiote_channel_get+0x40>)
 1020024:	f004 fdd7 	bl	1024bd6 <assert_print>
 1020028:	f240 2135 	movw	r1, #565	; 0x235
 102002c:	4809      	ldr	r0, [pc, #36]	; (1020054 <nrfx_gpiote_channel_get+0x40>)
 102002e:	f004 fdcb 	bl	1024bc8 <assert_post_action>
    if (pin_in_use_by_te(pin))
 1020032:	f7ff fdfb 	bl	101fc2c <pin_in_use_by_te>
 1020036:	b138      	cbz	r0, 1020048 <nrfx_gpiote_channel_get+0x34>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
 1020038:	4b07      	ldr	r3, [pc, #28]	; (1020058 <nrfx_gpiote_channel_get+0x44>)
 102003a:	3208      	adds	r2, #8
 102003c:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
        return NRFX_SUCCESS;
 1020040:	4806      	ldr	r0, [pc, #24]	; (102005c <nrfx_gpiote_channel_get+0x48>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
 1020042:	0b5b      	lsrs	r3, r3, #13
 1020044:	700b      	strb	r3, [r1, #0]
}
 1020046:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_PARAM;
 1020048:	4805      	ldr	r0, [pc, #20]	; (1020060 <nrfx_gpiote_channel_get+0x4c>)
 102004a:	e7fc      	b.n	1020046 <nrfx_gpiote_channel_get+0x32>
 102004c:	0102f425 	.word	0x0102f425
 1020050:	0102b695 	.word	0x0102b695
 1020054:	0102f3e7 	.word	0x0102f3e7
 1020058:	21000a3c 	.word	0x21000a3c
 102005c:	0bad0000 	.word	0x0bad0000
 1020060:	0bad0004 	.word	0x0bad0004

01020064 <nrfx_gpiote_init>:
{
 1020064:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
 1020066:	4c0f      	ldr	r4, [pc, #60]	; (10200a4 <nrfx_gpiote_init+0x40>)
 1020068:	f894 5078 	ldrb.w	r5, [r4, #120]	; 0x78
 102006c:	b9bd      	cbnz	r5, 102009e <nrfx_gpiote_init+0x3a>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
 102006e:	2260      	movs	r2, #96	; 0x60
 1020070:	4629      	mov	r1, r5
 1020072:	f104 0010 	add.w	r0, r4, #16
 1020076:	f006 fc88 	bl	102698a <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
 102007a:	200a      	movs	r0, #10
 102007c:	f7e5 feb4 	bl	1005de8 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 1020080:	4b09      	ldr	r3, [pc, #36]	; (10200a8 <nrfx_gpiote_init+0x44>)
    return err_code;
 1020082:	480a      	ldr	r0, [pc, #40]	; (10200ac <nrfx_gpiote_init+0x48>)
 1020084:	f8c3 517c 	str.w	r5, [r3, #380]	; 0x17c
 1020088:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
    p_reg->INTENSET = mask;
 102008c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 1020090:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
 1020094:	2301      	movs	r3, #1
 1020096:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
 102009a:	6763      	str	r3, [r4, #116]	; 0x74
}
 102009c:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
 102009e:	4804      	ldr	r0, [pc, #16]	; (10200b0 <nrfx_gpiote_init+0x4c>)
 10200a0:	e7fc      	b.n	102009c <nrfx_gpiote_init+0x38>
 10200a2:	bf00      	nop
 10200a4:	21000a3c 	.word	0x21000a3c
 10200a8:	4100a000 	.word	0x4100a000
 10200ac:	0bad0000 	.word	0x0bad0000
 10200b0:	0bad0005 	.word	0x0bad0005

010200b4 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
 10200b4:	4b03      	ldr	r3, [pc, #12]	; (10200c4 <nrfx_gpiote_is_init+0x10>)
 10200b6:	f893 0078 	ldrb.w	r0, [r3, #120]	; 0x78
}
 10200ba:	3800      	subs	r0, #0
 10200bc:	bf18      	it	ne
 10200be:	2001      	movne	r0, #1
 10200c0:	4770      	bx	lr
 10200c2:	bf00      	nop
 10200c4:	21000a3c 	.word	0x21000a3c

010200c8 <nrfx_gpiote_channel_free>:
{
 10200c8:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
 10200ca:	4801      	ldr	r0, [pc, #4]	; (10200d0 <nrfx_gpiote_channel_free+0x8>)
 10200cc:	f7ff bc20 	b.w	101f910 <nrfx_flag32_free>
 10200d0:	21000aac 	.word	0x21000aac

010200d4 <nrfx_gpiote_channel_alloc>:
{
 10200d4:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
 10200d6:	4801      	ldr	r0, [pc, #4]	; (10200dc <nrfx_gpiote_channel_alloc+0x8>)
 10200d8:	f7ff bbfe 	b.w	101f8d8 <nrfx_flag32_alloc>
 10200dc:	21000aac 	.word	0x21000aac

010200e0 <nrfx_gpiote_trigger_enable>:
{
 10200e0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 10200e2:	4604      	mov	r4, r0
    NRFX_ASSERT(pin_has_trigger(pin));
 10200e4:	f7ff fdac 	bl	101fc40 <pin_has_trigger>
 10200e8:	b958      	cbnz	r0, 1020102 <nrfx_gpiote_trigger_enable+0x22>
 10200ea:	492d      	ldr	r1, [pc, #180]	; (10201a0 <nrfx_gpiote_trigger_enable+0xc0>)
 10200ec:	f240 33df 	movw	r3, #991	; 0x3df
 10200f0:	4a2c      	ldr	r2, [pc, #176]	; (10201a4 <nrfx_gpiote_trigger_enable+0xc4>)
 10200f2:	482d      	ldr	r0, [pc, #180]	; (10201a8 <nrfx_gpiote_trigger_enable+0xc8>)
 10200f4:	f004 fd6f 	bl	1024bd6 <assert_print>
 10200f8:	f240 31df 	movw	r1, #991	; 0x3df
        NRFX_ASSERT(int_enable);
 10200fc:	4829      	ldr	r0, [pc, #164]	; (10201a4 <nrfx_gpiote_trigger_enable+0xc4>)
 10200fe:	f004 fd63 	bl	1024bc8 <assert_post_action>
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
 1020102:	4620      	mov	r0, r4
 1020104:	f7ff fd92 	bl	101fc2c <pin_in_use_by_te>
 1020108:	4a28      	ldr	r2, [pc, #160]	; (10201ac <nrfx_gpiote_trigger_enable+0xcc>)
 102010a:	f104 0508 	add.w	r5, r4, #8
 102010e:	b1f8      	cbz	r0, 1020150 <nrfx_gpiote_trigger_enable+0x70>
    return !pin_is_output(pin);
 1020110:	4620      	mov	r0, r4
 1020112:	f7ff fda1 	bl	101fc58 <pin_is_output>
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
 1020116:	b9d8      	cbnz	r0, 1020150 <nrfx_gpiote_trigger_enable+0x70>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
 1020118:	f832 2015 	ldrh.w	r2, [r2, r5, lsl #1]
 102011c:	0b52      	lsrs	r2, r2, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
 102011e:	0093      	lsls	r3, r2, #2
    return ((uint32_t)p_reg + event);
 1020120:	f103 4482 	add.w	r4, r3, #1090519040	; 0x41000000
 1020124:	f504 4421 	add.w	r4, r4, #41216	; 0xa100
 1020128:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 102012c:	6020      	str	r0, [r4, #0]
 102012e:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
 1020132:	6820      	ldr	r0, [r4, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
 1020134:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
 1020138:	f040 0001 	orr.w	r0, r0, #1
 102013c:	f8c3 0510 	str.w	r0, [r3, #1296]	; 0x510
        if (int_enable)
 1020140:	b121      	cbz	r1, 102014c <nrfx_gpiote_trigger_enable+0x6c>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
 1020142:	2301      	movs	r3, #1
 1020144:	4093      	lsls	r3, r2
    p_reg->INTENSET = mask;
 1020146:	4a1a      	ldr	r2, [pc, #104]	; (10201b0 <nrfx_gpiote_trigger_enable+0xd0>)
 1020148:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
 102014c:	b003      	add	sp, #12
 102014e:	bd30      	pop	{r4, r5, pc}
        NRFX_ASSERT(int_enable);
 1020150:	b949      	cbnz	r1, 1020166 <nrfx_gpiote_trigger_enable+0x86>
 1020152:	4918      	ldr	r1, [pc, #96]	; (10201b4 <nrfx_gpiote_trigger_enable+0xd4>)
 1020154:	f240 33ee 	movw	r3, #1006	; 0x3ee
 1020158:	4a12      	ldr	r2, [pc, #72]	; (10201a4 <nrfx_gpiote_trigger_enable+0xc4>)
 102015a:	4813      	ldr	r0, [pc, #76]	; (10201a8 <nrfx_gpiote_trigger_enable+0xc8>)
 102015c:	f004 fd3b 	bl	1024bd6 <assert_print>
 1020160:	f240 31ee 	movw	r1, #1006	; 0x3ee
 1020164:	e7ca      	b.n	10200fc <nrfx_gpiote_trigger_enable+0x1c>
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
 1020166:	f832 3015 	ldrh.w	r3, [r2, r5, lsl #1]
 102016a:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
 102016e:	2b04      	cmp	r3, #4
 1020170:	d011      	beq.n	1020196 <nrfx_gpiote_trigger_enable+0xb6>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
 1020172:	2b05      	cmp	r3, #5
 1020174:	d011      	beq.n	102019a <nrfx_gpiote_trigger_enable+0xba>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 1020176:	a801      	add	r0, sp, #4
 1020178:	9401      	str	r4, [sp, #4]
 102017a:	f7ff fdf1 	bl	101fd60 <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
 102017e:	9b01      	ldr	r3, [sp, #4]
    return p_reg->IN;
 1020180:	6901      	ldr	r1, [r0, #16]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
 1020182:	40d9      	lsrs	r1, r3
 1020184:	f001 0101 	and.w	r1, r1, #1
 1020188:	3102      	adds	r1, #2
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
 102018a:	4620      	mov	r0, r4
}
 102018c:	b003      	add	sp, #12
 102018e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
 1020192:	f008 bfc9 	b.w	1029128 <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
 1020196:	2103      	movs	r1, #3
 1020198:	e7f7      	b.n	102018a <nrfx_gpiote_trigger_enable+0xaa>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
 102019a:	2102      	movs	r1, #2
 102019c:	e7f5      	b.n	102018a <nrfx_gpiote_trigger_enable+0xaa>
 102019e:	bf00      	nop
 10201a0:	0102f42f 	.word	0x0102f42f
 10201a4:	0102f3e7 	.word	0x0102f3e7
 10201a8:	0102b695 	.word	0x0102b695
 10201ac:	21000a3c 	.word	0x21000a3c
 10201b0:	4100a000 	.word	0x4100a000
 10201b4:	0102f444 	.word	0x0102f444

010201b8 <nrfx_gpiote_trigger_disable>:
{
 10201b8:	b508      	push	{r3, lr}
 10201ba:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
 10201bc:	f7ff fd36 	bl	101fc2c <pin_in_use_by_te>
 10201c0:	b1c8      	cbz	r0, 10201f6 <nrfx_gpiote_trigger_disable+0x3e>
    return !pin_is_output(pin);
 10201c2:	4610      	mov	r0, r2
 10201c4:	f7ff fd48 	bl	101fc58 <pin_is_output>
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
 10201c8:	b9a8      	cbnz	r0, 10201f6 <nrfx_gpiote_trigger_disable+0x3e>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
 10201ca:	4b0e      	ldr	r3, [pc, #56]	; (1020204 <nrfx_gpiote_trigger_disable+0x4c>)
 10201cc:	3208      	adds	r2, #8
 10201ce:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
 10201d2:	2201      	movs	r2, #1
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
 10201d4:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
 10201d6:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
 10201d8:	490b      	ldr	r1, [pc, #44]	; (1020208 <nrfx_gpiote_trigger_disable+0x50>)
 10201da:	009b      	lsls	r3, r3, #2
 10201dc:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 10201e0:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
 10201e4:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
 10201e8:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
 10201ec:	f022 0203 	bic.w	r2, r2, #3
 10201f0:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
 10201f4:	bd08      	pop	{r3, pc}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
 10201f6:	2100      	movs	r1, #0
}
 10201f8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
 10201fc:	4610      	mov	r0, r2
 10201fe:	f008 bf93 	b.w	1029128 <nrf_gpio_cfg_sense_set>
 1020202:	bf00      	nop
 1020204:	21000a3c 	.word	0x21000a3c
 1020208:	4100a000 	.word	0x4100a000

0102020c <nrfx_gpiote_pin_uninit>:
{
 102020c:	b513      	push	{r0, r1, r4, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
 102020e:	4b10      	ldr	r3, [pc, #64]	; (1020250 <nrfx_gpiote_pin_uninit+0x44>)
 1020210:	f100 0208 	add.w	r2, r0, #8
 1020214:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
{
 1020218:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
 102021a:	07db      	lsls	r3, r3, #31
 102021c:	d516      	bpl.n	102024c <nrfx_gpiote_pin_uninit+0x40>
    nrfx_gpiote_trigger_disable(pin);
 102021e:	f7ff ffcb 	bl	10201b8 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
 1020222:	4620      	mov	r0, r4
 1020224:	f7ff fd7e 	bl	101fd24 <pin_handler_trigger_uninit>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 1020228:	a801      	add	r0, sp, #4
 102022a:	9401      	str	r4, [sp, #4]
 102022c:	f7ff fd98 	bl	101fd60 <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
 1020230:	9b01      	ldr	r3, [sp, #4]
 1020232:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 1020236:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
 102023a:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
 102023e:	f043 0302 	orr.w	r3, r3, #2
    reg->PIN_CNF[pin_number] = cnf;
 1020242:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
    nrf_gpio_cfg(
 1020246:	4803      	ldr	r0, [pc, #12]	; (1020254 <nrfx_gpiote_pin_uninit+0x48>)
}
 1020248:	b002      	add	sp, #8
 102024a:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
 102024c:	4802      	ldr	r0, [pc, #8]	; (1020258 <nrfx_gpiote_pin_uninit+0x4c>)
 102024e:	e7fb      	b.n	1020248 <nrfx_gpiote_pin_uninit+0x3c>
 1020250:	21000a3c 	.word	0x21000a3c
 1020254:	0bad0000 	.word	0x0bad0000
 1020258:	0bad0004 	.word	0x0bad0004

0102025c <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
 102025c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t status = 0;
 1020260:	2600      	movs	r6, #0
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
 1020262:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 1020264:	4634      	mov	r4, r6
{
 1020266:	4b66      	ldr	r3, [pc, #408]	; (1020400 <nrfx_gpiote_irq_handler+0x1a4>)
    return p_reg->INTENSET & mask;
 1020268:	4866      	ldr	r0, [pc, #408]	; (1020404 <nrfx_gpiote_irq_handler+0x1a8>)

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
 102026a:	4967      	ldr	r1, [pc, #412]	; (1020408 <nrfx_gpiote_irq_handler+0x1ac>)
{
 102026c:	b087      	sub	sp, #28
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 102026e:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
 1020270:	b135      	cbz	r5, 1020280 <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
 1020272:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
 1020276:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 1020278:	bf1e      	ittt	ne
 102027a:	601c      	strne	r4, [r3, #0]
 102027c:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
 102027e:	4316      	orrne	r6, r2
    for (i = 0; i < GPIOTE_CH_NUM; i++)
 1020280:	3304      	adds	r3, #4
 1020282:	428b      	cmp	r3, r1
        }
        mask <<= 1;
 1020284:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
 1020288:	d1f1      	bne.n	102026e <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 102028a:	4b5e      	ldr	r3, [pc, #376]	; (1020404 <nrfx_gpiote_irq_handler+0x1a8>)
 102028c:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
 1020290:	2b00      	cmp	r3, #0
 1020292:	f000 8098 	beq.w	10203c6 <nrfx_gpiote_irq_handler+0x16a>
        *p_masks = gpio_regs[i]->LATCH;
 1020296:	f8df 9174 	ldr.w	r9, [pc, #372]	; 102040c <nrfx_gpiote_irq_handler+0x1b0>
 102029a:	f8df 8174 	ldr.w	r8, [pc, #372]	; 1020410 <nrfx_gpiote_irq_handler+0x1b4>
 102029e:	f8d9 3020 	ldr.w	r3, [r9, #32]
 10202a2:	9304      	str	r3, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
 10202a4:	f8c9 3020 	str.w	r3, [r9, #32]
        *p_masks = gpio_regs[i]->LATCH;
 10202a8:	f8d8 3020 	ldr.w	r3, [r8, #32]
 10202ac:	9305      	str	r3, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
 10202ae:	f8c8 3020 	str.w	r3, [r8, #32]
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
 10202b2:	f04f 0a00 	mov.w	sl, #0
            while (latch[i])
 10202b6:	f10d 0b10 	add.w	fp, sp, #16
 10202ba:	ea4f 134a 	mov.w	r3, sl, lsl #5
 10202be:	9300      	str	r3, [sp, #0]
 10202c0:	e04a      	b.n	1020358 <nrfx_gpiote_irq_handler+0xfc>
                uint32_t pin = NRF_CTZ(latch[i]);
 10202c2:	fa94 f4a4 	rbit	r4, r4
 10202c6:	fab4 f484 	clz	r4, r4
                pin += 32 * i;
 10202ca:	9b00      	ldr	r3, [sp, #0]
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
 10202cc:	4a51      	ldr	r2, [pc, #324]	; (1020414 <nrfx_gpiote_irq_handler+0x1b8>)
                pin += 32 * i;
 10202ce:	441c      	add	r4, r3
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
 10202d0:	f104 0308 	add.w	r3, r4, #8
 10202d4:	f832 7013 	ldrh.w	r7, [r2, r3, lsl #1]
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
 10202d8:	2301      	movs	r3, #1
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
 10202da:	08e0      	lsrs	r0, r4, #3
    bit = BITMASK_RELBIT_GET(bit);
 10202dc:	f004 0107 	and.w	r1, r4, #7
    p_mask8[byte_idx] &= ~(1 << bit);
 10202e0:	fa03 f101 	lsl.w	r1, r3, r1
 10202e4:	f81b 3000 	ldrb.w	r3, [fp, r0]
 10202e8:	08ba      	lsrs	r2, r7, #2
 10202ea:	ea23 0301 	bic.w	r3, r3, r1
 10202ee:	f80b 3000 	strb.w	r3, [fp, r0]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 10202f2:	a803      	add	r0, sp, #12
 10202f4:	9201      	str	r2, [sp, #4]
 10202f6:	9403      	str	r4, [sp, #12]
 10202f8:	f7ff fd32 	bl	101fd60 <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
 10202fc:	9b03      	ldr	r3, [sp, #12]
    if (is_level(trigger))
 10202fe:	9a01      	ldr	r2, [sp, #4]
 1020300:	3380      	adds	r3, #128	; 0x80
 1020302:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
 1020306:	f3c7 0582 	ubfx	r5, r7, #2, #3
    if (is_level(trigger))
 102030a:	0752      	lsls	r2, r2, #29
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
 102030c:	462f      	mov	r7, r5
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
 102030e:	f3c3 4301 	ubfx	r3, r3, #16, #2
    if (is_level(trigger))
 1020312:	d52b      	bpl.n	102036c <nrfx_gpiote_irq_handler+0x110>
        call_handler(pin, trigger);
 1020314:	4639      	mov	r1, r7
 1020316:	4620      	mov	r0, r4
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
 1020318:	b2dd      	uxtb	r5, r3
 102031a:	f7ff fca7 	bl	101fc6c <call_handler>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 102031e:	a803      	add	r0, sp, #12
 1020320:	9403      	str	r4, [sp, #12]
 1020322:	f7ff fd1d 	bl	101fd60 <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
 1020326:	9b03      	ldr	r3, [sp, #12]
 1020328:	3380      	adds	r3, #128	; 0x80
 102032a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
        if (nrf_gpio_pin_sense_get(pin) == sense)
 102032e:	f3c3 4301 	ubfx	r3, r3, #16, #2
 1020332:	429d      	cmp	r5, r3
 1020334:	d107      	bne.n	1020346 <nrfx_gpiote_irq_handler+0xea>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
 1020336:	2100      	movs	r1, #0
 1020338:	4620      	mov	r0, r4
 102033a:	f008 fef5 	bl	1029128 <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
 102033e:	4629      	mov	r1, r5
 1020340:	4620      	mov	r0, r4
 1020342:	f008 fef1 	bl	1029128 <nrf_gpio_cfg_sense_set>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 1020346:	a803      	add	r0, sp, #12
 1020348:	9403      	str	r4, [sp, #12]
 102034a:	f7ff fd09 	bl	101fd60 <nrf_gpio_pin_port_decode>
    reg->LATCH = (1 << pin_number);
 102034e:	2201      	movs	r2, #1
 1020350:	9b03      	ldr	r3, [sp, #12]
 1020352:	fa02 f303 	lsl.w	r3, r2, r3
 1020356:	6203      	str	r3, [r0, #32]
            while (latch[i])
 1020358:	f85b 402a 	ldr.w	r4, [fp, sl, lsl #2]
 102035c:	2c00      	cmp	r4, #0
 102035e:	d1b0      	bne.n	10202c2 <nrfx_gpiote_irq_handler+0x66>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
 1020360:	f1ba 0f00 	cmp.w	sl, #0
 1020364:	d11d      	bne.n	10203a2 <nrfx_gpiote_irq_handler+0x146>
 1020366:	f04f 0a01 	mov.w	sl, #1
 102036a:	e7a6      	b.n	10202ba <nrfx_gpiote_irq_handler+0x5e>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
 102036c:	2b02      	cmp	r3, #2
 102036e:	d10c      	bne.n	102038a <nrfx_gpiote_irq_handler+0x12e>
        nrf_gpio_cfg_sense_set(pin, next_sense);
 1020370:	2103      	movs	r1, #3
 1020372:	4620      	mov	r0, r4
 1020374:	f008 fed8 	bl	1029128 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
 1020378:	f005 0305 	and.w	r3, r5, #5
 102037c:	2b01      	cmp	r3, #1
 102037e:	d1e2      	bne.n	1020346 <nrfx_gpiote_irq_handler+0xea>
            call_handler(pin, trigger);
 1020380:	4639      	mov	r1, r7
 1020382:	4620      	mov	r0, r4
 1020384:	f7ff fc72 	bl	101fc6c <call_handler>
 1020388:	e7dd      	b.n	1020346 <nrfx_gpiote_irq_handler+0xea>
        nrf_gpio_cfg_sense_set(pin, next_sense);
 102038a:	2102      	movs	r1, #2
 102038c:	4620      	mov	r0, r4
 102038e:	9301      	str	r3, [sp, #4]
 1020390:	f008 feca 	bl	1029128 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
 1020394:	2d03      	cmp	r5, #3
 1020396:	d0f3      	beq.n	1020380 <nrfx_gpiote_irq_handler+0x124>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
 1020398:	9b01      	ldr	r3, [sp, #4]
 102039a:	2b03      	cmp	r3, #3
 102039c:	d1d3      	bne.n	1020346 <nrfx_gpiote_irq_handler+0xea>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
 102039e:	2d02      	cmp	r5, #2
 10203a0:	e7ed      	b.n	102037e <nrfx_gpiote_irq_handler+0x122>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 10203a2:	4b18      	ldr	r3, [pc, #96]	; (1020404 <nrfx_gpiote_irq_handler+0x1a8>)
 10203a4:	f8c3 417c 	str.w	r4, [r3, #380]	; 0x17c
 10203a8:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
        *p_masks = gpio_regs[i]->LATCH;
 10203ac:	f8d9 3020 	ldr.w	r3, [r9, #32]
 10203b0:	9304      	str	r3, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
 10203b2:	f8c9 3020 	str.w	r3, [r9, #32]
        *p_masks = gpio_regs[i]->LATCH;
 10203b6:	f8d8 2020 	ldr.w	r2, [r8, #32]
        if (latch[port_idx])
 10203ba:	4313      	orrs	r3, r2
 10203bc:	9205      	str	r2, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
 10203be:	f8c8 2020 	str.w	r2, [r8, #32]
 10203c2:	f47f af76 	bne.w	10202b2 <nrfx_gpiote_irq_handler+0x56>
        mask &= ~NRFX_BIT(ch);
 10203c6:	2401      	movs	r4, #1
    while (mask)
 10203c8:	b916      	cbnz	r6, 10203d0 <nrfx_gpiote_irq_handler+0x174>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
 10203ca:	b007      	add	sp, #28
 10203cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        uint32_t ch = NRF_CTZ(mask);
 10203d0:	fa96 f3a6 	rbit	r3, r6
 10203d4:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
 10203d8:	fa04 f203 	lsl.w	r2, r4, r3
 10203dc:	009b      	lsls	r3, r3, #2
 10203de:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 10203e2:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
 10203e6:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
 10203ea:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
 10203ee:	f3c0 2005 	ubfx	r0, r0, #8, #6
 10203f2:	f3c1 4101 	ubfx	r1, r1, #16, #2
        mask &= ~NRFX_BIT(ch);
 10203f6:	ea26 0602 	bic.w	r6, r6, r2
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
 10203fa:	f7ff fc37 	bl	101fc6c <call_handler>
 10203fe:	e7e3      	b.n	10203c8 <nrfx_gpiote_irq_handler+0x16c>
 1020400:	4100a100 	.word	0x4100a100
 1020404:	4100a000 	.word	0x4100a000
 1020408:	4100a120 	.word	0x4100a120
 102040c:	418c0500 	.word	0x418c0500
 1020410:	418c0800 	.word	0x418c0800
 1020414:	21000a3c 	.word	0x21000a3c

01020418 <nrfx_ipc_init>:
} ipc_control_block_t;

static ipc_control_block_t m_ipc_cb;

nrfx_err_t nrfx_ipc_init(uint8_t irq_priority, nrfx_ipc_handler_t handler, void * p_context)
{
 1020418:	b570      	push	{r4, r5, r6, lr}
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
 102041a:	4c08      	ldr	r4, [pc, #32]	; (102043c <nrfx_ipc_init+0x24>)
{
 102041c:	460e      	mov	r6, r1
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
 102041e:	7923      	ldrb	r3, [r4, #4]
{
 1020420:	4615      	mov	r5, r2
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
 1020422:	b943      	cbnz	r3, 1020436 <nrfx_ipc_init+0x1e>
    {
        return NRFX_ERROR_ALREADY_INITIALIZED;
    }

    NRFX_IRQ_PRIORITY_SET(IPC_IRQn, irq_priority);
    NRFX_IRQ_ENABLE(IPC_IRQn);
 1020424:	2012      	movs	r0, #18
 1020426:	f7e5 fcdf 	bl	1005de8 <arch_irq_enable>

    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
 102042a:	2301      	movs	r3, #1
    m_ipc_cb.handler = handler;
    m_ipc_cb.p_context = p_context;

    return NRFX_SUCCESS;
 102042c:	4804      	ldr	r0, [pc, #16]	; (1020440 <nrfx_ipc_init+0x28>)
    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
 102042e:	7123      	strb	r3, [r4, #4]
    m_ipc_cb.handler = handler;
 1020430:	6026      	str	r6, [r4, #0]
    m_ipc_cb.p_context = p_context;
 1020432:	60a5      	str	r5, [r4, #8]
}
 1020434:	bd70      	pop	{r4, r5, r6, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
 1020436:	4803      	ldr	r0, [pc, #12]	; (1020444 <nrfx_ipc_init+0x2c>)
 1020438:	e7fc      	b.n	1020434 <nrfx_ipc_init+0x1c>
 102043a:	bf00      	nop
 102043c:	21008018 	.word	0x21008018
 1020440:	0bad0000 	.word	0x0bad0000
 1020444:	0bad000c 	.word	0x0bad000c

01020448 <nrfx_ipc_irq_handler>:
    channel_bitmask |= nrf_ipc_send_config_get(NRF_IPC, send_index);
    nrf_ipc_send_config_set(NRF_IPC, send_index, channel_bitmask);
}

void nrfx_ipc_irq_handler(void)
{
 1020448:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint32_t bitmask = events_map;

    while (bitmask)
    {
        uint8_t event_idx = NRF_CTZ(bitmask);
        bitmask &= ~(1UL << event_idx);
 102044a:	2601      	movs	r6, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 102044c:	2700      	movs	r7, #0
    return p_reg->INTPEND;
 102044e:	4b12      	ldr	r3, [pc, #72]	; (1020498 <nrfx_ipc_irq_handler+0x50>)
        nrf_ipc_event_clear(NRF_IPC, nrf_ipc_receive_event_get(event_idx));
#if NRFX_CHECK(NRFX_CONFIG_API_VER_2_10)
        if (m_ipc_cb.handler)
 1020450:	4d12      	ldr	r5, [pc, #72]	; (102049c <nrfx_ipc_irq_handler+0x54>)
 1020452:	f8d3 430c 	ldr.w	r4, [r3, #780]	; 0x30c
    while (bitmask)
 1020456:	b904      	cbnz	r4, 102045a <nrfx_ipc_irq_handler+0x12>
    if (m_ipc_cb.handler)
    {
        m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
#endif
    }
}
 1020458:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        uint8_t event_idx = NRF_CTZ(bitmask);
 102045a:	fa94 f0a4 	rbit	r0, r4
 102045e:	fab0 f080 	clz	r0, r0
        bitmask &= ~(1UL << event_idx);
 1020462:	fa06 f300 	lsl.w	r3, r6, r0
    return (nrf_ipc_task_t)(NRFX_OFFSETOF(NRF_IPC_Type, TASKS_SEND[index]));
}

NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
{
    NRFX_ASSERT(index < IPC_CH_NUM);
 1020466:	280f      	cmp	r0, #15
 1020468:	ea24 0403 	bic.w	r4, r4, r3
 102046c:	dd0b      	ble.n	1020486 <nrfx_ipc_irq_handler+0x3e>
 102046e:	490c      	ldr	r1, [pc, #48]	; (10204a0 <nrfx_ipc_irq_handler+0x58>)
 1020470:	480c      	ldr	r0, [pc, #48]	; (10204a4 <nrfx_ipc_irq_handler+0x5c>)
 1020472:	f240 13e7 	movw	r3, #487	; 0x1e7
 1020476:	4a0c      	ldr	r2, [pc, #48]	; (10204a8 <nrfx_ipc_irq_handler+0x60>)
 1020478:	f004 fbad 	bl	1024bd6 <assert_print>
 102047c:	f240 11e7 	movw	r1, #487	; 0x1e7
 1020480:	4809      	ldr	r0, [pc, #36]	; (10204a8 <nrfx_ipc_irq_handler+0x60>)
 1020482:	f004 fba1 	bl	1024bc8 <assert_post_action>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 1020486:	4b09      	ldr	r3, [pc, #36]	; (10204ac <nrfx_ipc_irq_handler+0x64>)
    return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
 1020488:	0082      	lsls	r2, r0, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 102048a:	509f      	str	r7, [r3, r2]
        if (m_ipc_cb.handler)
 102048c:	682b      	ldr	r3, [r5, #0]
 102048e:	2b00      	cmp	r3, #0
 1020490:	d0e1      	beq.n	1020456 <nrfx_ipc_irq_handler+0xe>
            m_ipc_cb.handler(event_idx, m_ipc_cb.p_context);
 1020492:	68a9      	ldr	r1, [r5, #8]
 1020494:	4798      	blx	r3
 1020496:	e7de      	b.n	1020456 <nrfx_ipc_irq_handler+0xe>
 1020498:	41012000 	.word	0x41012000
 102049c:	21008018 	.word	0x21008018
 10204a0:	0102f4fe 	.word	0x0102f4fe
 10204a4:	0102b695 	.word	0x0102b695
 10204a8:	0102f4cc 	.word	0x0102f4cc
 10204ac:	41012100 	.word	0x41012100

010204b0 <nvmc_word_write>:
 10204b0:	4a04      	ldr	r2, [pc, #16]	; (10204c4 <nvmc_word_write+0x14>)
 10204b2:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
{
#if defined(NRF9160_XXAA)
    while (!nrf_nvmc_write_ready_check(NRF_NVMC))
    {}
#else
    while (!nrf_nvmc_ready_check(NRF_NVMC))
 10204b6:	07db      	lsls	r3, r3, #31
 10204b8:	d5fb      	bpl.n	10204b2 <nvmc_word_write+0x2>
    {}
#endif

    *(volatile uint32_t *)addr = value;
 10204ba:	6001      	str	r1, [r0, #0]
  __ASM volatile ("dmb 0xF":::"memory");
 10204bc:	f3bf 8f5f 	dmb	sy
    __DMB();
}
 10204c0:	4770      	bx	lr
 10204c2:	bf00      	nop
 10204c4:	41080000 	.word	0x41080000

010204c8 <nrfx_nvmc_page_erase>:
        nvmc_word_write(addr + (NVMC_BYTES_IN_WORD * i), ((uint32_t const *)src)[i]);
    }
}

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
 10204c8:	b508      	push	{r3, lr}
    if ((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get())
 10204ca:	f100 437f 	add.w	r3, r0, #4278190080	; 0xff000000
 10204ce:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 10204d2:	d204      	bcs.n	10204de <nrfx_nvmc_page_erase+0x16>
    return !(addr % flash_page_size_get());
 10204d4:	f3c0 030a 	ubfx	r3, r0, #0, #11
    NRFX_ASSERT(is_valid_address(addr, false));

    if (!is_page_aligned_check(addr))
 10204d8:	b16b      	cbz	r3, 10204f6 <nrfx_nvmc_page_erase+0x2e>
    {
        return NRFX_ERROR_INVALID_ADDR;
 10204da:	480f      	ldr	r0, [pc, #60]	; (1020518 <nrfx_nvmc_page_erase+0x50>)
 10204dc:	e01a      	b.n	1020514 <nrfx_nvmc_page_erase+0x4c>
    NRFX_ASSERT(is_valid_address(addr, false));
 10204de:	490f      	ldr	r1, [pc, #60]	; (102051c <nrfx_nvmc_page_erase+0x54>)
 10204e0:	480f      	ldr	r0, [pc, #60]	; (1020520 <nrfx_nvmc_page_erase+0x58>)
 10204e2:	f44f 7383 	mov.w	r3, #262	; 0x106
 10204e6:	4a0f      	ldr	r2, [pc, #60]	; (1020524 <nrfx_nvmc_page_erase+0x5c>)
 10204e8:	f004 fb75 	bl	1024bd6 <assert_print>
 10204ec:	f44f 7183 	mov.w	r1, #262	; 0x106
 10204f0:	480c      	ldr	r0, [pc, #48]	; (1020524 <nrfx_nvmc_page_erase+0x5c>)
 10204f2:	f004 fb69 	bl	1024bc8 <assert_post_action>
    p_reg->CONFIG = (uint32_t)mode;
 10204f6:	2202      	movs	r2, #2
 10204f8:	4b0b      	ldr	r3, [pc, #44]	; (1020528 <nrfx_nvmc_page_erase+0x60>)
 10204fa:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *(volatile uint32_t *)page_addr = 0xFFFFFFFF;
 10204fe:	f04f 32ff 	mov.w	r2, #4294967295
 1020502:	6002      	str	r2, [r0, #0]
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
 1020504:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    }

    nvmc_erase_mode_set();
    nrf_nvmc_page_erase_start(NRF_NVMC, addr);
    while (!nrf_nvmc_ready_check(NRF_NVMC))
 1020508:	07d2      	lsls	r2, r2, #31
 102050a:	d5fb      	bpl.n	1020504 <nrfx_nvmc_page_erase+0x3c>
    p_reg->CONFIG = (uint32_t)mode;
 102050c:	2200      	movs	r2, #0
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
 102050e:	4807      	ldr	r0, [pc, #28]	; (102052c <nrfx_nvmc_page_erase+0x64>)
 1020510:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
 1020514:	bd08      	pop	{r3, pc}
 1020516:	bf00      	nop
 1020518:	0bad000a 	.word	0x0bad000a
 102051c:	0102f565 	.word	0x0102f565
 1020520:	0102b695 	.word	0x0102b695
 1020524:	0102f509 	.word	0x0102f509
 1020528:	41080000 	.word	0x41080000
 102052c:	0bad0000 	.word	0x0bad0000

01020530 <nrfx_nvmc_word_write>:

    nrfx_nvmc_word_write(aligned_addr, partial_word_create(addr, (const uint8_t *)&value, 2));
}

void nrfx_nvmc_word_write(uint32_t addr, uint32_t value)
{
 1020530:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1020532:	460d      	mov	r5, r1
    NRFX_ASSERT(is_valid_address(addr, true));
 1020534:	2101      	movs	r1, #1
{
 1020536:	4604      	mov	r4, r0
    NRFX_ASSERT(is_valid_address(addr, true));
 1020538:	f008 fe05 	bl	1029146 <is_valid_address>
 102053c:	b958      	cbnz	r0, 1020556 <nrfx_nvmc_word_write+0x26>
 102053e:	4911      	ldr	r1, [pc, #68]	; (1020584 <nrfx_nvmc_word_write+0x54>)
 1020540:	f44f 73ca 	mov.w	r3, #404	; 0x194
 1020544:	4a10      	ldr	r2, [pc, #64]	; (1020588 <nrfx_nvmc_word_write+0x58>)
 1020546:	4811      	ldr	r0, [pc, #68]	; (102058c <nrfx_nvmc_word_write+0x5c>)
 1020548:	f004 fb45 	bl	1024bd6 <assert_print>
 102054c:	f44f 71ca 	mov.w	r1, #404	; 0x194
    NRFX_ASSERT(nrfx_is_word_aligned((void const *)addr));
 1020550:	480d      	ldr	r0, [pc, #52]	; (1020588 <nrfx_nvmc_word_write+0x58>)
 1020552:	f004 fb39 	bl	1024bc8 <assert_post_action>
 1020556:	f014 0703 	ands.w	r7, r4, #3
 102055a:	d009      	beq.n	1020570 <nrfx_nvmc_word_write+0x40>
 102055c:	490c      	ldr	r1, [pc, #48]	; (1020590 <nrfx_nvmc_word_write+0x60>)
 102055e:	f240 1395 	movw	r3, #405	; 0x195
 1020562:	4a09      	ldr	r2, [pc, #36]	; (1020588 <nrfx_nvmc_word_write+0x58>)
 1020564:	4809      	ldr	r0, [pc, #36]	; (102058c <nrfx_nvmc_word_write+0x5c>)
 1020566:	f004 fb36 	bl	1024bd6 <assert_print>
 102056a:	f240 1195 	movw	r1, #405	; 0x195
 102056e:	e7ef      	b.n	1020550 <nrfx_nvmc_word_write+0x20>
 1020570:	4e08      	ldr	r6, [pc, #32]	; (1020594 <nrfx_nvmc_word_write+0x64>)

    nvmc_write_mode_set();

    nvmc_word_write(addr, value);
 1020572:	4620      	mov	r0, r4
 1020574:	f8c6 1504 	str.w	r1, [r6, #1284]	; 0x504
 1020578:	4629      	mov	r1, r5
 102057a:	f7ff ff99 	bl	10204b0 <nvmc_word_write>
 102057e:	f8c6 7504 	str.w	r7, [r6, #1284]	; 0x504

    nvmc_readonly_mode_set();
}
 1020582:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1020584:	0102f57f 	.word	0x0102f57f
 1020588:	0102f509 	.word	0x0102f509
 102058c:	0102b695 	.word	0x0102b695
 1020590:	0102f599 	.word	0x0102f599
 1020594:	41080000 	.word	0x41080000

01020598 <_DoInit>:
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 1020598:	2303      	movs	r3, #3
static void _DoInit(void) {
 102059a:	b510      	push	{r4, lr}
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 102059c:	4c10      	ldr	r4, [pc, #64]	; (10205e0 <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
 102059e:	4a11      	ldr	r2, [pc, #68]	; (10205e4 <_DoInit+0x4c>)
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 10205a0:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
 10205a2:	6163      	str	r3, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
 10205a4:	4b10      	ldr	r3, [pc, #64]	; (10205e8 <_DoInit+0x50>)
  p->aUp[0].sName         = "Terminal";
 10205a6:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
 10205a8:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
 10205aa:	f44f 6380 	mov.w	r3, #1024	; 0x400
 10205ae:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
 10205b0:	2300      	movs	r3, #0
 10205b2:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
 10205b4:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 10205b6:	62e3      	str	r3, [r4, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
 10205b8:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
 10205ba:	4a0c      	ldr	r2, [pc, #48]	; (10205ec <_DoInit+0x54>)
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
 10205bc:	490c      	ldr	r1, [pc, #48]	; (10205f0 <_DoInit+0x58>)
  p->aDown[0].pBuffer       = _acDownBuffer;
 10205be:	6662      	str	r2, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
 10205c0:	2210      	movs	r2, #16
  STRCPY((char*)&p->acID[7], "RTT");
 10205c2:	1de0      	adds	r0, r4, #7
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
 10205c4:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
 10205c6:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
 10205c8:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 10205ca:	6763      	str	r3, [r4, #116]	; 0x74
  STRCPY((char*)&p->acID[7], "RTT");
 10205cc:	f006 f989 	bl	10268e2 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
 10205d0:	4620      	mov	r0, r4
 10205d2:	4908      	ldr	r1, [pc, #32]	; (10205f4 <_DoInit+0x5c>)
 10205d4:	f006 f985 	bl	10268e2 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
 10205d8:	2320      	movs	r3, #32
 10205da:	71a3      	strb	r3, [r4, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
 10205dc:	bd10      	pop	{r4, pc}
 10205de:	bf00      	nop
 10205e0:	21008024 	.word	0x21008024
 10205e4:	0102f5c2 	.word	0x0102f5c2
 10205e8:	21008368 	.word	0x21008368
 10205ec:	21008358 	.word	0x21008358
 10205f0:	0102f5cb 	.word	0x0102f5cb
 10205f4:	0102f5cf 	.word	0x0102f5cf

010205f8 <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 10205f8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  RdOff = pRing->RdOff;
 10205fc:	f04f 0b18 	mov.w	fp, #24
 1020600:	4f20      	ldr	r7, [pc, #128]	; (1020684 <SEGGER_RTT_WriteSkipNoLock+0x8c>)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 1020602:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
 1020604:	fb0b 7200 	mla	r2, fp, r0, r7
 1020608:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
 102060a:	6a55      	ldr	r5, [r2, #36]	; 0x24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 102060c:	4606      	mov	r6, r0
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
 102060e:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 1020610:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
 1020612:	d831      	bhi.n	1020678 <SEGGER_RTT_WriteSkipNoLock+0x80>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
 1020614:	f8d2 a020 	ldr.w	sl, [r2, #32]
 1020618:	ebaa 0905 	sub.w	r9, sl, r5
 102061c:	f109 32ff 	add.w	r2, r9, #4294967295
    if (Avail >= NumBytes) {                            // Case 1)?
 1020620:	4294      	cmp	r4, r2
 1020622:	d811      	bhi.n	1020648 <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 1020624:	2318      	movs	r3, #24
 1020626:	fb06 3303 	mla	r3, r6, r3, r3
 102062a:	443b      	add	r3, r7
 102062c:	6858      	ldr	r0, [r3, #4]
      memcpy((void*)pDst, pData, NumBytes);
 102062e:	4622      	mov	r2, r4
 1020630:	4641      	mov	r1, r8
 1020632:	4428      	add	r0, r5
 1020634:	f006 f99e 	bl	1026974 <memcpy>
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = WrOff + NumBytes;
 1020638:	442c      	add	r4, r5
      if (NumBytes) {
        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
        memcpy((void*)pDst, pData + Rem, NumBytes);
      }
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = NumBytes;
 102063a:	2318      	movs	r3, #24
      return 1;
 102063c:	2001      	movs	r0, #1
      pRing->WrOff = NumBytes;
 102063e:	fb03 7306 	mla	r3, r3, r6, r7
 1020642:	625c      	str	r4, [r3, #36]	; 0x24
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
 1020644:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
 1020648:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
 102064a:	429c      	cmp	r4, r3
 102064c:	d818      	bhi.n	1020680 <SEGGER_RTT_WriteSkipNoLock+0x88>
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 102064e:	fb00 bb0b 	mla	fp, r0, fp, fp
 1020652:	44bb      	add	fp, r7
 1020654:	f8db 0004 	ldr.w	r0, [fp, #4]
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
 1020658:	464a      	mov	r2, r9
 102065a:	4428      	add	r0, r5
 102065c:	442c      	add	r4, r5
 102065e:	f006 f989 	bl	1026974 <memcpy>
      if (NumBytes) {
 1020662:	ebb4 040a 	subs.w	r4, r4, sl
 1020666:	d0e8      	beq.n	102063a <SEGGER_RTT_WriteSkipNoLock+0x42>
        memcpy((void*)pDst, pData + Rem, NumBytes);
 1020668:	4622      	mov	r2, r4
 102066a:	f8db 0004 	ldr.w	r0, [fp, #4]
 102066e:	eb08 0109 	add.w	r1, r8, r9
 1020672:	f006 f97f 	bl	1026974 <memcpy>
      return 1;
 1020676:	e7e0      	b.n	102063a <SEGGER_RTT_WriteSkipNoLock+0x42>
    Avail = RdOff - WrOff - 1u;
 1020678:	3b01      	subs	r3, #1
 102067a:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
 102067c:	42a3      	cmp	r3, r4
 102067e:	d2d1      	bcs.n	1020624 <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
 1020680:	2000      	movs	r0, #0
 1020682:	e7df      	b.n	1020644 <SEGGER_RTT_WriteSkipNoLock+0x4c>
 1020684:	21008024 	.word	0x21008024

01020688 <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 1020688:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
 102068a:	2718      	movs	r7, #24
 102068c:	fb00 7507 	mla	r5, r0, r7, r7
 1020690:	4b12      	ldr	r3, [pc, #72]	; (10206dc <SEGGER_RTT_WriteNoLock+0x54>)
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 1020692:	460e      	mov	r6, r1
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
 1020694:	441d      	add	r5, r3
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
 1020696:	fb07 3300 	mla	r3, r7, r0, r3
 102069a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 102069c:	4614      	mov	r4, r2
  switch (pRing->Flags) {
 102069e:	2b01      	cmp	r3, #1
 10206a0:	d00a      	beq.n	10206b8 <SEGGER_RTT_WriteNoLock+0x30>
 10206a2:	2b02      	cmp	r3, #2
 10206a4:	d014      	beq.n	10206d0 <SEGGER_RTT_WriteNoLock+0x48>
 10206a6:	b923      	cbnz	r3, 10206b2 <SEGGER_RTT_WriteNoLock+0x2a>
  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    //
    // If we are in skip mode and there is no space for the whole
    // of this output, don't bother.
    //
    Avail = _GetAvailWriteSpace(pRing);
 10206a8:	4628      	mov	r0, r5
 10206aa:	f008 fd68 	bl	102917e <_GetAvailWriteSpace>
    if (Avail < NumBytes) {
 10206ae:	4284      	cmp	r4, r0
 10206b0:	d908      	bls.n	10206c4 <SEGGER_RTT_WriteNoLock+0x3c>
    // If we are in blocking mode, output everything.
    //
    Status = _WriteBlocking(pRing, pData, NumBytes);
    break;
  default:
    Status = 0u;
 10206b2:	2400      	movs	r4, #0
  }
  //
  // Finish up.
  //
  return Status;
}
 10206b4:	4620      	mov	r0, r4
 10206b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    Avail = _GetAvailWriteSpace(pRing);
 10206b8:	4628      	mov	r0, r5
 10206ba:	f008 fd60 	bl	102917e <_GetAvailWriteSpace>
    Status = Avail < NumBytes ? Avail : NumBytes;
 10206be:	4284      	cmp	r4, r0
 10206c0:	bf28      	it	cs
 10206c2:	4604      	movcs	r4, r0
    _WriteNoCheck(pRing, pData, Status);
 10206c4:	4622      	mov	r2, r4
 10206c6:	4631      	mov	r1, r6
 10206c8:	4628      	mov	r0, r5
 10206ca:	f008 fd61 	bl	1029190 <_WriteNoCheck>
    break;
 10206ce:	e7f1      	b.n	10206b4 <SEGGER_RTT_WriteNoLock+0x2c>
    Status = _WriteBlocking(pRing, pData, NumBytes);
 10206d0:	4628      	mov	r0, r5
}
 10206d2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    Status = _WriteBlocking(pRing, pData, NumBytes);
 10206d6:	f008 bd76 	b.w	10291c6 <_WriteBlocking>
 10206da:	bf00      	nop
 10206dc:	21008024 	.word	0x21008024

010206e0 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  v = pRing->RdOff;
 10206e0:	2218      	movs	r2, #24
 10206e2:	4b03      	ldr	r3, [pc, #12]	; (10206f0 <SEGGER_RTT_HasDataUp+0x10>)
 10206e4:	fb02 3300 	mla	r3, r2, r0, r3
 10206e8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
 10206ea:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 10206ec:	1a80      	subs	r0, r0, r2
 10206ee:	4770      	bx	lr
 10206f0:	21008024 	.word	0x21008024

010206f4 <zephyr_rtt_mutex_lock>:
	return z_impl_k_mutex_lock(mutex, timeout);
 10206f4:	f04f 32ff 	mov.w	r2, #4294967295
 10206f8:	f04f 33ff 	mov.w	r3, #4294967295
 10206fc:	4801      	ldr	r0, [pc, #4]	; (1020704 <zephyr_rtt_mutex_lock+0x10>)
 10206fe:	f000 bd2f 	b.w	1021160 <z_impl_k_mutex_lock>
 1020702:	bf00      	nop
 1020704:	21000c70 	.word	0x21000c70

01020708 <zephyr_rtt_mutex_unlock>:
	return z_impl_k_mutex_unlock(mutex);
 1020708:	4801      	ldr	r0, [pc, #4]	; (1020710 <zephyr_rtt_mutex_unlock+0x8>)
 102070a:	f000 bdf9 	b.w	1021300 <z_impl_k_mutex_unlock>
 102070e:	bf00      	nop
 1020710:	21000c70 	.word	0x21000c70

01020714 <z_impl_device_get_binding>:
		++dev;
	}
}

const struct device *z_impl_device_get_binding(const char *name)
{
 1020714:	b570      	push	{r4, r5, r6, lr}
	const struct device *dev;

	/* A null string identifies no device.  So does an empty
	 * string.
	 */
	if ((name == NULL) || (name[0] == '\0')) {
 1020716:	4605      	mov	r5, r0
 1020718:	b910      	cbnz	r0, 1020720 <z_impl_device_get_binding+0xc>
		return NULL;
 102071a:	2400      	movs	r4, #0
			return dev;
		}
	}

	return NULL;
}
 102071c:	4620      	mov	r0, r4
 102071e:	bd70      	pop	{r4, r5, r6, pc}
	if ((name == NULL) || (name[0] == '\0')) {
 1020720:	7803      	ldrb	r3, [r0, #0]
 1020722:	2b00      	cmp	r3, #0
 1020724:	d0f9      	beq.n	102071a <z_impl_device_get_binding+0x6>
	for (dev = __device_start; dev != __device_end; dev++) {
 1020726:	4c0e      	ldr	r4, [pc, #56]	; (1020760 <z_impl_device_get_binding+0x4c>)
 1020728:	4e0e      	ldr	r6, [pc, #56]	; (1020764 <z_impl_device_get_binding+0x50>)
 102072a:	42b4      	cmp	r4, r6
 102072c:	d108      	bne.n	1020740 <z_impl_device_get_binding+0x2c>
	for (dev = __device_start; dev != __device_end; dev++) {
 102072e:	4c0c      	ldr	r4, [pc, #48]	; (1020760 <z_impl_device_get_binding+0x4c>)
 1020730:	42b4      	cmp	r4, r6
 1020732:	d0f2      	beq.n	102071a <z_impl_device_get_binding+0x6>
		if (z_device_is_ready(dev) && (strcmp(name, dev->name) == 0)) {
 1020734:	4620      	mov	r0, r4
 1020736:	f008 fd77 	bl	1029228 <z_device_is_ready>
 102073a:	b950      	cbnz	r0, 1020752 <z_impl_device_get_binding+0x3e>
	for (dev = __device_start; dev != __device_end; dev++) {
 102073c:	3418      	adds	r4, #24
 102073e:	e7f7      	b.n	1020730 <z_impl_device_get_binding+0x1c>
		if (z_device_is_ready(dev) && (dev->name == name)) {
 1020740:	4620      	mov	r0, r4
 1020742:	f008 fd71 	bl	1029228 <z_device_is_ready>
 1020746:	b110      	cbz	r0, 102074e <z_impl_device_get_binding+0x3a>
 1020748:	6823      	ldr	r3, [r4, #0]
 102074a:	42ab      	cmp	r3, r5
 102074c:	d0e6      	beq.n	102071c <z_impl_device_get_binding+0x8>
	for (dev = __device_start; dev != __device_end; dev++) {
 102074e:	3418      	adds	r4, #24
 1020750:	e7eb      	b.n	102072a <z_impl_device_get_binding+0x16>
		if (z_device_is_ready(dev) && (strcmp(name, dev->name) == 0)) {
 1020752:	4628      	mov	r0, r5
 1020754:	6821      	ldr	r1, [r4, #0]
 1020756:	f006 f8de 	bl	1026916 <strcmp>
 102075a:	2800      	cmp	r0, #0
 102075c:	d1ee      	bne.n	102073c <z_impl_device_get_binding+0x28>
 102075e:	e7dd      	b.n	102071c <z_impl_device_get_binding+0x8>
 1020760:	010296e8 	.word	0x010296e8
 1020764:	01029778 	.word	0x01029778

01020768 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
 1020768:	4b01      	ldr	r3, [pc, #4]	; (1020770 <z_impl_z_errno+0x8>)
 102076a:	6898      	ldr	r0, [r3, #8]
}
 102076c:	3064      	adds	r0, #100	; 0x64
 102076e:	4770      	bx	lr
 1020770:	210080cc 	.word	0x210080cc

01020774 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
 1020774:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1020778:	b086      	sub	sp, #24
 102077a:	4604      	mov	r4, r0
 102077c:	460e      	mov	r6, r1
 102077e:	af00      	add	r7, sp, #0
	__asm__ volatile(
 1020780:	f04f 0320 	mov.w	r3, #32
 1020784:	f3ef 8811 	mrs	r8, BASEPRI
 1020788:	f383 8812 	msr	BASEPRI_MAX, r3
 102078c:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
 1020790:	f002 fe60 	bl	1023454 <z_impl_z_current_get>
 1020794:	2c04      	cmp	r4, #4
 1020796:	bf98      	it	ls
 1020798:	4b34      	ldrls	r3, [pc, #208]	; (102086c <z_fatal_error+0xf8>)
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
 102079a:	46e9      	mov	r9, sp
 102079c:	b08a      	sub	sp, #40	; 0x28
 102079e:	4605      	mov	r5, r0
 10207a0:	466a      	mov	r2, sp
 10207a2:	bf94      	ite	ls
 10207a4:	f853 3024 	ldrls.w	r3, [r3, r4, lsl #2]
 10207a8:	4b31      	ldrhi	r3, [pc, #196]	; (1020870 <z_fatal_error+0xfc>)
 10207aa:	61d3      	str	r3, [r2, #28]
 10207ac:	f240 3301 	movw	r3, #769	; 0x301
 10207b0:	f04f 0a00 	mov.w	sl, #0
 10207b4:	8493      	strh	r3, [r2, #36]	; 0x24
 10207b6:	492f      	ldr	r1, [pc, #188]	; (1020874 <z_fatal_error+0x100>)
 10207b8:	4b2f      	ldr	r3, [pc, #188]	; (1020878 <z_fatal_error+0x104>)
 10207ba:	e9c2 1405 	strd	r1, r4, [r2, #20]
 10207be:	f8c2 a020 	str.w	sl, [r2, #32]
 10207c2:	f842 3f10 	str.w	r3, [r2, #16]!
 10207c6:	f44f 5131 	mov.w	r1, #11328	; 0x2c40
 10207ca:	4653      	mov	r3, sl
 10207cc:	482b      	ldr	r0, [pc, #172]	; (102087c <z_fatal_error+0x108>)
 10207ce:	f7e3 ff9b 	bl	1004708 <z_impl_z_log_msg_static_create>
 10207d2:	46cd      	mov	sp, r9
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 10207d4:	b17e      	cbz	r6, 10207f6 <z_fatal_error+0x82>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 10207d6:	69f3      	ldr	r3, [r6, #28]
 10207d8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 10207dc:	b15b      	cbz	r3, 10207f6 <z_fatal_error+0x82>
		LOG_ERR("Fault during interrupt handling\n");
 10207de:	4b28      	ldr	r3, [pc, #160]	; (1020880 <z_fatal_error+0x10c>)
 10207e0:	617b      	str	r3, [r7, #20]
 10207e2:	2302      	movs	r3, #2
 10207e4:	613b      	str	r3, [r7, #16]
 10207e6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
 10207ea:	4653      	mov	r3, sl
 10207ec:	4823      	ldr	r0, [pc, #140]	; (102087c <z_fatal_error+0x108>)
 10207ee:	f107 0210 	add.w	r2, r7, #16
 10207f2:	f7e3 ff89 	bl	1004708 <z_impl_z_log_msg_static_create>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
 10207f6:	b12d      	cbz	r5, 1020804 <z_fatal_error+0x90>
 10207f8:	4628      	mov	r0, r5
 10207fa:	f008 fd4b 	bl	1029294 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
 10207fe:	b108      	cbz	r0, 1020804 <z_fatal_error+0x90>
 1020800:	7803      	ldrb	r3, [r0, #0]
 1020802:	b903      	cbnz	r3, 1020806 <z_fatal_error+0x92>
		thread_name = "unknown";
 1020804:	481f      	ldr	r0, [pc, #124]	; (1020884 <z_fatal_error+0x110>)
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
 1020806:	46e9      	mov	r9, sp
 1020808:	b08a      	sub	sp, #40	; 0x28
 102080a:	466a      	mov	r2, sp
 102080c:	4b1e      	ldr	r3, [pc, #120]	; (1020888 <z_fatal_error+0x114>)
 102080e:	61d0      	str	r0, [r2, #28]
 1020810:	e9c2 3505 	strd	r3, r5, [r2, #20]
 1020814:	f240 3301 	movw	r3, #769	; 0x301
 1020818:	8413      	strh	r3, [r2, #32]
 102081a:	4b1c      	ldr	r3, [pc, #112]	; (102088c <z_fatal_error+0x118>)
 102081c:	f842 3f10 	str.w	r3, [r2, #16]!
 1020820:	2300      	movs	r3, #0
 1020822:	f44f 5111 	mov.w	r1, #9280	; 0x2440
 1020826:	4815      	ldr	r0, [pc, #84]	; (102087c <z_fatal_error+0x108>)
 1020828:	f7e3 ff6e 	bl	1004708 <z_impl_z_log_msg_static_create>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
 102082c:	4631      	mov	r1, r6
 102082e:	46cd      	mov	sp, r9
 1020830:	4620      	mov	r0, r4
 1020832:	f7fe fff1 	bl	101f818 <k_sys_fatal_error_handler>
	 *
	 * Note that k_thread_abort() returns on some architectures but
	 * not others; e.g. on ARC, x86_64, Xtensa with ASM2, ARM
	 */
	if (!IS_ENABLED(CONFIG_TEST)) {
		__ASSERT(reason != K_ERR_KERNEL_PANIC,
 1020836:	2c04      	cmp	r4, #4
 1020838:	d10c      	bne.n	1020854 <z_fatal_error+0xe0>
 102083a:	4915      	ldr	r1, [pc, #84]	; (1020890 <z_fatal_error+0x11c>)
 102083c:	2393      	movs	r3, #147	; 0x93
 102083e:	4a15      	ldr	r2, [pc, #84]	; (1020894 <z_fatal_error+0x120>)
 1020840:	4815      	ldr	r0, [pc, #84]	; (1020898 <z_fatal_error+0x124>)
 1020842:	f004 f9c8 	bl	1024bd6 <assert_print>
 1020846:	4815      	ldr	r0, [pc, #84]	; (102089c <z_fatal_error+0x128>)
 1020848:	f004 f9c5 	bl	1024bd6 <assert_print>
 102084c:	2193      	movs	r1, #147	; 0x93
 102084e:	4811      	ldr	r0, [pc, #68]	; (1020894 <z_fatal_error+0x120>)
 1020850:	f004 f9ba 	bl	1024bc8 <assert_post_action>
	__asm__ volatile(
 1020854:	f388 8811 	msr	BASEPRI, r8
 1020858:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
 102085c:	4628      	mov	r0, r5
 102085e:	f7e5 ff7f 	bl	1006760 <z_impl_k_thread_abort>
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
 1020862:	3718      	adds	r7, #24
 1020864:	46bd      	mov	sp, r7
 1020866:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 102086a:	bf00      	nop
 102086c:	0102b3d8 	.word	0x0102b3d8
 1020870:	0102f5d6 	.word	0x0102f5d6
 1020874:	0102f5ec 	.word	0x0102f5ec
 1020878:	01000005 	.word	0x01000005
 102087c:	01029a54 	.word	0x01029a54
 1020880:	0102f614 	.word	0x0102f614
 1020884:	0102f5e4 	.word	0x0102f5e4
 1020888:	0102f635 	.word	0x0102f635
 102088c:	01000004 	.word	0x01000004
 1020890:	0102f66f 	.word	0x0102f66f
 1020894:	0102f64d 	.word	0x0102f64d
 1020898:	0102b695 	.word	0x0102b695
 102089c:	0102f68c 	.word	0x0102f68c

010208a0 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 10208a0:	4b0f      	ldr	r3, [pc, #60]	; (10208e0 <z_sys_init_run_level+0x40>)
{
 10208a2:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 10208a4:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
 10208a8:	3001      	adds	r0, #1
 10208aa:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
 10208ae:	42a6      	cmp	r6, r4
 10208b0:	d800      	bhi.n	10208b4 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
 10208b2:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
 10208b4:	e9d4 3500 	ldrd	r3, r5, [r4]
 10208b8:	4628      	mov	r0, r5
 10208ba:	4798      	blx	r3
		if (dev != NULL) {
 10208bc:	b16d      	cbz	r5, 10208da <z_sys_init_run_level+0x3a>
			if (rc != 0) {
 10208be:	b138      	cbz	r0, 10208d0 <z_sys_init_run_level+0x30>
				if (rc < 0) {
 10208c0:	2800      	cmp	r0, #0
 10208c2:	bfb8      	it	lt
 10208c4:	4240      	neglt	r0, r0
				if (rc > UINT8_MAX) {
 10208c6:	28ff      	cmp	r0, #255	; 0xff
 10208c8:	bfa8      	it	ge
 10208ca:	20ff      	movge	r0, #255	; 0xff
				dev->state->init_res = rc;
 10208cc:	68eb      	ldr	r3, [r5, #12]
 10208ce:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
 10208d0:	68ea      	ldr	r2, [r5, #12]
 10208d2:	7853      	ldrb	r3, [r2, #1]
 10208d4:	f043 0301 	orr.w	r3, r3, #1
 10208d8:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 10208da:	3408      	adds	r4, #8
 10208dc:	e7e7      	b.n	10208ae <z_sys_init_run_level+0xe>
 10208de:	bf00      	nop
 10208e0:	0102b3ec 	.word	0x0102b3ec

010208e4 <bg_thread_main>:
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
 10208e4:	2201      	movs	r2, #1
{
 10208e6:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
 10208e8:	4b09      	ldr	r3, [pc, #36]	; (1020910 <bg_thread_main+0x2c>)

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 10208ea:	2003      	movs	r0, #3
	z_sys_post_kernel = true;
 10208ec:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 10208ee:	f7ff ffd7 	bl	10208a0 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
 10208f2:	f003 fe23 	bl	102453c <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
 10208f6:	2004      	movs	r0, #4
 10208f8:	f7ff ffd2 	bl	10208a0 <z_sys_init_run_level>

	z_init_static_threads();
 10208fc:	f000 fb64 	bl	1020fc8 <z_init_static_threads>
	extern int main(void);
#else
	extern void main(void);
#endif

	(void)main();
 1020900:	f7e1 f990 	bl	1001c24 <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
 1020904:	4a03      	ldr	r2, [pc, #12]	; (1020914 <bg_thread_main+0x30>)
 1020906:	7b13      	ldrb	r3, [r2, #12]
 1020908:	f023 0301 	bic.w	r3, r3, #1
 102090c:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 102090e:	bd08      	pop	{r3, pc}
 1020910:	21008768 	.word	0x21008768
 1020914:	21004490 	.word	0x21004490

01020918 <z_bss_zero>:
{
 1020918:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
 102091a:	4803      	ldr	r0, [pc, #12]	; (1020928 <z_bss_zero+0x10>)
 102091c:	4a03      	ldr	r2, [pc, #12]	; (102092c <z_bss_zero+0x14>)
 102091e:	2100      	movs	r1, #0
 1020920:	1a12      	subs	r2, r2, r0
 1020922:	f008 fc8c 	bl	102923e <z_early_memset>
}
 1020926:	bd08      	pop	{r3, pc}
 1020928:	21000ee8 	.word	0x21000ee8
 102092c:	2100876c 	.word	0x2100876c

01020930 <z_init_cpu>:

#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
 1020930:	2300      	movs	r3, #0
 1020932:	2201      	movs	r2, #1
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
 1020934:	b570      	push	{r4, r5, r6, lr}
 1020936:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
 1020938:	e9cd 2304 	strd	r2, r3, [sp, #16]
 102093c:	220f      	movs	r2, #15
 102093e:	9301      	str	r3, [sp, #4]
 1020940:	e9cd 3202 	strd	r3, r2, [sp, #8]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 1020944:	2318      	movs	r3, #24
 1020946:	4d0f      	ldr	r5, [pc, #60]	; (1020984 <z_init_cpu+0x54>)
	struct k_thread *thread = &z_idle_threads[i];
 1020948:	4e0f      	ldr	r6, [pc, #60]	; (1020988 <z_init_cpu+0x58>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 102094a:	fb03 5500 	mla	r5, r3, r0, r5
	z_setup_new_thread(thread, stack,
 102094e:	490f      	ldr	r1, [pc, #60]	; (102098c <z_init_cpu+0x5c>)
	struct k_thread *thread = &z_idle_threads[i];
 1020950:	eb06 16c0 	add.w	r6, r6, r0, lsl #7
{
 1020954:	4604      	mov	r4, r0
	z_setup_new_thread(thread, stack,
 1020956:	eb01 2100 	add.w	r1, r1, r0, lsl #8
 102095a:	f44f 7280 	mov.w	r2, #256	; 0x100
 102095e:	4630      	mov	r0, r6
 1020960:	4b0b      	ldr	r3, [pc, #44]	; (1020990 <z_init_cpu+0x60>)
 1020962:	9500      	str	r5, [sp, #0]
 1020964:	f000 fa96 	bl	1020e94 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
 1020968:	7b73      	ldrb	r3, [r6, #13]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
 102096a:	752c      	strb	r4, [r5, #20]
 102096c:	f023 0304 	bic.w	r3, r3, #4
 1020970:	7373      	strb	r3, [r6, #13]
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 1020972:	4b08      	ldr	r3, [pc, #32]	; (1020994 <z_init_cpu+0x64>)
 1020974:	3401      	adds	r4, #1
 1020976:	eb03 23c4 	add.w	r3, r3, r4, lsl #11
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 102097a:	60ee      	str	r6, [r5, #12]
	_kernel.cpus[id].irq_stack =
 102097c:	606b      	str	r3, [r5, #4]
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
 102097e:	b006      	add	sp, #24
 1020980:	bd70      	pop	{r4, r5, r6, pc}
 1020982:	bf00      	nop
 1020984:	210080cc 	.word	0x210080cc
 1020988:	21004410 	.word	0x21004410
 102098c:	2100c448 	.word	0x2100c448
 1020990:	01021119 	.word	0x01021119
 1020994:	2100bc48 	.word	0x2100bc48

01020998 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
 1020998:	b580      	push	{r7, lr}
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
 102099a:	2000      	movs	r0, #0
{
 102099c:	b0a6      	sub	sp, #152	; 0x98
	z_sys_init_run_level(INIT_LEVEL_EARLY);
 102099e:	f7ff ff7f 	bl	10208a0 <z_sys_init_run_level>
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
 10209a2:	4b2e      	ldr	r3, [pc, #184]	; (1020a5c <z_cstart+0xc4>)
	uint32_t msp =
 10209a4:	f503 6200 	add.w	r2, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 10209a8:	f382 8808 	msr	MSP, r2
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 10209ac:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 10209b0:	2400      	movs	r4, #0
 10209b2:	23e0      	movs	r3, #224	; 0xe0
 10209b4:	4d2a      	ldr	r5, [pc, #168]	; (1020a60 <z_cstart+0xc8>)

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
 10209b6:	4e2b      	ldr	r6, [pc, #172]	; (1020a64 <z_cstart+0xcc>)
 10209b8:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
 10209bc:	77ec      	strb	r4, [r5, #31]
 10209be:	762c      	strb	r4, [r5, #24]
 10209c0:	766c      	strb	r4, [r5, #25]
 10209c2:	76ac      	strb	r4, [r5, #26]
 10209c4:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
 10209c8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 10209ca:	4f27      	ldr	r7, [pc, #156]	; (1020a68 <z_cstart+0xd0>)
 10209cc:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
 10209d0:	626b      	str	r3, [r5, #36]	; 0x24
 10209d2:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
 10209d6:	f7e5 fe27 	bl	1006628 <z_arm_fault_init>
	z_arm_cpu_idle_init();
 10209da:	f7e5 f981 	bl	1005ce0 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
 10209de:	f04f 33ff 	mov.w	r3, #4294967295
 10209e2:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
 10209e4:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
 10209e6:	f7e6 f89b 	bl	1006b20 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
 10209ea:	f7e5 fecf 	bl	100678c <z_arm_configure_static_mpu_regions>

	/* perform any architecture-specific initialization */
	arch_kernel_init();

	LOG_CORE_INIT();
 10209ee:	f7e3 fc81 	bl	10042f4 <log_core_init>
	dummy_thread->base.user_options = K_ESSENTIAL;
 10209f2:	f240 1301 	movw	r3, #257	; 0x101
 10209f6:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
 10209fa:	ab06      	add	r3, sp, #24
 10209fc:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
 10209fe:	e9cd 4420 	strd	r4, r4, [sp, #128]	; 0x80
	dummy_thread->resource_pool = NULL;
 1020a02:	9423      	str	r4, [sp, #140]	; 0x8c
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
 1020a04:	f008 fc0f 	bl	1029226 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
 1020a08:	2001      	movs	r0, #1
 1020a0a:	f7ff ff49 	bl	10208a0 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
 1020a0e:	2002      	movs	r0, #2
	_kernel.ready_q.cache = &z_main_thread;
 1020a10:	4d16      	ldr	r5, [pc, #88]	; (1020a6c <z_cstart+0xd4>)
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
 1020a12:	f7ff ff45 	bl	10208a0 <z_sys_init_run_level>
	z_sched_init();
 1020a16:	f002 fba3 	bl	1023160 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 1020a1a:	4b15      	ldr	r3, [pc, #84]	; (1020a70 <z_cstart+0xd8>)
	_kernel.ready_q.cache = &z_main_thread;
 1020a1c:	61b5      	str	r5, [r6, #24]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 1020a1e:	9305      	str	r3, [sp, #20]
 1020a20:	2301      	movs	r3, #1
 1020a22:	4914      	ldr	r1, [pc, #80]	; (1020a74 <z_cstart+0xdc>)
 1020a24:	f44f 6280 	mov.w	r2, #1024	; 0x400
 1020a28:	e9cd 4303 	strd	r4, r3, [sp, #12]
 1020a2c:	4628      	mov	r0, r5
 1020a2e:	463b      	mov	r3, r7
 1020a30:	e9cd 4401 	strd	r4, r4, [sp, #4]
 1020a34:	9400      	str	r4, [sp, #0]
 1020a36:	f000 fa2d 	bl	1020e94 <z_setup_new_thread>
 1020a3a:	4606      	mov	r6, r0
 1020a3c:	7b6a      	ldrb	r2, [r5, #13]
	z_ready_thread(&z_main_thread);
 1020a3e:	4628      	mov	r0, r5
 1020a40:	f022 0204 	bic.w	r2, r2, #4
 1020a44:	736a      	strb	r2, [r5, #13]
 1020a46:	f001 fd63 	bl	1022510 <z_ready_thread>
	z_init_cpu(0);
 1020a4a:	4620      	mov	r0, r4
 1020a4c:	f7ff ff70 	bl	1020930 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 1020a50:	463a      	mov	r2, r7
 1020a52:	4631      	mov	r1, r6
 1020a54:	4628      	mov	r0, r5
 1020a56:	f7e5 fab5 	bl	1005fc4 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 1020a5a:	bf00      	nop
 1020a5c:	2100bc48 	.word	0x2100bc48
 1020a60:	e000ed00 	.word	0xe000ed00
 1020a64:	210080cc 	.word	0x210080cc
 1020a68:	010208e5 	.word	0x010208e5
 1020a6c:	21004490 	.word	0x21004490
 1020a70:	0102b857 	.word	0x0102b857
 1020a74:	2100c548 	.word	0x2100c548

01020a78 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
 1020a78:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
 1020a7a:	4c0d      	ldr	r4, [pc, #52]	; (1020ab0 <statics_init+0x38>)
 1020a7c:	4d0d      	ldr	r5, [pc, #52]	; (1020ab4 <statics_init+0x3c>)
 1020a7e:	42ac      	cmp	r4, r5
 1020a80:	d913      	bls.n	1020aaa <statics_init+0x32>
 1020a82:	490d      	ldr	r1, [pc, #52]	; (1020ab8 <statics_init+0x40>)
 1020a84:	2318      	movs	r3, #24
 1020a86:	4a0d      	ldr	r2, [pc, #52]	; (1020abc <statics_init+0x44>)
 1020a88:	480d      	ldr	r0, [pc, #52]	; (1020ac0 <statics_init+0x48>)
 1020a8a:	f004 f8a4 	bl	1024bd6 <assert_print>
 1020a8e:	480d      	ldr	r0, [pc, #52]	; (1020ac4 <statics_init+0x4c>)
 1020a90:	f004 f8a1 	bl	1024bd6 <assert_print>
 1020a94:	2118      	movs	r1, #24
 1020a96:	4809      	ldr	r0, [pc, #36]	; (1020abc <statics_init+0x44>)
 1020a98:	f004 f896 	bl	1024bc8 <assert_post_action>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
 1020a9c:	4620      	mov	r0, r4
 1020a9e:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
 1020aa2:	f008 fbd0 	bl	1029246 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
 1020aa6:	3418      	adds	r4, #24
 1020aa8:	e7e9      	b.n	1020a7e <statics_init+0x6>
 1020aaa:	d3f7      	bcc.n	1020a9c <statics_init+0x24>
		}
	}
	return 0;
}
 1020aac:	2000      	movs	r0, #0
 1020aae:	bd38      	pop	{r3, r4, r5, pc}
 1020ab0:	21000c70 	.word	0x21000c70
 1020ab4:	21000c70 	.word	0x21000c70
 1020ab8:	0102f730 	.word	0x0102f730
 1020abc:	0102f70e 	.word	0x0102f70e
 1020ac0:	0102b695 	.word	0x0102b695
 1020ac4:	0102bf04 	.word	0x0102bf04

01020ac8 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
 1020ac8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1020acc:	b085      	sub	sp, #20
 1020ace:	e9dd 9b0e 	ldrd	r9, fp, [sp, #56]	; 0x38
 1020ad2:	4680      	mov	r8, r0
 1020ad4:	9103      	str	r1, [sp, #12]
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
 1020ad6:	4648      	mov	r0, r9
 1020ad8:	4659      	mov	r1, fp
{
 1020ada:	4692      	mov	sl, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
 1020adc:	f008 fcca 	bl	1029474 <sys_clock_timeout_end_calc>
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
 1020ae0:	f1bb 3fff 	cmp.w	fp, #4294967295
 1020ae4:	bf08      	it	eq
 1020ae6:	f1b9 3fff 	cmpeq.w	r9, #4294967295
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
 1020aea:	4606      	mov	r6, r0
 1020aec:	460f      	mov	r7, r1
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
 1020aee:	bf04      	itt	eq
 1020af0:	f04f 36ff 	moveq.w	r6, #4294967295
 1020af4:	f06f 4700 	mvneq.w	r7, #2147483648	; 0x80000000

	k_spinlock_key_t key = k_spin_lock(&h->lock);
 1020af8:	f108 0414 	add.w	r4, r8, #20
	__asm__ volatile(
 1020afc:	f04f 0320 	mov.w	r3, #32
 1020b00:	f3ef 8511 	mrs	r5, BASEPRI
 1020b04:	f383 8812 	msr	BASEPRI_MAX, r3
 1020b08:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1020b0c:	4620      	mov	r0, r4
 1020b0e:	f000 fadf 	bl	10210d0 <z_spin_lock_valid>
 1020b12:	b960      	cbnz	r0, 1020b2e <k_heap_aligned_alloc+0x66>
 1020b14:	2394      	movs	r3, #148	; 0x94
 1020b16:	4a33      	ldr	r2, [pc, #204]	; (1020be4 <k_heap_aligned_alloc+0x11c>)
 1020b18:	4933      	ldr	r1, [pc, #204]	; (1020be8 <k_heap_aligned_alloc+0x120>)
 1020b1a:	4834      	ldr	r0, [pc, #208]	; (1020bec <k_heap_aligned_alloc+0x124>)
 1020b1c:	f004 f85b 	bl	1024bd6 <assert_print>
 1020b20:	4621      	mov	r1, r4
 1020b22:	4833      	ldr	r0, [pc, #204]	; (1020bf0 <k_heap_aligned_alloc+0x128>)
 1020b24:	f004 f857 	bl	1024bd6 <assert_print>
 1020b28:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1020b2a:	482e      	ldr	r0, [pc, #184]	; (1020be4 <k_heap_aligned_alloc+0x11c>)
 1020b2c:	e031      	b.n	1020b92 <k_heap_aligned_alloc+0xca>
	z_spin_lock_set_owner(l);
 1020b2e:	4620      	mov	r0, r4
 1020b30:	f000 faea 	bl	1021108 <z_spin_lock_set_owner>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 1020b34:	f3ef 8305 	mrs	r3, IPSR

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, aligned_alloc, h, timeout);

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
 1020b38:	b113      	cbz	r3, 1020b40 <k_heap_aligned_alloc+0x78>
 1020b3a:	ea5b 0909 	orrs.w	r9, fp, r9
 1020b3e:	d11d      	bne.n	1020b7c <k_heap_aligned_alloc+0xb4>
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
 1020b40:	f108 0b0c 	add.w	fp, r8, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
 1020b44:	4652      	mov	r2, sl
 1020b46:	4640      	mov	r0, r8
 1020b48:	9903      	ldr	r1, [sp, #12]
 1020b4a:	f7e2 f81b 	bl	1002b84 <sys_heap_aligned_alloc>
 1020b4e:	4681      	mov	r9, r0
		now = sys_clock_tick_get();
 1020b50:	f003 f828 	bl	1023ba4 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
 1020b54:	f1b9 0f00 	cmp.w	r9, #0
 1020b58:	d01d      	beq.n	1020b96 <k_heap_aligned_alloc+0xce>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1020b5a:	4620      	mov	r0, r4
 1020b5c:	f000 fac6 	bl	10210ec <z_spin_unlock_valid>
 1020b60:	2800      	cmp	r0, #0
 1020b62:	d137      	bne.n	1020bd4 <k_heap_aligned_alloc+0x10c>
 1020b64:	23c2      	movs	r3, #194	; 0xc2
 1020b66:	4a1f      	ldr	r2, [pc, #124]	; (1020be4 <k_heap_aligned_alloc+0x11c>)
 1020b68:	4922      	ldr	r1, [pc, #136]	; (1020bf4 <k_heap_aligned_alloc+0x12c>)
 1020b6a:	4820      	ldr	r0, [pc, #128]	; (1020bec <k_heap_aligned_alloc+0x124>)
 1020b6c:	f004 f833 	bl	1024bd6 <assert_print>
 1020b70:	4621      	mov	r1, r4
 1020b72:	4821      	ldr	r0, [pc, #132]	; (1020bf8 <k_heap_aligned_alloc+0x130>)
 1020b74:	f004 f82f 	bl	1024bd6 <assert_print>
 1020b78:	21c2      	movs	r1, #194	; 0xc2
 1020b7a:	e7d6      	b.n	1020b2a <k_heap_aligned_alloc+0x62>
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
 1020b7c:	491f      	ldr	r1, [pc, #124]	; (1020bfc <k_heap_aligned_alloc+0x134>)
 1020b7e:	234c      	movs	r3, #76	; 0x4c
 1020b80:	4a1f      	ldr	r2, [pc, #124]	; (1020c00 <k_heap_aligned_alloc+0x138>)
 1020b82:	481a      	ldr	r0, [pc, #104]	; (1020bec <k_heap_aligned_alloc+0x124>)
 1020b84:	f004 f827 	bl	1024bd6 <assert_print>
 1020b88:	481e      	ldr	r0, [pc, #120]	; (1020c04 <k_heap_aligned_alloc+0x13c>)
 1020b8a:	f004 f824 	bl	1024bd6 <assert_print>
 1020b8e:	214c      	movs	r1, #76	; 0x4c
 1020b90:	481b      	ldr	r0, [pc, #108]	; (1020c00 <k_heap_aligned_alloc+0x138>)
 1020b92:	f004 f819 	bl	1024bc8 <assert_post_action>
		    (ret != NULL) || ((end - now) <= 0)) {
 1020b96:	1a30      	subs	r0, r6, r0
 1020b98:	eb67 0101 	sbc.w	r1, r7, r1
 1020b9c:	2801      	cmp	r0, #1
 1020b9e:	f171 0300 	sbcs.w	r3, r1, #0
 1020ba2:	dbda      	blt.n	1020b5a <k_heap_aligned_alloc+0x92>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
 1020ba4:	e9cd 0100 	strd	r0, r1, [sp]
 1020ba8:	465a      	mov	r2, fp
 1020baa:	4629      	mov	r1, r5
 1020bac:	4620      	mov	r0, r4
 1020bae:	f002 f809 	bl	1022bc4 <z_pend_curr>
 1020bb2:	f04f 0320 	mov.w	r3, #32
 1020bb6:	f3ef 8511 	mrs	r5, BASEPRI
 1020bba:	f383 8812 	msr	BASEPRI_MAX, r3
 1020bbe:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1020bc2:	4620      	mov	r0, r4
 1020bc4:	f000 fa84 	bl	10210d0 <z_spin_lock_valid>
 1020bc8:	2800      	cmp	r0, #0
 1020bca:	d0a3      	beq.n	1020b14 <k_heap_aligned_alloc+0x4c>
	z_spin_lock_set_owner(l);
 1020bcc:	4620      	mov	r0, r4
 1020bce:	f000 fa9b 	bl	1021108 <z_spin_lock_set_owner>
	return k;
 1020bd2:	e7b7      	b.n	1020b44 <k_heap_aligned_alloc+0x7c>
	__asm__ volatile(
 1020bd4:	f385 8811 	msr	BASEPRI, r5
 1020bd8:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
 1020bdc:	4648      	mov	r0, r9
 1020bde:	b005      	add	sp, #20
 1020be0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1020be4:	0102bd8a 	.word	0x0102bd8a
 1020be8:	0102bde3 	.word	0x0102bde3
 1020bec:	0102b695 	.word	0x0102b695
 1020bf0:	0102bdf8 	.word	0x0102bdf8
 1020bf4:	0102bdb7 	.word	0x0102bdb7
 1020bf8:	0102bdce 	.word	0x0102bdce
 1020bfc:	0102f746 	.word	0x0102f746
 1020c00:	0102f70e 	.word	0x0102f70e
 1020c04:	0102ee84 	.word	0x0102ee84

01020c08 <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
 1020c08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1020c0a:	4605      	mov	r5, r0
 1020c0c:	460e      	mov	r6, r1
	k_spinlock_key_t key = k_spin_lock(&h->lock);
 1020c0e:	f100 0414 	add.w	r4, r0, #20
	__asm__ volatile(
 1020c12:	f04f 0320 	mov.w	r3, #32
 1020c16:	f3ef 8711 	mrs	r7, BASEPRI
 1020c1a:	f383 8812 	msr	BASEPRI_MAX, r3
 1020c1e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1020c22:	4620      	mov	r0, r4
 1020c24:	f000 fa54 	bl	10210d0 <z_spin_lock_valid>
 1020c28:	b968      	cbnz	r0, 1020c46 <k_heap_free+0x3e>
 1020c2a:	2394      	movs	r3, #148	; 0x94
 1020c2c:	4a19      	ldr	r2, [pc, #100]	; (1020c94 <k_heap_free+0x8c>)
 1020c2e:	491a      	ldr	r1, [pc, #104]	; (1020c98 <k_heap_free+0x90>)
 1020c30:	481a      	ldr	r0, [pc, #104]	; (1020c9c <k_heap_free+0x94>)
 1020c32:	f003 ffd0 	bl	1024bd6 <assert_print>
 1020c36:	4621      	mov	r1, r4
 1020c38:	4819      	ldr	r0, [pc, #100]	; (1020ca0 <k_heap_free+0x98>)
 1020c3a:	f003 ffcc 	bl	1024bd6 <assert_print>
 1020c3e:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1020c40:	4814      	ldr	r0, [pc, #80]	; (1020c94 <k_heap_free+0x8c>)
 1020c42:	f003 ffc1 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1020c46:	4620      	mov	r0, r4
 1020c48:	f000 fa5e 	bl	1021108 <z_spin_lock_set_owner>

	sys_heap_free(&h->heap, mem);
 1020c4c:	4628      	mov	r0, r5
 1020c4e:	4631      	mov	r1, r6
 1020c50:	f7e1 ff52 	bl	1002af8 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
 1020c54:	f105 000c 	add.w	r0, r5, #12
 1020c58:	f008 fbf2 	bl	1029440 <z_unpend_all>
 1020c5c:	b128      	cbz	r0, 1020c6a <k_heap_free+0x62>
		z_reschedule(&h->lock, key);
 1020c5e:	4639      	mov	r1, r7
 1020c60:	4620      	mov	r0, r4
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
 1020c62:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		z_reschedule(&h->lock, key);
 1020c66:	f001 bcdf 	b.w	1022628 <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1020c6a:	4620      	mov	r0, r4
 1020c6c:	f000 fa3e 	bl	10210ec <z_spin_unlock_valid>
 1020c70:	b958      	cbnz	r0, 1020c8a <k_heap_free+0x82>
 1020c72:	23c2      	movs	r3, #194	; 0xc2
 1020c74:	4a07      	ldr	r2, [pc, #28]	; (1020c94 <k_heap_free+0x8c>)
 1020c76:	490b      	ldr	r1, [pc, #44]	; (1020ca4 <k_heap_free+0x9c>)
 1020c78:	4808      	ldr	r0, [pc, #32]	; (1020c9c <k_heap_free+0x94>)
 1020c7a:	f003 ffac 	bl	1024bd6 <assert_print>
 1020c7e:	4621      	mov	r1, r4
 1020c80:	4809      	ldr	r0, [pc, #36]	; (1020ca8 <k_heap_free+0xa0>)
 1020c82:	f003 ffa8 	bl	1024bd6 <assert_print>
 1020c86:	21c2      	movs	r1, #194	; 0xc2
 1020c88:	e7da      	b.n	1020c40 <k_heap_free+0x38>
	__asm__ volatile(
 1020c8a:	f387 8811 	msr	BASEPRI, r7
 1020c8e:	f3bf 8f6f 	isb	sy
}
 1020c92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1020c94:	0102bd8a 	.word	0x0102bd8a
 1020c98:	0102bde3 	.word	0x0102bde3
 1020c9c:	0102b695 	.word	0x0102b695
 1020ca0:	0102bdf8 	.word	0x0102bdf8
 1020ca4:	0102bdb7 	.word	0x0102bdb7
 1020ca8:	0102bdce 	.word	0x0102bdce

01020cac <init_mem_slab_module>:
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(const struct device *dev)
{
	int rc = 0;
 1020cac:	2000      	movs	r0, #0
{
 1020cae:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 1020cb0:	4c0c      	ldr	r4, [pc, #48]	; (1020ce4 <init_mem_slab_module+0x38>)
 1020cb2:	4d0d      	ldr	r5, [pc, #52]	; (1020ce8 <init_mem_slab_module+0x3c>)
 1020cb4:	42ac      	cmp	r4, r5
 1020cb6:	d913      	bls.n	1020ce0 <init_mem_slab_module+0x34>
 1020cb8:	490c      	ldr	r1, [pc, #48]	; (1020cec <init_mem_slab_module+0x40>)
 1020cba:	233d      	movs	r3, #61	; 0x3d
 1020cbc:	4a0c      	ldr	r2, [pc, #48]	; (1020cf0 <init_mem_slab_module+0x44>)
 1020cbe:	480d      	ldr	r0, [pc, #52]	; (1020cf4 <init_mem_slab_module+0x48>)
 1020cc0:	f003 ff89 	bl	1024bd6 <assert_print>
 1020cc4:	480c      	ldr	r0, [pc, #48]	; (1020cf8 <init_mem_slab_module+0x4c>)
 1020cc6:	f003 ff86 	bl	1024bd6 <assert_print>
 1020cca:	213d      	movs	r1, #61	; 0x3d
 1020ccc:	4808      	ldr	r0, [pc, #32]	; (1020cf0 <init_mem_slab_module+0x44>)
 1020cce:	f003 ff7b 	bl	1024bc8 <assert_post_action>
		rc = create_free_list(slab);
 1020cd2:	4620      	mov	r0, r4
 1020cd4:	f008 fabf 	bl	1029256 <create_free_list>
		if (rc < 0) {
 1020cd8:	2800      	cmp	r0, #0
 1020cda:	db02      	blt.n	1020ce2 <init_mem_slab_module+0x36>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 1020cdc:	3420      	adds	r4, #32
 1020cde:	e7e9      	b.n	1020cb4 <init_mem_slab_module+0x8>
 1020ce0:	d3f7      	bcc.n	1020cd2 <init_mem_slab_module+0x26>
		z_object_init(slab);
	}

out:
	return rc;
}
 1020ce2:	bd38      	pop	{r3, r4, r5, pc}
 1020ce4:	21000c10 	.word	0x21000c10
 1020ce8:	21000c70 	.word	0x21000c70
 1020cec:	0102f7b1 	.word	0x0102f7b1
 1020cf0:	0102f78c 	.word	0x0102f78c
 1020cf4:	0102b695 	.word	0x0102b695
 1020cf8:	0102bf04 	.word	0x0102bf04

01020cfc <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
 1020cfc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 1020d00:	4604      	mov	r4, r0
 1020d02:	460e      	mov	r6, r1
 1020d04:	4690      	mov	r8, r2
 1020d06:	461f      	mov	r7, r3
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
 1020d08:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
 1020d0c:	f04f 0320 	mov.w	r3, #32
 1020d10:	f3ef 8911 	mrs	r9, BASEPRI
 1020d14:	f383 8812 	msr	BASEPRI_MAX, r3
 1020d18:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1020d1c:	4628      	mov	r0, r5
 1020d1e:	f000 f9d7 	bl	10210d0 <z_spin_lock_valid>
 1020d22:	b968      	cbnz	r0, 1020d40 <k_mem_slab_alloc+0x44>
 1020d24:	2394      	movs	r3, #148	; 0x94
 1020d26:	4a23      	ldr	r2, [pc, #140]	; (1020db4 <k_mem_slab_alloc+0xb8>)
 1020d28:	4923      	ldr	r1, [pc, #140]	; (1020db8 <k_mem_slab_alloc+0xbc>)
 1020d2a:	4824      	ldr	r0, [pc, #144]	; (1020dbc <k_mem_slab_alloc+0xc0>)
 1020d2c:	f003 ff53 	bl	1024bd6 <assert_print>
 1020d30:	4629      	mov	r1, r5
 1020d32:	4823      	ldr	r0, [pc, #140]	; (1020dc0 <k_mem_slab_alloc+0xc4>)
 1020d34:	f003 ff4f 	bl	1024bd6 <assert_print>
 1020d38:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1020d3a:	481e      	ldr	r0, [pc, #120]	; (1020db4 <k_mem_slab_alloc+0xb8>)
 1020d3c:	f003 ff44 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1020d40:	4628      	mov	r0, r5
 1020d42:	f000 f9e1 	bl	1021108 <z_spin_lock_set_owner>
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
 1020d46:	69a3      	ldr	r3, [r4, #24]
 1020d48:	b1b3      	cbz	r3, 1020d78 <k_mem_slab_alloc+0x7c>
		/* take a free block */
		*mem = slab->free_list;
 1020d4a:	6033      	str	r3, [r6, #0]
		slab->free_list = *(char **)(slab->free_list);
 1020d4c:	681b      	ldr	r3, [r3, #0]
 1020d4e:	61a3      	str	r3, [r4, #24]
		slab->num_used++;
 1020d50:	69e3      	ldr	r3, [r4, #28]
 1020d52:	3301      	adds	r3, #1
 1020d54:	61e3      	str	r3, [r4, #28]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
 1020d56:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1020d58:	4628      	mov	r0, r5
 1020d5a:	f000 f9c7 	bl	10210ec <z_spin_unlock_valid>
 1020d5e:	bb18      	cbnz	r0, 1020da8 <k_mem_slab_alloc+0xac>
 1020d60:	23c2      	movs	r3, #194	; 0xc2
 1020d62:	4a14      	ldr	r2, [pc, #80]	; (1020db4 <k_mem_slab_alloc+0xb8>)
 1020d64:	4917      	ldr	r1, [pc, #92]	; (1020dc4 <k_mem_slab_alloc+0xc8>)
 1020d66:	4815      	ldr	r0, [pc, #84]	; (1020dbc <k_mem_slab_alloc+0xc0>)
 1020d68:	f003 ff35 	bl	1024bd6 <assert_print>
 1020d6c:	4629      	mov	r1, r5
 1020d6e:	4816      	ldr	r0, [pc, #88]	; (1020dc8 <k_mem_slab_alloc+0xcc>)
 1020d70:	f003 ff31 	bl	1024bd6 <assert_print>
 1020d74:	21c2      	movs	r1, #194	; 0xc2
 1020d76:	e7e0      	b.n	1020d3a <k_mem_slab_alloc+0x3e>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
 1020d78:	ea58 0207 	orrs.w	r2, r8, r7
 1020d7c:	d103      	bne.n	1020d86 <k_mem_slab_alloc+0x8a>
		   !IS_ENABLED(CONFIG_MULTITHREADING)) {
		/* don't wait for a free block to become available */
		*mem = NULL;
		result = -ENOMEM;
 1020d7e:	f06f 040b 	mvn.w	r4, #11
		*mem = NULL;
 1020d82:	6033      	str	r3, [r6, #0]
		result = -ENOMEM;
 1020d84:	e7e8      	b.n	1020d58 <k_mem_slab_alloc+0x5c>
	} else {
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mem_slab, alloc, slab, timeout);

		/* wait for a free block or timeout */
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
 1020d86:	4622      	mov	r2, r4
 1020d88:	4649      	mov	r1, r9
 1020d8a:	4628      	mov	r0, r5
 1020d8c:	e9cd 8700 	strd	r8, r7, [sp]
 1020d90:	f001 ff18 	bl	1022bc4 <z_pend_curr>
		if (result == 0) {
 1020d94:	4604      	mov	r4, r0
 1020d96:	b918      	cbnz	r0, 1020da0 <k_mem_slab_alloc+0xa4>
			*mem = _current->base.swap_data;
 1020d98:	4b0c      	ldr	r3, [pc, #48]	; (1020dcc <k_mem_slab_alloc+0xd0>)
 1020d9a:	689b      	ldr	r3, [r3, #8]
 1020d9c:	695b      	ldr	r3, [r3, #20]
 1020d9e:	6033      	str	r3, [r6, #0]
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
}
 1020da0:	4620      	mov	r0, r4
 1020da2:	b003      	add	sp, #12
 1020da4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	__asm__ volatile(
 1020da8:	f389 8811 	msr	BASEPRI, r9
 1020dac:	f3bf 8f6f 	isb	sy
	return result;
 1020db0:	e7f6      	b.n	1020da0 <k_mem_slab_alloc+0xa4>
 1020db2:	bf00      	nop
 1020db4:	0102bd8a 	.word	0x0102bd8a
 1020db8:	0102bde3 	.word	0x0102bde3
 1020dbc:	0102b695 	.word	0x0102b695
 1020dc0:	0102bdf8 	.word	0x0102bdf8
 1020dc4:	0102bdb7 	.word	0x0102bdb7
 1020dc8:	0102bdce 	.word	0x0102bdce
 1020dcc:	210080cc 	.word	0x210080cc

01020dd0 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
 1020dd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1020dd4:	4604      	mov	r4, r0
 1020dd6:	460e      	mov	r6, r1
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
 1020dd8:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
 1020ddc:	f04f 0320 	mov.w	r3, #32
 1020de0:	f3ef 8711 	mrs	r7, BASEPRI
 1020de4:	f383 8812 	msr	BASEPRI_MAX, r3
 1020de8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1020dec:	4628      	mov	r0, r5
 1020dee:	f000 f96f 	bl	10210d0 <z_spin_lock_valid>
 1020df2:	b968      	cbnz	r0, 1020e10 <k_mem_slab_free+0x40>
 1020df4:	2394      	movs	r3, #148	; 0x94
 1020df6:	4a21      	ldr	r2, [pc, #132]	; (1020e7c <k_mem_slab_free+0xac>)
 1020df8:	4921      	ldr	r1, [pc, #132]	; (1020e80 <k_mem_slab_free+0xb0>)
 1020dfa:	4822      	ldr	r0, [pc, #136]	; (1020e84 <k_mem_slab_free+0xb4>)
 1020dfc:	f003 feeb 	bl	1024bd6 <assert_print>
 1020e00:	4629      	mov	r1, r5
 1020e02:	4821      	ldr	r0, [pc, #132]	; (1020e88 <k_mem_slab_free+0xb8>)
 1020e04:	f003 fee7 	bl	1024bd6 <assert_print>
 1020e08:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1020e0a:	481c      	ldr	r0, [pc, #112]	; (1020e7c <k_mem_slab_free+0xac>)
 1020e0c:	f003 fedc 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1020e10:	4628      	mov	r0, r5
 1020e12:	f000 f979 	bl	1021108 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
 1020e16:	f8d4 8018 	ldr.w	r8, [r4, #24]
 1020e1a:	f1b8 0f00 	cmp.w	r8, #0
 1020e1e:	d10f      	bne.n	1020e40 <k_mem_slab_free+0x70>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
 1020e20:	4620      	mov	r0, r4
 1020e22:	f002 f94d 	bl	10230c0 <z_unpend_first_thread>

		if (pending_thread != NULL) {
 1020e26:	b158      	cbz	r0, 1020e40 <k_mem_slab_free+0x70>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
 1020e28:	6832      	ldr	r2, [r6, #0]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
 1020e2a:	f8c0 807c 	str.w	r8, [r0, #124]	; 0x7c
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
 1020e2e:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
 1020e30:	f001 fb6e 	bl	1022510 <z_ready_thread>
			z_reschedule(&slab->lock, key);
 1020e34:	4639      	mov	r1, r7
 1020e36:	4628      	mov	r0, r5
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
 1020e38:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			z_reschedule(&slab->lock, key);
 1020e3c:	f001 bbf4 	b.w	1022628 <z_reschedule>
	**(char ***) mem = slab->free_list;
 1020e40:	6833      	ldr	r3, [r6, #0]
 1020e42:	69a2      	ldr	r2, [r4, #24]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1020e44:	4628      	mov	r0, r5
 1020e46:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
 1020e48:	6833      	ldr	r3, [r6, #0]
 1020e4a:	61a3      	str	r3, [r4, #24]
	slab->num_used--;
 1020e4c:	69e3      	ldr	r3, [r4, #28]
 1020e4e:	3b01      	subs	r3, #1
 1020e50:	61e3      	str	r3, [r4, #28]
 1020e52:	f000 f94b 	bl	10210ec <z_spin_unlock_valid>
 1020e56:	b958      	cbnz	r0, 1020e70 <k_mem_slab_free+0xa0>
 1020e58:	23c2      	movs	r3, #194	; 0xc2
 1020e5a:	4a08      	ldr	r2, [pc, #32]	; (1020e7c <k_mem_slab_free+0xac>)
 1020e5c:	490b      	ldr	r1, [pc, #44]	; (1020e8c <k_mem_slab_free+0xbc>)
 1020e5e:	4809      	ldr	r0, [pc, #36]	; (1020e84 <k_mem_slab_free+0xb4>)
 1020e60:	f003 feb9 	bl	1024bd6 <assert_print>
 1020e64:	4629      	mov	r1, r5
 1020e66:	480a      	ldr	r0, [pc, #40]	; (1020e90 <k_mem_slab_free+0xc0>)
 1020e68:	f003 feb5 	bl	1024bd6 <assert_print>
 1020e6c:	21c2      	movs	r1, #194	; 0xc2
 1020e6e:	e7cc      	b.n	1020e0a <k_mem_slab_free+0x3a>
	__asm__ volatile(
 1020e70:	f387 8811 	msr	BASEPRI, r7
 1020e74:	f3bf 8f6f 	isb	sy
}
 1020e78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 1020e7c:	0102bd8a 	.word	0x0102bd8a
 1020e80:	0102bde3 	.word	0x0102bde3
 1020e84:	0102b695 	.word	0x0102b695
 1020e88:	0102bdf8 	.word	0x0102bdf8
 1020e8c:	0102bdb7 	.word	0x0102bdb7
 1020e90:	0102bdce 	.word	0x0102bdce

01020e94 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
 1020e94:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 1020e96:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 1020e98:	4604      	mov	r4, r0
	char *stack_ptr;

	Z_ASSERT_VALID_PRIO(prio, entry);
 1020e9a:	2e0f      	cmp	r6, #15
 1020e9c:	d12a      	bne.n	1020ef4 <z_setup_new_thread+0x60>
 1020e9e:	4821      	ldr	r0, [pc, #132]	; (1020f24 <z_setup_new_thread+0x90>)
 1020ea0:	4283      	cmp	r3, r0
 1020ea2:	d12b      	bne.n	1020efc <z_setup_new_thread+0x68>
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
 1020ea4:	f104 0058 	add.w	r0, r4, #88	; 0x58
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
 1020ea8:	e9c4 0016 	strd	r0, r0, [r4, #88]	; 0x58
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
 1020eac:	980c      	ldr	r0, [sp, #48]	; 0x30
	thread_base->pended_on = NULL;
 1020eae:	2500      	movs	r5, #0
	thread_base->user_options = (uint8_t)options;
 1020eb0:	7320      	strb	r0, [r4, #12]
	thread_base->thread_state = (uint8_t)initial_state;
 1020eb2:	2004      	movs	r0, #4
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
 1020eb4:	3207      	adds	r2, #7
 1020eb6:	f022 0207 	bic.w	r2, r2, #7
	new_thread->stack_info.size = stack_buf_size;
 1020eba:	e9c4 121a 	strd	r1, r2, [r4, #104]	; 0x68

	thread_base->prio = priority;
 1020ebe:	73a6      	strb	r6, [r4, #14]
	stack_ptr = (char *)stack + stack_obj_size;
 1020ec0:	188e      	adds	r6, r1, r2
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 1020ec2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
	thread_base->thread_state = (uint8_t)initial_state;
 1020ec4:	7360      	strb	r0, [r4, #13]
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
 1020ec6:	e9c4 5506 	strd	r5, r5, [r4, #24]
	thread_base->pended_on = NULL;
 1020eca:	60a5      	str	r5, [r4, #8]

	thread_base->sched_locked = 0U;
 1020ecc:	73e5      	strb	r5, [r4, #15]
	new_thread->stack_info.delta = delta;
 1020ece:	6725      	str	r5, [r4, #112]	; 0x70
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 1020ed0:	9202      	str	r2, [sp, #8]
 1020ed2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 1020ed4:	4620      	mov	r0, r4
 1020ed6:	9201      	str	r2, [sp, #4]
 1020ed8:	9a08      	ldr	r2, [sp, #32]
 1020eda:	9200      	str	r2, [sp, #0]
 1020edc:	4632      	mov	r2, r6
 1020ede:	f7e5 f855 	bl	1005f8c <arch_new_thread>
	if (!_current) {
 1020ee2:	4b11      	ldr	r3, [pc, #68]	; (1020f28 <z_setup_new_thread+0x94>)
	new_thread->init_data = NULL;
 1020ee4:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
 1020ee6:	689b      	ldr	r3, [r3, #8]
 1020ee8:	b103      	cbz	r3, 1020eec <z_setup_new_thread+0x58>
	new_thread->resource_pool = _current->resource_pool;
 1020eea:	6f5b      	ldr	r3, [r3, #116]	; 0x74
}
 1020eec:	4630      	mov	r0, r6
 1020eee:	6763      	str	r3, [r4, #116]	; 0x74
 1020ef0:	b004      	add	sp, #16
 1020ef2:	bd70      	pop	{r4, r5, r6, pc}
	Z_ASSERT_VALID_PRIO(prio, entry);
 1020ef4:	f106 0010 	add.w	r0, r6, #16
 1020ef8:	281e      	cmp	r0, #30
 1020efa:	d9d3      	bls.n	1020ea4 <z_setup_new_thread+0x10>
 1020efc:	f44f 7306 	mov.w	r3, #536	; 0x218
 1020f00:	4a0a      	ldr	r2, [pc, #40]	; (1020f2c <z_setup_new_thread+0x98>)
 1020f02:	490b      	ldr	r1, [pc, #44]	; (1020f30 <z_setup_new_thread+0x9c>)
 1020f04:	480b      	ldr	r0, [pc, #44]	; (1020f34 <z_setup_new_thread+0xa0>)
 1020f06:	f003 fe66 	bl	1024bd6 <assert_print>
 1020f0a:	4631      	mov	r1, r6
 1020f0c:	480a      	ldr	r0, [pc, #40]	; (1020f38 <z_setup_new_thread+0xa4>)
 1020f0e:	f06f 030f 	mvn.w	r3, #15
 1020f12:	220e      	movs	r2, #14
 1020f14:	f003 fe5f 	bl	1024bd6 <assert_print>
 1020f18:	f44f 7106 	mov.w	r1, #536	; 0x218
 1020f1c:	4803      	ldr	r0, [pc, #12]	; (1020f2c <z_setup_new_thread+0x98>)
 1020f1e:	f003 fe53 	bl	1024bc8 <assert_post_action>
 1020f22:	bf00      	nop
 1020f24:	01021119 	.word	0x01021119
 1020f28:	210080cc 	.word	0x210080cc
 1020f2c:	0102f7ce 	.word	0x0102f7ce
 1020f30:	0102f7f1 	.word	0x0102f7f1
 1020f34:	0102b695 	.word	0x0102b695
 1020f38:	0102f871 	.word	0x0102f871

01020f3c <z_impl_k_thread_create>:
{
 1020f3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 1020f3e:	b087      	sub	sp, #28
 1020f40:	4604      	mov	r4, r0
 1020f42:	e9dd 7612 	ldrd	r7, r6, [sp, #72]	; 0x48
 1020f46:	f3ef 8505 	mrs	r5, IPSR
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
 1020f4a:	b175      	cbz	r5, 1020f6a <z_impl_k_thread_create+0x2e>
 1020f4c:	4919      	ldr	r1, [pc, #100]	; (1020fb4 <z_impl_k_thread_create+0x78>)
 1020f4e:	f240 2387 	movw	r3, #647	; 0x287
 1020f52:	4a19      	ldr	r2, [pc, #100]	; (1020fb8 <z_impl_k_thread_create+0x7c>)
 1020f54:	4819      	ldr	r0, [pc, #100]	; (1020fbc <z_impl_k_thread_create+0x80>)
 1020f56:	f003 fe3e 	bl	1024bd6 <assert_print>
 1020f5a:	4819      	ldr	r0, [pc, #100]	; (1020fc0 <z_impl_k_thread_create+0x84>)
 1020f5c:	f003 fe3b 	bl	1024bd6 <assert_print>
 1020f60:	f240 2187 	movw	r1, #647	; 0x287
 1020f64:	4814      	ldr	r0, [pc, #80]	; (1020fb8 <z_impl_k_thread_create+0x7c>)
 1020f66:	f003 fe2f 	bl	1024bc8 <assert_post_action>
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 1020f6a:	9505      	str	r5, [sp, #20]
 1020f6c:	9d10      	ldr	r5, [sp, #64]	; 0x40
 1020f6e:	9504      	str	r5, [sp, #16]
 1020f70:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 1020f72:	9503      	str	r5, [sp, #12]
 1020f74:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 1020f76:	9502      	str	r5, [sp, #8]
 1020f78:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 1020f7a:	9501      	str	r5, [sp, #4]
 1020f7c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 1020f7e:	9500      	str	r5, [sp, #0]
 1020f80:	f7ff ff88 	bl	1020e94 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
 1020f84:	f1b6 3fff 	cmp.w	r6, #4294967295
 1020f88:	bf08      	it	eq
 1020f8a:	f1b7 3fff 	cmpeq.w	r7, #4294967295
 1020f8e:	d005      	beq.n	1020f9c <z_impl_k_thread_create+0x60>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 1020f90:	ea56 0307 	orrs.w	r3, r6, r7
 1020f94:	d105      	bne.n	1020fa2 <z_impl_k_thread_create+0x66>
	z_sched_start(thread);
 1020f96:	4620      	mov	r0, r4
 1020f98:	f001 fb88 	bl	10226ac <z_sched_start>
}
 1020f9c:	4620      	mov	r0, r4
 1020f9e:	b007      	add	sp, #28
 1020fa0:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 1020fa2:	463a      	mov	r2, r7
 1020fa4:	4633      	mov	r3, r6
 1020fa6:	4907      	ldr	r1, [pc, #28]	; (1020fc4 <z_impl_k_thread_create+0x88>)
 1020fa8:	f104 0018 	add.w	r0, r4, #24
 1020fac:	f002 fbf8 	bl	10237a0 <z_add_timeout>
 1020fb0:	e7f4      	b.n	1020f9c <z_impl_k_thread_create+0x60>
 1020fb2:	bf00      	nop
 1020fb4:	0102f8a2 	.word	0x0102f8a2
 1020fb8:	0102f7ce 	.word	0x0102f7ce
 1020fbc:	0102b695 	.word	0x0102b695
 1020fc0:	0102f8b4 	.word	0x0102f8b4
 1020fc4:	01022f79 	.word	0x01022f79

01020fc8 <z_init_static_threads>:
{
 1020fc8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1020fcc:	4c39      	ldr	r4, [pc, #228]	; (10210b4 <z_init_static_threads+0xec>)
	_FOREACH_STATIC_THREAD(thread_data) {
 1020fce:	4d3a      	ldr	r5, [pc, #232]	; (10210b8 <z_init_static_threads+0xf0>)
{
 1020fd0:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
 1020fd2:	42ac      	cmp	r4, r5
 1020fd4:	4626      	mov	r6, r4
 1020fd6:	d92a      	bls.n	102102e <z_init_static_threads+0x66>
 1020fd8:	4938      	ldr	r1, [pc, #224]	; (10210bc <z_init_static_threads+0xf4>)
 1020fda:	f240 23ee 	movw	r3, #750	; 0x2ee
 1020fde:	4a38      	ldr	r2, [pc, #224]	; (10210c0 <z_init_static_threads+0xf8>)
 1020fe0:	4838      	ldr	r0, [pc, #224]	; (10210c4 <z_init_static_threads+0xfc>)
 1020fe2:	f003 fdf8 	bl	1024bd6 <assert_print>
 1020fe6:	4838      	ldr	r0, [pc, #224]	; (10210c8 <z_init_static_threads+0x100>)
 1020fe8:	f003 fdf5 	bl	1024bd6 <assert_print>
 1020fec:	f240 21ee 	movw	r1, #750	; 0x2ee
	_FOREACH_STATIC_THREAD(thread_data) {
 1020ff0:	4833      	ldr	r0, [pc, #204]	; (10210c0 <z_init_static_threads+0xf8>)
 1020ff2:	f003 fde9 	bl	1024bc8 <assert_post_action>
		z_setup_new_thread(
 1020ff6:	f854 3c04 	ldr.w	r3, [r4, #-4]
 1020ffa:	9305      	str	r3, [sp, #20]
 1020ffc:	f854 3c10 	ldr.w	r3, [r4, #-16]
 1021000:	9304      	str	r3, [sp, #16]
 1021002:	f854 3c14 	ldr.w	r3, [r4, #-20]
 1021006:	9303      	str	r3, [sp, #12]
 1021008:	f854 3c18 	ldr.w	r3, [r4, #-24]
 102100c:	9302      	str	r3, [sp, #8]
 102100e:	f854 3c1c 	ldr.w	r3, [r4, #-28]
 1021012:	9301      	str	r3, [sp, #4]
 1021014:	f854 3c20 	ldr.w	r3, [r4, #-32]
 1021018:	9300      	str	r3, [sp, #0]
 102101a:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
 102101e:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
 1021022:	f7ff ff37 	bl	1020e94 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
 1021026:	f854 3c30 	ldr.w	r3, [r4, #-48]
 102102a:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
 102102c:	e7d1      	b.n	1020fd2 <z_init_static_threads+0xa>
 102102e:	42ae      	cmp	r6, r5
 1021030:	f104 0430 	add.w	r4, r4, #48	; 0x30
 1021034:	d3df      	bcc.n	1020ff6 <z_init_static_threads+0x2e>
	k_sched_lock();
 1021036:	f001 fb8b 	bl	1022750 <k_sched_lock>
 102103a:	f44f 4600 	mov.w	r6, #32768	; 0x8000
 102103e:	f240 37e7 	movw	r7, #999	; 0x3e7
	_FOREACH_STATIC_THREAD(thread_data) {
 1021042:	4c1c      	ldr	r4, [pc, #112]	; (10210b4 <z_init_static_threads+0xec>)
 1021044:	f8df 9084 	ldr.w	r9, [pc, #132]	; 10210cc <z_init_static_threads+0x104>
 1021048:	42ac      	cmp	r4, r5
 102104a:	d92c      	bls.n	10210a6 <z_init_static_threads+0xde>
 102104c:	491b      	ldr	r1, [pc, #108]	; (10210bc <z_init_static_threads+0xf4>)
 102104e:	f240 330d 	movw	r3, #781	; 0x30d
 1021052:	4a1b      	ldr	r2, [pc, #108]	; (10210c0 <z_init_static_threads+0xf8>)
 1021054:	481b      	ldr	r0, [pc, #108]	; (10210c4 <z_init_static_threads+0xfc>)
 1021056:	f003 fdbe 	bl	1024bd6 <assert_print>
 102105a:	481b      	ldr	r0, [pc, #108]	; (10210c8 <z_init_static_threads+0x100>)
 102105c:	f003 fdbb 	bl	1024bd6 <assert_print>
 1021060:	f240 310d 	movw	r1, #781	; 0x30d
 1021064:	e7c4      	b.n	1020ff0 <z_init_static_threads+0x28>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
 1021066:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1021068:	1c5a      	adds	r2, r3, #1
 102106a:	d00d      	beq.n	1021088 <z_init_static_threads+0xc0>
 102106c:	2100      	movs	r1, #0
 102106e:	4638      	mov	r0, r7
					    K_MSEC(thread_data->init_delay));
 1021070:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 1021074:	fbc3 0106 	smlal	r0, r1, r3, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 1021078:	ea51 33c3 	orrs.w	r3, r1, r3, lsl #15
			schedule_new_thread(thread_data->init_thread,
 102107c:	f8d4 8000 	ldr.w	r8, [r4]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 1021080:	d104      	bne.n	102108c <z_init_static_threads+0xc4>
	z_sched_start(thread);
 1021082:	4640      	mov	r0, r8
 1021084:	f001 fb12 	bl	10226ac <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
 1021088:	3430      	adds	r4, #48	; 0x30
 102108a:	e7dd      	b.n	1021048 <z_init_static_threads+0x80>
 102108c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 1021090:	2300      	movs	r3, #0
 1021092:	f7df f811 	bl	10000b8 <__aeabi_uldivmod>
 1021096:	4602      	mov	r2, r0
 1021098:	460b      	mov	r3, r1
 102109a:	f108 0018 	add.w	r0, r8, #24
 102109e:	4649      	mov	r1, r9
 10210a0:	f002 fb7e 	bl	10237a0 <z_add_timeout>
 10210a4:	e7f0      	b.n	1021088 <z_init_static_threads+0xc0>
 10210a6:	d3de      	bcc.n	1021066 <z_init_static_threads+0x9e>
}
 10210a8:	b007      	add	sp, #28
 10210aa:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
 10210ae:	f001 bbbb 	b.w	1022828 <k_sched_unlock>
 10210b2:	bf00      	nop
 10210b4:	01029868 	.word	0x01029868
 10210b8:	010298c8 	.word	0x010298c8
 10210bc:	0102f8d9 	.word	0x0102f8d9
 10210c0:	0102f7ce 	.word	0x0102f7ce
 10210c4:	0102b695 	.word	0x0102b695
 10210c8:	0102bf04 	.word	0x0102bf04
 10210cc:	01022f79 	.word	0x01022f79

010210d0 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
 10210d0:	6800      	ldr	r0, [r0, #0]

	if (thread_cpu != 0U) {
 10210d2:	b138      	cbz	r0, 10210e4 <z_spin_lock_valid+0x14>
		if ((thread_cpu & 3U) == _current_cpu->id) {
 10210d4:	4b04      	ldr	r3, [pc, #16]	; (10210e8 <z_spin_lock_valid+0x18>)
 10210d6:	f000 0003 	and.w	r0, r0, #3
 10210da:	7d1b      	ldrb	r3, [r3, #20]
 10210dc:	1ac0      	subs	r0, r0, r3
 10210de:	bf18      	it	ne
 10210e0:	2001      	movne	r0, #1
 10210e2:	4770      	bx	lr
			return false;
		}
	}
	return true;
 10210e4:	2001      	movs	r0, #1
}
 10210e6:	4770      	bx	lr
 10210e8:	210080cc 	.word	0x210080cc

010210ec <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
 10210ec:	4a05      	ldr	r2, [pc, #20]	; (1021104 <z_spin_unlock_valid+0x18>)
{
 10210ee:	4603      	mov	r3, r0
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
 10210f0:	7d11      	ldrb	r1, [r2, #20]
 10210f2:	6892      	ldr	r2, [r2, #8]
 10210f4:	430a      	orrs	r2, r1
 10210f6:	6801      	ldr	r1, [r0, #0]
 10210f8:	2000      	movs	r0, #0
 10210fa:	4291      	cmp	r1, r2
		return false;
	}
	l->thread_cpu = 0;
 10210fc:	bf04      	itt	eq
 10210fe:	6018      	streq	r0, [r3, #0]
	return true;
 1021100:	2001      	moveq	r0, #1
}
 1021102:	4770      	bx	lr
 1021104:	210080cc 	.word	0x210080cc

01021108 <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
 1021108:	4b02      	ldr	r3, [pc, #8]	; (1021114 <z_spin_lock_set_owner+0xc>)
 102110a:	7d1a      	ldrb	r2, [r3, #20]
 102110c:	689b      	ldr	r3, [r3, #8]
 102110e:	4313      	orrs	r3, r2
 1021110:	6003      	str	r3, [r0, #0]
}
 1021112:	4770      	bx	lr
 1021114:	210080cc 	.word	0x210080cc

01021118 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
 1021118:	b508      	push	{r3, lr}
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	__ASSERT_NO_MSG(_current->base.prio >= 0);
 102111a:	4b0d      	ldr	r3, [pc, #52]	; (1021150 <idle+0x38>)
 102111c:	689b      	ldr	r3, [r3, #8]
 102111e:	f993 300e 	ldrsb.w	r3, [r3, #14]
 1021122:	2b00      	cmp	r3, #0
 1021124:	da09      	bge.n	102113a <idle+0x22>
 1021126:	490b      	ldr	r1, [pc, #44]	; (1021154 <idle+0x3c>)
 1021128:	480b      	ldr	r0, [pc, #44]	; (1021158 <idle+0x40>)
 102112a:	2327      	movs	r3, #39	; 0x27
 102112c:	4a0b      	ldr	r2, [pc, #44]	; (102115c <idle+0x44>)
 102112e:	f003 fd52 	bl	1024bd6 <assert_print>
 1021132:	2127      	movs	r1, #39	; 0x27
 1021134:	4809      	ldr	r0, [pc, #36]	; (102115c <idle+0x44>)
 1021136:	f003 fd47 	bl	1024bc8 <assert_post_action>
	__asm__ volatile(
 102113a:	f04f 0220 	mov.w	r2, #32
 102113e:	f3ef 8311 	mrs	r3, BASEPRI
 1021142:	f382 8812 	msr	BASEPRI_MAX, r2
 1021146:	f3bf 8f6f 	isb	sy
	arch_cpu_idle();
 102114a:	f7e4 fdcf 	bl	1005cec <arch_cpu_idle>
 102114e:	e7f4      	b.n	102113a <idle+0x22>
 1021150:	210080cc 	.word	0x210080cc
 1021154:	0102f927 	.word	0x0102f927
 1021158:	0102b695 	.word	0x0102b695
 102115c:	0102f906 	.word	0x0102f906

01021160 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
 1021160:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 1021164:	4604      	mov	r4, r0
 1021166:	4617      	mov	r7, r2
 1021168:	461e      	mov	r6, r3
 102116a:	f3ef 8505 	mrs	r5, IPSR
	int new_prio;
	k_spinlock_key_t key;
	bool resched = false;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
 102116e:	b165      	cbz	r5, 102118a <z_impl_k_mutex_lock+0x2a>
 1021170:	4958      	ldr	r1, [pc, #352]	; (10212d4 <z_impl_k_mutex_lock+0x174>)
 1021172:	2365      	movs	r3, #101	; 0x65
 1021174:	4a58      	ldr	r2, [pc, #352]	; (10212d8 <z_impl_k_mutex_lock+0x178>)
 1021176:	4859      	ldr	r0, [pc, #356]	; (10212dc <z_impl_k_mutex_lock+0x17c>)
 1021178:	f003 fd2d 	bl	1024bd6 <assert_print>
 102117c:	4858      	ldr	r0, [pc, #352]	; (10212e0 <z_impl_k_mutex_lock+0x180>)
 102117e:	f003 fd2a 	bl	1024bd6 <assert_print>
 1021182:	2165      	movs	r1, #101	; 0x65
 1021184:	4854      	ldr	r0, [pc, #336]	; (10212d8 <z_impl_k_mutex_lock+0x178>)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1021186:	f003 fd1f 	bl	1024bc8 <assert_post_action>
 102118a:	f04f 0320 	mov.w	r3, #32
 102118e:	f3ef 8811 	mrs	r8, BASEPRI
 1021192:	f383 8812 	msr	BASEPRI_MAX, r3
 1021196:	f3bf 8f6f 	isb	sy
 102119a:	4852      	ldr	r0, [pc, #328]	; (10212e4 <z_impl_k_mutex_lock+0x184>)
 102119c:	f7ff ff98 	bl	10210d0 <z_spin_lock_valid>
 10211a0:	b960      	cbnz	r0, 10211bc <z_impl_k_mutex_lock+0x5c>
 10211a2:	2394      	movs	r3, #148	; 0x94
 10211a4:	4a50      	ldr	r2, [pc, #320]	; (10212e8 <z_impl_k_mutex_lock+0x188>)
 10211a6:	4951      	ldr	r1, [pc, #324]	; (10212ec <z_impl_k_mutex_lock+0x18c>)
 10211a8:	484c      	ldr	r0, [pc, #304]	; (10212dc <z_impl_k_mutex_lock+0x17c>)
 10211aa:	f003 fd14 	bl	1024bd6 <assert_print>
 10211ae:	494d      	ldr	r1, [pc, #308]	; (10212e4 <z_impl_k_mutex_lock+0x184>)
 10211b0:	484f      	ldr	r0, [pc, #316]	; (10212f0 <z_impl_k_mutex_lock+0x190>)
 10211b2:	f003 fd10 	bl	1024bd6 <assert_print>
 10211b6:	2194      	movs	r1, #148	; 0x94
 10211b8:	484b      	ldr	r0, [pc, #300]	; (10212e8 <z_impl_k_mutex_lock+0x188>)
 10211ba:	e7e4      	b.n	1021186 <z_impl_k_mutex_lock+0x26>
	z_spin_lock_set_owner(l);
 10211bc:	4849      	ldr	r0, [pc, #292]	; (10212e4 <z_impl_k_mutex_lock+0x184>)
 10211be:	f7ff ffa3 	bl	1021108 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
 10211c2:	68e3      	ldr	r3, [r4, #12]
 10211c4:	4a4b      	ldr	r2, [pc, #300]	; (10212f4 <z_impl_k_mutex_lock+0x194>)
 10211c6:	b19b      	cbz	r3, 10211f0 <z_impl_k_mutex_lock+0x90>
 10211c8:	68a0      	ldr	r0, [r4, #8]
 10211ca:	6891      	ldr	r1, [r2, #8]
 10211cc:	4288      	cmp	r0, r1
 10211ce:	d027      	beq.n	1021220 <z_impl_k_mutex_lock+0xc0>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
 10211d0:	ea57 0306 	orrs.w	r3, r7, r6
 10211d4:	d12c      	bne.n	1021230 <z_impl_k_mutex_lock+0xd0>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10211d6:	4843      	ldr	r0, [pc, #268]	; (10212e4 <z_impl_k_mutex_lock+0x184>)
 10211d8:	f7ff ff88 	bl	10210ec <z_spin_unlock_valid>
 10211dc:	b1a0      	cbz	r0, 1021208 <z_impl_k_mutex_lock+0xa8>
	__asm__ volatile(
 10211de:	f388 8811 	msr	BASEPRI, r8
 10211e2:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
 10211e6:	f06f 000f 	mvn.w	r0, #15
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
 10211ea:	b002      	add	sp, #8
 10211ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
 10211f0:	6891      	ldr	r1, [r2, #8]
 10211f2:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
 10211f6:	3301      	adds	r3, #1
 10211f8:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
 10211fa:	6893      	ldr	r3, [r2, #8]
 10211fc:	4839      	ldr	r0, [pc, #228]	; (10212e4 <z_impl_k_mutex_lock+0x184>)
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 10211fe:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
 1021200:	60a3      	str	r3, [r4, #8]
 1021202:	f7ff ff73 	bl	10210ec <z_spin_unlock_valid>
 1021206:	b968      	cbnz	r0, 1021224 <z_impl_k_mutex_lock+0xc4>
 1021208:	23c2      	movs	r3, #194	; 0xc2
 102120a:	4a37      	ldr	r2, [pc, #220]	; (10212e8 <z_impl_k_mutex_lock+0x188>)
 102120c:	493a      	ldr	r1, [pc, #232]	; (10212f8 <z_impl_k_mutex_lock+0x198>)
 102120e:	4833      	ldr	r0, [pc, #204]	; (10212dc <z_impl_k_mutex_lock+0x17c>)
 1021210:	f003 fce1 	bl	1024bd6 <assert_print>
 1021214:	4933      	ldr	r1, [pc, #204]	; (10212e4 <z_impl_k_mutex_lock+0x184>)
 1021216:	4839      	ldr	r0, [pc, #228]	; (10212fc <z_impl_k_mutex_lock+0x19c>)
 1021218:	f003 fcdd 	bl	1024bd6 <assert_print>
 102121c:	21c2      	movs	r1, #194	; 0xc2
 102121e:	e7cb      	b.n	10211b8 <z_impl_k_mutex_lock+0x58>
					_current->base.prio :
 1021220:	6921      	ldr	r1, [r4, #16]
 1021222:	e7e8      	b.n	10211f6 <z_impl_k_mutex_lock+0x96>
 1021224:	f388 8811 	msr	BASEPRI, r8
 1021228:	f3bf 8f6f 	isb	sy
		return 0;
 102122c:	2000      	movs	r0, #0
 102122e:	e7dc      	b.n	10211ea <z_impl_k_mutex_lock+0x8a>
	new_prio = new_prio_for_inheritance(_current->base.prio,
 1021230:	f991 100e 	ldrsb.w	r1, [r1, #14]
 1021234:	f990 300e 	ldrsb.w	r3, [r0, #14]
	return prio >= CONFIG_PRIORITY_CEILING;
}

static inline int z_get_new_prio_with_ceiling(int prio)
{
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
 1021238:	f06f 027e 	mvn.w	r2, #126	; 0x7e
 102123c:	4299      	cmp	r1, r3
 102123e:	bfa8      	it	ge
 1021240:	4619      	movge	r1, r3
 1021242:	4291      	cmp	r1, r2
 1021244:	bfb8      	it	lt
 1021246:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
 1021248:	428b      	cmp	r3, r1
 102124a:	dd02      	ble.n	1021252 <z_impl_k_mutex_lock+0xf2>
		resched = adjust_owner_prio(mutex, new_prio);
 102124c:	f008 f826 	bl	102929c <adjust_owner_prio.isra.0>
 1021250:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
 1021252:	4622      	mov	r2, r4
 1021254:	4641      	mov	r1, r8
 1021256:	e9cd 7600 	strd	r7, r6, [sp]
 102125a:	4822      	ldr	r0, [pc, #136]	; (10212e4 <z_impl_k_mutex_lock+0x184>)
 102125c:	f001 fcb2 	bl	1022bc4 <z_pend_curr>
	if (got_mutex == 0) {
 1021260:	2800      	cmp	r0, #0
 1021262:	d0e3      	beq.n	102122c <z_impl_k_mutex_lock+0xcc>
	__asm__ volatile(
 1021264:	f04f 0320 	mov.w	r3, #32
 1021268:	f3ef 8611 	mrs	r6, BASEPRI
 102126c:	f383 8812 	msr	BASEPRI_MAX, r3
 1021270:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1021274:	481b      	ldr	r0, [pc, #108]	; (10212e4 <z_impl_k_mutex_lock+0x184>)
 1021276:	f7ff ff2b 	bl	10210d0 <z_spin_lock_valid>
 102127a:	2800      	cmp	r0, #0
 102127c:	d091      	beq.n	10211a2 <z_impl_k_mutex_lock+0x42>
	z_spin_lock_set_owner(l);
 102127e:	4819      	ldr	r0, [pc, #100]	; (10212e4 <z_impl_k_mutex_lock+0x184>)
 1021280:	f7ff ff42 	bl	1021108 <z_spin_lock_set_owner>
	if (likely(mutex->owner != NULL)) {
 1021284:	68a0      	ldr	r0, [r4, #8]
 1021286:	b1c0      	cbz	r0, 10212ba <z_impl_k_mutex_lock+0x15a>
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
 1021288:	6823      	ldr	r3, [r4, #0]
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
 102128a:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
 102128c:	429c      	cmp	r4, r3
 102128e:	d00a      	beq.n	10212a6 <z_impl_k_mutex_lock+0x146>
 1021290:	b14b      	cbz	r3, 10212a6 <z_impl_k_mutex_lock+0x146>
 1021292:	f993 300e 	ldrsb.w	r3, [r3, #14]
 1021296:	4299      	cmp	r1, r3
 1021298:	bfa8      	it	ge
 102129a:	4619      	movge	r1, r3
 102129c:	f06f 037e 	mvn.w	r3, #126	; 0x7e
 10212a0:	4299      	cmp	r1, r3
 10212a2:	bfb8      	it	lt
 10212a4:	4619      	movlt	r1, r3
		resched = adjust_owner_prio(mutex, new_prio) || resched;
 10212a6:	f007 fff9 	bl	102929c <adjust_owner_prio.isra.0>
 10212aa:	b130      	cbz	r0, 10212ba <z_impl_k_mutex_lock+0x15a>
		z_reschedule(&lock, key);
 10212ac:	4631      	mov	r1, r6
 10212ae:	480d      	ldr	r0, [pc, #52]	; (10212e4 <z_impl_k_mutex_lock+0x184>)
 10212b0:	f001 f9ba 	bl	1022628 <z_reschedule>
	return -EAGAIN;
 10212b4:	f06f 000a 	mvn.w	r0, #10
 10212b8:	e797      	b.n	10211ea <z_impl_k_mutex_lock+0x8a>
	if (resched) {
 10212ba:	2d00      	cmp	r5, #0
 10212bc:	d1f6      	bne.n	10212ac <z_impl_k_mutex_lock+0x14c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10212be:	4809      	ldr	r0, [pc, #36]	; (10212e4 <z_impl_k_mutex_lock+0x184>)
 10212c0:	f7ff ff14 	bl	10210ec <z_spin_unlock_valid>
 10212c4:	2800      	cmp	r0, #0
 10212c6:	d09f      	beq.n	1021208 <z_impl_k_mutex_lock+0xa8>
	__asm__ volatile(
 10212c8:	f386 8811 	msr	BASEPRI, r6
 10212cc:	f3bf 8f6f 	isb	sy
 10212d0:	e7f0      	b.n	10212b4 <z_impl_k_mutex_lock+0x154>
 10212d2:	bf00      	nop
 10212d4:	0102f8a2 	.word	0x0102f8a2
 10212d8:	0102f94f 	.word	0x0102f94f
 10212dc:	0102b695 	.word	0x0102b695
 10212e0:	0102f971 	.word	0x0102f971
 10212e4:	210080f0 	.word	0x210080f0
 10212e8:	0102bd8a 	.word	0x0102bd8a
 10212ec:	0102bde3 	.word	0x0102bde3
 10212f0:	0102bdf8 	.word	0x0102bdf8
 10212f4:	210080cc 	.word	0x210080cc
 10212f8:	0102bdb7 	.word	0x0102bdb7
 10212fc:	0102bdce 	.word	0x0102bdce

01021300 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
 1021300:	b570      	push	{r4, r5, r6, lr}
 1021302:	4604      	mov	r4, r0
 1021304:	f3ef 8605 	mrs	r6, IPSR
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
 1021308:	b166      	cbz	r6, 1021324 <z_impl_k_mutex_unlock+0x24>
 102130a:	4938      	ldr	r1, [pc, #224]	; (10213ec <z_impl_k_mutex_unlock+0xec>)
 102130c:	23cd      	movs	r3, #205	; 0xcd
 102130e:	4a38      	ldr	r2, [pc, #224]	; (10213f0 <z_impl_k_mutex_unlock+0xf0>)
 1021310:	4838      	ldr	r0, [pc, #224]	; (10213f4 <z_impl_k_mutex_unlock+0xf4>)
 1021312:	f003 fc60 	bl	1024bd6 <assert_print>
 1021316:	4838      	ldr	r0, [pc, #224]	; (10213f8 <z_impl_k_mutex_unlock+0xf8>)
 1021318:	f003 fc5d 	bl	1024bd6 <assert_print>
 102131c:	21cd      	movs	r1, #205	; 0xcd
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
 102131e:	4834      	ldr	r0, [pc, #208]	; (10213f0 <z_impl_k_mutex_unlock+0xf0>)
 1021320:	f003 fc52 	bl	1024bc8 <assert_post_action>
	CHECKIF(mutex->owner == NULL) {
 1021324:	6883      	ldr	r3, [r0, #8]
 1021326:	2b00      	cmp	r3, #0
 1021328:	d059      	beq.n	10213de <z_impl_k_mutex_unlock+0xde>
	CHECKIF(mutex->owner != _current) {
 102132a:	4a34      	ldr	r2, [pc, #208]	; (10213fc <z_impl_k_mutex_unlock+0xfc>)
 102132c:	6892      	ldr	r2, [r2, #8]
 102132e:	4293      	cmp	r3, r2
 1021330:	d158      	bne.n	10213e4 <z_impl_k_mutex_unlock+0xe4>
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
 1021332:	68c3      	ldr	r3, [r0, #12]
 1021334:	b93b      	cbnz	r3, 1021346 <z_impl_k_mutex_unlock+0x46>
 1021336:	4932      	ldr	r1, [pc, #200]	; (1021400 <z_impl_k_mutex_unlock+0x100>)
 1021338:	23e5      	movs	r3, #229	; 0xe5
 102133a:	4a2d      	ldr	r2, [pc, #180]	; (10213f0 <z_impl_k_mutex_unlock+0xf0>)
 102133c:	482d      	ldr	r0, [pc, #180]	; (10213f4 <z_impl_k_mutex_unlock+0xf4>)
 102133e:	f003 fc4a 	bl	1024bd6 <assert_print>
 1021342:	21e5      	movs	r1, #229	; 0xe5
 1021344:	e7eb      	b.n	102131e <z_impl_k_mutex_unlock+0x1e>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
 1021346:	2b01      	cmp	r3, #1
 1021348:	d003      	beq.n	1021352 <z_impl_k_mutex_unlock+0x52>
		mutex->lock_count--;
 102134a:	3b01      	subs	r3, #1
 102134c:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
 102134e:	2000      	movs	r0, #0
}
 1021350:	bd70      	pop	{r4, r5, r6, pc}
	__asm__ volatile(
 1021352:	f04f 0320 	mov.w	r3, #32
 1021356:	f3ef 8511 	mrs	r5, BASEPRI
 102135a:	f383 8812 	msr	BASEPRI_MAX, r3
 102135e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1021362:	4828      	ldr	r0, [pc, #160]	; (1021404 <z_impl_k_mutex_unlock+0x104>)
 1021364:	f7ff feb4 	bl	10210d0 <z_spin_lock_valid>
 1021368:	b960      	cbnz	r0, 1021384 <z_impl_k_mutex_unlock+0x84>
 102136a:	2394      	movs	r3, #148	; 0x94
 102136c:	4a26      	ldr	r2, [pc, #152]	; (1021408 <z_impl_k_mutex_unlock+0x108>)
 102136e:	4927      	ldr	r1, [pc, #156]	; (102140c <z_impl_k_mutex_unlock+0x10c>)
 1021370:	4820      	ldr	r0, [pc, #128]	; (10213f4 <z_impl_k_mutex_unlock+0xf4>)
 1021372:	f003 fc30 	bl	1024bd6 <assert_print>
 1021376:	4923      	ldr	r1, [pc, #140]	; (1021404 <z_impl_k_mutex_unlock+0x104>)
 1021378:	4825      	ldr	r0, [pc, #148]	; (1021410 <z_impl_k_mutex_unlock+0x110>)
 102137a:	f003 fc2c 	bl	1024bd6 <assert_print>
 102137e:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1021380:	4821      	ldr	r0, [pc, #132]	; (1021408 <z_impl_k_mutex_unlock+0x108>)
 1021382:	e7cd      	b.n	1021320 <z_impl_k_mutex_unlock+0x20>
	z_spin_lock_set_owner(l);
 1021384:	481f      	ldr	r0, [pc, #124]	; (1021404 <z_impl_k_mutex_unlock+0x104>)
 1021386:	f7ff febf 	bl	1021108 <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
 102138a:	6921      	ldr	r1, [r4, #16]
 102138c:	68a0      	ldr	r0, [r4, #8]
 102138e:	f007 ff85 	bl	102929c <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
 1021392:	4620      	mov	r0, r4
 1021394:	f001 fe94 	bl	10230c0 <z_unpend_first_thread>
	mutex->owner = new_owner;
 1021398:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
 102139a:	b150      	cbz	r0, 10213b2 <z_impl_k_mutex_unlock+0xb2>
		mutex->owner_orig_prio = new_owner->base.prio;
 102139c:	f990 200e 	ldrsb.w	r2, [r0, #14]
 10213a0:	6122      	str	r2, [r4, #16]
 10213a2:	67c6      	str	r6, [r0, #124]	; 0x7c
		z_ready_thread(new_owner);
 10213a4:	f001 f8b4 	bl	1022510 <z_ready_thread>
		z_reschedule(&lock, key);
 10213a8:	4629      	mov	r1, r5
 10213aa:	4816      	ldr	r0, [pc, #88]	; (1021404 <z_impl_k_mutex_unlock+0x104>)
 10213ac:	f001 f93c 	bl	1022628 <z_reschedule>
 10213b0:	e7cd      	b.n	102134e <z_impl_k_mutex_unlock+0x4e>
		mutex->lock_count = 0U;
 10213b2:	60e0      	str	r0, [r4, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10213b4:	4813      	ldr	r0, [pc, #76]	; (1021404 <z_impl_k_mutex_unlock+0x104>)
 10213b6:	f7ff fe99 	bl	10210ec <z_spin_unlock_valid>
 10213ba:	b958      	cbnz	r0, 10213d4 <z_impl_k_mutex_unlock+0xd4>
 10213bc:	23c2      	movs	r3, #194	; 0xc2
 10213be:	4a12      	ldr	r2, [pc, #72]	; (1021408 <z_impl_k_mutex_unlock+0x108>)
 10213c0:	4914      	ldr	r1, [pc, #80]	; (1021414 <z_impl_k_mutex_unlock+0x114>)
 10213c2:	480c      	ldr	r0, [pc, #48]	; (10213f4 <z_impl_k_mutex_unlock+0xf4>)
 10213c4:	f003 fc07 	bl	1024bd6 <assert_print>
 10213c8:	490e      	ldr	r1, [pc, #56]	; (1021404 <z_impl_k_mutex_unlock+0x104>)
 10213ca:	4813      	ldr	r0, [pc, #76]	; (1021418 <z_impl_k_mutex_unlock+0x118>)
 10213cc:	f003 fc03 	bl	1024bd6 <assert_print>
 10213d0:	21c2      	movs	r1, #194	; 0xc2
 10213d2:	e7d5      	b.n	1021380 <z_impl_k_mutex_unlock+0x80>
	__asm__ volatile(
 10213d4:	f385 8811 	msr	BASEPRI, r5
 10213d8:	f3bf 8f6f 	isb	sy
 10213dc:	e7b7      	b.n	102134e <z_impl_k_mutex_unlock+0x4e>
		return -EINVAL;
 10213de:	f06f 0015 	mvn.w	r0, #21
 10213e2:	e7b5      	b.n	1021350 <z_impl_k_mutex_unlock+0x50>
		return -EPERM;
 10213e4:	f04f 30ff 	mov.w	r0, #4294967295
 10213e8:	e7b2      	b.n	1021350 <z_impl_k_mutex_unlock+0x50>
 10213ea:	bf00      	nop
 10213ec:	0102f8a2 	.word	0x0102f8a2
 10213f0:	0102f94f 	.word	0x0102f94f
 10213f4:	0102b695 	.word	0x0102b695
 10213f8:	0102f971 	.word	0x0102f971
 10213fc:	210080cc 	.word	0x210080cc
 1021400:	0102f996 	.word	0x0102f996
 1021404:	210080f0 	.word	0x210080f0
 1021408:	0102bd8a 	.word	0x0102bd8a
 102140c:	0102bde3 	.word	0x0102bde3
 1021410:	0102bdf8 	.word	0x0102bdf8
 1021414:	0102bdb7 	.word	0x0102bdb7
 1021418:	0102bdce 	.word	0x0102bdce

0102141c <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
 102141c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1021420:	4604      	mov	r4, r0
 1021422:	460e      	mov	r6, r1
 1021424:	4690      	mov	r8, r2
 1021426:	4699      	mov	r9, r3
 1021428:	f89d a020 	ldrb.w	sl, [sp, #32]
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 102142c:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
 1021430:	f04f 0320 	mov.w	r3, #32
 1021434:	f3ef 8711 	mrs	r7, BASEPRI
 1021438:	f383 8812 	msr	BASEPRI_MAX, r3
 102143c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1021440:	4628      	mov	r0, r5
 1021442:	f7ff fe45 	bl	10210d0 <z_spin_lock_valid>
 1021446:	b968      	cbnz	r0, 1021464 <queue_insert+0x48>
 1021448:	2394      	movs	r3, #148	; 0x94
 102144a:	4a3b      	ldr	r2, [pc, #236]	; (1021538 <queue_insert+0x11c>)
 102144c:	493b      	ldr	r1, [pc, #236]	; (102153c <queue_insert+0x120>)
 102144e:	483c      	ldr	r0, [pc, #240]	; (1021540 <queue_insert+0x124>)
 1021450:	f003 fbc1 	bl	1024bd6 <assert_print>
 1021454:	4629      	mov	r1, r5
 1021456:	483b      	ldr	r0, [pc, #236]	; (1021544 <queue_insert+0x128>)
 1021458:	f003 fbbd 	bl	1024bd6 <assert_print>
 102145c:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 102145e:	4836      	ldr	r0, [pc, #216]	; (1021538 <queue_insert+0x11c>)
 1021460:	f003 fbb2 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1021464:	4628      	mov	r0, r5
 1021466:	f7ff fe4f 	bl	1021108 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
 102146a:	f1ba 0f00 	cmp.w	sl, #0
 102146e:	d000      	beq.n	1021472 <queue_insert+0x56>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
 1021470:	6866      	ldr	r6, [r4, #4]
		prev = sys_sflist_peek_tail(&queue->data_q);
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
 1021472:	f104 000c 	add.w	r0, r4, #12
 1021476:	f001 fe23 	bl	10230c0 <z_unpend_first_thread>

	if (first_pending_thread != NULL) {
 102147a:	b158      	cbz	r0, 1021494 <queue_insert+0x78>
 102147c:	2300      	movs	r3, #0
 102147e:	f8c0 8014 	str.w	r8, [r0, #20]
 1021482:	67c3      	str	r3, [r0, #124]	; 0x7c
	z_ready_thread(thread);
 1021484:	f001 f844 	bl	1022510 <z_ready_thread>

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
 1021488:	4628      	mov	r0, r5
 102148a:	4639      	mov	r1, r7
 102148c:	f001 f8cc 	bl	1022628 <z_reschedule>
		return 0;
 1021490:	2000      	movs	r0, #0
 1021492:	e01c      	b.n	10214ce <queue_insert+0xb2>
	if (alloc) {
 1021494:	f1b9 0f00 	cmp.w	r9, #0
 1021498:	d02b      	beq.n	10214f2 <queue_insert+0xd6>
	return z_thread_aligned_alloc(0, size);
 102149a:	2108      	movs	r1, #8
 102149c:	f003 f814 	bl	10244c8 <z_thread_aligned_alloc>
		if (anode == NULL) {
 10214a0:	b9b8      	cbnz	r0, 10214d2 <queue_insert+0xb6>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10214a2:	4628      	mov	r0, r5
 10214a4:	f7ff fe22 	bl	10210ec <z_spin_unlock_valid>
 10214a8:	b958      	cbnz	r0, 10214c2 <queue_insert+0xa6>
 10214aa:	23c2      	movs	r3, #194	; 0xc2
 10214ac:	4a22      	ldr	r2, [pc, #136]	; (1021538 <queue_insert+0x11c>)
 10214ae:	4926      	ldr	r1, [pc, #152]	; (1021548 <queue_insert+0x12c>)
 10214b0:	4823      	ldr	r0, [pc, #140]	; (1021540 <queue_insert+0x124>)
 10214b2:	f003 fb90 	bl	1024bd6 <assert_print>
 10214b6:	4629      	mov	r1, r5
 10214b8:	4824      	ldr	r0, [pc, #144]	; (102154c <queue_insert+0x130>)
 10214ba:	f003 fb8c 	bl	1024bd6 <assert_print>
 10214be:	21c2      	movs	r1, #194	; 0xc2
 10214c0:	e7cd      	b.n	102145e <queue_insert+0x42>
	__asm__ volatile(
 10214c2:	f387 8811 	msr	BASEPRI, r7
 10214c6:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
 10214ca:	f06f 000b 	mvn.w	r0, #11

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
}
 10214ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
 10214d2:	2201      	movs	r2, #1
		anode->data = data;
 10214d4:	f8c0 8004 	str.w	r8, [r0, #4]
 10214d8:	6002      	str	r2, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 10214da:	6801      	ldr	r1, [r0, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
 10214dc:	f001 0103 	and.w	r1, r1, #3
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
 10214e0:	b95e      	cbnz	r6, 10214fa <queue_insert+0xde>
	parent->next_and_flags = cur_flags | (unative_t)child;
 10214e2:	6822      	ldr	r2, [r4, #0]
 10214e4:	430a      	orrs	r2, r1
 10214e6:	6002      	str	r2, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
 10214e8:	6862      	ldr	r2, [r4, #4]
	list->head = node;
 10214ea:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
 10214ec:	b96a      	cbnz	r2, 102150a <queue_insert+0xee>
	list->tail = node;
 10214ee:	6060      	str	r0, [r4, #4]
}
 10214f0:	e00b      	b.n	102150a <queue_insert+0xee>
}
 10214f2:	4640      	mov	r0, r8
	node->next_and_flags = flags;
 10214f4:	f8c8 9000 	str.w	r9, [r8]
}
 10214f8:	e7ef      	b.n	10214da <queue_insert+0xbe>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 10214fa:	6832      	ldr	r2, [r6, #0]
Z_GENLIST_INSERT(sflist, sfnode)
 10214fc:	2a03      	cmp	r2, #3
 10214fe:	d810      	bhi.n	1021522 <queue_insert+0x106>
	parent->next_and_flags = cur_flags | (unative_t)child;
 1021500:	6001      	str	r1, [r0, #0]
	return list->tail;
 1021502:	6861      	ldr	r1, [r4, #4]
Z_GENLIST_APPEND(sflist, sfnode)
 1021504:	b939      	cbnz	r1, 1021516 <queue_insert+0xfa>
	list->head = node;
 1021506:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
 102150a:	2104      	movs	r1, #4
 102150c:	f104 0014 	add.w	r0, r4, #20
 1021510:	f008 f886 	bl	1029620 <z_handle_obj_poll_events>
 1021514:	e7b8      	b.n	1021488 <queue_insert+0x6c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 1021516:	680a      	ldr	r2, [r1, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
 1021518:	f002 0203 	and.w	r2, r2, #3
 102151c:	4302      	orrs	r2, r0
 102151e:	600a      	str	r2, [r1, #0]
 1021520:	e7e5      	b.n	10214ee <queue_insert+0xd2>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 1021522:	f022 0203 	bic.w	r2, r2, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
 1021526:	430a      	orrs	r2, r1
 1021528:	6002      	str	r2, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 102152a:	6832      	ldr	r2, [r6, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
 102152c:	f002 0203 	and.w	r2, r2, #3
 1021530:	ea40 0302 	orr.w	r3, r0, r2
 1021534:	6033      	str	r3, [r6, #0]
}
 1021536:	e7e8      	b.n	102150a <queue_insert+0xee>
 1021538:	0102bd8a 	.word	0x0102bd8a
 102153c:	0102bde3 	.word	0x0102bde3
 1021540:	0102b695 	.word	0x0102b695
 1021544:	0102bdf8 	.word	0x0102bdf8
 1021548:	0102bdb7 	.word	0x0102bdb7
 102154c:	0102bdce 	.word	0x0102bdce

01021550 <z_impl_k_queue_cancel_wait>:
{
 1021550:	b570      	push	{r4, r5, r6, lr}
 1021552:	4604      	mov	r4, r0
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 1021554:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
 1021558:	f04f 0320 	mov.w	r3, #32
 102155c:	f3ef 8611 	mrs	r6, BASEPRI
 1021560:	f383 8812 	msr	BASEPRI_MAX, r3
 1021564:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1021568:	4628      	mov	r0, r5
 102156a:	f7ff fdb1 	bl	10210d0 <z_spin_lock_valid>
 102156e:	b968      	cbnz	r0, 102158c <z_impl_k_queue_cancel_wait+0x3c>
 1021570:	2394      	movs	r3, #148	; 0x94
 1021572:	4a12      	ldr	r2, [pc, #72]	; (10215bc <z_impl_k_queue_cancel_wait+0x6c>)
 1021574:	4912      	ldr	r1, [pc, #72]	; (10215c0 <z_impl_k_queue_cancel_wait+0x70>)
 1021576:	4813      	ldr	r0, [pc, #76]	; (10215c4 <z_impl_k_queue_cancel_wait+0x74>)
 1021578:	f003 fb2d 	bl	1024bd6 <assert_print>
 102157c:	4629      	mov	r1, r5
 102157e:	4812      	ldr	r0, [pc, #72]	; (10215c8 <z_impl_k_queue_cancel_wait+0x78>)
 1021580:	f003 fb29 	bl	1024bd6 <assert_print>
 1021584:	2194      	movs	r1, #148	; 0x94
 1021586:	480d      	ldr	r0, [pc, #52]	; (10215bc <z_impl_k_queue_cancel_wait+0x6c>)
 1021588:	f003 fb1e 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 102158c:	4628      	mov	r0, r5
 102158e:	f7ff fdbb 	bl	1021108 <z_spin_lock_set_owner>
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
 1021592:	f104 000c 	add.w	r0, r4, #12
 1021596:	f001 fd93 	bl	10230c0 <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
 102159a:	b120      	cbz	r0, 10215a6 <z_impl_k_queue_cancel_wait+0x56>
 102159c:	2200      	movs	r2, #0
 102159e:	67c2      	str	r2, [r0, #124]	; 0x7c
	thread->base.swap_data = data;
 10215a0:	6142      	str	r2, [r0, #20]
	z_ready_thread(thread);
 10215a2:	f000 ffb5 	bl	1022510 <z_ready_thread>
	z_handle_obj_poll_events(&queue->poll_events, state);
 10215a6:	f104 0014 	add.w	r0, r4, #20
 10215aa:	2108      	movs	r1, #8
 10215ac:	f008 f838 	bl	1029620 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
 10215b0:	4631      	mov	r1, r6
 10215b2:	4628      	mov	r0, r5
}
 10215b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&queue->lock, key);
 10215b8:	f001 b836 	b.w	1022628 <z_reschedule>
 10215bc:	0102bd8a 	.word	0x0102bd8a
 10215c0:	0102bde3 	.word	0x0102bde3
 10215c4:	0102b695 	.word	0x0102b695
 10215c8:	0102bdf8 	.word	0x0102bdf8

010215cc <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
 10215cc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 10215d0:	4606      	mov	r6, r0
 10215d2:	4691      	mov	r9, r2
 10215d4:	461f      	mov	r7, r3
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 10215d6:	f100 0508 	add.w	r5, r0, #8
 10215da:	f04f 0320 	mov.w	r3, #32
 10215de:	f3ef 8811 	mrs	r8, BASEPRI
 10215e2:	f383 8812 	msr	BASEPRI_MAX, r3
 10215e6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10215ea:	4628      	mov	r0, r5
 10215ec:	f7ff fd70 	bl	10210d0 <z_spin_lock_valid>
 10215f0:	b968      	cbnz	r0, 102160e <z_impl_k_queue_get+0x42>
 10215f2:	2394      	movs	r3, #148	; 0x94
 10215f4:	4a23      	ldr	r2, [pc, #140]	; (1021684 <z_impl_k_queue_get+0xb8>)
 10215f6:	4924      	ldr	r1, [pc, #144]	; (1021688 <z_impl_k_queue_get+0xbc>)
 10215f8:	4824      	ldr	r0, [pc, #144]	; (102168c <z_impl_k_queue_get+0xc0>)
 10215fa:	f003 faec 	bl	1024bd6 <assert_print>
 10215fe:	4629      	mov	r1, r5
 1021600:	4823      	ldr	r0, [pc, #140]	; (1021690 <z_impl_k_queue_get+0xc4>)
 1021602:	f003 fae8 	bl	1024bd6 <assert_print>
 1021606:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1021608:	481e      	ldr	r0, [pc, #120]	; (1021684 <z_impl_k_queue_get+0xb8>)
 102160a:	f003 fadd 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 102160e:	4628      	mov	r0, r5
 1021610:	f7ff fd7a 	bl	1021108 <z_spin_lock_set_owner>
	return list->head;
 1021614:	6834      	ldr	r4, [r6, #0]
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
 1021616:	b1ec      	cbz	r4, 1021654 <z_impl_k_queue_get+0x88>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 1021618:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
 102161a:	6872      	ldr	r2, [r6, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 102161c:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
 1021620:	4294      	cmp	r4, r2
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
 1021622:	4620      	mov	r0, r4
 1021624:	f04f 0101 	mov.w	r1, #1
	list->head = node;
 1021628:	6033      	str	r3, [r6, #0]
	list->tail = node;
 102162a:	bf08      	it	eq
 102162c:	6073      	streq	r3, [r6, #4]
 102162e:	f007 fe44 	bl	10292ba <z_queue_node_peek>
 1021632:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1021634:	4628      	mov	r0, r5
 1021636:	f7ff fd59 	bl	10210ec <z_spin_unlock_valid>
 102163a:	b9d8      	cbnz	r0, 1021674 <z_impl_k_queue_get+0xa8>
 102163c:	23c2      	movs	r3, #194	; 0xc2
 102163e:	4a11      	ldr	r2, [pc, #68]	; (1021684 <z_impl_k_queue_get+0xb8>)
 1021640:	4914      	ldr	r1, [pc, #80]	; (1021694 <z_impl_k_queue_get+0xc8>)
 1021642:	4812      	ldr	r0, [pc, #72]	; (102168c <z_impl_k_queue_get+0xc0>)
 1021644:	f003 fac7 	bl	1024bd6 <assert_print>
 1021648:	4629      	mov	r1, r5
 102164a:	4813      	ldr	r0, [pc, #76]	; (1021698 <z_impl_k_queue_get+0xcc>)
 102164c:	f003 fac3 	bl	1024bd6 <assert_print>
 1021650:	21c2      	movs	r1, #194	; 0xc2
 1021652:	e7d9      	b.n	1021608 <z_impl_k_queue_get+0x3c>
		return data;
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, get, queue, timeout);

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 1021654:	ea59 0307 	orrs.w	r3, r9, r7
 1021658:	d0ec      	beq.n	1021634 <z_impl_k_queue_get+0x68>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, NULL);

		return NULL;
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
 102165a:	4641      	mov	r1, r8
 102165c:	4628      	mov	r0, r5
 102165e:	e9cd 9700 	strd	r9, r7, [sp]
 1021662:	f106 020c 	add.w	r2, r6, #12
 1021666:	f001 faad 	bl	1022bc4 <z_pend_curr>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
 102166a:	b938      	cbnz	r0, 102167c <z_impl_k_queue_get+0xb0>
 102166c:	4b0b      	ldr	r3, [pc, #44]	; (102169c <z_impl_k_queue_get+0xd0>)
 102166e:	689b      	ldr	r3, [r3, #8]
 1021670:	695c      	ldr	r4, [r3, #20]
 1021672:	e003      	b.n	102167c <z_impl_k_queue_get+0xb0>
	__asm__ volatile(
 1021674:	f388 8811 	msr	BASEPRI, r8
 1021678:	f3bf 8f6f 	isb	sy
}
 102167c:	4620      	mov	r0, r4
 102167e:	b003      	add	sp, #12
 1021680:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1021684:	0102bd8a 	.word	0x0102bd8a
 1021688:	0102bde3 	.word	0x0102bde3
 102168c:	0102b695 	.word	0x0102b695
 1021690:	0102bdf8 	.word	0x0102bdf8
 1021694:	0102bdb7 	.word	0x0102bdb7
 1021698:	0102bdce 	.word	0x0102bdce
 102169c:	210080cc 	.word	0x210080cc

010216a0 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
 10216a0:	b538      	push	{r3, r4, r5, lr}
 10216a2:	4604      	mov	r4, r0
	__asm__ volatile(
 10216a4:	f04f 0320 	mov.w	r3, #32
 10216a8:	f3ef 8511 	mrs	r5, BASEPRI
 10216ac:	f383 8812 	msr	BASEPRI_MAX, r3
 10216b0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10216b4:	4817      	ldr	r0, [pc, #92]	; (1021714 <z_impl_k_sem_give+0x74>)
 10216b6:	f7ff fd0b 	bl	10210d0 <z_spin_lock_valid>
 10216ba:	b968      	cbnz	r0, 10216d8 <z_impl_k_sem_give+0x38>
 10216bc:	2394      	movs	r3, #148	; 0x94
 10216be:	4a16      	ldr	r2, [pc, #88]	; (1021718 <z_impl_k_sem_give+0x78>)
 10216c0:	4916      	ldr	r1, [pc, #88]	; (102171c <z_impl_k_sem_give+0x7c>)
 10216c2:	4817      	ldr	r0, [pc, #92]	; (1021720 <z_impl_k_sem_give+0x80>)
 10216c4:	f003 fa87 	bl	1024bd6 <assert_print>
 10216c8:	4912      	ldr	r1, [pc, #72]	; (1021714 <z_impl_k_sem_give+0x74>)
 10216ca:	4816      	ldr	r0, [pc, #88]	; (1021724 <z_impl_k_sem_give+0x84>)
 10216cc:	f003 fa83 	bl	1024bd6 <assert_print>
 10216d0:	2194      	movs	r1, #148	; 0x94
 10216d2:	4811      	ldr	r0, [pc, #68]	; (1021718 <z_impl_k_sem_give+0x78>)
 10216d4:	f003 fa78 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 10216d8:	480e      	ldr	r0, [pc, #56]	; (1021714 <z_impl_k_sem_give+0x74>)
 10216da:	f7ff fd15 	bl	1021108 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
 10216de:	4620      	mov	r0, r4
 10216e0:	f001 fcee 	bl	10230c0 <z_unpend_first_thread>

	if (thread != NULL) {
 10216e4:	b148      	cbz	r0, 10216fa <z_impl_k_sem_give+0x5a>
 10216e6:	2200      	movs	r2, #0
 10216e8:	67c2      	str	r2, [r0, #124]	; 0x7c
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
 10216ea:	f000 ff11 	bl	1022510 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
 10216ee:	4629      	mov	r1, r5

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
 10216f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
 10216f4:	4807      	ldr	r0, [pc, #28]	; (1021714 <z_impl_k_sem_give+0x74>)
 10216f6:	f000 bf97 	b.w	1022628 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 10216fa:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 10216fe:	429a      	cmp	r2, r3
 1021700:	bf18      	it	ne
 1021702:	3301      	addne	r3, #1
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
 1021704:	2102      	movs	r1, #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 1021706:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
 1021708:	f104 0010 	add.w	r0, r4, #16
 102170c:	f007 ff88 	bl	1029620 <z_handle_obj_poll_events>
}
 1021710:	e7ed      	b.n	10216ee <z_impl_k_sem_give+0x4e>
 1021712:	bf00      	nop
 1021714:	210080f4 	.word	0x210080f4
 1021718:	0102bd8a 	.word	0x0102bd8a
 102171c:	0102bde3 	.word	0x0102bde3
 1021720:	0102b695 	.word	0x0102b695
 1021724:	0102bdf8 	.word	0x0102bdf8

01021728 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
 1021728:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 102172a:	4604      	mov	r4, r0
 102172c:	4616      	mov	r6, r2
 102172e:	461d      	mov	r5, r3
 1021730:	f3ef 8305 	mrs	r3, IPSR
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) ||
 1021734:	b17b      	cbz	r3, 1021756 <z_impl_k_sem_take+0x2e>
 1021736:	ea52 0305 	orrs.w	r3, r2, r5
 102173a:	d00c      	beq.n	1021756 <z_impl_k_sem_take+0x2e>
 102173c:	492d      	ldr	r1, [pc, #180]	; (10217f4 <z_impl_k_sem_take+0xcc>)
 102173e:	2379      	movs	r3, #121	; 0x79
 1021740:	4a2d      	ldr	r2, [pc, #180]	; (10217f8 <z_impl_k_sem_take+0xd0>)
 1021742:	482e      	ldr	r0, [pc, #184]	; (10217fc <z_impl_k_sem_take+0xd4>)
 1021744:	f003 fa47 	bl	1024bd6 <assert_print>
 1021748:	482d      	ldr	r0, [pc, #180]	; (1021800 <z_impl_k_sem_take+0xd8>)
 102174a:	f003 fa44 	bl	1024bd6 <assert_print>
 102174e:	2179      	movs	r1, #121	; 0x79
 1021750:	4829      	ldr	r0, [pc, #164]	; (10217f8 <z_impl_k_sem_take+0xd0>)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1021752:	f003 fa39 	bl	1024bc8 <assert_post_action>
 1021756:	f04f 0320 	mov.w	r3, #32
 102175a:	f3ef 8711 	mrs	r7, BASEPRI
 102175e:	f383 8812 	msr	BASEPRI_MAX, r3
 1021762:	f3bf 8f6f 	isb	sy
 1021766:	4827      	ldr	r0, [pc, #156]	; (1021804 <z_impl_k_sem_take+0xdc>)
 1021768:	f7ff fcb2 	bl	10210d0 <z_spin_lock_valid>
 102176c:	b960      	cbnz	r0, 1021788 <z_impl_k_sem_take+0x60>
 102176e:	2394      	movs	r3, #148	; 0x94
 1021770:	4a25      	ldr	r2, [pc, #148]	; (1021808 <z_impl_k_sem_take+0xe0>)
 1021772:	4926      	ldr	r1, [pc, #152]	; (102180c <z_impl_k_sem_take+0xe4>)
 1021774:	4821      	ldr	r0, [pc, #132]	; (10217fc <z_impl_k_sem_take+0xd4>)
 1021776:	f003 fa2e 	bl	1024bd6 <assert_print>
 102177a:	4922      	ldr	r1, [pc, #136]	; (1021804 <z_impl_k_sem_take+0xdc>)
 102177c:	4824      	ldr	r0, [pc, #144]	; (1021810 <z_impl_k_sem_take+0xe8>)
 102177e:	f003 fa2a 	bl	1024bd6 <assert_print>
 1021782:	2194      	movs	r1, #148	; 0x94
 1021784:	4820      	ldr	r0, [pc, #128]	; (1021808 <z_impl_k_sem_take+0xe0>)
 1021786:	e7e4      	b.n	1021752 <z_impl_k_sem_take+0x2a>
	z_spin_lock_set_owner(l);
 1021788:	481e      	ldr	r0, [pc, #120]	; (1021804 <z_impl_k_sem_take+0xdc>)
 102178a:	f7ff fcbd 	bl	1021108 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
 102178e:	68a3      	ldr	r3, [r4, #8]
 1021790:	b1c3      	cbz	r3, 10217c4 <z_impl_k_sem_take+0x9c>
		sem->count--;
 1021792:	3b01      	subs	r3, #1
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1021794:	481b      	ldr	r0, [pc, #108]	; (1021804 <z_impl_k_sem_take+0xdc>)
 1021796:	60a3      	str	r3, [r4, #8]
 1021798:	f7ff fca8 	bl	10210ec <z_spin_unlock_valid>
 102179c:	b958      	cbnz	r0, 10217b6 <z_impl_k_sem_take+0x8e>
 102179e:	23c2      	movs	r3, #194	; 0xc2
 10217a0:	4a19      	ldr	r2, [pc, #100]	; (1021808 <z_impl_k_sem_take+0xe0>)
 10217a2:	491c      	ldr	r1, [pc, #112]	; (1021814 <z_impl_k_sem_take+0xec>)
 10217a4:	4815      	ldr	r0, [pc, #84]	; (10217fc <z_impl_k_sem_take+0xd4>)
 10217a6:	f003 fa16 	bl	1024bd6 <assert_print>
 10217aa:	4916      	ldr	r1, [pc, #88]	; (1021804 <z_impl_k_sem_take+0xdc>)
 10217ac:	481a      	ldr	r0, [pc, #104]	; (1021818 <z_impl_k_sem_take+0xf0>)
 10217ae:	f003 fa12 	bl	1024bd6 <assert_print>
 10217b2:	21c2      	movs	r1, #194	; 0xc2
 10217b4:	e7e6      	b.n	1021784 <z_impl_k_sem_take+0x5c>
	__asm__ volatile(
 10217b6:	f387 8811 	msr	BASEPRI, r7
 10217ba:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
 10217be:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
 10217c0:	b003      	add	sp, #12
 10217c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 10217c4:	ea56 0305 	orrs.w	r3, r6, r5
 10217c8:	d10b      	bne.n	10217e2 <z_impl_k_sem_take+0xba>
 10217ca:	480e      	ldr	r0, [pc, #56]	; (1021804 <z_impl_k_sem_take+0xdc>)
 10217cc:	f7ff fc8e 	bl	10210ec <z_spin_unlock_valid>
 10217d0:	2800      	cmp	r0, #0
 10217d2:	d0e4      	beq.n	102179e <z_impl_k_sem_take+0x76>
 10217d4:	f387 8811 	msr	BASEPRI, r7
 10217d8:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
 10217dc:	f06f 000f 	mvn.w	r0, #15
 10217e0:	e7ee      	b.n	10217c0 <z_impl_k_sem_take+0x98>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 10217e2:	4622      	mov	r2, r4
 10217e4:	4639      	mov	r1, r7
 10217e6:	e9cd 6500 	strd	r6, r5, [sp]
 10217ea:	4806      	ldr	r0, [pc, #24]	; (1021804 <z_impl_k_sem_take+0xdc>)
 10217ec:	f001 f9ea 	bl	1022bc4 <z_pend_curr>
	return ret;
 10217f0:	e7e6      	b.n	10217c0 <z_impl_k_sem_take+0x98>
 10217f2:	bf00      	nop
 10217f4:	0102f9cd 	.word	0x0102f9cd
 10217f8:	0102f9ad 	.word	0x0102f9ad
 10217fc:	0102b695 	.word	0x0102b695
 1021800:	0102ee84 	.word	0x0102ee84
 1021804:	210080f4 	.word	0x210080f4
 1021808:	0102bd8a 	.word	0x0102bd8a
 102180c:	0102bde3 	.word	0x0102bde3
 1021810:	0102bdf8 	.word	0x0102bdf8
 1021814:	0102bdb7 	.word	0x0102bdb7
 1021818:	0102bdce 	.word	0x0102bdce

0102181c <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
 102181c:	b570      	push	{r4, r5, r6, lr}
 102181e:	4604      	mov	r4, r0
	__asm__ volatile(
 1021820:	f04f 0320 	mov.w	r3, #32
 1021824:	f3ef 8511 	mrs	r5, BASEPRI
 1021828:	f383 8812 	msr	BASEPRI_MAX, r3
 102182c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1021830:	4815      	ldr	r0, [pc, #84]	; (1021888 <z_impl_k_sem_reset+0x6c>)
 1021832:	f7ff fc4d 	bl	10210d0 <z_spin_lock_valid>
 1021836:	b968      	cbnz	r0, 1021854 <z_impl_k_sem_reset+0x38>
 1021838:	2394      	movs	r3, #148	; 0x94
 102183a:	4a14      	ldr	r2, [pc, #80]	; (102188c <z_impl_k_sem_reset+0x70>)
 102183c:	4914      	ldr	r1, [pc, #80]	; (1021890 <z_impl_k_sem_reset+0x74>)
 102183e:	4815      	ldr	r0, [pc, #84]	; (1021894 <z_impl_k_sem_reset+0x78>)
 1021840:	f003 f9c9 	bl	1024bd6 <assert_print>
 1021844:	4910      	ldr	r1, [pc, #64]	; (1021888 <z_impl_k_sem_reset+0x6c>)
 1021846:	4814      	ldr	r0, [pc, #80]	; (1021898 <z_impl_k_sem_reset+0x7c>)
 1021848:	f003 f9c5 	bl	1024bd6 <assert_print>
 102184c:	2194      	movs	r1, #148	; 0x94
 102184e:	480f      	ldr	r0, [pc, #60]	; (102188c <z_impl_k_sem_reset+0x70>)
 1021850:	f003 f9ba 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1021854:	480c      	ldr	r0, [pc, #48]	; (1021888 <z_impl_k_sem_reset+0x6c>)
 1021856:	f7ff fc57 	bl	1021108 <z_spin_lock_set_owner>
 102185a:	f06f 060a 	mvn.w	r6, #10
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
 102185e:	4620      	mov	r0, r4
 1021860:	f001 fc2e 	bl	10230c0 <z_unpend_first_thread>
		if (thread == NULL) {
 1021864:	b118      	cbz	r0, 102186e <z_impl_k_sem_reset+0x52>
 1021866:	67c6      	str	r6, [r0, #124]	; 0x7c
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
 1021868:	f000 fe52 	bl	1022510 <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
 102186c:	e7f7      	b.n	102185e <z_impl_k_sem_reset+0x42>
	}
	sem->count = 0;
 102186e:	60a0      	str	r0, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
 1021870:	2102      	movs	r1, #2
 1021872:	f104 0010 	add.w	r0, r4, #16
 1021876:	f007 fed3 	bl	1029620 <z_handle_obj_poll_events>

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
 102187a:	4629      	mov	r1, r5
}
 102187c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
 1021880:	4801      	ldr	r0, [pc, #4]	; (1021888 <z_impl_k_sem_reset+0x6c>)
 1021882:	f000 bed1 	b.w	1022628 <z_reschedule>
 1021886:	bf00      	nop
 1021888:	210080f4 	.word	0x210080f4
 102188c:	0102bd8a 	.word	0x0102bd8a
 1021890:	0102bde3 	.word	0x0102bde3
 1021894:	0102b695 	.word	0x0102b695
 1021898:	0102bdf8 	.word	0x0102bdf8

0102189c <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
 102189c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
 102189e:	2400      	movs	r4, #0
 10218a0:	4b08      	ldr	r3, [pc, #32]	; (10218c4 <k_sys_work_q_init+0x28>)
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
 10218a2:	f44f 6280 	mov.w	r2, #1024	; 0x400
	struct k_work_queue_config cfg = {
 10218a6:	9302      	str	r3, [sp, #8]
	k_work_queue_start(&k_sys_work_q,
 10218a8:	ab02      	add	r3, sp, #8
 10218aa:	9300      	str	r3, [sp, #0]
 10218ac:	4906      	ldr	r1, [pc, #24]	; (10218c8 <k_sys_work_q_init+0x2c>)
 10218ae:	f04f 33ff 	mov.w	r3, #4294967295
 10218b2:	4806      	ldr	r0, [pc, #24]	; (10218cc <k_sys_work_q_init+0x30>)
	struct k_work_queue_config cfg = {
 10218b4:	f88d 400c 	strb.w	r4, [sp, #12]
	k_work_queue_start(&k_sys_work_q,
 10218b8:	f000 fac0 	bl	1021e3c <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
 10218bc:	4620      	mov	r0, r4
 10218be:	b004      	add	sp, #16
 10218c0:	bd10      	pop	{r4, pc}
 10218c2:	bf00      	nop
 10218c4:	0102fa1b 	.word	0x0102fa1b
 10218c8:	2100c948 	.word	0x2100c948
 10218cc:	21004510 	.word	0x21004510

010218d0 <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
 10218d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10218d4:	4604      	mov	r4, r0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10218d6:	4e6e      	ldr	r6, [pc, #440]	; (1021a90 <work_queue_main+0x1c0>)
	return list->head;
 10218d8:	4f6e      	ldr	r7, [pc, #440]	; (1021a94 <work_queue_main+0x1c4>)
 10218da:	b085      	sub	sp, #20
 10218dc:	f04f 0320 	mov.w	r3, #32
 10218e0:	f3ef 8811 	mrs	r8, BASEPRI
 10218e4:	f383 8812 	msr	BASEPRI_MAX, r3
 10218e8:	f3bf 8f6f 	isb	sy
 10218ec:	4630      	mov	r0, r6
 10218ee:	f7ff fbef 	bl	10210d0 <z_spin_lock_valid>
 10218f2:	b968      	cbnz	r0, 1021910 <work_queue_main+0x40>
 10218f4:	2394      	movs	r3, #148	; 0x94
 10218f6:	4a68      	ldr	r2, [pc, #416]	; (1021a98 <work_queue_main+0x1c8>)
 10218f8:	4968      	ldr	r1, [pc, #416]	; (1021a9c <work_queue_main+0x1cc>)
 10218fa:	4869      	ldr	r0, [pc, #420]	; (1021aa0 <work_queue_main+0x1d0>)
 10218fc:	f003 f96b 	bl	1024bd6 <assert_print>
 1021900:	4963      	ldr	r1, [pc, #396]	; (1021a90 <work_queue_main+0x1c0>)
 1021902:	4868      	ldr	r0, [pc, #416]	; (1021aa4 <work_queue_main+0x1d4>)
 1021904:	f003 f967 	bl	1024bd6 <assert_print>
 1021908:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 102190a:	4863      	ldr	r0, [pc, #396]	; (1021a98 <work_queue_main+0x1c8>)
 102190c:	f003 f95c 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1021910:	4630      	mov	r0, r6
 1021912:	f7ff fbf9 	bl	1021108 <z_spin_lock_set_owner>
 1021916:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
Z_GENLIST_GET(slist, snode)
 102191a:	b9ad      	cbnz	r5, 1021948 <work_queue_main+0x78>
			 * which should never happen, even line 'if (work != NULL)'
			 * ensures that.
			 * This means that if node is not NULL, then work will not be NULL.
			 */
			handler = work->handler;
		} else if (flag_test_and_clear(&queue->flags,
 102191c:	2102      	movs	r1, #2
 102191e:	f104 0098 	add.w	r0, r4, #152	; 0x98
 1021922:	f007 fd08 	bl	1029336 <flag_test_and_clear>
 1021926:	2800      	cmp	r0, #0
 1021928:	d135      	bne.n	1021996 <work_queue_main+0xc6>
			 * the lock, and we didn't find work nor got asked to
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
 102192a:	2300      	movs	r3, #0
 102192c:	f04f 32ff 	mov.w	r2, #4294967295
 1021930:	9302      	str	r3, [sp, #8]
 1021932:	f04f 33ff 	mov.w	r3, #4294967295
 1021936:	4641      	mov	r1, r8
 1021938:	e9cd 2300 	strd	r2, r3, [sp]
 102193c:	4630      	mov	r0, r6
 102193e:	f104 0288 	add.w	r2, r4, #136	; 0x88
 1021942:	f001 feb3 	bl	10236ac <z_sched_wait>
					   K_FOREVER, NULL);
			continue;
 1021946:	e7c9      	b.n	10218dc <work_queue_main+0xc>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1021948:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
	return node->next;
 102194c:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 102194e:	4295      	cmp	r5, r2
	list->tail = node;
 1021950:	bf08      	it	eq
 1021952:	f8c4 3084 	streq.w	r3, [r4, #132]	; 0x84
	list->head = node;
 1021956:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	*flagp |= BIT(bit);
 102195a:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 102195e:	4630      	mov	r0, r6
 1021960:	f043 0302 	orr.w	r3, r3, #2
 1021964:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	*flagp &= ~BIT(bit);
 1021968:	68eb      	ldr	r3, [r5, #12]
			handler = work->handler;
 102196a:	f8d5 9004 	ldr.w	r9, [r5, #4]
	*flagp &= ~BIT(bit);
 102196e:	f023 0304 	bic.w	r3, r3, #4
 1021972:	f043 0301 	orr.w	r3, r3, #1
 1021976:	60eb      	str	r3, [r5, #12]
 1021978:	f7ff fbb8 	bl	10210ec <z_spin_unlock_valid>
 102197c:	b9a8      	cbnz	r0, 10219aa <work_queue_main+0xda>
 102197e:	23c2      	movs	r3, #194	; 0xc2
 1021980:	4a45      	ldr	r2, [pc, #276]	; (1021a98 <work_queue_main+0x1c8>)
 1021982:	4949      	ldr	r1, [pc, #292]	; (1021aa8 <work_queue_main+0x1d8>)
 1021984:	4846      	ldr	r0, [pc, #280]	; (1021aa0 <work_queue_main+0x1d0>)
 1021986:	f003 f926 	bl	1024bd6 <assert_print>
 102198a:	4941      	ldr	r1, [pc, #260]	; (1021a90 <work_queue_main+0x1c0>)
 102198c:	4847      	ldr	r0, [pc, #284]	; (1021aac <work_queue_main+0x1dc>)
 102198e:	f003 f922 	bl	1024bd6 <assert_print>
 1021992:	21c2      	movs	r1, #194	; 0xc2
 1021994:	e7b9      	b.n	102190a <work_queue_main+0x3a>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
 1021996:	f104 0590 	add.w	r5, r4, #144	; 0x90
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 102199a:	2200      	movs	r2, #0
 102199c:	2101      	movs	r1, #1
 102199e:	4628      	mov	r0, r5
 10219a0:	f001 fe26 	bl	10235f0 <z_sched_wake>
 10219a4:	2800      	cmp	r0, #0
 10219a6:	d1f8      	bne.n	102199a <work_queue_main+0xca>
 10219a8:	e7bf      	b.n	102192a <work_queue_main+0x5a>
	__asm__ volatile(
 10219aa:	f388 8811 	msr	BASEPRI, r8
 10219ae:	f3bf 8f6f 	isb	sy
		}

		k_spin_unlock(&lock, key);

		__ASSERT_NO_MSG(handler != NULL);
 10219b2:	f1b9 0f00 	cmp.w	r9, #0
 10219b6:	d10a      	bne.n	10219ce <work_queue_main+0xfe>
 10219b8:	493d      	ldr	r1, [pc, #244]	; (1021ab0 <work_queue_main+0x1e0>)
 10219ba:	4839      	ldr	r0, [pc, #228]	; (1021aa0 <work_queue_main+0x1d0>)
 10219bc:	f240 239b 	movw	r3, #667	; 0x29b
 10219c0:	4a3c      	ldr	r2, [pc, #240]	; (1021ab4 <work_queue_main+0x1e4>)
 10219c2:	f003 f908 	bl	1024bd6 <assert_print>
 10219c6:	f240 219b 	movw	r1, #667	; 0x29b
 10219ca:	483a      	ldr	r0, [pc, #232]	; (1021ab4 <work_queue_main+0x1e4>)
 10219cc:	e79e      	b.n	102190c <work_queue_main+0x3c>
		handler(work);
 10219ce:	4628      	mov	r0, r5
 10219d0:	47c8      	blx	r9
	__asm__ volatile(
 10219d2:	f04f 0320 	mov.w	r3, #32
 10219d6:	f3ef 8a11 	mrs	sl, BASEPRI
 10219da:	f383 8812 	msr	BASEPRI_MAX, r3
 10219de:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10219e2:	4630      	mov	r0, r6
 10219e4:	f7ff fb74 	bl	10210d0 <z_spin_lock_valid>
 10219e8:	2800      	cmp	r0, #0
 10219ea:	d083      	beq.n	10218f4 <work_queue_main+0x24>
	z_spin_lock_set_owner(l);
 10219ec:	4630      	mov	r0, r6
 10219ee:	f7ff fb8b 	bl	1021108 <z_spin_lock_set_owner>
	*flagp &= ~BIT(bit);
 10219f2:	68eb      	ldr	r3, [r5, #12]
		 * starving other threads.
		 */
		key = k_spin_lock(&lock);

		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 10219f4:	0799      	lsls	r1, r3, #30
	*flagp &= ~BIT(bit);
 10219f6:	f023 0201 	bic.w	r2, r3, #1
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 10219fa:	d417      	bmi.n	1021a2c <work_queue_main+0x15c>
	*flagp &= ~BIT(bit);
 10219fc:	60ea      	str	r2, [r5, #12]
 10219fe:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1021a02:	4630      	mov	r0, r6
 1021a04:	f023 0302 	bic.w	r3, r3, #2
 1021a08:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	return (*flagp & BIT(bit)) != 0U;
 1021a0c:	f3c3 2500 	ubfx	r5, r3, #8, #1
 1021a10:	f7ff fb6c 	bl	10210ec <z_spin_unlock_valid>
 1021a14:	2800      	cmp	r0, #0
 1021a16:	d0b2      	beq.n	102197e <work_queue_main+0xae>
	__asm__ volatile(
 1021a18:	f38a 8811 	msr	BASEPRI, sl
 1021a1c:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		/* Optionally yield to prevent the work queue from
		 * starving other threads.
		 */
		if (yield) {
 1021a20:	2d00      	cmp	r5, #0
 1021a22:	f47f af5b 	bne.w	10218dc <work_queue_main+0xc>
	z_impl_k_yield();
 1021a26:	f001 fba7 	bl	1023178 <z_impl_k_yield>
}
 1021a2a:	e757      	b.n	10218dc <work_queue_main+0xc>
	return list->head;
 1021a2c:	6838      	ldr	r0, [r7, #0]
	*flagp &= ~BIT(bit);
 1021a2e:	f023 0303 	bic.w	r3, r3, #3
 1021a32:	60eb      	str	r3, [r5, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 1021a34:	2800      	cmp	r0, #0
 1021a36:	d0e2      	beq.n	10219fe <work_queue_main+0x12e>
	return node->next;
 1021a38:	f04f 0800 	mov.w	r8, #0
	parent->next = child;
 1021a3c:	46c3      	mov	fp, r8
	return node->next;
 1021a3e:	f8d0 9000 	ldr.w	r9, [r0]
 1021a42:	2800      	cmp	r0, #0
 1021a44:	d0db      	beq.n	10219fe <work_queue_main+0x12e>
		if (wc->work == work) {
 1021a46:	6843      	ldr	r3, [r0, #4]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
 1021a48:	4602      	mov	r2, r0
		if (wc->work == work) {
 1021a4a:	429d      	cmp	r5, r3
 1021a4c:	d10d      	bne.n	1021a6a <work_queue_main+0x19a>
 1021a4e:	6802      	ldr	r2, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
 1021a50:	f1b8 0f00 	cmp.w	r8, #0
 1021a54:	d112      	bne.n	1021a7c <work_queue_main+0x1ac>
 1021a56:	687b      	ldr	r3, [r7, #4]
	list->head = node;
 1021a58:	603a      	str	r2, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
 1021a5a:	4283      	cmp	r3, r0
 1021a5c:	d100      	bne.n	1021a60 <work_queue_main+0x190>
	list->tail = node;
 1021a5e:	607a      	str	r2, [r7, #4]
	parent->next = child;
 1021a60:	f840 bb08 	str.w	fp, [r0], #8
	z_impl_k_sem_give(sem);
 1021a64:	f7ff fe1c 	bl	10216a0 <z_impl_k_sem_give>
}
 1021a68:	4642      	mov	r2, r8
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 1021a6a:	f1b9 0f00 	cmp.w	r9, #0
 1021a6e:	d00d      	beq.n	1021a8c <work_queue_main+0x1bc>
	return node->next;
 1021a70:	f8d9 3000 	ldr.w	r3, [r9]
 1021a74:	4648      	mov	r0, r9
 1021a76:	4690      	mov	r8, r2
 1021a78:	4699      	mov	r9, r3
 1021a7a:	e7e2      	b.n	1021a42 <work_queue_main+0x172>
	parent->next = child;
 1021a7c:	f8c8 2000 	str.w	r2, [r8]
Z_GENLIST_REMOVE(slist, snode)
 1021a80:	687b      	ldr	r3, [r7, #4]
 1021a82:	4283      	cmp	r3, r0
	list->tail = node;
 1021a84:	bf08      	it	eq
 1021a86:	f8c7 8004 	streq.w	r8, [r7, #4]
}
 1021a8a:	e7e9      	b.n	1021a60 <work_queue_main+0x190>
 1021a8c:	464b      	mov	r3, r9
 1021a8e:	e7f1      	b.n	1021a74 <work_queue_main+0x1a4>
 1021a90:	21008100 	.word	0x21008100
 1021a94:	210080f8 	.word	0x210080f8
 1021a98:	0102bd8a 	.word	0x0102bd8a
 1021a9c:	0102bde3 	.word	0x0102bde3
 1021aa0:	0102b695 	.word	0x0102b695
 1021aa4:	0102bdf8 	.word	0x0102bdf8
 1021aa8:	0102bdb7 	.word	0x0102bdb7
 1021aac:	0102bdce 	.word	0x0102bdce
 1021ab0:	0102fa45 	.word	0x0102fa45
 1021ab4:	0102fa24 	.word	0x0102fa24

01021ab8 <cancel_sync_locked>:
{
 1021ab8:	b570      	push	{r4, r5, r6, lr}
	return (*flagp & BIT(bit)) != 0U;
 1021aba:	68c3      	ldr	r3, [r0, #12]
{
 1021abc:	4605      	mov	r5, r0
	return (*flagp & BIT(bit)) != 0U;
 1021abe:	f3c3 0640 	ubfx	r6, r3, #1, #1
	if (ret) {
 1021ac2:	079b      	lsls	r3, r3, #30
{
 1021ac4:	460c      	mov	r4, r1
	if (ret) {
 1021ac6:	d50d      	bpl.n	1021ae4 <cancel_sync_locked+0x2c>
	return z_impl_k_sem_init(sem, initial_count, limit);
 1021ac8:	2201      	movs	r2, #1
 1021aca:	2100      	movs	r1, #0
 1021acc:	f104 0008 	add.w	r0, r4, #8
 1021ad0:	f007 fc21 	bl	1029316 <z_impl_k_sem_init>
	parent->next = child;
 1021ad4:	2300      	movs	r3, #0
 1021ad6:	6023      	str	r3, [r4, #0]
	return list->tail;
 1021ad8:	4b05      	ldr	r3, [pc, #20]	; (1021af0 <cancel_sync_locked+0x38>)
	canceler->work = work;
 1021ada:	6065      	str	r5, [r4, #4]
 1021adc:	685a      	ldr	r2, [r3, #4]
Z_GENLIST_APPEND(slist, snode)
 1021ade:	b91a      	cbnz	r2, 1021ae8 <cancel_sync_locked+0x30>
	list->head = node;
 1021ae0:	e9c3 4400 	strd	r4, r4, [r3]
}
 1021ae4:	4630      	mov	r0, r6
 1021ae6:	bd70      	pop	{r4, r5, r6, pc}
	parent->next = child;
 1021ae8:	6014      	str	r4, [r2, #0]
	list->tail = node;
 1021aea:	605c      	str	r4, [r3, #4]
}
 1021aec:	e7fa      	b.n	1021ae4 <cancel_sync_locked+0x2c>
 1021aee:	bf00      	nop
 1021af0:	210080f8 	.word	0x210080f8

01021af4 <submit_to_queue_locked>:
{
 1021af4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return (*flagp & BIT(bit)) != 0U;
 1021af6:	68c3      	ldr	r3, [r0, #12]
{
 1021af8:	4604      	mov	r4, r0
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 1021afa:	079a      	lsls	r2, r3, #30
{
 1021afc:	460f      	mov	r7, r1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 1021afe:	f3c3 0640 	ubfx	r6, r3, #1, #1
 1021b02:	d439      	bmi.n	1021b78 <submit_to_queue_locked+0x84>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
 1021b04:	075b      	lsls	r3, r3, #29
 1021b06:	d425      	bmi.n	1021b54 <submit_to_queue_locked+0x60>
		if (*queuep == NULL) {
 1021b08:	680b      	ldr	r3, [r1, #0]
 1021b0a:	b90b      	cbnz	r3, 1021b10 <submit_to_queue_locked+0x1c>
			*queuep = work->queue;
 1021b0c:	6883      	ldr	r3, [r0, #8]
 1021b0e:	600b      	str	r3, [r1, #0]
	return (*flagp & BIT(bit)) != 0U;
 1021b10:	68e3      	ldr	r3, [r4, #12]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
 1021b12:	07dd      	lsls	r5, r3, #31
 1021b14:	d521      	bpl.n	1021b5a <submit_to_queue_locked+0x66>
			__ASSERT_NO_MSG(work->queue != NULL);
 1021b16:	68a3      	ldr	r3, [r4, #8]
 1021b18:	b95b      	cbnz	r3, 1021b32 <submit_to_queue_locked+0x3e>
 1021b1a:	4928      	ldr	r1, [pc, #160]	; (1021bbc <submit_to_queue_locked+0xc8>)
 1021b1c:	4828      	ldr	r0, [pc, #160]	; (1021bc0 <submit_to_queue_locked+0xcc>)
 1021b1e:	f44f 73a7 	mov.w	r3, #334	; 0x14e
 1021b22:	4a28      	ldr	r2, [pc, #160]	; (1021bc4 <submit_to_queue_locked+0xd0>)
 1021b24:	f003 f857 	bl	1024bd6 <assert_print>
 1021b28:	f44f 71a7 	mov.w	r1, #334	; 0x14e
 1021b2c:	4825      	ldr	r0, [pc, #148]	; (1021bc4 <submit_to_queue_locked+0xd0>)
 1021b2e:	f003 f84b 	bl	1024bc8 <assert_post_action>
			ret = 2;
 1021b32:	2602      	movs	r6, #2
			*queuep = work->queue;
 1021b34:	603b      	str	r3, [r7, #0]
		int rc = queue_submit_locked(*queuep, work);
 1021b36:	683d      	ldr	r5, [r7, #0]
	if (queue == NULL) {
 1021b38:	2d00      	cmp	r5, #0
 1021b3a:	d03c      	beq.n	1021bb6 <submit_to_queue_locked+0xc2>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
 1021b3c:	4b22      	ldr	r3, [pc, #136]	; (1021bc8 <submit_to_queue_locked+0xd4>)
 1021b3e:	689b      	ldr	r3, [r3, #8]
 1021b40:	42ab      	cmp	r3, r5
 1021b42:	d00c      	beq.n	1021b5e <submit_to_queue_locked+0x6a>
	return (*flagp & BIT(bit)) != 0U;
 1021b44:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
 1021b48:	07d8      	lsls	r0, r3, #31
	return (*flagp & BIT(bit)) != 0U;
 1021b4a:	f3c3 0280 	ubfx	r2, r3, #2, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
 1021b4e:	d416      	bmi.n	1021b7e <submit_to_queue_locked+0x8a>
		ret = -EBUSY;
 1021b50:	f06f 0612 	mvn.w	r6, #18
		*queuep = NULL;
 1021b54:	2300      	movs	r3, #0
 1021b56:	603b      	str	r3, [r7, #0]
	return ret;
 1021b58:	e027      	b.n	1021baa <submit_to_queue_locked+0xb6>
		ret = 1;
 1021b5a:	2601      	movs	r6, #1
 1021b5c:	e7eb      	b.n	1021b36 <submit_to_queue_locked+0x42>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
 1021b5e:	f007 fb90 	bl	1029282 <k_is_in_isr>
 1021b62:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 1021b66:	2800      	cmp	r0, #0
 1021b68:	d1ee      	bne.n	1021b48 <submit_to_queue_locked+0x54>
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
 1021b6a:	07d9      	lsls	r1, r3, #31
	return (*flagp & BIT(bit)) != 0U;
 1021b6c:	f3c3 02c0 	ubfx	r2, r3, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
 1021b70:	d5ee      	bpl.n	1021b50 <submit_to_queue_locked+0x5c>
	} else if (plugged && !draining) {
 1021b72:	b152      	cbz	r2, 1021b8a <submit_to_queue_locked+0x96>
 1021b74:	075b      	lsls	r3, r3, #29
 1021b76:	d408      	bmi.n	1021b8a <submit_to_queue_locked+0x96>
		ret = -EBUSY;
 1021b78:	f06f 060f 	mvn.w	r6, #15
 1021b7c:	e7ea      	b.n	1021b54 <submit_to_queue_locked+0x60>
	} else if (draining && !chained) {
 1021b7e:	2a00      	cmp	r2, #0
 1021b80:	d1fa      	bne.n	1021b78 <submit_to_queue_locked+0x84>
	return (*flagp & BIT(bit)) != 0U;
 1021b82:	f3c3 03c0 	ubfx	r3, r3, #3, #1
	} else if (plugged && !draining) {
 1021b86:	2b00      	cmp	r3, #0
 1021b88:	d1f6      	bne.n	1021b78 <submit_to_queue_locked+0x84>
	parent->next = child;
 1021b8a:	2300      	movs	r3, #0
 1021b8c:	6023      	str	r3, [r4, #0]
	return list->tail;
 1021b8e:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
Z_GENLIST_APPEND(slist, snode)
 1021b92:	b963      	cbnz	r3, 1021bae <submit_to_queue_locked+0xba>
	list->head = node;
 1021b94:	e9c5 4420 	strd	r4, r4, [r5, #128]	; 0x80
		(void)notify_queue_locked(queue);
 1021b98:	4628      	mov	r0, r5
 1021b9a:	f007 fbe5 	bl	1029368 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
 1021b9e:	68e3      	ldr	r3, [r4, #12]
 1021ba0:	f043 0304 	orr.w	r3, r3, #4
 1021ba4:	60e3      	str	r3, [r4, #12]
			work->queue = *queuep;
 1021ba6:	683b      	ldr	r3, [r7, #0]
 1021ba8:	60a3      	str	r3, [r4, #8]
}
 1021baa:	4630      	mov	r0, r6
 1021bac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	parent->next = child;
 1021bae:	601c      	str	r4, [r3, #0]
	list->tail = node;
 1021bb0:	f8c5 4084 	str.w	r4, [r5, #132]	; 0x84
}
 1021bb4:	e7f0      	b.n	1021b98 <submit_to_queue_locked+0xa4>
		return -EINVAL;
 1021bb6:	f06f 0615 	mvn.w	r6, #21
 1021bba:	e7cb      	b.n	1021b54 <submit_to_queue_locked+0x60>
 1021bbc:	0102fa5c 	.word	0x0102fa5c
 1021bc0:	0102b695 	.word	0x0102b695
 1021bc4:	0102fa24 	.word	0x0102fa24
 1021bc8:	210080cc 	.word	0x210080cc

01021bcc <work_timeout>:
 * Invoked by timeout infrastructure.
 * Takes and releases work lock.
 * Conditionally reschedules.
 */
static void work_timeout(struct _timeout *to)
{
 1021bcc:	b573      	push	{r0, r1, r4, r5, r6, lr}
 1021bce:	4604      	mov	r4, r0
	__asm__ volatile(
 1021bd0:	f04f 0320 	mov.w	r3, #32
 1021bd4:	f3ef 8511 	mrs	r5, BASEPRI
 1021bd8:	f383 8812 	msr	BASEPRI_MAX, r3
 1021bdc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1021be0:	481c      	ldr	r0, [pc, #112]	; (1021c54 <work_timeout+0x88>)
 1021be2:	f7ff fa75 	bl	10210d0 <z_spin_lock_valid>
 1021be6:	b968      	cbnz	r0, 1021c04 <work_timeout+0x38>
 1021be8:	2394      	movs	r3, #148	; 0x94
 1021bea:	4a1b      	ldr	r2, [pc, #108]	; (1021c58 <work_timeout+0x8c>)
 1021bec:	491b      	ldr	r1, [pc, #108]	; (1021c5c <work_timeout+0x90>)
 1021bee:	481c      	ldr	r0, [pc, #112]	; (1021c60 <work_timeout+0x94>)
 1021bf0:	f002 fff1 	bl	1024bd6 <assert_print>
 1021bf4:	4917      	ldr	r1, [pc, #92]	; (1021c54 <work_timeout+0x88>)
 1021bf6:	481b      	ldr	r0, [pc, #108]	; (1021c64 <work_timeout+0x98>)
 1021bf8:	f002 ffed 	bl	1024bd6 <assert_print>
 1021bfc:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1021bfe:	4816      	ldr	r0, [pc, #88]	; (1021c58 <work_timeout+0x8c>)
 1021c00:	f002 ffe2 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1021c04:	4813      	ldr	r0, [pc, #76]	; (1021c54 <work_timeout+0x88>)
 1021c06:	f7ff fa7f 	bl	1021108 <z_spin_lock_set_owner>
	struct k_work_delayable *dw
		= CONTAINER_OF(to, struct k_work_delayable, timeout);
	struct k_work *wp = &dw->work;
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_work_q *queue = NULL;
 1021c0a:	2300      	movs	r3, #0
	 * notified of new work at the next reschedule point.
	 *
	 * If not successful there is no notification that the work has been
	 * abandoned.  Sorry.
	 */
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
 1021c0c:	2103      	movs	r1, #3
 1021c0e:	1f20      	subs	r0, r4, #4
	struct k_work_q *queue = NULL;
 1021c10:	9301      	str	r3, [sp, #4]
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
 1021c12:	f1a4 0610 	sub.w	r6, r4, #16
 1021c16:	f007 fb8e 	bl	1029336 <flag_test_and_clear>
 1021c1a:	b128      	cbz	r0, 1021c28 <work_timeout+0x5c>
		queue = dw->queue;
 1021c1c:	69a3      	ldr	r3, [r4, #24]
		(void)submit_to_queue_locked(wp, &queue);
 1021c1e:	4630      	mov	r0, r6
 1021c20:	a901      	add	r1, sp, #4
		queue = dw->queue;
 1021c22:	9301      	str	r3, [sp, #4]
		(void)submit_to_queue_locked(wp, &queue);
 1021c24:	f7ff ff66 	bl	1021af4 <submit_to_queue_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1021c28:	480a      	ldr	r0, [pc, #40]	; (1021c54 <work_timeout+0x88>)
 1021c2a:	f7ff fa5f 	bl	10210ec <z_spin_unlock_valid>
 1021c2e:	b958      	cbnz	r0, 1021c48 <work_timeout+0x7c>
 1021c30:	23c2      	movs	r3, #194	; 0xc2
 1021c32:	4a09      	ldr	r2, [pc, #36]	; (1021c58 <work_timeout+0x8c>)
 1021c34:	490c      	ldr	r1, [pc, #48]	; (1021c68 <work_timeout+0x9c>)
 1021c36:	480a      	ldr	r0, [pc, #40]	; (1021c60 <work_timeout+0x94>)
 1021c38:	f002 ffcd 	bl	1024bd6 <assert_print>
 1021c3c:	4905      	ldr	r1, [pc, #20]	; (1021c54 <work_timeout+0x88>)
 1021c3e:	480b      	ldr	r0, [pc, #44]	; (1021c6c <work_timeout+0xa0>)
 1021c40:	f002 ffc9 	bl	1024bd6 <assert_print>
 1021c44:	21c2      	movs	r1, #194	; 0xc2
 1021c46:	e7da      	b.n	1021bfe <work_timeout+0x32>
	__asm__ volatile(
 1021c48:	f385 8811 	msr	BASEPRI, r5
 1021c4c:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&lock, key);
}
 1021c50:	b002      	add	sp, #8
 1021c52:	bd70      	pop	{r4, r5, r6, pc}
 1021c54:	21008100 	.word	0x21008100
 1021c58:	0102bd8a 	.word	0x0102bd8a
 1021c5c:	0102bde3 	.word	0x0102bde3
 1021c60:	0102b695 	.word	0x0102b695
 1021c64:	0102bdf8 	.word	0x0102bdf8
 1021c68:	0102bdb7 	.word	0x0102bdb7
 1021c6c:	0102bdce 	.word	0x0102bdce

01021c70 <k_work_init>:
{
 1021c70:	b538      	push	{r3, r4, r5, lr}
 1021c72:	460d      	mov	r5, r1
	__ASSERT_NO_MSG(work != NULL);
 1021c74:	4604      	mov	r4, r0
 1021c76:	b948      	cbnz	r0, 1021c8c <k_work_init+0x1c>
 1021c78:	490c      	ldr	r1, [pc, #48]	; (1021cac <k_work_init+0x3c>)
 1021c7a:	2389      	movs	r3, #137	; 0x89
 1021c7c:	4a0c      	ldr	r2, [pc, #48]	; (1021cb0 <k_work_init+0x40>)
 1021c7e:	480d      	ldr	r0, [pc, #52]	; (1021cb4 <k_work_init+0x44>)
 1021c80:	f002 ffa9 	bl	1024bd6 <assert_print>
 1021c84:	2189      	movs	r1, #137	; 0x89
	__ASSERT_NO_MSG(handler != NULL);
 1021c86:	480a      	ldr	r0, [pc, #40]	; (1021cb0 <k_work_init+0x40>)
 1021c88:	f002 ff9e 	bl	1024bc8 <assert_post_action>
 1021c8c:	b939      	cbnz	r1, 1021c9e <k_work_init+0x2e>
 1021c8e:	490a      	ldr	r1, [pc, #40]	; (1021cb8 <k_work_init+0x48>)
 1021c90:	238a      	movs	r3, #138	; 0x8a
 1021c92:	4a07      	ldr	r2, [pc, #28]	; (1021cb0 <k_work_init+0x40>)
 1021c94:	4807      	ldr	r0, [pc, #28]	; (1021cb4 <k_work_init+0x44>)
 1021c96:	f002 ff9e 	bl	1024bd6 <assert_print>
 1021c9a:	218a      	movs	r1, #138	; 0x8a
 1021c9c:	e7f3      	b.n	1021c86 <k_work_init+0x16>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
 1021c9e:	2210      	movs	r2, #16
 1021ca0:	2100      	movs	r1, #0
 1021ca2:	f004 fe72 	bl	102698a <memset>
 1021ca6:	6065      	str	r5, [r4, #4]
}
 1021ca8:	bd38      	pop	{r3, r4, r5, pc}
 1021caa:	bf00      	nop
 1021cac:	0102fafb 	.word	0x0102fafb
 1021cb0:	0102fa24 	.word	0x0102fa24
 1021cb4:	0102b695 	.word	0x0102b695
 1021cb8:	0102fa45 	.word	0x0102fa45

01021cbc <k_work_busy_get>:
{
 1021cbc:	b538      	push	{r3, r4, r5, lr}
 1021cbe:	4604      	mov	r4, r0
	__asm__ volatile(
 1021cc0:	f04f 0320 	mov.w	r3, #32
 1021cc4:	f3ef 8511 	mrs	r5, BASEPRI
 1021cc8:	f383 8812 	msr	BASEPRI_MAX, r3
 1021ccc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1021cd0:	4816      	ldr	r0, [pc, #88]	; (1021d2c <k_work_busy_get+0x70>)
 1021cd2:	f7ff f9fd 	bl	10210d0 <z_spin_lock_valid>
 1021cd6:	b968      	cbnz	r0, 1021cf4 <k_work_busy_get+0x38>
 1021cd8:	2394      	movs	r3, #148	; 0x94
 1021cda:	4a15      	ldr	r2, [pc, #84]	; (1021d30 <k_work_busy_get+0x74>)
 1021cdc:	4915      	ldr	r1, [pc, #84]	; (1021d34 <k_work_busy_get+0x78>)
 1021cde:	4816      	ldr	r0, [pc, #88]	; (1021d38 <k_work_busy_get+0x7c>)
 1021ce0:	f002 ff79 	bl	1024bd6 <assert_print>
 1021ce4:	4911      	ldr	r1, [pc, #68]	; (1021d2c <k_work_busy_get+0x70>)
 1021ce6:	4815      	ldr	r0, [pc, #84]	; (1021d3c <k_work_busy_get+0x80>)
 1021ce8:	f002 ff75 	bl	1024bd6 <assert_print>
 1021cec:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1021cee:	4810      	ldr	r0, [pc, #64]	; (1021d30 <k_work_busy_get+0x74>)
 1021cf0:	f002 ff6a 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1021cf4:	480d      	ldr	r0, [pc, #52]	; (1021d2c <k_work_busy_get+0x70>)
 1021cf6:	f7ff fa07 	bl	1021108 <z_spin_lock_set_owner>
	return flags_get(&work->flags) & K_WORK_MASK;
 1021cfa:	68e4      	ldr	r4, [r4, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1021cfc:	480b      	ldr	r0, [pc, #44]	; (1021d2c <k_work_busy_get+0x70>)
 1021cfe:	f004 040f 	and.w	r4, r4, #15
 1021d02:	f7ff f9f3 	bl	10210ec <z_spin_unlock_valid>
 1021d06:	b958      	cbnz	r0, 1021d20 <k_work_busy_get+0x64>
 1021d08:	23c2      	movs	r3, #194	; 0xc2
 1021d0a:	4a09      	ldr	r2, [pc, #36]	; (1021d30 <k_work_busy_get+0x74>)
 1021d0c:	490c      	ldr	r1, [pc, #48]	; (1021d40 <k_work_busy_get+0x84>)
 1021d0e:	480a      	ldr	r0, [pc, #40]	; (1021d38 <k_work_busy_get+0x7c>)
 1021d10:	f002 ff61 	bl	1024bd6 <assert_print>
 1021d14:	4905      	ldr	r1, [pc, #20]	; (1021d2c <k_work_busy_get+0x70>)
 1021d16:	480b      	ldr	r0, [pc, #44]	; (1021d44 <k_work_busy_get+0x88>)
 1021d18:	f002 ff5d 	bl	1024bd6 <assert_print>
 1021d1c:	21c2      	movs	r1, #194	; 0xc2
 1021d1e:	e7e6      	b.n	1021cee <k_work_busy_get+0x32>
	__asm__ volatile(
 1021d20:	f385 8811 	msr	BASEPRI, r5
 1021d24:	f3bf 8f6f 	isb	sy
}
 1021d28:	4620      	mov	r0, r4
 1021d2a:	bd38      	pop	{r3, r4, r5, pc}
 1021d2c:	21008100 	.word	0x21008100
 1021d30:	0102bd8a 	.word	0x0102bd8a
 1021d34:	0102bde3 	.word	0x0102bde3
 1021d38:	0102b695 	.word	0x0102b695
 1021d3c:	0102bdf8 	.word	0x0102bdf8
 1021d40:	0102bdb7 	.word	0x0102bdb7
 1021d44:	0102bdce 	.word	0x0102bdce

01021d48 <z_work_submit_to_queue>:
{
 1021d48:	b537      	push	{r0, r1, r2, r4, r5, lr}
	__ASSERT_NO_MSG(work != NULL);
 1021d4a:	460c      	mov	r4, r1
{
 1021d4c:	9001      	str	r0, [sp, #4]
	__ASSERT_NO_MSG(work != NULL);
 1021d4e:	b959      	cbnz	r1, 1021d68 <z_work_submit_to_queue+0x20>
 1021d50:	4921      	ldr	r1, [pc, #132]	; (1021dd8 <z_work_submit_to_queue+0x90>)
 1021d52:	4822      	ldr	r0, [pc, #136]	; (1021ddc <z_work_submit_to_queue+0x94>)
 1021d54:	f44f 73ba 	mov.w	r3, #372	; 0x174
 1021d58:	4a21      	ldr	r2, [pc, #132]	; (1021de0 <z_work_submit_to_queue+0x98>)
 1021d5a:	f002 ff3c 	bl	1024bd6 <assert_print>
 1021d5e:	f44f 71ba 	mov.w	r1, #372	; 0x174
 1021d62:	481f      	ldr	r0, [pc, #124]	; (1021de0 <z_work_submit_to_queue+0x98>)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1021d64:	f002 ff30 	bl	1024bc8 <assert_post_action>
	__asm__ volatile(
 1021d68:	f04f 0320 	mov.w	r3, #32
 1021d6c:	f3ef 8511 	mrs	r5, BASEPRI
 1021d70:	f383 8812 	msr	BASEPRI_MAX, r3
 1021d74:	f3bf 8f6f 	isb	sy
 1021d78:	481a      	ldr	r0, [pc, #104]	; (1021de4 <z_work_submit_to_queue+0x9c>)
 1021d7a:	f7ff f9a9 	bl	10210d0 <z_spin_lock_valid>
 1021d7e:	b960      	cbnz	r0, 1021d9a <z_work_submit_to_queue+0x52>
 1021d80:	2394      	movs	r3, #148	; 0x94
 1021d82:	4a19      	ldr	r2, [pc, #100]	; (1021de8 <z_work_submit_to_queue+0xa0>)
 1021d84:	4919      	ldr	r1, [pc, #100]	; (1021dec <z_work_submit_to_queue+0xa4>)
 1021d86:	4815      	ldr	r0, [pc, #84]	; (1021ddc <z_work_submit_to_queue+0x94>)
 1021d88:	f002 ff25 	bl	1024bd6 <assert_print>
 1021d8c:	4915      	ldr	r1, [pc, #84]	; (1021de4 <z_work_submit_to_queue+0x9c>)
 1021d8e:	4818      	ldr	r0, [pc, #96]	; (1021df0 <z_work_submit_to_queue+0xa8>)
 1021d90:	f002 ff21 	bl	1024bd6 <assert_print>
 1021d94:	2194      	movs	r1, #148	; 0x94
 1021d96:	4814      	ldr	r0, [pc, #80]	; (1021de8 <z_work_submit_to_queue+0xa0>)
 1021d98:	e7e4      	b.n	1021d64 <z_work_submit_to_queue+0x1c>
	z_spin_lock_set_owner(l);
 1021d9a:	4812      	ldr	r0, [pc, #72]	; (1021de4 <z_work_submit_to_queue+0x9c>)
 1021d9c:	f7ff f9b4 	bl	1021108 <z_spin_lock_set_owner>
	int ret = submit_to_queue_locked(work, &queue);
 1021da0:	4620      	mov	r0, r4
 1021da2:	a901      	add	r1, sp, #4
 1021da4:	f7ff fea6 	bl	1021af4 <submit_to_queue_locked>
 1021da8:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1021daa:	480e      	ldr	r0, [pc, #56]	; (1021de4 <z_work_submit_to_queue+0x9c>)
 1021dac:	f7ff f99e 	bl	10210ec <z_spin_unlock_valid>
 1021db0:	b958      	cbnz	r0, 1021dca <z_work_submit_to_queue+0x82>
 1021db2:	23c2      	movs	r3, #194	; 0xc2
 1021db4:	4a0c      	ldr	r2, [pc, #48]	; (1021de8 <z_work_submit_to_queue+0xa0>)
 1021db6:	490f      	ldr	r1, [pc, #60]	; (1021df4 <z_work_submit_to_queue+0xac>)
 1021db8:	4808      	ldr	r0, [pc, #32]	; (1021ddc <z_work_submit_to_queue+0x94>)
 1021dba:	f002 ff0c 	bl	1024bd6 <assert_print>
 1021dbe:	4909      	ldr	r1, [pc, #36]	; (1021de4 <z_work_submit_to_queue+0x9c>)
 1021dc0:	480d      	ldr	r0, [pc, #52]	; (1021df8 <z_work_submit_to_queue+0xb0>)
 1021dc2:	f002 ff08 	bl	1024bd6 <assert_print>
 1021dc6:	21c2      	movs	r1, #194	; 0xc2
 1021dc8:	e7e5      	b.n	1021d96 <z_work_submit_to_queue+0x4e>
	__asm__ volatile(
 1021dca:	f385 8811 	msr	BASEPRI, r5
 1021dce:	f3bf 8f6f 	isb	sy
}
 1021dd2:	4620      	mov	r0, r4
 1021dd4:	b003      	add	sp, #12
 1021dd6:	bd30      	pop	{r4, r5, pc}
 1021dd8:	0102fafb 	.word	0x0102fafb
 1021ddc:	0102b695 	.word	0x0102b695
 1021de0:	0102fa24 	.word	0x0102fa24
 1021de4:	21008100 	.word	0x21008100
 1021de8:	0102bd8a 	.word	0x0102bd8a
 1021dec:	0102bde3 	.word	0x0102bde3
 1021df0:	0102bdf8 	.word	0x0102bdf8
 1021df4:	0102bdb7 	.word	0x0102bdb7
 1021df8:	0102bdce 	.word	0x0102bdce

01021dfc <k_work_submit>:
{
 1021dfc:	4601      	mov	r1, r0
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
 1021dfe:	4801      	ldr	r0, [pc, #4]	; (1021e04 <k_work_submit+0x8>)
 1021e00:	f007 baec 	b.w	10293dc <k_work_submit_to_queue>
 1021e04:	21004510 	.word	0x21004510

01021e08 <k_work_queue_init>:
{
 1021e08:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(queue != NULL);
 1021e0a:	b958      	cbnz	r0, 1021e24 <k_work_queue_init+0x1c>
 1021e0c:	4908      	ldr	r1, [pc, #32]	; (1021e30 <k_work_queue_init+0x28>)
 1021e0e:	4809      	ldr	r0, [pc, #36]	; (1021e34 <k_work_queue_init+0x2c>)
 1021e10:	f240 23b9 	movw	r3, #697	; 0x2b9
 1021e14:	4a08      	ldr	r2, [pc, #32]	; (1021e38 <k_work_queue_init+0x30>)
 1021e16:	f002 fede 	bl	1024bd6 <assert_print>
 1021e1a:	f240 21b9 	movw	r1, #697	; 0x2b9
 1021e1e:	4806      	ldr	r0, [pc, #24]	; (1021e38 <k_work_queue_init+0x30>)
 1021e20:	f002 fed2 	bl	1024bc8 <assert_post_action>
	*queue = (struct k_work_q) {
 1021e24:	22a0      	movs	r2, #160	; 0xa0
 1021e26:	2100      	movs	r1, #0
 1021e28:	f004 fdaf 	bl	102698a <memset>
}
 1021e2c:	bd08      	pop	{r3, pc}
 1021e2e:	bf00      	nop
 1021e30:	0102fa62 	.word	0x0102fa62
 1021e34:	0102b695 	.word	0x0102b695
 1021e38:	0102fa24 	.word	0x0102fa24

01021e3c <k_work_queue_start>:
{
 1021e3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 1021e3e:	b089      	sub	sp, #36	; 0x24
	__ASSERT_NO_MSG(queue);
 1021e40:	4604      	mov	r4, r0
{
 1021e42:	9d0e      	ldr	r5, [sp, #56]	; 0x38
	__ASSERT_NO_MSG(queue);
 1021e44:	b958      	cbnz	r0, 1021e5e <k_work_queue_start+0x22>
 1021e46:	492b      	ldr	r1, [pc, #172]	; (1021ef4 <k_work_queue_start+0xb8>)
 1021e48:	f44f 7332 	mov.w	r3, #712	; 0x2c8
 1021e4c:	4a2a      	ldr	r2, [pc, #168]	; (1021ef8 <k_work_queue_start+0xbc>)
 1021e4e:	482b      	ldr	r0, [pc, #172]	; (1021efc <k_work_queue_start+0xc0>)
 1021e50:	f002 fec1 	bl	1024bd6 <assert_print>
 1021e54:	f44f 7132 	mov.w	r1, #712	; 0x2c8
	__ASSERT_NO_MSG(stack);
 1021e58:	4827      	ldr	r0, [pc, #156]	; (1021ef8 <k_work_queue_start+0xbc>)
 1021e5a:	f002 feb5 	bl	1024bc8 <assert_post_action>
 1021e5e:	b949      	cbnz	r1, 1021e74 <k_work_queue_start+0x38>
 1021e60:	4927      	ldr	r1, [pc, #156]	; (1021f00 <k_work_queue_start+0xc4>)
 1021e62:	f240 23c9 	movw	r3, #713	; 0x2c9
 1021e66:	4a24      	ldr	r2, [pc, #144]	; (1021ef8 <k_work_queue_start+0xbc>)
 1021e68:	4824      	ldr	r0, [pc, #144]	; (1021efc <k_work_queue_start+0xc0>)
 1021e6a:	f002 feb4 	bl	1024bd6 <assert_print>
 1021e6e:	f240 21c9 	movw	r1, #713	; 0x2c9
 1021e72:	e7f1      	b.n	1021e58 <k_work_queue_start+0x1c>
	return (*flagp & BIT(bit)) != 0U;
 1021e74:	f8d0 0098 	ldr.w	r0, [r0, #152]	; 0x98
	__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));
 1021e78:	f010 0001 	ands.w	r0, r0, #1
 1021e7c:	d009      	beq.n	1021e92 <k_work_queue_start+0x56>
 1021e7e:	4921      	ldr	r1, [pc, #132]	; (1021f04 <k_work_queue_start+0xc8>)
 1021e80:	f240 23ca 	movw	r3, #714	; 0x2ca
 1021e84:	4a1c      	ldr	r2, [pc, #112]	; (1021ef8 <k_work_queue_start+0xbc>)
 1021e86:	481d      	ldr	r0, [pc, #116]	; (1021efc <k_work_queue_start+0xc0>)
 1021e88:	f002 fea5 	bl	1024bd6 <assert_print>
 1021e8c:	f240 21ca 	movw	r1, #714	; 0x2ca
 1021e90:	e7e2      	b.n	1021e58 <k_work_queue_start+0x1c>
	list->tail = NULL;
 1021e92:	e9c4 0020 	strd	r0, r0, [r4, #128]	; 0x80
 1021e96:	f104 0088 	add.w	r0, r4, #136	; 0x88
	list->tail = (sys_dnode_t *)list;
 1021e9a:	e9c4 0022 	strd	r0, r0, [r4, #136]	; 0x88
 1021e9e:	f104 0090 	add.w	r0, r4, #144	; 0x90
 1021ea2:	e9c4 0024 	strd	r0, r0, [r4, #144]	; 0x90
	if ((cfg != NULL) && cfg->no_yield) {
 1021ea6:	b31d      	cbz	r5, 1021ef0 <k_work_queue_start+0xb4>
 1021ea8:	7928      	ldrb	r0, [r5, #4]
		flags |= K_WORK_QUEUE_NO_YIELD;
 1021eaa:	2800      	cmp	r0, #0
 1021eac:	f240 1001 	movw	r0, #257	; 0x101
 1021eb0:	bf08      	it	eq
 1021eb2:	2001      	moveq	r0, #1
	*flagp = flags;
 1021eb4:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 1021eb8:	2000      	movs	r0, #0
 1021eba:	f04f 36ff 	mov.w	r6, #4294967295
 1021ebe:	f04f 37ff 	mov.w	r7, #4294967295
 1021ec2:	e9cd 3003 	strd	r3, r0, [sp, #12]
 1021ec6:	e9cd 0001 	strd	r0, r0, [sp, #4]
 1021eca:	e9cd 6706 	strd	r6, r7, [sp, #24]
 1021ece:	4620      	mov	r0, r4
 1021ed0:	4b0d      	ldr	r3, [pc, #52]	; (1021f08 <k_work_queue_start+0xcc>)
 1021ed2:	9400      	str	r4, [sp, #0]
 1021ed4:	f7ff f832 	bl	1020f3c <z_impl_k_thread_create>
	if ((cfg != NULL) && (cfg->name != NULL)) {
 1021ed8:	b125      	cbz	r5, 1021ee4 <k_work_queue_start+0xa8>
 1021eda:	6829      	ldr	r1, [r5, #0]
 1021edc:	b111      	cbz	r1, 1021ee4 <k_work_queue_start+0xa8>
	return z_impl_k_thread_name_set(thread, str);
 1021ede:	4620      	mov	r0, r4
 1021ee0:	f007 f9d5 	bl	102928e <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
 1021ee4:	4620      	mov	r0, r4
}
 1021ee6:	b009      	add	sp, #36	; 0x24
 1021ee8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 1021eec:	f007 b9d4 	b.w	1029298 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
 1021ef0:	2001      	movs	r0, #1
 1021ef2:	e7df      	b.n	1021eb4 <k_work_queue_start+0x78>
 1021ef4:	0102faba 	.word	0x0102faba
 1021ef8:	0102fa24 	.word	0x0102fa24
 1021efc:	0102b695 	.word	0x0102b695
 1021f00:	0102fac0 	.word	0x0102fac0
 1021f04:	0102fac6 	.word	0x0102fac6
 1021f08:	010218d1 	.word	0x010218d1

01021f0c <k_work_init_delayable>:

void k_work_init_delayable(struct k_work_delayable *dwork,
			    k_work_handler_t handler)
{
 1021f0c:	b538      	push	{r3, r4, r5, lr}
 1021f0e:	460d      	mov	r5, r1
	__ASSERT_NO_MSG(dwork != NULL);
 1021f10:	4604      	mov	r4, r0
 1021f12:	b958      	cbnz	r0, 1021f2c <k_work_init_delayable+0x20>
 1021f14:	490f      	ldr	r1, [pc, #60]	; (1021f54 <k_work_init_delayable+0x48>)
 1021f16:	f44f 7350 	mov.w	r3, #832	; 0x340
 1021f1a:	4a0f      	ldr	r2, [pc, #60]	; (1021f58 <k_work_init_delayable+0x4c>)
 1021f1c:	480f      	ldr	r0, [pc, #60]	; (1021f5c <k_work_init_delayable+0x50>)
 1021f1e:	f002 fe5a 	bl	1024bd6 <assert_print>
 1021f22:	f44f 7150 	mov.w	r1, #832	; 0x340
	__ASSERT_NO_MSG(handler != NULL);
 1021f26:	480c      	ldr	r0, [pc, #48]	; (1021f58 <k_work_init_delayable+0x4c>)
 1021f28:	f002 fe4e 	bl	1024bc8 <assert_post_action>
 1021f2c:	b949      	cbnz	r1, 1021f42 <k_work_init_delayable+0x36>
 1021f2e:	490c      	ldr	r1, [pc, #48]	; (1021f60 <k_work_init_delayable+0x54>)
 1021f30:	f240 3341 	movw	r3, #833	; 0x341
 1021f34:	4a08      	ldr	r2, [pc, #32]	; (1021f58 <k_work_init_delayable+0x4c>)
 1021f36:	4809      	ldr	r0, [pc, #36]	; (1021f5c <k_work_init_delayable+0x50>)
 1021f38:	f002 fe4d 	bl	1024bd6 <assert_print>
 1021f3c:	f240 3141 	movw	r1, #833	; 0x341
 1021f40:	e7f1      	b.n	1021f26 <k_work_init_delayable+0x1a>

	*dwork = (struct k_work_delayable){
 1021f42:	2230      	movs	r2, #48	; 0x30
 1021f44:	2100      	movs	r1, #0
 1021f46:	f004 fd20 	bl	102698a <memset>
 1021f4a:	f44f 7380 	mov.w	r3, #256	; 0x100
 1021f4e:	6065      	str	r5, [r4, #4]
 1021f50:	60e3      	str	r3, [r4, #12]
		},
	};
	z_init_timeout(&dwork->timeout);

	SYS_PORT_TRACING_OBJ_INIT(k_work_delayable, dwork);
}
 1021f52:	bd38      	pop	{r3, r4, r5, pc}
 1021f54:	0102fafa 	.word	0x0102fafa
 1021f58:	0102fa24 	.word	0x0102fa24
 1021f5c:	0102b695 	.word	0x0102b695
 1021f60:	0102fa45 	.word	0x0102fa45

01021f64 <k_work_schedule_for_queue>:
}

int k_work_schedule_for_queue(struct k_work_q *queue,
			       struct k_work_delayable *dwork,
			       k_timeout_t delay)
{
 1021f64:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1021f66:	4616      	mov	r6, r2
 1021f68:	461d      	mov	r5, r3
	__ASSERT_NO_MSG(dwork != NULL);
 1021f6a:	460c      	mov	r4, r1
{
 1021f6c:	9001      	str	r0, [sp, #4]
	__ASSERT_NO_MSG(dwork != NULL);
 1021f6e:	b959      	cbnz	r1, 1021f88 <k_work_schedule_for_queue+0x24>
 1021f70:	492d      	ldr	r1, [pc, #180]	; (1022028 <k_work_schedule_for_queue+0xc4>)
 1021f72:	482e      	ldr	r0, [pc, #184]	; (102202c <k_work_schedule_for_queue+0xc8>)
 1021f74:	f240 33b7 	movw	r3, #951	; 0x3b7
 1021f78:	4a2d      	ldr	r2, [pc, #180]	; (1022030 <k_work_schedule_for_queue+0xcc>)
 1021f7a:	f002 fe2c 	bl	1024bd6 <assert_print>
 1021f7e:	f240 31b7 	movw	r1, #951	; 0x3b7
 1021f82:	482b      	ldr	r0, [pc, #172]	; (1022030 <k_work_schedule_for_queue+0xcc>)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1021f84:	f002 fe20 	bl	1024bc8 <assert_post_action>
	__asm__ volatile(
 1021f88:	f04f 0320 	mov.w	r3, #32
 1021f8c:	f3ef 8711 	mrs	r7, BASEPRI
 1021f90:	f383 8812 	msr	BASEPRI_MAX, r3
 1021f94:	f3bf 8f6f 	isb	sy
 1021f98:	4826      	ldr	r0, [pc, #152]	; (1022034 <k_work_schedule_for_queue+0xd0>)
 1021f9a:	f7ff f899 	bl	10210d0 <z_spin_lock_valid>
 1021f9e:	b960      	cbnz	r0, 1021fba <k_work_schedule_for_queue+0x56>
 1021fa0:	2394      	movs	r3, #148	; 0x94
 1021fa2:	4a25      	ldr	r2, [pc, #148]	; (1022038 <k_work_schedule_for_queue+0xd4>)
 1021fa4:	4925      	ldr	r1, [pc, #148]	; (102203c <k_work_schedule_for_queue+0xd8>)
 1021fa6:	4821      	ldr	r0, [pc, #132]	; (102202c <k_work_schedule_for_queue+0xc8>)
 1021fa8:	f002 fe15 	bl	1024bd6 <assert_print>
 1021fac:	4921      	ldr	r1, [pc, #132]	; (1022034 <k_work_schedule_for_queue+0xd0>)
 1021fae:	4824      	ldr	r0, [pc, #144]	; (1022040 <k_work_schedule_for_queue+0xdc>)
 1021fb0:	f002 fe11 	bl	1024bd6 <assert_print>
 1021fb4:	2194      	movs	r1, #148	; 0x94
 1021fb6:	4820      	ldr	r0, [pc, #128]	; (1022038 <k_work_schedule_for_queue+0xd4>)
 1021fb8:	e7e4      	b.n	1021f84 <k_work_schedule_for_queue+0x20>
	z_spin_lock_set_owner(l);
 1021fba:	481e      	ldr	r0, [pc, #120]	; (1022034 <k_work_schedule_for_queue+0xd0>)
 1021fbc:	f7ff f8a4 	bl	1021108 <z_spin_lock_set_owner>
	return *flagp;
 1021fc0:	68e3      	ldr	r3, [r4, #12]
	struct k_work *work = &dwork->work;
	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Schedule the work item if it's idle or running. */
	if ((work_busy_get_locked(work) & ~K_WORK_RUNNING) == 0U) {
 1021fc2:	f013 0f0e 	tst.w	r3, #14
 1021fc6:	d125      	bne.n	1022014 <k_work_schedule_for_queue+0xb0>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 1021fc8:	ea55 0206 	orrs.w	r2, r5, r6
 1021fcc:	d114      	bne.n	1021ff8 <k_work_schedule_for_queue+0x94>
		return submit_to_queue_locked(work, queuep);
 1021fce:	4620      	mov	r0, r4
 1021fd0:	a901      	add	r1, sp, #4
 1021fd2:	f7ff fd8f 	bl	1021af4 <submit_to_queue_locked>
 1021fd6:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1021fd8:	4816      	ldr	r0, [pc, #88]	; (1022034 <k_work_schedule_for_queue+0xd0>)
 1021fda:	f7ff f887 	bl	10210ec <z_spin_unlock_valid>
 1021fde:	b9d8      	cbnz	r0, 1022018 <k_work_schedule_for_queue+0xb4>
 1021fe0:	23c2      	movs	r3, #194	; 0xc2
 1021fe2:	4a15      	ldr	r2, [pc, #84]	; (1022038 <k_work_schedule_for_queue+0xd4>)
 1021fe4:	4917      	ldr	r1, [pc, #92]	; (1022044 <k_work_schedule_for_queue+0xe0>)
 1021fe6:	4811      	ldr	r0, [pc, #68]	; (102202c <k_work_schedule_for_queue+0xc8>)
 1021fe8:	f002 fdf5 	bl	1024bd6 <assert_print>
 1021fec:	4911      	ldr	r1, [pc, #68]	; (1022034 <k_work_schedule_for_queue+0xd0>)
 1021fee:	4816      	ldr	r0, [pc, #88]	; (1022048 <k_work_schedule_for_queue+0xe4>)
 1021ff0:	f002 fdf1 	bl	1024bd6 <assert_print>
 1021ff4:	21c2      	movs	r1, #194	; 0xc2
 1021ff6:	e7de      	b.n	1021fb6 <k_work_schedule_for_queue+0x52>
	*flagp |= BIT(bit);
 1021ff8:	f043 0308 	orr.w	r3, r3, #8
 1021ffc:	60e3      	str	r3, [r4, #12]
	dwork->queue = *queuep;
 1021ffe:	9b01      	ldr	r3, [sp, #4]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
 1022000:	f104 0010 	add.w	r0, r4, #16
	dwork->queue = *queuep;
 1022004:	62a3      	str	r3, [r4, #40]	; 0x28
	z_add_timeout(&dwork->timeout, work_timeout, delay);
 1022006:	4632      	mov	r2, r6
 1022008:	462b      	mov	r3, r5
 102200a:	4910      	ldr	r1, [pc, #64]	; (102204c <k_work_schedule_for_queue+0xe8>)
 102200c:	f001 fbc8 	bl	10237a0 <z_add_timeout>
	return ret;
 1022010:	2401      	movs	r4, #1
 1022012:	e7e1      	b.n	1021fd8 <k_work_schedule_for_queue+0x74>
	int ret = 0;
 1022014:	2400      	movs	r4, #0
 1022016:	e7df      	b.n	1021fd8 <k_work_schedule_for_queue+0x74>
	__asm__ volatile(
 1022018:	f387 8811 	msr	BASEPRI, r7
 102201c:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, schedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
 1022020:	4620      	mov	r0, r4
 1022022:	b003      	add	sp, #12
 1022024:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1022026:	bf00      	nop
 1022028:	0102fafa 	.word	0x0102fafa
 102202c:	0102b695 	.word	0x0102b695
 1022030:	0102fa24 	.word	0x0102fa24
 1022034:	21008100 	.word	0x21008100
 1022038:	0102bd8a 	.word	0x0102bd8a
 102203c:	0102bde3 	.word	0x0102bde3
 1022040:	0102bdf8 	.word	0x0102bdf8
 1022044:	0102bdb7 	.word	0x0102bdb7
 1022048:	0102bdce 	.word	0x0102bdce
 102204c:	01021bcd 	.word	0x01021bcd

01022050 <k_work_schedule>:

int k_work_schedule(struct k_work_delayable *dwork,
				   k_timeout_t delay)
{
 1022050:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, schedule, dwork, delay);

	int ret = k_work_schedule_for_queue(&k_sys_work_q, dwork, delay);
 1022052:	4801      	ldr	r0, [pc, #4]	; (1022058 <k_work_schedule+0x8>)
 1022054:	f7ff bf86 	b.w	1021f64 <k_work_schedule_for_queue>
 1022058:	21004510 	.word	0x21004510

0102205c <k_work_reschedule_for_queue>:
}

int k_work_reschedule_for_queue(struct k_work_q *queue,
				 struct k_work_delayable *dwork,
				 k_timeout_t delay)
{
 102205c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 102205e:	4616      	mov	r6, r2
 1022060:	461d      	mov	r5, r3
	__ASSERT_NO_MSG(dwork != NULL);
 1022062:	460c      	mov	r4, r1
{
 1022064:	9001      	str	r0, [sp, #4]
	__ASSERT_NO_MSG(dwork != NULL);
 1022066:	b959      	cbnz	r1, 1022080 <k_work_reschedule_for_queue+0x24>
 1022068:	492c      	ldr	r1, [pc, #176]	; (102211c <k_work_reschedule_for_queue+0xc0>)
 102206a:	482d      	ldr	r0, [pc, #180]	; (1022120 <k_work_reschedule_for_queue+0xc4>)
 102206c:	f240 33db 	movw	r3, #987	; 0x3db
 1022070:	4a2c      	ldr	r2, [pc, #176]	; (1022124 <k_work_reschedule_for_queue+0xc8>)
 1022072:	f002 fdb0 	bl	1024bd6 <assert_print>
 1022076:	f240 31db 	movw	r1, #987	; 0x3db
 102207a:	482a      	ldr	r0, [pc, #168]	; (1022124 <k_work_reschedule_for_queue+0xc8>)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 102207c:	f002 fda4 	bl	1024bc8 <assert_post_action>
	__asm__ volatile(
 1022080:	f04f 0320 	mov.w	r3, #32
 1022084:	f3ef 8711 	mrs	r7, BASEPRI
 1022088:	f383 8812 	msr	BASEPRI_MAX, r3
 102208c:	f3bf 8f6f 	isb	sy
 1022090:	4825      	ldr	r0, [pc, #148]	; (1022128 <k_work_reschedule_for_queue+0xcc>)
 1022092:	f7ff f81d 	bl	10210d0 <z_spin_lock_valid>
 1022096:	b960      	cbnz	r0, 10220b2 <k_work_reschedule_for_queue+0x56>
 1022098:	2394      	movs	r3, #148	; 0x94
 102209a:	4a24      	ldr	r2, [pc, #144]	; (102212c <k_work_reschedule_for_queue+0xd0>)
 102209c:	4924      	ldr	r1, [pc, #144]	; (1022130 <k_work_reschedule_for_queue+0xd4>)
 102209e:	4820      	ldr	r0, [pc, #128]	; (1022120 <k_work_reschedule_for_queue+0xc4>)
 10220a0:	f002 fd99 	bl	1024bd6 <assert_print>
 10220a4:	4920      	ldr	r1, [pc, #128]	; (1022128 <k_work_reschedule_for_queue+0xcc>)
 10220a6:	4823      	ldr	r0, [pc, #140]	; (1022134 <k_work_reschedule_for_queue+0xd8>)
 10220a8:	f002 fd95 	bl	1024bd6 <assert_print>
 10220ac:	2194      	movs	r1, #148	; 0x94
 10220ae:	481f      	ldr	r0, [pc, #124]	; (102212c <k_work_reschedule_for_queue+0xd0>)
 10220b0:	e7e4      	b.n	102207c <k_work_reschedule_for_queue+0x20>
	z_spin_lock_set_owner(l);
 10220b2:	481d      	ldr	r0, [pc, #116]	; (1022128 <k_work_reschedule_for_queue+0xcc>)
 10220b4:	f7ff f828 	bl	1021108 <z_spin_lock_set_owner>

	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Remove any active scheduling. */
	(void)unschedule_locked(dwork);
 10220b8:	4620      	mov	r0, r4
 10220ba:	f007 f947 	bl	102934c <unschedule_locked>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 10220be:	ea55 0306 	orrs.w	r3, r5, r6
 10220c2:	d114      	bne.n	10220ee <k_work_reschedule_for_queue+0x92>
		return submit_to_queue_locked(work, queuep);
 10220c4:	4620      	mov	r0, r4
 10220c6:	a901      	add	r1, sp, #4
 10220c8:	f7ff fd14 	bl	1021af4 <submit_to_queue_locked>
 10220cc:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10220ce:	4816      	ldr	r0, [pc, #88]	; (1022128 <k_work_reschedule_for_queue+0xcc>)
 10220d0:	f7ff f80c 	bl	10210ec <z_spin_unlock_valid>
 10220d4:	b9d0      	cbnz	r0, 102210c <k_work_reschedule_for_queue+0xb0>
 10220d6:	23c2      	movs	r3, #194	; 0xc2
 10220d8:	4a14      	ldr	r2, [pc, #80]	; (102212c <k_work_reschedule_for_queue+0xd0>)
 10220da:	4917      	ldr	r1, [pc, #92]	; (1022138 <k_work_reschedule_for_queue+0xdc>)
 10220dc:	4810      	ldr	r0, [pc, #64]	; (1022120 <k_work_reschedule_for_queue+0xc4>)
 10220de:	f002 fd7a 	bl	1024bd6 <assert_print>
 10220e2:	4911      	ldr	r1, [pc, #68]	; (1022128 <k_work_reschedule_for_queue+0xcc>)
 10220e4:	4815      	ldr	r0, [pc, #84]	; (102213c <k_work_reschedule_for_queue+0xe0>)
 10220e6:	f002 fd76 	bl	1024bd6 <assert_print>
 10220ea:	21c2      	movs	r1, #194	; 0xc2
 10220ec:	e7df      	b.n	10220ae <k_work_reschedule_for_queue+0x52>
	*flagp |= BIT(bit);
 10220ee:	68e3      	ldr	r3, [r4, #12]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
 10220f0:	f104 0010 	add.w	r0, r4, #16
	*flagp |= BIT(bit);
 10220f4:	f043 0308 	orr.w	r3, r3, #8
 10220f8:	60e3      	str	r3, [r4, #12]
	dwork->queue = *queuep;
 10220fa:	9b01      	ldr	r3, [sp, #4]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
 10220fc:	4632      	mov	r2, r6
	dwork->queue = *queuep;
 10220fe:	62a3      	str	r3, [r4, #40]	; 0x28
	z_add_timeout(&dwork->timeout, work_timeout, delay);
 1022100:	490f      	ldr	r1, [pc, #60]	; (1022140 <k_work_reschedule_for_queue+0xe4>)
 1022102:	462b      	mov	r3, r5
 1022104:	f001 fb4c 	bl	10237a0 <z_add_timeout>
	return ret;
 1022108:	2401      	movs	r4, #1
 102210a:	e7e0      	b.n	10220ce <k_work_reschedule_for_queue+0x72>
	__asm__ volatile(
 102210c:	f387 8811 	msr	BASEPRI, r7
 1022110:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
 1022114:	4620      	mov	r0, r4
 1022116:	b003      	add	sp, #12
 1022118:	bdf0      	pop	{r4, r5, r6, r7, pc}
 102211a:	bf00      	nop
 102211c:	0102fafa 	.word	0x0102fafa
 1022120:	0102b695 	.word	0x0102b695
 1022124:	0102fa24 	.word	0x0102fa24
 1022128:	21008100 	.word	0x21008100
 102212c:	0102bd8a 	.word	0x0102bd8a
 1022130:	0102bde3 	.word	0x0102bde3
 1022134:	0102bdf8 	.word	0x0102bdf8
 1022138:	0102bdb7 	.word	0x0102bdb7
 102213c:	0102bdce 	.word	0x0102bdce
 1022140:	01021bcd 	.word	0x01021bcd

01022144 <k_work_reschedule>:

int k_work_reschedule(struct k_work_delayable *dwork,
				     k_timeout_t delay)
{
 1022144:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, reschedule, dwork, delay);

	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
 1022146:	4801      	ldr	r0, [pc, #4]	; (102214c <k_work_reschedule+0x8>)
 1022148:	f7ff bf88 	b.w	102205c <k_work_reschedule_for_queue>
 102214c:	21004510 	.word	0x21004510

01022150 <k_work_cancel_delayable>:

	return ret;
}

int k_work_cancel_delayable(struct k_work_delayable *dwork)
{
 1022150:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(dwork != NULL);
 1022152:	4604      	mov	r4, r0
 1022154:	b958      	cbnz	r0, 102216e <k_work_cancel_delayable+0x1e>
 1022156:	4922      	ldr	r1, [pc, #136]	; (10221e0 <k_work_cancel_delayable+0x90>)
 1022158:	4822      	ldr	r0, [pc, #136]	; (10221e4 <k_work_cancel_delayable+0x94>)
 102215a:	f240 33fd 	movw	r3, #1021	; 0x3fd
 102215e:	4a22      	ldr	r2, [pc, #136]	; (10221e8 <k_work_cancel_delayable+0x98>)
 1022160:	f002 fd39 	bl	1024bd6 <assert_print>
 1022164:	f240 31fd 	movw	r1, #1021	; 0x3fd
 1022168:	481f      	ldr	r0, [pc, #124]	; (10221e8 <k_work_cancel_delayable+0x98>)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 102216a:	f002 fd2d 	bl	1024bc8 <assert_post_action>
	__asm__ volatile(
 102216e:	f04f 0320 	mov.w	r3, #32
 1022172:	f3ef 8511 	mrs	r5, BASEPRI
 1022176:	f383 8812 	msr	BASEPRI_MAX, r3
 102217a:	f3bf 8f6f 	isb	sy
 102217e:	481b      	ldr	r0, [pc, #108]	; (10221ec <k_work_cancel_delayable+0x9c>)
 1022180:	f7fe ffa6 	bl	10210d0 <z_spin_lock_valid>
 1022184:	b960      	cbnz	r0, 10221a0 <k_work_cancel_delayable+0x50>
 1022186:	2394      	movs	r3, #148	; 0x94
 1022188:	4a19      	ldr	r2, [pc, #100]	; (10221f0 <k_work_cancel_delayable+0xa0>)
 102218a:	491a      	ldr	r1, [pc, #104]	; (10221f4 <k_work_cancel_delayable+0xa4>)
 102218c:	4815      	ldr	r0, [pc, #84]	; (10221e4 <k_work_cancel_delayable+0x94>)
 102218e:	f002 fd22 	bl	1024bd6 <assert_print>
 1022192:	4916      	ldr	r1, [pc, #88]	; (10221ec <k_work_cancel_delayable+0x9c>)
 1022194:	4818      	ldr	r0, [pc, #96]	; (10221f8 <k_work_cancel_delayable+0xa8>)
 1022196:	f002 fd1e 	bl	1024bd6 <assert_print>
 102219a:	2194      	movs	r1, #148	; 0x94
 102219c:	4814      	ldr	r0, [pc, #80]	; (10221f0 <k_work_cancel_delayable+0xa0>)
 102219e:	e7e4      	b.n	102216a <k_work_cancel_delayable+0x1a>
	z_spin_lock_set_owner(l);
 10221a0:	4812      	ldr	r0, [pc, #72]	; (10221ec <k_work_cancel_delayable+0x9c>)
 10221a2:	f7fe ffb1 	bl	1021108 <z_spin_lock_set_owner>
	(void)unschedule_locked(dwork);
 10221a6:	4620      	mov	r0, r4
 10221a8:	f007 f8d0 	bl	102934c <unschedule_locked>
	return cancel_async_locked(&dwork->work);
 10221ac:	4620      	mov	r0, r4
 10221ae:	f007 f8e2 	bl	1029376 <cancel_async_locked>
 10221b2:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10221b4:	480d      	ldr	r0, [pc, #52]	; (10221ec <k_work_cancel_delayable+0x9c>)
 10221b6:	f7fe ff99 	bl	10210ec <z_spin_unlock_valid>
 10221ba:	b958      	cbnz	r0, 10221d4 <k_work_cancel_delayable+0x84>
 10221bc:	23c2      	movs	r3, #194	; 0xc2
 10221be:	4a0c      	ldr	r2, [pc, #48]	; (10221f0 <k_work_cancel_delayable+0xa0>)
 10221c0:	490e      	ldr	r1, [pc, #56]	; (10221fc <k_work_cancel_delayable+0xac>)
 10221c2:	4808      	ldr	r0, [pc, #32]	; (10221e4 <k_work_cancel_delayable+0x94>)
 10221c4:	f002 fd07 	bl	1024bd6 <assert_print>
 10221c8:	4908      	ldr	r1, [pc, #32]	; (10221ec <k_work_cancel_delayable+0x9c>)
 10221ca:	480d      	ldr	r0, [pc, #52]	; (1022200 <k_work_cancel_delayable+0xb0>)
 10221cc:	f002 fd03 	bl	1024bd6 <assert_print>
 10221d0:	21c2      	movs	r1, #194	; 0xc2
 10221d2:	e7e3      	b.n	102219c <k_work_cancel_delayable+0x4c>
	__asm__ volatile(
 10221d4:	f385 8811 	msr	BASEPRI, r5
 10221d8:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable, dwork, ret);

	return ret;
}
 10221dc:	4620      	mov	r0, r4
 10221de:	bd38      	pop	{r3, r4, r5, pc}
 10221e0:	0102fafa 	.word	0x0102fafa
 10221e4:	0102b695 	.word	0x0102b695
 10221e8:	0102fa24 	.word	0x0102fa24
 10221ec:	21008100 	.word	0x21008100
 10221f0:	0102bd8a 	.word	0x0102bd8a
 10221f4:	0102bde3 	.word	0x0102bde3
 10221f8:	0102bdf8 	.word	0x0102bdf8
 10221fc:	0102bdb7 	.word	0x0102bdb7
 1022200:	0102bdce 	.word	0x0102bdce

01022204 <k_work_cancel_delayable_sync>:

bool k_work_cancel_delayable_sync(struct k_work_delayable *dwork,
				  struct k_work_sync *sync)
{
 1022204:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1022208:	460e      	mov	r6, r1
	__ASSERT_NO_MSG(dwork != NULL);
 102220a:	4605      	mov	r5, r0
 102220c:	b958      	cbnz	r0, 1022226 <k_work_cancel_delayable_sync+0x22>
 102220e:	493a      	ldr	r1, [pc, #232]	; (10222f8 <k_work_cancel_delayable_sync+0xf4>)
 1022210:	f240 430e 	movw	r3, #1038	; 0x40e
 1022214:	4a39      	ldr	r2, [pc, #228]	; (10222fc <k_work_cancel_delayable_sync+0xf8>)
 1022216:	483a      	ldr	r0, [pc, #232]	; (1022300 <k_work_cancel_delayable_sync+0xfc>)
 1022218:	f002 fcdd 	bl	1024bd6 <assert_print>
 102221c:	f240 410e 	movw	r1, #1038	; 0x40e
	__ASSERT_NO_MSG(sync != NULL);
 1022220:	4836      	ldr	r0, [pc, #216]	; (10222fc <k_work_cancel_delayable_sync+0xf8>)
 1022222:	f002 fcd1 	bl	1024bc8 <assert_post_action>
 1022226:	b949      	cbnz	r1, 102223c <k_work_cancel_delayable_sync+0x38>
 1022228:	4936      	ldr	r1, [pc, #216]	; (1022304 <k_work_cancel_delayable_sync+0x100>)
 102222a:	f240 430f 	movw	r3, #1039	; 0x40f
 102222e:	4a33      	ldr	r2, [pc, #204]	; (10222fc <k_work_cancel_delayable_sync+0xf8>)
 1022230:	4833      	ldr	r0, [pc, #204]	; (1022300 <k_work_cancel_delayable_sync+0xfc>)
 1022232:	f002 fcd0 	bl	1024bd6 <assert_print>
 1022236:	f240 410f 	movw	r1, #1039	; 0x40f
 102223a:	e7f1      	b.n	1022220 <k_work_cancel_delayable_sync+0x1c>
	__ASSERT_NO_MSG(!k_is_in_isr());
 102223c:	f007 f821 	bl	1029282 <k_is_in_isr>
 1022240:	4604      	mov	r4, r0
 1022242:	b148      	cbz	r0, 1022258 <k_work_cancel_delayable_sync+0x54>
 1022244:	4930      	ldr	r1, [pc, #192]	; (1022308 <k_work_cancel_delayable_sync+0x104>)
 1022246:	f44f 6382 	mov.w	r3, #1040	; 0x410
 102224a:	4a2c      	ldr	r2, [pc, #176]	; (10222fc <k_work_cancel_delayable_sync+0xf8>)
 102224c:	482c      	ldr	r0, [pc, #176]	; (1022300 <k_work_cancel_delayable_sync+0xfc>)
 102224e:	f002 fcc2 	bl	1024bd6 <assert_print>
 1022252:	f44f 6182 	mov.w	r1, #1040	; 0x410
 1022256:	e7e3      	b.n	1022220 <k_work_cancel_delayable_sync+0x1c>
	__asm__ volatile(
 1022258:	f04f 0320 	mov.w	r3, #32
 102225c:	f3ef 8811 	mrs	r8, BASEPRI
 1022260:	f383 8812 	msr	BASEPRI_MAX, r3
 1022264:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1022268:	4828      	ldr	r0, [pc, #160]	; (102230c <k_work_cancel_delayable_sync+0x108>)
 102226a:	f7fe ff31 	bl	10210d0 <z_spin_lock_valid>
 102226e:	b960      	cbnz	r0, 102228a <k_work_cancel_delayable_sync+0x86>
 1022270:	2394      	movs	r3, #148	; 0x94
 1022272:	4a27      	ldr	r2, [pc, #156]	; (1022310 <k_work_cancel_delayable_sync+0x10c>)
 1022274:	4927      	ldr	r1, [pc, #156]	; (1022314 <k_work_cancel_delayable_sync+0x110>)
 1022276:	4822      	ldr	r0, [pc, #136]	; (1022300 <k_work_cancel_delayable_sync+0xfc>)
 1022278:	f002 fcad 	bl	1024bd6 <assert_print>
 102227c:	4923      	ldr	r1, [pc, #140]	; (102230c <k_work_cancel_delayable_sync+0x108>)
 102227e:	4826      	ldr	r0, [pc, #152]	; (1022318 <k_work_cancel_delayable_sync+0x114>)
 1022280:	f002 fca9 	bl	1024bd6 <assert_print>
 1022284:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022286:	4822      	ldr	r0, [pc, #136]	; (1022310 <k_work_cancel_delayable_sync+0x10c>)
 1022288:	e7cb      	b.n	1022222 <k_work_cancel_delayable_sync+0x1e>
	z_spin_lock_set_owner(l);
 102228a:	4820      	ldr	r0, [pc, #128]	; (102230c <k_work_cancel_delayable_sync+0x108>)
 102228c:	f7fe ff3c 	bl	1021108 <z_spin_lock_set_owner>
	return *flagp;
 1022290:	68eb      	ldr	r3, [r5, #12]
 1022292:	f003 030f 	and.w	r3, r3, #15

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_delayable_sync, dwork, sync);

	struct z_work_canceller *canceller = &sync->canceller;
	k_spinlock_key_t key = k_spin_lock(&lock);
	bool pending = (work_delayable_busy_get_locked(dwork) != 0U);
 1022296:	2b00      	cmp	r3, #0
 1022298:	bf14      	ite	ne
 102229a:	2701      	movne	r7, #1
 102229c:	2700      	moveq	r7, #0
	bool need_wait = false;

	if (pending) {
 102229e:	d00a      	beq.n	10222b6 <k_work_cancel_delayable_sync+0xb2>
	(void)unschedule_locked(dwork);
 10222a0:	4628      	mov	r0, r5
 10222a2:	f007 f853 	bl	102934c <unschedule_locked>
	return cancel_async_locked(&dwork->work);
 10222a6:	4628      	mov	r0, r5
 10222a8:	f007 f865 	bl	1029376 <cancel_async_locked>
		(void)cancel_delayable_async_locked(dwork);
		need_wait = cancel_sync_locked(&dwork->work, canceller);
 10222ac:	4631      	mov	r1, r6
 10222ae:	4628      	mov	r0, r5
 10222b0:	f7ff fc02 	bl	1021ab8 <cancel_sync_locked>
 10222b4:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10222b6:	4815      	ldr	r0, [pc, #84]	; (102230c <k_work_cancel_delayable_sync+0x108>)
 10222b8:	f7fe ff18 	bl	10210ec <z_spin_unlock_valid>
 10222bc:	b958      	cbnz	r0, 10222d6 <k_work_cancel_delayable_sync+0xd2>
 10222be:	23c2      	movs	r3, #194	; 0xc2
 10222c0:	4a13      	ldr	r2, [pc, #76]	; (1022310 <k_work_cancel_delayable_sync+0x10c>)
 10222c2:	4916      	ldr	r1, [pc, #88]	; (102231c <k_work_cancel_delayable_sync+0x118>)
 10222c4:	480e      	ldr	r0, [pc, #56]	; (1022300 <k_work_cancel_delayable_sync+0xfc>)
 10222c6:	f002 fc86 	bl	1024bd6 <assert_print>
 10222ca:	4910      	ldr	r1, [pc, #64]	; (102230c <k_work_cancel_delayable_sync+0x108>)
 10222cc:	4814      	ldr	r0, [pc, #80]	; (1022320 <k_work_cancel_delayable_sync+0x11c>)
 10222ce:	f002 fc82 	bl	1024bd6 <assert_print>
 10222d2:	21c2      	movs	r1, #194	; 0xc2
 10222d4:	e7d7      	b.n	1022286 <k_work_cancel_delayable_sync+0x82>
	__asm__ volatile(
 10222d6:	f388 8811 	msr	BASEPRI, r8
 10222da:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&lock, key);

	if (need_wait) {
 10222de:	b13c      	cbz	r4, 10222f0 <k_work_cancel_delayable_sync+0xec>
	return z_impl_k_sem_take(sem, timeout);
 10222e0:	f04f 32ff 	mov.w	r2, #4294967295
 10222e4:	f04f 33ff 	mov.w	r3, #4294967295
 10222e8:	f106 0008 	add.w	r0, r6, #8
 10222ec:	f7ff fa1c 	bl	1021728 <z_impl_k_sem_take>
		k_sem_take(&canceller->sem, K_FOREVER);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable_sync, dwork, sync, pending);
	return pending;
}
 10222f0:	4638      	mov	r0, r7
 10222f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 10222f6:	bf00      	nop
 10222f8:	0102fafa 	.word	0x0102fafa
 10222fc:	0102fa24 	.word	0x0102fa24
 1022300:	0102b695 	.word	0x0102b695
 1022304:	0102faa6 	.word	0x0102faa6
 1022308:	0102db94 	.word	0x0102db94
 102230c:	21008100 	.word	0x21008100
 1022310:	0102bd8a 	.word	0x0102bd8a
 1022314:	0102bde3 	.word	0x0102bde3
 1022318:	0102bdf8 	.word	0x0102bdf8
 102231c:	0102bdb7 	.word	0x0102bdb7
 1022320:	0102bdce 	.word	0x0102bdce

01022324 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(struct k_thread *curr)
{
 1022324:	b538      	push	{r3, r4, r5, lr}
	int ret = slice_ticks;
 1022326:	4d07      	ldr	r5, [pc, #28]	; (1022344 <z_reset_time_slice+0x20>)
 1022328:	682c      	ldr	r4, [r5, #0]
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time(curr) != 0) {
 102232a:	b154      	cbz	r4, 1022342 <z_reset_time_slice+0x1e>
		_current_cpu->slice_ticks = slice_time(curr) + sys_clock_elapsed();
 102232c:	f7fd fa6a 	bl	101f804 <sys_clock_elapsed>
 1022330:	4b05      	ldr	r3, [pc, #20]	; (1022348 <z_reset_time_slice+0x24>)
 1022332:	4404      	add	r4, r0
 1022334:	611c      	str	r4, [r3, #16]
		z_set_timeout_expiry(slice_time(curr), false);
 1022336:	6828      	ldr	r0, [r5, #0]
 1022338:	2100      	movs	r1, #0
	}
}
 102233a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_set_timeout_expiry(slice_time(curr), false);
 102233e:	f001 bb41 	b.w	10239c4 <z_set_timeout_expiry>
}
 1022342:	bd38      	pop	{r3, r4, r5, pc}
 1022344:	2100810c 	.word	0x2100810c
 1022348:	210080cc 	.word	0x210080cc

0102234c <update_cache>:
	}
#endif
}

static void update_cache(int preempt_ok)
{
 102234c:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
 102234e:	4d14      	ldr	r5, [pc, #80]	; (10223a0 <update_cache+0x54>)
 1022350:	462b      	mov	r3, r5
 1022352:	f853 4f1c 	ldr.w	r4, [r3, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1022356:	429c      	cmp	r4, r3
 1022358:	d000      	beq.n	102235c <update_cache+0x10>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 102235a:	b904      	cbnz	r4, 102235e <update_cache+0x12>
 102235c:	68ec      	ldr	r4, [r5, #12]
	__ASSERT(_current != NULL, "");
 102235e:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
 1022360:	b9a8      	cbnz	r0, 102238e <update_cache+0x42>
	__ASSERT(_current != NULL, "");
 1022362:	b963      	cbnz	r3, 102237e <update_cache+0x32>
 1022364:	490f      	ldr	r1, [pc, #60]	; (10223a4 <update_cache+0x58>)
 1022366:	2389      	movs	r3, #137	; 0x89
 1022368:	4a0f      	ldr	r2, [pc, #60]	; (10223a8 <update_cache+0x5c>)
 102236a:	4810      	ldr	r0, [pc, #64]	; (10223ac <update_cache+0x60>)
 102236c:	f002 fc33 	bl	1024bd6 <assert_print>
 1022370:	480f      	ldr	r0, [pc, #60]	; (10223b0 <update_cache+0x64>)
 1022372:	f002 fc30 	bl	1024bd6 <assert_print>
 1022376:	2189      	movs	r1, #137	; 0x89
 1022378:	480b      	ldr	r0, [pc, #44]	; (10223a8 <update_cache+0x5c>)
 102237a:	f002 fc25 	bl	1024bc8 <assert_post_action>
	if (z_is_thread_prevented_from_running(_current)) {
 102237e:	7b5a      	ldrb	r2, [r3, #13]
 1022380:	06d2      	lsls	r2, r2, #27
 1022382:	d104      	bne.n	102238e <update_cache+0x42>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 1022384:	69a2      	ldr	r2, [r4, #24]
 1022386:	b912      	cbnz	r2, 102238e <update_cache+0x42>
	if (is_preempt(_current) || is_metairq(thread)) {
 1022388:	89da      	ldrh	r2, [r3, #14]
 102238a:	2a7f      	cmp	r2, #127	; 0x7f
 102238c:	d805      	bhi.n	102239a <update_cache+0x4e>
#ifndef CONFIG_SMP
	struct k_thread *thread = next_up();

	if (should_preempt(thread, preempt_ok)) {
#ifdef CONFIG_TIMESLICING
		if (thread != _current) {
 102238e:	429c      	cmp	r4, r3
 1022390:	d002      	beq.n	1022398 <update_cache+0x4c>
			z_reset_time_slice(thread);
 1022392:	4620      	mov	r0, r4
 1022394:	f7ff ffc6 	bl	1022324 <z_reset_time_slice>
		}
#endif
		update_metairq_preempt(thread);
		_kernel.ready_q.cache = thread;
 1022398:	4623      	mov	r3, r4
 102239a:	61ab      	str	r3, [r5, #24]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
 102239c:	bd38      	pop	{r3, r4, r5, pc}
 102239e:	bf00      	nop
 10223a0:	210080cc 	.word	0x210080cc
 10223a4:	0102fb31 	.word	0x0102fb31
 10223a8:	0102fb0f 	.word	0x0102fb0f
 10223ac:	0102b695 	.word	0x0102b695
 10223b0:	0102ee84 	.word	0x0102ee84

010223b4 <ready_thread>:
	}
#endif
}

static void ready_thread(struct k_thread *thread)
{
 10223b4:	b570      	push	{r4, r5, r6, lr}
#endif

	/* If thread is queued already, do not try and added it to the
	 * run queue again
	 */
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 10223b6:	f990 300d 	ldrsb.w	r3, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
 10223ba:	7b42      	ldrb	r2, [r0, #13]
 10223bc:	2b00      	cmp	r3, #0
 10223be:	db38      	blt.n	1022432 <ready_thread+0x7e>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 10223c0:	06d3      	lsls	r3, r2, #27
 10223c2:	d136      	bne.n	1022432 <ready_thread+0x7e>
	return node->next != NULL;
 10223c4:	6983      	ldr	r3, [r0, #24]
 10223c6:	2b00      	cmp	r3, #0
 10223c8:	d133      	bne.n	1022432 <ready_thread+0x7e>
	thread->base.thread_state |= _THREAD_QUEUED;
 10223ca:	f062 027f 	orn	r2, r2, #127	; 0x7f
 10223ce:	7342      	strb	r2, [r0, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
 10223d0:	4a18      	ldr	r2, [pc, #96]	; (1022434 <ready_thread+0x80>)
 10223d2:	4290      	cmp	r0, r2
 10223d4:	d109      	bne.n	10223ea <ready_thread+0x36>
 10223d6:	4918      	ldr	r1, [pc, #96]	; (1022438 <ready_thread+0x84>)
 10223d8:	4818      	ldr	r0, [pc, #96]	; (102243c <ready_thread+0x88>)
 10223da:	23ba      	movs	r3, #186	; 0xba
 10223dc:	4a18      	ldr	r2, [pc, #96]	; (1022440 <ready_thread+0x8c>)
 10223de:	f002 fbfa 	bl	1024bd6 <assert_print>
 10223e2:	21ba      	movs	r1, #186	; 0xba
 10223e4:	4816      	ldr	r0, [pc, #88]	; (1022440 <ready_thread+0x8c>)
 10223e6:	f002 fbef 	bl	1024bc8 <assert_post_action>
	return list->head == list;
 10223ea:	4916      	ldr	r1, [pc, #88]	; (1022444 <ready_thread+0x90>)
 10223ec:	460a      	mov	r2, r1
 10223ee:	f852 4f1c 	ldr.w	r4, [r2, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
 10223f2:	4294      	cmp	r4, r2
 10223f4:	bf18      	it	ne
 10223f6:	4623      	movne	r3, r4
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
 10223f8:	6a0c      	ldr	r4, [r1, #32]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 10223fa:	b923      	cbnz	r3, 1022406 <ready_thread+0x52>
static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;

	node->next = list;
	node->prev = tail;
 10223fc:	e9c0 2400 	strd	r2, r4, [r0]

	tail->next = node;
 1022400:	6020      	str	r0, [r4, #0]
	list->tail = node;
 1022402:	6208      	str	r0, [r1, #32]
}
 1022404:	e00c      	b.n	1022420 <ready_thread+0x6c>
	int32_t b1 = thread_1->base.prio;
 1022406:	f990 500e 	ldrsb.w	r5, [r0, #14]
	int32_t b2 = thread_2->base.prio;
 102240a:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
 102240e:	42b5      	cmp	r5, r6
 1022410:	d00b      	beq.n	102242a <ready_thread+0x76>
		if (z_sched_prio_cmp(thread, t) > 0) {
 1022412:	42ae      	cmp	r6, r5
 1022414:	dd09      	ble.n	102242a <ready_thread+0x76>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
 1022416:	685a      	ldr	r2, [r3, #4]

	node->prev = prev;
	node->next = successor;
 1022418:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
 102241c:	6010      	str	r0, [r2, #0]
	successor->prev = node;
 102241e:	6058      	str	r0, [r3, #4]
		SYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_ready, thread);

		queue_thread(thread);
		update_cache(0);
 1022420:	2000      	movs	r0, #0
		flag_ipi();
	}
}
 1022422:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		update_cache(0);
 1022426:	f7ff bf91 	b.w	102234c <update_cache>
	return (node == list->tail) ? NULL : node->next;
 102242a:	42a3      	cmp	r3, r4
 102242c:	d0e6      	beq.n	10223fc <ready_thread+0x48>
 102242e:	681b      	ldr	r3, [r3, #0]
 1022430:	e7e3      	b.n	10223fa <ready_thread+0x46>
}
 1022432:	bd70      	pop	{r4, r5, r6, pc}
 1022434:	21004410 	.word	0x21004410
 1022438:	0102fb58 	.word	0x0102fb58
 102243c:	0102b695 	.word	0x0102b695
 1022440:	0102fb0f 	.word	0x0102fb0f
 1022444:	210080cc 	.word	0x210080cc

01022448 <k_sched_time_slice_set>:
{
 1022448:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 102244a:	4604      	mov	r4, r0
 102244c:	460d      	mov	r5, r1
	__asm__ volatile(
 102244e:	f04f 0320 	mov.w	r3, #32
 1022452:	f3ef 8711 	mrs	r7, BASEPRI
 1022456:	f383 8812 	msr	BASEPRI_MAX, r3
 102245a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 102245e:	4822      	ldr	r0, [pc, #136]	; (10224e8 <k_sched_time_slice_set+0xa0>)
 1022460:	f7fe fe36 	bl	10210d0 <z_spin_lock_valid>
 1022464:	b968      	cbnz	r0, 1022482 <k_sched_time_slice_set+0x3a>
 1022466:	2394      	movs	r3, #148	; 0x94
 1022468:	4a20      	ldr	r2, [pc, #128]	; (10224ec <k_sched_time_slice_set+0xa4>)
 102246a:	4921      	ldr	r1, [pc, #132]	; (10224f0 <k_sched_time_slice_set+0xa8>)
 102246c:	4821      	ldr	r0, [pc, #132]	; (10224f4 <k_sched_time_slice_set+0xac>)
 102246e:	f002 fbb2 	bl	1024bd6 <assert_print>
 1022472:	491d      	ldr	r1, [pc, #116]	; (10224e8 <k_sched_time_slice_set+0xa0>)
 1022474:	4820      	ldr	r0, [pc, #128]	; (10224f8 <k_sched_time_slice_set+0xb0>)
 1022476:	f002 fbae 	bl	1024bd6 <assert_print>
 102247a:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 102247c:	481b      	ldr	r0, [pc, #108]	; (10224ec <k_sched_time_slice_set+0xa4>)
 102247e:	f002 fba3 	bl	1024bc8 <assert_post_action>
			return (uint32_t)((t * to_hz + off) / from_hz);
 1022482:	2600      	movs	r6, #0
	z_spin_lock_set_owner(l);
 1022484:	4818      	ldr	r0, [pc, #96]	; (10224e8 <k_sched_time_slice_set+0xa0>)
 1022486:	f7fe fe3f 	bl	1021108 <z_spin_lock_set_owner>
 102248a:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
 102248e:	f240 30e7 	movw	r0, #999	; 0x3e7
 1022492:	4631      	mov	r1, r6
 1022494:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 1022498:	2300      	movs	r3, #0
 102249a:	fbe4 010c 	umlal	r0, r1, r4, ip
 102249e:	f7dd fe0b 	bl	10000b8 <__aeabi_uldivmod>
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
 10224a2:	42b4      	cmp	r4, r6
 10224a4:	dd02      	ble.n	10224ac <k_sched_time_slice_set+0x64>
			slice_ticks = MAX(2, slice_ticks);
 10224a6:	2802      	cmp	r0, #2
 10224a8:	bfb8      	it	lt
 10224aa:	2002      	movlt	r0, #2
		slice_ticks = k_ms_to_ticks_ceil32(slice);
 10224ac:	4a13      	ldr	r2, [pc, #76]	; (10224fc <k_sched_time_slice_set+0xb4>)
		_current_cpu->slice_ticks = 0;
 10224ae:	4b14      	ldr	r3, [pc, #80]	; (1022500 <k_sched_time_slice_set+0xb8>)
		slice_ticks = k_ms_to_ticks_ceil32(slice);
 10224b0:	6010      	str	r0, [r2, #0]
		slice_max_prio = prio;
 10224b2:	4a14      	ldr	r2, [pc, #80]	; (1022504 <k_sched_time_slice_set+0xbc>)
		z_reset_time_slice(_current);
 10224b4:	6898      	ldr	r0, [r3, #8]
		_current_cpu->slice_ticks = 0;
 10224b6:	611e      	str	r6, [r3, #16]
		slice_max_prio = prio;
 10224b8:	6015      	str	r5, [r2, #0]
		z_reset_time_slice(_current);
 10224ba:	f7ff ff33 	bl	1022324 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10224be:	480a      	ldr	r0, [pc, #40]	; (10224e8 <k_sched_time_slice_set+0xa0>)
 10224c0:	f7fe fe14 	bl	10210ec <z_spin_unlock_valid>
 10224c4:	b958      	cbnz	r0, 10224de <k_sched_time_slice_set+0x96>
 10224c6:	23c2      	movs	r3, #194	; 0xc2
 10224c8:	4a08      	ldr	r2, [pc, #32]	; (10224ec <k_sched_time_slice_set+0xa4>)
 10224ca:	490f      	ldr	r1, [pc, #60]	; (1022508 <k_sched_time_slice_set+0xc0>)
 10224cc:	4809      	ldr	r0, [pc, #36]	; (10224f4 <k_sched_time_slice_set+0xac>)
 10224ce:	f002 fb82 	bl	1024bd6 <assert_print>
 10224d2:	4905      	ldr	r1, [pc, #20]	; (10224e8 <k_sched_time_slice_set+0xa0>)
 10224d4:	480d      	ldr	r0, [pc, #52]	; (102250c <k_sched_time_slice_set+0xc4>)
 10224d6:	f002 fb7e 	bl	1024bd6 <assert_print>
 10224da:	21c2      	movs	r1, #194	; 0xc2
 10224dc:	e7ce      	b.n	102247c <k_sched_time_slice_set+0x34>
	__asm__ volatile(
 10224de:	f387 8811 	msr	BASEPRI, r7
 10224e2:	f3bf 8f6f 	isb	sy
}
 10224e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 10224e8:	21008110 	.word	0x21008110
 10224ec:	0102bd8a 	.word	0x0102bd8a
 10224f0:	0102bde3 	.word	0x0102bde3
 10224f4:	0102b695 	.word	0x0102b695
 10224f8:	0102bdf8 	.word	0x0102bdf8
 10224fc:	2100810c 	.word	0x2100810c
 1022500:	210080cc 	.word	0x210080cc
 1022504:	21008108 	.word	0x21008108
 1022508:	0102bdb7 	.word	0x0102bdb7
 102250c:	0102bdce 	.word	0x0102bdce

01022510 <z_ready_thread>:

void z_ready_thread(struct k_thread *thread)
{
 1022510:	b538      	push	{r3, r4, r5, lr}
 1022512:	4604      	mov	r4, r0
	__asm__ volatile(
 1022514:	f04f 0320 	mov.w	r3, #32
 1022518:	f3ef 8511 	mrs	r5, BASEPRI
 102251c:	f383 8812 	msr	BASEPRI_MAX, r3
 1022520:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1022524:	4816      	ldr	r0, [pc, #88]	; (1022580 <z_ready_thread+0x70>)
 1022526:	f7fe fdd3 	bl	10210d0 <z_spin_lock_valid>
 102252a:	b968      	cbnz	r0, 1022548 <z_ready_thread+0x38>
 102252c:	2394      	movs	r3, #148	; 0x94
 102252e:	4a15      	ldr	r2, [pc, #84]	; (1022584 <z_ready_thread+0x74>)
 1022530:	4915      	ldr	r1, [pc, #84]	; (1022588 <z_ready_thread+0x78>)
 1022532:	4816      	ldr	r0, [pc, #88]	; (102258c <z_ready_thread+0x7c>)
 1022534:	f002 fb4f 	bl	1024bd6 <assert_print>
 1022538:	4911      	ldr	r1, [pc, #68]	; (1022580 <z_ready_thread+0x70>)
 102253a:	4815      	ldr	r0, [pc, #84]	; (1022590 <z_ready_thread+0x80>)
 102253c:	f002 fb4b 	bl	1024bd6 <assert_print>
 1022540:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022542:	4810      	ldr	r0, [pc, #64]	; (1022584 <z_ready_thread+0x74>)
 1022544:	f002 fb40 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1022548:	480d      	ldr	r0, [pc, #52]	; (1022580 <z_ready_thread+0x70>)
 102254a:	f7fe fddd 	bl	1021108 <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		if (!thread_active_elsewhere(thread)) {
			ready_thread(thread);
 102254e:	4620      	mov	r0, r4
 1022550:	f7ff ff30 	bl	10223b4 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022554:	480a      	ldr	r0, [pc, #40]	; (1022580 <z_ready_thread+0x70>)
 1022556:	f7fe fdc9 	bl	10210ec <z_spin_unlock_valid>
 102255a:	b958      	cbnz	r0, 1022574 <z_ready_thread+0x64>
 102255c:	23c2      	movs	r3, #194	; 0xc2
 102255e:	4a09      	ldr	r2, [pc, #36]	; (1022584 <z_ready_thread+0x74>)
 1022560:	490c      	ldr	r1, [pc, #48]	; (1022594 <z_ready_thread+0x84>)
 1022562:	480a      	ldr	r0, [pc, #40]	; (102258c <z_ready_thread+0x7c>)
 1022564:	f002 fb37 	bl	1024bd6 <assert_print>
 1022568:	4905      	ldr	r1, [pc, #20]	; (1022580 <z_ready_thread+0x70>)
 102256a:	480b      	ldr	r0, [pc, #44]	; (1022598 <z_ready_thread+0x88>)
 102256c:	f002 fb33 	bl	1024bd6 <assert_print>
 1022570:	21c2      	movs	r1, #194	; 0xc2
 1022572:	e7e6      	b.n	1022542 <z_ready_thread+0x32>
	__asm__ volatile(
 1022574:	f385 8811 	msr	BASEPRI, r5
 1022578:	f3bf 8f6f 	isb	sy
		}
	}
}
 102257c:	bd38      	pop	{r3, r4, r5, pc}
 102257e:	bf00      	nop
 1022580:	21008110 	.word	0x21008110
 1022584:	0102bd8a 	.word	0x0102bd8a
 1022588:	0102bde3 	.word	0x0102bde3
 102258c:	0102b695 	.word	0x0102b695
 1022590:	0102bdf8 	.word	0x0102bdf8
 1022594:	0102bdb7 	.word	0x0102bdb7
 1022598:	0102bdce 	.word	0x0102bdce

0102259c <z_unpend_thread_no_timeout>:
	z_mark_thread_as_not_pending(thread);
	thread->base.pended_on = NULL;
}

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
 102259c:	b538      	push	{r3, r4, r5, lr}
 102259e:	4604      	mov	r4, r0
	__asm__ volatile(
 10225a0:	f04f 0320 	mov.w	r3, #32
 10225a4:	f3ef 8511 	mrs	r5, BASEPRI
 10225a8:	f383 8812 	msr	BASEPRI_MAX, r3
 10225ac:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10225b0:	4816      	ldr	r0, [pc, #88]	; (102260c <z_unpend_thread_no_timeout+0x70>)
 10225b2:	f7fe fd8d 	bl	10210d0 <z_spin_lock_valid>
 10225b6:	b968      	cbnz	r0, 10225d4 <z_unpend_thread_no_timeout+0x38>
 10225b8:	2394      	movs	r3, #148	; 0x94
 10225ba:	4a15      	ldr	r2, [pc, #84]	; (1022610 <z_unpend_thread_no_timeout+0x74>)
 10225bc:	4915      	ldr	r1, [pc, #84]	; (1022614 <z_unpend_thread_no_timeout+0x78>)
 10225be:	4816      	ldr	r0, [pc, #88]	; (1022618 <z_unpend_thread_no_timeout+0x7c>)
 10225c0:	f002 fb09 	bl	1024bd6 <assert_print>
 10225c4:	4911      	ldr	r1, [pc, #68]	; (102260c <z_unpend_thread_no_timeout+0x70>)
 10225c6:	4815      	ldr	r0, [pc, #84]	; (102261c <z_unpend_thread_no_timeout+0x80>)
 10225c8:	f002 fb05 	bl	1024bd6 <assert_print>
 10225cc:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10225ce:	4810      	ldr	r0, [pc, #64]	; (1022610 <z_unpend_thread_no_timeout+0x74>)
 10225d0:	f002 fafa 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 10225d4:	480d      	ldr	r0, [pc, #52]	; (102260c <z_unpend_thread_no_timeout+0x70>)
 10225d6:	f7fe fd97 	bl	1021108 <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		unpend_thread_no_timeout(thread);
 10225da:	4620      	mov	r0, r4
 10225dc:	f000 fc62 	bl	1022ea4 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10225e0:	480a      	ldr	r0, [pc, #40]	; (102260c <z_unpend_thread_no_timeout+0x70>)
 10225e2:	f7fe fd83 	bl	10210ec <z_spin_unlock_valid>
 10225e6:	b958      	cbnz	r0, 1022600 <z_unpend_thread_no_timeout+0x64>
 10225e8:	23c2      	movs	r3, #194	; 0xc2
 10225ea:	4a09      	ldr	r2, [pc, #36]	; (1022610 <z_unpend_thread_no_timeout+0x74>)
 10225ec:	490c      	ldr	r1, [pc, #48]	; (1022620 <z_unpend_thread_no_timeout+0x84>)
 10225ee:	480a      	ldr	r0, [pc, #40]	; (1022618 <z_unpend_thread_no_timeout+0x7c>)
 10225f0:	f002 faf1 	bl	1024bd6 <assert_print>
 10225f4:	4905      	ldr	r1, [pc, #20]	; (102260c <z_unpend_thread_no_timeout+0x70>)
 10225f6:	480b      	ldr	r0, [pc, #44]	; (1022624 <z_unpend_thread_no_timeout+0x88>)
 10225f8:	f002 faed 	bl	1024bd6 <assert_print>
 10225fc:	21c2      	movs	r1, #194	; 0xc2
 10225fe:	e7e6      	b.n	10225ce <z_unpend_thread_no_timeout+0x32>
	__asm__ volatile(
 1022600:	f385 8811 	msr	BASEPRI, r5
 1022604:	f3bf 8f6f 	isb	sy
	}
}
 1022608:	bd38      	pop	{r3, r4, r5, pc}
 102260a:	bf00      	nop
 102260c:	21008110 	.word	0x21008110
 1022610:	0102bd8a 	.word	0x0102bd8a
 1022614:	0102bde3 	.word	0x0102bde3
 1022618:	0102b695 	.word	0x0102b695
 102261c:	0102bdf8 	.word	0x0102bdf8
 1022620:	0102bdb7 	.word	0x0102bdb7
 1022624:	0102bdce 	.word	0x0102bdce

01022628 <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
 1022628:	b570      	push	{r4, r5, r6, lr}
 102262a:	4604      	mov	r4, r0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
 102262c:	460d      	mov	r5, r1
 102262e:	b9e9      	cbnz	r1, 102266c <z_reschedule+0x44>
 1022630:	f3ef 8605 	mrs	r6, IPSR
 1022634:	b9d6      	cbnz	r6, 102266c <z_reschedule+0x44>
	new_thread = _kernel.ready_q.cache;
 1022636:	4b18      	ldr	r3, [pc, #96]	; (1022698 <z_reschedule+0x70>)
	if (resched(key.key) && need_swap()) {
 1022638:	699a      	ldr	r2, [r3, #24]
 102263a:	689b      	ldr	r3, [r3, #8]
 102263c:	429a      	cmp	r2, r3
 102263e:	d015      	beq.n	102266c <z_reschedule+0x44>
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022640:	f7fe fd54 	bl	10210ec <z_spin_unlock_valid>
 1022644:	b968      	cbnz	r0, 1022662 <z_reschedule+0x3a>
 1022646:	23e1      	movs	r3, #225	; 0xe1
 1022648:	4a14      	ldr	r2, [pc, #80]	; (102269c <z_reschedule+0x74>)
 102264a:	4915      	ldr	r1, [pc, #84]	; (10226a0 <z_reschedule+0x78>)
 102264c:	4815      	ldr	r0, [pc, #84]	; (10226a4 <z_reschedule+0x7c>)
 102264e:	f002 fac2 	bl	1024bd6 <assert_print>
 1022652:	4621      	mov	r1, r4
 1022654:	4814      	ldr	r0, [pc, #80]	; (10226a8 <z_reschedule+0x80>)
 1022656:	f002 fabe 	bl	1024bd6 <assert_print>
 102265a:	21e1      	movs	r1, #225	; 0xe1
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 102265c:	480f      	ldr	r0, [pc, #60]	; (102269c <z_reschedule+0x74>)
 102265e:	f002 fab3 	bl	1024bc8 <assert_post_action>
	ret = arch_swap(key);
 1022662:	4630      	mov	r0, r6
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
		signal_pending_ipi();
	}
}
 1022664:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 1022668:	f7e3 bc3a 	b.w	1005ee0 <arch_swap>
 102266c:	4620      	mov	r0, r4
 102266e:	f7fe fd3d 	bl	10210ec <z_spin_unlock_valid>
 1022672:	b958      	cbnz	r0, 102268c <z_reschedule+0x64>
 1022674:	23c2      	movs	r3, #194	; 0xc2
 1022676:	4a09      	ldr	r2, [pc, #36]	; (102269c <z_reschedule+0x74>)
 1022678:	4909      	ldr	r1, [pc, #36]	; (10226a0 <z_reschedule+0x78>)
 102267a:	480a      	ldr	r0, [pc, #40]	; (10226a4 <z_reschedule+0x7c>)
 102267c:	f002 faab 	bl	1024bd6 <assert_print>
 1022680:	4621      	mov	r1, r4
 1022682:	4809      	ldr	r0, [pc, #36]	; (10226a8 <z_reschedule+0x80>)
 1022684:	f002 faa7 	bl	1024bd6 <assert_print>
 1022688:	21c2      	movs	r1, #194	; 0xc2
 102268a:	e7e7      	b.n	102265c <z_reschedule+0x34>
 102268c:	f385 8811 	msr	BASEPRI, r5
 1022690:	f3bf 8f6f 	isb	sy
 1022694:	bd70      	pop	{r4, r5, r6, pc}
 1022696:	bf00      	nop
 1022698:	210080cc 	.word	0x210080cc
 102269c:	0102bd8a 	.word	0x0102bd8a
 10226a0:	0102bdb7 	.word	0x0102bdb7
 10226a4:	0102b695 	.word	0x0102b695
 10226a8:	0102bdce 	.word	0x0102bdce

010226ac <z_sched_start>:
{
 10226ac:	b538      	push	{r3, r4, r5, lr}
 10226ae:	4604      	mov	r4, r0
	__asm__ volatile(
 10226b0:	f04f 0320 	mov.w	r3, #32
 10226b4:	f3ef 8511 	mrs	r5, BASEPRI
 10226b8:	f383 8812 	msr	BASEPRI_MAX, r3
 10226bc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10226c0:	481c      	ldr	r0, [pc, #112]	; (1022734 <z_sched_start+0x88>)
 10226c2:	f7fe fd05 	bl	10210d0 <z_spin_lock_valid>
 10226c6:	b968      	cbnz	r0, 10226e4 <z_sched_start+0x38>
 10226c8:	2394      	movs	r3, #148	; 0x94
 10226ca:	4a1b      	ldr	r2, [pc, #108]	; (1022738 <z_sched_start+0x8c>)
 10226cc:	491b      	ldr	r1, [pc, #108]	; (102273c <z_sched_start+0x90>)
 10226ce:	481c      	ldr	r0, [pc, #112]	; (1022740 <z_sched_start+0x94>)
 10226d0:	f002 fa81 	bl	1024bd6 <assert_print>
 10226d4:	4917      	ldr	r1, [pc, #92]	; (1022734 <z_sched_start+0x88>)
 10226d6:	481b      	ldr	r0, [pc, #108]	; (1022744 <z_sched_start+0x98>)
 10226d8:	f002 fa7d 	bl	1024bd6 <assert_print>
 10226dc:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10226de:	4816      	ldr	r0, [pc, #88]	; (1022738 <z_sched_start+0x8c>)
 10226e0:	f002 fa72 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 10226e4:	4813      	ldr	r0, [pc, #76]	; (1022734 <z_sched_start+0x88>)
 10226e6:	f7fe fd0f 	bl	1021108 <z_spin_lock_set_owner>
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
 10226ea:	7b63      	ldrb	r3, [r4, #13]
	if (z_has_thread_started(thread)) {
 10226ec:	075a      	lsls	r2, r3, #29
 10226ee:	d414      	bmi.n	102271a <z_sched_start+0x6e>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10226f0:	4810      	ldr	r0, [pc, #64]	; (1022734 <z_sched_start+0x88>)
 10226f2:	f7fe fcfb 	bl	10210ec <z_spin_unlock_valid>
 10226f6:	b958      	cbnz	r0, 1022710 <z_sched_start+0x64>
 10226f8:	23c2      	movs	r3, #194	; 0xc2
 10226fa:	4a0f      	ldr	r2, [pc, #60]	; (1022738 <z_sched_start+0x8c>)
 10226fc:	4912      	ldr	r1, [pc, #72]	; (1022748 <z_sched_start+0x9c>)
 10226fe:	4810      	ldr	r0, [pc, #64]	; (1022740 <z_sched_start+0x94>)
 1022700:	f002 fa69 	bl	1024bd6 <assert_print>
 1022704:	490b      	ldr	r1, [pc, #44]	; (1022734 <z_sched_start+0x88>)
 1022706:	4811      	ldr	r0, [pc, #68]	; (102274c <z_sched_start+0xa0>)
 1022708:	f002 fa65 	bl	1024bd6 <assert_print>
 102270c:	21c2      	movs	r1, #194	; 0xc2
 102270e:	e7e6      	b.n	10226de <z_sched_start+0x32>
	__asm__ volatile(
 1022710:	f385 8811 	msr	BASEPRI, r5
 1022714:	f3bf 8f6f 	isb	sy
}
 1022718:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
 102271a:	f023 0304 	bic.w	r3, r3, #4
	ready_thread(thread);
 102271e:	4620      	mov	r0, r4
 1022720:	7363      	strb	r3, [r4, #13]
 1022722:	f7ff fe47 	bl	10223b4 <ready_thread>
	z_reschedule(&sched_spinlock, key);
 1022726:	4629      	mov	r1, r5
}
 1022728:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&sched_spinlock, key);
 102272c:	4801      	ldr	r0, [pc, #4]	; (1022734 <z_sched_start+0x88>)
 102272e:	f7ff bf7b 	b.w	1022628 <z_reschedule>
 1022732:	bf00      	nop
 1022734:	21008110 	.word	0x21008110
 1022738:	0102bd8a 	.word	0x0102bd8a
 102273c:	0102bde3 	.word	0x0102bde3
 1022740:	0102b695 	.word	0x0102b695
 1022744:	0102bdf8 	.word	0x0102bdf8
 1022748:	0102bdb7 	.word	0x0102bdb7
 102274c:	0102bdce 	.word	0x0102bdce

01022750 <k_sched_lock>:
		signal_pending_ipi();
	}
}

void k_sched_lock(void)
{
 1022750:	b510      	push	{r4, lr}
	__asm__ volatile(
 1022752:	f04f 0320 	mov.w	r3, #32
 1022756:	f3ef 8411 	mrs	r4, BASEPRI
 102275a:	f383 8812 	msr	BASEPRI_MAX, r3
 102275e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1022762:	4825      	ldr	r0, [pc, #148]	; (10227f8 <k_sched_lock+0xa8>)
 1022764:	f7fe fcb4 	bl	10210d0 <z_spin_lock_valid>
 1022768:	b960      	cbnz	r0, 1022784 <k_sched_lock+0x34>
 102276a:	2394      	movs	r3, #148	; 0x94
 102276c:	4a23      	ldr	r2, [pc, #140]	; (10227fc <k_sched_lock+0xac>)
 102276e:	4924      	ldr	r1, [pc, #144]	; (1022800 <k_sched_lock+0xb0>)
 1022770:	4824      	ldr	r0, [pc, #144]	; (1022804 <k_sched_lock+0xb4>)
 1022772:	f002 fa30 	bl	1024bd6 <assert_print>
 1022776:	4920      	ldr	r1, [pc, #128]	; (10227f8 <k_sched_lock+0xa8>)
 1022778:	4823      	ldr	r0, [pc, #140]	; (1022808 <k_sched_lock+0xb8>)
 102277a:	f002 fa2c 	bl	1024bd6 <assert_print>
 102277e:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022780:	481e      	ldr	r0, [pc, #120]	; (10227fc <k_sched_lock+0xac>)
 1022782:	e010      	b.n	10227a6 <k_sched_lock+0x56>
	z_spin_lock_set_owner(l);
 1022784:	481c      	ldr	r0, [pc, #112]	; (10227f8 <k_sched_lock+0xa8>)
 1022786:	f7fe fcbf 	bl	1021108 <z_spin_lock_set_owner>
 102278a:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
 102278e:	b163      	cbz	r3, 10227aa <k_sched_lock+0x5a>
 1022790:	491e      	ldr	r1, [pc, #120]	; (102280c <k_sched_lock+0xbc>)
 1022792:	23fd      	movs	r3, #253	; 0xfd
 1022794:	4a1e      	ldr	r2, [pc, #120]	; (1022810 <k_sched_lock+0xc0>)
 1022796:	481b      	ldr	r0, [pc, #108]	; (1022804 <k_sched_lock+0xb4>)
 1022798:	f002 fa1d 	bl	1024bd6 <assert_print>
 102279c:	481d      	ldr	r0, [pc, #116]	; (1022814 <k_sched_lock+0xc4>)
 102279e:	f002 fa1a 	bl	1024bd6 <assert_print>
 10227a2:	21fd      	movs	r1, #253	; 0xfd
 10227a4:	481a      	ldr	r0, [pc, #104]	; (1022810 <k_sched_lock+0xc0>)
 10227a6:	f002 fa0f 	bl	1024bc8 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1U, "");
 10227aa:	4b1b      	ldr	r3, [pc, #108]	; (1022818 <k_sched_lock+0xc8>)
 10227ac:	689a      	ldr	r2, [r3, #8]
 10227ae:	7bd3      	ldrb	r3, [r2, #15]
 10227b0:	2b01      	cmp	r3, #1
 10227b2:	d10a      	bne.n	10227ca <k_sched_lock+0x7a>
 10227b4:	4919      	ldr	r1, [pc, #100]	; (102281c <k_sched_lock+0xcc>)
 10227b6:	23fe      	movs	r3, #254	; 0xfe
 10227b8:	4a15      	ldr	r2, [pc, #84]	; (1022810 <k_sched_lock+0xc0>)
 10227ba:	4812      	ldr	r0, [pc, #72]	; (1022804 <k_sched_lock+0xb4>)
 10227bc:	f002 fa0b 	bl	1024bd6 <assert_print>
 10227c0:	4814      	ldr	r0, [pc, #80]	; (1022814 <k_sched_lock+0xc4>)
 10227c2:	f002 fa08 	bl	1024bd6 <assert_print>
 10227c6:	21fe      	movs	r1, #254	; 0xfe
 10227c8:	e7ec      	b.n	10227a4 <k_sched_lock+0x54>
	--_current->base.sched_locked;
 10227ca:	3b01      	subs	r3, #1
 10227cc:	73d3      	strb	r3, [r2, #15]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10227ce:	480a      	ldr	r0, [pc, #40]	; (10227f8 <k_sched_lock+0xa8>)
 10227d0:	f7fe fc8c 	bl	10210ec <z_spin_unlock_valid>
 10227d4:	b958      	cbnz	r0, 10227ee <k_sched_lock+0x9e>
 10227d6:	23c2      	movs	r3, #194	; 0xc2
 10227d8:	4a08      	ldr	r2, [pc, #32]	; (10227fc <k_sched_lock+0xac>)
 10227da:	4911      	ldr	r1, [pc, #68]	; (1022820 <k_sched_lock+0xd0>)
 10227dc:	4809      	ldr	r0, [pc, #36]	; (1022804 <k_sched_lock+0xb4>)
 10227de:	f002 f9fa 	bl	1024bd6 <assert_print>
 10227e2:	4905      	ldr	r1, [pc, #20]	; (10227f8 <k_sched_lock+0xa8>)
 10227e4:	480f      	ldr	r0, [pc, #60]	; (1022824 <k_sched_lock+0xd4>)
 10227e6:	f002 f9f6 	bl	1024bd6 <assert_print>
 10227ea:	21c2      	movs	r1, #194	; 0xc2
 10227ec:	e7c8      	b.n	1022780 <k_sched_lock+0x30>
	__asm__ volatile(
 10227ee:	f384 8811 	msr	BASEPRI, r4
 10227f2:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
 10227f6:	bd10      	pop	{r4, pc}
 10227f8:	21008110 	.word	0x21008110
 10227fc:	0102bd8a 	.word	0x0102bd8a
 1022800:	0102bde3 	.word	0x0102bde3
 1022804:	0102b695 	.word	0x0102b695
 1022808:	0102bdf8 	.word	0x0102bdf8
 102280c:	0102f8a2 	.word	0x0102f8a2
 1022810:	0102fb79 	.word	0x0102fb79
 1022814:	0102ee84 	.word	0x0102ee84
 1022818:	210080cc 	.word	0x210080cc
 102281c:	0102fba4 	.word	0x0102fba4
 1022820:	0102bdb7 	.word	0x0102bdb7
 1022824:	0102bdce 	.word	0x0102bdce

01022828 <k_sched_unlock>:

void k_sched_unlock(void)
{
 1022828:	b510      	push	{r4, lr}
	__asm__ volatile(
 102282a:	f04f 0320 	mov.w	r3, #32
 102282e:	f3ef 8411 	mrs	r4, BASEPRI
 1022832:	f383 8812 	msr	BASEPRI_MAX, r3
 1022836:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 102283a:	4829      	ldr	r0, [pc, #164]	; (10228e0 <k_sched_unlock+0xb8>)
 102283c:	f7fe fc48 	bl	10210d0 <z_spin_lock_valid>
 1022840:	b960      	cbnz	r0, 102285c <k_sched_unlock+0x34>
 1022842:	2394      	movs	r3, #148	; 0x94
 1022844:	4a27      	ldr	r2, [pc, #156]	; (10228e4 <k_sched_unlock+0xbc>)
 1022846:	4928      	ldr	r1, [pc, #160]	; (10228e8 <k_sched_unlock+0xc0>)
 1022848:	4828      	ldr	r0, [pc, #160]	; (10228ec <k_sched_unlock+0xc4>)
 102284a:	f002 f9c4 	bl	1024bd6 <assert_print>
 102284e:	4924      	ldr	r1, [pc, #144]	; (10228e0 <k_sched_unlock+0xb8>)
 1022850:	4827      	ldr	r0, [pc, #156]	; (10228f0 <k_sched_unlock+0xc8>)
 1022852:	f002 f9c0 	bl	1024bd6 <assert_print>
 1022856:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022858:	4822      	ldr	r0, [pc, #136]	; (10228e4 <k_sched_unlock+0xbc>)
 102285a:	e013      	b.n	1022884 <k_sched_unlock+0x5c>
	z_spin_lock_set_owner(l);
 102285c:	4820      	ldr	r0, [pc, #128]	; (10228e0 <k_sched_unlock+0xb8>)
 102285e:	f7fe fc53 	bl	1021108 <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		__ASSERT(_current->base.sched_locked != 0U, "");
 1022862:	4b24      	ldr	r3, [pc, #144]	; (10228f4 <k_sched_unlock+0xcc>)
 1022864:	689a      	ldr	r2, [r3, #8]
 1022866:	7bd3      	ldrb	r3, [r2, #15]
 1022868:	b973      	cbnz	r3, 1022888 <k_sched_unlock+0x60>
 102286a:	4923      	ldr	r1, [pc, #140]	; (10228f8 <k_sched_unlock+0xd0>)
 102286c:	f240 33e7 	movw	r3, #999	; 0x3e7
 1022870:	4a22      	ldr	r2, [pc, #136]	; (10228fc <k_sched_unlock+0xd4>)
 1022872:	481e      	ldr	r0, [pc, #120]	; (10228ec <k_sched_unlock+0xc4>)
 1022874:	f002 f9af 	bl	1024bd6 <assert_print>
 1022878:	4821      	ldr	r0, [pc, #132]	; (1022900 <k_sched_unlock+0xd8>)
 102287a:	f002 f9ac 	bl	1024bd6 <assert_print>
 102287e:	f240 31e7 	movw	r1, #999	; 0x3e7
 1022882:	481e      	ldr	r0, [pc, #120]	; (10228fc <k_sched_unlock+0xd4>)
 1022884:	f002 f9a0 	bl	1024bc8 <assert_post_action>
 1022888:	f3ef 8005 	mrs	r0, IPSR
		__ASSERT(!arch_is_in_isr(), "");
 102288c:	b160      	cbz	r0, 10228a8 <k_sched_unlock+0x80>
 102288e:	491d      	ldr	r1, [pc, #116]	; (1022904 <k_sched_unlock+0xdc>)
 1022890:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 1022894:	4a19      	ldr	r2, [pc, #100]	; (10228fc <k_sched_unlock+0xd4>)
 1022896:	4815      	ldr	r0, [pc, #84]	; (10228ec <k_sched_unlock+0xc4>)
 1022898:	f002 f99d 	bl	1024bd6 <assert_print>
 102289c:	4818      	ldr	r0, [pc, #96]	; (1022900 <k_sched_unlock+0xd8>)
 102289e:	f002 f99a 	bl	1024bd6 <assert_print>
 10228a2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 10228a6:	e7ec      	b.n	1022882 <k_sched_unlock+0x5a>

		++_current->base.sched_locked;
 10228a8:	3301      	adds	r3, #1
 10228aa:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
 10228ac:	f7ff fd4e 	bl	102234c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10228b0:	480b      	ldr	r0, [pc, #44]	; (10228e0 <k_sched_unlock+0xb8>)
 10228b2:	f7fe fc1b 	bl	10210ec <z_spin_unlock_valid>
 10228b6:	b958      	cbnz	r0, 10228d0 <k_sched_unlock+0xa8>
 10228b8:	23c2      	movs	r3, #194	; 0xc2
 10228ba:	4a0a      	ldr	r2, [pc, #40]	; (10228e4 <k_sched_unlock+0xbc>)
 10228bc:	4912      	ldr	r1, [pc, #72]	; (1022908 <k_sched_unlock+0xe0>)
 10228be:	480b      	ldr	r0, [pc, #44]	; (10228ec <k_sched_unlock+0xc4>)
 10228c0:	f002 f989 	bl	1024bd6 <assert_print>
 10228c4:	4906      	ldr	r1, [pc, #24]	; (10228e0 <k_sched_unlock+0xb8>)
 10228c6:	4811      	ldr	r0, [pc, #68]	; (102290c <k_sched_unlock+0xe4>)
 10228c8:	f002 f985 	bl	1024bd6 <assert_print>
 10228cc:	21c2      	movs	r1, #194	; 0xc2
 10228ce:	e7c3      	b.n	1022858 <k_sched_unlock+0x30>
	__asm__ volatile(
 10228d0:	f384 8811 	msr	BASEPRI, r4
 10228d4:	f3bf 8f6f 	isb	sy
		_current, _current->base.sched_locked);

	SYS_PORT_TRACING_FUNC(k_thread, sched_unlock);

	z_reschedule_unlocked();
}
 10228d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
 10228dc:	f006 bda6 	b.w	102942c <z_reschedule_unlocked>
 10228e0:	21008110 	.word	0x21008110
 10228e4:	0102bd8a 	.word	0x0102bd8a
 10228e8:	0102bde3 	.word	0x0102bde3
 10228ec:	0102b695 	.word	0x0102b695
 10228f0:	0102bdf8 	.word	0x0102bdf8
 10228f4:	210080cc 	.word	0x210080cc
 10228f8:	0102fbd5 	.word	0x0102fbd5
 10228fc:	0102fb0f 	.word	0x0102fb0f
 1022900:	0102ee84 	.word	0x0102ee84
 1022904:	0102f8a2 	.word	0x0102f8a2
 1022908:	0102bdb7 	.word	0x0102bdb7
 102290c:	0102bdce 	.word	0x0102bdce

01022910 <z_priq_dumb_remove>:
#endif
}
#endif

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
 1022910:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
 1022912:	4b0b      	ldr	r3, [pc, #44]	; (1022940 <z_priq_dumb_remove+0x30>)
 1022914:	4299      	cmp	r1, r3
 1022916:	d10b      	bne.n	1022930 <z_priq_dumb_remove+0x20>
 1022918:	490a      	ldr	r1, [pc, #40]	; (1022944 <z_priq_dumb_remove+0x34>)
 102291a:	480b      	ldr	r0, [pc, #44]	; (1022948 <z_priq_dumb_remove+0x38>)
 102291c:	f240 4373 	movw	r3, #1139	; 0x473
 1022920:	4a0a      	ldr	r2, [pc, #40]	; (102294c <z_priq_dumb_remove+0x3c>)
 1022922:	f002 f958 	bl	1024bd6 <assert_print>
 1022926:	f240 4173 	movw	r1, #1139	; 0x473
 102292a:	4808      	ldr	r0, [pc, #32]	; (102294c <z_priq_dumb_remove+0x3c>)
 102292c:	f002 f94c 	bl	1024bc8 <assert_post_action>
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
	sys_dnode_t *const next = node->next;
 1022930:	e9d1 3200 	ldrd	r3, r2, [r1]

	prev->next = next;
 1022934:	6013      	str	r3, [r2, #0]
	next->prev = prev;
 1022936:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 1022938:	2300      	movs	r3, #0
	node->prev = NULL;
 102293a:	e9c1 3300 	strd	r3, r3, [r1]

	sys_dlist_remove(&thread->base.qnode_dlist);
}
 102293e:	bd08      	pop	{r3, pc}
 1022940:	21004410 	.word	0x21004410
 1022944:	0102fb58 	.word	0x0102fb58
 1022948:	0102b695 	.word	0x0102b695
 102294c:	0102fb0f 	.word	0x0102fb0f

01022950 <move_thread_to_end_of_prio_q>:
{
 1022950:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
 1022952:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
 1022956:	4604      	mov	r4, r0
	if (z_is_thread_queued(thread)) {
 1022958:	2a00      	cmp	r2, #0
	return (thread->base.thread_state & state) != 0U;
 102295a:	7b43      	ldrb	r3, [r0, #13]
 102295c:	da06      	bge.n	102296c <move_thread_to_end_of_prio_q+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 102295e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	_priq_run_remove(thread_runq(thread), thread);
 1022962:	4601      	mov	r1, r0
	thread->base.thread_state &= ~_THREAD_QUEUED;
 1022964:	7343      	strb	r3, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
 1022966:	481d      	ldr	r0, [pc, #116]	; (10229dc <move_thread_to_end_of_prio_q+0x8c>)
 1022968:	f7ff ffd2 	bl	1022910 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
 102296c:	7b63      	ldrb	r3, [r4, #13]
 102296e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 1022972:	7363      	strb	r3, [r4, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
 1022974:	4b1a      	ldr	r3, [pc, #104]	; (10229e0 <move_thread_to_end_of_prio_q+0x90>)
 1022976:	429c      	cmp	r4, r3
 1022978:	d109      	bne.n	102298e <move_thread_to_end_of_prio_q+0x3e>
 102297a:	491a      	ldr	r1, [pc, #104]	; (10229e4 <move_thread_to_end_of_prio_q+0x94>)
 102297c:	481a      	ldr	r0, [pc, #104]	; (10229e8 <move_thread_to_end_of_prio_q+0x98>)
 102297e:	23ba      	movs	r3, #186	; 0xba
 1022980:	4a1a      	ldr	r2, [pc, #104]	; (10229ec <move_thread_to_end_of_prio_q+0x9c>)
 1022982:	f002 f928 	bl	1024bd6 <assert_print>
 1022986:	21ba      	movs	r1, #186	; 0xba
 1022988:	4818      	ldr	r0, [pc, #96]	; (10229ec <move_thread_to_end_of_prio_q+0x9c>)
 102298a:	f002 f91d 	bl	1024bc8 <assert_post_action>
	return list->head == list;
 102298e:	4a18      	ldr	r2, [pc, #96]	; (10229f0 <move_thread_to_end_of_prio_q+0xa0>)
 1022990:	4611      	mov	r1, r2
 1022992:	f851 3f1c 	ldr.w	r3, [r1, #28]!
	return (node == list->tail) ? NULL : node->next;
 1022996:	6a10      	ldr	r0, [r2, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1022998:	428b      	cmp	r3, r1
 102299a:	bf08      	it	eq
 102299c:	2300      	moveq	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 102299e:	b923      	cbnz	r3, 10229aa <move_thread_to_end_of_prio_q+0x5a>
	node->prev = tail;
 10229a0:	e9c4 1000 	strd	r1, r0, [r4]
	tail->next = node;
 10229a4:	6004      	str	r4, [r0, #0]
	list->tail = node;
 10229a6:	6214      	str	r4, [r2, #32]
}
 10229a8:	e00c      	b.n	10229c4 <move_thread_to_end_of_prio_q+0x74>
	int32_t b1 = thread_1->base.prio;
 10229aa:	f994 500e 	ldrsb.w	r5, [r4, #14]
	int32_t b2 = thread_2->base.prio;
 10229ae:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
 10229b2:	42b5      	cmp	r5, r6
 10229b4:	d00e      	beq.n	10229d4 <move_thread_to_end_of_prio_q+0x84>
		if (z_sched_prio_cmp(thread, t) > 0) {
 10229b6:	42ae      	cmp	r6, r5
 10229b8:	dd0c      	ble.n	10229d4 <move_thread_to_end_of_prio_q+0x84>
	sys_dnode_t *const prev = successor->prev;
 10229ba:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
 10229bc:	e9c4 3100 	strd	r3, r1, [r4]
	prev->next = node;
 10229c0:	600c      	str	r4, [r1, #0]
	successor->prev = node;
 10229c2:	605c      	str	r4, [r3, #4]
	update_cache(thread == _current);
 10229c4:	6890      	ldr	r0, [r2, #8]
 10229c6:	1b03      	subs	r3, r0, r4
 10229c8:	4258      	negs	r0, r3
 10229ca:	4158      	adcs	r0, r3
}
 10229cc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
 10229d0:	f7ff bcbc 	b.w	102234c <update_cache>
	return (node == list->tail) ? NULL : node->next;
 10229d4:	4298      	cmp	r0, r3
 10229d6:	d0e3      	beq.n	10229a0 <move_thread_to_end_of_prio_q+0x50>
 10229d8:	681b      	ldr	r3, [r3, #0]
 10229da:	e7e0      	b.n	102299e <move_thread_to_end_of_prio_q+0x4e>
 10229dc:	210080e8 	.word	0x210080e8
 10229e0:	21004410 	.word	0x21004410
 10229e4:	0102fb58 	.word	0x0102fb58
 10229e8:	0102b695 	.word	0x0102b695
 10229ec:	0102fb0f 	.word	0x0102fb0f
 10229f0:	210080cc 	.word	0x210080cc

010229f4 <z_time_slice>:
{
 10229f4:	b570      	push	{r4, r5, r6, lr}
 10229f6:	4605      	mov	r5, r0
	__asm__ volatile(
 10229f8:	f04f 0320 	mov.w	r3, #32
 10229fc:	f3ef 8611 	mrs	r6, BASEPRI
 1022a00:	f383 8812 	msr	BASEPRI_MAX, r3
 1022a04:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1022a08:	4829      	ldr	r0, [pc, #164]	; (1022ab0 <z_time_slice+0xbc>)
 1022a0a:	f7fe fb61 	bl	10210d0 <z_spin_lock_valid>
 1022a0e:	b968      	cbnz	r0, 1022a2c <z_time_slice+0x38>
 1022a10:	2394      	movs	r3, #148	; 0x94
 1022a12:	4a28      	ldr	r2, [pc, #160]	; (1022ab4 <z_time_slice+0xc0>)
 1022a14:	4928      	ldr	r1, [pc, #160]	; (1022ab8 <z_time_slice+0xc4>)
 1022a16:	4829      	ldr	r0, [pc, #164]	; (1022abc <z_time_slice+0xc8>)
 1022a18:	f002 f8dd 	bl	1024bd6 <assert_print>
 1022a1c:	4924      	ldr	r1, [pc, #144]	; (1022ab0 <z_time_slice+0xbc>)
 1022a1e:	4828      	ldr	r0, [pc, #160]	; (1022ac0 <z_time_slice+0xcc>)
 1022a20:	f002 f8d9 	bl	1024bd6 <assert_print>
 1022a24:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022a26:	4823      	ldr	r0, [pc, #140]	; (1022ab4 <z_time_slice+0xc0>)
 1022a28:	f002 f8ce 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1022a2c:	4820      	ldr	r0, [pc, #128]	; (1022ab0 <z_time_slice+0xbc>)
 1022a2e:	f7fe fb6b 	bl	1021108 <z_spin_lock_set_owner>
	if (pending_current == _current) {
 1022a32:	4b24      	ldr	r3, [pc, #144]	; (1022ac4 <z_time_slice+0xd0>)
 1022a34:	4a24      	ldr	r2, [pc, #144]	; (1022ac8 <z_time_slice+0xd4>)
 1022a36:	689c      	ldr	r4, [r3, #8]
 1022a38:	6811      	ldr	r1, [r2, #0]
 1022a3a:	428c      	cmp	r4, r1
 1022a3c:	d112      	bne.n	1022a64 <z_time_slice+0x70>
		z_reset_time_slice(_current);
 1022a3e:	4620      	mov	r0, r4
 1022a40:	f7ff fc70 	bl	1022324 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022a44:	481a      	ldr	r0, [pc, #104]	; (1022ab0 <z_time_slice+0xbc>)
 1022a46:	f7fe fb51 	bl	10210ec <z_spin_unlock_valid>
 1022a4a:	bb58      	cbnz	r0, 1022aa4 <z_time_slice+0xb0>
 1022a4c:	23c2      	movs	r3, #194	; 0xc2
 1022a4e:	4a19      	ldr	r2, [pc, #100]	; (1022ab4 <z_time_slice+0xc0>)
 1022a50:	491e      	ldr	r1, [pc, #120]	; (1022acc <z_time_slice+0xd8>)
 1022a52:	481a      	ldr	r0, [pc, #104]	; (1022abc <z_time_slice+0xc8>)
 1022a54:	f002 f8bf 	bl	1024bd6 <assert_print>
 1022a58:	4915      	ldr	r1, [pc, #84]	; (1022ab0 <z_time_slice+0xbc>)
 1022a5a:	481d      	ldr	r0, [pc, #116]	; (1022ad0 <z_time_slice+0xdc>)
 1022a5c:	f002 f8bb 	bl	1024bd6 <assert_print>
 1022a60:	21c2      	movs	r1, #194	; 0xc2
 1022a62:	e7e0      	b.n	1022a26 <z_time_slice+0x32>
	pending_current = NULL;
 1022a64:	2100      	movs	r1, #0
 1022a66:	6011      	str	r1, [r2, #0]
	int ret = slice_ticks;
 1022a68:	4a1a      	ldr	r2, [pc, #104]	; (1022ad4 <z_time_slice+0xe0>)
	if (slice_time(_current) && sliceable(_current)) {
 1022a6a:	6812      	ldr	r2, [r2, #0]
 1022a6c:	b1c2      	cbz	r2, 1022aa0 <z_time_slice+0xac>
		&& !z_is_idle_thread_object(thread);
 1022a6e:	89e2      	ldrh	r2, [r4, #14]
 1022a70:	2a7f      	cmp	r2, #127	; 0x7f
 1022a72:	d815      	bhi.n	1022aa0 <z_time_slice+0xac>
		&& !z_is_thread_prevented_from_running(thread)
 1022a74:	7b62      	ldrb	r2, [r4, #13]
 1022a76:	06d2      	lsls	r2, r2, #27
 1022a78:	d112      	bne.n	1022aa0 <z_time_slice+0xac>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 1022a7a:	4a17      	ldr	r2, [pc, #92]	; (1022ad8 <z_time_slice+0xe4>)
 1022a7c:	f994 100e 	ldrsb.w	r1, [r4, #14]
 1022a80:	6812      	ldr	r2, [r2, #0]
 1022a82:	4291      	cmp	r1, r2
 1022a84:	db0c      	blt.n	1022aa0 <z_time_slice+0xac>
		&& !z_is_idle_thread_object(thread);
 1022a86:	4a15      	ldr	r2, [pc, #84]	; (1022adc <z_time_slice+0xe8>)
 1022a88:	4294      	cmp	r4, r2
 1022a8a:	d009      	beq.n	1022aa0 <z_time_slice+0xac>
		if (ticks >= _current_cpu->slice_ticks) {
 1022a8c:	691a      	ldr	r2, [r3, #16]
 1022a8e:	42aa      	cmp	r2, r5
 1022a90:	dc03      	bgt.n	1022a9a <z_time_slice+0xa6>
		move_thread_to_end_of_prio_q(curr);
 1022a92:	4620      	mov	r0, r4
 1022a94:	f7ff ff5c 	bl	1022950 <move_thread_to_end_of_prio_q>
	z_reset_time_slice(curr);
 1022a98:	e7d1      	b.n	1022a3e <z_time_slice+0x4a>
			_current_cpu->slice_ticks -= ticks;
 1022a9a:	1b52      	subs	r2, r2, r5
		_current_cpu->slice_ticks = 0;
 1022a9c:	611a      	str	r2, [r3, #16]
 1022a9e:	e7d1      	b.n	1022a44 <z_time_slice+0x50>
 1022aa0:	2200      	movs	r2, #0
 1022aa2:	e7fb      	b.n	1022a9c <z_time_slice+0xa8>
	__asm__ volatile(
 1022aa4:	f386 8811 	msr	BASEPRI, r6
 1022aa8:	f3bf 8f6f 	isb	sy
}
 1022aac:	bd70      	pop	{r4, r5, r6, pc}
 1022aae:	bf00      	nop
 1022ab0:	21008110 	.word	0x21008110
 1022ab4:	0102bd8a 	.word	0x0102bd8a
 1022ab8:	0102bde3 	.word	0x0102bde3
 1022abc:	0102b695 	.word	0x0102b695
 1022ac0:	0102bdf8 	.word	0x0102bdf8
 1022ac4:	210080cc 	.word	0x210080cc
 1022ac8:	21008104 	.word	0x21008104
 1022acc:	0102bdb7 	.word	0x0102bdb7
 1022ad0:	0102bdce 	.word	0x0102bdce
 1022ad4:	2100810c 	.word	0x2100810c
 1022ad8:	21008108 	.word	0x21008108
 1022adc:	21004410 	.word	0x21004410

01022ae0 <unready_thread>:
{
 1022ae0:	b510      	push	{r4, lr}
	if (z_is_thread_queued(thread)) {
 1022ae2:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
 1022ae6:	4604      	mov	r4, r0
	if (z_is_thread_queued(thread)) {
 1022ae8:	2a00      	cmp	r2, #0
 1022aea:	7b43      	ldrb	r3, [r0, #13]
 1022aec:	da06      	bge.n	1022afc <unready_thread+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 1022aee:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	_priq_run_remove(thread_runq(thread), thread);
 1022af2:	4601      	mov	r1, r0
	thread->base.thread_state &= ~_THREAD_QUEUED;
 1022af4:	7343      	strb	r3, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
 1022af6:	4806      	ldr	r0, [pc, #24]	; (1022b10 <unready_thread+0x30>)
 1022af8:	f7ff ff0a 	bl	1022910 <z_priq_dumb_remove>
	update_cache(thread == _current);
 1022afc:	4b05      	ldr	r3, [pc, #20]	; (1022b14 <unready_thread+0x34>)
 1022afe:	6898      	ldr	r0, [r3, #8]
 1022b00:	1b03      	subs	r3, r0, r4
 1022b02:	4258      	negs	r0, r3
 1022b04:	4158      	adcs	r0, r3
}
 1022b06:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	update_cache(thread == _current);
 1022b0a:	f7ff bc1f 	b.w	102234c <update_cache>
 1022b0e:	bf00      	nop
 1022b10:	210080e8 	.word	0x210080e8
 1022b14:	210080cc 	.word	0x210080cc

01022b18 <add_to_waitq_locked>:
{
 1022b18:	b538      	push	{r3, r4, r5, lr}
 1022b1a:	4604      	mov	r4, r0
 1022b1c:	460d      	mov	r5, r1
	unready_thread(thread);
 1022b1e:	f7ff ffdf 	bl	1022ae0 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
 1022b22:	7b63      	ldrb	r3, [r4, #13]
 1022b24:	f043 0302 	orr.w	r3, r3, #2
 1022b28:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
 1022b2a:	b34d      	cbz	r5, 1022b80 <add_to_waitq_locked+0x68>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
 1022b2c:	4b15      	ldr	r3, [pc, #84]	; (1022b84 <add_to_waitq_locked+0x6c>)
		thread->base.pended_on = wait_q;
 1022b2e:	60a5      	str	r5, [r4, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
 1022b30:	429c      	cmp	r4, r3
 1022b32:	d109      	bne.n	1022b48 <add_to_waitq_locked+0x30>
 1022b34:	4914      	ldr	r1, [pc, #80]	; (1022b88 <add_to_waitq_locked+0x70>)
 1022b36:	4815      	ldr	r0, [pc, #84]	; (1022b8c <add_to_waitq_locked+0x74>)
 1022b38:	23ba      	movs	r3, #186	; 0xba
 1022b3a:	4a15      	ldr	r2, [pc, #84]	; (1022b90 <add_to_waitq_locked+0x78>)
 1022b3c:	f002 f84b 	bl	1024bd6 <assert_print>
 1022b40:	21ba      	movs	r1, #186	; 0xba
 1022b42:	4813      	ldr	r0, [pc, #76]	; (1022b90 <add_to_waitq_locked+0x78>)
 1022b44:	f002 f840 	bl	1024bc8 <assert_post_action>
	return list->head == list;
 1022b48:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1022b4a:	429d      	cmp	r5, r3
 1022b4c:	d109      	bne.n	1022b62 <add_to_waitq_locked+0x4a>
	sys_dnode_t *const tail = list->tail;
 1022b4e:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
 1022b50:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
 1022b54:	601c      	str	r4, [r3, #0]
	list->tail = node;
 1022b56:	606c      	str	r4, [r5, #4]
}
 1022b58:	e012      	b.n	1022b80 <add_to_waitq_locked+0x68>
	return (node == list->tail) ? NULL : node->next;
 1022b5a:	686a      	ldr	r2, [r5, #4]
 1022b5c:	4293      	cmp	r3, r2
 1022b5e:	d0f6      	beq.n	1022b4e <add_to_waitq_locked+0x36>
 1022b60:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 1022b62:	2b00      	cmp	r3, #0
 1022b64:	d0f3      	beq.n	1022b4e <add_to_waitq_locked+0x36>
	int32_t b1 = thread_1->base.prio;
 1022b66:	f994 200e 	ldrsb.w	r2, [r4, #14]
	int32_t b2 = thread_2->base.prio;
 1022b6a:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
 1022b6e:	428a      	cmp	r2, r1
 1022b70:	d0f3      	beq.n	1022b5a <add_to_waitq_locked+0x42>
		if (z_sched_prio_cmp(thread, t) > 0) {
 1022b72:	4291      	cmp	r1, r2
 1022b74:	ddf1      	ble.n	1022b5a <add_to_waitq_locked+0x42>
	sys_dnode_t *const prev = successor->prev;
 1022b76:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
 1022b78:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
 1022b7c:	6014      	str	r4, [r2, #0]
	successor->prev = node;
 1022b7e:	605c      	str	r4, [r3, #4]
}
 1022b80:	bd38      	pop	{r3, r4, r5, pc}
 1022b82:	bf00      	nop
 1022b84:	21004410 	.word	0x21004410
 1022b88:	0102fb58 	.word	0x0102fb58
 1022b8c:	0102b695 	.word	0x0102b695
 1022b90:	0102fb0f 	.word	0x0102fb0f

01022b94 <pend_locked>:
{
 1022b94:	b570      	push	{r4, r5, r6, lr}
 1022b96:	4615      	mov	r5, r2
 1022b98:	461c      	mov	r4, r3
 1022b9a:	4606      	mov	r6, r0
	add_to_waitq_locked(thread, wait_q);
 1022b9c:	f7ff ffbc 	bl	1022b18 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 1022ba0:	f1b4 3fff 	cmp.w	r4, #4294967295
 1022ba4:	bf08      	it	eq
 1022ba6:	f1b5 3fff 	cmpeq.w	r5, #4294967295
 1022baa:	d008      	beq.n	1022bbe <pend_locked+0x2a>
 1022bac:	462a      	mov	r2, r5
 1022bae:	4623      	mov	r3, r4
 1022bb0:	f106 0018 	add.w	r0, r6, #24
 1022bb4:	4902      	ldr	r1, [pc, #8]	; (1022bc0 <pend_locked+0x2c>)
}
 1022bb6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 1022bba:	f000 bdf1 	b.w	10237a0 <z_add_timeout>
 1022bbe:	bd70      	pop	{r4, r5, r6, pc}
 1022bc0:	01022f79 	.word	0x01022f79

01022bc4 <z_pend_curr>:
{
 1022bc4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1022bc8:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
	pending_current = _current;
 1022bcc:	f8df a0b4 	ldr.w	sl, [pc, #180]	; 1022c84 <z_pend_curr+0xc0>
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
 1022bd0:	4c2d      	ldr	r4, [pc, #180]	; (1022c88 <z_pend_curr+0xc4>)
{
 1022bd2:	4617      	mov	r7, r2
	pending_current = _current;
 1022bd4:	4b2d      	ldr	r3, [pc, #180]	; (1022c8c <z_pend_curr+0xc8>)
 1022bd6:	f8da 2008 	ldr.w	r2, [sl, #8]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
 1022bda:	42a0      	cmp	r0, r4
{
 1022bdc:	4605      	mov	r5, r0
 1022bde:	460e      	mov	r6, r1
	pending_current = _current;
 1022be0:	601a      	str	r2, [r3, #0]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
 1022be2:	d10b      	bne.n	1022bfc <z_pend_curr+0x38>
 1022be4:	492a      	ldr	r1, [pc, #168]	; (1022c90 <z_pend_curr+0xcc>)
 1022be6:	482b      	ldr	r0, [pc, #172]	; (1022c94 <z_pend_curr+0xd0>)
 1022be8:	f240 334e 	movw	r3, #846	; 0x34e
 1022bec:	4a2a      	ldr	r2, [pc, #168]	; (1022c98 <z_pend_curr+0xd4>)
 1022bee:	f001 fff2 	bl	1024bd6 <assert_print>
 1022bf2:	f240 314e 	movw	r1, #846	; 0x34e
 1022bf6:	4828      	ldr	r0, [pc, #160]	; (1022c98 <z_pend_curr+0xd4>)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1022bf8:	f001 ffe6 	bl	1024bc8 <assert_post_action>
	__asm__ volatile(
 1022bfc:	f04f 0220 	mov.w	r2, #32
 1022c00:	f3ef 8311 	mrs	r3, BASEPRI
 1022c04:	f382 8812 	msr	BASEPRI_MAX, r2
 1022c08:	f3bf 8f6f 	isb	sy
 1022c0c:	4620      	mov	r0, r4
 1022c0e:	f7fe fa5f 	bl	10210d0 <z_spin_lock_valid>
 1022c12:	b960      	cbnz	r0, 1022c2e <z_pend_curr+0x6a>
 1022c14:	2394      	movs	r3, #148	; 0x94
 1022c16:	4a21      	ldr	r2, [pc, #132]	; (1022c9c <z_pend_curr+0xd8>)
 1022c18:	4921      	ldr	r1, [pc, #132]	; (1022ca0 <z_pend_curr+0xdc>)
 1022c1a:	481e      	ldr	r0, [pc, #120]	; (1022c94 <z_pend_curr+0xd0>)
 1022c1c:	f001 ffdb 	bl	1024bd6 <assert_print>
 1022c20:	4621      	mov	r1, r4
 1022c22:	4820      	ldr	r0, [pc, #128]	; (1022ca4 <z_pend_curr+0xe0>)
 1022c24:	f001 ffd7 	bl	1024bd6 <assert_print>
 1022c28:	2194      	movs	r1, #148	; 0x94
 1022c2a:	481c      	ldr	r0, [pc, #112]	; (1022c9c <z_pend_curr+0xd8>)
 1022c2c:	e7e4      	b.n	1022bf8 <z_pend_curr+0x34>
	z_spin_lock_set_owner(l);
 1022c2e:	4620      	mov	r0, r4
 1022c30:	f7fe fa6a 	bl	1021108 <z_spin_lock_set_owner>
	pend_locked(_current, wait_q, timeout);
 1022c34:	f8da 0008 	ldr.w	r0, [sl, #8]
 1022c38:	4642      	mov	r2, r8
 1022c3a:	464b      	mov	r3, r9
 1022c3c:	4639      	mov	r1, r7
 1022c3e:	f7ff ffa9 	bl	1022b94 <pend_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022c42:	4628      	mov	r0, r5
 1022c44:	f7fe fa52 	bl	10210ec <z_spin_unlock_valid>
 1022c48:	b958      	cbnz	r0, 1022c62 <z_pend_curr+0x9e>
 1022c4a:	4917      	ldr	r1, [pc, #92]	; (1022ca8 <z_pend_curr+0xe4>)
 1022c4c:	23e1      	movs	r3, #225	; 0xe1
 1022c4e:	4a13      	ldr	r2, [pc, #76]	; (1022c9c <z_pend_curr+0xd8>)
 1022c50:	4810      	ldr	r0, [pc, #64]	; (1022c94 <z_pend_curr+0xd0>)
 1022c52:	f001 ffc0 	bl	1024bd6 <assert_print>
 1022c56:	4629      	mov	r1, r5
 1022c58:	4814      	ldr	r0, [pc, #80]	; (1022cac <z_pend_curr+0xe8>)
 1022c5a:	f001 ffbc 	bl	1024bd6 <assert_print>
 1022c5e:	21e1      	movs	r1, #225	; 0xe1
 1022c60:	e7e3      	b.n	1022c2a <z_pend_curr+0x66>
 1022c62:	4620      	mov	r0, r4
 1022c64:	f7fe fa42 	bl	10210ec <z_spin_unlock_valid>
 1022c68:	b938      	cbnz	r0, 1022c7a <z_pend_curr+0xb6>
 1022c6a:	490f      	ldr	r1, [pc, #60]	; (1022ca8 <z_pend_curr+0xe4>)
 1022c6c:	23e1      	movs	r3, #225	; 0xe1
 1022c6e:	4a0b      	ldr	r2, [pc, #44]	; (1022c9c <z_pend_curr+0xd8>)
 1022c70:	4808      	ldr	r0, [pc, #32]	; (1022c94 <z_pend_curr+0xd0>)
 1022c72:	f001 ffb0 	bl	1024bd6 <assert_print>
 1022c76:	4621      	mov	r1, r4
 1022c78:	e7ee      	b.n	1022c58 <z_pend_curr+0x94>
 1022c7a:	4630      	mov	r0, r6
}
 1022c7c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1022c80:	f7e3 b92e 	b.w	1005ee0 <arch_swap>
 1022c84:	210080cc 	.word	0x210080cc
 1022c88:	21008110 	.word	0x21008110
 1022c8c:	21008104 	.word	0x21008104
 1022c90:	0102fc06 	.word	0x0102fc06
 1022c94:	0102b695 	.word	0x0102b695
 1022c98:	0102fb0f 	.word	0x0102fb0f
 1022c9c:	0102bd8a 	.word	0x0102bd8a
 1022ca0:	0102bde3 	.word	0x0102bde3
 1022ca4:	0102bdf8 	.word	0x0102bdf8
 1022ca8:	0102bdb7 	.word	0x0102bdb7
 1022cac:	0102bdce 	.word	0x0102bdce

01022cb0 <z_set_prio>:
{
 1022cb0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1022cb4:	4604      	mov	r4, r0
 1022cb6:	460e      	mov	r6, r1
 1022cb8:	f04f 0320 	mov.w	r3, #32
 1022cbc:	f3ef 8911 	mrs	r9, BASEPRI
 1022cc0:	f383 8812 	msr	BASEPRI_MAX, r3
 1022cc4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1022cc8:	4837      	ldr	r0, [pc, #220]	; (1022da8 <z_set_prio+0xf8>)
 1022cca:	f7fe fa01 	bl	10210d0 <z_spin_lock_valid>
 1022cce:	4607      	mov	r7, r0
 1022cd0:	b960      	cbnz	r0, 1022cec <z_set_prio+0x3c>
 1022cd2:	2394      	movs	r3, #148	; 0x94
 1022cd4:	4a35      	ldr	r2, [pc, #212]	; (1022dac <z_set_prio+0xfc>)
 1022cd6:	4936      	ldr	r1, [pc, #216]	; (1022db0 <z_set_prio+0x100>)
 1022cd8:	4836      	ldr	r0, [pc, #216]	; (1022db4 <z_set_prio+0x104>)
 1022cda:	f001 ff7c 	bl	1024bd6 <assert_print>
 1022cde:	4932      	ldr	r1, [pc, #200]	; (1022da8 <z_set_prio+0xf8>)
 1022ce0:	4835      	ldr	r0, [pc, #212]	; (1022db8 <z_set_prio+0x108>)
 1022ce2:	f001 ff78 	bl	1024bd6 <assert_print>
 1022ce6:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022ce8:	4830      	ldr	r0, [pc, #192]	; (1022dac <z_set_prio+0xfc>)
 1022cea:	e021      	b.n	1022d30 <z_set_prio+0x80>
	z_spin_lock_set_owner(l);
 1022cec:	482e      	ldr	r0, [pc, #184]	; (1022da8 <z_set_prio+0xf8>)
 1022cee:	f7fe fa0b 	bl	1021108 <z_spin_lock_set_owner>
	uint8_t state = thread->base.thread_state;
 1022cf2:	7b63      	ldrb	r3, [r4, #13]
				thread->base.prio = prio;
 1022cf4:	b276      	sxtb	r6, r6
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 1022cf6:	06da      	lsls	r2, r3, #27
 1022cf8:	d11c      	bne.n	1022d34 <z_set_prio+0x84>
	return node->next != NULL;
 1022cfa:	69a5      	ldr	r5, [r4, #24]
 1022cfc:	b9d5      	cbnz	r5, 1022d34 <z_set_prio+0x84>
	_priq_run_remove(thread_runq(thread), thread);
 1022cfe:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 1022dbc <z_set_prio+0x10c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 1022d02:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 1022d06:	7363      	strb	r3, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
 1022d08:	4621      	mov	r1, r4
 1022d0a:	4640      	mov	r0, r8
 1022d0c:	f7ff fe00 	bl	1022910 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
 1022d10:	7b63      	ldrb	r3, [r4, #13]
				thread->base.prio = prio;
 1022d12:	73a6      	strb	r6, [r4, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
 1022d14:	f063 037f 	orn	r3, r3, #127	; 0x7f
 1022d18:	7363      	strb	r3, [r4, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
 1022d1a:	4b29      	ldr	r3, [pc, #164]	; (1022dc0 <z_set_prio+0x110>)
 1022d1c:	429c      	cmp	r4, r3
 1022d1e:	d11b      	bne.n	1022d58 <z_set_prio+0xa8>
 1022d20:	4928      	ldr	r1, [pc, #160]	; (1022dc4 <z_set_prio+0x114>)
 1022d22:	4824      	ldr	r0, [pc, #144]	; (1022db4 <z_set_prio+0x104>)
 1022d24:	23ba      	movs	r3, #186	; 0xba
 1022d26:	4a28      	ldr	r2, [pc, #160]	; (1022dc8 <z_set_prio+0x118>)
 1022d28:	f001 ff55 	bl	1024bd6 <assert_print>
 1022d2c:	21ba      	movs	r1, #186	; 0xba
 1022d2e:	4826      	ldr	r0, [pc, #152]	; (1022dc8 <z_set_prio+0x118>)
 1022d30:	f001 ff4a 	bl	1024bc8 <assert_post_action>
 1022d34:	2700      	movs	r7, #0
			thread->base.prio = prio;
 1022d36:	73a6      	strb	r6, [r4, #14]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022d38:	481b      	ldr	r0, [pc, #108]	; (1022da8 <z_set_prio+0xf8>)
 1022d3a:	f7fe f9d7 	bl	10210ec <z_spin_unlock_valid>
 1022d3e:	bb58      	cbnz	r0, 1022d98 <z_set_prio+0xe8>
 1022d40:	23c2      	movs	r3, #194	; 0xc2
 1022d42:	4a1a      	ldr	r2, [pc, #104]	; (1022dac <z_set_prio+0xfc>)
 1022d44:	4921      	ldr	r1, [pc, #132]	; (1022dcc <z_set_prio+0x11c>)
 1022d46:	481b      	ldr	r0, [pc, #108]	; (1022db4 <z_set_prio+0x104>)
 1022d48:	f001 ff45 	bl	1024bd6 <assert_print>
 1022d4c:	4916      	ldr	r1, [pc, #88]	; (1022da8 <z_set_prio+0xf8>)
 1022d4e:	4820      	ldr	r0, [pc, #128]	; (1022dd0 <z_set_prio+0x120>)
 1022d50:	f001 ff41 	bl	1024bd6 <assert_print>
 1022d54:	21c2      	movs	r1, #194	; 0xc2
 1022d56:	e7c7      	b.n	1022ce8 <z_set_prio+0x38>
	return list->head == list;
 1022d58:	4643      	mov	r3, r8
 1022d5a:	f853 291c 	ldr.w	r2, [r3], #-28
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1022d5e:	4542      	cmp	r2, r8
 1022d60:	bf18      	it	ne
 1022d62:	4615      	movne	r5, r2
	return (node == list->tail) ? NULL : node->next;
 1022d64:	6a1a      	ldr	r2, [r3, #32]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 1022d66:	b925      	cbnz	r5, 1022d72 <z_set_prio+0xc2>
	node->prev = tail;
 1022d68:	e9c4 8200 	strd	r8, r2, [r4]
	tail->next = node;
 1022d6c:	6014      	str	r4, [r2, #0]
	list->tail = node;
 1022d6e:	621c      	str	r4, [r3, #32]
}
 1022d70:	e00a      	b.n	1022d88 <z_set_prio+0xd8>
	int32_t b2 = thread_2->base.prio;
 1022d72:	f995 100e 	ldrsb.w	r1, [r5, #14]
	if (b1 != b2) {
 1022d76:	428e      	cmp	r6, r1
 1022d78:	d00a      	beq.n	1022d90 <z_set_prio+0xe0>
		if (z_sched_prio_cmp(thread, t) > 0) {
 1022d7a:	42b1      	cmp	r1, r6
 1022d7c:	dd08      	ble.n	1022d90 <z_set_prio+0xe0>
	sys_dnode_t *const prev = successor->prev;
 1022d7e:	686b      	ldr	r3, [r5, #4]
	node->next = successor;
 1022d80:	e9c4 5300 	strd	r5, r3, [r4]
	prev->next = node;
 1022d84:	601c      	str	r4, [r3, #0]
	successor->prev = node;
 1022d86:	606c      	str	r4, [r5, #4]
			update_cache(1);
 1022d88:	2001      	movs	r0, #1
 1022d8a:	f7ff fadf 	bl	102234c <update_cache>
 1022d8e:	e7d3      	b.n	1022d38 <z_set_prio+0x88>
	return (node == list->tail) ? NULL : node->next;
 1022d90:	42aa      	cmp	r2, r5
 1022d92:	d0e9      	beq.n	1022d68 <z_set_prio+0xb8>
 1022d94:	682d      	ldr	r5, [r5, #0]
 1022d96:	e7e6      	b.n	1022d66 <z_set_prio+0xb6>
	__asm__ volatile(
 1022d98:	f389 8811 	msr	BASEPRI, r9
 1022d9c:	f3bf 8f6f 	isb	sy
}
 1022da0:	4638      	mov	r0, r7
 1022da2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 1022da6:	bf00      	nop
 1022da8:	21008110 	.word	0x21008110
 1022dac:	0102bd8a 	.word	0x0102bd8a
 1022db0:	0102bde3 	.word	0x0102bde3
 1022db4:	0102b695 	.word	0x0102b695
 1022db8:	0102bdf8 	.word	0x0102bdf8
 1022dbc:	210080e8 	.word	0x210080e8
 1022dc0:	21004410 	.word	0x21004410
 1022dc4:	0102fb58 	.word	0x0102fb58
 1022dc8:	0102fb0f 	.word	0x0102fb0f
 1022dcc:	0102bdb7 	.word	0x0102bdb7
 1022dd0:	0102bdce 	.word	0x0102bdce

01022dd4 <z_impl_k_thread_suspend>:
{
 1022dd4:	b570      	push	{r4, r5, r6, lr}
 1022dd6:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
 1022dd8:	3018      	adds	r0, #24
 1022dda:	f000 fda7 	bl	102392c <z_abort_timeout>
	__asm__ volatile(
 1022dde:	f04f 0320 	mov.w	r3, #32
 1022de2:	f3ef 8611 	mrs	r6, BASEPRI
 1022de6:	f383 8812 	msr	BASEPRI_MAX, r3
 1022dea:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1022dee:	4824      	ldr	r0, [pc, #144]	; (1022e80 <z_impl_k_thread_suspend+0xac>)
 1022df0:	f7fe f96e 	bl	10210d0 <z_spin_lock_valid>
 1022df4:	b968      	cbnz	r0, 1022e12 <z_impl_k_thread_suspend+0x3e>
 1022df6:	2394      	movs	r3, #148	; 0x94
 1022df8:	4a22      	ldr	r2, [pc, #136]	; (1022e84 <z_impl_k_thread_suspend+0xb0>)
 1022dfa:	4923      	ldr	r1, [pc, #140]	; (1022e88 <z_impl_k_thread_suspend+0xb4>)
 1022dfc:	4823      	ldr	r0, [pc, #140]	; (1022e8c <z_impl_k_thread_suspend+0xb8>)
 1022dfe:	f001 feea 	bl	1024bd6 <assert_print>
 1022e02:	491f      	ldr	r1, [pc, #124]	; (1022e80 <z_impl_k_thread_suspend+0xac>)
 1022e04:	4822      	ldr	r0, [pc, #136]	; (1022e90 <z_impl_k_thread_suspend+0xbc>)
 1022e06:	f001 fee6 	bl	1024bd6 <assert_print>
 1022e0a:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022e0c:	481d      	ldr	r0, [pc, #116]	; (1022e84 <z_impl_k_thread_suspend+0xb0>)
 1022e0e:	f001 fedb 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1022e12:	481b      	ldr	r0, [pc, #108]	; (1022e80 <z_impl_k_thread_suspend+0xac>)
 1022e14:	f7fe f978 	bl	1021108 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
 1022e18:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
 1022e1c:	7b63      	ldrb	r3, [r4, #13]
 1022e1e:	2a00      	cmp	r2, #0
 1022e20:	da06      	bge.n	1022e30 <z_impl_k_thread_suspend+0x5c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 1022e22:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	_priq_run_remove(thread_runq(thread), thread);
 1022e26:	4621      	mov	r1, r4
 1022e28:	481a      	ldr	r0, [pc, #104]	; (1022e94 <z_impl_k_thread_suspend+0xc0>)
	thread->base.thread_state &= ~_THREAD_QUEUED;
 1022e2a:	7363      	strb	r3, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
 1022e2c:	f7ff fd70 	bl	1022910 <z_priq_dumb_remove>
		update_cache(thread == _current);
 1022e30:	4d19      	ldr	r5, [pc, #100]	; (1022e98 <z_impl_k_thread_suspend+0xc4>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
 1022e32:	7b63      	ldrb	r3, [r4, #13]
 1022e34:	68a8      	ldr	r0, [r5, #8]
 1022e36:	f043 0310 	orr.w	r3, r3, #16
 1022e3a:	7363      	strb	r3, [r4, #13]
 1022e3c:	1b03      	subs	r3, r0, r4
 1022e3e:	4258      	negs	r0, r3
 1022e40:	4158      	adcs	r0, r3
 1022e42:	f7ff fa83 	bl	102234c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022e46:	480e      	ldr	r0, [pc, #56]	; (1022e80 <z_impl_k_thread_suspend+0xac>)
 1022e48:	f7fe f950 	bl	10210ec <z_spin_unlock_valid>
 1022e4c:	b958      	cbnz	r0, 1022e66 <z_impl_k_thread_suspend+0x92>
 1022e4e:	23c2      	movs	r3, #194	; 0xc2
 1022e50:	4a0c      	ldr	r2, [pc, #48]	; (1022e84 <z_impl_k_thread_suspend+0xb0>)
 1022e52:	4912      	ldr	r1, [pc, #72]	; (1022e9c <z_impl_k_thread_suspend+0xc8>)
 1022e54:	480d      	ldr	r0, [pc, #52]	; (1022e8c <z_impl_k_thread_suspend+0xb8>)
 1022e56:	f001 febe 	bl	1024bd6 <assert_print>
 1022e5a:	4909      	ldr	r1, [pc, #36]	; (1022e80 <z_impl_k_thread_suspend+0xac>)
 1022e5c:	4810      	ldr	r0, [pc, #64]	; (1022ea0 <z_impl_k_thread_suspend+0xcc>)
 1022e5e:	f001 feba 	bl	1024bd6 <assert_print>
 1022e62:	21c2      	movs	r1, #194	; 0xc2
 1022e64:	e7d2      	b.n	1022e0c <z_impl_k_thread_suspend+0x38>
	__asm__ volatile(
 1022e66:	f386 8811 	msr	BASEPRI, r6
 1022e6a:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
 1022e6e:	68ab      	ldr	r3, [r5, #8]
 1022e70:	42a3      	cmp	r3, r4
 1022e72:	d103      	bne.n	1022e7c <z_impl_k_thread_suspend+0xa8>
}
 1022e74:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
 1022e78:	f006 bad8 	b.w	102942c <z_reschedule_unlocked>
}
 1022e7c:	bd70      	pop	{r4, r5, r6, pc}
 1022e7e:	bf00      	nop
 1022e80:	21008110 	.word	0x21008110
 1022e84:	0102bd8a 	.word	0x0102bd8a
 1022e88:	0102bde3 	.word	0x0102bde3
 1022e8c:	0102b695 	.word	0x0102b695
 1022e90:	0102bdf8 	.word	0x0102bdf8
 1022e94:	210080e8 	.word	0x210080e8
 1022e98:	210080cc 	.word	0x210080cc
 1022e9c:	0102bdb7 	.word	0x0102bdb7
 1022ea0:	0102bdce 	.word	0x0102bdce

01022ea4 <unpend_thread_no_timeout>:
{
 1022ea4:	b510      	push	{r4, lr}
 1022ea6:	4604      	mov	r4, r0
 1022ea8:	6880      	ldr	r0, [r0, #8]
	__ASSERT_NO_MSG(thread->base.pended_on);
 1022eaa:	b958      	cbnz	r0, 1022ec4 <unpend_thread_no_timeout+0x20>
 1022eac:	490a      	ldr	r1, [pc, #40]	; (1022ed8 <unpend_thread_no_timeout+0x34>)
 1022eae:	480b      	ldr	r0, [pc, #44]	; (1022edc <unpend_thread_no_timeout+0x38>)
 1022eb0:	f240 23d6 	movw	r3, #726	; 0x2d6
 1022eb4:	4a0a      	ldr	r2, [pc, #40]	; (1022ee0 <unpend_thread_no_timeout+0x3c>)
 1022eb6:	f001 fe8e 	bl	1024bd6 <assert_print>
 1022eba:	f240 21d6 	movw	r1, #726	; 0x2d6
 1022ebe:	4808      	ldr	r0, [pc, #32]	; (1022ee0 <unpend_thread_no_timeout+0x3c>)
 1022ec0:	f001 fe82 	bl	1024bc8 <assert_post_action>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
 1022ec4:	4621      	mov	r1, r4
 1022ec6:	f7ff fd23 	bl	1022910 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 1022eca:	7b63      	ldrb	r3, [r4, #13]
 1022ecc:	f023 0302 	bic.w	r3, r3, #2
 1022ed0:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
 1022ed2:	2300      	movs	r3, #0
 1022ed4:	60a3      	str	r3, [r4, #8]
}
 1022ed6:	bd10      	pop	{r4, pc}
 1022ed8:	0102fc3d 	.word	0x0102fc3d
 1022edc:	0102b695 	.word	0x0102b695
 1022ee0:	0102fb0f 	.word	0x0102fb0f

01022ee4 <z_unpend_thread>:
{
 1022ee4:	b538      	push	{r3, r4, r5, lr}
 1022ee6:	4604      	mov	r4, r0
	__asm__ volatile(
 1022ee8:	f04f 0320 	mov.w	r3, #32
 1022eec:	f3ef 8511 	mrs	r5, BASEPRI
 1022ef0:	f383 8812 	msr	BASEPRI_MAX, r3
 1022ef4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1022ef8:	4818      	ldr	r0, [pc, #96]	; (1022f5c <z_unpend_thread+0x78>)
 1022efa:	f7fe f8e9 	bl	10210d0 <z_spin_lock_valid>
 1022efe:	b968      	cbnz	r0, 1022f1c <z_unpend_thread+0x38>
 1022f00:	2394      	movs	r3, #148	; 0x94
 1022f02:	4a17      	ldr	r2, [pc, #92]	; (1022f60 <z_unpend_thread+0x7c>)
 1022f04:	4917      	ldr	r1, [pc, #92]	; (1022f64 <z_unpend_thread+0x80>)
 1022f06:	4818      	ldr	r0, [pc, #96]	; (1022f68 <z_unpend_thread+0x84>)
 1022f08:	f001 fe65 	bl	1024bd6 <assert_print>
 1022f0c:	4913      	ldr	r1, [pc, #76]	; (1022f5c <z_unpend_thread+0x78>)
 1022f0e:	4817      	ldr	r0, [pc, #92]	; (1022f6c <z_unpend_thread+0x88>)
 1022f10:	f001 fe61 	bl	1024bd6 <assert_print>
 1022f14:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022f16:	4812      	ldr	r0, [pc, #72]	; (1022f60 <z_unpend_thread+0x7c>)
 1022f18:	f001 fe56 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1022f1c:	480f      	ldr	r0, [pc, #60]	; (1022f5c <z_unpend_thread+0x78>)
 1022f1e:	f7fe f8f3 	bl	1021108 <z_spin_lock_set_owner>
		unpend_thread_no_timeout(thread);
 1022f22:	4620      	mov	r0, r4
 1022f24:	f7ff ffbe 	bl	1022ea4 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022f28:	480c      	ldr	r0, [pc, #48]	; (1022f5c <z_unpend_thread+0x78>)
 1022f2a:	f7fe f8df 	bl	10210ec <z_spin_unlock_valid>
 1022f2e:	b958      	cbnz	r0, 1022f48 <z_unpend_thread+0x64>
 1022f30:	23c2      	movs	r3, #194	; 0xc2
 1022f32:	4a0b      	ldr	r2, [pc, #44]	; (1022f60 <z_unpend_thread+0x7c>)
 1022f34:	490e      	ldr	r1, [pc, #56]	; (1022f70 <z_unpend_thread+0x8c>)
 1022f36:	480c      	ldr	r0, [pc, #48]	; (1022f68 <z_unpend_thread+0x84>)
 1022f38:	f001 fe4d 	bl	1024bd6 <assert_print>
 1022f3c:	4907      	ldr	r1, [pc, #28]	; (1022f5c <z_unpend_thread+0x78>)
 1022f3e:	480d      	ldr	r0, [pc, #52]	; (1022f74 <z_unpend_thread+0x90>)
 1022f40:	f001 fe49 	bl	1024bd6 <assert_print>
 1022f44:	21c2      	movs	r1, #194	; 0xc2
 1022f46:	e7e6      	b.n	1022f16 <z_unpend_thread+0x32>
	__asm__ volatile(
 1022f48:	f385 8811 	msr	BASEPRI, r5
 1022f4c:	f3bf 8f6f 	isb	sy
 1022f50:	f104 0018 	add.w	r0, r4, #24
}
 1022f54:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 1022f58:	f000 bce8 	b.w	102392c <z_abort_timeout>
 1022f5c:	21008110 	.word	0x21008110
 1022f60:	0102bd8a 	.word	0x0102bd8a
 1022f64:	0102bde3 	.word	0x0102bde3
 1022f68:	0102b695 	.word	0x0102b695
 1022f6c:	0102bdf8 	.word	0x0102bdf8
 1022f70:	0102bdb7 	.word	0x0102bdb7
 1022f74:	0102bdce 	.word	0x0102bdce

01022f78 <z_thread_timeout>:
{
 1022f78:	b570      	push	{r4, r5, r6, lr}
 1022f7a:	4604      	mov	r4, r0
	__asm__ volatile(
 1022f7c:	f04f 0320 	mov.w	r3, #32
 1022f80:	f3ef 8611 	mrs	r6, BASEPRI
 1022f84:	f383 8812 	msr	BASEPRI_MAX, r3
 1022f88:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1022f8c:	481f      	ldr	r0, [pc, #124]	; (102300c <z_thread_timeout+0x94>)
 1022f8e:	f7fe f89f 	bl	10210d0 <z_spin_lock_valid>
 1022f92:	b968      	cbnz	r0, 1022fb0 <z_thread_timeout+0x38>
 1022f94:	2394      	movs	r3, #148	; 0x94
 1022f96:	4a1e      	ldr	r2, [pc, #120]	; (1023010 <z_thread_timeout+0x98>)
 1022f98:	491e      	ldr	r1, [pc, #120]	; (1023014 <z_thread_timeout+0x9c>)
 1022f9a:	481f      	ldr	r0, [pc, #124]	; (1023018 <z_thread_timeout+0xa0>)
 1022f9c:	f001 fe1b 	bl	1024bd6 <assert_print>
 1022fa0:	491a      	ldr	r1, [pc, #104]	; (102300c <z_thread_timeout+0x94>)
 1022fa2:	481e      	ldr	r0, [pc, #120]	; (102301c <z_thread_timeout+0xa4>)
 1022fa4:	f001 fe17 	bl	1024bd6 <assert_print>
 1022fa8:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022faa:	4819      	ldr	r0, [pc, #100]	; (1023010 <z_thread_timeout+0x98>)
 1022fac:	f001 fe0c 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1022fb0:	4816      	ldr	r0, [pc, #88]	; (102300c <z_thread_timeout+0x94>)
 1022fb2:	f7fe f8a9 	bl	1021108 <z_spin_lock_set_owner>
		if (!killed) {
 1022fb6:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
 1022fba:	f013 0f28 	tst.w	r3, #40	; 0x28
 1022fbe:	d110      	bne.n	1022fe2 <z_thread_timeout+0x6a>
			if (thread->base.pended_on != NULL) {
 1022fc0:	f854 3c10 	ldr.w	r3, [r4, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
 1022fc4:	f1a4 0518 	sub.w	r5, r4, #24
			if (thread->base.pended_on != NULL) {
 1022fc8:	b113      	cbz	r3, 1022fd0 <z_thread_timeout+0x58>
				unpend_thread_no_timeout(thread);
 1022fca:	4628      	mov	r0, r5
 1022fcc:	f7ff ff6a 	bl	1022ea4 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 1022fd0:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
			ready_thread(thread);
 1022fd4:	4628      	mov	r0, r5
 1022fd6:	f023 0314 	bic.w	r3, r3, #20
 1022fda:	f804 3c0b 	strb.w	r3, [r4, #-11]
 1022fde:	f7ff f9e9 	bl	10223b4 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1022fe2:	480a      	ldr	r0, [pc, #40]	; (102300c <z_thread_timeout+0x94>)
 1022fe4:	f7fe f882 	bl	10210ec <z_spin_unlock_valid>
 1022fe8:	b958      	cbnz	r0, 1023002 <z_thread_timeout+0x8a>
 1022fea:	23c2      	movs	r3, #194	; 0xc2
 1022fec:	4a08      	ldr	r2, [pc, #32]	; (1023010 <z_thread_timeout+0x98>)
 1022fee:	490c      	ldr	r1, [pc, #48]	; (1023020 <z_thread_timeout+0xa8>)
 1022ff0:	4809      	ldr	r0, [pc, #36]	; (1023018 <z_thread_timeout+0xa0>)
 1022ff2:	f001 fdf0 	bl	1024bd6 <assert_print>
 1022ff6:	4905      	ldr	r1, [pc, #20]	; (102300c <z_thread_timeout+0x94>)
 1022ff8:	480a      	ldr	r0, [pc, #40]	; (1023024 <z_thread_timeout+0xac>)
 1022ffa:	f001 fdec 	bl	1024bd6 <assert_print>
 1022ffe:	21c2      	movs	r1, #194	; 0xc2
 1023000:	e7d3      	b.n	1022faa <z_thread_timeout+0x32>
	__asm__ volatile(
 1023002:	f386 8811 	msr	BASEPRI, r6
 1023006:	f3bf 8f6f 	isb	sy
}
 102300a:	bd70      	pop	{r4, r5, r6, pc}
 102300c:	21008110 	.word	0x21008110
 1023010:	0102bd8a 	.word	0x0102bd8a
 1023014:	0102bde3 	.word	0x0102bde3
 1023018:	0102b695 	.word	0x0102b695
 102301c:	0102bdf8 	.word	0x0102bdf8
 1023020:	0102bdb7 	.word	0x0102bdb7
 1023024:	0102bdce 	.word	0x0102bdce

01023028 <z_unpend1_no_timeout>:
{
 1023028:	b570      	push	{r4, r5, r6, lr}
 102302a:	4605      	mov	r5, r0
	__asm__ volatile(
 102302c:	f04f 0320 	mov.w	r3, #32
 1023030:	f3ef 8611 	mrs	r6, BASEPRI
 1023034:	f383 8812 	msr	BASEPRI_MAX, r3
 1023038:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 102303c:	4819      	ldr	r0, [pc, #100]	; (10230a4 <z_unpend1_no_timeout+0x7c>)
 102303e:	f7fe f847 	bl	10210d0 <z_spin_lock_valid>
 1023042:	b968      	cbnz	r0, 1023060 <z_unpend1_no_timeout+0x38>
 1023044:	2394      	movs	r3, #148	; 0x94
 1023046:	4a18      	ldr	r2, [pc, #96]	; (10230a8 <z_unpend1_no_timeout+0x80>)
 1023048:	4918      	ldr	r1, [pc, #96]	; (10230ac <z_unpend1_no_timeout+0x84>)
 102304a:	4819      	ldr	r0, [pc, #100]	; (10230b0 <z_unpend1_no_timeout+0x88>)
 102304c:	f001 fdc3 	bl	1024bd6 <assert_print>
 1023050:	4914      	ldr	r1, [pc, #80]	; (10230a4 <z_unpend1_no_timeout+0x7c>)
 1023052:	4818      	ldr	r0, [pc, #96]	; (10230b4 <z_unpend1_no_timeout+0x8c>)
 1023054:	f001 fdbf 	bl	1024bd6 <assert_print>
 1023058:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 102305a:	4813      	ldr	r0, [pc, #76]	; (10230a8 <z_unpend1_no_timeout+0x80>)
 102305c:	f001 fdb4 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1023060:	4810      	ldr	r0, [pc, #64]	; (10230a4 <z_unpend1_no_timeout+0x7c>)
 1023062:	f7fe f851 	bl	1021108 <z_spin_lock_set_owner>
	return list->head == list;
 1023066:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1023068:	42a5      	cmp	r5, r4
 102306a:	d013      	beq.n	1023094 <z_unpend1_no_timeout+0x6c>
		if (thread != NULL) {
 102306c:	b114      	cbz	r4, 1023074 <z_unpend1_no_timeout+0x4c>
			unpend_thread_no_timeout(thread);
 102306e:	4620      	mov	r0, r4
 1023070:	f7ff ff18 	bl	1022ea4 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023074:	480b      	ldr	r0, [pc, #44]	; (10230a4 <z_unpend1_no_timeout+0x7c>)
 1023076:	f7fe f839 	bl	10210ec <z_spin_unlock_valid>
 102307a:	b968      	cbnz	r0, 1023098 <z_unpend1_no_timeout+0x70>
 102307c:	23c2      	movs	r3, #194	; 0xc2
 102307e:	4a0a      	ldr	r2, [pc, #40]	; (10230a8 <z_unpend1_no_timeout+0x80>)
 1023080:	490d      	ldr	r1, [pc, #52]	; (10230b8 <z_unpend1_no_timeout+0x90>)
 1023082:	480b      	ldr	r0, [pc, #44]	; (10230b0 <z_unpend1_no_timeout+0x88>)
 1023084:	f001 fda7 	bl	1024bd6 <assert_print>
 1023088:	4906      	ldr	r1, [pc, #24]	; (10230a4 <z_unpend1_no_timeout+0x7c>)
 102308a:	480c      	ldr	r0, [pc, #48]	; (10230bc <z_unpend1_no_timeout+0x94>)
 102308c:	f001 fda3 	bl	1024bd6 <assert_print>
 1023090:	21c2      	movs	r1, #194	; 0xc2
 1023092:	e7e2      	b.n	102305a <z_unpend1_no_timeout+0x32>
 1023094:	2400      	movs	r4, #0
 1023096:	e7ed      	b.n	1023074 <z_unpend1_no_timeout+0x4c>
	__asm__ volatile(
 1023098:	f386 8811 	msr	BASEPRI, r6
 102309c:	f3bf 8f6f 	isb	sy
}
 10230a0:	4620      	mov	r0, r4
 10230a2:	bd70      	pop	{r4, r5, r6, pc}
 10230a4:	21008110 	.word	0x21008110
 10230a8:	0102bd8a 	.word	0x0102bd8a
 10230ac:	0102bde3 	.word	0x0102bde3
 10230b0:	0102b695 	.word	0x0102b695
 10230b4:	0102bdf8 	.word	0x0102bdf8
 10230b8:	0102bdb7 	.word	0x0102bdb7
 10230bc:	0102bdce 	.word	0x0102bdce

010230c0 <z_unpend_first_thread>:
{
 10230c0:	b570      	push	{r4, r5, r6, lr}
 10230c2:	4605      	mov	r5, r0
	__asm__ volatile(
 10230c4:	f04f 0320 	mov.w	r3, #32
 10230c8:	f3ef 8611 	mrs	r6, BASEPRI
 10230cc:	f383 8812 	msr	BASEPRI_MAX, r3
 10230d0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10230d4:	481b      	ldr	r0, [pc, #108]	; (1023144 <z_unpend_first_thread+0x84>)
 10230d6:	f7fd fffb 	bl	10210d0 <z_spin_lock_valid>
 10230da:	b968      	cbnz	r0, 10230f8 <z_unpend_first_thread+0x38>
 10230dc:	2394      	movs	r3, #148	; 0x94
 10230de:	4a1a      	ldr	r2, [pc, #104]	; (1023148 <z_unpend_first_thread+0x88>)
 10230e0:	491a      	ldr	r1, [pc, #104]	; (102314c <z_unpend_first_thread+0x8c>)
 10230e2:	481b      	ldr	r0, [pc, #108]	; (1023150 <z_unpend_first_thread+0x90>)
 10230e4:	f001 fd77 	bl	1024bd6 <assert_print>
 10230e8:	4916      	ldr	r1, [pc, #88]	; (1023144 <z_unpend_first_thread+0x84>)
 10230ea:	481a      	ldr	r0, [pc, #104]	; (1023154 <z_unpend_first_thread+0x94>)
 10230ec:	f001 fd73 	bl	1024bd6 <assert_print>
 10230f0:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10230f2:	4815      	ldr	r0, [pc, #84]	; (1023148 <z_unpend_first_thread+0x88>)
 10230f4:	f001 fd68 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 10230f8:	4812      	ldr	r0, [pc, #72]	; (1023144 <z_unpend_first_thread+0x84>)
 10230fa:	f7fe f805 	bl	1021108 <z_spin_lock_set_owner>
	return list->head == list;
 10230fe:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1023100:	42a5      	cmp	r5, r4
 1023102:	d017      	beq.n	1023134 <z_unpend_first_thread+0x74>
		if (thread != NULL) {
 1023104:	b134      	cbz	r4, 1023114 <z_unpend_first_thread+0x54>
			unpend_thread_no_timeout(thread);
 1023106:	4620      	mov	r0, r4
 1023108:	f7ff fecc 	bl	1022ea4 <unpend_thread_no_timeout>
 102310c:	f104 0018 	add.w	r0, r4, #24
 1023110:	f000 fc0c 	bl	102392c <z_abort_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023114:	480b      	ldr	r0, [pc, #44]	; (1023144 <z_unpend_first_thread+0x84>)
 1023116:	f7fd ffe9 	bl	10210ec <z_spin_unlock_valid>
 102311a:	b968      	cbnz	r0, 1023138 <z_unpend_first_thread+0x78>
 102311c:	23c2      	movs	r3, #194	; 0xc2
 102311e:	4a0a      	ldr	r2, [pc, #40]	; (1023148 <z_unpend_first_thread+0x88>)
 1023120:	490d      	ldr	r1, [pc, #52]	; (1023158 <z_unpend_first_thread+0x98>)
 1023122:	480b      	ldr	r0, [pc, #44]	; (1023150 <z_unpend_first_thread+0x90>)
 1023124:	f001 fd57 	bl	1024bd6 <assert_print>
 1023128:	4906      	ldr	r1, [pc, #24]	; (1023144 <z_unpend_first_thread+0x84>)
 102312a:	480c      	ldr	r0, [pc, #48]	; (102315c <z_unpend_first_thread+0x9c>)
 102312c:	f001 fd53 	bl	1024bd6 <assert_print>
 1023130:	21c2      	movs	r1, #194	; 0xc2
 1023132:	e7de      	b.n	10230f2 <z_unpend_first_thread+0x32>
 1023134:	2400      	movs	r4, #0
 1023136:	e7ed      	b.n	1023114 <z_unpend_first_thread+0x54>
	__asm__ volatile(
 1023138:	f386 8811 	msr	BASEPRI, r6
 102313c:	f3bf 8f6f 	isb	sy
}
 1023140:	4620      	mov	r0, r4
 1023142:	bd70      	pop	{r4, r5, r6, pc}
 1023144:	21008110 	.word	0x21008110
 1023148:	0102bd8a 	.word	0x0102bd8a
 102314c:	0102bde3 	.word	0x0102bde3
 1023150:	0102b695 	.word	0x0102b695
 1023154:	0102bdf8 	.word	0x0102bdf8
 1023158:	0102bdb7 	.word	0x0102bdb7
 102315c:	0102bdce 	.word	0x0102bdce

01023160 <z_sched_init>:
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
 1023160:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
 1023162:	4b04      	ldr	r3, [pc, #16]	; (1023174 <z_sched_init+0x14>)
 1023164:	4608      	mov	r0, r1
 1023166:	f103 021c 	add.w	r2, r3, #28
	list->tail = (sys_dnode_t *)list;
 102316a:	e9c3 2207 	strd	r2, r2, [r3, #28]
 102316e:	f7ff b96b 	b.w	1022448 <k_sched_time_slice_set>
 1023172:	bf00      	nop
 1023174:	210080cc 	.word	0x210080cc

01023178 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
 1023178:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 102317a:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
 102317e:	b16b      	cbz	r3, 102319c <z_impl_k_yield+0x24>
 1023180:	493c      	ldr	r1, [pc, #240]	; (1023274 <z_impl_k_yield+0xfc>)
 1023182:	f44f 63ae 	mov.w	r3, #1392	; 0x570
 1023186:	4a3c      	ldr	r2, [pc, #240]	; (1023278 <z_impl_k_yield+0x100>)
 1023188:	483c      	ldr	r0, [pc, #240]	; (102327c <z_impl_k_yield+0x104>)
 102318a:	f001 fd24 	bl	1024bd6 <assert_print>
 102318e:	483c      	ldr	r0, [pc, #240]	; (1023280 <z_impl_k_yield+0x108>)
 1023190:	f001 fd21 	bl	1024bd6 <assert_print>
 1023194:	f44f 61ae 	mov.w	r1, #1392	; 0x570
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
 1023198:	4837      	ldr	r0, [pc, #220]	; (1023278 <z_impl_k_yield+0x100>)
 102319a:	e017      	b.n	10231cc <z_impl_k_yield+0x54>
	__asm__ volatile(
 102319c:	f04f 0320 	mov.w	r3, #32
 10231a0:	f3ef 8611 	mrs	r6, BASEPRI
 10231a4:	f383 8812 	msr	BASEPRI_MAX, r3
 10231a8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10231ac:	4835      	ldr	r0, [pc, #212]	; (1023284 <z_impl_k_yield+0x10c>)
 10231ae:	f7fd ff8f 	bl	10210d0 <z_spin_lock_valid>
 10231b2:	b968      	cbnz	r0, 10231d0 <z_impl_k_yield+0x58>
 10231b4:	2394      	movs	r3, #148	; 0x94
 10231b6:	4a34      	ldr	r2, [pc, #208]	; (1023288 <z_impl_k_yield+0x110>)
 10231b8:	4934      	ldr	r1, [pc, #208]	; (102328c <z_impl_k_yield+0x114>)
 10231ba:	4830      	ldr	r0, [pc, #192]	; (102327c <z_impl_k_yield+0x104>)
 10231bc:	f001 fd0b 	bl	1024bd6 <assert_print>
 10231c0:	4930      	ldr	r1, [pc, #192]	; (1023284 <z_impl_k_yield+0x10c>)
 10231c2:	4833      	ldr	r0, [pc, #204]	; (1023290 <z_impl_k_yield+0x118>)
 10231c4:	f001 fd07 	bl	1024bd6 <assert_print>
 10231c8:	2194      	movs	r1, #148	; 0x94
 10231ca:	482f      	ldr	r0, [pc, #188]	; (1023288 <z_impl_k_yield+0x110>)
 10231cc:	f001 fcfc 	bl	1024bc8 <assert_post_action>

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
 10231d0:	4c30      	ldr	r4, [pc, #192]	; (1023294 <z_impl_k_yield+0x11c>)
	z_spin_lock_set_owner(l);
 10231d2:	482c      	ldr	r0, [pc, #176]	; (1023284 <z_impl_k_yield+0x10c>)
 10231d4:	f7fd ff98 	bl	1021108 <z_spin_lock_set_owner>
 10231d8:	68a1      	ldr	r1, [r4, #8]
	_priq_run_remove(thread_runq(thread), thread);
 10231da:	f104 051c 	add.w	r5, r4, #28
	thread->base.thread_state &= ~_THREAD_QUEUED;
 10231de:	7b4b      	ldrb	r3, [r1, #13]
	_priq_run_remove(thread_runq(thread), thread);
 10231e0:	4628      	mov	r0, r5
	thread->base.thread_state &= ~_THREAD_QUEUED;
 10231e2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 10231e6:	734b      	strb	r3, [r1, #13]
	_priq_run_remove(thread_runq(thread), thread);
 10231e8:	f7ff fb92 	bl	1022910 <z_priq_dumb_remove>
	}
	queue_thread(_current);
 10231ec:	68a3      	ldr	r3, [r4, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
 10231ee:	7b5a      	ldrb	r2, [r3, #13]
 10231f0:	f062 027f 	orn	r2, r2, #127	; 0x7f
 10231f4:	735a      	strb	r2, [r3, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
 10231f6:	4a28      	ldr	r2, [pc, #160]	; (1023298 <z_impl_k_yield+0x120>)
 10231f8:	4293      	cmp	r3, r2
 10231fa:	d107      	bne.n	102320c <z_impl_k_yield+0x94>
 10231fc:	4927      	ldr	r1, [pc, #156]	; (102329c <z_impl_k_yield+0x124>)
 10231fe:	23ba      	movs	r3, #186	; 0xba
 1023200:	4a1d      	ldr	r2, [pc, #116]	; (1023278 <z_impl_k_yield+0x100>)
 1023202:	481e      	ldr	r0, [pc, #120]	; (102327c <z_impl_k_yield+0x104>)
 1023204:	f001 fce7 	bl	1024bd6 <assert_print>
 1023208:	21ba      	movs	r1, #186	; 0xba
 102320a:	e7c5      	b.n	1023198 <z_impl_k_yield+0x20>
	return list->head == list;
 102320c:	69e2      	ldr	r2, [r4, #28]
	return (node == list->tail) ? NULL : node->next;
 102320e:	6a21      	ldr	r1, [r4, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1023210:	42aa      	cmp	r2, r5
 1023212:	bf08      	it	eq
 1023214:	2200      	moveq	r2, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 1023216:	b922      	cbnz	r2, 1023222 <z_impl_k_yield+0xaa>
	node->prev = tail;
 1023218:	e9c3 5100 	strd	r5, r1, [r3]
	tail->next = node;
 102321c:	600b      	str	r3, [r1, #0]
	list->tail = node;
 102321e:	6223      	str	r3, [r4, #32]
}
 1023220:	e00c      	b.n	102323c <z_impl_k_yield+0xc4>
	int32_t b1 = thread_1->base.prio;
 1023222:	f993 000e 	ldrsb.w	r0, [r3, #14]
	int32_t b2 = thread_2->base.prio;
 1023226:	f992 700e 	ldrsb.w	r7, [r2, #14]
	if (b1 != b2) {
 102322a:	42b8      	cmp	r0, r7
 102322c:	d019      	beq.n	1023262 <z_impl_k_yield+0xea>
		if (z_sched_prio_cmp(thread, t) > 0) {
 102322e:	4287      	cmp	r7, r0
 1023230:	dd17      	ble.n	1023262 <z_impl_k_yield+0xea>
	sys_dnode_t *const prev = successor->prev;
 1023232:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
 1023234:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
 1023238:	600b      	str	r3, [r1, #0]
	successor->prev = node;
 102323a:	6053      	str	r3, [r2, #4]
	update_cache(1);
 102323c:	2001      	movs	r0, #1
 102323e:	f7ff f885 	bl	102234c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023242:	4810      	ldr	r0, [pc, #64]	; (1023284 <z_impl_k_yield+0x10c>)
 1023244:	f7fd ff52 	bl	10210ec <z_spin_unlock_valid>
 1023248:	b978      	cbnz	r0, 102326a <z_impl_k_yield+0xf2>
 102324a:	23e1      	movs	r3, #225	; 0xe1
 102324c:	4a0e      	ldr	r2, [pc, #56]	; (1023288 <z_impl_k_yield+0x110>)
 102324e:	4914      	ldr	r1, [pc, #80]	; (10232a0 <z_impl_k_yield+0x128>)
 1023250:	480a      	ldr	r0, [pc, #40]	; (102327c <z_impl_k_yield+0x104>)
 1023252:	f001 fcc0 	bl	1024bd6 <assert_print>
 1023256:	490b      	ldr	r1, [pc, #44]	; (1023284 <z_impl_k_yield+0x10c>)
 1023258:	4812      	ldr	r0, [pc, #72]	; (10232a4 <z_impl_k_yield+0x12c>)
 102325a:	f001 fcbc 	bl	1024bd6 <assert_print>
 102325e:	21e1      	movs	r1, #225	; 0xe1
 1023260:	e7b3      	b.n	10231ca <z_impl_k_yield+0x52>
	return (node == list->tail) ? NULL : node->next;
 1023262:	428a      	cmp	r2, r1
 1023264:	d0d8      	beq.n	1023218 <z_impl_k_yield+0xa0>
 1023266:	6812      	ldr	r2, [r2, #0]
 1023268:	e7d5      	b.n	1023216 <z_impl_k_yield+0x9e>
 102326a:	4630      	mov	r0, r6
	z_swap(&sched_spinlock, key);
}
 102326c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 1023270:	f7e2 be36 	b.w	1005ee0 <arch_swap>
 1023274:	0102f8a2 	.word	0x0102f8a2
 1023278:	0102fb0f 	.word	0x0102fb0f
 102327c:	0102b695 	.word	0x0102b695
 1023280:	0102ee84 	.word	0x0102ee84
 1023284:	21008110 	.word	0x21008110
 1023288:	0102bd8a 	.word	0x0102bd8a
 102328c:	0102bde3 	.word	0x0102bde3
 1023290:	0102bdf8 	.word	0x0102bdf8
 1023294:	210080cc 	.word	0x210080cc
 1023298:	21004410 	.word	0x21004410
 102329c:	0102fb58 	.word	0x0102fb58
 10232a0:	0102bdb7 	.word	0x0102bdb7
 10232a4:	0102bdce 	.word	0x0102bdce

010232a8 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
 10232a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10232ac:	4605      	mov	r5, r0
 10232ae:	460e      	mov	r6, r1
 10232b0:	f3ef 8305 	mrs	r3, IPSR
#ifdef CONFIG_MULTITHREADING
	uint32_t expected_wakeup_ticks;

	__ASSERT(!arch_is_in_isr(), "");
 10232b4:	b16b      	cbz	r3, 10232d2 <z_tick_sleep+0x2a>
 10232b6:	493f      	ldr	r1, [pc, #252]	; (10233b4 <z_tick_sleep+0x10c>)
 10232b8:	f240 538c 	movw	r3, #1420	; 0x58c
 10232bc:	4a3e      	ldr	r2, [pc, #248]	; (10233b8 <z_tick_sleep+0x110>)
 10232be:	483f      	ldr	r0, [pc, #252]	; (10233bc <z_tick_sleep+0x114>)
 10232c0:	f001 fc89 	bl	1024bd6 <assert_print>
 10232c4:	483e      	ldr	r0, [pc, #248]	; (10233c0 <z_tick_sleep+0x118>)
 10232c6:	f001 fc86 	bl	1024bd6 <assert_print>
 10232ca:	f240 518c 	movw	r1, #1420	; 0x58c
	z_add_thread_timeout(_current, timeout);
	z_mark_thread_as_suspended(_current);

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
 10232ce:	483a      	ldr	r0, [pc, #232]	; (10233b8 <z_tick_sleep+0x110>)
 10232d0:	e025      	b.n	102331e <z_tick_sleep+0x76>
	if (ticks == 0) {
 10232d2:	ea50 0301 	orrs.w	r3, r0, r1
 10232d6:	d103      	bne.n	10232e0 <z_tick_sleep+0x38>
	z_impl_k_yield();
 10232d8:	f7ff ff4e 	bl	1023178 <z_impl_k_yield>
		return 0;
 10232dc:	2000      	movs	r0, #0
 10232de:	e066      	b.n	10233ae <z_tick_sleep+0x106>
	if (Z_TICK_ABS(ticks) <= 0) {
 10232e0:	1c82      	adds	r2, r0, #2
 10232e2:	f171 33ff 	sbcs.w	r3, r1, #4294967295
 10232e6:	db1c      	blt.n	1023322 <z_tick_sleep+0x7a>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
 10232e8:	f006 f8ba 	bl	1029460 <sys_clock_tick_get_32>
 10232ec:	182c      	adds	r4, r5, r0
 10232ee:	f04f 0320 	mov.w	r3, #32
 10232f2:	f3ef 8811 	mrs	r8, BASEPRI
 10232f6:	f383 8812 	msr	BASEPRI_MAX, r3
 10232fa:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10232fe:	4831      	ldr	r0, [pc, #196]	; (10233c4 <z_tick_sleep+0x11c>)
 1023300:	f7fd fee6 	bl	10210d0 <z_spin_lock_valid>
 1023304:	b988      	cbnz	r0, 102332a <z_tick_sleep+0x82>
 1023306:	2394      	movs	r3, #148	; 0x94
 1023308:	4a2f      	ldr	r2, [pc, #188]	; (10233c8 <z_tick_sleep+0x120>)
 102330a:	4930      	ldr	r1, [pc, #192]	; (10233cc <z_tick_sleep+0x124>)
 102330c:	482b      	ldr	r0, [pc, #172]	; (10233bc <z_tick_sleep+0x114>)
 102330e:	f001 fc62 	bl	1024bd6 <assert_print>
 1023312:	492c      	ldr	r1, [pc, #176]	; (10233c4 <z_tick_sleep+0x11c>)
 1023314:	482e      	ldr	r0, [pc, #184]	; (10233d0 <z_tick_sleep+0x128>)
 1023316:	f001 fc5e 	bl	1024bd6 <assert_print>
 102331a:	2194      	movs	r1, #148	; 0x94
 102331c:	482a      	ldr	r0, [pc, #168]	; (10233c8 <z_tick_sleep+0x120>)
 102331e:	f001 fc53 	bl	1024bc8 <assert_post_action>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
 1023322:	f06f 0401 	mvn.w	r4, #1
 1023326:	1a24      	subs	r4, r4, r0
 1023328:	e7e1      	b.n	10232ee <z_tick_sleep+0x46>
	pending_current = _current;
 102332a:	4f2a      	ldr	r7, [pc, #168]	; (10233d4 <z_tick_sleep+0x12c>)
	z_spin_lock_set_owner(l);
 102332c:	4825      	ldr	r0, [pc, #148]	; (10233c4 <z_tick_sleep+0x11c>)
 102332e:	f7fd feeb 	bl	1021108 <z_spin_lock_set_owner>
 1023332:	68b8      	ldr	r0, [r7, #8]
 1023334:	4b28      	ldr	r3, [pc, #160]	; (10233d8 <z_tick_sleep+0x130>)
 1023336:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
 1023338:	f7ff fbd2 	bl	1022ae0 <unready_thread>
	z_add_thread_timeout(_current, timeout);
 102333c:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 102333e:	462a      	mov	r2, r5
 1023340:	4633      	mov	r3, r6
 1023342:	3018      	adds	r0, #24
 1023344:	4925      	ldr	r1, [pc, #148]	; (10233dc <z_tick_sleep+0x134>)
 1023346:	f000 fa2b 	bl	10237a0 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
 102334a:	68ba      	ldr	r2, [r7, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 102334c:	481d      	ldr	r0, [pc, #116]	; (10233c4 <z_tick_sleep+0x11c>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
 102334e:	7b53      	ldrb	r3, [r2, #13]
 1023350:	f043 0310 	orr.w	r3, r3, #16
 1023354:	7353      	strb	r3, [r2, #13]
 1023356:	f7fd fec9 	bl	10210ec <z_spin_unlock_valid>
 102335a:	b958      	cbnz	r0, 1023374 <z_tick_sleep+0xcc>
 102335c:	23e1      	movs	r3, #225	; 0xe1
 102335e:	4a1a      	ldr	r2, [pc, #104]	; (10233c8 <z_tick_sleep+0x120>)
 1023360:	491f      	ldr	r1, [pc, #124]	; (10233e0 <z_tick_sleep+0x138>)
 1023362:	4816      	ldr	r0, [pc, #88]	; (10233bc <z_tick_sleep+0x114>)
 1023364:	f001 fc37 	bl	1024bd6 <assert_print>
 1023368:	4916      	ldr	r1, [pc, #88]	; (10233c4 <z_tick_sleep+0x11c>)
 102336a:	481e      	ldr	r0, [pc, #120]	; (10233e4 <z_tick_sleep+0x13c>)
 102336c:	f001 fc33 	bl	1024bd6 <assert_print>
 1023370:	21e1      	movs	r1, #225	; 0xe1
 1023372:	e7d3      	b.n	102331c <z_tick_sleep+0x74>
 1023374:	4640      	mov	r0, r8
 1023376:	f7e2 fdb3 	bl	1005ee0 <arch_swap>
	return (thread->base.thread_state & state) != 0U;
 102337a:	68bb      	ldr	r3, [r7, #8]
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
 102337c:	7b5b      	ldrb	r3, [r3, #13]
 102337e:	06db      	lsls	r3, r3, #27
 1023380:	d50c      	bpl.n	102339c <z_tick_sleep+0xf4>
 1023382:	4919      	ldr	r1, [pc, #100]	; (10233e8 <z_tick_sleep+0x140>)
 1023384:	f44f 63b5 	mov.w	r3, #1448	; 0x5a8
 1023388:	4a0b      	ldr	r2, [pc, #44]	; (10233b8 <z_tick_sleep+0x110>)
 102338a:	480c      	ldr	r0, [pc, #48]	; (10233bc <z_tick_sleep+0x114>)
 102338c:	f001 fc23 	bl	1024bd6 <assert_print>
 1023390:	480b      	ldr	r0, [pc, #44]	; (10233c0 <z_tick_sleep+0x118>)
 1023392:	f001 fc20 	bl	1024bd6 <assert_print>
 1023396:	f44f 61b5 	mov.w	r1, #1448	; 0x5a8
 102339a:	e798      	b.n	10232ce <z_tick_sleep+0x26>

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
 102339c:	f006 f860 	bl	1029460 <sys_clock_tick_get_32>
 10233a0:	1a20      	subs	r0, r4, r0
 10233a2:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
 10233a6:	2801      	cmp	r0, #1
 10233a8:	f173 0300 	sbcs.w	r3, r3, #0
 10233ac:	db96      	blt.n	10232dc <z_tick_sleep+0x34>
		return ticks;
	}
#endif

	return 0;
}
 10233ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 10233b2:	bf00      	nop
 10233b4:	0102f8a2 	.word	0x0102f8a2
 10233b8:	0102fb0f 	.word	0x0102fb0f
 10233bc:	0102b695 	.word	0x0102b695
 10233c0:	0102ee84 	.word	0x0102ee84
 10233c4:	21008110 	.word	0x21008110
 10233c8:	0102bd8a 	.word	0x0102bd8a
 10233cc:	0102bde3 	.word	0x0102bde3
 10233d0:	0102bdf8 	.word	0x0102bdf8
 10233d4:	210080cc 	.word	0x210080cc
 10233d8:	21008104 	.word	0x21008104
 10233dc:	01022f79 	.word	0x01022f79
 10233e0:	0102bdb7 	.word	0x0102bdb7
 10233e4:	0102bdce 	.word	0x0102bdce
 10233e8:	0102fc54 	.word	0x0102fc54

010233ec <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
 10233ec:	b508      	push	{r3, lr}
 10233ee:	f3ef 8305 	mrs	r3, IPSR
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
 10233f2:	b173      	cbz	r3, 1023412 <z_impl_k_sleep+0x26>
 10233f4:	4912      	ldr	r1, [pc, #72]	; (1023440 <z_impl_k_sleep+0x54>)
 10233f6:	f240 53b7 	movw	r3, #1463	; 0x5b7
 10233fa:	4a12      	ldr	r2, [pc, #72]	; (1023444 <z_impl_k_sleep+0x58>)
 10233fc:	4812      	ldr	r0, [pc, #72]	; (1023448 <z_impl_k_sleep+0x5c>)
 10233fe:	f001 fbea 	bl	1024bd6 <assert_print>
 1023402:	4812      	ldr	r0, [pc, #72]	; (102344c <z_impl_k_sleep+0x60>)
 1023404:	f001 fbe7 	bl	1024bd6 <assert_print>
 1023408:	f240 51b7 	movw	r1, #1463	; 0x5b7
 102340c:	480d      	ldr	r0, [pc, #52]	; (1023444 <z_impl_k_sleep+0x58>)
 102340e:	f001 fbdb 	bl	1024bc8 <assert_post_action>

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 1023412:	f1b1 3fff 	cmp.w	r1, #4294967295
 1023416:	bf08      	it	eq
 1023418:	f1b0 3fff 	cmpeq.w	r0, #4294967295
 102341c:	d106      	bne.n	102342c <z_impl_k_sleep+0x40>
		k_thread_suspend(_current);
 102341e:	4b0c      	ldr	r3, [pc, #48]	; (1023450 <z_impl_k_sleep+0x64>)
 1023420:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
 1023422:	f7ff fcd7 	bl	1022dd4 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
 1023426:	f04f 30ff 	mov.w	r0, #4294967295
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
 102342a:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
 102342c:	f7ff ff3c 	bl	10232a8 <z_tick_sleep>
			return ((t * to_hz + off) / from_hz);
 1023430:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 1023434:	fb80 0303 	smull	r0, r3, r0, r3
 1023438:	0bc0      	lsrs	r0, r0, #15
 102343a:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return ret;
 102343e:	e7f4      	b.n	102342a <z_impl_k_sleep+0x3e>
 1023440:	0102f8a2 	.word	0x0102f8a2
 1023444:	0102fb0f 	.word	0x0102fb0f
 1023448:	0102b695 	.word	0x0102b695
 102344c:	0102ee84 	.word	0x0102ee84
 1023450:	210080cc 	.word	0x210080cc

01023454 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
 1023454:	4b01      	ldr	r3, [pc, #4]	; (102345c <z_impl_z_current_get+0x8>)
 1023456:	6898      	ldr	r0, [r3, #8]
 1023458:	4770      	bx	lr
 102345a:	bf00      	nop
 102345c:	210080cc 	.word	0x210080cc

01023460 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
 1023460:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1023464:	4604      	mov	r4, r0
 1023466:	f04f 0320 	mov.w	r3, #32
 102346a:	f3ef 8611 	mrs	r6, BASEPRI
 102346e:	f383 8812 	msr	BASEPRI_MAX, r3
 1023472:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1023476:	4851      	ldr	r0, [pc, #324]	; (10235bc <z_thread_abort+0x15c>)
 1023478:	f7fd fe2a 	bl	10210d0 <z_spin_lock_valid>
 102347c:	b968      	cbnz	r0, 102349a <z_thread_abort+0x3a>
 102347e:	2394      	movs	r3, #148	; 0x94
 1023480:	4a4f      	ldr	r2, [pc, #316]	; (10235c0 <z_thread_abort+0x160>)
 1023482:	4950      	ldr	r1, [pc, #320]	; (10235c4 <z_thread_abort+0x164>)
 1023484:	4850      	ldr	r0, [pc, #320]	; (10235c8 <z_thread_abort+0x168>)
 1023486:	f001 fba6 	bl	1024bd6 <assert_print>
 102348a:	494c      	ldr	r1, [pc, #304]	; (10235bc <z_thread_abort+0x15c>)
 102348c:	484f      	ldr	r0, [pc, #316]	; (10235cc <z_thread_abort+0x16c>)
 102348e:	f001 fba2 	bl	1024bd6 <assert_print>
 1023492:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023494:	484a      	ldr	r0, [pc, #296]	; (10235c0 <z_thread_abort+0x160>)
 1023496:	f001 fb97 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 102349a:	4848      	ldr	r0, [pc, #288]	; (10235bc <z_thread_abort+0x15c>)
 102349c:	f7fd fe34 	bl	1021108 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
 10234a0:	7b23      	ldrb	r3, [r4, #12]
 10234a2:	07d9      	lsls	r1, r3, #31
 10234a4:	d522      	bpl.n	10234ec <z_thread_abort+0x8c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10234a6:	4845      	ldr	r0, [pc, #276]	; (10235bc <z_thread_abort+0x15c>)
 10234a8:	f7fd fe20 	bl	10210ec <z_spin_unlock_valid>
 10234ac:	b958      	cbnz	r0, 10234c6 <z_thread_abort+0x66>
 10234ae:	23c2      	movs	r3, #194	; 0xc2
 10234b0:	4a43      	ldr	r2, [pc, #268]	; (10235c0 <z_thread_abort+0x160>)
 10234b2:	4947      	ldr	r1, [pc, #284]	; (10235d0 <z_thread_abort+0x170>)
 10234b4:	4844      	ldr	r0, [pc, #272]	; (10235c8 <z_thread_abort+0x168>)
 10234b6:	f001 fb8e 	bl	1024bd6 <assert_print>
 10234ba:	4940      	ldr	r1, [pc, #256]	; (10235bc <z_thread_abort+0x15c>)
 10234bc:	4845      	ldr	r0, [pc, #276]	; (10235d4 <z_thread_abort+0x174>)
 10234be:	f001 fb8a 	bl	1024bd6 <assert_print>
 10234c2:	21c2      	movs	r1, #194	; 0xc2
 10234c4:	e7e6      	b.n	1023494 <z_thread_abort+0x34>
	__asm__ volatile(
 10234c6:	f386 8811 	msr	BASEPRI, r6
 10234ca:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
 10234ce:	f240 63c3 	movw	r3, #1731	; 0x6c3
 10234d2:	4a41      	ldr	r2, [pc, #260]	; (10235d8 <z_thread_abort+0x178>)
 10234d4:	4941      	ldr	r1, [pc, #260]	; (10235dc <z_thread_abort+0x17c>)
 10234d6:	483c      	ldr	r0, [pc, #240]	; (10235c8 <z_thread_abort+0x168>)
 10234d8:	f001 fb7d 	bl	1024bd6 <assert_print>
 10234dc:	4621      	mov	r1, r4
 10234de:	4840      	ldr	r0, [pc, #256]	; (10235e0 <z_thread_abort+0x180>)
 10234e0:	f001 fb79 	bl	1024bd6 <assert_print>
 10234e4:	f240 61c3 	movw	r1, #1731	; 0x6c3
	}
#endif
	end_thread(thread);
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
 10234e8:	483b      	ldr	r0, [pc, #236]	; (10235d8 <z_thread_abort+0x178>)
 10234ea:	e7d4      	b.n	1023496 <z_thread_abort+0x36>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 10234ec:	7b63      	ldrb	r3, [r4, #13]
 10234ee:	071a      	lsls	r2, r3, #28
 10234f0:	d50a      	bpl.n	1023508 <z_thread_abort+0xa8>
 10234f2:	4832      	ldr	r0, [pc, #200]	; (10235bc <z_thread_abort+0x15c>)
 10234f4:	f7fd fdfa 	bl	10210ec <z_spin_unlock_valid>
 10234f8:	2800      	cmp	r0, #0
 10234fa:	d0d8      	beq.n	10234ae <z_thread_abort+0x4e>
 10234fc:	f386 8811 	msr	BASEPRI, r6
 1023500:	f3bf 8f6f 	isb	sy
	}
	k_spin_unlock(&sched_spinlock, key);
}
 1023504:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
 1023508:	f023 0220 	bic.w	r2, r3, #32
 102350c:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
 1023510:	09d2      	lsrs	r2, r2, #7
 1023512:	d12c      	bne.n	102356e <z_thread_abort+0x10e>
		thread->base.thread_state &= ~_THREAD_ABORTING;
 1023514:	7361      	strb	r1, [r4, #13]
		if (thread->base.pended_on != NULL) {
 1023516:	68a3      	ldr	r3, [r4, #8]
 1023518:	b113      	cbz	r3, 1023520 <z_thread_abort+0xc0>
			unpend_thread_no_timeout(thread);
 102351a:	4620      	mov	r0, r4
 102351c:	f7ff fcc2 	bl	1022ea4 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
 1023520:	f104 0018 	add.w	r0, r4, #24
 1023524:	f000 fa02 	bl	102392c <z_abort_timeout>
 1023528:	f04f 0800 	mov.w	r8, #0
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 102352c:	f104 0758 	add.w	r7, r4, #88	; 0x58
	return list->head == list;
 1023530:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1023532:	42bd      	cmp	r5, r7
 1023534:	d000      	beq.n	1023538 <z_thread_abort+0xd8>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
 1023536:	bb25      	cbnz	r5, 1023582 <z_thread_abort+0x122>
		update_cache(1);
 1023538:	2001      	movs	r0, #1
 102353a:	f7fe ff07 	bl	102234c <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
 102353e:	4b29      	ldr	r3, [pc, #164]	; (10235e4 <z_thread_abort+0x184>)
 1023540:	689b      	ldr	r3, [r3, #8]
 1023542:	42a3      	cmp	r3, r4
 1023544:	d1d5      	bne.n	10234f2 <z_thread_abort+0x92>
 1023546:	f3ef 8305 	mrs	r3, IPSR
 102354a:	2b00      	cmp	r3, #0
 102354c:	d1d1      	bne.n	10234f2 <z_thread_abort+0x92>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 102354e:	481b      	ldr	r0, [pc, #108]	; (10235bc <z_thread_abort+0x15c>)
 1023550:	f7fd fdcc 	bl	10210ec <z_spin_unlock_valid>
 1023554:	bb10      	cbnz	r0, 102359c <z_thread_abort+0x13c>
 1023556:	23e1      	movs	r3, #225	; 0xe1
 1023558:	4a19      	ldr	r2, [pc, #100]	; (10235c0 <z_thread_abort+0x160>)
 102355a:	491d      	ldr	r1, [pc, #116]	; (10235d0 <z_thread_abort+0x170>)
 102355c:	481a      	ldr	r0, [pc, #104]	; (10235c8 <z_thread_abort+0x168>)
 102355e:	f001 fb3a 	bl	1024bd6 <assert_print>
 1023562:	4916      	ldr	r1, [pc, #88]	; (10235bc <z_thread_abort+0x15c>)
 1023564:	481b      	ldr	r0, [pc, #108]	; (10235d4 <z_thread_abort+0x174>)
 1023566:	f001 fb36 	bl	1024bd6 <assert_print>
 102356a:	21e1      	movs	r1, #225	; 0xe1
 102356c:	e792      	b.n	1023494 <z_thread_abort+0x34>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 102356e:	f003 035f 	and.w	r3, r3, #95	; 0x5f
 1023572:	f043 0308 	orr.w	r3, r3, #8
	_priq_run_remove(thread_runq(thread), thread);
 1023576:	4621      	mov	r1, r4
 1023578:	481b      	ldr	r0, [pc, #108]	; (10235e8 <z_thread_abort+0x188>)
	thread->base.thread_state &= ~_THREAD_QUEUED;
 102357a:	7363      	strb	r3, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
 102357c:	f7ff f9c8 	bl	1022910 <z_priq_dumb_remove>
}
 1023580:	e7c9      	b.n	1023516 <z_thread_abort+0xb6>
		unpend_thread_no_timeout(thread);
 1023582:	4628      	mov	r0, r5
 1023584:	f7ff fc8e 	bl	1022ea4 <unpend_thread_no_timeout>
 1023588:	f105 0018 	add.w	r0, r5, #24
 102358c:	f000 f9ce 	bl	102392c <z_abort_timeout>
		ready_thread(thread);
 1023590:	4628      	mov	r0, r5
 1023592:	f8c5 807c 	str.w	r8, [r5, #124]	; 0x7c
 1023596:	f7fe ff0d 	bl	10223b4 <ready_thread>
 102359a:	e7c9      	b.n	1023530 <z_thread_abort+0xd0>
 102359c:	4630      	mov	r0, r6
 102359e:	f7e2 fc9f 	bl	1005ee0 <arch_swap>
		__ASSERT(false, "aborted _current back from dead");
 10235a2:	490e      	ldr	r1, [pc, #56]	; (10235dc <z_thread_abort+0x17c>)
 10235a4:	f240 63f2 	movw	r3, #1778	; 0x6f2
 10235a8:	4a0b      	ldr	r2, [pc, #44]	; (10235d8 <z_thread_abort+0x178>)
 10235aa:	4807      	ldr	r0, [pc, #28]	; (10235c8 <z_thread_abort+0x168>)
 10235ac:	f001 fb13 	bl	1024bd6 <assert_print>
 10235b0:	480e      	ldr	r0, [pc, #56]	; (10235ec <z_thread_abort+0x18c>)
 10235b2:	f001 fb10 	bl	1024bd6 <assert_print>
 10235b6:	f240 61f2 	movw	r1, #1778	; 0x6f2
 10235ba:	e795      	b.n	10234e8 <z_thread_abort+0x88>
 10235bc:	21008110 	.word	0x21008110
 10235c0:	0102bd8a 	.word	0x0102bd8a
 10235c4:	0102bde3 	.word	0x0102bde3
 10235c8:	0102b695 	.word	0x0102b695
 10235cc:	0102bdf8 	.word	0x0102bdf8
 10235d0:	0102bdb7 	.word	0x0102bdb7
 10235d4:	0102bdce 	.word	0x0102bdce
 10235d8:	0102fb0f 	.word	0x0102fb0f
 10235dc:	0102ff6e 	.word	0x0102ff6e
 10235e0:	0102fc94 	.word	0x0102fc94
 10235e4:	210080cc 	.word	0x210080cc
 10235e8:	210080e8 	.word	0x210080e8
 10235ec:	0102fcb3 	.word	0x0102fcb3

010235f0 <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
 10235f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 10235f4:	4606      	mov	r6, r0
 10235f6:	4688      	mov	r8, r1
 10235f8:	4617      	mov	r7, r2
	__asm__ volatile(
 10235fa:	f04f 0320 	mov.w	r3, #32
 10235fe:	f3ef 8911 	mrs	r9, BASEPRI
 1023602:	f383 8812 	msr	BASEPRI_MAX, r3
 1023606:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 102360a:	4821      	ldr	r0, [pc, #132]	; (1023690 <z_sched_wake+0xa0>)
 102360c:	f7fd fd60 	bl	10210d0 <z_spin_lock_valid>
 1023610:	4605      	mov	r5, r0
 1023612:	b968      	cbnz	r0, 1023630 <z_sched_wake+0x40>
 1023614:	2394      	movs	r3, #148	; 0x94
 1023616:	4a1f      	ldr	r2, [pc, #124]	; (1023694 <z_sched_wake+0xa4>)
 1023618:	491f      	ldr	r1, [pc, #124]	; (1023698 <z_sched_wake+0xa8>)
 102361a:	4820      	ldr	r0, [pc, #128]	; (102369c <z_sched_wake+0xac>)
 102361c:	f001 fadb 	bl	1024bd6 <assert_print>
 1023620:	491b      	ldr	r1, [pc, #108]	; (1023690 <z_sched_wake+0xa0>)
 1023622:	481f      	ldr	r0, [pc, #124]	; (10236a0 <z_sched_wake+0xb0>)
 1023624:	f001 fad7 	bl	1024bd6 <assert_print>
 1023628:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 102362a:	481a      	ldr	r0, [pc, #104]	; (1023694 <z_sched_wake+0xa4>)
 102362c:	f001 facc 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1023630:	4817      	ldr	r0, [pc, #92]	; (1023690 <z_sched_wake+0xa0>)
 1023632:	f7fd fd69 	bl	1021108 <z_spin_lock_set_owner>
	return list->head == list;
 1023636:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1023638:	42a6      	cmp	r6, r4
 102363a:	d01d      	beq.n	1023678 <z_sched_wake+0x88>
	bool ret = false;

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);

		if (thread != NULL) {
 102363c:	b1f4      	cbz	r4, 102367c <z_sched_wake+0x8c>
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
 102363e:	4620      	mov	r0, r4
 1023640:	f8c4 807c 	str.w	r8, [r4, #124]	; 0x7c
 1023644:	6167      	str	r7, [r4, #20]
 1023646:	f7ff fc2d 	bl	1022ea4 <unpend_thread_no_timeout>
 102364a:	f104 0018 	add.w	r0, r4, #24
 102364e:	f000 f96d 	bl	102392c <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
 1023652:	4620      	mov	r0, r4
 1023654:	f7fe feae 	bl	10223b4 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023658:	480d      	ldr	r0, [pc, #52]	; (1023690 <z_sched_wake+0xa0>)
 102365a:	f7fd fd47 	bl	10210ec <z_spin_unlock_valid>
 102365e:	b978      	cbnz	r0, 1023680 <z_sched_wake+0x90>
 1023660:	23c2      	movs	r3, #194	; 0xc2
 1023662:	4a0c      	ldr	r2, [pc, #48]	; (1023694 <z_sched_wake+0xa4>)
 1023664:	490f      	ldr	r1, [pc, #60]	; (10236a4 <z_sched_wake+0xb4>)
 1023666:	480d      	ldr	r0, [pc, #52]	; (102369c <z_sched_wake+0xac>)
 1023668:	f001 fab5 	bl	1024bd6 <assert_print>
 102366c:	4908      	ldr	r1, [pc, #32]	; (1023690 <z_sched_wake+0xa0>)
 102366e:	480e      	ldr	r0, [pc, #56]	; (10236a8 <z_sched_wake+0xb8>)
 1023670:	f001 fab1 	bl	1024bd6 <assert_print>
 1023674:	21c2      	movs	r1, #194	; 0xc2
 1023676:	e7d8      	b.n	102362a <z_sched_wake+0x3a>
	bool ret = false;
 1023678:	2500      	movs	r5, #0
 102367a:	e7ed      	b.n	1023658 <z_sched_wake+0x68>
 102367c:	4625      	mov	r5, r4
 102367e:	e7eb      	b.n	1023658 <z_sched_wake+0x68>
	__asm__ volatile(
 1023680:	f389 8811 	msr	BASEPRI, r9
 1023684:	f3bf 8f6f 	isb	sy
			ret = true;
		}
	}

	return ret;
}
 1023688:	4628      	mov	r0, r5
 102368a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 102368e:	bf00      	nop
 1023690:	21008110 	.word	0x21008110
 1023694:	0102bd8a 	.word	0x0102bd8a
 1023698:	0102bde3 	.word	0x0102bde3
 102369c:	0102b695 	.word	0x0102b695
 10236a0:	0102bdf8 	.word	0x0102bdf8
 10236a4:	0102bdb7 	.word	0x0102bdb7
 10236a8:	0102bdce 	.word	0x0102bdce

010236ac <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
 10236ac:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
	int ret = z_pend_curr(lock, key, wait_q, timeout);
 10236ae:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
{
 10236b2:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
 10236b4:	e9cd 6700 	strd	r6, r7, [sp]
 10236b8:	f7ff fa84 	bl	1022bc4 <z_pend_curr>

	if (data != NULL) {
 10236bc:	b11c      	cbz	r4, 10236c6 <z_sched_wait+0x1a>
		*data = _current->base.swap_data;
 10236be:	4b03      	ldr	r3, [pc, #12]	; (10236cc <z_sched_wait+0x20>)
 10236c0:	689b      	ldr	r3, [r3, #8]
 10236c2:	695b      	ldr	r3, [r3, #20]
 10236c4:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
 10236c6:	b002      	add	sp, #8
 10236c8:	bdd0      	pop	{r4, r6, r7, pc}
 10236ca:	bf00      	nop
 10236cc:	210080cc 	.word	0x210080cc

010236d0 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
 10236d0:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
 10236d2:	4806      	ldr	r0, [pc, #24]	; (10236ec <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
 10236d4:	4a06      	ldr	r2, [pc, #24]	; (10236f0 <z_data_copy+0x20>)
 10236d6:	4907      	ldr	r1, [pc, #28]	; (10236f4 <z_data_copy+0x24>)
 10236d8:	1a12      	subs	r2, r2, r0
 10236da:	f005 fdb2 	bl	1029242 <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
 10236de:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
 10236e2:	4a05      	ldr	r2, [pc, #20]	; (10236f8 <z_data_copy+0x28>)
 10236e4:	4905      	ldr	r1, [pc, #20]	; (10236fc <z_data_copy+0x2c>)
 10236e6:	4806      	ldr	r0, [pc, #24]	; (1023700 <z_data_copy+0x30>)
 10236e8:	f005 bdab 	b.w	1029242 <z_early_memcpy>
 10236ec:	21000000 	.word	0x21000000
 10236f0:	21000ee8 	.word	0x21000ee8
 10236f4:	0102ffdc 	.word	0x0102ffdc
 10236f8:	00000000 	.word	0x00000000
 10236fc:	0102ffdc 	.word	0x0102ffdc
 1023700:	21000000 	.word	0x21000000

01023704 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 1023704:	4b03      	ldr	r3, [pc, #12]	; (1023714 <elapsed+0x10>)
 1023706:	681b      	ldr	r3, [r3, #0]
 1023708:	b90b      	cbnz	r3, 102370e <elapsed+0xa>
 102370a:	f7fc b87b 	b.w	101f804 <sys_clock_elapsed>
}
 102370e:	2000      	movs	r0, #0
 1023710:	4770      	bx	lr
 1023712:	bf00      	nop
 1023714:	21008114 	.word	0x21008114

01023718 <next_timeout>:

static int32_t next_timeout(void)
{
 1023718:	b510      	push	{r4, lr}
	return list->head == list;
 102371a:	4b11      	ldr	r3, [pc, #68]	; (1023760 <next_timeout+0x48>)
 102371c:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 102371e:	429c      	cmp	r4, r3
 1023720:	d10a      	bne.n	1023738 <next_timeout+0x20>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
 1023722:	f7ff ffef 	bl	1023704 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
 1023726:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
 102372a:	4b0e      	ldr	r3, [pc, #56]	; (1023764 <next_timeout+0x4c>)
 102372c:	691b      	ldr	r3, [r3, #16]
 102372e:	b113      	cbz	r3, 1023736 <next_timeout+0x1e>
 1023730:	4298      	cmp	r0, r3
 1023732:	bfa8      	it	ge
 1023734:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
 1023736:	bd10      	pop	{r4, pc}
	int32_t ticks_elapsed = elapsed();
 1023738:	f7ff ffe4 	bl	1023704 <elapsed>
	if ((to == NULL) ||
 102373c:	2c00      	cmp	r4, #0
 102373e:	d0f2      	beq.n	1023726 <next_timeout+0xe>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 1023740:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 1023744:	1a1b      	subs	r3, r3, r0
 1023746:	eb62 72e0 	sbc.w	r2, r2, r0, asr #31
	if ((to == NULL) ||
 102374a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 102374e:	f172 0100 	sbcs.w	r1, r2, #0
 1023752:	dae8      	bge.n	1023726 <next_timeout+0xe>
		ret = MAX(0, to->dticks - ticks_elapsed);
 1023754:	2a00      	cmp	r2, #0
 1023756:	bfac      	ite	ge
 1023758:	4618      	movge	r0, r3
 102375a:	2000      	movlt	r0, #0
 102375c:	e7e5      	b.n	102372a <next_timeout+0x12>
 102375e:	bf00      	nop
 1023760:	21000ab8 	.word	0x21000ab8
 1023764:	210080cc 	.word	0x210080cc

01023768 <remove_timeout>:
{
 1023768:	b530      	push	{r4, r5, lr}
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 102376a:	b170      	cbz	r0, 102378a <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
 102376c:	4b0b      	ldr	r3, [pc, #44]	; (102379c <remove_timeout+0x34>)
 102376e:	685b      	ldr	r3, [r3, #4]
 1023770:	4298      	cmp	r0, r3
 1023772:	d00a      	beq.n	102378a <remove_timeout+0x22>
 1023774:	6803      	ldr	r3, [r0, #0]
	if (next(t) != NULL) {
 1023776:	b143      	cbz	r3, 102378a <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
 1023778:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
 102377c:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
 1023780:	1912      	adds	r2, r2, r4
 1023782:	eb41 0105 	adc.w	r1, r1, r5
 1023786:	e9c3 2104 	strd	r2, r1, [r3, #16]
	sys_dnode_t *const next = node->next;
 102378a:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
 102378e:	6013      	str	r3, [r2, #0]
	next->prev = prev;
 1023790:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 1023792:	2300      	movs	r3, #0
	node->prev = NULL;
 1023794:	e9c0 3300 	strd	r3, r3, [r0]
}
 1023798:	bd30      	pop	{r4, r5, pc}
 102379a:	bf00      	nop
 102379c:	21000ab8 	.word	0x21000ab8

010237a0 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 10237a0:	f1b3 3fff 	cmp.w	r3, #4294967295
 10237a4:	bf08      	it	eq
 10237a6:	f1b2 3fff 	cmpeq.w	r2, #4294967295
{
 10237aa:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 10237ae:	4604      	mov	r4, r0
 10237b0:	4692      	mov	sl, r2
 10237b2:	461d      	mov	r5, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 10237b4:	f000 809e 	beq.w	10238f4 <z_add_timeout+0x154>
	return node->next != NULL;
 10237b8:	6806      	ldr	r6, [r0, #0]

#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
 10237ba:	b166      	cbz	r6, 10237d6 <z_add_timeout+0x36>
 10237bc:	494e      	ldr	r1, [pc, #312]	; (10238f8 <z_add_timeout+0x158>)
 10237be:	2363      	movs	r3, #99	; 0x63
 10237c0:	4a4e      	ldr	r2, [pc, #312]	; (10238fc <z_add_timeout+0x15c>)
 10237c2:	484f      	ldr	r0, [pc, #316]	; (1023900 <z_add_timeout+0x160>)
 10237c4:	f001 fa07 	bl	1024bd6 <assert_print>
 10237c8:	484e      	ldr	r0, [pc, #312]	; (1023904 <z_add_timeout+0x164>)
 10237ca:	f001 fa04 	bl	1024bd6 <assert_print>
 10237ce:	2163      	movs	r1, #99	; 0x63
 10237d0:	484a      	ldr	r0, [pc, #296]	; (10238fc <z_add_timeout+0x15c>)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10237d2:	f001 f9f9 	bl	1024bc8 <assert_post_action>
	to->fn = fn;
 10237d6:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
 10237d8:	f04f 0320 	mov.w	r3, #32
 10237dc:	f3ef 8711 	mrs	r7, BASEPRI
 10237e0:	f383 8812 	msr	BASEPRI_MAX, r3
 10237e4:	f3bf 8f6f 	isb	sy
 10237e8:	4847      	ldr	r0, [pc, #284]	; (1023908 <z_add_timeout+0x168>)
 10237ea:	f7fd fc71 	bl	10210d0 <z_spin_lock_valid>
 10237ee:	b960      	cbnz	r0, 102380a <z_add_timeout+0x6a>
 10237f0:	2394      	movs	r3, #148	; 0x94
 10237f2:	4a46      	ldr	r2, [pc, #280]	; (102390c <z_add_timeout+0x16c>)
 10237f4:	4946      	ldr	r1, [pc, #280]	; (1023910 <z_add_timeout+0x170>)
 10237f6:	4842      	ldr	r0, [pc, #264]	; (1023900 <z_add_timeout+0x160>)
 10237f8:	f001 f9ed 	bl	1024bd6 <assert_print>
 10237fc:	4942      	ldr	r1, [pc, #264]	; (1023908 <z_add_timeout+0x168>)
 10237fe:	4845      	ldr	r0, [pc, #276]	; (1023914 <z_add_timeout+0x174>)
 1023800:	f001 f9e9 	bl	1024bd6 <assert_print>
 1023804:	2194      	movs	r1, #148	; 0x94
 1023806:	4841      	ldr	r0, [pc, #260]	; (102390c <z_add_timeout+0x16c>)
 1023808:	e7e3      	b.n	10237d2 <z_add_timeout+0x32>
	z_spin_lock_set_owner(l);
 102380a:	483f      	ldr	r0, [pc, #252]	; (1023908 <z_add_timeout+0x168>)
 102380c:	f7fd fc7c 	bl	1021108 <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 1023810:	f1ba 3fff 	cmp.w	sl, #4294967295
 1023814:	f175 33ff 	sbcs.w	r3, r5, #4294967295
 1023818:	da23      	bge.n	1023862 <z_add_timeout+0xc2>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 102381a:	f06f 0301 	mvn.w	r3, #1
 102381e:	493e      	ldr	r1, [pc, #248]	; (1023918 <z_add_timeout+0x178>)
 1023820:	e9d1 2000 	ldrd	r2, r0, [r1]
 1023824:	1a9b      	subs	r3, r3, r2
 1023826:	f04f 32ff 	mov.w	r2, #4294967295
 102382a:	eb62 0000 	sbc.w	r0, r2, r0
 102382e:	ebb3 030a 	subs.w	r3, r3, sl
 1023832:	eb60 0005 	sbc.w	r0, r0, r5

			to->dticks = MAX(1, ticks);
 1023836:	2b01      	cmp	r3, #1
 1023838:	f170 0200 	sbcs.w	r2, r0, #0
 102383c:	da01      	bge.n	1023842 <z_add_timeout+0xa2>
 102383e:	2301      	movs	r3, #1
 1023840:	4630      	mov	r0, r6
 1023842:	e9c4 3004 	strd	r3, r0, [r4, #16]
	return list->head == list;
 1023846:	4b35      	ldr	r3, [pc, #212]	; (102391c <z_add_timeout+0x17c>)
 1023848:	681a      	ldr	r2, [r3, #0]
	return (node == list->tail) ? NULL : node->next;
 102384a:	f8d3 c004 	ldr.w	ip, [r3, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 102384e:	429a      	cmp	r2, r3
 1023850:	bf18      	it	ne
 1023852:	4616      	movne	r6, r2
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
		}

		for (t = first(); t != NULL; t = next(t)) {
 1023854:	b986      	cbnz	r6, 1023878 <z_add_timeout+0xd8>
	node->prev = tail;
 1023856:	e9c4 3c00 	strd	r3, ip, [r4]
	tail->next = node;
 102385a:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
 102385e:	605c      	str	r4, [r3, #4]
}
 1023860:	e01c      	b.n	102389c <z_add_timeout+0xfc>
			to->dticks = timeout.ticks + 1 + elapsed();
 1023862:	f7ff ff4f 	bl	1023704 <elapsed>
 1023866:	f11a 0801 	adds.w	r8, sl, #1
 102386a:	f145 0500 	adc.w	r5, r5, #0
 102386e:	eb18 0300 	adds.w	r3, r8, r0
 1023872:	eb45 70e0 	adc.w	r0, r5, r0, asr #31
 1023876:	e7e4      	b.n	1023842 <z_add_timeout+0xa2>
			if (t->dticks > to->dticks) {
 1023878:	e9d6 1504 	ldrd	r1, r5, [r6, #16]
 102387c:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
 1023880:	428a      	cmp	r2, r1
 1023882:	eb70 0e05 	sbcs.w	lr, r0, r5
 1023886:	da28      	bge.n	10238da <z_add_timeout+0x13a>
				t->dticks -= to->dticks;
 1023888:	1a89      	subs	r1, r1, r2
	sys_dnode_t *const prev = successor->prev;
 102388a:	6872      	ldr	r2, [r6, #4]
 102388c:	eb65 0500 	sbc.w	r5, r5, r0
 1023890:	e9c6 1504 	strd	r1, r5, [r6, #16]
	node->next = successor;
 1023894:	e9c4 6200 	strd	r6, r2, [r4]
	prev->next = node;
 1023898:	6014      	str	r4, [r2, #0]
	successor->prev = node;
 102389a:	6074      	str	r4, [r6, #4]
	return list->head == list;
 102389c:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 102389e:	429a      	cmp	r2, r3
 10238a0:	d00b      	beq.n	10238ba <z_add_timeout+0x11a>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
 10238a2:	4294      	cmp	r4, r2
 10238a4:	d109      	bne.n	10238ba <z_add_timeout+0x11a>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
 10238a6:	f7ff ff37 	bl	1023718 <next_timeout>

			if (next_time == 0 ||
 10238aa:	b118      	cbz	r0, 10238b4 <z_add_timeout+0x114>
			    _current_cpu->slice_ticks != next_time) {
 10238ac:	4b1c      	ldr	r3, [pc, #112]	; (1023920 <z_add_timeout+0x180>)
			if (next_time == 0 ||
 10238ae:	691b      	ldr	r3, [r3, #16]
 10238b0:	4283      	cmp	r3, r0
 10238b2:	d002      	beq.n	10238ba <z_add_timeout+0x11a>
				sys_clock_set_timeout(next_time, false);
 10238b4:	2100      	movs	r1, #0
 10238b6:	f7fb ff7b 	bl	101f7b0 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10238ba:	4813      	ldr	r0, [pc, #76]	; (1023908 <z_add_timeout+0x168>)
 10238bc:	f7fd fc16 	bl	10210ec <z_spin_unlock_valid>
 10238c0:	b9a0      	cbnz	r0, 10238ec <z_add_timeout+0x14c>
 10238c2:	23c2      	movs	r3, #194	; 0xc2
 10238c4:	4a11      	ldr	r2, [pc, #68]	; (102390c <z_add_timeout+0x16c>)
 10238c6:	4917      	ldr	r1, [pc, #92]	; (1023924 <z_add_timeout+0x184>)
 10238c8:	480d      	ldr	r0, [pc, #52]	; (1023900 <z_add_timeout+0x160>)
 10238ca:	f001 f984 	bl	1024bd6 <assert_print>
 10238ce:	490e      	ldr	r1, [pc, #56]	; (1023908 <z_add_timeout+0x168>)
 10238d0:	4815      	ldr	r0, [pc, #84]	; (1023928 <z_add_timeout+0x188>)
 10238d2:	f001 f980 	bl	1024bd6 <assert_print>
 10238d6:	21c2      	movs	r1, #194	; 0xc2
 10238d8:	e795      	b.n	1023806 <z_add_timeout+0x66>
			to->dticks -= t->dticks;
 10238da:	1a52      	subs	r2, r2, r1
 10238dc:	eb60 0005 	sbc.w	r0, r0, r5
	return (node == list->tail) ? NULL : node->next;
 10238e0:	4566      	cmp	r6, ip
 10238e2:	e9c4 2004 	strd	r2, r0, [r4, #16]
 10238e6:	d0b6      	beq.n	1023856 <z_add_timeout+0xb6>
 10238e8:	6836      	ldr	r6, [r6, #0]
 10238ea:	e7b3      	b.n	1023854 <z_add_timeout+0xb4>
	__asm__ volatile(
 10238ec:	f387 8811 	msr	BASEPRI, r7
 10238f0:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
 10238f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 10238f8:	0102fcf9 	.word	0x0102fcf9
 10238fc:	0102fcd5 	.word	0x0102fcd5
 1023900:	0102b695 	.word	0x0102b695
 1023904:	0102ee84 	.word	0x0102ee84
 1023908:	21008118 	.word	0x21008118
 102390c:	0102bd8a 	.word	0x0102bd8a
 1023910:	0102bde3 	.word	0x0102bde3
 1023914:	0102bdf8 	.word	0x0102bdf8
 1023918:	210045b0 	.word	0x210045b0
 102391c:	21000ab8 	.word	0x21000ab8
 1023920:	210080cc 	.word	0x210080cc
 1023924:	0102bdb7 	.word	0x0102bdb7
 1023928:	0102bdce 	.word	0x0102bdce

0102392c <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
 102392c:	b538      	push	{r3, r4, r5, lr}
 102392e:	4604      	mov	r4, r0
	__asm__ volatile(
 1023930:	f04f 0320 	mov.w	r3, #32
 1023934:	f3ef 8511 	mrs	r5, BASEPRI
 1023938:	f383 8812 	msr	BASEPRI_MAX, r3
 102393c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1023940:	4819      	ldr	r0, [pc, #100]	; (10239a8 <z_abort_timeout+0x7c>)
 1023942:	f7fd fbc5 	bl	10210d0 <z_spin_lock_valid>
 1023946:	b968      	cbnz	r0, 1023964 <z_abort_timeout+0x38>
 1023948:	2394      	movs	r3, #148	; 0x94
 102394a:	4a18      	ldr	r2, [pc, #96]	; (10239ac <z_abort_timeout+0x80>)
 102394c:	4918      	ldr	r1, [pc, #96]	; (10239b0 <z_abort_timeout+0x84>)
 102394e:	4819      	ldr	r0, [pc, #100]	; (10239b4 <z_abort_timeout+0x88>)
 1023950:	f001 f941 	bl	1024bd6 <assert_print>
 1023954:	4914      	ldr	r1, [pc, #80]	; (10239a8 <z_abort_timeout+0x7c>)
 1023956:	4818      	ldr	r0, [pc, #96]	; (10239b8 <z_abort_timeout+0x8c>)
 1023958:	f001 f93d 	bl	1024bd6 <assert_print>
 102395c:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 102395e:	4813      	ldr	r0, [pc, #76]	; (10239ac <z_abort_timeout+0x80>)
 1023960:	f001 f932 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1023964:	4810      	ldr	r0, [pc, #64]	; (10239a8 <z_abort_timeout+0x7c>)
 1023966:	f7fd fbcf 	bl	1021108 <z_spin_lock_set_owner>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
 102396a:	6823      	ldr	r3, [r4, #0]
 102396c:	b19b      	cbz	r3, 1023996 <z_abort_timeout+0x6a>
			remove_timeout(to);
 102396e:	4620      	mov	r0, r4
 1023970:	f7ff fefa 	bl	1023768 <remove_timeout>
			ret = 0;
 1023974:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023976:	480c      	ldr	r0, [pc, #48]	; (10239a8 <z_abort_timeout+0x7c>)
 1023978:	f7fd fbb8 	bl	10210ec <z_spin_unlock_valid>
 102397c:	b970      	cbnz	r0, 102399c <z_abort_timeout+0x70>
 102397e:	23c2      	movs	r3, #194	; 0xc2
 1023980:	4a0a      	ldr	r2, [pc, #40]	; (10239ac <z_abort_timeout+0x80>)
 1023982:	490e      	ldr	r1, [pc, #56]	; (10239bc <z_abort_timeout+0x90>)
 1023984:	480b      	ldr	r0, [pc, #44]	; (10239b4 <z_abort_timeout+0x88>)
 1023986:	f001 f926 	bl	1024bd6 <assert_print>
 102398a:	4907      	ldr	r1, [pc, #28]	; (10239a8 <z_abort_timeout+0x7c>)
 102398c:	480c      	ldr	r0, [pc, #48]	; (10239c0 <z_abort_timeout+0x94>)
 102398e:	f001 f922 	bl	1024bd6 <assert_print>
 1023992:	21c2      	movs	r1, #194	; 0xc2
 1023994:	e7e3      	b.n	102395e <z_abort_timeout+0x32>
	int ret = -EINVAL;
 1023996:	f06f 0415 	mvn.w	r4, #21
 102399a:	e7ec      	b.n	1023976 <z_abort_timeout+0x4a>
	__asm__ volatile(
 102399c:	f385 8811 	msr	BASEPRI, r5
 10239a0:	f3bf 8f6f 	isb	sy
		}
	}

	return ret;
}
 10239a4:	4620      	mov	r0, r4
 10239a6:	bd38      	pop	{r3, r4, r5, pc}
 10239a8:	21008118 	.word	0x21008118
 10239ac:	0102bd8a 	.word	0x0102bd8a
 10239b0:	0102bde3 	.word	0x0102bde3
 10239b4:	0102b695 	.word	0x0102b695
 10239b8:	0102bdf8 	.word	0x0102bdf8
 10239bc:	0102bdb7 	.word	0x0102bdb7
 10239c0:	0102bdce 	.word	0x0102bdce

010239c4 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
 10239c4:	b570      	push	{r4, r5, r6, lr}
 10239c6:	4604      	mov	r4, r0
 10239c8:	460d      	mov	r5, r1
	__asm__ volatile(
 10239ca:	f04f 0320 	mov.w	r3, #32
 10239ce:	f3ef 8611 	mrs	r6, BASEPRI
 10239d2:	f383 8812 	msr	BASEPRI_MAX, r3
 10239d6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10239da:	481b      	ldr	r0, [pc, #108]	; (1023a48 <z_set_timeout_expiry+0x84>)
 10239dc:	f7fd fb78 	bl	10210d0 <z_spin_lock_valid>
 10239e0:	b968      	cbnz	r0, 10239fe <z_set_timeout_expiry+0x3a>
 10239e2:	2394      	movs	r3, #148	; 0x94
 10239e4:	4a19      	ldr	r2, [pc, #100]	; (1023a4c <z_set_timeout_expiry+0x88>)
 10239e6:	491a      	ldr	r1, [pc, #104]	; (1023a50 <z_set_timeout_expiry+0x8c>)
 10239e8:	481a      	ldr	r0, [pc, #104]	; (1023a54 <z_set_timeout_expiry+0x90>)
 10239ea:	f001 f8f4 	bl	1024bd6 <assert_print>
 10239ee:	4916      	ldr	r1, [pc, #88]	; (1023a48 <z_set_timeout_expiry+0x84>)
 10239f0:	4819      	ldr	r0, [pc, #100]	; (1023a58 <z_set_timeout_expiry+0x94>)
 10239f2:	f001 f8f0 	bl	1024bd6 <assert_print>
 10239f6:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10239f8:	4814      	ldr	r0, [pc, #80]	; (1023a4c <z_set_timeout_expiry+0x88>)
 10239fa:	f001 f8e5 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 10239fe:	4812      	ldr	r0, [pc, #72]	; (1023a48 <z_set_timeout_expiry+0x84>)
 1023a00:	f7fd fb82 	bl	1021108 <z_spin_lock_set_owner>
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
 1023a04:	f7ff fe88 	bl	1023718 <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
			      || (ticks <= next_to);
 1023a08:	2801      	cmp	r0, #1
 1023a0a:	dd07      	ble.n	1023a1c <z_set_timeout_expiry+0x58>
 1023a0c:	42a0      	cmp	r0, r4
 1023a0e:	db05      	blt.n	1023a1c <z_set_timeout_expiry+0x58>
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
 1023a10:	42a0      	cmp	r0, r4
 1023a12:	4629      	mov	r1, r5
 1023a14:	bfa8      	it	ge
 1023a16:	4620      	movge	r0, r4
 1023a18:	f7fb feca 	bl	101f7b0 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023a1c:	480a      	ldr	r0, [pc, #40]	; (1023a48 <z_set_timeout_expiry+0x84>)
 1023a1e:	f7fd fb65 	bl	10210ec <z_spin_unlock_valid>
 1023a22:	b958      	cbnz	r0, 1023a3c <z_set_timeout_expiry+0x78>
 1023a24:	23c2      	movs	r3, #194	; 0xc2
 1023a26:	4a09      	ldr	r2, [pc, #36]	; (1023a4c <z_set_timeout_expiry+0x88>)
 1023a28:	490c      	ldr	r1, [pc, #48]	; (1023a5c <z_set_timeout_expiry+0x98>)
 1023a2a:	480a      	ldr	r0, [pc, #40]	; (1023a54 <z_set_timeout_expiry+0x90>)
 1023a2c:	f001 f8d3 	bl	1024bd6 <assert_print>
 1023a30:	4905      	ldr	r1, [pc, #20]	; (1023a48 <z_set_timeout_expiry+0x84>)
 1023a32:	480b      	ldr	r0, [pc, #44]	; (1023a60 <z_set_timeout_expiry+0x9c>)
 1023a34:	f001 f8cf 	bl	1024bd6 <assert_print>
 1023a38:	21c2      	movs	r1, #194	; 0xc2
 1023a3a:	e7dd      	b.n	10239f8 <z_set_timeout_expiry+0x34>
	__asm__ volatile(
 1023a3c:	f386 8811 	msr	BASEPRI, r6
 1023a40:	f3bf 8f6f 	isb	sy
		}
	}
}
 1023a44:	bd70      	pop	{r4, r5, r6, pc}
 1023a46:	bf00      	nop
 1023a48:	21008118 	.word	0x21008118
 1023a4c:	0102bd8a 	.word	0x0102bd8a
 1023a50:	0102bde3 	.word	0x0102bde3
 1023a54:	0102b695 	.word	0x0102b695
 1023a58:	0102bdf8 	.word	0x0102bdf8
 1023a5c:	0102bdb7 	.word	0x0102bdb7
 1023a60:	0102bdce 	.word	0x0102bdce

01023a64 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
 1023a64:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1023a68:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
 1023a6a:	f7fe ffc3 	bl	10229f4 <z_time_slice>
	__asm__ volatile(
 1023a6e:	f04f 0320 	mov.w	r3, #32
 1023a72:	f3ef 8711 	mrs	r7, BASEPRI
 1023a76:	f383 8812 	msr	BASEPRI_MAX, r3
 1023a7a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1023a7e:	483f      	ldr	r0, [pc, #252]	; (1023b7c <sys_clock_announce+0x118>)
 1023a80:	f7fd fb26 	bl	10210d0 <z_spin_lock_valid>
 1023a84:	b968      	cbnz	r0, 1023aa2 <sys_clock_announce+0x3e>
 1023a86:	2394      	movs	r3, #148	; 0x94
 1023a88:	4a3d      	ldr	r2, [pc, #244]	; (1023b80 <sys_clock_announce+0x11c>)
 1023a8a:	493e      	ldr	r1, [pc, #248]	; (1023b84 <sys_clock_announce+0x120>)
 1023a8c:	483e      	ldr	r0, [pc, #248]	; (1023b88 <sys_clock_announce+0x124>)
 1023a8e:	f001 f8a2 	bl	1024bd6 <assert_print>
 1023a92:	493a      	ldr	r1, [pc, #232]	; (1023b7c <sys_clock_announce+0x118>)
 1023a94:	483d      	ldr	r0, [pc, #244]	; (1023b8c <sys_clock_announce+0x128>)
 1023a96:	f001 f89e 	bl	1024bd6 <assert_print>
 1023a9a:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023a9c:	4838      	ldr	r0, [pc, #224]	; (1023b80 <sys_clock_announce+0x11c>)
 1023a9e:	f001 f893 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1023aa2:	4836      	ldr	r0, [pc, #216]	; (1023b7c <sys_clock_announce+0x118>)
 1023aa4:	f7fd fb30 	bl	1021108 <z_spin_lock_set_owner>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
 1023aa8:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 1023b90 <sys_clock_announce+0x12c>
	return list->head == list;
 1023aac:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 1023b94 <sys_clock_announce+0x130>
 1023ab0:	f8d9 5000 	ldr.w	r5, [r9]

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
 1023ab4:	4a38      	ldr	r2, [pc, #224]	; (1023b98 <sys_clock_announce+0x134>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1023ab6:	454d      	cmp	r5, r9
	announce_remaining = ticks;
 1023ab8:	f8c8 4000 	str.w	r4, [r8]
	return list->head == list;
 1023abc:	ea4f 71e4 	mov.w	r1, r4, asr #31
		curr_tick += dt;
 1023ac0:	e9d2 3c00 	ldrd	r3, ip, [r2]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1023ac4:	d00b      	beq.n	1023ade <sys_clock_announce+0x7a>
	while (first() != NULL && first()->dticks <= announce_remaining) {
 1023ac6:	b155      	cbz	r5, 1023ade <sys_clock_announce+0x7a>
 1023ac8:	e9d5 6004 	ldrd	r6, r0, [r5, #16]
 1023acc:	42b4      	cmp	r4, r6
 1023ace:	eb71 0e00 	sbcs.w	lr, r1, r0
 1023ad2:	da1c      	bge.n	1023b0e <sys_clock_announce+0xaa>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
 1023ad4:	1b36      	subs	r6, r6, r4
 1023ad6:	eb60 0001 	sbc.w	r0, r0, r1
 1023ada:	e9c5 6004 	strd	r6, r0, [r5, #16]
	}

	curr_tick += announce_remaining;
 1023ade:	18e3      	adds	r3, r4, r3
	announce_remaining = 0;
 1023ae0:	f04f 0400 	mov.w	r4, #0
	curr_tick += announce_remaining;
 1023ae4:	eb4c 0101 	adc.w	r1, ip, r1
 1023ae8:	e9c2 3100 	strd	r3, r1, [r2]
	announce_remaining = 0;
 1023aec:	f8c8 4000 	str.w	r4, [r8]

	sys_clock_set_timeout(next_timeout(), false);
 1023af0:	f7ff fe12 	bl	1023718 <next_timeout>
 1023af4:	4621      	mov	r1, r4
 1023af6:	f7fb fe5b 	bl	101f7b0 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023afa:	4820      	ldr	r0, [pc, #128]	; (1023b7c <sys_clock_announce+0x118>)
 1023afc:	f7fd faf6 	bl	10210ec <z_spin_unlock_valid>
 1023b00:	b1a8      	cbz	r0, 1023b2e <sys_clock_announce+0xca>
	__asm__ volatile(
 1023b02:	f387 8811 	msr	BASEPRI, r7
 1023b06:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
 1023b0a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		curr_tick += dt;
 1023b0e:	18f3      	adds	r3, r6, r3
 1023b10:	eb4c 71e6 	adc.w	r1, ip, r6, asr #31
 1023b14:	e9c2 3100 	strd	r3, r1, [r2]
		t->dticks = 0;
 1023b18:	2200      	movs	r2, #0
 1023b1a:	2300      	movs	r3, #0
		remove_timeout(t);
 1023b1c:	4628      	mov	r0, r5
		t->dticks = 0;
 1023b1e:	e9c5 2304 	strd	r2, r3, [r5, #16]
		remove_timeout(t);
 1023b22:	f7ff fe21 	bl	1023768 <remove_timeout>
 1023b26:	4815      	ldr	r0, [pc, #84]	; (1023b7c <sys_clock_announce+0x118>)
 1023b28:	f7fd fae0 	bl	10210ec <z_spin_unlock_valid>
 1023b2c:	b958      	cbnz	r0, 1023b46 <sys_clock_announce+0xe2>
 1023b2e:	23c2      	movs	r3, #194	; 0xc2
 1023b30:	4a13      	ldr	r2, [pc, #76]	; (1023b80 <sys_clock_announce+0x11c>)
 1023b32:	491a      	ldr	r1, [pc, #104]	; (1023b9c <sys_clock_announce+0x138>)
 1023b34:	4814      	ldr	r0, [pc, #80]	; (1023b88 <sys_clock_announce+0x124>)
 1023b36:	f001 f84e 	bl	1024bd6 <assert_print>
 1023b3a:	4910      	ldr	r1, [pc, #64]	; (1023b7c <sys_clock_announce+0x118>)
 1023b3c:	4818      	ldr	r0, [pc, #96]	; (1023ba0 <sys_clock_announce+0x13c>)
 1023b3e:	f001 f84a 	bl	1024bd6 <assert_print>
 1023b42:	21c2      	movs	r1, #194	; 0xc2
 1023b44:	e7aa      	b.n	1023a9c <sys_clock_announce+0x38>
 1023b46:	f387 8811 	msr	BASEPRI, r7
 1023b4a:	f3bf 8f6f 	isb	sy
		t->fn(t);
 1023b4e:	4628      	mov	r0, r5
 1023b50:	68ab      	ldr	r3, [r5, #8]
 1023b52:	4798      	blx	r3
	__asm__ volatile(
 1023b54:	f04f 0320 	mov.w	r3, #32
 1023b58:	f3ef 8711 	mrs	r7, BASEPRI
 1023b5c:	f383 8812 	msr	BASEPRI_MAX, r3
 1023b60:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1023b64:	4805      	ldr	r0, [pc, #20]	; (1023b7c <sys_clock_announce+0x118>)
 1023b66:	f7fd fab3 	bl	10210d0 <z_spin_lock_valid>
 1023b6a:	2800      	cmp	r0, #0
 1023b6c:	d08b      	beq.n	1023a86 <sys_clock_announce+0x22>
	z_spin_lock_set_owner(l);
 1023b6e:	4803      	ldr	r0, [pc, #12]	; (1023b7c <sys_clock_announce+0x118>)
 1023b70:	f7fd faca 	bl	1021108 <z_spin_lock_set_owner>
		announce_remaining -= dt;
 1023b74:	f8d8 4000 	ldr.w	r4, [r8]
 1023b78:	1ba4      	subs	r4, r4, r6
 1023b7a:	e799      	b.n	1023ab0 <sys_clock_announce+0x4c>
 1023b7c:	21008118 	.word	0x21008118
 1023b80:	0102bd8a 	.word	0x0102bd8a
 1023b84:	0102bde3 	.word	0x0102bde3
 1023b88:	0102b695 	.word	0x0102b695
 1023b8c:	0102bdf8 	.word	0x0102bdf8
 1023b90:	21008114 	.word	0x21008114
 1023b94:	21000ab8 	.word	0x21000ab8
 1023b98:	210045b0 	.word	0x210045b0
 1023b9c:	0102bdb7 	.word	0x0102bdb7
 1023ba0:	0102bdce 	.word	0x0102bdce

01023ba4 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
 1023ba4:	b570      	push	{r4, r5, r6, lr}
 1023ba6:	f04f 0320 	mov.w	r3, #32
 1023baa:	f3ef 8611 	mrs	r6, BASEPRI
 1023bae:	f383 8812 	msr	BASEPRI_MAX, r3
 1023bb2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1023bb6:	481a      	ldr	r0, [pc, #104]	; (1023c20 <sys_clock_tick_get+0x7c>)
 1023bb8:	f7fd fa8a 	bl	10210d0 <z_spin_lock_valid>
 1023bbc:	b968      	cbnz	r0, 1023bda <sys_clock_tick_get+0x36>
 1023bbe:	2394      	movs	r3, #148	; 0x94
 1023bc0:	4a18      	ldr	r2, [pc, #96]	; (1023c24 <sys_clock_tick_get+0x80>)
 1023bc2:	4919      	ldr	r1, [pc, #100]	; (1023c28 <sys_clock_tick_get+0x84>)
 1023bc4:	4819      	ldr	r0, [pc, #100]	; (1023c2c <sys_clock_tick_get+0x88>)
 1023bc6:	f001 f806 	bl	1024bd6 <assert_print>
 1023bca:	4915      	ldr	r1, [pc, #84]	; (1023c20 <sys_clock_tick_get+0x7c>)
 1023bcc:	4818      	ldr	r0, [pc, #96]	; (1023c30 <sys_clock_tick_get+0x8c>)
 1023bce:	f001 f802 	bl	1024bd6 <assert_print>
 1023bd2:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023bd4:	4813      	ldr	r0, [pc, #76]	; (1023c24 <sys_clock_tick_get+0x80>)
 1023bd6:	f000 fff7 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1023bda:	4811      	ldr	r0, [pc, #68]	; (1023c20 <sys_clock_tick_get+0x7c>)
 1023bdc:	f7fd fa94 	bl	1021108 <z_spin_lock_set_owner>
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
 1023be0:	f7ff fd90 	bl	1023704 <elapsed>
 1023be4:	4a13      	ldr	r2, [pc, #76]	; (1023c34 <sys_clock_tick_get+0x90>)
 1023be6:	e9d2 4500 	ldrd	r4, r5, [r2]
 1023bea:	1904      	adds	r4, r0, r4
 1023bec:	eb45 75e0 	adc.w	r5, r5, r0, asr #31
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023bf0:	480b      	ldr	r0, [pc, #44]	; (1023c20 <sys_clock_tick_get+0x7c>)
 1023bf2:	f7fd fa7b 	bl	10210ec <z_spin_unlock_valid>
 1023bf6:	b958      	cbnz	r0, 1023c10 <sys_clock_tick_get+0x6c>
 1023bf8:	23c2      	movs	r3, #194	; 0xc2
 1023bfa:	4a0a      	ldr	r2, [pc, #40]	; (1023c24 <sys_clock_tick_get+0x80>)
 1023bfc:	490e      	ldr	r1, [pc, #56]	; (1023c38 <sys_clock_tick_get+0x94>)
 1023bfe:	480b      	ldr	r0, [pc, #44]	; (1023c2c <sys_clock_tick_get+0x88>)
 1023c00:	f000 ffe9 	bl	1024bd6 <assert_print>
 1023c04:	4906      	ldr	r1, [pc, #24]	; (1023c20 <sys_clock_tick_get+0x7c>)
 1023c06:	480d      	ldr	r0, [pc, #52]	; (1023c3c <sys_clock_tick_get+0x98>)
 1023c08:	f000 ffe5 	bl	1024bd6 <assert_print>
 1023c0c:	21c2      	movs	r1, #194	; 0xc2
 1023c0e:	e7e1      	b.n	1023bd4 <sys_clock_tick_get+0x30>
	__asm__ volatile(
 1023c10:	f386 8811 	msr	BASEPRI, r6
 1023c14:	f3bf 8f6f 	isb	sy
	}
	return t;
}
 1023c18:	4620      	mov	r0, r4
 1023c1a:	4629      	mov	r1, r5
 1023c1c:	bd70      	pop	{r4, r5, r6, pc}
 1023c1e:	bf00      	nop
 1023c20:	21008118 	.word	0x21008118
 1023c24:	0102bd8a 	.word	0x0102bd8a
 1023c28:	0102bde3 	.word	0x0102bde3
 1023c2c:	0102b695 	.word	0x0102b695
 1023c30:	0102bdf8 	.word	0x0102bdf8
 1023c34:	210045b0 	.word	0x210045b0
 1023c38:	0102bdb7 	.word	0x0102bdb7
 1023c3c:	0102bdce 	.word	0x0102bdce

01023c40 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
 1023c40:	b570      	push	{r4, r5, r6, lr}
 1023c42:	4604      	mov	r4, r0
	__asm__ volatile(
 1023c44:	f04f 0320 	mov.w	r3, #32
 1023c48:	f3ef 8511 	mrs	r5, BASEPRI
 1023c4c:	f383 8812 	msr	BASEPRI_MAX, r3
 1023c50:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1023c54:	4849      	ldr	r0, [pc, #292]	; (1023d7c <z_timer_expiration_handler+0x13c>)
 1023c56:	f7fd fa3b 	bl	10210d0 <z_spin_lock_valid>
 1023c5a:	b968      	cbnz	r0, 1023c78 <z_timer_expiration_handler+0x38>
 1023c5c:	2394      	movs	r3, #148	; 0x94
 1023c5e:	4a48      	ldr	r2, [pc, #288]	; (1023d80 <z_timer_expiration_handler+0x140>)
 1023c60:	4948      	ldr	r1, [pc, #288]	; (1023d84 <z_timer_expiration_handler+0x144>)
 1023c62:	4849      	ldr	r0, [pc, #292]	; (1023d88 <z_timer_expiration_handler+0x148>)
 1023c64:	f000 ffb7 	bl	1024bd6 <assert_print>
 1023c68:	4944      	ldr	r1, [pc, #272]	; (1023d7c <z_timer_expiration_handler+0x13c>)
 1023c6a:	4848      	ldr	r0, [pc, #288]	; (1023d8c <z_timer_expiration_handler+0x14c>)
 1023c6c:	f000 ffb3 	bl	1024bd6 <assert_print>
 1023c70:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023c72:	4843      	ldr	r0, [pc, #268]	; (1023d80 <z_timer_expiration_handler+0x140>)
 1023c74:	f000 ffa8 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 1023c78:	4840      	ldr	r0, [pc, #256]	; (1023d7c <z_timer_expiration_handler+0x13c>)
 1023c7a:	f7fd fa45 	bl	1021108 <z_spin_lock_set_owner>

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
 1023c7e:	e9d4 320a 	ldrd	r3, r2, [r4, #40]	; 0x28
 1023c82:	3301      	adds	r3, #1
 1023c84:	f142 0200 	adc.w	r2, r2, #0
 1023c88:	2b02      	cmp	r3, #2
 1023c8a:	f172 0200 	sbcs.w	r2, r2, #0
 1023c8e:	d322      	bcc.n	1023cd6 <z_timer_expiration_handler+0x96>
	return z_impl_k_uptime_ticks();
 1023c90:	f005 fbea 	bl	1029468 <z_impl_k_uptime_ticks>
		 * we "should" have run.  Requires absolute timeouts.
		 * (Note offset by one: we're nominally at the
		 * beginning of a tick, so need to defeat the "round
		 * down" behavior on timeout addition).
		 */
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1
 1023c94:	e9d4 320a 	ldrd	r3, r2, [r4, #40]	; 0x28
 1023c98:	3001      	adds	r0, #1
 1023c9a:	f141 0100 	adc.w	r1, r1, #0
 1023c9e:	18c0      	adds	r0, r0, r3
 1023ca0:	eb41 0102 	adc.w	r1, r1, r2
 1023ca4:	2801      	cmp	r0, #1
 1023ca6:	f171 0100 	sbcs.w	r1, r1, #0
 1023caa:	db29      	blt.n	1023d00 <z_timer_expiration_handler+0xc0>
 1023cac:	f005 fbdc 	bl	1029468 <z_impl_k_uptime_ticks>
 1023cb0:	3001      	adds	r0, #1
 1023cb2:	f141 0300 	adc.w	r3, r1, #0
 1023cb6:	e9d4 210a 	ldrd	r2, r1, [r4, #40]	; 0x28
 1023cba:	1880      	adds	r0, r0, r2
 1023cbc:	f06f 0201 	mvn.w	r2, #1
 1023cc0:	eb43 0301 	adc.w	r3, r3, r1
 1023cc4:	f04f 31ff 	mov.w	r1, #4294967295
 1023cc8:	1a12      	subs	r2, r2, r0
 1023cca:	eb61 0303 	sbc.w	r3, r1, r3
					   + timer->period.ticks);
#endif
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 1023cce:	4620      	mov	r0, r4
 1023cd0:	492f      	ldr	r1, [pc, #188]	; (1023d90 <z_timer_expiration_handler+0x150>)
 1023cd2:	f7ff fd65 	bl	10237a0 <z_add_timeout>
			      next);
	}

	/* update timer's status */
	timer->status += 1U;
 1023cd6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 1023cd8:	3301      	adds	r3, #1
 1023cda:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
 1023cdc:	6a23      	ldr	r3, [r4, #32]
 1023cde:	b35b      	cbz	r3, 1023d38 <z_timer_expiration_handler+0xf8>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023ce0:	4826      	ldr	r0, [pc, #152]	; (1023d7c <z_timer_expiration_handler+0x13c>)
 1023ce2:	f7fd fa03 	bl	10210ec <z_spin_unlock_valid>
 1023ce6:	b980      	cbnz	r0, 1023d0a <z_timer_expiration_handler+0xca>
 1023ce8:	23c2      	movs	r3, #194	; 0xc2
 1023cea:	4a25      	ldr	r2, [pc, #148]	; (1023d80 <z_timer_expiration_handler+0x140>)
 1023cec:	4929      	ldr	r1, [pc, #164]	; (1023d94 <z_timer_expiration_handler+0x154>)
 1023cee:	4826      	ldr	r0, [pc, #152]	; (1023d88 <z_timer_expiration_handler+0x148>)
 1023cf0:	f000 ff71 	bl	1024bd6 <assert_print>
 1023cf4:	4921      	ldr	r1, [pc, #132]	; (1023d7c <z_timer_expiration_handler+0x13c>)
 1023cf6:	4828      	ldr	r0, [pc, #160]	; (1023d98 <z_timer_expiration_handler+0x158>)
 1023cf8:	f000 ff6d 	bl	1024bd6 <assert_print>
 1023cfc:	21c2      	movs	r1, #194	; 0xc2
 1023cfe:	e7b8      	b.n	1023c72 <z_timer_expiration_handler+0x32>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1
 1023d00:	f06f 0201 	mvn.w	r2, #1
 1023d04:	f04f 33ff 	mov.w	r3, #4294967295
 1023d08:	e7e1      	b.n	1023cce <z_timer_expiration_handler+0x8e>
	__asm__ volatile(
 1023d0a:	f385 8811 	msr	BASEPRI, r5
 1023d0e:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
 1023d12:	4620      	mov	r0, r4
 1023d14:	6a23      	ldr	r3, [r4, #32]
 1023d16:	4798      	blx	r3
	__asm__ volatile(
 1023d18:	f04f 0320 	mov.w	r3, #32
 1023d1c:	f3ef 8511 	mrs	r5, BASEPRI
 1023d20:	f383 8812 	msr	BASEPRI_MAX, r3
 1023d24:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1023d28:	4814      	ldr	r0, [pc, #80]	; (1023d7c <z_timer_expiration_handler+0x13c>)
 1023d2a:	f7fd f9d1 	bl	10210d0 <z_spin_lock_valid>
 1023d2e:	2800      	cmp	r0, #0
 1023d30:	d094      	beq.n	1023c5c <z_timer_expiration_handler+0x1c>
	z_spin_lock_set_owner(l);
 1023d32:	4812      	ldr	r0, [pc, #72]	; (1023d7c <z_timer_expiration_handler+0x13c>)
 1023d34:	f7fd f9e8 	bl	1021108 <z_spin_lock_set_owner>
	return list->head == list;
 1023d38:	f854 6f18 	ldr.w	r6, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1023d3c:	42a6      	cmp	r6, r4
 1023d3e:	d000      	beq.n	1023d42 <z_timer_expiration_handler+0x102>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
 1023d40:	b94e      	cbnz	r6, 1023d56 <z_timer_expiration_handler+0x116>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023d42:	480e      	ldr	r0, [pc, #56]	; (1023d7c <z_timer_expiration_handler+0x13c>)
 1023d44:	f7fd f9d2 	bl	10210ec <z_spin_unlock_valid>
 1023d48:	2800      	cmp	r0, #0
 1023d4a:	d0cd      	beq.n	1023ce8 <z_timer_expiration_handler+0xa8>
	__asm__ volatile(
 1023d4c:	f385 8811 	msr	BASEPRI, r5
 1023d50:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
 1023d54:	bd70      	pop	{r4, r5, r6, pc}
	z_unpend_thread_no_timeout(thread);
 1023d56:	4630      	mov	r0, r6
 1023d58:	f7fe fc20 	bl	102259c <z_unpend_thread_no_timeout>
 1023d5c:	2300      	movs	r3, #0
 1023d5e:	4807      	ldr	r0, [pc, #28]	; (1023d7c <z_timer_expiration_handler+0x13c>)
 1023d60:	67f3      	str	r3, [r6, #124]	; 0x7c
 1023d62:	f7fd f9c3 	bl	10210ec <z_spin_unlock_valid>
 1023d66:	2800      	cmp	r0, #0
 1023d68:	d0be      	beq.n	1023ce8 <z_timer_expiration_handler+0xa8>
 1023d6a:	f385 8811 	msr	BASEPRI, r5
 1023d6e:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
 1023d72:	4630      	mov	r0, r6
}
 1023d74:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_ready_thread(thread);
 1023d78:	f7fe bbca 	b.w	1022510 <z_ready_thread>
 1023d7c:	2100811c 	.word	0x2100811c
 1023d80:	0102bd8a 	.word	0x0102bd8a
 1023d84:	0102bde3 	.word	0x0102bde3
 1023d88:	0102b695 	.word	0x0102b695
 1023d8c:	0102bdf8 	.word	0x0102bdf8
 1023d90:	01023c41 	.word	0x01023c41
 1023d94:	0102bdb7 	.word	0x0102bdb7
 1023d98:	0102bdce 	.word	0x0102bdce

01023d9c <z_impl_k_timer_start>:
void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer, duration, period);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
 1023d9c:	f1b3 3fff 	cmp.w	r3, #4294967295
 1023da0:	bf08      	it	eq
 1023da2:	f1b2 3fff 	cmpeq.w	r2, #4294967295
{
 1023da6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1023daa:	4619      	mov	r1, r3
 1023dac:	4605      	mov	r5, r0
 1023dae:	e9dd 6008 	ldrd	r6, r0, [sp, #32]
 1023db2:	4614      	mov	r4, r2
 1023db4:	4691      	mov	r9, r2
 1023db6:	4698      	mov	r8, r3
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
 1023db8:	d037      	beq.n	1023e2a <z_impl_k_timer_start+0x8e>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
 1023dba:	f1b0 3fff 	cmp.w	r0, #4294967295
 1023dbe:	bf08      	it	eq
 1023dc0:	f1b6 3fff 	cmpeq.w	r6, #4294967295
 1023dc4:	4637      	mov	r7, r6
 1023dc6:	4682      	mov	sl, r0
 1023dc8:	d011      	beq.n	1023dee <z_impl_k_timer_start+0x52>
 1023dca:	ea50 0306 	orrs.w	r3, r0, r6
 1023dce:	d00e      	beq.n	1023dee <z_impl_k_timer_start+0x52>
 1023dd0:	1c72      	adds	r2, r6, #1
 1023dd2:	f170 33ff 	sbcs.w	r3, r0, #4294967295
 1023dd6:	db0a      	blt.n	1023dee <z_impl_k_timer_start+0x52>
	    Z_TICK_ABS(period.ticks) < 0) {
		period.ticks = MAX(period.ticks - 1, 1);
 1023dd8:	2e02      	cmp	r6, #2
 1023dda:	4684      	mov	ip, r0
 1023ddc:	f170 0000 	sbcs.w	r0, r0, #0
 1023de0:	bfbc      	itt	lt
 1023de2:	2702      	movlt	r7, #2
 1023de4:	f04f 0c00 	movlt.w	ip, #0
 1023de8:	3f01      	subs	r7, #1
 1023dea:	f14c 3aff 	adc.w	sl, ip, #4294967295
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
 1023dee:	1c63      	adds	r3, r4, #1
 1023df0:	f171 33ff 	sbcs.w	r3, r1, #4294967295
 1023df4:	db0a      	blt.n	1023e0c <z_impl_k_timer_start+0x70>
		duration.ticks = MAX(duration.ticks - 1, 0);
 1023df6:	2c01      	cmp	r4, #1
 1023df8:	f171 0300 	sbcs.w	r3, r1, #0
 1023dfc:	4622      	mov	r2, r4
 1023dfe:	bfbc      	itt	lt
 1023e00:	2201      	movlt	r2, #1
 1023e02:	2100      	movlt	r1, #0
 1023e04:	f112 39ff 	adds.w	r9, r2, #4294967295
 1023e08:	f141 38ff 	adc.w	r8, r1, #4294967295
	}

	(void)z_abort_timeout(&timer->timeout);
 1023e0c:	4628      	mov	r0, r5
 1023e0e:	f7ff fd8d 	bl	102392c <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
 1023e12:	2300      	movs	r3, #0
	timer->period = period;
 1023e14:	e9c5 7a0a 	strd	r7, sl, [r5, #40]	; 0x28
	timer->status = 0U;
 1023e18:	632b      	str	r3, [r5, #48]	; 0x30

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 1023e1a:	464a      	mov	r2, r9
 1023e1c:	4643      	mov	r3, r8
 1023e1e:	4628      	mov	r0, r5
		     duration);
}
 1023e20:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 1023e24:	4902      	ldr	r1, [pc, #8]	; (1023e30 <z_impl_k_timer_start+0x94>)
 1023e26:	f7ff bcbb 	b.w	10237a0 <z_add_timeout>
}
 1023e2a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1023e2e:	bf00      	nop
 1023e30:	01023c41 	.word	0x01023c41

01023e34 <register_events>:

static inline int register_events(struct k_poll_event *events,
				  int num_events,
				  struct z_poller *poller,
				  bool just_check)
{
 1023e34:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int events_registered = 0;

	for (int ii = 0; ii < num_events; ii++) {
 1023e38:	2600      	movs	r6, #0
{
 1023e3a:	4688      	mov	r8, r1
 1023e3c:	4615      	mov	r5, r2
	for (int ii = 0; ii < num_events; ii++) {
 1023e3e:	4604      	mov	r4, r0
	int events_registered = 0;
 1023e40:	4637      	mov	r7, r6
	event->poller = NULL;
 1023e42:	46b2      	mov	sl, r6
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1023e44:	f8df 91bc 	ldr.w	r9, [pc, #444]	; 1024004 <register_events+0x1d0>
{
 1023e48:	9301      	str	r3, [sp, #4]
	for (int ii = 0; ii < num_events; ii++) {
 1023e4a:	4546      	cmp	r6, r8
 1023e4c:	db03      	blt.n	1023e56 <register_events+0x22>
		}
		k_spin_unlock(&lock, key);
	}

	return events_registered;
}
 1023e4e:	4638      	mov	r0, r7
 1023e50:	b003      	add	sp, #12
 1023e52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__asm__ volatile(
 1023e56:	f04f 0320 	mov.w	r3, #32
 1023e5a:	f3ef 8b11 	mrs	fp, BASEPRI
 1023e5e:	f383 8812 	msr	BASEPRI_MAX, r3
 1023e62:	f3bf 8f6f 	isb	sy
 1023e66:	4648      	mov	r0, r9
 1023e68:	f7fd f932 	bl	10210d0 <z_spin_lock_valid>
 1023e6c:	b960      	cbnz	r0, 1023e88 <register_events+0x54>
 1023e6e:	2394      	movs	r3, #148	; 0x94
 1023e70:	4a65      	ldr	r2, [pc, #404]	; (1024008 <register_events+0x1d4>)
 1023e72:	4966      	ldr	r1, [pc, #408]	; (102400c <register_events+0x1d8>)
 1023e74:	4866      	ldr	r0, [pc, #408]	; (1024010 <register_events+0x1dc>)
 1023e76:	f000 feae 	bl	1024bd6 <assert_print>
 1023e7a:	4962      	ldr	r1, [pc, #392]	; (1024004 <register_events+0x1d0>)
 1023e7c:	4865      	ldr	r0, [pc, #404]	; (1024014 <register_events+0x1e0>)
 1023e7e:	f000 feaa 	bl	1024bd6 <assert_print>
 1023e82:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023e84:	4860      	ldr	r0, [pc, #384]	; (1024008 <register_events+0x1d4>)
 1023e86:	e060      	b.n	1023f4a <register_events+0x116>
	z_spin_lock_set_owner(l);
 1023e88:	4648      	mov	r0, r9
 1023e8a:	f7fd f93d 	bl	1021108 <z_spin_lock_set_owner>
	switch (event->type) {
 1023e8e:	7b63      	ldrb	r3, [r4, #13]
 1023e90:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 1023e94:	2b08      	cmp	r3, #8
 1023e96:	d84a      	bhi.n	1023f2e <register_events+0xfa>
 1023e98:	e8df f003 	tbb	[pc, r3]
 1023e9c:	49053d2b 	.word	0x49053d2b
 1023ea0:	49494927 	.word	0x49494927
 1023ea4:	43          	.byte	0x43
 1023ea5:	00          	.byte	0x00
		if (k_sem_count_get(event->sem) > 0U) {
 1023ea6:	6923      	ldr	r3, [r4, #16]
 1023ea8:	689b      	ldr	r3, [r3, #8]
 1023eaa:	b313      	cbz	r3, 1023ef2 <register_events+0xbe>
			*state = K_POLL_STATE_SEM_AVAILABLE;
 1023eac:	2302      	movs	r3, #2
	event->state |= state;
 1023eae:	68e2      	ldr	r2, [r4, #12]
	event->poller = NULL;
 1023eb0:	f8c4 a008 	str.w	sl, [r4, #8]
	event->state |= state;
 1023eb4:	f3c2 3186 	ubfx	r1, r2, #14, #7
 1023eb8:	430b      	orrs	r3, r1
 1023eba:	f363 3294 	bfi	r2, r3, #14, #7
 1023ebe:	60e2      	str	r2, [r4, #12]
			poller->is_polling = false;
 1023ec0:	f885 a000 	strb.w	sl, [r5]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1023ec4:	4648      	mov	r0, r9
 1023ec6:	f7fd f911 	bl	10210ec <z_spin_unlock_valid>
 1023eca:	3414      	adds	r4, #20
 1023ecc:	2800      	cmp	r0, #0
 1023ece:	f040 8092 	bne.w	1023ff6 <register_events+0x1c2>
 1023ed2:	23c2      	movs	r3, #194	; 0xc2
 1023ed4:	4a4c      	ldr	r2, [pc, #304]	; (1024008 <register_events+0x1d4>)
 1023ed6:	4950      	ldr	r1, [pc, #320]	; (1024018 <register_events+0x1e4>)
 1023ed8:	484d      	ldr	r0, [pc, #308]	; (1024010 <register_events+0x1dc>)
 1023eda:	f000 fe7c 	bl	1024bd6 <assert_print>
 1023ede:	4949      	ldr	r1, [pc, #292]	; (1024004 <register_events+0x1d0>)
 1023ee0:	484e      	ldr	r0, [pc, #312]	; (102401c <register_events+0x1e8>)
 1023ee2:	f000 fe78 	bl	1024bd6 <assert_print>
 1023ee6:	21c2      	movs	r1, #194	; 0xc2
 1023ee8:	e7cc      	b.n	1023e84 <register_events+0x50>
		if (!k_queue_is_empty(event->queue)) {
 1023eea:	6923      	ldr	r3, [r4, #16]
 1023eec:	681b      	ldr	r3, [r3, #0]
 1023eee:	2b00      	cmp	r3, #0
 1023ef0:	d12d      	bne.n	1023f4e <register_events+0x11a>
		} else if (!just_check && poller->is_polling) {
 1023ef2:	9b01      	ldr	r3, [sp, #4]
 1023ef4:	2b00      	cmp	r3, #0
 1023ef6:	d1e5      	bne.n	1023ec4 <register_events+0x90>
 1023ef8:	782b      	ldrb	r3, [r5, #0]
 1023efa:	2b00      	cmp	r3, #0
 1023efc:	d0e2      	beq.n	1023ec4 <register_events+0x90>
	switch (event->type) {
 1023efe:	7b63      	ldrb	r3, [r4, #13]
 1023f00:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 1023f04:	2b08      	cmp	r3, #8
 1023f06:	d86b      	bhi.n	1023fe0 <register_events+0x1ac>
 1023f08:	e8df f003 	tbb	[pc, r3]
 1023f0c:	6a234935 	.word	0x6a234935
 1023f10:	6a6a6a38 	.word	0x6a6a6a38
 1023f14:	59          	.byte	0x59
 1023f15:	00          	.byte	0x00
		if (event->signal->signaled != 0U) {
 1023f16:	6923      	ldr	r3, [r4, #16]
 1023f18:	689b      	ldr	r3, [r3, #8]
 1023f1a:	2b00      	cmp	r3, #0
 1023f1c:	d0e9      	beq.n	1023ef2 <register_events+0xbe>
			*state = K_POLL_STATE_SIGNALED;
 1023f1e:	2301      	movs	r3, #1
 1023f20:	e7c5      	b.n	1023eae <register_events+0x7a>
		if (event->msgq->used_msgs > 0) {
 1023f22:	6923      	ldr	r3, [r4, #16]
 1023f24:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 1023f26:	2b00      	cmp	r3, #0
 1023f28:	d0e3      	beq.n	1023ef2 <register_events+0xbe>
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
 1023f2a:	2310      	movs	r3, #16
 1023f2c:	e7bf      	b.n	1023eae <register_events+0x7a>
		__ASSERT(false, "invalid event type (0x%x)\n", event->type);
 1023f2e:	2363      	movs	r3, #99	; 0x63
 1023f30:	4a3b      	ldr	r2, [pc, #236]	; (1024020 <register_events+0x1ec>)
 1023f32:	493c      	ldr	r1, [pc, #240]	; (1024024 <register_events+0x1f0>)
 1023f34:	4836      	ldr	r0, [pc, #216]	; (1024010 <register_events+0x1dc>)
 1023f36:	f000 fe4e 	bl	1024bd6 <assert_print>
 1023f3a:	7b61      	ldrb	r1, [r4, #13]
 1023f3c:	483a      	ldr	r0, [pc, #232]	; (1024028 <register_events+0x1f4>)
 1023f3e:	f001 013f 	and.w	r1, r1, #63	; 0x3f
 1023f42:	f000 fe48 	bl	1024bd6 <assert_print>
 1023f46:	2163      	movs	r1, #99	; 0x63
 1023f48:	4835      	ldr	r0, [pc, #212]	; (1024020 <register_events+0x1ec>)
 1023f4a:	f000 fe3d 	bl	1024bc8 <assert_post_action>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
 1023f4e:	2304      	movs	r3, #4
 1023f50:	e7ad      	b.n	1023eae <register_events+0x7a>
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
 1023f52:	6920      	ldr	r0, [r4, #16]
 1023f54:	b950      	cbnz	r0, 1023f6c <register_events+0x138>
 1023f56:	4935      	ldr	r1, [pc, #212]	; (102402c <register_events+0x1f8>)
 1023f58:	238d      	movs	r3, #141	; 0x8d
 1023f5a:	4a31      	ldr	r2, [pc, #196]	; (1024020 <register_events+0x1ec>)
 1023f5c:	482c      	ldr	r0, [pc, #176]	; (1024010 <register_events+0x1dc>)
 1023f5e:	f000 fe3a 	bl	1024bd6 <assert_print>
 1023f62:	4833      	ldr	r0, [pc, #204]	; (1024030 <register_events+0x1fc>)
 1023f64:	f000 fe37 	bl	1024bd6 <assert_print>
 1023f68:	218d      	movs	r1, #141	; 0x8d
 1023f6a:	e7ed      	b.n	1023f48 <register_events+0x114>
		add_event(&event->sem->poll_events, event, poller);
 1023f6c:	462a      	mov	r2, r5
 1023f6e:	4621      	mov	r1, r4
 1023f70:	3010      	adds	r0, #16
		add_event(&event->msgq->poll_events, event, poller);
 1023f72:	f005 faca 	bl	102950a <add_event>
	event->poller = poller;
 1023f76:	60a5      	str	r5, [r4, #8]
			events_registered += 1;
 1023f78:	3701      	adds	r7, #1
 1023f7a:	e7a3      	b.n	1023ec4 <register_events+0x90>
		__ASSERT(event->queue != NULL, "invalid queue\n");
 1023f7c:	6920      	ldr	r0, [r4, #16]
 1023f7e:	b950      	cbnz	r0, 1023f96 <register_events+0x162>
 1023f80:	492c      	ldr	r1, [pc, #176]	; (1024034 <register_events+0x200>)
 1023f82:	2391      	movs	r3, #145	; 0x91
 1023f84:	4a26      	ldr	r2, [pc, #152]	; (1024020 <register_events+0x1ec>)
 1023f86:	4822      	ldr	r0, [pc, #136]	; (1024010 <register_events+0x1dc>)
 1023f88:	f000 fe25 	bl	1024bd6 <assert_print>
 1023f8c:	482a      	ldr	r0, [pc, #168]	; (1024038 <register_events+0x204>)
 1023f8e:	f000 fe22 	bl	1024bd6 <assert_print>
 1023f92:	2191      	movs	r1, #145	; 0x91
 1023f94:	e7d8      	b.n	1023f48 <register_events+0x114>
		add_event(&event->queue->poll_events, event, poller);
 1023f96:	462a      	mov	r2, r5
 1023f98:	4621      	mov	r1, r4
 1023f9a:	3014      	adds	r0, #20
 1023f9c:	e7e9      	b.n	1023f72 <register_events+0x13e>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
 1023f9e:	6920      	ldr	r0, [r4, #16]
 1023fa0:	b950      	cbnz	r0, 1023fb8 <register_events+0x184>
 1023fa2:	4926      	ldr	r1, [pc, #152]	; (102403c <register_events+0x208>)
 1023fa4:	2395      	movs	r3, #149	; 0x95
 1023fa6:	4a1e      	ldr	r2, [pc, #120]	; (1024020 <register_events+0x1ec>)
 1023fa8:	4819      	ldr	r0, [pc, #100]	; (1024010 <register_events+0x1dc>)
 1023faa:	f000 fe14 	bl	1024bd6 <assert_print>
 1023fae:	4824      	ldr	r0, [pc, #144]	; (1024040 <register_events+0x20c>)
 1023fb0:	f000 fe11 	bl	1024bd6 <assert_print>
 1023fb4:	2195      	movs	r1, #149	; 0x95
 1023fb6:	e7c7      	b.n	1023f48 <register_events+0x114>
		add_event(&event->signal->poll_events, event, poller);
 1023fb8:	462a      	mov	r2, r5
 1023fba:	4621      	mov	r1, r4
 1023fbc:	e7d9      	b.n	1023f72 <register_events+0x13e>
		__ASSERT(event->msgq != NULL, "invalid message queue\n");
 1023fbe:	6920      	ldr	r0, [r4, #16]
 1023fc0:	b950      	cbnz	r0, 1023fd8 <register_events+0x1a4>
 1023fc2:	4920      	ldr	r1, [pc, #128]	; (1024044 <register_events+0x210>)
 1023fc4:	2399      	movs	r3, #153	; 0x99
 1023fc6:	4a16      	ldr	r2, [pc, #88]	; (1024020 <register_events+0x1ec>)
 1023fc8:	4811      	ldr	r0, [pc, #68]	; (1024010 <register_events+0x1dc>)
 1023fca:	f000 fe04 	bl	1024bd6 <assert_print>
 1023fce:	481e      	ldr	r0, [pc, #120]	; (1024048 <register_events+0x214>)
 1023fd0:	f000 fe01 	bl	1024bd6 <assert_print>
 1023fd4:	2199      	movs	r1, #153	; 0x99
 1023fd6:	e7b7      	b.n	1023f48 <register_events+0x114>
		add_event(&event->msgq->poll_events, event, poller);
 1023fd8:	462a      	mov	r2, r5
 1023fda:	4621      	mov	r1, r4
 1023fdc:	3028      	adds	r0, #40	; 0x28
 1023fde:	e7c8      	b.n	1023f72 <register_events+0x13e>
		__ASSERT(false, "invalid event type\n");
 1023fe0:	4910      	ldr	r1, [pc, #64]	; (1024024 <register_events+0x1f0>)
 1023fe2:	23a6      	movs	r3, #166	; 0xa6
 1023fe4:	4a0e      	ldr	r2, [pc, #56]	; (1024020 <register_events+0x1ec>)
 1023fe6:	480a      	ldr	r0, [pc, #40]	; (1024010 <register_events+0x1dc>)
 1023fe8:	f000 fdf5 	bl	1024bd6 <assert_print>
 1023fec:	4817      	ldr	r0, [pc, #92]	; (102404c <register_events+0x218>)
 1023fee:	f000 fdf2 	bl	1024bd6 <assert_print>
 1023ff2:	21a6      	movs	r1, #166	; 0xa6
 1023ff4:	e7a8      	b.n	1023f48 <register_events+0x114>
	__asm__ volatile(
 1023ff6:	f38b 8811 	msr	BASEPRI, fp
 1023ffa:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
 1023ffe:	3601      	adds	r6, #1
 1024000:	e723      	b.n	1023e4a <register_events+0x16>
 1024002:	bf00      	nop
 1024004:	21008120 	.word	0x21008120
 1024008:	0102bd8a 	.word	0x0102bd8a
 102400c:	0102bde3 	.word	0x0102bde3
 1024010:	0102b695 	.word	0x0102b695
 1024014:	0102bdf8 	.word	0x0102bdf8
 1024018:	0102bdb7 	.word	0x0102bdb7
 102401c:	0102bdce 	.word	0x0102bdce
 1024020:	0102fd19 	.word	0x0102fd19
 1024024:	0102ff6e 	.word	0x0102ff6e
 1024028:	0102fd3a 	.word	0x0102fd3a
 102402c:	0102fd57 	.word	0x0102fd57
 1024030:	0102fd71 	.word	0x0102fd71
 1024034:	0102fd86 	.word	0x0102fd86
 1024038:	0102fda2 	.word	0x0102fda2
 102403c:	0102fdb3 	.word	0x0102fdb3
 1024040:	0102fdd0 	.word	0x0102fdd0
 1024044:	0102fde7 	.word	0x0102fde7
 1024048:	0102fe02 	.word	0x0102fe02
 102404c:	0102fe1b 	.word	0x0102fe1b

01024050 <clear_event_registrations>:
{
 1024050:	2314      	movs	r3, #20
 1024052:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1024056:	4615      	mov	r5, r2
	while (num_events--) {
 1024058:	460c      	mov	r4, r1
	event->poller = NULL;
 102405a:	2600      	movs	r6, #0
 102405c:	fb03 0001 	mla	r0, r3, r1, r0
 1024060:	4f4b      	ldr	r7, [pc, #300]	; (1024190 <clear_event_registrations+0x140>)
	while (num_events--) {
 1024062:	b90c      	cbnz	r4, 1024068 <clear_event_registrations+0x18>
}
 1024064:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (event->type) {
 1024068:	f810 3c07 	ldrb.w	r3, [r0, #-7]
 102406c:	f1a0 0814 	sub.w	r8, r0, #20
 1024070:	f003 033f 	and.w	r3, r3, #63	; 0x3f
	event->poller = NULL;
 1024074:	f840 6c0c 	str.w	r6, [r0, #-12]
	switch (event->type) {
 1024078:	2b08      	cmp	r3, #8
 102407a:	d842      	bhi.n	1024102 <clear_event_registrations+0xb2>
 102407c:	e8df f003 	tbb	[pc, r3]
 1024080:	41052555 	.word	0x41052555
 1024084:	41414116 	.word	0x41414116
 1024088:	33          	.byte	0x33
 1024089:	00          	.byte	0x00
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
 102408a:	f850 3c04 	ldr.w	r3, [r0, #-4]
 102408e:	2b00      	cmp	r3, #0
 1024090:	d142      	bne.n	1024118 <clear_event_registrations+0xc8>
 1024092:	4940      	ldr	r1, [pc, #256]	; (1024194 <clear_event_registrations+0x144>)
 1024094:	23b6      	movs	r3, #182	; 0xb6
 1024096:	4a40      	ldr	r2, [pc, #256]	; (1024198 <clear_event_registrations+0x148>)
 1024098:	4840      	ldr	r0, [pc, #256]	; (102419c <clear_event_registrations+0x14c>)
 102409a:	f000 fd9c 	bl	1024bd6 <assert_print>
 102409e:	4840      	ldr	r0, [pc, #256]	; (10241a0 <clear_event_registrations+0x150>)
 10240a0:	f000 fd99 	bl	1024bd6 <assert_print>
 10240a4:	21b6      	movs	r1, #182	; 0xb6
		__ASSERT(event->queue != NULL, "invalid queue\n");
 10240a6:	483c      	ldr	r0, [pc, #240]	; (1024198 <clear_event_registrations+0x148>)
 10240a8:	f000 fd8e 	bl	1024bc8 <assert_post_action>
 10240ac:	f850 3c04 	ldr.w	r3, [r0, #-4]
 10240b0:	2b00      	cmp	r3, #0
 10240b2:	d131      	bne.n	1024118 <clear_event_registrations+0xc8>
 10240b4:	493b      	ldr	r1, [pc, #236]	; (10241a4 <clear_event_registrations+0x154>)
 10240b6:	23ba      	movs	r3, #186	; 0xba
 10240b8:	4a37      	ldr	r2, [pc, #220]	; (1024198 <clear_event_registrations+0x148>)
 10240ba:	4838      	ldr	r0, [pc, #224]	; (102419c <clear_event_registrations+0x14c>)
 10240bc:	f000 fd8b 	bl	1024bd6 <assert_print>
 10240c0:	4839      	ldr	r0, [pc, #228]	; (10241a8 <clear_event_registrations+0x158>)
 10240c2:	f000 fd88 	bl	1024bd6 <assert_print>
 10240c6:	21ba      	movs	r1, #186	; 0xba
 10240c8:	e7ed      	b.n	10240a6 <clear_event_registrations+0x56>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
 10240ca:	f850 3c04 	ldr.w	r3, [r0, #-4]
 10240ce:	bb1b      	cbnz	r3, 1024118 <clear_event_registrations+0xc8>
 10240d0:	4936      	ldr	r1, [pc, #216]	; (10241ac <clear_event_registrations+0x15c>)
 10240d2:	23be      	movs	r3, #190	; 0xbe
 10240d4:	4a30      	ldr	r2, [pc, #192]	; (1024198 <clear_event_registrations+0x148>)
 10240d6:	4831      	ldr	r0, [pc, #196]	; (102419c <clear_event_registrations+0x14c>)
 10240d8:	f000 fd7d 	bl	1024bd6 <assert_print>
 10240dc:	4834      	ldr	r0, [pc, #208]	; (10241b0 <clear_event_registrations+0x160>)
 10240de:	f000 fd7a 	bl	1024bd6 <assert_print>
 10240e2:	21be      	movs	r1, #190	; 0xbe
 10240e4:	e7df      	b.n	10240a6 <clear_event_registrations+0x56>
		__ASSERT(event->msgq != NULL, "invalid message queue\n");
 10240e6:	f850 3c04 	ldr.w	r3, [r0, #-4]
 10240ea:	b9ab      	cbnz	r3, 1024118 <clear_event_registrations+0xc8>
 10240ec:	4931      	ldr	r1, [pc, #196]	; (10241b4 <clear_event_registrations+0x164>)
 10240ee:	23c2      	movs	r3, #194	; 0xc2
 10240f0:	4a29      	ldr	r2, [pc, #164]	; (1024198 <clear_event_registrations+0x148>)
 10240f2:	482a      	ldr	r0, [pc, #168]	; (102419c <clear_event_registrations+0x14c>)
 10240f4:	f000 fd6f 	bl	1024bd6 <assert_print>
 10240f8:	482f      	ldr	r0, [pc, #188]	; (10241b8 <clear_event_registrations+0x168>)
 10240fa:	f000 fd6c 	bl	1024bd6 <assert_print>
 10240fe:	21c2      	movs	r1, #194	; 0xc2
 1024100:	e7d1      	b.n	10240a6 <clear_event_registrations+0x56>
		__ASSERT(false, "invalid event type\n");
 1024102:	492e      	ldr	r1, [pc, #184]	; (10241bc <clear_event_registrations+0x16c>)
 1024104:	23cf      	movs	r3, #207	; 0xcf
 1024106:	4a24      	ldr	r2, [pc, #144]	; (1024198 <clear_event_registrations+0x148>)
 1024108:	4824      	ldr	r0, [pc, #144]	; (102419c <clear_event_registrations+0x14c>)
 102410a:	f000 fd64 	bl	1024bd6 <assert_print>
 102410e:	482c      	ldr	r0, [pc, #176]	; (10241c0 <clear_event_registrations+0x170>)
 1024110:	f000 fd61 	bl	1024bd6 <assert_print>
 1024114:	21cf      	movs	r1, #207	; 0xcf
 1024116:	e7c6      	b.n	10240a6 <clear_event_registrations+0x56>
	return node->next != NULL;
 1024118:	f850 3c14 	ldr.w	r3, [r0, #-20]
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
 102411c:	b12b      	cbz	r3, 102412a <clear_event_registrations+0xda>
	sys_dnode_t *const prev = node->prev;
 102411e:	f850 2c10 	ldr.w	r2, [r0, #-16]
	prev->next = next;
 1024122:	6013      	str	r3, [r2, #0]
	next->prev = prev;
 1024124:	605a      	str	r2, [r3, #4]
	node->prev = NULL;
 1024126:	e940 6605 	strd	r6, r6, [r0, #-20]
 102412a:	4638      	mov	r0, r7
 102412c:	f7fc ffde 	bl	10210ec <z_spin_unlock_valid>
 1024130:	b960      	cbnz	r0, 102414c <clear_event_registrations+0xfc>
 1024132:	23c2      	movs	r3, #194	; 0xc2
 1024134:	4a23      	ldr	r2, [pc, #140]	; (10241c4 <clear_event_registrations+0x174>)
 1024136:	4924      	ldr	r1, [pc, #144]	; (10241c8 <clear_event_registrations+0x178>)
 1024138:	4818      	ldr	r0, [pc, #96]	; (102419c <clear_event_registrations+0x14c>)
 102413a:	f000 fd4c 	bl	1024bd6 <assert_print>
 102413e:	4914      	ldr	r1, [pc, #80]	; (1024190 <clear_event_registrations+0x140>)
 1024140:	4822      	ldr	r0, [pc, #136]	; (10241cc <clear_event_registrations+0x17c>)
 1024142:	f000 fd48 	bl	1024bd6 <assert_print>
 1024146:	21c2      	movs	r1, #194	; 0xc2
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 1024148:	481e      	ldr	r0, [pc, #120]	; (10241c4 <clear_event_registrations+0x174>)
 102414a:	e7ad      	b.n	10240a8 <clear_event_registrations+0x58>
 102414c:	f385 8811 	msr	BASEPRI, r5
 1024150:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
 1024154:	f04f 0320 	mov.w	r3, #32
 1024158:	f3ef 8511 	mrs	r5, BASEPRI
 102415c:	f383 8812 	msr	BASEPRI_MAX, r3
 1024160:	f3bf 8f6f 	isb	sy
 1024164:	4638      	mov	r0, r7
 1024166:	f7fc ffb3 	bl	10210d0 <z_spin_lock_valid>
 102416a:	3c01      	subs	r4, #1
 102416c:	b958      	cbnz	r0, 1024186 <clear_event_registrations+0x136>
 102416e:	2394      	movs	r3, #148	; 0x94
 1024170:	4a14      	ldr	r2, [pc, #80]	; (10241c4 <clear_event_registrations+0x174>)
 1024172:	4917      	ldr	r1, [pc, #92]	; (10241d0 <clear_event_registrations+0x180>)
 1024174:	4809      	ldr	r0, [pc, #36]	; (102419c <clear_event_registrations+0x14c>)
 1024176:	f000 fd2e 	bl	1024bd6 <assert_print>
 102417a:	4905      	ldr	r1, [pc, #20]	; (1024190 <clear_event_registrations+0x140>)
 102417c:	4815      	ldr	r0, [pc, #84]	; (10241d4 <clear_event_registrations+0x184>)
 102417e:	f000 fd2a 	bl	1024bd6 <assert_print>
 1024182:	2194      	movs	r1, #148	; 0x94
 1024184:	e7e0      	b.n	1024148 <clear_event_registrations+0xf8>
	z_spin_lock_set_owner(l);
 1024186:	4638      	mov	r0, r7
 1024188:	f7fc ffbe 	bl	1021108 <z_spin_lock_set_owner>
	return k;
 102418c:	4640      	mov	r0, r8
 102418e:	e768      	b.n	1024062 <clear_event_registrations+0x12>
 1024190:	21008120 	.word	0x21008120
 1024194:	0102fd57 	.word	0x0102fd57
 1024198:	0102fd19 	.word	0x0102fd19
 102419c:	0102b695 	.word	0x0102b695
 10241a0:	0102fd71 	.word	0x0102fd71
 10241a4:	0102fd86 	.word	0x0102fd86
 10241a8:	0102fda2 	.word	0x0102fda2
 10241ac:	0102fdb3 	.word	0x0102fdb3
 10241b0:	0102fdd0 	.word	0x0102fdd0
 10241b4:	0102fde7 	.word	0x0102fde7
 10241b8:	0102fe02 	.word	0x0102fe02
 10241bc:	0102ff6e 	.word	0x0102ff6e
 10241c0:	0102fe1b 	.word	0x0102fe1b
 10241c4:	0102bd8a 	.word	0x0102bd8a
 10241c8:	0102bdb7 	.word	0x0102bdb7
 10241cc:	0102bdce 	.word	0x0102bdce
 10241d0:	0102bde3 	.word	0x0102bde3
 10241d4:	0102bdf8 	.word	0x0102bdf8

010241d8 <k_poll_event_init>:
{
 10241d8:	b508      	push	{r3, lr}
	__ASSERT(mode == K_POLL_MODE_NOTIFY_ONLY,
 10241da:	b162      	cbz	r2, 10241f6 <k_poll_event_init+0x1e>
 10241dc:	4917      	ldr	r1, [pc, #92]	; (102423c <k_poll_event_init+0x64>)
 10241de:	232d      	movs	r3, #45	; 0x2d
 10241e0:	4a17      	ldr	r2, [pc, #92]	; (1024240 <k_poll_event_init+0x68>)
 10241e2:	4818      	ldr	r0, [pc, #96]	; (1024244 <k_poll_event_init+0x6c>)
 10241e4:	f000 fcf7 	bl	1024bd6 <assert_print>
 10241e8:	4817      	ldr	r0, [pc, #92]	; (1024248 <k_poll_event_init+0x70>)
 10241ea:	f000 fcf4 	bl	1024bd6 <assert_print>
 10241ee:	212d      	movs	r1, #45	; 0x2d
	__ASSERT(type < (BIT(_POLL_NUM_TYPES)), "invalid type\n");
 10241f0:	4813      	ldr	r0, [pc, #76]	; (1024240 <k_poll_event_init+0x68>)
 10241f2:	f000 fce9 	bl	1024bc8 <assert_post_action>
 10241f6:	293f      	cmp	r1, #63	; 0x3f
 10241f8:	d90a      	bls.n	1024210 <k_poll_event_init+0x38>
 10241fa:	4914      	ldr	r1, [pc, #80]	; (102424c <k_poll_event_init+0x74>)
 10241fc:	232f      	movs	r3, #47	; 0x2f
 10241fe:	4a10      	ldr	r2, [pc, #64]	; (1024240 <k_poll_event_init+0x68>)
 1024200:	4810      	ldr	r0, [pc, #64]	; (1024244 <k_poll_event_init+0x6c>)
 1024202:	f000 fce8 	bl	1024bd6 <assert_print>
 1024206:	4812      	ldr	r0, [pc, #72]	; (1024250 <k_poll_event_init+0x78>)
 1024208:	f000 fce5 	bl	1024bd6 <assert_print>
 102420c:	212f      	movs	r1, #47	; 0x2f
 102420e:	e7ef      	b.n	10241f0 <k_poll_event_init+0x18>
	__ASSERT(obj != NULL, "must provide an object\n");
 1024210:	b953      	cbnz	r3, 1024228 <k_poll_event_init+0x50>
 1024212:	4910      	ldr	r1, [pc, #64]	; (1024254 <k_poll_event_init+0x7c>)
 1024214:	2330      	movs	r3, #48	; 0x30
 1024216:	4a0a      	ldr	r2, [pc, #40]	; (1024240 <k_poll_event_init+0x68>)
 1024218:	480a      	ldr	r0, [pc, #40]	; (1024244 <k_poll_event_init+0x6c>)
 102421a:	f000 fcdc 	bl	1024bd6 <assert_print>
 102421e:	480e      	ldr	r0, [pc, #56]	; (1024258 <k_poll_event_init+0x80>)
 1024220:	f000 fcd9 	bl	1024bd6 <assert_print>
 1024224:	2130      	movs	r1, #48	; 0x30
 1024226:	e7e3      	b.n	10241f0 <k_poll_event_init+0x18>
	event->poller = NULL;
 1024228:	6082      	str	r2, [r0, #8]
	event->type = type;
 102422a:	0209      	lsls	r1, r1, #8
 102422c:	7b02      	ldrb	r2, [r0, #12]
 102422e:	f401 517c 	and.w	r1, r1, #16128	; 0x3f00
 1024232:	4311      	orrs	r1, r2
	event->obj = obj;
 1024234:	e9c0 1303 	strd	r1, r3, [r0, #12]
}
 1024238:	bd08      	pop	{r3, pc}
 102423a:	bf00      	nop
 102423c:	0102fe31 	.word	0x0102fe31
 1024240:	0102fd19 	.word	0x0102fd19
 1024244:	0102b695 	.word	0x0102b695
 1024248:	0102fe51 	.word	0x0102fe51
 102424c:	0102fe77 	.word	0x0102fe77
 1024250:	0102fe9b 	.word	0x0102fe9b
 1024254:	0102feab 	.word	0x0102feab
 1024258:	0102febe 	.word	0x0102febe

0102425c <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
 102425c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1024260:	461e      	mov	r6, r3
	int events_registered;
	k_spinlock_key_t key;
	struct z_poller *poller = &_current->poller;
 1024262:	4b5c      	ldr	r3, [pc, #368]	; (10243d4 <z_impl_k_poll+0x178>)
{
 1024264:	4617      	mov	r7, r2
	struct z_poller *poller = &_current->poller;
 1024266:	f8d3 8008 	ldr.w	r8, [r3, #8]

	poller->is_polling = true;
 102426a:	2301      	movs	r3, #1
{
 102426c:	4605      	mov	r5, r0
	struct z_poller *poller = &_current->poller;
 102426e:	f108 0260 	add.w	r2, r8, #96	; 0x60
	poller->is_polling = true;
 1024272:	f888 3060 	strb.w	r3, [r8, #96]	; 0x60
	poller->mode = MODE_POLL;
 1024276:	f888 3061 	strb.w	r3, [r8, #97]	; 0x61
 102427a:	f3ef 8b05 	mrs	fp, IPSR

	__ASSERT(!arch_is_in_isr(), "");
 102427e:	f1bb 0f00 	cmp.w	fp, #0
 1024282:	d00e      	beq.n	10242a2 <z_impl_k_poll+0x46>
 1024284:	4954      	ldr	r1, [pc, #336]	; (10243d8 <z_impl_k_poll+0x17c>)
 1024286:	f240 132d 	movw	r3, #301	; 0x12d
 102428a:	4a54      	ldr	r2, [pc, #336]	; (10243dc <z_impl_k_poll+0x180>)
 102428c:	4854      	ldr	r0, [pc, #336]	; (10243e0 <z_impl_k_poll+0x184>)
 102428e:	f000 fca2 	bl	1024bd6 <assert_print>
 1024292:	4854      	ldr	r0, [pc, #336]	; (10243e4 <z_impl_k_poll+0x188>)
 1024294:	f000 fc9f 	bl	1024bd6 <assert_print>
 1024298:	f240 112d 	movw	r1, #301	; 0x12d
	__ASSERT(events != NULL, "NULL events\n");
 102429c:	484f      	ldr	r0, [pc, #316]	; (10243dc <z_impl_k_poll+0x180>)
 102429e:	f000 fc93 	bl	1024bc8 <assert_post_action>
 10242a2:	b960      	cbnz	r0, 10242be <z_impl_k_poll+0x62>
 10242a4:	4950      	ldr	r1, [pc, #320]	; (10243e8 <z_impl_k_poll+0x18c>)
 10242a6:	f44f 7397 	mov.w	r3, #302	; 0x12e
 10242aa:	4a4c      	ldr	r2, [pc, #304]	; (10243dc <z_impl_k_poll+0x180>)
 10242ac:	484c      	ldr	r0, [pc, #304]	; (10243e0 <z_impl_k_poll+0x184>)
 10242ae:	f000 fc92 	bl	1024bd6 <assert_print>
 10242b2:	484e      	ldr	r0, [pc, #312]	; (10243ec <z_impl_k_poll+0x190>)
 10242b4:	f000 fc8f 	bl	1024bd6 <assert_print>
 10242b8:	f44f 7197 	mov.w	r1, #302	; 0x12e
 10242bc:	e7ee      	b.n	102429c <z_impl_k_poll+0x40>
	__ASSERT(num_events >= 0, "<0 events\n");
 10242be:	2900      	cmp	r1, #0
 10242c0:	da0c      	bge.n	10242dc <z_impl_k_poll+0x80>
 10242c2:	494b      	ldr	r1, [pc, #300]	; (10243f0 <z_impl_k_poll+0x194>)
 10242c4:	f240 132f 	movw	r3, #303	; 0x12f
 10242c8:	4a44      	ldr	r2, [pc, #272]	; (10243dc <z_impl_k_poll+0x180>)
 10242ca:	4845      	ldr	r0, [pc, #276]	; (10243e0 <z_impl_k_poll+0x184>)
 10242cc:	f000 fc83 	bl	1024bd6 <assert_print>
 10242d0:	4848      	ldr	r0, [pc, #288]	; (10243f4 <z_impl_k_poll+0x198>)
 10242d2:	f000 fc80 	bl	1024bd6 <assert_print>
 10242d6:	f240 112f 	movw	r1, #303	; 0x12f
 10242da:	e7df      	b.n	102429c <z_impl_k_poll+0x40>

	SYS_PORT_TRACING_FUNC_ENTER(k_poll_api, poll, events);

	events_registered = register_events(events, num_events, poller,
 10242dc:	ea57 0306 	orrs.w	r3, r7, r6
 10242e0:	bf0c      	ite	eq
 10242e2:	2301      	moveq	r3, #1
 10242e4:	2300      	movne	r3, #0
 10242e6:	f7ff fda5 	bl	1023e34 <register_events>
 10242ea:	4681      	mov	r9, r0
 10242ec:	f04f 0320 	mov.w	r3, #32
 10242f0:	f3ef 8a11 	mrs	sl, BASEPRI
 10242f4:	f383 8812 	msr	BASEPRI_MAX, r3
 10242f8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10242fc:	483e      	ldr	r0, [pc, #248]	; (10243f8 <z_impl_k_poll+0x19c>)
 10242fe:	f7fc fee7 	bl	10210d0 <z_spin_lock_valid>
 1024302:	b960      	cbnz	r0, 102431e <z_impl_k_poll+0xc2>
 1024304:	2394      	movs	r3, #148	; 0x94
 1024306:	4a3d      	ldr	r2, [pc, #244]	; (10243fc <z_impl_k_poll+0x1a0>)
 1024308:	493d      	ldr	r1, [pc, #244]	; (1024400 <z_impl_k_poll+0x1a4>)
 102430a:	4835      	ldr	r0, [pc, #212]	; (10243e0 <z_impl_k_poll+0x184>)
 102430c:	f000 fc63 	bl	1024bd6 <assert_print>
 1024310:	4939      	ldr	r1, [pc, #228]	; (10243f8 <z_impl_k_poll+0x19c>)
 1024312:	483c      	ldr	r0, [pc, #240]	; (1024404 <z_impl_k_poll+0x1a8>)
 1024314:	f000 fc5f 	bl	1024bd6 <assert_print>
 1024318:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 102431a:	4838      	ldr	r0, [pc, #224]	; (10243fc <z_impl_k_poll+0x1a0>)
 102431c:	e7bf      	b.n	102429e <z_impl_k_poll+0x42>
	z_spin_lock_set_owner(l);
 102431e:	4836      	ldr	r0, [pc, #216]	; (10243f8 <z_impl_k_poll+0x19c>)
 1024320:	f7fc fef2 	bl	1021108 <z_spin_lock_set_owner>
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller->is_polling) {
 1024324:	f898 4060 	ldrb.w	r4, [r8, #96]	; 0x60
 1024328:	b9e4      	cbnz	r4, 1024364 <z_impl_k_poll+0x108>
		clear_event_registrations(events, events_registered, key);
 102432a:	4628      	mov	r0, r5
 102432c:	4652      	mov	r2, sl
 102432e:	4649      	mov	r1, r9
 1024330:	f7ff fe8e 	bl	1024050 <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1024334:	4830      	ldr	r0, [pc, #192]	; (10243f8 <z_impl_k_poll+0x19c>)
 1024336:	f7fc fed9 	bl	10210ec <z_spin_unlock_valid>
 102433a:	b958      	cbnz	r0, 1024354 <z_impl_k_poll+0xf8>
 102433c:	23c2      	movs	r3, #194	; 0xc2
 102433e:	4a2f      	ldr	r2, [pc, #188]	; (10243fc <z_impl_k_poll+0x1a0>)
 1024340:	4931      	ldr	r1, [pc, #196]	; (1024408 <z_impl_k_poll+0x1ac>)
 1024342:	4827      	ldr	r0, [pc, #156]	; (10243e0 <z_impl_k_poll+0x184>)
 1024344:	f000 fc47 	bl	1024bd6 <assert_print>
 1024348:	492b      	ldr	r1, [pc, #172]	; (10243f8 <z_impl_k_poll+0x19c>)
 102434a:	4830      	ldr	r0, [pc, #192]	; (102440c <z_impl_k_poll+0x1b0>)
 102434c:	f000 fc43 	bl	1024bd6 <assert_print>
 1024350:	21c2      	movs	r1, #194	; 0xc2
 1024352:	e7e2      	b.n	102431a <z_impl_k_poll+0xbe>
	__asm__ volatile(
 1024354:	f38a 8811 	msr	BASEPRI, sl
 1024358:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, swap_rc);

	return swap_rc;
}
 102435c:	4620      	mov	r0, r4
 102435e:	b003      	add	sp, #12
 1024360:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 1024364:	ea57 0306 	orrs.w	r3, r7, r6
	poller->is_polling = false;
 1024368:	f888 b060 	strb.w	fp, [r8, #96]	; 0x60
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 102436c:	d10b      	bne.n	1024386 <z_impl_k_poll+0x12a>
 102436e:	4822      	ldr	r0, [pc, #136]	; (10243f8 <z_impl_k_poll+0x19c>)
 1024370:	f7fc febc 	bl	10210ec <z_spin_unlock_valid>
 1024374:	2800      	cmp	r0, #0
 1024376:	d0e1      	beq.n	102433c <z_impl_k_poll+0xe0>
 1024378:	f38a 8811 	msr	BASEPRI, sl
 102437c:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
 1024380:	f06f 040a 	mvn.w	r4, #10
 1024384:	e7ea      	b.n	102435c <z_impl_k_poll+0x100>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
 1024386:	4651      	mov	r1, sl
 1024388:	e9cd 7600 	strd	r7, r6, [sp]
 102438c:	4a20      	ldr	r2, [pc, #128]	; (1024410 <z_impl_k_poll+0x1b4>)
 102438e:	481a      	ldr	r0, [pc, #104]	; (10243f8 <z_impl_k_poll+0x19c>)
 1024390:	f7fe fc18 	bl	1022bc4 <z_pend_curr>
 1024394:	4604      	mov	r4, r0
	__asm__ volatile(
 1024396:	f04f 0320 	mov.w	r3, #32
 102439a:	f3ef 8611 	mrs	r6, BASEPRI
 102439e:	f383 8812 	msr	BASEPRI_MAX, r3
 10243a2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 10243a6:	4814      	ldr	r0, [pc, #80]	; (10243f8 <z_impl_k_poll+0x19c>)
 10243a8:	f7fc fe92 	bl	10210d0 <z_spin_lock_valid>
 10243ac:	2800      	cmp	r0, #0
 10243ae:	d0a9      	beq.n	1024304 <z_impl_k_poll+0xa8>
	z_spin_lock_set_owner(l);
 10243b0:	4811      	ldr	r0, [pc, #68]	; (10243f8 <z_impl_k_poll+0x19c>)
 10243b2:	f7fc fea9 	bl	1021108 <z_spin_lock_set_owner>
	clear_event_registrations(events, events_registered, key);
 10243b6:	4628      	mov	r0, r5
 10243b8:	4632      	mov	r2, r6
 10243ba:	4649      	mov	r1, r9
 10243bc:	f7ff fe48 	bl	1024050 <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 10243c0:	480d      	ldr	r0, [pc, #52]	; (10243f8 <z_impl_k_poll+0x19c>)
 10243c2:	f7fc fe93 	bl	10210ec <z_spin_unlock_valid>
 10243c6:	2800      	cmp	r0, #0
 10243c8:	d0b8      	beq.n	102433c <z_impl_k_poll+0xe0>
	__asm__ volatile(
 10243ca:	f386 8811 	msr	BASEPRI, r6
 10243ce:	f3bf 8f6f 	isb	sy
	return swap_rc;
 10243d2:	e7c3      	b.n	102435c <z_impl_k_poll+0x100>
 10243d4:	210080cc 	.word	0x210080cc
 10243d8:	0102f8a2 	.word	0x0102f8a2
 10243dc:	0102fd19 	.word	0x0102fd19
 10243e0:	0102b695 	.word	0x0102b695
 10243e4:	0102ee84 	.word	0x0102ee84
 10243e8:	0102fed8 	.word	0x0102fed8
 10243ec:	0102feee 	.word	0x0102feee
 10243f0:	0102fefd 	.word	0x0102fefd
 10243f4:	0102ff0d 	.word	0x0102ff0d
 10243f8:	21008120 	.word	0x21008120
 10243fc:	0102bd8a 	.word	0x0102bd8a
 1024400:	0102bde3 	.word	0x0102bde3
 1024404:	0102bdf8 	.word	0x0102bdf8
 1024408:	0102bdb7 	.word	0x0102bdb7
 102440c:	0102bdce 	.word	0x0102bdce
 1024410:	21000ac0 	.word	0x21000ac0

01024414 <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *sig, int result)
{
 1024414:	b570      	push	{r4, r5, r6, lr}
 1024416:	4604      	mov	r4, r0
 1024418:	460d      	mov	r5, r1
	__asm__ volatile(
 102441a:	f04f 0320 	mov.w	r3, #32
 102441e:	f3ef 8611 	mrs	r6, BASEPRI
 1024422:	f383 8812 	msr	BASEPRI_MAX, r3
 1024426:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 102442a:	4820      	ldr	r0, [pc, #128]	; (10244ac <z_impl_k_poll_signal_raise+0x98>)
 102442c:	f7fc fe50 	bl	10210d0 <z_spin_lock_valid>
 1024430:	b968      	cbnz	r0, 102444e <z_impl_k_poll_signal_raise+0x3a>
 1024432:	2394      	movs	r3, #148	; 0x94
 1024434:	4a1e      	ldr	r2, [pc, #120]	; (10244b0 <z_impl_k_poll_signal_raise+0x9c>)
 1024436:	491f      	ldr	r1, [pc, #124]	; (10244b4 <z_impl_k_poll_signal_raise+0xa0>)
 1024438:	481f      	ldr	r0, [pc, #124]	; (10244b8 <z_impl_k_poll_signal_raise+0xa4>)
 102443a:	f000 fbcc 	bl	1024bd6 <assert_print>
 102443e:	491b      	ldr	r1, [pc, #108]	; (10244ac <z_impl_k_poll_signal_raise+0x98>)
 1024440:	481e      	ldr	r0, [pc, #120]	; (10244bc <z_impl_k_poll_signal_raise+0xa8>)
 1024442:	f000 fbc8 	bl	1024bd6 <assert_print>
 1024446:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1024448:	4819      	ldr	r0, [pc, #100]	; (10244b0 <z_impl_k_poll_signal_raise+0x9c>)
 102444a:	f000 fbbd 	bl	1024bc8 <assert_post_action>
	z_spin_lock_set_owner(l);
 102444e:	4817      	ldr	r0, [pc, #92]	; (10244ac <z_impl_k_poll_signal_raise+0x98>)
 1024450:	f7fc fe5a 	bl	1021108 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	sig->result = result;
	sig->signaled = 1U;
 1024454:	2101      	movs	r1, #1
	return list->head == list;
 1024456:	6820      	ldr	r0, [r4, #0]
	sig->result = result;
 1024458:	60e5      	str	r5, [r4, #12]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
 102445a:	4284      	cmp	r4, r0
	sig->signaled = 1U;
 102445c:	60a1      	str	r1, [r4, #8]
 102445e:	d10f      	bne.n	1024480 <z_impl_k_poll_signal_raise+0x6c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 1024460:	4812      	ldr	r0, [pc, #72]	; (10244ac <z_impl_k_poll_signal_raise+0x98>)
 1024462:	f7fc fe43 	bl	10210ec <z_spin_unlock_valid>
 1024466:	b9d8      	cbnz	r0, 10244a0 <z_impl_k_poll_signal_raise+0x8c>
 1024468:	23c2      	movs	r3, #194	; 0xc2
 102446a:	4a11      	ldr	r2, [pc, #68]	; (10244b0 <z_impl_k_poll_signal_raise+0x9c>)
 102446c:	4914      	ldr	r1, [pc, #80]	; (10244c0 <z_impl_k_poll_signal_raise+0xac>)
 102446e:	4812      	ldr	r0, [pc, #72]	; (10244b8 <z_impl_k_poll_signal_raise+0xa4>)
 1024470:	f000 fbb1 	bl	1024bd6 <assert_print>
 1024474:	490d      	ldr	r1, [pc, #52]	; (10244ac <z_impl_k_poll_signal_raise+0x98>)
 1024476:	4813      	ldr	r0, [pc, #76]	; (10244c4 <z_impl_k_poll_signal_raise+0xb0>)
 1024478:	f000 fbad 	bl	1024bd6 <assert_print>
 102447c:	21c2      	movs	r1, #194	; 0xc2
 102447e:	e7e3      	b.n	1024448 <z_impl_k_poll_signal_raise+0x34>
	sys_dnode_t *const next = node->next;
 1024480:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
 1024484:	6013      	str	r3, [r2, #0]
	next->prev = prev;
 1024486:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 1024488:	2300      	movs	r3, #0
	node->prev = NULL;
 102448a:	e9c0 3300 	strd	r3, r3, [r0]
		SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, 0);

		return 0;
	}

	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
 102448e:	f005 f86d 	bl	102956c <signal_poll_event>

	SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, rc);

	z_reschedule(&lock, key);
 1024492:	4631      	mov	r1, r6
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
 1024494:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
 1024496:	4805      	ldr	r0, [pc, #20]	; (10244ac <z_impl_k_poll_signal_raise+0x98>)
 1024498:	f7fe f8c6 	bl	1022628 <z_reschedule>
	return rc;
}
 102449c:	4620      	mov	r0, r4
 102449e:	bd70      	pop	{r4, r5, r6, pc}
	__asm__ volatile(
 10244a0:	f386 8811 	msr	BASEPRI, r6
 10244a4:	f3bf 8f6f 	isb	sy
		return 0;
 10244a8:	2400      	movs	r4, #0
 10244aa:	e7f7      	b.n	102449c <z_impl_k_poll_signal_raise+0x88>
 10244ac:	21008120 	.word	0x21008120
 10244b0:	0102bd8a 	.word	0x0102bd8a
 10244b4:	0102bde3 	.word	0x0102bde3
 10244b8:	0102b695 	.word	0x0102b695
 10244bc:	0102bdf8 	.word	0x0102bdf8
 10244c0:	0102bdb7 	.word	0x0102bdb7
 10244c4:	0102bdce 	.word	0x0102bdce

010244c8 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
 10244c8:	b573      	push	{r0, r1, r4, r5, r6, lr}
 10244ca:	4606      	mov	r6, r0
 10244cc:	460d      	mov	r5, r1
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
 10244ce:	f004 fed8 	bl	1029282 <k_is_in_isr>
 10244d2:	bb20      	cbnz	r0, 102451e <z_thread_aligned_alloc+0x56>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
 10244d4:	4b14      	ldr	r3, [pc, #80]	; (1024528 <z_thread_aligned_alloc+0x60>)
 10244d6:	689b      	ldr	r3, [r3, #8]
 10244d8:	6f5c      	ldr	r4, [r3, #116]	; 0x74
	}

	if (heap != NULL) {
 10244da:	b30c      	cbz	r4, 1024520 <z_thread_aligned_alloc+0x58>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
 10244dc:	1d2a      	adds	r2, r5, #4
 10244de:	d21e      	bcs.n	102451e <z_thread_aligned_alloc+0x56>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
 10244e0:	2000      	movs	r0, #0
 10244e2:	2100      	movs	r1, #0
 10244e4:	e9cd 0100 	strd	r0, r1, [sp]
 10244e8:	4620      	mov	r0, r4
 10244ea:	f046 0104 	orr.w	r1, r6, #4
 10244ee:	f7fc faeb 	bl	1020ac8 <k_heap_aligned_alloc>
	if (mem == NULL) {
 10244f2:	b1a0      	cbz	r0, 102451e <z_thread_aligned_alloc+0x56>
	*heap_ref = heap;
 10244f4:	6004      	str	r4, [r0, #0]
	mem = ++heap_ref;
 10244f6:	1d04      	adds	r4, r0, #4
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
 10244f8:	b196      	cbz	r6, 1024520 <z_thread_aligned_alloc+0x58>
 10244fa:	1e73      	subs	r3, r6, #1
 10244fc:	421c      	tst	r4, r3
 10244fe:	d00f      	beq.n	1024520 <z_thread_aligned_alloc+0x58>
 1024500:	2325      	movs	r3, #37	; 0x25
 1024502:	4a0a      	ldr	r2, [pc, #40]	; (102452c <z_thread_aligned_alloc+0x64>)
 1024504:	490a      	ldr	r1, [pc, #40]	; (1024530 <z_thread_aligned_alloc+0x68>)
 1024506:	480b      	ldr	r0, [pc, #44]	; (1024534 <z_thread_aligned_alloc+0x6c>)
 1024508:	f000 fb65 	bl	1024bd6 <assert_print>
 102450c:	4621      	mov	r1, r4
 102450e:	480a      	ldr	r0, [pc, #40]	; (1024538 <z_thread_aligned_alloc+0x70>)
 1024510:	4632      	mov	r2, r6
 1024512:	f000 fb60 	bl	1024bd6 <assert_print>
 1024516:	2125      	movs	r1, #37	; 0x25
 1024518:	4804      	ldr	r0, [pc, #16]	; (102452c <z_thread_aligned_alloc+0x64>)
 102451a:	f000 fb55 	bl	1024bc8 <assert_post_action>
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
 102451e:	2400      	movs	r4, #0
	}

	return ret;
}
 1024520:	4620      	mov	r0, r4
 1024522:	b002      	add	sp, #8
 1024524:	bd70      	pop	{r4, r5, r6, pc}
 1024526:	bf00      	nop
 1024528:	210080cc 	.word	0x210080cc
 102452c:	0102ff1a 	.word	0x0102ff1a
 1024530:	0102ff3e 	.word	0x0102ff3e
 1024534:	0102b695 	.word	0x0102b695
 1024538:	0102ff70 	.word	0x0102ff70

0102453c <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
 102453c:	4801      	ldr	r0, [pc, #4]	; (1024544 <boot_banner+0x8>)
 102453e:	f000 b942 	b.w	10247c6 <printk>
 1024542:	bf00      	nop
 1024544:	0102ff98 	.word	0x0102ff98

01024548 <z_log_msg_static_create>:
 1024548:	f7e0 b8de 	b.w	1004708 <z_impl_z_log_msg_static_create>

0102454c <net2app_send_nus>:
{
 102454c:	b510      	push	{r4, lr}
	buf[0] = NET2APP_BT_NUS_RECV;
 102454e:	2304      	movs	r3, #4
{
 1024550:	460c      	mov	r4, r1
 1024552:	b0fc      	sub	sp, #496	; 0x1f0
	memcpy(&buf[1], data, len);
 1024554:	460a      	mov	r2, r1
 1024556:	4601      	mov	r1, r0
 1024558:	f10d 0001 	add.w	r0, sp, #1
	buf[0] = NET2APP_BT_NUS_RECV;
 102455c:	f88d 3000 	strb.w	r3, [sp]
	memcpy(&buf[1], data, len);
 1024560:	f002 fa08 	bl	1026974 <memcpy>
	return nrfx_ipc_send(buf, len+1);	
 1024564:	1c61      	adds	r1, r4, #1
 1024566:	4668      	mov	r0, sp
 1024568:	b289      	uxth	r1, r1
 102456a:	f7dd fd9b 	bl	10020a4 <nrfx_ipc_send>
}
 102456e:	b07c      	add	sp, #496	; 0x1f0
 1024570:	bd10      	pop	{r4, pc}

01024572 <net2app_send_conn_status>:
	data[0] = NET2APP_BT_CONN_STATUS;
 1024572:	2303      	movs	r3, #3
{
 1024574:	b507      	push	{r0, r1, r2, lr}
	return nrfx_ipc_send(data, sizeof(data));	
 1024576:	2102      	movs	r1, #2
	data[1] = connected;
 1024578:	f88d 0005 	strb.w	r0, [sp, #5]
	return nrfx_ipc_send(data, sizeof(data));	
 102457c:	a801      	add	r0, sp, #4
	data[0] = NET2APP_BT_CONN_STATUS;
 102457e:	f88d 3004 	strb.w	r3, [sp, #4]
	return nrfx_ipc_send(data, sizeof(data));	
 1024582:	f7dd fd8f 	bl	10020a4 <nrfx_ipc_send>
}
 1024586:	b003      	add	sp, #12
 1024588:	f85d fb04 	ldr.w	pc, [sp], #4

0102458c <net2app_bt_smp_send>:
{
 102458c:	b510      	push	{r4, lr}
	buf[0] = NET2APP_BT_SMP_SEND;
 102458e:	2305      	movs	r3, #5
{
 1024590:	460c      	mov	r4, r1
 1024592:	b0fc      	sub	sp, #496	; 0x1f0
	memcpy(&buf[1], data, len);
 1024594:	460a      	mov	r2, r1
 1024596:	4601      	mov	r1, r0
 1024598:	f10d 0001 	add.w	r0, sp, #1
	buf[0] = NET2APP_BT_SMP_SEND;
 102459c:	f88d 3000 	strb.w	r3, [sp]
	memcpy(&buf[1], data, len);
 10245a0:	f002 f9e8 	bl	1026974 <memcpy>
	return nrfx_ipc_send(buf, len+1);	
 10245a4:	1c61      	adds	r1, r4, #1
 10245a6:	4668      	mov	r0, sp
 10245a8:	b289      	uxth	r1, r1
 10245aa:	f7dd fd7b 	bl	10020a4 <nrfx_ipc_send>
}
 10245ae:	b07c      	add	sp, #496	; 0x1f0
 10245b0:	bd10      	pop	{r4, pc}

010245b2 <net2app_test>:
	if (len > 249) len = 249;
 10245b2:	29f9      	cmp	r1, #249	; 0xf9
 10245b4:	bf28      	it	cs
 10245b6:	21f9      	movcs	r1, #249	; 0xf9
{
 10245b8:	b510      	push	{r4, lr}
	buf[0] = NET2APP_TEST;
 10245ba:	2301      	movs	r3, #1
	if (len > 249) len = 249;
 10245bc:	460c      	mov	r4, r1
{
 10245be:	b0c0      	sub	sp, #256	; 0x100
	memcpy(&buf[1], data, len);
 10245c0:	460a      	mov	r2, r1
 10245c2:	4601      	mov	r1, r0
 10245c4:	f10d 0005 	add.w	r0, sp, #5
	buf[0] = NET2APP_TEST;
 10245c8:	f88d 3004 	strb.w	r3, [sp, #4]
	memcpy(&buf[1], data, len);
 10245cc:	f002 f9d2 	bl	1026974 <memcpy>
	return nrfx_ipc_send(buf, len+1);	
 10245d0:	1c61      	adds	r1, r4, #1
 10245d2:	b289      	uxth	r1, r1
 10245d4:	a801      	add	r0, sp, #4
 10245d6:	f7dd fd65 	bl	10020a4 <nrfx_ipc_send>
}
 10245da:	b040      	add	sp, #256	; 0x100
 10245dc:	bd10      	pop	{r4, pc}

010245de <nrfx_ipc_handler>:
	if (event_mask == CH_NO_RECEIVE) {
 10245de:	b908      	cbnz	r0, 10245e4 <nrfx_ipc_handler+0x6>
 10245e0:	f7dd bd20 	b.w	1002024 <nrfx_ipc_handler.part.0>
}
 10245e4:	4770      	bx	lr

010245e6 <smp_bt_ccc_changed>:
	net2app_send_bt_mtu();
 10245e6:	f7dd bc97 	b.w	1001f18 <net2app_send_bt_mtu>

010245ea <smp_bt_chr_write>:
{
 10245ea:	b510      	push	{r4, lr}
 10245ec:	461c      	mov	r4, r3
	net2app_bt_smp_send((uint8_t *)buf, len);
 10245ee:	4619      	mov	r1, r3
 10245f0:	4610      	mov	r0, r2
 10245f2:	f7ff ffcb 	bl	102458c <net2app_bt_smp_send>
}
 10245f6:	4620      	mov	r0, r4
 10245f8:	bd10      	pop	{r4, pc}

010245fa <cbpprintf_external>:
{
 10245fa:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 10245fe:	4606      	mov	r6, r0
 1024600:	460d      	mov	r5, r1
 1024602:	4617      	mov	r7, r2
	if (buf == NULL) {
 1024604:	4698      	mov	r8, r3
 1024606:	b32b      	cbz	r3, 1024654 <cbpprintf_external+0x5a>
	for (i = 0; i < s_nbr; i++) {
 1024608:	f04f 0a00 	mov.w	sl, #0
	args_size = hdr->hdr.desc.len * sizeof(int);
 102460c:	f898 4000 	ldrb.w	r4, [r8]
	s_nbr     = hdr->hdr.desc.str_cnt;
 1024610:	f893 9001 	ldrb.w	r9, [r3, #1]
	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
 1024614:	78db      	ldrb	r3, [r3, #3]
	args_size = hdr->hdr.desc.len * sizeof(int);
 1024616:	00a4      	lsls	r4, r4, #2
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
 1024618:	eb04 0443 	add.w	r4, r4, r3, lsl #1
	ros_nbr   = hdr->hdr.desc.ro_str_cnt;
 102461c:	f898 3002 	ldrb.w	r3, [r8, #2]
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
 1024620:	441c      	add	r4, r3
 1024622:	4444      	add	r4, r8
	for (i = 0; i < s_nbr; i++) {
 1024624:	45ca      	cmp	sl, r9
 1024626:	d309      	bcc.n	102463c <cbpprintf_external+0x42>
	return formatter(out, ctx, fmt, u.ap);
 1024628:	4639      	mov	r1, r7
 102462a:	4630      	mov	r0, r6
 102462c:	46ac      	mov	ip, r5
 102462e:	f8d8 2004 	ldr.w	r2, [r8, #4]
 1024632:	f108 0308 	add.w	r3, r8, #8
}
 1024636:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return formatter(out, ctx, fmt, u.ap);
 102463a:	4760      	bx	ip
		s_idx = *(uint8_t *)s++;
 102463c:	f814 3b01 	ldrb.w	r3, [r4], #1
	for (i = 0; i < s_nbr; i++) {
 1024640:	f10a 0a01 	add.w	sl, sl, #1
		s += strlen(s) + 1;
 1024644:	4620      	mov	r0, r4
		*ps = s;
 1024646:	f848 4023 	str.w	r4, [r8, r3, lsl #2]
		s += strlen(s) + 1;
 102464a:	f002 f954 	bl	10268f6 <strlen>
 102464e:	3001      	adds	r0, #1
 1024650:	4404      	add	r4, r0
	for (i = 0; i < s_nbr; i++) {
 1024652:	e7e7      	b.n	1024624 <cbpprintf_external+0x2a>
}
 1024654:	f06f 0015 	mvn.w	r0, #21
 1024658:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0102465c <is_ptr>:
{
 102465c:	b570      	push	{r4, r5, r6, lr}
	int cnt = 0;
 102465e:	2500      	movs	r5, #0
{
 1024660:	4602      	mov	r2, r0
	bool mod = false;
 1024662:	4628      	mov	r0, r5
	while ((c = *fmt++) != '\0') {
 1024664:	4614      	mov	r4, r2
 1024666:	f814 3b01 	ldrb.w	r3, [r4], #1
 102466a:	b90b      	cbnz	r3, 1024670 <is_ptr+0x14>
					return false;
 102466c:	4618      	mov	r0, r3
 102466e:	e009      	b.n	1024684 <is_ptr+0x28>
		if (mod) {
 1024670:	b198      	cbz	r0, 102469a <is_ptr+0x3e>
			if (cnt == n) {
 1024672:	428d      	cmp	r5, r1
 1024674:	d107      	bne.n	1024686 <is_ptr+0x2a>
				if (c == 'p') {
 1024676:	2b70      	cmp	r3, #112	; 0x70
 1024678:	d004      	beq.n	1024684 <is_ptr+0x28>
				} else if (is_fmt_spec(c)) {
 102467a:	f1a3 0240 	sub.w	r2, r3, #64	; 0x40
 102467e:	2a3a      	cmp	r2, #58	; 0x3a
 1024680:	d80b      	bhi.n	102469a <is_ptr+0x3e>
					return false;
 1024682:	2000      	movs	r0, #0
}
 1024684:	bd70      	pop	{r4, r5, r6, pc}
			} else if (is_fmt_spec(c)) {
 1024686:	f1a3 0640 	sub.w	r6, r3, #64	; 0x40
 102468a:	2e3a      	cmp	r6, #58	; 0x3a
 102468c:	d805      	bhi.n	102469a <is_ptr+0x3e>
	while ((c = *fmt++) != '\0') {
 102468e:	7853      	ldrb	r3, [r2, #1]
				cnt++;
 1024690:	3501      	adds	r5, #1
	while ((c = *fmt++) != '\0') {
 1024692:	1c94      	adds	r4, r2, #2
 1024694:	2b00      	cmp	r3, #0
 1024696:	d0e9      	beq.n	102466c <is_ptr+0x10>
 1024698:	2000      	movs	r0, #0
		if (c == '%') {
 102469a:	2b25      	cmp	r3, #37	; 0x25
	while ((c = *fmt++) != '\0') {
 102469c:	4622      	mov	r2, r4
			mod = !mod;
 102469e:	bf08      	it	eq
 10246a0:	f080 0001 	eoreq.w	r0, r0, #1
 10246a4:	e7de      	b.n	1024664 <is_ptr+0x8>

010246a6 <u8_to_dec>:
 */

#include <zephyr/sys/util.h>

uint8_t u8_to_dec(char *buf, uint8_t buflen, uint8_t value)
{
 10246a6:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t divisor = 100;
 10246a8:	2364      	movs	r3, #100	; 0x64
{
 10246aa:	4605      	mov	r5, r0
	uint8_t num_digits = 0;
	uint8_t digit;

	while (buflen > 0 && divisor > 0) {
 10246ac:	2604      	movs	r6, #4
	uint8_t num_digits = 0;
 10246ae:	2000      	movs	r0, #0
			buflen--;
			num_digits++;
		}

		value -= digit * divisor;
		divisor /= 10;
 10246b0:	270a      	movs	r7, #10
	while (buflen > 0 && divisor > 0) {
 10246b2:	b969      	cbnz	r1, 10246d0 <u8_to_dec+0x2a>
	if (buflen) {
		*buf = '\0';
	}

	return num_digits;
}
 10246b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (digit != 0 || divisor == 1 || num_digits != 0) {
 10246b6:	429a      	cmp	r2, r3
 10246b8:	fbb2 f4f3 	udiv	r4, r2, r3
 10246bc:	d20c      	bcs.n	10246d8 <u8_to_dec+0x32>
 10246be:	2b01      	cmp	r3, #1
 10246c0:	d00a      	beq.n	10246d8 <u8_to_dec+0x32>
 10246c2:	b948      	cbnz	r0, 10246d8 <u8_to_dec+0x32>
		value -= digit * divisor;
 10246c4:	fb03 2214 	mls	r2, r3, r4, r2
		divisor /= 10;
 10246c8:	240a      	movs	r4, #10
 10246ca:	fbb3 f3f4 	udiv	r3, r3, r4
 10246ce:	b2d2      	uxtb	r2, r2
	while (buflen > 0 && divisor > 0) {
 10246d0:	3e01      	subs	r6, #1
 10246d2:	d1f0      	bne.n	10246b6 <u8_to_dec+0x10>
		*buf = '\0';
 10246d4:	702e      	strb	r6, [r5, #0]
	return num_digits;
 10246d6:	e7ed      	b.n	10246b4 <u8_to_dec+0xe>
			*buf = (char)digit + '0';
 10246d8:	3430      	adds	r4, #48	; 0x30
 10246da:	f805 4b01 	strb.w	r4, [r5], #1
			buflen--;
 10246de:	fbb2 f4f3 	udiv	r4, r2, r3
 10246e2:	fb03 2214 	mls	r2, r3, r4, r2
		divisor /= 10;
 10246e6:	fbb3 f3f7 	udiv	r3, r3, r7
			buflen--;
 10246ea:	3901      	subs	r1, #1
			num_digits++;
 10246ec:	3001      	adds	r0, #1
			buflen--;
 10246ee:	b2c9      	uxtb	r1, r1
			num_digits++;
 10246f0:	b2c0      	uxtb	r0, r0
		value -= digit * divisor;
 10246f2:	b2d2      	uxtb	r2, r2
		divisor /= 10;
 10246f4:	b2db      	uxtb	r3, r3
 10246f6:	e7dc      	b.n	10246b2 <u8_to_dec+0xc>

010246f8 <char2hex>:
#include <errno.h>
#include <zephyr/sys/util.h>

int char2hex(char c, uint8_t *x)
{
	if (c >= '0' && c <= '9') {
 10246f8:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
 10246fc:	b2db      	uxtb	r3, r3
 10246fe:	2b09      	cmp	r3, #9
 1024700:	d802      	bhi.n	1024708 <char2hex+0x10>
		*x = c - 'A' + 10;
	} else {
		return -EINVAL;
	}

	return 0;
 1024702:	2000      	movs	r0, #0
		*x = c - '0';
 1024704:	700b      	strb	r3, [r1, #0]
 1024706:	4770      	bx	lr
	} else if (c >= 'a' && c <= 'f') {
 1024708:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
 102470c:	2b05      	cmp	r3, #5
 102470e:	d802      	bhi.n	1024716 <char2hex+0x1e>
		*x = c - 'a' + 10;
 1024710:	3857      	subs	r0, #87	; 0x57
		*x = c - 'A' + 10;
 1024712:	b2c3      	uxtb	r3, r0
 1024714:	e7f5      	b.n	1024702 <char2hex+0xa>
	} else if (c >= 'A' && c <= 'F') {
 1024716:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
 102471a:	2b05      	cmp	r3, #5
 102471c:	d801      	bhi.n	1024722 <char2hex+0x2a>
		*x = c - 'A' + 10;
 102471e:	3837      	subs	r0, #55	; 0x37
 1024720:	e7f7      	b.n	1024712 <char2hex+0x1a>
		return -EINVAL;
 1024722:	f06f 0015 	mvn.w	r0, #21
}
 1024726:	4770      	bx	lr

01024728 <hex2bin>:
	hex[2 * buflen] = '\0';
	return 2 * buflen;
}

size_t hex2bin(const char *hex, size_t hexlen, uint8_t *buf, size_t buflen)
{
 1024728:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 102472a:	4605      	mov	r5, r0
	uint8_t dec;

	if (buflen < hexlen / 2 + hexlen % 2) {
 102472c:	f001 0001 	and.w	r0, r1, #1
 1024730:	eb00 0651 	add.w	r6, r0, r1, lsr #1
 1024734:	429e      	cmp	r6, r3
 1024736:	ea4f 0751 	mov.w	r7, r1, lsr #1
 102473a:	d903      	bls.n	1024744 <hex2bin+0x1c>
		return 0;
 102473c:	2600      	movs	r6, #0
		}
		buf[i] += dec;
	}

	return hexlen / 2 + hexlen % 2;
}
 102473e:	4630      	mov	r0, r6
 1024740:	b003      	add	sp, #12
 1024742:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (hexlen % 2) {
 1024744:	b158      	cbz	r0, 102475e <hex2bin+0x36>
		if (char2hex(hex[0], &dec) < 0) {
 1024746:	7828      	ldrb	r0, [r5, #0]
 1024748:	f10d 0107 	add.w	r1, sp, #7
 102474c:	f7ff ffd4 	bl	10246f8 <char2hex>
 1024750:	2800      	cmp	r0, #0
 1024752:	dbf3      	blt.n	102473c <hex2bin+0x14>
		buf[0] = dec;
 1024754:	f89d 3007 	ldrb.w	r3, [sp, #7]
		hex++;
 1024758:	3501      	adds	r5, #1
		buf[0] = dec;
 102475a:	f802 3b01 	strb.w	r3, [r2], #1
	for (size_t i = 0; i < hexlen / 2; i++) {
 102475e:	3501      	adds	r5, #1
 1024760:	4417      	add	r7, r2
 1024762:	42ba      	cmp	r2, r7
 1024764:	d0eb      	beq.n	102473e <hex2bin+0x16>
		if (char2hex(hex[2 * i], &dec) < 0) {
 1024766:	f815 0c01 	ldrb.w	r0, [r5, #-1]
 102476a:	f10d 0107 	add.w	r1, sp, #7
 102476e:	f7ff ffc3 	bl	10246f8 <char2hex>
 1024772:	2800      	cmp	r0, #0
 1024774:	dbe2      	blt.n	102473c <hex2bin+0x14>
		buf[i] = dec << 4;
 1024776:	f89d 4007 	ldrb.w	r4, [sp, #7]
 102477a:	0124      	lsls	r4, r4, #4
 102477c:	b2e4      	uxtb	r4, r4
 102477e:	7014      	strb	r4, [r2, #0]
		if (char2hex(hex[2 * i + 1], &dec) < 0) {
 1024780:	f815 0b02 	ldrb.w	r0, [r5], #2
 1024784:	f7ff ffb8 	bl	10246f8 <char2hex>
 1024788:	2800      	cmp	r0, #0
 102478a:	dbd7      	blt.n	102473c <hex2bin+0x14>
		buf[i] += dec;
 102478c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 1024790:	441c      	add	r4, r3
 1024792:	f802 4b01 	strb.w	r4, [r2], #1
	for (size_t i = 0; i < hexlen / 2; i++) {
 1024796:	e7e4      	b.n	1024762 <hex2bin+0x3a>

01024798 <arch_printk_char_out>:
}
 1024798:	2000      	movs	r0, #0
 102479a:	4770      	bx	lr

0102479c <str_out>:
{
 102479c:	b530      	push	{r4, r5, lr}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
 102479e:	688a      	ldr	r2, [r1, #8]
 10247a0:	680c      	ldr	r4, [r1, #0]
		ctx->str[ctx->count++] = '\0';
 10247a2:	1c55      	adds	r5, r2, #1
	if (ctx->str == NULL || ctx->count >= ctx->max) {
 10247a4:	b114      	cbz	r4, 10247ac <str_out+0x10>
 10247a6:	684b      	ldr	r3, [r1, #4]
 10247a8:	4293      	cmp	r3, r2
 10247aa:	dc01      	bgt.n	10247b0 <str_out+0x14>
		ctx->count++;
 10247ac:	608d      	str	r5, [r1, #8]
}
 10247ae:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
 10247b0:	3b01      	subs	r3, #1
 10247b2:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
 10247b4:	bf08      	it	eq
 10247b6:	2200      	moveq	r2, #0
 10247b8:	608d      	str	r5, [r1, #8]
 10247ba:	bf0c      	ite	eq
 10247bc:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
 10247be:	54a0      	strbne	r0, [r4, r2]
 10247c0:	e7f5      	b.n	10247ae <str_out+0x12>

010247c2 <vprintk>:
		z_log_vprintk(fmt, ap);
 10247c2:	f000 baeb 	b.w	1024d9c <z_log_vprintk>

010247c6 <printk>:
{
 10247c6:	b40f      	push	{r0, r1, r2, r3}
 10247c8:	b507      	push	{r0, r1, r2, lr}
 10247ca:	a904      	add	r1, sp, #16
 10247cc:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
 10247d0:	9101      	str	r1, [sp, #4]
		z_log_vprintk(fmt, ap);
 10247d2:	f000 fae3 	bl	1024d9c <z_log_vprintk>
}
 10247d6:	b003      	add	sp, #12
 10247d8:	f85d eb04 	ldr.w	lr, [sp], #4
 10247dc:	b004      	add	sp, #16
 10247de:	4770      	bx	lr

010247e0 <snprintk>:
{
 10247e0:	b40c      	push	{r2, r3}
 10247e2:	b507      	push	{r0, r1, r2, lr}
 10247e4:	ab04      	add	r3, sp, #16
 10247e6:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
 10247ea:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
 10247ec:	f7de f96e 	bl	1002acc <vsnprintk>
}
 10247f0:	b003      	add	sp, #12
 10247f2:	f85d eb04 	ldr.w	lr, [sp], #4
 10247f6:	b002      	add	sp, #8
 10247f8:	4770      	bx	lr

010247fa <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
 10247fa:	4604      	mov	r4, r0
 10247fc:	b508      	push	{r3, lr}
 10247fe:	4608      	mov	r0, r1
 1024800:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
 1024802:	461a      	mov	r2, r3
 1024804:	47a0      	blx	r4
	return z_impl_z_current_get();
 1024806:	f7fe fe25 	bl	1023454 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
 102480a:	f7e1 ffa9 	bl	1006760 <z_impl_k_thread_abort>

0102480e <chunk_size>:
		return ((uint16_t *)cmem)[f];
 102480e:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
 1024812:	8840      	ldrh	r0, [r0, #2]
}
 1024814:	0840      	lsrs	r0, r0, #1
 1024816:	4770      	bx	lr

01024818 <free_list_add>:
{
 1024818:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 102481a:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
 102481c:	f7ff fff7 	bl	102480e <chunk_size>
	return 31 - __builtin_clz(usable_sz);
 1024820:	fab0 f080 	clz	r0, r0
 1024824:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
 1024828:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 102482c:	f8dc 6010 	ldr.w	r6, [ip, #16]
	void *cmem = &buf[c];
 1024830:	00ca      	lsls	r2, r1, #3
		((uint16_t *)cmem)[f] = val;
 1024832:	1d17      	adds	r7, r2, #4
{
 1024834:	460c      	mov	r4, r1
 1024836:	3206      	adds	r2, #6
 1024838:	b28d      	uxth	r5, r1
	if (b->next == 0U) {
 102483a:	b956      	cbnz	r6, 1024852 <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
 102483c:	2101      	movs	r1, #1
 102483e:	fa01 f000 	lsl.w	r0, r1, r0
 1024842:	68d9      	ldr	r1, [r3, #12]
 1024844:	4301      	orrs	r1, r0
 1024846:	60d9      	str	r1, [r3, #12]
		b->next = c;
 1024848:	f8cc 4010 	str.w	r4, [ip, #16]
 102484c:	53dd      	strh	r5, [r3, r7]
 102484e:	529d      	strh	r5, [r3, r2]
}
 1024850:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
 1024852:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
 1024854:	3104      	adds	r1, #4
 1024856:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
 1024858:	53d8      	strh	r0, [r3, r7]
 102485a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 102485e:	529e      	strh	r6, [r3, r2]
 1024860:	80c5      	strh	r5, [r0, #6]
 1024862:	525d      	strh	r5, [r3, r1]
 1024864:	e7f4      	b.n	1024850 <free_list_add+0x38>

01024866 <free_list_remove_bidx>:
{
 1024866:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
 1024868:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
 102486c:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
 102486e:	4299      	cmp	r1, r3
 1024870:	f102 0104 	add.w	r1, r2, #4
 1024874:	d10a      	bne.n	102488c <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
 1024876:	2301      	movs	r3, #1
 1024878:	fa03 f202 	lsl.w	r2, r3, r2
 102487c:	68c3      	ldr	r3, [r0, #12]
 102487e:	ea23 0302 	bic.w	r3, r3, r2
 1024882:	60c3      	str	r3, [r0, #12]
		b->next = 0;
 1024884:	2300      	movs	r3, #0
 1024886:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
 102488a:	bd10      	pop	{r4, pc}
 102488c:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
 102488e:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
 1024892:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
 1024896:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
 102489a:	80cb      	strh	r3, [r1, #6]
 102489c:	8082      	strh	r2, [r0, #4]
}
 102489e:	e7f4      	b.n	102488a <free_list_remove_bidx+0x24>

010248a0 <free_list_remove>:
{
 10248a0:	b508      	push	{r3, lr}
 10248a2:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
 10248a4:	f7ff ffb3 	bl	102480e <chunk_size>
	return 31 - __builtin_clz(usable_sz);
 10248a8:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
 10248ac:	4618      	mov	r0, r3
}
 10248ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		free_list_remove_bidx(h, c, bidx);
 10248b2:	f1c2 021f 	rsb	r2, r2, #31
 10248b6:	f7ff bfd6 	b.w	1024866 <free_list_remove_bidx>

010248ba <alloc_chunk>:
{
 10248ba:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 10248be:	fab1 f581 	clz	r5, r1
 10248c2:	f1c5 091f 	rsb	r9, r5, #31
	if (b->next) {
 10248c6:	eb00 0889 	add.w	r8, r0, r9, lsl #2
 10248ca:	f8d8 2010 	ldr.w	r2, [r8, #16]
{
 10248ce:	4603      	mov	r3, r0
 10248d0:	460e      	mov	r6, r1
	if (b->next) {
 10248d2:	b1c2      	cbz	r2, 1024906 <alloc_chunk+0x4c>
 10248d4:	2703      	movs	r7, #3
			chunkid_t c = b->next;
 10248d6:	f8d8 4010 	ldr.w	r4, [r8, #16]
			if (chunk_size(h, c) >= sz) {
 10248da:	4618      	mov	r0, r3
 10248dc:	4621      	mov	r1, r4
 10248de:	f7ff ff96 	bl	102480e <chunk_size>
 10248e2:	42b0      	cmp	r0, r6
 10248e4:	d306      	bcc.n	10248f4 <alloc_chunk+0x3a>
				free_list_remove_bidx(h, c, bi);
 10248e6:	464a      	mov	r2, r9
		free_list_remove_bidx(h, c, minbucket);
 10248e8:	4618      	mov	r0, r3
 10248ea:	f7ff ffbc 	bl	1024866 <free_list_remove_bidx>
}
 10248ee:	4620      	mov	r0, r4
 10248f0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
 10248f4:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
 10248f8:	88e0      	ldrh	r0, [r4, #6]
		} while (--i && b->next != first);
 10248fa:	3f01      	subs	r7, #1
			b->next = next_free_chunk(h, c);
 10248fc:	f8c8 0010 	str.w	r0, [r8, #16]
		} while (--i && b->next != first);
 1024900:	d001      	beq.n	1024906 <alloc_chunk+0x4c>
 1024902:	4282      	cmp	r2, r0
 1024904:	d1e7      	bne.n	10248d6 <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
 1024906:	f04f 34ff 	mov.w	r4, #4294967295
 102490a:	f1c5 0220 	rsb	r2, r5, #32
 102490e:	4094      	lsls	r4, r2
 1024910:	68da      	ldr	r2, [r3, #12]
	if (bmask != 0U) {
 1024912:	4014      	ands	r4, r2
 1024914:	d0eb      	beq.n	10248ee <alloc_chunk+0x34>
		int minbucket = __builtin_ctz(bmask);
 1024916:	fa94 f2a4 	rbit	r2, r4
 102491a:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
 102491e:	1d11      	adds	r1, r2, #4
 1024920:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
		free_list_remove_bidx(h, c, minbucket);
 1024924:	4621      	mov	r1, r4
 1024926:	e7df      	b.n	10248e8 <alloc_chunk+0x2e>

01024928 <merge_chunks>:
{
 1024928:	b538      	push	{r3, r4, r5, lr}
 102492a:	4603      	mov	r3, r0
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
 102492c:	f7ff ff6f 	bl	102480e <chunk_size>
{
 1024930:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
 1024932:	4604      	mov	r4, r0
 1024934:	4611      	mov	r1, r2
 1024936:	4618      	mov	r0, r3
 1024938:	f7ff ff69 	bl	102480e <chunk_size>
 102493c:	4404      	add	r4, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
 102493e:	0060      	lsls	r0, r4, #1
		((uint16_t *)cmem)[f] = val;
 1024940:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
 1024944:	8068      	strh	r0, [r5, #2]
	return c + chunk_size(h, c);
 1024946:	4618      	mov	r0, r3
 1024948:	f7ff ff61 	bl	102480e <chunk_size>
	void *cmem = &buf[c];
 102494c:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
 102494e:	f823 4031 	strh.w	r4, [r3, r1, lsl #3]
}
 1024952:	bd38      	pop	{r3, r4, r5, pc}

01024954 <split_chunks>:
{
 1024954:	b538      	push	{r3, r4, r5, lr}
 1024956:	460c      	mov	r4, r1
 1024958:	4603      	mov	r3, r0
	chunksz_t sz0 = chunk_size(h, lc);
 102495a:	f7ff ff58 	bl	102480e <chunk_size>
	chunksz_t rsz = sz0 - lsz;
 102495e:	1aa5      	subs	r5, r4, r2
	chunksz_t lsz = rc - lc;
 1024960:	1a51      	subs	r1, r2, r1
	chunksz_t rsz = sz0 - lsz;
 1024962:	4405      	add	r5, r0
 1024964:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
 1024968:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
 102496a:	8060      	strh	r0, [r4, #2]
 102496c:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
 1024970:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
 1024972:	8044      	strh	r4, [r0, #2]
 1024974:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
 1024978:	4618      	mov	r0, r3
 102497a:	4611      	mov	r1, r2
 102497c:	f7ff ff47 	bl	102480e <chunk_size>
	void *cmem = &buf[c];
 1024980:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
 1024982:	f823 5031 	strh.w	r5, [r3, r1, lsl #3]
}
 1024986:	bd38      	pop	{r3, r4, r5, pc}

01024988 <free_chunk>:
{
 1024988:	b538      	push	{r3, r4, r5, lr}
 102498a:	4605      	mov	r5, r0
	return c + chunk_size(h, c);
 102498c:	f7ff ff3f 	bl	102480e <chunk_size>
 1024990:	460c      	mov	r4, r1
 1024992:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
 1024994:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
 1024998:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
 102499a:	07da      	lsls	r2, r3, #31
 102499c:	d40a      	bmi.n	10249b4 <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
 102499e:	4628      	mov	r0, r5
 10249a0:	f7ff ff7e 	bl	10248a0 <free_list_remove>
	return c + chunk_size(h, c);
 10249a4:	4621      	mov	r1, r4
 10249a6:	4628      	mov	r0, r5
 10249a8:	f7ff ff31 	bl	102480e <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
 10249ac:	1822      	adds	r2, r4, r0
 10249ae:	4628      	mov	r0, r5
 10249b0:	f7ff ffba 	bl	1024928 <merge_chunks>
		return ((uint16_t *)cmem)[f];
 10249b4:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
 10249b8:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
 10249ba:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
 10249be:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
 10249c0:	07db      	lsls	r3, r3, #31
 10249c2:	d40c      	bmi.n	10249de <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
 10249c4:	4628      	mov	r0, r5
 10249c6:	f7ff ff6b 	bl	10248a0 <free_list_remove>
		return ((uint16_t *)cmem)[f];
 10249ca:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
 10249ce:	4622      	mov	r2, r4
 10249d0:	1a61      	subs	r1, r4, r1
 10249d2:	4628      	mov	r0, r5
 10249d4:	f7ff ffa8 	bl	1024928 <merge_chunks>
 10249d8:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
 10249dc:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
 10249de:	4621      	mov	r1, r4
 10249e0:	4628      	mov	r0, r5
}
 10249e2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
 10249e6:	f7ff bf17 	b.w	1024818 <free_list_add>

010249ea <sys_heap_alloc>:
{
 10249ea:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
 10249ec:	6805      	ldr	r5, [r0, #0]
	if (bytes == 0U || size_too_big(h, bytes)) {
 10249ee:	b909      	cbnz	r1, 10249f4 <sys_heap_alloc+0xa>
		return NULL;
 10249f0:	2000      	movs	r0, #0
}
 10249f2:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
 10249f4:	68ab      	ldr	r3, [r5, #8]
 10249f6:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 10249fa:	d9f9      	bls.n	10249f0 <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 10249fc:	310b      	adds	r1, #11
 10249fe:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
 1024a00:	4621      	mov	r1, r4
 1024a02:	4628      	mov	r0, r5
 1024a04:	f7ff ff59 	bl	10248ba <alloc_chunk>
	if (c == 0U) {
 1024a08:	4606      	mov	r6, r0
 1024a0a:	2800      	cmp	r0, #0
 1024a0c:	d0f0      	beq.n	10249f0 <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
 1024a0e:	4601      	mov	r1, r0
 1024a10:	4628      	mov	r0, r5
 1024a12:	f7ff fefc 	bl	102480e <chunk_size>
 1024a16:	42a0      	cmp	r0, r4
 1024a18:	d907      	bls.n	1024a2a <sys_heap_alloc+0x40>
		split_chunks(h, c, c + chunk_sz);
 1024a1a:	4628      	mov	r0, r5
 1024a1c:	1932      	adds	r2, r6, r4
 1024a1e:	f7ff ff99 	bl	1024954 <split_chunks>
		free_list_add(h, c + chunk_sz);
 1024a22:	4611      	mov	r1, r2
 1024a24:	4628      	mov	r0, r5
 1024a26:	f7ff fef7 	bl	1024818 <free_list_add>
	void *cmem = &buf[c];
 1024a2a:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
 1024a2e:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 1024a30:	8853      	ldrh	r3, [r2, #2]
 1024a32:	3004      	adds	r0, #4
 1024a34:	f043 0301 	orr.w	r3, r3, #1
 1024a38:	8053      	strh	r3, [r2, #2]
	return mem;
 1024a3a:	e7da      	b.n	10249f2 <sys_heap_alloc+0x8>

01024a3c <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1024a3c:	8b83      	ldrh	r3, [r0, #28]
	if ((state == ONOFF_STATE_OFF)
 1024a3e:	f013 0307 	ands.w	r3, r3, #7
 1024a42:	d105      	bne.n	1024a50 <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
 1024a44:	6803      	ldr	r3, [r0, #0]
		evt = EVT_START;
 1024a46:	2b00      	cmp	r3, #0
 1024a48:	bf0c      	ite	eq
 1024a4a:	2000      	moveq	r0, #0
 1024a4c:	2003      	movne	r0, #3
 1024a4e:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
 1024a50:	2b02      	cmp	r3, #2
 1024a52:	d105      	bne.n	1024a60 <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
 1024a54:	8bc0      	ldrh	r0, [r0, #30]
 1024a56:	fab0 f080 	clz	r0, r0
 1024a5a:	0940      	lsrs	r0, r0, #5
 1024a5c:	0080      	lsls	r0, r0, #2
 1024a5e:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
 1024a60:	2b01      	cmp	r3, #1
 1024a62:	d105      	bne.n	1024a70 <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
 1024a64:	6803      	ldr	r3, [r0, #0]
		evt = EVT_RESET;
 1024a66:	2b00      	cmp	r3, #0
 1024a68:	bf0c      	ite	eq
 1024a6a:	2000      	moveq	r0, #0
 1024a6c:	2005      	movne	r0, #5
 1024a6e:	4770      	bx	lr
	int evt = EVT_NOP;
 1024a70:	2000      	movs	r0, #0
}
 1024a72:	4770      	bx	lr

01024a74 <validate_args>:
{
 1024a74:	b510      	push	{r4, lr}
 1024a76:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
 1024a78:	b100      	cbz	r0, 1024a7c <validate_args+0x8>
 1024a7a:	b911      	cbnz	r1, 1024a82 <validate_args+0xe>
		return -EINVAL;
 1024a7c:	f06f 0015 	mvn.w	r0, #21
}
 1024a80:	bd10      	pop	{r4, pc}
	int rv = sys_notify_validate(&cli->notify);
 1024a82:	1d08      	adds	r0, r1, #4
 1024a84:	f000 f82f 	bl	1024ae6 <sys_notify_validate>
	if ((rv == 0)
 1024a88:	2800      	cmp	r0, #0
 1024a8a:	d1f9      	bne.n	1024a80 <validate_args+0xc>
	    && ((cli->notify.flags
 1024a8c:	68a3      	ldr	r3, [r4, #8]
 1024a8e:	2b03      	cmp	r3, #3
 1024a90:	d9f6      	bls.n	1024a80 <validate_args+0xc>
 1024a92:	e7f3      	b.n	1024a7c <validate_args+0x8>

01024a94 <notify_one>:
{
 1024a94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1024a98:	460d      	mov	r5, r1
 1024a9a:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
 1024a9c:	4619      	mov	r1, r3
 1024a9e:	1d28      	adds	r0, r5, #4
{
 1024aa0:	4690      	mov	r8, r2
 1024aa2:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
 1024aa4:	f7de fc82 	bl	10033ac <sys_notify_finalize>
	if (cb) {
 1024aa8:	4604      	mov	r4, r0
 1024aaa:	b138      	cbz	r0, 1024abc <notify_one+0x28>
		cb(mgr, cli, state, res);
 1024aac:	4633      	mov	r3, r6
 1024aae:	4642      	mov	r2, r8
 1024ab0:	4629      	mov	r1, r5
 1024ab2:	4638      	mov	r0, r7
 1024ab4:	46a4      	mov	ip, r4
}
 1024ab6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
 1024aba:	4760      	bx	ip
}
 1024abc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

01024ac0 <onoff_manager_init>:
{
 1024ac0:	b538      	push	{r3, r4, r5, lr}
 1024ac2:	460c      	mov	r4, r1
	if ((mgr == NULL)
 1024ac4:	4605      	mov	r5, r0
 1024ac6:	b158      	cbz	r0, 1024ae0 <onoff_manager_init+0x20>
	    || (transitions == NULL)
 1024ac8:	b151      	cbz	r1, 1024ae0 <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
 1024aca:	680b      	ldr	r3, [r1, #0]
 1024acc:	b143      	cbz	r3, 1024ae0 <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
 1024ace:	684b      	ldr	r3, [r1, #4]
 1024ad0:	b133      	cbz	r3, 1024ae0 <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
 1024ad2:	2220      	movs	r2, #32
 1024ad4:	2100      	movs	r1, #0
 1024ad6:	f001 ff58 	bl	102698a <memset>
	return 0;
 1024ada:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
 1024adc:	612c      	str	r4, [r5, #16]
}
 1024ade:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
 1024ae0:	f06f 0015 	mvn.w	r0, #21
 1024ae4:	e7fb      	b.n	1024ade <onoff_manager_init+0x1e>

01024ae6 <sys_notify_validate>:
	if (notify == NULL) {
 1024ae6:	4603      	mov	r3, r0
 1024ae8:	b140      	cbz	r0, 1024afc <sys_notify_validate+0x16>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
 1024aea:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
 1024aec:	f002 0203 	and.w	r2, r2, #3
	switch (sys_notify_get_method(notify)) {
 1024af0:	2a02      	cmp	r2, #2
 1024af2:	d006      	beq.n	1024b02 <sys_notify_validate+0x1c>
 1024af4:	2a03      	cmp	r2, #3
 1024af6:	d004      	beq.n	1024b02 <sys_notify_validate+0x1c>
 1024af8:	2a01      	cmp	r2, #1
 1024afa:	d005      	beq.n	1024b08 <sys_notify_validate+0x22>
 1024afc:	f06f 0015 	mvn.w	r0, #21
}
 1024b00:	4770      	bx	lr
		if (notify->method.signal == NULL) {
 1024b02:	681a      	ldr	r2, [r3, #0]
 1024b04:	2a00      	cmp	r2, #0
 1024b06:	d0f9      	beq.n	1024afc <sys_notify_validate+0x16>
		notify->result = 0;
 1024b08:	2000      	movs	r0, #0
 1024b0a:	6098      	str	r0, [r3, #8]
 1024b0c:	4770      	bx	lr

01024b0e <encode_uint>:
{
 1024b0e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1024b12:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier);
 1024b14:	78d3      	ldrb	r3, [r2, #3]
{
 1024b16:	4680      	mov	r8, r0
	switch (specifier) {
 1024b18:	2b6f      	cmp	r3, #111	; 0x6f
{
 1024b1a:	460f      	mov	r7, r1
 1024b1c:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
 1024b1e:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
 1024b22:	d029      	beq.n	1024b78 <encode_uint+0x6a>
 1024b24:	d824      	bhi.n	1024b70 <encode_uint+0x62>
		return 10;
 1024b26:	2b58      	cmp	r3, #88	; 0x58
 1024b28:	bf0c      	ite	eq
 1024b2a:	2610      	moveq	r6, #16
 1024b2c:	260a      	movne	r6, #10
	char *bp = bps + (bpe - bps);
 1024b2e:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
 1024b32:	4632      	mov	r2, r6
 1024b34:	2300      	movs	r3, #0
 1024b36:	4640      	mov	r0, r8
 1024b38:	4639      	mov	r1, r7
 1024b3a:	f7db fabd 	bl	10000b8 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
 1024b3e:	2a09      	cmp	r2, #9
 1024b40:	b2d4      	uxtb	r4, r2
 1024b42:	d81e      	bhi.n	1024b82 <encode_uint+0x74>
 1024b44:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
 1024b46:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
 1024b48:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
 1024b4a:	f177 0700 	sbcs.w	r7, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
 1024b4e:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
 1024b52:	d301      	bcc.n	1024b58 <encode_uint+0x4a>
 1024b54:	45d1      	cmp	r9, sl
 1024b56:	d811      	bhi.n	1024b7c <encode_uint+0x6e>
	if (conv->flag_hash) {
 1024b58:	782b      	ldrb	r3, [r5, #0]
 1024b5a:	069b      	lsls	r3, r3, #26
 1024b5c:	d505      	bpl.n	1024b6a <encode_uint+0x5c>
		if (radix == 8) {
 1024b5e:	2e08      	cmp	r6, #8
 1024b60:	d115      	bne.n	1024b8e <encode_uint+0x80>
			conv->altform_0 = true;
 1024b62:	78ab      	ldrb	r3, [r5, #2]
 1024b64:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
 1024b68:	70ab      	strb	r3, [r5, #2]
}
 1024b6a:	4648      	mov	r0, r9
 1024b6c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
 1024b70:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 10;
 1024b74:	2b70      	cmp	r3, #112	; 0x70
 1024b76:	e7d7      	b.n	1024b28 <encode_uint+0x1a>
	switch (specifier) {
 1024b78:	2608      	movs	r6, #8
 1024b7a:	e7d8      	b.n	1024b2e <encode_uint+0x20>
		value /= radix;
 1024b7c:	4680      	mov	r8, r0
 1024b7e:	460f      	mov	r7, r1
 1024b80:	e7d7      	b.n	1024b32 <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
 1024b82:	f1bb 0f19 	cmp.w	fp, #25
 1024b86:	bf94      	ite	ls
 1024b88:	3437      	addls	r4, #55	; 0x37
 1024b8a:	3457      	addhi	r4, #87	; 0x57
 1024b8c:	e7db      	b.n	1024b46 <encode_uint+0x38>
		} else if (radix == 16) {
 1024b8e:	2e10      	cmp	r6, #16
 1024b90:	d1eb      	bne.n	1024b6a <encode_uint+0x5c>
			conv->altform_0c = true;
 1024b92:	78ab      	ldrb	r3, [r5, #2]
 1024b94:	f043 0310 	orr.w	r3, r3, #16
 1024b98:	e7e6      	b.n	1024b68 <encode_uint+0x5a>

01024b9a <outs>:
{
 1024b9a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1024b9e:	4607      	mov	r7, r0
 1024ba0:	4688      	mov	r8, r1
 1024ba2:	4615      	mov	r5, r2
 1024ba4:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 1024ba6:	4614      	mov	r4, r2
 1024ba8:	42b4      	cmp	r4, r6
 1024baa:	d305      	bcc.n	1024bb8 <outs+0x1e>
 1024bac:	b10e      	cbz	r6, 1024bb2 <outs+0x18>
	return (int)count;
 1024bae:	1b60      	subs	r0, r4, r5
 1024bb0:	e008      	b.n	1024bc4 <outs+0x2a>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 1024bb2:	7823      	ldrb	r3, [r4, #0]
 1024bb4:	2b00      	cmp	r3, #0
 1024bb6:	d0fa      	beq.n	1024bae <outs+0x14>
		int rc = out((int)*sp++, ctx);
 1024bb8:	4641      	mov	r1, r8
 1024bba:	f814 0b01 	ldrb.w	r0, [r4], #1
 1024bbe:	47b8      	blx	r7
		if (rc < 0) {
 1024bc0:	2800      	cmp	r0, #0
 1024bc2:	daf1      	bge.n	1024ba8 <outs+0xe>
}
 1024bc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

01024bc8 <assert_post_action>:
	if (k_is_user_context()) {
		k_oops();
	}
#endif

	k_panic();
 1024bc8:	4040      	eors	r0, r0
 1024bca:	f380 8811 	msr	BASEPRI, r0
 1024bce:	f04f 0004 	mov.w	r0, #4
 1024bd2:	df02      	svc	2
}
 1024bd4:	4770      	bx	lr

01024bd6 <assert_print>:

void assert_print(const char *fmt, ...)
{
 1024bd6:	b40f      	push	{r0, r1, r2, r3}
 1024bd8:	b507      	push	{r0, r1, r2, lr}
 1024bda:	a904      	add	r1, sp, #16
 1024bdc:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
 1024be0:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
 1024be2:	f7ff fdee 	bl	10247c2 <vprintk>

	va_end(ap);
}
 1024be6:	b003      	add	sp, #12
 1024be8:	f85d eb04 	ldr.w	lr, [sp], #4
 1024bec:	b004      	add	sp, #16
 1024bee:	4770      	bx	lr

01024bf0 <free_space>:
	if (buffer->rd_idx > buffer->tmp_wr_idx) {
 1024bf0:	68c3      	ldr	r3, [r0, #12]
 1024bf2:	6802      	ldr	r2, [r0, #0]
 1024bf4:	4293      	cmp	r3, r2
 1024bf6:	d904      	bls.n	1024c02 <free_space+0x12>
		*res =  buffer->rd_idx - buffer->tmp_wr_idx - 1;
 1024bf8:	3b01      	subs	r3, #1
 1024bfa:	1a9a      	subs	r2, r3, r2
		return false;
 1024bfc:	2000      	movs	r0, #0
		*res = buffer->size - buffer->tmp_wr_idx - 1;
 1024bfe:	600a      	str	r2, [r1, #0]
}
 1024c00:	4770      	bx	lr
		*res = buffer->size - buffer->tmp_wr_idx - 1;
 1024c02:	6a40      	ldr	r0, [r0, #36]	; 0x24
	} else if (!buffer->rd_idx) {
 1024c04:	b913      	cbnz	r3, 1024c0c <free_space+0x1c>
		*res = buffer->size - buffer->tmp_wr_idx - 1;
 1024c06:	3801      	subs	r0, #1
 1024c08:	1a82      	subs	r2, r0, r2
		return false;
 1024c0a:	e7f7      	b.n	1024bfc <free_space+0xc>
	*res = buffer->size - buffer->tmp_wr_idx;
 1024c0c:	1a82      	subs	r2, r0, r2
	return true;
 1024c0e:	2001      	movs	r0, #1
 1024c10:	e7f5      	b.n	1024bfe <free_space+0xe>

01024c12 <get_usage>:
{
 1024c12:	b513      	push	{r0, r1, r4, lr}
	if (free_space(buffer, &f)) {
 1024c14:	a901      	add	r1, sp, #4
{
 1024c16:	4604      	mov	r4, r0
	if (free_space(buffer, &f)) {
 1024c18:	f7ff ffea 	bl	1024bf0 <free_space>
 1024c1c:	b120      	cbz	r0, 1024c28 <get_usage+0x16>
		f += (buffer->rd_idx - 1);
 1024c1e:	9b01      	ldr	r3, [sp, #4]
 1024c20:	68e2      	ldr	r2, [r4, #12]
 1024c22:	3b01      	subs	r3, #1
 1024c24:	4413      	add	r3, r2
 1024c26:	9301      	str	r3, [sp, #4]
	return buffer->size - 1 - f;
 1024c28:	6a60      	ldr	r0, [r4, #36]	; 0x24
 1024c2a:	9b01      	ldr	r3, [sp, #4]
 1024c2c:	1ac0      	subs	r0, r0, r3
}
 1024c2e:	3801      	subs	r0, #1
 1024c30:	b002      	add	sp, #8
 1024c32:	bd10      	pop	{r4, pc}

01024c34 <idx_inc>:
{
 1024c34:	b510      	push	{r4, lr}
 1024c36:	4604      	mov	r4, r0
	uint32_t i = idx + val;
 1024c38:	1888      	adds	r0, r1, r2
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
 1024c3a:	6922      	ldr	r2, [r4, #16]
		return i & (buffer->size - 1);
 1024c3c:	6a63      	ldr	r3, [r4, #36]	; 0x24
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
 1024c3e:	07d2      	lsls	r2, r2, #31
 1024c40:	d502      	bpl.n	1024c48 <idx_inc+0x14>
		return i & (buffer->size - 1);
 1024c42:	3b01      	subs	r3, #1
 1024c44:	4018      	ands	r0, r3
}
 1024c46:	bd10      	pop	{r4, pc}
	return (i >= buffer->size) ? i - buffer->size : i;
 1024c48:	4298      	cmp	r0, r3
 1024c4a:	bf28      	it	cs
 1024c4c:	1ac0      	subcs	r0, r0, r3
 1024c4e:	e7fa      	b.n	1024c46 <idx_inc+0x12>

01024c50 <add_skip_item>:
{
 1024c50:	b538      	push	{r3, r4, r5, lr}
 1024c52:	460d      	mov	r5, r1
	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
 1024c54:	6a02      	ldr	r2, [r0, #32]
	union mpsc_pbuf_generic skip = {
 1024c56:	008b      	lsls	r3, r1, #2
	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
 1024c58:	6801      	ldr	r1, [r0, #0]
	union mpsc_pbuf_generic skip = {
 1024c5a:	f043 0302 	orr.w	r3, r3, #2
	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
 1024c5e:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
 1024c62:	6801      	ldr	r1, [r0, #0]
 1024c64:	462a      	mov	r2, r5
{
 1024c66:	4604      	mov	r4, r0
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
 1024c68:	f7ff ffe4 	bl	1024c34 <idx_inc>
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
 1024c6c:	6861      	ldr	r1, [r4, #4]
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
 1024c6e:	6020      	str	r0, [r4, #0]
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
 1024c70:	462a      	mov	r2, r5
 1024c72:	4620      	mov	r0, r4
 1024c74:	f7ff ffde 	bl	1024c34 <idx_inc>
 1024c78:	6060      	str	r0, [r4, #4]
}
 1024c7a:	bd38      	pop	{r3, r4, r5, pc}

01024c7c <max_utilization_update>:
{
 1024c7c:	b538      	push	{r3, r4, r5, lr}
	if (!(buffer->flags & MPSC_PBUF_MAX_UTILIZATION)) {
 1024c7e:	6903      	ldr	r3, [r0, #16]
{
 1024c80:	4604      	mov	r4, r0
	if (!(buffer->flags & MPSC_PBUF_MAX_UTILIZATION)) {
 1024c82:	075b      	lsls	r3, r3, #29
 1024c84:	d506      	bpl.n	1024c94 <max_utilization_update+0x18>
	buffer->max_usage = MAX(buffer->max_usage, get_usage(buffer));
 1024c86:	6a85      	ldr	r5, [r0, #40]	; 0x28
 1024c88:	f7ff ffc3 	bl	1024c12 <get_usage>
 1024c8c:	4285      	cmp	r5, r0
 1024c8e:	bf2c      	ite	cs
 1024c90:	62a5      	strcs	r5, [r4, #40]	; 0x28
 1024c92:	62a0      	strcc	r0, [r4, #40]	; 0x28
}
 1024c94:	bd38      	pop	{r3, r4, r5, pc}

01024c96 <drop_item_locked>:
{
 1024c96:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1024c9a:	461f      	mov	r7, r3
	*user_packet = false;
 1024c9c:	2300      	movs	r3, #0
 1024c9e:	703b      	strb	r3, [r7, #0]
	item = (union mpsc_pbuf_generic *)&buffer->buf[buffer->rd_idx];
 1024ca0:	f8d0 a00c 	ldr.w	sl, [r0, #12]
 1024ca4:	f8d0 9020 	ldr.w	r9, [r0, #32]
{
 1024ca8:	4604      	mov	r4, r0
	if (item->hdr.busy && !item->hdr.valid) {
 1024caa:	f819 302a 	ldrb.w	r3, [r9, sl, lsl #2]
{
 1024cae:	468b      	mov	fp, r1
	if (item->hdr.busy && !item->hdr.valid) {
 1024cb0:	f003 0303 	and.w	r3, r3, #3
 1024cb4:	2b02      	cmp	r3, #2
{
 1024cb6:	4690      	mov	r8, r2
	item = (union mpsc_pbuf_generic *)&buffer->buf[buffer->rd_idx];
 1024cb8:	eb09 068a 	add.w	r6, r9, sl, lsl #2
	if (item->hdr.busy && !item->hdr.valid) {
 1024cbc:	d103      	bne.n	1024cc6 <drop_item_locked+0x30>
		return item->skip.len;
 1024cbe:	f859 502a 	ldr.w	r5, [r9, sl, lsl #2]
	rd_wlen = skip_wlen ? skip_wlen : buffer->get_wlen(item);
 1024cc2:	08ad      	lsrs	r5, r5, #2
 1024cc4:	d12e      	bne.n	1024d24 <drop_item_locked+0x8e>
 1024cc6:	4630      	mov	r0, r6
 1024cc8:	69e3      	ldr	r3, [r4, #28]
 1024cca:	4798      	blx	r3
 1024ccc:	4605      	mov	r5, r0
	} else if (allow_drop) {
 1024cce:	f1b8 0f00 	cmp.w	r8, #0
 1024cd2:	d038      	beq.n	1024d46 <drop_item_locked+0xb0>
		if (item->hdr.busy) {
 1024cd4:	f819 302a 	ldrb.w	r3, [r9, sl, lsl #2]
 1024cd8:	079b      	lsls	r3, r3, #30
 1024cda:	d531      	bpl.n	1024d40 <drop_item_locked+0xaa>
			add_skip_item(buffer, free_wlen + 1);
 1024cdc:	4620      	mov	r0, r4
 1024cde:	f10b 0101 	add.w	r1, fp, #1
 1024ce2:	f7ff ffb5 	bl	1024c50 <add_skip_item>
			buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, rd_wlen);
 1024ce6:	6861      	ldr	r1, [r4, #4]
 1024ce8:	462a      	mov	r2, r5
 1024cea:	4620      	mov	r0, r4
 1024cec:	f7ff ffa2 	bl	1024c34 <idx_inc>
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
 1024cf0:	6821      	ldr	r1, [r4, #0]
 1024cf2:	462a      	mov	r2, r5
			buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, rd_wlen);
 1024cf4:	6060      	str	r0, [r4, #4]
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
 1024cf6:	4620      	mov	r0, r4
 1024cf8:	f7ff ff9c 	bl	1024c34 <idx_inc>
			uint32_t next_rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
 1024cfc:	462a      	mov	r2, r5
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
 1024cfe:	6020      	str	r0, [r4, #0]
			uint32_t next_rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
 1024d00:	68e1      	ldr	r1, [r4, #12]
 1024d02:	4620      	mov	r0, r4
 1024d04:	f7ff ff96 	bl	1024c34 <idx_inc>
			item = (union mpsc_pbuf_generic *)&buffer->buf[next_rd_idx];
 1024d08:	6a23      	ldr	r3, [r4, #32]
	if (item->hdr.busy && !item->hdr.valid) {
 1024d0a:	f813 2020 	ldrb.w	r2, [r3, r0, lsl #2]
			item = (union mpsc_pbuf_generic *)&buffer->buf[next_rd_idx];
 1024d0e:	eb03 0680 	add.w	r6, r3, r0, lsl #2
	if (item->hdr.busy && !item->hdr.valid) {
 1024d12:	f002 0203 	and.w	r2, r2, #3
 1024d16:	2a02      	cmp	r2, #2
 1024d18:	d10e      	bne.n	1024d38 <drop_item_locked+0xa2>
		return item->skip.len;
 1024d1a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
			if (skip_wlen) {
 1024d1e:	089b      	lsrs	r3, r3, #2
 1024d20:	d00a      	beq.n	1024d38 <drop_item_locked+0xa2>
				rd_wlen += skip_wlen;
 1024d22:	441d      	add	r5, r3
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
 1024d24:	68e1      	ldr	r1, [r4, #12]
 1024d26:	462a      	mov	r2, r5
 1024d28:	4620      	mov	r0, r4
 1024d2a:	f7ff ff83 	bl	1024c34 <idx_inc>
		buffer->tmp_rd_idx = buffer->rd_idx;
 1024d2e:	e9c4 0002 	strd	r0, r0, [r4, #8]
}
 1024d32:	4630      	mov	r0, r6
 1024d34:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				rd_wlen += buffer->get_wlen(item);
 1024d38:	4630      	mov	r0, r6
 1024d3a:	69e3      	ldr	r3, [r4, #28]
 1024d3c:	4798      	blx	r3
 1024d3e:	4405      	add	r5, r0
			*user_packet = true;
 1024d40:	2301      	movs	r3, #1
 1024d42:	703b      	strb	r3, [r7, #0]
	if (allow_drop) {
 1024d44:	e7ee      	b.n	1024d24 <drop_item_locked+0x8e>
		item = NULL;
 1024d46:	4646      	mov	r6, r8
	return item;
 1024d48:	e7f3      	b.n	1024d32 <drop_item_locked+0x9c>

01024d4a <mpsc_pbuf_is_pending>:
	if (buffer->tmp_rd_idx <= buffer->wr_idx) {
 1024d4a:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
 1024d4e:	4293      	cmp	r3, r2
	*res = buffer->size - buffer->tmp_rd_idx;
 1024d50:	bf88      	it	hi
 1024d52:	6a42      	ldrhi	r2, [r0, #36]	; 0x24
 1024d54:	1ad3      	subs	r3, r2, r3
	uint32_t a;

	(void)available(buffer, &a);

	return a ? true : false;
}
 1024d56:	1e18      	subs	r0, r3, #0
 1024d58:	bf18      	it	ne
 1024d5a:	2001      	movne	r0, #1
 1024d5c:	4770      	bx	lr

01024d5e <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BT_NUS_SECURITY_ENABLED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BT_NUS_UART_DEV, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BT_NUS_UART_RX_WAIT_TIME, 50);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_IPC_SMP_BT, 1);

GEN_ABS_SYM_END
 1024d5e:	4770      	bx	lr

01024d60 <log_msg_generic_get_wlen>:
	return msg->generic.type == Z_LOG_MSG2_LOG;
 1024d60:	7803      	ldrb	r3, [r0, #0]
	if (z_log_item_is_msg(generic_msg)) {
 1024d62:	075b      	lsls	r3, r3, #29
 1024d64:	d40b      	bmi.n	1024d7e <log_msg_generic_get_wlen+0x1e>
	return Z_LOG_MSG2_ALIGNED_WLEN(desc.package_len, desc.data_len);
 1024d66:	6803      	ldr	r3, [r0, #0]
 1024d68:	8842      	ldrh	r2, [r0, #2]
 1024d6a:	f3c3 2349 	ubfx	r3, r3, #9, #10
 1024d6e:	f3c2 02cb 	ubfx	r2, r2, #3, #12
 1024d72:	1898      	adds	r0, r3, r2
 1024d74:	3017      	adds	r0, #23
 1024d76:	f020 0007 	bic.w	r0, r0, #7
 1024d7a:	0880      	lsrs	r0, r0, #2
		return log_msg_get_total_wlen(msg->hdr.desc);
 1024d7c:	4770      	bx	lr
	return 0;
 1024d7e:	2000      	movs	r0, #0
}
 1024d80:	4770      	bx	lr

01024d82 <dummy_timestamp>:
}
 1024d82:	2000      	movs	r0, #0
 1024d84:	4770      	bx	lr

01024d86 <default_get_timestamp>:
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
 1024d86:	f004 b95f 	b.w	1029048 <sys_clock_cycle_get_32>

01024d8a <atomic_inc>:
{
 1024d8a:	4603      	mov	r3, r0
}
 1024d8c:	e8d3 0fef 	ldaex	r0, [r3]
 1024d90:	1c42      	adds	r2, r0, #1
 1024d92:	e8c3 2fe1 	stlex	r1, r2, [r3]
 1024d96:	2900      	cmp	r1, #0
 1024d98:	d1f8      	bne.n	1024d8c <atomic_inc+0x2>
 1024d9a:	4770      	bx	lr

01024d9c <z_log_vprintk>:
{
 1024d9c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		va_end(parm7.val);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg_runtime_vcreate(domain_id, source, level, data, dlen, package_flags, fmt, ap);
 1024d9e:	2300      	movs	r3, #0
 1024da0:	e9cd 0102 	strd	r0, r1, [sp, #8]
 1024da4:	461a      	mov	r2, r3
 1024da6:	4619      	mov	r1, r3
 1024da8:	4618      	mov	r0, r3
 1024daa:	e9cd 3300 	strd	r3, r3, [sp]
 1024dae:	f7df fd11 	bl	10047d4 <z_impl_z_log_msg_runtime_vcreate>
}
 1024db2:	b005      	add	sp, #20
 1024db4:	f85d fb04 	ldr.w	pc, [sp], #4

01024db8 <z_log_notify_drop>:
				     const union mpsc_pbuf_generic *item)
{
	ARG_UNUSED(buffer);
	ARG_UNUSED(item);

	z_log_dropped(true);
 1024db8:	2001      	movs	r0, #1
 1024dba:	f7df ba3b 	b.w	1004234 <z_log_dropped>

01024dbe <z_log_get_tag>:
}
 1024dbe:	2000      	movs	r0, #0
 1024dc0:	4770      	bx	lr

01024dc2 <z_cbprintf_cpy>:
{
 1024dc2:	b570      	push	{r4, r5, r6, lr}
	if ((desc->size - desc->off) < len) {
 1024dc4:	e9d2 3601 	ldrd	r3, r6, [r2, #4]
 1024dc8:	1b9b      	subs	r3, r3, r6
 1024dca:	428b      	cmp	r3, r1
{
 1024dcc:	460c      	mov	r4, r1
 1024dce:	4615      	mov	r5, r2
	if ((desc->size - desc->off) < len) {
 1024dd0:	d30a      	bcc.n	1024de8 <z_cbprintf_cpy+0x26>
	memcpy(&((uint8_t *)desc->buf)[desc->off], buf, len);
 1024dd2:	6813      	ldr	r3, [r2, #0]
 1024dd4:	460a      	mov	r2, r1
 1024dd6:	4601      	mov	r1, r0
 1024dd8:	1998      	adds	r0, r3, r6
 1024dda:	f001 fdcb 	bl	1026974 <memcpy>
	return len;
 1024dde:	4620      	mov	r0, r4
	desc->off += len;
 1024de0:	68ab      	ldr	r3, [r5, #8]
 1024de2:	4423      	add	r3, r4
 1024de4:	60ab      	str	r3, [r5, #8]
}
 1024de6:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOSPC;
 1024de8:	f06f 001b 	mvn.w	r0, #27
 1024dec:	e7fb      	b.n	1024de6 <z_cbprintf_cpy+0x24>

01024dee <z_log_msg_finalize>:
{
 1024dee:	b570      	push	{r4, r5, r6, lr}
 1024df0:	460e      	mov	r6, r1
 1024df2:	4615      	mov	r5, r2
 1024df4:	4619      	mov	r1, r3
	if (!msg) {
 1024df6:	4604      	mov	r4, r0
 1024df8:	b918      	cbnz	r0, 1024e02 <z_log_msg_finalize+0x14>
}
 1024dfa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_log_dropped(false);
 1024dfe:	f7df ba19 	b.w	1004234 <z_log_dropped>
	if (data) {
 1024e02:	b13b      	cbz	r3, 1024e14 <z_log_msg_finalize+0x26>
		uint8_t *d = msg->data + desc.package_len;
 1024e04:	f3c2 2349 	ubfx	r3, r2, #9, #10
 1024e08:	3010      	adds	r0, #16
		memcpy(d, data, desc.data_len);
 1024e0a:	f3c2 42cb 	ubfx	r2, r2, #19, #12
 1024e0e:	4418      	add	r0, r3
 1024e10:	f001 fdb0 	bl	1026974 <memcpy>
	msg->hdr.source = source;
 1024e14:	e9c4 5600 	strd	r5, r6, [r4]
	z_log_msg_commit(msg);
 1024e18:	4620      	mov	r0, r4
}
 1024e1a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_log_msg_commit(msg);
 1024e1e:	f7df bc2d 	b.w	100467c <z_log_msg_commit>

01024e22 <buffer_write>:
{
 1024e22:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1024e24:	4606      	mov	r6, r0
 1024e26:	460d      	mov	r5, r1
 1024e28:	4614      	mov	r4, r2
 1024e2a:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
 1024e2c:	4621      	mov	r1, r4
 1024e2e:	4628      	mov	r0, r5
 1024e30:	463a      	mov	r2, r7
 1024e32:	47b0      	blx	r6
	} while (len != 0);
 1024e34:	1a24      	subs	r4, r4, r0
		buf += processed;
 1024e36:	4405      	add	r5, r0
	} while (len != 0);
 1024e38:	d1f8      	bne.n	1024e2c <buffer_write+0xa>
}
 1024e3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

01024e3c <cbvprintf>:
{
 1024e3c:	b513      	push	{r0, r1, r4, lr}
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
 1024e3e:	2400      	movs	r4, #0
 1024e40:	9400      	str	r4, [sp, #0]
 1024e42:	f7de faf5 	bl	1003430 <z_cbvprintf_impl>
}
 1024e46:	b002      	add	sp, #8
 1024e48:	bd10      	pop	{r4, pc}

01024e4a <log_output_flush>:
{
 1024e4a:	b510      	push	{r4, lr}
		     output->control_block->offset,
 1024e4c:	6842      	ldr	r2, [r0, #4]
{
 1024e4e:	4604      	mov	r4, r0
	buffer_write(output->func, output->buf,
 1024e50:	e9d2 2300 	ldrd	r2, r3, [r2]
 1024e54:	6881      	ldr	r1, [r0, #8]
 1024e56:	6800      	ldr	r0, [r0, #0]
 1024e58:	f7ff ffe3 	bl	1024e22 <buffer_write>
	output->control_block->offset = 0;
 1024e5c:	2200      	movs	r2, #0
 1024e5e:	6863      	ldr	r3, [r4, #4]
 1024e60:	601a      	str	r2, [r3, #0]
}
 1024e62:	bd10      	pop	{r4, pc}

01024e64 <cr_out_func>:
	if (c == '\n') {
 1024e64:	280a      	cmp	r0, #10
{
 1024e66:	b538      	push	{r3, r4, r5, lr}
 1024e68:	4604      	mov	r4, r0
 1024e6a:	460d      	mov	r5, r1
	if (c == '\n') {
 1024e6c:	d102      	bne.n	1024e74 <cr_out_func+0x10>
		out_func((int)'\r', ctx);
 1024e6e:	200d      	movs	r0, #13
 1024e70:	f7df fd34 	bl	10048dc <out_func>
	out_func(c, ctx);
 1024e74:	4629      	mov	r1, r5
 1024e76:	4620      	mov	r0, r4
 1024e78:	f7df fd30 	bl	10048dc <out_func>
}
 1024e7c:	2000      	movs	r0, #0
 1024e7e:	bd38      	pop	{r3, r4, r5, pc}

01024e80 <nvs_flash_rd>:
{
 1024e80:	b470      	push	{r4, r5, r6}
	offset += addr & ADDR_OFFS_MASK;
 1024e82:	6806      	ldr	r6, [r0, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
 1024e84:	8984      	ldrh	r4, [r0, #12]
 1024e86:	0c0d      	lsrs	r5, r1, #16
	offset += addr & ADDR_OFFS_MASK;
 1024e88:	b289      	uxth	r1, r1
 1024e8a:	4431      	add	r1, r6
 1024e8c:	fb05 1104 	mla	r1, r5, r4, r1
	rc = flash_read(fs->flash_device, offset, data, len);
 1024e90:	6a80      	ldr	r0, [r0, #40]	; 0x28
	return api->read(dev, offset, data, len);
 1024e92:	6884      	ldr	r4, [r0, #8]
 1024e94:	6824      	ldr	r4, [r4, #0]
 1024e96:	46a4      	mov	ip, r4
}
 1024e98:	bc70      	pop	{r4, r5, r6}
 1024e9a:	4760      	bx	ip

01024e9c <nvs_sector_advance>:
	*addr += (1 << ADDR_SECT_SHIFT);
 1024e9c:	680b      	ldr	r3, [r1, #0]
 1024e9e:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 1024ea2:	600b      	str	r3, [r1, #0]
	if ((*addr >> ADDR_SECT_SHIFT) == fs->sector_count) {
 1024ea4:	89c0      	ldrh	r0, [r0, #14]
 1024ea6:	0c1a      	lsrs	r2, r3, #16
 1024ea8:	ebb0 4f13 	cmp.w	r0, r3, lsr #16
		*addr -= (fs->sector_count << ADDR_SECT_SHIFT);
 1024eac:	bf04      	itt	eq
 1024eae:	eba3 4302 	subeq.w	r3, r3, r2, lsl #16
 1024eb2:	600b      	streq	r3, [r1, #0]
}
 1024eb4:	4770      	bx	lr

01024eb6 <nvs_flash_block_cmp>:
{
 1024eb6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1024eba:	4681      	mov	r9, r0
 1024ebc:	460e      	mov	r6, r1
 1024ebe:	4617      	mov	r7, r2
 1024ec0:	461c      	mov	r4, r3
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
 1024ec2:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
{
 1024ec4:	b089      	sub	sp, #36	; 0x24
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
 1024ec6:	681d      	ldr	r5, [r3, #0]
 1024ec8:	426d      	negs	r5, r5
	block_size =
 1024eca:	f005 0520 	and.w	r5, r5, #32
	while (len) {
 1024ece:	b91c      	cbnz	r4, 1024ed8 <nvs_flash_block_cmp+0x22>
	return 0;
 1024ed0:	4620      	mov	r0, r4
}
 1024ed2:	b009      	add	sp, #36	; 0x24
 1024ed4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		bytes_to_cmp = MIN(block_size, len);
 1024ed8:	42ac      	cmp	r4, r5
 1024eda:	46a0      	mov	r8, r4
 1024edc:	bf28      	it	cs
 1024ede:	46a8      	movcs	r8, r5
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_cmp);
 1024ee0:	466a      	mov	r2, sp
 1024ee2:	4643      	mov	r3, r8
 1024ee4:	4631      	mov	r1, r6
 1024ee6:	4648      	mov	r0, r9
 1024ee8:	f7ff ffca 	bl	1024e80 <nvs_flash_rd>
		if (rc) {
 1024eec:	2800      	cmp	r0, #0
 1024eee:	d1f0      	bne.n	1024ed2 <nvs_flash_block_cmp+0x1c>
		rc = memcmp(data8, buf, bytes_to_cmp);
 1024ef0:	4642      	mov	r2, r8
 1024ef2:	4669      	mov	r1, sp
 1024ef4:	4638      	mov	r0, r7
 1024ef6:	f001 fd2d 	bl	1026954 <memcmp>
		if (rc) {
 1024efa:	b920      	cbnz	r0, 1024f06 <nvs_flash_block_cmp+0x50>
		len -= bytes_to_cmp;
 1024efc:	eba4 0408 	sub.w	r4, r4, r8
		addr += bytes_to_cmp;
 1024f00:	4446      	add	r6, r8
		data8 += bytes_to_cmp;
 1024f02:	4447      	add	r7, r8
 1024f04:	e7e3      	b.n	1024ece <nvs_flash_block_cmp+0x18>
			return 1;
 1024f06:	2001      	movs	r0, #1
 1024f08:	e7e3      	b.n	1024ed2 <nvs_flash_block_cmp+0x1c>

01024f0a <nvs_flash_cmp_const>:
{
 1024f0a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1024f0e:	461c      	mov	r4, r3
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
 1024f10:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
{
 1024f12:	b088      	sub	sp, #32
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
 1024f14:	681d      	ldr	r5, [r3, #0]
{
 1024f16:	4607      	mov	r7, r0
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
 1024f18:	426d      	negs	r5, r5
	block_size =
 1024f1a:	f005 0520 	and.w	r5, r5, #32
{
 1024f1e:	460e      	mov	r6, r1
	(void)memset(cmp, value, block_size);
 1024f20:	4668      	mov	r0, sp
{
 1024f22:	4611      	mov	r1, r2
	(void)memset(cmp, value, block_size);
 1024f24:	462a      	mov	r2, r5
 1024f26:	f001 fd30 	bl	102698a <memset>
	while (len) {
 1024f2a:	b91c      	cbnz	r4, 1024f34 <nvs_flash_cmp_const+0x2a>
	return 0;
 1024f2c:	4620      	mov	r0, r4
}
 1024f2e:	b008      	add	sp, #32
 1024f30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		bytes_to_cmp = MIN(block_size, len);
 1024f34:	42ac      	cmp	r4, r5
 1024f36:	46a0      	mov	r8, r4
 1024f38:	bf28      	it	cs
 1024f3a:	46a8      	movcs	r8, r5
		rc = nvs_flash_block_cmp(fs, addr, cmp, bytes_to_cmp);
 1024f3c:	466a      	mov	r2, sp
 1024f3e:	4643      	mov	r3, r8
 1024f40:	4631      	mov	r1, r6
 1024f42:	4638      	mov	r0, r7
 1024f44:	f7ff ffb7 	bl	1024eb6 <nvs_flash_block_cmp>
		if (rc) {
 1024f48:	2800      	cmp	r0, #0
 1024f4a:	d1f0      	bne.n	1024f2e <nvs_flash_cmp_const+0x24>
		len -= bytes_to_cmp;
 1024f4c:	eba4 0408 	sub.w	r4, r4, r8
		addr += bytes_to_cmp;
 1024f50:	4446      	add	r6, r8
 1024f52:	e7ea      	b.n	1024f2a <nvs_flash_cmp_const+0x20>

01024f54 <nvs_flash_erase_sector>:
{
 1024f54:	b538      	push	{r3, r4, r5, lr}
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
 1024f56:	8982      	ldrh	r2, [r0, #12]
 1024f58:	6803      	ldr	r3, [r0, #0]
	addr &= ADDR_SECT_MASK;
 1024f5a:	0c0d      	lsrs	r5, r1, #16
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
 1024f5c:	0c09      	lsrs	r1, r1, #16
{
 1024f5e:	4604      	mov	r4, r0
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
 1024f60:	fb02 3101 	mla	r1, r2, r1, r3
	rc = flash_erase(fs->flash_device, offset, fs->sector_size);
 1024f64:	6a80      	ldr	r0, [r0, #40]	; 0x28
	addr &= ADDR_SECT_MASK;
 1024f66:	042d      	lsls	r5, r5, #16
	rc = api->erase(dev, offset, size);
 1024f68:	6883      	ldr	r3, [r0, #8]
 1024f6a:	689b      	ldr	r3, [r3, #8]
 1024f6c:	4798      	blx	r3
	if (rc) {
 1024f6e:	b950      	cbnz	r0, 1024f86 <nvs_flash_erase_sector+0x32>
	if (nvs_flash_cmp_const(fs, addr, fs->flash_parameters->erase_value,
 1024f70:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 1024f72:	4629      	mov	r1, r5
 1024f74:	4620      	mov	r0, r4
 1024f76:	89a3      	ldrh	r3, [r4, #12]
 1024f78:	7912      	ldrb	r2, [r2, #4]
 1024f7a:	f7ff ffc6 	bl	1024f0a <nvs_flash_cmp_const>
		rc = -ENXIO;
 1024f7e:	2800      	cmp	r0, #0
 1024f80:	bf18      	it	ne
 1024f82:	f06f 0005 	mvnne.w	r0, #5
}
 1024f86:	bd38      	pop	{r3, r4, r5, pc}

01024f88 <nvs_ate_crc8_update>:
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
 1024f88:	4601      	mov	r1, r0
{
 1024f8a:	b510      	push	{r4, lr}
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
 1024f8c:	2207      	movs	r2, #7
{
 1024f8e:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
 1024f90:	20ff      	movs	r0, #255	; 0xff
 1024f92:	f7de fa37 	bl	1003404 <crc8_ccitt>
	entry->crc8 = crc8;
 1024f96:	71e0      	strb	r0, [r4, #7]
}
 1024f98:	bd10      	pop	{r4, pc}

01024f9a <z_log_msg_static_create.constprop.0>:
	z_impl_z_log_msg_static_create(source, desc, package, data);
 1024f9a:	2300      	movs	r3, #0
 1024f9c:	f7df bbb4 	b.w	1004708 <z_impl_z_log_msg_static_create>

01024fa0 <nvs_al_size.isra.0>:
	if (write_block_size <= 1U) {
 1024fa0:	7803      	ldrb	r3, [r0, #0]
 1024fa2:	2b01      	cmp	r3, #1
	return (len + (write_block_size - 1U)) & ~(write_block_size - 1U);
 1024fa4:	bf81      	itttt	hi
 1024fa6:	f101 31ff 	addhi.w	r1, r1, #4294967295
 1024faa:	18c9      	addhi	r1, r1, r3
 1024fac:	425b      	neghi	r3, r3
 1024fae:	4019      	andhi	r1, r3
}
 1024fb0:	4608      	mov	r0, r1
 1024fb2:	4770      	bx	lr

01024fb4 <nvs_ate_valid>:
{
 1024fb4:	b570      	push	{r4, r5, r6, lr}
 1024fb6:	460c      	mov	r4, r1
 1024fb8:	4605      	mov	r5, r0
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
 1024fba:	2108      	movs	r1, #8
 1024fbc:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 1024fbe:	f7ff ffef 	bl	1024fa0 <nvs_al_size.isra.0>
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
 1024fc2:	2207      	movs	r2, #7
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
 1024fc4:	4606      	mov	r6, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
 1024fc6:	4621      	mov	r1, r4
 1024fc8:	20ff      	movs	r0, #255	; 0xff
 1024fca:	f7de fa1b 	bl	1003404 <crc8_ccitt>
	if (crc8 == entry->crc8) {
 1024fce:	79e3      	ldrb	r3, [r4, #7]
 1024fd0:	4283      	cmp	r3, r0
 1024fd2:	d107      	bne.n	1024fe4 <nvs_ate_valid+0x30>
	    (entry->offset >= (fs->sector_size - ate_size))) {
 1024fd4:	89aa      	ldrh	r2, [r5, #12]
 1024fd6:	8863      	ldrh	r3, [r4, #2]
 1024fd8:	1b90      	subs	r0, r2, r6
	if ((nvs_ate_crc8_check(entry)) ||
 1024fda:	4283      	cmp	r3, r0
 1024fdc:	bf2c      	ite	cs
 1024fde:	2000      	movcs	r0, #0
 1024fe0:	2001      	movcc	r0, #1
}
 1024fe2:	bd70      	pop	{r4, r5, r6, pc}
		return 0;
 1024fe4:	2000      	movs	r0, #0
 1024fe6:	e7fc      	b.n	1024fe2 <nvs_ate_valid+0x2e>

01024fe8 <nvs_close_ate_valid>:
{
 1024fe8:	b538      	push	{r3, r4, r5, lr}
 1024fea:	4605      	mov	r5, r0
 1024fec:	460c      	mov	r4, r1
	if ((!nvs_ate_valid(fs, entry)) || (entry->len != 0U) ||
 1024fee:	f7ff ffe1 	bl	1024fb4 <nvs_ate_valid>
 1024ff2:	b1a0      	cbz	r0, 102501e <nvs_close_ate_valid+0x36>
 1024ff4:	88a0      	ldrh	r0, [r4, #4]
 1024ff6:	b998      	cbnz	r0, 1025020 <nvs_close_ate_valid+0x38>
 1024ff8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 1024ffc:	8822      	ldrh	r2, [r4, #0]
 1024ffe:	429a      	cmp	r2, r3
 1025000:	d10d      	bne.n	102501e <nvs_close_ate_valid+0x36>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
 1025002:	2108      	movs	r1, #8
 1025004:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 1025006:	f7ff ffcb 	bl	1024fa0 <nvs_al_size.isra.0>
	if ((fs->sector_size - entry->offset) % ate_size) {
 102500a:	8862      	ldrh	r2, [r4, #2]
 102500c:	89ab      	ldrh	r3, [r5, #12]
 102500e:	1a9b      	subs	r3, r3, r2
 1025010:	fbb3 f2f0 	udiv	r2, r3, r0
 1025014:	fb02 3010 	mls	r0, r2, r0, r3
 1025018:	fab0 f080 	clz	r0, r0
 102501c:	0940      	lsrs	r0, r0, #5
}
 102501e:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
 1025020:	2000      	movs	r0, #0
 1025022:	e7fc      	b.n	102501e <nvs_close_ate_valid+0x36>

01025024 <nvs_prev_ate>:
{
 1025024:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1025026:	4604      	mov	r4, r0
 1025028:	460d      	mov	r5, r1
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
 102502a:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 102502c:	2108      	movs	r1, #8
 102502e:	f7ff ffb7 	bl	1024fa0 <nvs_al_size.isra.0>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
 1025032:	2308      	movs	r3, #8
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
 1025034:	4607      	mov	r7, r0
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
 1025036:	6829      	ldr	r1, [r5, #0]
 1025038:	4620      	mov	r0, r4
 102503a:	f7ff ff21 	bl	1024e80 <nvs_flash_rd>
	if (rc) {
 102503e:	4606      	mov	r6, r0
 1025040:	2800      	cmp	r0, #0
 1025042:	d136      	bne.n	10250b2 <nvs_prev_ate+0x8e>
	*addr += ate_size;
 1025044:	682b      	ldr	r3, [r5, #0]
 1025046:	443b      	add	r3, r7
 1025048:	602b      	str	r3, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
 102504a:	89a2      	ldrh	r2, [r4, #12]
 102504c:	b299      	uxth	r1, r3
 102504e:	1bd2      	subs	r2, r2, r7
 1025050:	4291      	cmp	r1, r2
 1025052:	d12e      	bne.n	10250b2 <nvs_prev_ate+0x8e>
	if (((*addr) >> ADDR_SECT_SHIFT) == 0U) {
 1025054:	0c1a      	lsrs	r2, r3, #16
		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
 1025056:	bf09      	itett	eq
 1025058:	89e2      	ldrheq	r2, [r4, #14]
		*addr -= (1 << ADDR_SECT_SHIFT);
 102505a:	f5a3 3180 	subne.w	r1, r3, #65536	; 0x10000
		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
 102505e:	f102 32ff 	addeq.w	r2, r2, #4294967295
 1025062:	eb03 4102 	addeq.w	r1, r3, r2, lsl #16
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
 1025066:	4620      	mov	r0, r4
 1025068:	2308      	movs	r3, #8
 102506a:	466a      	mov	r2, sp
 102506c:	6029      	str	r1, [r5, #0]
 102506e:	f7ff ff07 	bl	1024e80 <nvs_flash_rd>
	if (rc) {
 1025072:	b9e8      	cbnz	r0, 10250b0 <nvs_prev_ate+0x8c>
	rc = nvs_ate_cmp_const(&close_ate, fs->flash_parameters->erase_value);
 1025074:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 1025076:	791a      	ldrb	r2, [r3, #4]
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
 1025078:	466b      	mov	r3, sp
		if (data8[i] != value) {
 102507a:	f813 1b01 	ldrb.w	r1, [r3], #1
 102507e:	428a      	cmp	r2, r1
 1025080:	d10c      	bne.n	102509c <nvs_prev_ate+0x78>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
 1025082:	3001      	adds	r0, #1
 1025084:	2808      	cmp	r0, #8
 1025086:	d1f8      	bne.n	102507a <nvs_prev_ate+0x56>
		*addr = fs->ate_wra;
 1025088:	6863      	ldr	r3, [r4, #4]
 102508a:	e005      	b.n	1025098 <nvs_prev_ate+0x74>
		(*addr) &= ADDR_SECT_MASK;
 102508c:	682b      	ldr	r3, [r5, #0]
		(*addr) += close_ate.offset;
 102508e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
		(*addr) &= ADDR_SECT_MASK;
 1025092:	0c1b      	lsrs	r3, r3, #16
 1025094:	041b      	lsls	r3, r3, #16
		(*addr) += close_ate.offset;
 1025096:	4413      	add	r3, r2
		*addr = fs->ate_wra;
 1025098:	602b      	str	r3, [r5, #0]
		return 0;
 102509a:	e00a      	b.n	10250b2 <nvs_prev_ate+0x8e>
	if (nvs_close_ate_valid(fs, &close_ate)) {
 102509c:	4669      	mov	r1, sp
 102509e:	4620      	mov	r0, r4
 10250a0:	f7ff ffa2 	bl	1024fe8 <nvs_close_ate_valid>
 10250a4:	2800      	cmp	r0, #0
 10250a6:	d1f1      	bne.n	102508c <nvs_prev_ate+0x68>
	return nvs_recover_last_ate(fs, addr);
 10250a8:	4629      	mov	r1, r5
 10250aa:	4620      	mov	r0, r4
 10250ac:	f7df fea6 	bl	1004dfc <nvs_recover_last_ate>
 10250b0:	4606      	mov	r6, r0
}
 10250b2:	4630      	mov	r0, r6
 10250b4:	b003      	add	sp, #12
 10250b6:	bdf0      	pop	{r4, r5, r6, r7, pc}

010250b8 <nvs_flash_al_wrt>:
{
 10250b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 10250bc:	4607      	mov	r7, r0
 10250be:	4690      	mov	r8, r2
	if (!len) {
 10250c0:	461e      	mov	r6, r3
{
 10250c2:	b089      	sub	sp, #36	; 0x24
	if (!len) {
 10250c4:	b91b      	cbnz	r3, 10250ce <nvs_flash_al_wrt+0x16>
		return 0;
 10250c6:	2000      	movs	r0, #0
}
 10250c8:	b009      	add	sp, #36	; 0x24
 10250ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
 10250ce:	8983      	ldrh	r3, [r0, #12]
	offset += addr & ADDR_OFFS_MASK;
 10250d0:	b28c      	uxth	r4, r1
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
 10250d2:	0c08      	lsrs	r0, r1, #16
	offset += addr & ADDR_OFFS_MASK;
 10250d4:	6839      	ldr	r1, [r7, #0]
 10250d6:	440c      	add	r4, r1
 10250d8:	fb00 4403 	mla	r4, r0, r3, r4
	blen = len & ~(fs->flash_parameters->write_block_size - 1U);
 10250dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 10250de:	681d      	ldr	r5, [r3, #0]
 10250e0:	426d      	negs	r5, r5
	if (blen > 0) {
 10250e2:	4035      	ands	r5, r6
 10250e4:	d00c      	beq.n	1025100 <nvs_flash_al_wrt+0x48>
		rc = flash_write(fs->flash_device, offset, data8, blen);
 10250e6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
	rc = api->write(dev, offset, data, len);
 10250e8:	6883      	ldr	r3, [r0, #8]
 10250ea:	4621      	mov	r1, r4
 10250ec:	f8d3 9004 	ldr.w	r9, [r3, #4]
 10250f0:	462b      	mov	r3, r5
 10250f2:	47c8      	blx	r9
		if (rc) {
 10250f4:	2800      	cmp	r0, #0
 10250f6:	d1e7      	bne.n	10250c8 <nvs_flash_al_wrt+0x10>
	if (len) {
 10250f8:	1b76      	subs	r6, r6, r5
 10250fa:	d0e4      	beq.n	10250c6 <nvs_flash_al_wrt+0xe>
		offset += blen;
 10250fc:	442c      	add	r4, r5
		data8 += blen;
 10250fe:	44a8      	add	r8, r5
		memcpy(buf, data8, len);
 1025100:	4632      	mov	r2, r6
 1025102:	4641      	mov	r1, r8
 1025104:	4668      	mov	r0, sp
 1025106:	f001 fc35 	bl	1026974 <memcpy>
		(void)memset(buf + len, fs->flash_parameters->erase_value,
 102510a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 102510c:	eb0d 0006 	add.w	r0, sp, r6
 1025110:	681a      	ldr	r2, [r3, #0]
 1025112:	7919      	ldrb	r1, [r3, #4]
 1025114:	1b92      	subs	r2, r2, r6
 1025116:	f001 fc38 	bl	102698a <memset>
				 fs->flash_parameters->write_block_size);
 102511a:	e9d7 030a 	ldrd	r0, r3, [r7, #40]	; 0x28
 102511e:	681b      	ldr	r3, [r3, #0]
 1025120:	6882      	ldr	r2, [r0, #8]
 1025122:	4621      	mov	r1, r4
 1025124:	6855      	ldr	r5, [r2, #4]
 1025126:	466a      	mov	r2, sp
 1025128:	47a8      	blx	r5
	return rc;
 102512a:	e7cd      	b.n	10250c8 <nvs_flash_al_wrt+0x10>

0102512c <nvs_flash_ate_wrt>:
{
 102512c:	b510      	push	{r4, lr}
 102512e:	460a      	mov	r2, r1
	rc = nvs_flash_al_wrt(fs, fs->ate_wra, entry,
 1025130:	2308      	movs	r3, #8
 1025132:	6841      	ldr	r1, [r0, #4]
{
 1025134:	4604      	mov	r4, r0
	rc = nvs_flash_al_wrt(fs, fs->ate_wra, entry,
 1025136:	f7ff ffbf 	bl	10250b8 <nvs_flash_al_wrt>
	fs->ate_wra -= nvs_al_size(fs, sizeof(struct nvs_ate));
 102513a:	2108      	movs	r1, #8
	rc = nvs_flash_al_wrt(fs, fs->ate_wra, entry,
 102513c:	4602      	mov	r2, r0
	fs->ate_wra -= nvs_al_size(fs, sizeof(struct nvs_ate));
 102513e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 1025140:	f7ff ff2e 	bl	1024fa0 <nvs_al_size.isra.0>
 1025144:	6863      	ldr	r3, [r4, #4]
 1025146:	1a1b      	subs	r3, r3, r0
 1025148:	6063      	str	r3, [r4, #4]
}
 102514a:	4610      	mov	r0, r2
 102514c:	bd10      	pop	{r4, pc}

0102514e <nvs_add_gc_done_ate>:
	gc_done_ate.id = 0xffff;
 102514e:	f64f 73ff 	movw	r3, #65535	; 0xffff
{
 1025152:	b513      	push	{r0, r1, r4, lr}
	gc_done_ate.id = 0xffff;
 1025154:	f8ad 3000 	strh.w	r3, [sp]
	gc_done_ate.len = 0U;
 1025158:	2300      	movs	r3, #0
{
 102515a:	4604      	mov	r4, r0
	gc_done_ate.len = 0U;
 102515c:	f8ad 3004 	strh.w	r3, [sp, #4]
	gc_done_ate.offset = (uint16_t)(fs->data_wra & ADDR_OFFS_MASK);
 1025160:	6883      	ldr	r3, [r0, #8]
	nvs_ate_crc8_update(&gc_done_ate);
 1025162:	4668      	mov	r0, sp
	gc_done_ate.offset = (uint16_t)(fs->data_wra & ADDR_OFFS_MASK);
 1025164:	f8ad 3002 	strh.w	r3, [sp, #2]
	nvs_ate_crc8_update(&gc_done_ate);
 1025168:	f7ff ff0e 	bl	1024f88 <nvs_ate_crc8_update>
	return nvs_flash_ate_wrt(fs, &gc_done_ate);
 102516c:	4669      	mov	r1, sp
 102516e:	4620      	mov	r0, r4
 1025170:	f7ff ffdc 	bl	102512c <nvs_flash_ate_wrt>
}
 1025174:	b002      	add	sp, #8
 1025176:	bd10      	pop	{r4, pc}

01025178 <nvs_gc>:
{
 1025178:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
 102517c:	2108      	movs	r1, #8
{
 102517e:	b095      	sub	sp, #84	; 0x54
 1025180:	4604      	mov	r4, r0
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
 1025182:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 1025184:	f7ff ff0c 	bl	1024fa0 <nvs_al_size.isra.0>
 1025188:	4605      	mov	r5, r0
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
 102518a:	6863      	ldr	r3, [r4, #4]
	nvs_sector_advance(fs, &sec_addr);
 102518c:	4620      	mov	r0, r4
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
 102518e:	0c1b      	lsrs	r3, r3, #16
 1025190:	041b      	lsls	r3, r3, #16
	nvs_sector_advance(fs, &sec_addr);
 1025192:	a903      	add	r1, sp, #12
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
 1025194:	9303      	str	r3, [sp, #12]
	nvs_sector_advance(fs, &sec_addr);
 1025196:	f7ff fe81 	bl	1024e9c <nvs_sector_advance>
	gc_addr = sec_addr + fs->sector_size - ate_size;
 102519a:	f8dd b00c 	ldr.w	fp, [sp, #12]
 102519e:	89a6      	ldrh	r6, [r4, #12]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
 10251a0:	aa06      	add	r2, sp, #24
	gc_addr = sec_addr + fs->sector_size - ate_size;
 10251a2:	445e      	add	r6, fp
 10251a4:	1b76      	subs	r6, r6, r5
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
 10251a6:	2308      	movs	r3, #8
 10251a8:	4631      	mov	r1, r6
 10251aa:	4620      	mov	r0, r4
	gc_addr = sec_addr + fs->sector_size - ate_size;
 10251ac:	9604      	str	r6, [sp, #16]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
 10251ae:	f7ff fe67 	bl	1024e80 <nvs_flash_rd>
	if (rc < 0) {
 10251b2:	1e02      	subs	r2, r0, #0
 10251b4:	f2c0 80a9 	blt.w	102530a <nvs_gc+0x192>
	rc = nvs_ate_cmp_const(&close_ate, fs->flash_parameters->erase_value);
 10251b8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 10251ba:	aa06      	add	r2, sp, #24
 10251bc:	7919      	ldrb	r1, [r3, #4]
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
 10251be:	2300      	movs	r3, #0
		if (data8[i] != value) {
 10251c0:	f812 0b01 	ldrb.w	r0, [r2], #1
 10251c4:	4281      	cmp	r1, r0
 10251c6:	f040 808f 	bne.w	10252e8 <nvs_gc+0x170>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
 10251ca:	3301      	adds	r3, #1
 10251cc:	2b08      	cmp	r3, #8
 10251ce:	d1f7      	bne.n	10251c0 <nvs_gc+0x48>
	if (fs->ate_wra >= (fs->data_wra + ate_size)) {
 10251d0:	68a3      	ldr	r3, [r4, #8]
 10251d2:	6862      	ldr	r2, [r4, #4]
 10251d4:	442b      	add	r3, r5
 10251d6:	429a      	cmp	r2, r3
 10251d8:	d27e      	bcs.n	10252d8 <nvs_gc+0x160>
	rc = nvs_flash_erase_sector(fs, sec_addr);
 10251da:	4659      	mov	r1, fp
 10251dc:	4620      	mov	r0, r4
 10251de:	f7ff feb9 	bl	1024f54 <nvs_flash_erase_sector>
 10251e2:	4602      	mov	r2, r0
	if (rc) {
 10251e4:	e091      	b.n	102530a <nvs_gc+0x192>
		gc_addr += close_ate.offset;
 10251e6:	f8bd 301a 	ldrh.w	r3, [sp, #26]
		gc_addr &= ADDR_SECT_MASK;
 10251ea:	0c36      	lsrs	r6, r6, #16
 10251ec:	0436      	lsls	r6, r6, #16
		gc_addr += close_ate.offset;
 10251ee:	441e      	add	r6, r3
 10251f0:	9604      	str	r6, [sp, #16]
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
 10251f2:	aa08      	add	r2, sp, #32
 10251f4:	4620      	mov	r0, r4
 10251f6:	a904      	add	r1, sp, #16
		gc_prev_addr = gc_addr;
 10251f8:	f8dd a010 	ldr.w	sl, [sp, #16]
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
 10251fc:	f7ff ff12 	bl	1025024 <nvs_prev_ate>
		if (rc) {
 1025200:	4602      	mov	r2, r0
 1025202:	2800      	cmp	r0, #0
 1025204:	f040 8081 	bne.w	102530a <nvs_gc+0x192>
		if (!nvs_ate_valid(fs, &gc_ate)) {
 1025208:	4620      	mov	r0, r4
 102520a:	a908      	add	r1, sp, #32
 102520c:	f7ff fed2 	bl	1024fb4 <nvs_ate_valid>
 1025210:	b918      	cbnz	r0, 102521a <nvs_gc+0xa2>
	} while (gc_prev_addr != stop_addr);
 1025212:	9b01      	ldr	r3, [sp, #4]
 1025214:	459a      	cmp	sl, r3
 1025216:	d1ec      	bne.n	10251f2 <nvs_gc+0x7a>
 1025218:	e7da      	b.n	10251d0 <nvs_gc+0x58>
		wlk_addr = fs->ate_wra;
 102521a:	6863      	ldr	r3, [r4, #4]
 102521c:	9305      	str	r3, [sp, #20]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
 102521e:	aa0a      	add	r2, sp, #40	; 0x28
 1025220:	4620      	mov	r0, r4
 1025222:	a905      	add	r1, sp, #20
			wlk_prev_addr = wlk_addr;
 1025224:	9e05      	ldr	r6, [sp, #20]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
 1025226:	f7ff fefd 	bl	1025024 <nvs_prev_ate>
			if (rc) {
 102522a:	4602      	mov	r2, r0
 102522c:	2800      	cmp	r0, #0
 102522e:	d16c      	bne.n	102530a <nvs_gc+0x192>
			if ((wlk_ate.id == gc_ate.id) &&
 1025230:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
 1025234:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 1025238:	429a      	cmp	r2, r3
 102523a:	d027      	beq.n	102528c <nvs_gc+0x114>
		} while (wlk_addr != fs->ate_wra);
 102523c:	6862      	ldr	r2, [r4, #4]
 102523e:	9b05      	ldr	r3, [sp, #20]
 1025240:	429a      	cmp	r2, r3
 1025242:	d1ec      	bne.n	102521e <nvs_gc+0xa6>
		if ((wlk_prev_addr == gc_prev_addr) && gc_ate.len) {
 1025244:	4556      	cmp	r6, sl
 1025246:	d1e4      	bne.n	1025212 <nvs_gc+0x9a>
 1025248:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
 102524c:	2b00      	cmp	r3, #0
 102524e:	d0e0      	beq.n	1025212 <nvs_gc+0x9a>
			data_addr += gc_ate.offset;
 1025250:	f8bd 7022 	ldrh.w	r7, [sp, #34]	; 0x22
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
 1025254:	ea4f 431a 	mov.w	r3, sl, lsr #16
 1025258:	041b      	lsls	r3, r3, #16
			data_addr += gc_ate.offset;
 102525a:	441f      	add	r7, r3
			gc_ate.offset = (uint16_t)(fs->data_wra & ADDR_OFFS_MASK);
 102525c:	68a3      	ldr	r3, [r4, #8]
			nvs_ate_crc8_update(&gc_ate);
 102525e:	a808      	add	r0, sp, #32
			gc_ate.offset = (uint16_t)(fs->data_wra & ADDR_OFFS_MASK);
 1025260:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
			nvs_ate_crc8_update(&gc_ate);
 1025264:	f7ff fe90 	bl	1024f88 <nvs_ate_crc8_update>
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
 1025268:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
			rc = nvs_flash_block_move(fs, data_addr, gc_ate.len);
 102526a:	f8bd 9024 	ldrh.w	r9, [sp, #36]	; 0x24
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
 102526e:	681e      	ldr	r6, [r3, #0]
 1025270:	4276      	negs	r6, r6
	block_size =
 1025272:	f006 0620 	and.w	r6, r6, #32
	while (len) {
 1025276:	f1b9 0f00 	cmp.w	r9, #0
 102527a:	d10e      	bne.n	102529a <nvs_gc+0x122>
			rc = nvs_flash_ate_wrt(fs, &gc_ate);
 102527c:	4620      	mov	r0, r4
 102527e:	a908      	add	r1, sp, #32
 1025280:	f7ff ff54 	bl	102512c <nvs_flash_ate_wrt>
			if (rc) {
 1025284:	4602      	mov	r2, r0
 1025286:	2800      	cmp	r0, #0
 1025288:	d0c3      	beq.n	1025212 <nvs_gc+0x9a>
 102528a:	e03e      	b.n	102530a <nvs_gc+0x192>
			    (nvs_ate_valid(fs, &wlk_ate))) {
 102528c:	4620      	mov	r0, r4
 102528e:	a90a      	add	r1, sp, #40	; 0x28
 1025290:	f7ff fe90 	bl	1024fb4 <nvs_ate_valid>
			if ((wlk_ate.id == gc_ate.id) &&
 1025294:	2800      	cmp	r0, #0
 1025296:	d0d1      	beq.n	102523c <nvs_gc+0xc4>
 1025298:	e7d4      	b.n	1025244 <nvs_gc+0xcc>
		bytes_to_copy = MIN(block_size, len);
 102529a:	454e      	cmp	r6, r9
 102529c:	46b0      	mov	r8, r6
 102529e:	bf28      	it	cs
 10252a0:	46c8      	movcs	r8, r9
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_copy);
 10252a2:	aa0c      	add	r2, sp, #48	; 0x30
 10252a4:	4643      	mov	r3, r8
 10252a6:	4639      	mov	r1, r7
 10252a8:	4620      	mov	r0, r4
 10252aa:	f7ff fde9 	bl	1024e80 <nvs_flash_rd>
		if (rc) {
 10252ae:	4602      	mov	r2, r0
 10252b0:	bb58      	cbnz	r0, 102530a <nvs_gc+0x192>
	rc = nvs_flash_al_wrt(fs, fs->data_wra, data, len);
 10252b2:	4643      	mov	r3, r8
 10252b4:	68a1      	ldr	r1, [r4, #8]
 10252b6:	aa0c      	add	r2, sp, #48	; 0x30
 10252b8:	4620      	mov	r0, r4
 10252ba:	f7ff fefd 	bl	10250b8 <nvs_flash_al_wrt>
	fs->data_wra += nvs_al_size(fs, len);
 10252be:	4641      	mov	r1, r8
	rc = nvs_flash_al_wrt(fs, fs->data_wra, data, len);
 10252c0:	4602      	mov	r2, r0
	fs->data_wra += nvs_al_size(fs, len);
 10252c2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 10252c4:	f7ff fe6c 	bl	1024fa0 <nvs_al_size.isra.0>
 10252c8:	68a3      	ldr	r3, [r4, #8]
 10252ca:	4403      	add	r3, r0
 10252cc:	60a3      	str	r3, [r4, #8]
		if (rc) {
 10252ce:	b9e2      	cbnz	r2, 102530a <nvs_gc+0x192>
		len -= bytes_to_copy;
 10252d0:	eba9 0908 	sub.w	r9, r9, r8
		addr += bytes_to_copy;
 10252d4:	4447      	add	r7, r8
 10252d6:	e7ce      	b.n	1025276 <nvs_gc+0xfe>
		rc = nvs_add_gc_done_ate(fs);
 10252d8:	4620      	mov	r0, r4
 10252da:	f7ff ff38 	bl	102514e <nvs_add_gc_done_ate>
		if (rc) {
 10252de:	4602      	mov	r2, r0
 10252e0:	2800      	cmp	r0, #0
 10252e2:	f43f af7a 	beq.w	10251da <nvs_gc+0x62>
 10252e6:	e010      	b.n	102530a <nvs_gc+0x192>
	stop_addr = gc_addr - ate_size;
 10252e8:	1b73      	subs	r3, r6, r5
	if (nvs_close_ate_valid(fs, &close_ate)) {
 10252ea:	4620      	mov	r0, r4
 10252ec:	a906      	add	r1, sp, #24
	stop_addr = gc_addr - ate_size;
 10252ee:	9301      	str	r3, [sp, #4]
	if (nvs_close_ate_valid(fs, &close_ate)) {
 10252f0:	f7ff fe7a 	bl	1024fe8 <nvs_close_ate_valid>
 10252f4:	2800      	cmp	r0, #0
 10252f6:	f47f af76 	bne.w	10251e6 <nvs_gc+0x6e>
		rc = nvs_recover_last_ate(fs, &gc_addr);
 10252fa:	4620      	mov	r0, r4
 10252fc:	a904      	add	r1, sp, #16
 10252fe:	f7df fd7d 	bl	1004dfc <nvs_recover_last_ate>
		if (rc) {
 1025302:	4602      	mov	r2, r0
 1025304:	2800      	cmp	r0, #0
 1025306:	f43f af74 	beq.w	10251f2 <nvs_gc+0x7a>
}
 102530a:	4610      	mov	r0, r2
 102530c:	b015      	add	sp, #84	; 0x54
 102530e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

01025312 <nvs_delete>:
	return nvs_write(fs, id, NULL, 0);
 1025312:	2300      	movs	r3, #0
 1025314:	461a      	mov	r2, r3
 1025316:	f7df bf7b 	b.w	1005210 <nvs_write>

0102531a <nvs_read>:

ssize_t nvs_read(struct nvs_fs *fs, uint16_t id, void *data, size_t len)
{
 102531a:	b513      	push	{r0, r1, r4, lr}
	int rc;

	rc = nvs_read_hist(fs, id, data, len, 0);
 102531c:	2400      	movs	r4, #0
 102531e:	9400      	str	r4, [sp, #0]
 1025320:	f7e0 f852 	bl	10053c8 <nvs_read_hist>
	return rc;
}
 1025324:	b002      	add	sp, #8
 1025326:	bd10      	pop	{r4, pc}

01025328 <flash_area_close>:

void flash_area_close(const struct flash_area *fa)
{
	/* nothing to do for now */
}
 1025328:	4770      	bx	lr

0102532a <get_sectors_cb>:
{
 102532a:	b570      	push	{r4, r5, r6, lr}
	if (info->start_offset < data->area_off) {
 102532c:	684c      	ldr	r4, [r1, #4]
 102532e:	6803      	ldr	r3, [r0, #0]
 1025330:	42a3      	cmp	r3, r4
 1025332:	d201      	bcs.n	1025338 <get_sectors_cb+0xe>
		*bail_value = true;
 1025334:	2001      	movs	r0, #1
}
 1025336:	bd70      	pop	{r4, r5, r6, pc}
	} else if (info->start_offset >= data->area_off + data->area_len) {
 1025338:	688a      	ldr	r2, [r1, #8]
 102533a:	4422      	add	r2, r4
 102533c:	4293      	cmp	r3, r2
 102533e:	d301      	bcc.n	1025344 <get_sectors_cb+0x1a>
		*bail_value = false;
 1025340:	2000      	movs	r0, #0
 1025342:	e7f8      	b.n	1025336 <get_sectors_cb+0xc>
	} else if (data->ret_idx >= data->ret_len) {
 1025344:	694e      	ldr	r6, [r1, #20]
 1025346:	e9d1 2503 	ldrd	r2, r5, [r1, #12]
 102534a:	42b5      	cmp	r5, r6
 102534c:	d303      	bcc.n	1025356 <get_sectors_cb+0x2c>
		data->status = -ENOMEM;
 102534e:	f06f 030b 	mvn.w	r3, #11
 1025352:	618b      	str	r3, [r1, #24]
		return true;
 1025354:	e7f4      	b.n	1025340 <get_sectors_cb+0x16>
	ret[data->ret_idx].fs_off = info->start_offset - data->area_off;
 1025356:	1b1b      	subs	r3, r3, r4
 1025358:	f842 3035 	str.w	r3, [r2, r5, lsl #3]
	ret[data->ret_idx].fs_size = info->size;
 102535c:	6843      	ldr	r3, [r0, #4]
 102535e:	6908      	ldr	r0, [r1, #16]
 1025360:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
 1025364:	6053      	str	r3, [r2, #4]
	data->ret_idx++;
 1025366:	690b      	ldr	r3, [r1, #16]
 1025368:	3301      	adds	r3, #1
 102536a:	610b      	str	r3, [r1, #16]
	return true;
 102536c:	e7e2      	b.n	1025334 <get_sectors_cb+0xa>

0102536e <settings_load>:
	return settings_load_subtree(NULL);
 102536e:	2000      	movs	r0, #0
 1025370:	f7e0 b92a 	b.w	10055c8 <settings_load_subtree>

01025374 <settings_delete>:
	return settings_save_one(name, NULL, 0);
 1025374:	2200      	movs	r2, #0
 1025376:	4611      	mov	r1, r2
 1025378:	f7e0 b8ec 	b.w	1005554 <settings_save_one>

0102537c <settings_name_steq>:
{
 102537c:	4603      	mov	r3, r0
 102537e:	b510      	push	{r4, lr}
 1025380:	4608      	mov	r0, r1
	if (next) {
 1025382:	b10a      	cbz	r2, 1025388 <settings_name_steq+0xc>
		*next = NULL;
 1025384:	2100      	movs	r1, #0
 1025386:	6011      	str	r1, [r2, #0]
	if ((!name) || (!key)) {
 1025388:	b153      	cbz	r3, 10253a0 <settings_name_steq+0x24>
 102538a:	b1d0      	cbz	r0, 10253c2 <settings_name_steq+0x46>
 102538c:	1e41      	subs	r1, r0, #1
	while ((*key != '\0') && (*key == *name) &&
 102538e:	f811 0f01 	ldrb.w	r0, [r1, #1]!
	       (*name != '\0') && (*name != SETTINGS_NAME_END)) {
 1025392:	b180      	cbz	r0, 10253b6 <settings_name_steq+0x3a>
	while ((*key != '\0') && (*key == *name) &&
 1025394:	f813 4b01 	ldrb.w	r4, [r3], #1
 1025398:	42a0      	cmp	r0, r4
 102539a:	d101      	bne.n	10253a0 <settings_name_steq+0x24>
	       (*name != '\0') && (*name != SETTINGS_NAME_END)) {
 102539c:	283d      	cmp	r0, #61	; 0x3d
 102539e:	d1f6      	bne.n	102538e <settings_name_steq+0x12>
		return 0;
 10253a0:	2000      	movs	r0, #0
 10253a2:	e00e      	b.n	10253c2 <settings_name_steq+0x46>
			*next = name + 1;
 10253a4:	3301      	adds	r3, #1
 10253a6:	6013      	str	r3, [r2, #0]
 10253a8:	e00a      	b.n	10253c0 <settings_name_steq+0x44>
	if ((*name == SETTINGS_NAME_END) || (*name == '\0')) {
 10253aa:	283d      	cmp	r0, #61	; 0x3d
 10253ac:	d008      	beq.n	10253c0 <settings_name_steq+0x44>
 10253ae:	fab0 f080 	clz	r0, r0
 10253b2:	0940      	lsrs	r0, r0, #5
 10253b4:	e005      	b.n	10253c2 <settings_name_steq+0x46>
	if (*name == SETTINGS_NAME_SEPARATOR) {
 10253b6:	7818      	ldrb	r0, [r3, #0]
 10253b8:	282f      	cmp	r0, #47	; 0x2f
 10253ba:	d1f6      	bne.n	10253aa <settings_name_steq+0x2e>
		if (next) {
 10253bc:	2a00      	cmp	r2, #0
 10253be:	d1f1      	bne.n	10253a4 <settings_name_steq+0x28>
		return 1;
 10253c0:	2001      	movs	r0, #1
}
 10253c2:	bd10      	pop	{r4, pc}

010253c4 <settings_name_next>:
{
 10253c4:	b510      	push	{r4, lr}
	if (next) {
 10253c6:	b109      	cbz	r1, 10253cc <settings_name_next+0x8>
		*next = NULL;
 10253c8:	2300      	movs	r3, #0
 10253ca:	600b      	str	r3, [r1, #0]
	if (!name) {
 10253cc:	b158      	cbz	r0, 10253e6 <settings_name_next+0x22>
 10253ce:	4603      	mov	r3, r0
	while ((*name != '\0') && (*name != SETTINGS_NAME_END) &&
 10253d0:	781a      	ldrb	r2, [r3, #0]
 10253d2:	461c      	mov	r4, r3
 10253d4:	3301      	adds	r3, #1
 10253d6:	b12a      	cbz	r2, 10253e4 <settings_name_next+0x20>
 10253d8:	2a3d      	cmp	r2, #61	; 0x3d
 10253da:	d003      	beq.n	10253e4 <settings_name_next+0x20>
 10253dc:	2a2f      	cmp	r2, #47	; 0x2f
 10253de:	d1f7      	bne.n	10253d0 <settings_name_next+0xc>
		if (next) {
 10253e0:	b101      	cbz	r1, 10253e4 <settings_name_next+0x20>
			*next = name + 1;
 10253e2:	600b      	str	r3, [r1, #0]
 10253e4:	1a20      	subs	r0, r4, r0
}
 10253e6:	bd10      	pop	{r4, pc}

010253e8 <settings_nvs_storage_get>:
static void *settings_nvs_storage_get(struct settings_store *cs)
{
	struct settings_nvs *cf = CONTAINER_OF(cs, struct settings_nvs, cf_store);

	return &cf->cf_nvs;
}
 10253e8:	3008      	adds	r0, #8
 10253ea:	4770      	bx	lr

010253ec <settings_nvs_read_fn>:
{
 10253ec:	b510      	push	{r4, lr}
	rc = nvs_read(rd_fn_arg->fs, rd_fn_arg->id, data, len);
 10253ee:	4613      	mov	r3, r2
{
 10253f0:	4614      	mov	r4, r2
	rc = nvs_read(rd_fn_arg->fs, rd_fn_arg->id, data, len);
 10253f2:	460a      	mov	r2, r1
 10253f4:	8881      	ldrh	r1, [r0, #4]
 10253f6:	6800      	ldr	r0, [r0, #0]
 10253f8:	f7ff ff8f 	bl	102531a <nvs_read>
}
 10253fc:	42a0      	cmp	r0, r4
 10253fe:	bfa8      	it	ge
 1025400:	4620      	movge	r0, r4
 1025402:	bd10      	pop	{r4, pc}

01025404 <settings_nvs_save>:
{
 1025404:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1025408:	b097      	sub	sp, #92	; 0x5c
 102540a:	4604      	mov	r4, r0
 102540c:	469a      	mov	sl, r3
	if (!name) {
 102540e:	4689      	mov	r9, r1
{
 1025410:	9201      	str	r2, [sp, #4]
	if (!name) {
 1025412:	2900      	cmp	r1, #0
 1025414:	d07e      	beq.n	1025514 <settings_nvs_save+0x110>
	delete = ((value == NULL) || (val_len == 0));
 1025416:	b1da      	cbz	r2, 1025450 <settings_nvs_save+0x4c>
 1025418:	faba f78a 	clz	r7, sl
 102541c:	097f      	lsrs	r7, r7, #5
	name_id = cf->last_name_id + 1;
 102541e:	8f25      	ldrh	r5, [r4, #56]	; 0x38
		rc = nvs_read(&cf->cf_nvs, name_id, &rdname, sizeof(rdname));
 1025420:	f104 0b08 	add.w	fp, r4, #8
	name_id = cf->last_name_id + 1;
 1025424:	3501      	adds	r5, #1
 1025426:	b2ad      	uxth	r5, r5
	write_name_id = cf->last_name_id + 1;
 1025428:	46a8      	mov	r8, r5
		name_id--;
 102542a:	1e6e      	subs	r6, r5, #1
 102542c:	b2b6      	uxth	r6, r6
		if (name_id == NVS_NAMECNT_ID) {
 102542e:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
 1025432:	d029      	beq.n	1025488 <settings_nvs_save+0x84>
		rc = nvs_read(&cf->cf_nvs, name_id, &rdname, sizeof(rdname));
 1025434:	234a      	movs	r3, #74	; 0x4a
 1025436:	4631      	mov	r1, r6
 1025438:	4658      	mov	r0, fp
 102543a:	aa03      	add	r2, sp, #12
 102543c:	f7ff ff6d 	bl	102531a <nvs_read>
		if (rc < 0) {
 1025440:	2800      	cmp	r0, #0
 1025442:	da07      	bge.n	1025454 <settings_nvs_save+0x50>
		name_id--;
 1025444:	f110 0f02 	cmn.w	r0, #2
 1025448:	bf08      	it	eq
 102544a:	46b0      	moveq	r8, r6
 102544c:	4635      	mov	r5, r6
 102544e:	e7ec      	b.n	102542a <settings_nvs_save+0x26>
	delete = ((value == NULL) || (val_len == 0));
 1025450:	2701      	movs	r7, #1
 1025452:	e7e4      	b.n	102541e <settings_nvs_save+0x1a>
		rdname[rc] = '\0';
 1025454:	f100 0358 	add.w	r3, r0, #88	; 0x58
 1025458:	eb0d 0003 	add.w	r0, sp, r3
 102545c:	2300      	movs	r3, #0
		if (strcmp(name, rdname)) {
 102545e:	a903      	add	r1, sp, #12
		rdname[rc] = '\0';
 1025460:	f800 3c4c 	strb.w	r3, [r0, #-76]
		if (strcmp(name, rdname)) {
 1025464:	4648      	mov	r0, r9
 1025466:	f001 fa56 	bl	1026916 <strcmp>
 102546a:	2800      	cmp	r0, #0
 102546c:	d1ee      	bne.n	102544c <settings_nvs_save+0x48>
		if (!delete) {
 102546e:	b32f      	cbz	r7, 10254bc <settings_nvs_save+0xb8>
		if (name_id == cf->last_name_id) {
 1025470:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 1025472:	42b3      	cmp	r3, r6
 1025474:	d00b      	beq.n	102548e <settings_nvs_save+0x8a>
		rc = nvs_delete(&cf->cf_nvs, name_id);
 1025476:	4631      	mov	r1, r6
 1025478:	4658      	mov	r0, fp
 102547a:	f7ff ff4a 	bl	1025312 <nvs_delete>
		if (rc >= 0) {
 102547e:	2800      	cmp	r0, #0
 1025480:	da12      	bge.n	10254a8 <settings_nvs_save+0xa4>
}
 1025482:	b017      	add	sp, #92	; 0x5c
 1025484:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (delete) {
 1025488:	b3b7      	cbz	r7, 10254f8 <settings_nvs_save+0xf4>
			return 0;
 102548a:	2000      	movs	r0, #0
 102548c:	e7f9      	b.n	1025482 <settings_nvs_save+0x7e>
			cf->last_name_id--;
 102548e:	4622      	mov	r2, r4
 1025490:	1e73      	subs	r3, r6, #1
 1025492:	f822 3f38 	strh.w	r3, [r2, #56]!
			rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID,
 1025496:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 102549a:	2302      	movs	r3, #2
 102549c:	4658      	mov	r0, fp
 102549e:	f7df feb7 	bl	1005210 <nvs_write>
			if (rc < 0) {
 10254a2:	2800      	cmp	r0, #0
 10254a4:	dae7      	bge.n	1025476 <settings_nvs_save+0x72>
 10254a6:	e7ec      	b.n	1025482 <settings_nvs_save+0x7e>
			rc = nvs_delete(&cf->cf_nvs, name_id +
 10254a8:	f505 517f 	add.w	r1, r5, #16320	; 0x3fc0
 10254ac:	313f      	adds	r1, #63	; 0x3f
 10254ae:	4658      	mov	r0, fp
 10254b0:	b289      	uxth	r1, r1
 10254b2:	f7ff ff2e 	bl	1025312 <nvs_delete>
	if (rc < 0) {
 10254b6:	ea00 70e0 	and.w	r0, r0, r0, asr #31
 10254ba:	e7e2      	b.n	1025482 <settings_nvs_save+0x7e>
		name_id--;
 10254bc:	46b0      	mov	r8, r6
	if (write_name_id == NVS_NAMECNT_ID + NVS_NAME_ID_OFFSET) {
 10254be:	f5b8 4f40 	cmp.w	r8, #49152	; 0xc000
 10254c2:	d02a      	beq.n	102551a <settings_nvs_save+0x116>
	rc = nvs_write(&cf->cf_nvs, write_name_id + NVS_NAME_ID_OFFSET,
 10254c4:	f104 0508 	add.w	r5, r4, #8
 10254c8:	f508 4180 	add.w	r1, r8, #16384	; 0x4000
 10254cc:	4653      	mov	r3, sl
 10254ce:	4628      	mov	r0, r5
 10254d0:	9a01      	ldr	r2, [sp, #4]
 10254d2:	b289      	uxth	r1, r1
 10254d4:	f7df fe9c 	bl	1005210 <nvs_write>
	if (rc < 0) {
 10254d8:	2800      	cmp	r0, #0
 10254da:	dbd2      	blt.n	1025482 <settings_nvs_save+0x7e>
	if (write_name) {
 10254dc:	b977      	cbnz	r7, 10254fc <settings_nvs_save+0xf8>
	if (write_name_id > cf->last_name_id) {
 10254de:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 10254e0:	4543      	cmp	r3, r8
 10254e2:	d2d2      	bcs.n	102548a <settings_nvs_save+0x86>
		cf->last_name_id = write_name_id;
 10254e4:	4622      	mov	r2, r4
		rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID, &cf->last_name_id,
 10254e6:	2302      	movs	r3, #2
 10254e8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 10254ec:	4628      	mov	r0, r5
		cf->last_name_id = write_name_id;
 10254ee:	f822 8f38 	strh.w	r8, [r2, #56]!
		rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID, &cf->last_name_id,
 10254f2:	f7df fe8d 	bl	1005210 <nvs_write>
 10254f6:	e7de      	b.n	10254b6 <settings_nvs_save+0xb2>
	write_name = true;
 10254f8:	2701      	movs	r7, #1
 10254fa:	e7e0      	b.n	10254be <settings_nvs_save+0xba>
		rc = nvs_write(&cf->cf_nvs, write_name_id, name, strlen(name));
 10254fc:	4648      	mov	r0, r9
 10254fe:	f001 f9fa 	bl	10268f6 <strlen>
 1025502:	464a      	mov	r2, r9
 1025504:	4603      	mov	r3, r0
 1025506:	4641      	mov	r1, r8
 1025508:	4628      	mov	r0, r5
 102550a:	f7df fe81 	bl	1005210 <nvs_write>
		if (rc < 0) {
 102550e:	2800      	cmp	r0, #0
 1025510:	dae5      	bge.n	10254de <settings_nvs_save+0xda>
 1025512:	e7b6      	b.n	1025482 <settings_nvs_save+0x7e>
		return -EINVAL;
 1025514:	f06f 0015 	mvn.w	r0, #21
 1025518:	e7b3      	b.n	1025482 <settings_nvs_save+0x7e>
		return -ENOMEM;
 102551a:	f06f 000b 	mvn.w	r0, #11
 102551e:	e7b0      	b.n	1025482 <settings_nvs_save+0x7e>

01025520 <settings_nvs_backend_init>:
{
 1025520:	b573      	push	{r0, r1, r4, r5, r6, lr}
	cf->cf_nvs.flash_device = cf->flash_dev;
 1025522:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
{
 1025524:	4604      	mov	r4, r0
	cf->cf_nvs.flash_device = cf->flash_dev;
 1025526:	6303      	str	r3, [r0, #48]	; 0x30
	if (cf->cf_nvs.flash_device == NULL) {
 1025528:	b1c3      	cbz	r3, 102555c <settings_nvs_backend_init+0x3c>
	rc = nvs_mount(&cf->cf_nvs);
 102552a:	f100 0608 	add.w	r6, r0, #8
 102552e:	4630      	mov	r0, r6
 1025530:	f7df fc96 	bl	1004e60 <nvs_mount>
	if (rc) {
 1025534:	4605      	mov	r5, r0
 1025536:	b970      	cbnz	r0, 1025556 <settings_nvs_backend_init+0x36>
	rc = nvs_read(&cf->cf_nvs, NVS_NAMECNT_ID, &last_name_id,
 1025538:	2302      	movs	r3, #2
 102553a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 102553e:	4630      	mov	r0, r6
 1025540:	f10d 0206 	add.w	r2, sp, #6
 1025544:	f7ff fee9 	bl	102531a <nvs_read>
	if (rc < 0) {
 1025548:	2800      	cmp	r0, #0
		cf->last_name_id = last_name_id;
 102554a:	bfb4      	ite	lt
 102554c:	f44f 4300 	movlt.w	r3, #32768	; 0x8000
 1025550:	f8bd 3006 	ldrhge.w	r3, [sp, #6]
 1025554:	8723      	strh	r3, [r4, #56]	; 0x38
}
 1025556:	4628      	mov	r0, r5
 1025558:	b002      	add	sp, #8
 102555a:	bd70      	pop	{r4, r5, r6, pc}
		return -ENODEV;
 102555c:	f06f 0512 	mvn.w	r5, #18
 1025560:	e7f9      	b.n	1025556 <settings_nvs_backend_init+0x36>

01025562 <_copy>:

#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
 1025562:	b538      	push	{r3, r4, r5, lr}
 1025564:	460d      	mov	r5, r1
	if (from_len <= to_len) {
 1025566:	42ab      	cmp	r3, r5
{
 1025568:	4611      	mov	r1, r2
 102556a:	461c      	mov	r4, r3
	if (from_len <= to_len) {
 102556c:	d804      	bhi.n	1025578 <_copy+0x16>
		(void)memcpy(to, from, from_len);
 102556e:	461a      	mov	r2, r3
 1025570:	f001 fa00 	bl	1026974 <memcpy>
		return from_len;
	} else {
		return TC_CRYPTO_FAIL;
	}
}
 1025574:	4620      	mov	r0, r4
 1025576:	bd38      	pop	{r3, r4, r5, pc}
		return TC_CRYPTO_FAIL;
 1025578:	2400      	movs	r4, #0
 102557a:	e7fb      	b.n	1025574 <_copy+0x12>

0102557c <_set>:

void _set(void *to, uint8_t val, unsigned int len)
{
	(void)memset(to, val, len);
 102557c:	f001 ba05 	b.w	102698a <memset>

01025580 <_double_byte>:
/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
 1025580:	09c3      	lsrs	r3, r0, #7
 1025582:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 1025586:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 102558a:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
 102558e:	b2c0      	uxtb	r0, r0
 1025590:	4770      	bx	lr

01025592 <uECC_make_key>:
	}
	return 0;
}

int uECC_make_key(uint8_t *public_key, uint8_t *private_key, uECC_Curve curve)
{
 1025592:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1025596:	4606      	mov	r6, r0
 1025598:	4688      	mov	r8, r1
 102559a:	4614      	mov	r4, r2
 102559c:	2740      	movs	r7, #64	; 0x40
 102559e:	b0a9      	sub	sp, #164	; 0xa4
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
        		return 0;
		}

		/* computing modular reduction of _random (see FIPS 186.4 B.4.1): */
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
 10255a0:	f102 0924 	add.w	r9, r2, #36	; 0x24
		uECC_RNG_Function rng_function = uECC_get_rng();
 10255a4:	f7e0 fa74 	bl	1005a90 <uECC_get_rng>
		if (!rng_function ||
 10255a8:	4603      	mov	r3, r0
 10255aa:	2800      	cmp	r0, #0
 10255ac:	d03e      	beq.n	102562c <uECC_make_key+0x9a>
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
 10255ae:	2140      	movs	r1, #64	; 0x40
 10255b0:	a808      	add	r0, sp, #32
 10255b2:	4798      	blx	r3
		if (!rng_function ||
 10255b4:	b3d0      	cbz	r0, 102562c <uECC_make_key+0x9a>
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
 10255b6:	466d      	mov	r5, sp
 10255b8:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
 10255bc:	4628      	mov	r0, r5
 10255be:	f112 031f 	adds.w	r3, r2, #31
 10255c2:	bf48      	it	mi
 10255c4:	f102 033e 	addmi.w	r3, r2, #62	; 0x3e
 10255c8:	a908      	add	r1, sp, #32
 10255ca:	464a      	mov	r2, r9
 10255cc:	f343 1347 	sbfx	r3, r3, #5, #8
 10255d0:	f000 f9f4 	bl	10259bc <uECC_vli_mmod>

		/* Computing public-key from private: */
		if (EccPoint_compute_public_key(_public, _private, curve)) {
 10255d4:	4622      	mov	r2, r4
 10255d6:	4629      	mov	r1, r5
 10255d8:	a818      	add	r0, sp, #96	; 0x60
 10255da:	f000 fe07 	bl	10261ec <EccPoint_compute_public_key>
 10255de:	b318      	cbz	r0, 1025628 <uECC_make_key+0x96>

			/* Converting buffers to correct bit order: */
			uECC_vli_nativeToBytes(private_key,
					       BITS_TO_BYTES(curve->num_n_bits),
 10255e0:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
			uECC_vli_nativeToBytes(private_key,
 10255e4:	462a      	mov	r2, r5
 10255e6:	1dd9      	adds	r1, r3, #7
 10255e8:	bf48      	it	mi
 10255ea:	f103 010e 	addmi.w	r1, r3, #14
 10255ee:	4640      	mov	r0, r8
 10255f0:	10c9      	asrs	r1, r1, #3
 10255f2:	f000 fe23 	bl	102623c <uECC_vli_nativeToBytes>
					       _private);
			uECC_vli_nativeToBytes(public_key,
 10255f6:	4630      	mov	r0, r6
 10255f8:	f994 1001 	ldrsb.w	r1, [r4, #1]
 10255fc:	aa18      	add	r2, sp, #96	; 0x60
 10255fe:	f000 fe1d 	bl	102623c <uECC_vli_nativeToBytes>
					       curve->num_bytes,
					       _public);
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
 1025602:	f994 1001 	ldrsb.w	r1, [r4, #1]
 					       curve->num_bytes,
					       _public + curve->num_words);
 1025606:	f994 2000 	ldrsb.w	r2, [r4]
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
 102560a:	ab18      	add	r3, sp, #96	; 0x60
 102560c:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 1025610:	1870      	adds	r0, r6, r1
 1025612:	f000 fe13 	bl	102623c <uECC_vli_nativeToBytes>
#ifdef TINYCRYPT_ARCH_HAS_SET_SECURE
extern void _set_secure(void *to, uint8_t val, unsigned int len);
#else /* ! TINYCRYPT_ARCH_HAS_SET_SECURE */
static inline void _set_secure(void *to, uint8_t val, unsigned int len)
{
  (void) memset(to, val, len);
 1025616:	2220      	movs	r2, #32
 1025618:	2100      	movs	r1, #0
 102561a:	4628      	mov	r0, r5
 102561c:	f001 f9b5 	bl	102698a <memset>

			/* erasing temporary buffer that stored secret: */
			_set_secure(_private, 0, NUM_ECC_BYTES);

      			return 1;
 1025620:	2001      	movs	r0, #1
    		}
  	}
	return 0;
}
 1025622:	b029      	add	sp, #164	; 0xa4
 1025624:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
 1025628:	3f01      	subs	r7, #1
 102562a:	d1bb      	bne.n	10255a4 <uECC_make_key+0x12>
        		return 0;
 102562c:	2000      	movs	r0, #0
 102562e:	e7f8      	b.n	1025622 <uECC_make_key+0x90>

01025630 <uECC_shared_secret>:

int uECC_shared_secret(const uint8_t *public_key, const uint8_t *private_key,
		       uint8_t *secret, uECC_Curve curve)
{
 1025630:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1025634:	4681      	mov	r9, r0
 1025636:	461c      	mov	r4, r3
	uECC_word_t tmp[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {_private, tmp};
	uECC_word_t *initial_Z = 0;
	uECC_word_t carry;
	wordcount_t num_words = curve->num_words;
	wordcount_t num_bytes = curve->num_bytes;
 1025638:	f993 7001 	ldrsb.w	r7, [r3, #1]
	wordcount_t num_words = curve->num_words;
 102563c:	f993 a000 	ldrsb.w	sl, [r3]
	int r;

	/* Converting buffers to correct bit order: */
	uECC_vli_bytesToNative(_private,
      			       private_key,
			       BITS_TO_BYTES(curve->num_n_bits));
 1025640:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
{
 1025644:	b0a4      	sub	sp, #144	; 0x90
 1025646:	4690      	mov	r8, r2
	uECC_vli_bytesToNative(_private,
 1025648:	1dda      	adds	r2, r3, #7
 102564a:	bf48      	it	mi
 102564c:	f103 020e 	addmi.w	r2, r3, #14
	uECC_word_t *p2[2] = {_private, tmp};
 1025650:	ad04      	add	r5, sp, #16
	uECC_vli_bytesToNative(_private,
 1025652:	4628      	mov	r0, r5
	uECC_word_t *p2[2] = {_private, tmp};
 1025654:	ae0c      	add	r6, sp, #48	; 0x30
	uECC_vli_bytesToNative(_private,
 1025656:	10d2      	asrs	r2, r2, #3
	uECC_word_t *p2[2] = {_private, tmp};
 1025658:	9502      	str	r5, [sp, #8]
 102565a:	9603      	str	r6, [sp, #12]
	uECC_vli_bytesToNative(_private,
 102565c:	f000 fe02 	bl	1026264 <uECC_vli_bytesToNative>
	uECC_vli_bytesToNative(_public,
 1025660:	463a      	mov	r2, r7
 1025662:	4649      	mov	r1, r9
 1025664:	a814      	add	r0, sp, #80	; 0x50
 1025666:	f000 fdfd 	bl	1026264 <uECC_vli_bytesToNative>
      			       public_key,
			       num_bytes);
	uECC_vli_bytesToNative(_public + num_words,
 102566a:	ab14      	add	r3, sp, #80	; 0x50
 102566c:	eb09 0107 	add.w	r1, r9, r7
 1025670:	eb03 008a 	add.w	r0, r3, sl, lsl #2
 1025674:	463a      	mov	r2, r7
 1025676:	f000 fdf5 	bl	1026264 <uECC_vli_bytesToNative>
			       public_key + num_bytes,
			       num_bytes);

	/* Regularize the bitcount for the private key so that attackers cannot use a
	 * side channel attack to learn the number of leading zeros. */
	carry = regularize_k(_private, _private, tmp, curve);
 102567a:	4623      	mov	r3, r4
 102567c:	4632      	mov	r2, r6
 102567e:	4629      	mov	r1, r5
 1025680:	4628      	mov	r0, r5
 1025682:	f000 fd87 	bl	1026194 <regularize_k>
			goto clear_and_out;
    		}
    		initial_Z = p2[carry];
  	}

	EccPoint_mult(_public, _public, p2[!carry], initial_Z, curve->num_n_bits + 1,
 1025686:	fab0 f380 	clz	r3, r0
 102568a:	9401      	str	r4, [sp, #4]
 102568c:	aa24      	add	r2, sp, #144	; 0x90
 102568e:	095b      	lsrs	r3, r3, #5
 1025690:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 1025694:	8863      	ldrh	r3, [r4, #2]
 1025696:	3301      	adds	r3, #1
 1025698:	b21b      	sxth	r3, r3
 102569a:	9300      	str	r3, [sp, #0]
 102569c:	f851 2c88 	ldr.w	r2, [r1, #-136]
 10256a0:	a914      	add	r1, sp, #80	; 0x50
 10256a2:	2300      	movs	r3, #0
 10256a4:	4608      	mov	r0, r1
 10256a6:	f000 fcad 	bl	1026004 <EccPoint_mult>
		      curve);

	uECC_vli_nativeToBytes(secret, num_bytes, _public);
 10256aa:	aa14      	add	r2, sp, #80	; 0x50
 10256ac:	4639      	mov	r1, r7
 10256ae:	4640      	mov	r0, r8
 10256b0:	f000 fdc4 	bl	102623c <uECC_vli_nativeToBytes>
	r = !EccPoint_isZero(_public, curve);
 10256b4:	4621      	mov	r1, r4
 10256b6:	a814      	add	r0, sp, #80	; 0x50
 10256b8:	f000 fc19 	bl	1025eee <EccPoint_isZero>
 10256bc:	af02      	add	r7, sp, #8
 10256be:	4604      	mov	r4, r0
 10256c0:	2208      	movs	r2, #8
 10256c2:	2100      	movs	r1, #0
 10256c4:	4638      	mov	r0, r7
 10256c6:	f001 f960 	bl	102698a <memset>
 10256ca:	2220      	movs	r2, #32
 10256cc:	2100      	movs	r1, #0
 10256ce:	4630      	mov	r0, r6
 10256d0:	f001 f95b 	bl	102698a <memset>
 10256d4:	2220      	movs	r2, #32
 10256d6:	2100      	movs	r1, #0
 10256d8:	4628      	mov	r0, r5
 10256da:	f001 f956 	bl	102698a <memset>
	_set_secure(p2, 0, sizeof(p2));
	_set_secure(tmp, 0, sizeof(tmp));
	_set_secure(_private, 0, sizeof(_private));

	return r;
}
 10256de:	fab4 f084 	clz	r0, r4
 10256e2:	0940      	lsrs	r0, r0, #5
 10256e4:	b024      	add	sp, #144	; 0x90
 10256e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

010256ea <uECC_vli_add>:
{
 10256ea:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
 10256ec:	2400      	movs	r4, #0
{
 10256ee:	4606      	mov	r6, r0
	uECC_word_t carry = 0;
 10256f0:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
 10256f2:	b265      	sxtb	r5, r4
 10256f4:	42ab      	cmp	r3, r5
 10256f6:	dc00      	bgt.n	10256fa <uECC_vli_add+0x10>
}
 10256f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t sum = left[i] + right[i] + carry;
 10256fa:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
 10256fe:	f852 5024 	ldr.w	r5, [r2, r4, lsl #2]
 1025702:	443d      	add	r5, r7
 1025704:	4405      	add	r5, r0
	return (p_true*(cond)) | (p_false*(!cond));
 1025706:	42af      	cmp	r7, r5
 1025708:	f000 0001 	and.w	r0, r0, #1
 102570c:	bf18      	it	ne
 102570e:	2000      	movne	r0, #0
		result[i] = sum;
 1025710:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
 1025714:	bf88      	it	hi
 1025716:	f040 0001 	orrhi.w	r0, r0, #1
	for (i = 0; i < num_words; ++i) {
 102571a:	3401      	adds	r4, #1
 102571c:	e7e9      	b.n	10256f2 <uECC_vli_add+0x8>

0102571e <uECC_vli_rshift1>:
	uECC_word_t carry = 0;
 102571e:	2300      	movs	r3, #0
	vli += num_words;
 1025720:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	while (vli-- > end) {
 1025724:	4288      	cmp	r0, r1
 1025726:	d300      	bcc.n	102572a <uECC_vli_rshift1+0xc>
}
 1025728:	4770      	bx	lr
		uECC_word_t temp = *vli;
 102572a:	f851 2d04 	ldr.w	r2, [r1, #-4]!
		*vli = (temp >> 1) | carry;
 102572e:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
 1025732:	600b      	str	r3, [r1, #0]
		carry = temp << (uECC_WORD_BITS - 1);
 1025734:	07d3      	lsls	r3, r2, #31
 1025736:	e7f5      	b.n	1025724 <uECC_vli_rshift1+0x6>

01025738 <vli_modInv_update>:
{
 1025738:	b570      	push	{r4, r5, r6, lr}
	if (!EVEN(uv)) {
 102573a:	6803      	ldr	r3, [r0, #0]
{
 102573c:	4605      	mov	r5, r0
	if (!EVEN(uv)) {
 102573e:	07db      	lsls	r3, r3, #31
{
 1025740:	4614      	mov	r4, r2
	if (!EVEN(uv)) {
 1025742:	d404      	bmi.n	102574e <vli_modInv_update+0x16>
}
 1025744:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	uECC_vli_rshift1(uv, num_words);
 1025748:	4611      	mov	r1, r2
 102574a:	f7ff bfe8 	b.w	102571e <uECC_vli_rshift1>
		carry = uECC_vli_add(uv, uv, mod, num_words);
 102574e:	4613      	mov	r3, r2
 1025750:	460a      	mov	r2, r1
 1025752:	4601      	mov	r1, r0
 1025754:	f7ff ffc9 	bl	10256ea <uECC_vli_add>
 1025758:	4606      	mov	r6, r0
	uECC_vli_rshift1(uv, num_words);
 102575a:	4621      	mov	r1, r4
 102575c:	4628      	mov	r0, r5
 102575e:	f7ff ffde 	bl	102571e <uECC_vli_rshift1>
	if (carry) {
 1025762:	b146      	cbz	r6, 1025776 <vli_modInv_update+0x3e>
		uv[num_words - 1] |= HIGH_BIT_SET;
 1025764:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 1025768:	3c01      	subs	r4, #1
 102576a:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 102576e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 1025772:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
}
 1025776:	bd70      	pop	{r4, r5, r6, pc}

01025778 <uECC_vli_mult>:
	for (k = 0; k < num_words; ++k) {
 1025778:	f04f 0c00 	mov.w	ip, #0
{
 102577c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uECC_word_t r1 = 0;
 1025780:	4666      	mov	r6, ip
	uECC_word_t r0 = 0;
 1025782:	4664      	mov	r4, ip
	for (k = 0; k < num_words; ++k) {
 1025784:	fa4f f98c 	sxtb.w	r9, ip
 1025788:	454b      	cmp	r3, r9
 102578a:	dc14      	bgt.n	10257b6 <uECC_vli_mult+0x3e>
	for (k = num_words; k < num_words * 2 - 1; ++k) {
 102578c:	f04f 0900 	mov.w	r9, #0
 1025790:	005d      	lsls	r5, r3, #1
 1025792:	3d01      	subs	r5, #1
 1025794:	9501      	str	r5, [sp, #4]
 1025796:	fa5f f589 	uxtb.w	r5, r9
 102579a:	9f01      	ldr	r7, [sp, #4]
 102579c:	eb05 0e03 	add.w	lr, r5, r3
 10257a0:	fa4f fe8e 	sxtb.w	lr, lr
 10257a4:	45be      	cmp	lr, r7
 10257a6:	db28      	blt.n	10257fa <uECC_vli_mult+0x82>
	result[num_words * 2 - 1] = r0;
 10257a8:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
 10257ac:	f840 4c04 	str.w	r4, [r0, #-4]
}
 10257b0:	b003      	add	sp, #12
 10257b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (k = 0; k < num_words; ++k) {
 10257b6:	f04f 0e00 	mov.w	lr, #0
 10257ba:	46f0      	mov	r8, lr
 10257bc:	eb02 0a8c 	add.w	sl, r2, ip, lsl #2
	uECC_dword_t p = (uECC_dword_t)a * b;
 10257c0:	f851 702e 	ldr.w	r7, [r1, lr, lsl #2]
			muladd(left[i], right[k - i], &r0, &r1, &r2);
 10257c4:	f85a 5904 	ldr.w	r5, [sl], #-4
	r01 += p;
 10257c8:	f04f 0b00 	mov.w	fp, #0
	uECC_dword_t p = (uECC_dword_t)a * b;
 10257cc:	fba5 5707 	umull	r5, r7, r5, r7
 10257d0:	192d      	adds	r5, r5, r4
 10257d2:	4177      	adcs	r7, r6
 10257d4:	bf28      	it	cs
 10257d6:	f04f 0b01 	movcs.w	fp, #1
		for (i = 0; i <= k; ++i) {
 10257da:	f10e 0e01 	add.w	lr, lr, #1
	*r0 = (uECC_word_t)r01;
 10257de:	462c      	mov	r4, r5
		for (i = 0; i <= k; ++i) {
 10257e0:	fa4f f58e 	sxtb.w	r5, lr
 10257e4:	454d      	cmp	r5, r9
	*r1 = r01 >> uECC_WORD_BITS;
 10257e6:	463e      	mov	r6, r7
	*r2 += (r01 < p);
 10257e8:	44d8      	add	r8, fp
		for (i = 0; i <= k; ++i) {
 10257ea:	dde9      	ble.n	10257c0 <uECC_vli_mult+0x48>
		result[k] = r0;
 10257ec:	f840 402c 	str.w	r4, [r0, ip, lsl #2]
	*r2 += (r01 < p);
 10257f0:	4646      	mov	r6, r8
	*r1 = r01 >> uECC_WORD_BITS;
 10257f2:	463c      	mov	r4, r7
 10257f4:	f10c 0c01 	add.w	ip, ip, #1
 10257f8:	e7c4      	b.n	1025784 <uECC_vli_mult+0xc>
		for (i = (k + 1) - num_words; i < num_words; ++i) {
 10257fa:	46b0      	mov	r8, r6
 10257fc:	2600      	movs	r6, #0
 10257fe:	3501      	adds	r5, #1
 1025800:	b26d      	sxtb	r5, r5
 1025802:	eb02 0a8e 	add.w	sl, r2, lr, lsl #2
 1025806:	b26f      	sxtb	r7, r5
 1025808:	42bb      	cmp	r3, r7
 102580a:	dc05      	bgt.n	1025818 <uECC_vli_mult+0xa0>
		result[k] = r0;
 102580c:	f840 402e 	str.w	r4, [r0, lr, lsl #2]
	for (k = num_words; k < num_words * 2 - 1; ++k) {
 1025810:	f109 0901 	add.w	r9, r9, #1
		result[k] = r0;
 1025814:	4644      	mov	r4, r8
 1025816:	e7be      	b.n	1025796 <uECC_vli_mult+0x1e>
			muladd(left[i], right[k - i], &r0, &r1, &r2);
 1025818:	f06f 0703 	mvn.w	r7, #3
 102581c:	436f      	muls	r7, r5
	uECC_dword_t p = (uECC_dword_t)a * b;
 102581e:	f851 c025 	ldr.w	ip, [r1, r5, lsl #2]
 1025822:	f85a 7007 	ldr.w	r7, [sl, r7]
 1025826:	f04f 0b00 	mov.w	fp, #0
 102582a:	fba7 7c0c 	umull	r7, ip, r7, ip
 102582e:	193f      	adds	r7, r7, r4
 1025830:	eb5c 0c08 	adcs.w	ip, ip, r8
 1025834:	bf28      	it	cs
 1025836:	f04f 0b01 	movcs.w	fp, #1
	*r1 = r01 >> uECC_WORD_BITS;
 102583a:	46e0      	mov	r8, ip
	*r0 = (uECC_word_t)r01;
 102583c:	463c      	mov	r4, r7
	*r2 += (r01 < p);
 102583e:	445e      	add	r6, fp
		for (i = (k + 1) - num_words; i < num_words; ++i) {
 1025840:	3501      	adds	r5, #1
 1025842:	e7e0      	b.n	1025806 <uECC_vli_mult+0x8e>

01025844 <uECC_vli_clear>:
	for (i = 0; i < num_words; ++i) {
 1025844:	2300      	movs	r3, #0
{
 1025846:	b510      	push	{r4, lr}
		 vli[i] = 0;
 1025848:	461c      	mov	r4, r3
	for (i = 0; i < num_words; ++i) {
 102584a:	b25a      	sxtb	r2, r3
 102584c:	4291      	cmp	r1, r2
 102584e:	dc00      	bgt.n	1025852 <uECC_vli_clear+0xe>
}
 1025850:	bd10      	pop	{r4, pc}
		 vli[i] = 0;
 1025852:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
 1025856:	3301      	adds	r3, #1
 1025858:	e7f7      	b.n	102584a <uECC_vli_clear+0x6>

0102585a <uECC_vli_isZero>:
	for (i = 0; i < num_words; ++i) {
 102585a:	2300      	movs	r3, #0
	uECC_word_t bits = 0;
 102585c:	461a      	mov	r2, r3
{
 102585e:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
 1025860:	b25c      	sxtb	r4, r3
 1025862:	42a1      	cmp	r1, r4
 1025864:	dc03      	bgt.n	102586e <uECC_vli_isZero+0x14>
}
 1025866:	fab2 f082 	clz	r0, r2
 102586a:	0940      	lsrs	r0, r0, #5
 102586c:	bd10      	pop	{r4, pc}
		bits |= vli[i];
 102586e:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
 1025872:	3301      	adds	r3, #1
 1025874:	4322      	orrs	r2, r4
	for (i = 0; i < num_words; ++i) {
 1025876:	e7f3      	b.n	1025860 <uECC_vli_isZero+0x6>

01025878 <uECC_vli_testBit>:
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
 1025878:	2301      	movs	r3, #1
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 102587a:	114a      	asrs	r2, r1, #5
 102587c:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
 1025880:	f001 011f 	and.w	r1, r1, #31
 1025884:	408b      	lsls	r3, r1
}
 1025886:	4018      	ands	r0, r3
 1025888:	4770      	bx	lr

0102588a <uECC_vli_numBits>:
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
 102588a:	1e4b      	subs	r3, r1, #1
{
 102588c:	b510      	push	{r4, lr}
 102588e:	b25b      	sxtb	r3, r3
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
 1025890:	1d04      	adds	r4, r0, #4
 1025892:	061a      	lsls	r2, r3, #24
 1025894:	d403      	bmi.n	102589e <uECC_vli_numBits+0x14>
 1025896:	1e5a      	subs	r2, r3, #1
 1025898:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
 102589c:	b171      	cbz	r1, 10258bc <uECC_vli_numBits+0x32>
	return (i + 1);
 102589e:	3301      	adds	r3, #1
 10258a0:	b25b      	sxtb	r3, r3
	if (num_digits == 0) {
 10258a2:	b183      	cbz	r3, 10258c6 <uECC_vli_numBits+0x3c>
	digit = vli[num_digits - 1];
 10258a4:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
 10258a8:	3a01      	subs	r2, #1
 10258aa:	f850 1022 	ldr.w	r1, [r0, r2, lsl #2]
	for (i = 0; digit; ++i) {
 10258ae:	2200      	movs	r2, #0
 10258b0:	b931      	cbnz	r1, 10258c0 <uECC_vli_numBits+0x36>
	return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
 10258b2:	3b01      	subs	r3, #1
 10258b4:	eb02 1243 	add.w	r2, r2, r3, lsl #5
 10258b8:	b210      	sxth	r0, r2
}
 10258ba:	bd10      	pop	{r4, pc}
 10258bc:	4613      	mov	r3, r2
 10258be:	e7e8      	b.n	1025892 <uECC_vli_numBits+0x8>
		digit >>= 1;
 10258c0:	0849      	lsrs	r1, r1, #1
	for (i = 0; digit; ++i) {
 10258c2:	3201      	adds	r2, #1
 10258c4:	e7f4      	b.n	10258b0 <uECC_vli_numBits+0x26>
		return 0;
 10258c6:	4618      	mov	r0, r3
 10258c8:	e7f7      	b.n	10258ba <uECC_vli_numBits+0x30>

010258ca <uECC_vli_set>:
	for (i = 0; i < num_words; ++i) {
 10258ca:	2300      	movs	r3, #0
{
 10258cc:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
 10258ce:	b25c      	sxtb	r4, r3
 10258d0:	42a2      	cmp	r2, r4
 10258d2:	dc00      	bgt.n	10258d6 <uECC_vli_set+0xc>
}
 10258d4:	bd10      	pop	{r4, pc}
		dest[i] = src[i];
 10258d6:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
 10258da:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
 10258de:	3301      	adds	r3, #1
 10258e0:	e7f5      	b.n	10258ce <uECC_vli_set+0x4>

010258e2 <uECC_vli_cmp_unsafe>:
{
 10258e2:	b510      	push	{r4, lr}
	for (i = num_words - 1; i >= 0; --i) {
 10258e4:	3a01      	subs	r2, #1
 10258e6:	b252      	sxtb	r2, r2
 10258e8:	0613      	lsls	r3, r2, #24
 10258ea:	d501      	bpl.n	10258f0 <uECC_vli_cmp_unsafe+0xe>
	return 0;
 10258ec:	2000      	movs	r0, #0
}
 10258ee:	bd10      	pop	{r4, pc}
		if (left[i] > right[i]) {
 10258f0:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
 10258f4:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
 10258f8:	429c      	cmp	r4, r3
 10258fa:	d805      	bhi.n	1025908 <uECC_vli_cmp_unsafe+0x26>
		} else if (left[i] < right[i]) {
 10258fc:	f102 32ff 	add.w	r2, r2, #4294967295
 1025900:	d2f2      	bcs.n	10258e8 <uECC_vli_cmp_unsafe+0x6>
			return -1;
 1025902:	f04f 30ff 	mov.w	r0, #4294967295
 1025906:	e7f2      	b.n	10258ee <uECC_vli_cmp_unsafe+0xc>
			return 1;
 1025908:	2001      	movs	r0, #1
 102590a:	e7f0      	b.n	10258ee <uECC_vli_cmp_unsafe+0xc>

0102590c <uECC_vli_equal>:
	uECC_word_t diff = 0;
 102590c:	2300      	movs	r3, #0
{
 102590e:	b530      	push	{r4, r5, lr}
	for (i = num_words - 1; i >= 0; --i) {
 1025910:	3a01      	subs	r2, #1
 1025912:	b252      	sxtb	r2, r2
 1025914:	0614      	lsls	r4, r2, #24
 1025916:	d503      	bpl.n	1025920 <uECC_vli_equal+0x14>
}
 1025918:	1e18      	subs	r0, r3, #0
 102591a:	bf18      	it	ne
 102591c:	2001      	movne	r0, #1
 102591e:	bd30      	pop	{r4, r5, pc}
		diff |= (left[i] ^ right[i]);
 1025920:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
 1025924:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
 1025928:	3a01      	subs	r2, #1
 102592a:	406c      	eors	r4, r5
 102592c:	4323      	orrs	r3, r4
	for (i = num_words - 1; i >= 0; --i) {
 102592e:	e7f1      	b.n	1025914 <uECC_vli_equal+0x8>

01025930 <uECC_vli_sub>:
{
 1025930:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
 1025932:	2400      	movs	r4, #0
{
 1025934:	4606      	mov	r6, r0
 1025936:	469c      	mov	ip, r3
	uECC_word_t borrow = 0;
 1025938:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
 102593a:	b265      	sxtb	r5, r4
 102593c:	4565      	cmp	r5, ip
 102593e:	db00      	blt.n	1025942 <uECC_vli_sub+0x12>
}
 1025940:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t diff = left[i] - right[i] - borrow;
 1025942:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
 1025946:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
 102594a:	1a3d      	subs	r5, r7, r0
 102594c:	1aed      	subs	r5, r5, r3
	return (p_true*(cond)) | (p_false*(!cond));
 102594e:	42af      	cmp	r7, r5
 1025950:	f000 0001 	and.w	r0, r0, #1
 1025954:	bf18      	it	ne
 1025956:	2000      	movne	r0, #0
		result[i] = diff;
 1025958:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
 102595c:	bf38      	it	cc
 102595e:	f040 0001 	orrcc.w	r0, r0, #1
	for (i = 0; i < num_words; ++i) {
 1025962:	3401      	adds	r4, #1
 1025964:	e7e9      	b.n	102593a <uECC_vli_sub+0xa>

01025966 <uECC_vli_modAdd>:
{
 1025966:	b570      	push	{r4, r5, r6, lr}
 1025968:	f99d 6010 	ldrsb.w	r6, [sp, #16]
 102596c:	461d      	mov	r5, r3
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
 102596e:	4633      	mov	r3, r6
{
 1025970:	4604      	mov	r4, r0
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
 1025972:	f7ff feba 	bl	10256ea <uECC_vli_add>
	if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
 1025976:	b930      	cbnz	r0, 1025986 <uECC_vli_modAdd+0x20>
 1025978:	4632      	mov	r2, r6
 102597a:	4621      	mov	r1, r4
 102597c:	4628      	mov	r0, r5
 102597e:	f7ff ffb0 	bl	10258e2 <uECC_vli_cmp_unsafe>
 1025982:	2801      	cmp	r0, #1
 1025984:	d007      	beq.n	1025996 <uECC_vli_modAdd+0x30>
		uECC_vli_sub(result, result, mod, num_words);
 1025986:	4633      	mov	r3, r6
 1025988:	462a      	mov	r2, r5
 102598a:	4621      	mov	r1, r4
 102598c:	4620      	mov	r0, r4
}
 102598e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_sub(result, result, mod, num_words);
 1025992:	f7ff bfcd 	b.w	1025930 <uECC_vli_sub>
}
 1025996:	bd70      	pop	{r4, r5, r6, pc}

01025998 <uECC_vli_modSub>:
{
 1025998:	b570      	push	{r4, r5, r6, lr}
 102599a:	f99d 6010 	ldrsb.w	r6, [sp, #16]
 102599e:	461d      	mov	r5, r3
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
 10259a0:	4633      	mov	r3, r6
{
 10259a2:	4604      	mov	r4, r0
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
 10259a4:	f7ff ffc4 	bl	1025930 <uECC_vli_sub>
	if (l_borrow) {
 10259a8:	b138      	cbz	r0, 10259ba <uECC_vli_modSub+0x22>
		uECC_vli_add(result, result, mod, num_words);
 10259aa:	4633      	mov	r3, r6
 10259ac:	462a      	mov	r2, r5
 10259ae:	4621      	mov	r1, r4
 10259b0:	4620      	mov	r0, r4
}
 10259b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_add(result, result, mod, num_words);
 10259b6:	f7ff be98 	b.w	10256ea <uECC_vli_add>
}
 10259ba:	bd70      	pop	{r4, r5, r6, pc}

010259bc <uECC_vli_mmod>:
{
 10259bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10259c0:	461d      	mov	r5, r3
 10259c2:	b0a5      	sub	sp, #148	; 0x94
	uECC_word_t *v[2] = {tmp, product};
 10259c4:	ab14      	add	r3, sp, #80	; 0x50
 10259c6:	e9cd 3102 	strd	r3, r1, [sp, #8]
{
 10259ca:	9001      	str	r0, [sp, #4]
			   uECC_vli_numBits(mod, num_words);
 10259cc:	4629      	mov	r1, r5
 10259ce:	4610      	mov	r0, r2
{
 10259d0:	4617      	mov	r7, r2
			   uECC_vli_numBits(mod, num_words);
 10259d2:	f7ff ff5a 	bl	102588a <uECC_vli_numBits>
	bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) -
 10259d6:	ebc0 1485 	rsb	r4, r0, r5, lsl #6
 10259da:	b224      	sxth	r4, r4
	wordcount_t word_shift = shift / uECC_WORD_BITS;
 10259dc:	4621      	mov	r1, r4
 10259de:	2c00      	cmp	r4, #0
 10259e0:	bfb8      	it	lt
 10259e2:	f104 011f 	addlt.w	r1, r4, #31
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
 10259e6:	4263      	negs	r3, r4
 10259e8:	f003 031f 	and.w	r3, r3, #31
	wordcount_t word_shift = shift / uECC_WORD_BITS;
 10259ec:	f341 1147 	sbfx	r1, r1, #5, #8
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
 10259f0:	f004 061f 	and.w	r6, r4, #31
	uECC_vli_clear(mod_multiple, word_shift);
 10259f4:	a804      	add	r0, sp, #16
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
 10259f6:	bf58      	it	pl
 10259f8:	425e      	negpl	r6, r3
	uECC_vli_clear(mod_multiple, word_shift);
 10259fa:	f7ff ff23 	bl	1025844 <uECC_vli_clear>
	if (bit_shift > 0) {
 10259fe:	2e00      	cmp	r6, #0
 1025a00:	ea4f 0081 	mov.w	r0, r1, lsl #2
 1025a04:	dd2d      	ble.n	1025a62 <uECC_vli_mmod+0xa6>
	uECC_word_t carry = 0;
 1025a06:	2200      	movs	r2, #0
 1025a08:	ab04      	add	r3, sp, #16
 1025a0a:	4418      	add	r0, r3
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 1025a0c:	4613      	mov	r3, r2
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
 1025a0e:	f1c6 0e20 	rsb	lr, r6, #32
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 1025a12:	429d      	cmp	r5, r3
 1025a14:	d81a      	bhi.n	1025a4c <uECC_vli_mmod+0x90>
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1025a16:	2601      	movs	r6, #1
 1025a18:	ab04      	add	r3, sp, #16
 1025a1a:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 1025a1e:	9300      	str	r3, [sp, #0]
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 1025a20:	1e6f      	subs	r7, r5, #1
 1025a22:	ab24      	add	r3, sp, #144	; 0x90
		for (i = 0; i < num_words * 2; ++i) {
 1025a24:	ea4f 0845 	mov.w	r8, r5, lsl #1
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1025a28:	ea4f 0985 	mov.w	r9, r5, lsl #2
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 1025a2c:	eb03 0787 	add.w	r7, r3, r7, lsl #2
	for (index = 1; shift >= 0; --shift) {
 1025a30:	2c00      	cmp	r4, #0
 1025a32:	da53      	bge.n	1025adc <uECC_vli_mmod+0x120>
	uECC_vli_set(result, v[index], num_words);
 1025a34:	ab24      	add	r3, sp, #144	; 0x90
 1025a36:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 1025a3a:	462a      	mov	r2, r5
 1025a3c:	f856 1c88 	ldr.w	r1, [r6, #-136]
 1025a40:	9801      	ldr	r0, [sp, #4]
 1025a42:	f7ff ff42 	bl	10258ca <uECC_vli_set>
}
 1025a46:	b025      	add	sp, #148	; 0x94
 1025a48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
 1025a4c:	f857 c023 	ldr.w	ip, [r7, r3, lsl #2]
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 1025a50:	3301      	adds	r3, #1
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
 1025a52:	fa0c f106 	lsl.w	r1, ip, r6
 1025a56:	430a      	orrs	r2, r1
 1025a58:	f840 2b04 	str.w	r2, [r0], #4
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
 1025a5c:	fa2c f20e 	lsr.w	r2, ip, lr
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 1025a60:	e7d7      	b.n	1025a12 <uECC_vli_mmod+0x56>
		uECC_vli_set(mod_multiple + word_shift, mod, num_words);
 1025a62:	ab04      	add	r3, sp, #16
 1025a64:	462a      	mov	r2, r5
 1025a66:	4639      	mov	r1, r7
 1025a68:	4418      	add	r0, r3
 1025a6a:	f7ff ff2e 	bl	10258ca <uECC_vli_set>
 1025a6e:	e7d2      	b.n	1025a16 <uECC_vli_mmod+0x5a>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 1025a70:	f85a 3c88 	ldr.w	r3, [sl, #-136]
 1025a74:	f10c 0c01 	add.w	ip, ip, #1
 1025a78:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 1025a7c:	ab24      	add	r3, sp, #144	; 0x90
 1025a7e:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 1025a82:	f853 3c80 	ldr.w	r3, [r3, #-128]
 1025a86:	440b      	add	r3, r1
 1025a88:	1ad3      	subs	r3, r2, r3
 1025a8a:	bf34      	ite	cc
 1025a8c:	f04f 0b01 	movcc.w	fp, #1
 1025a90:	f04f 0b00 	movcs.w	fp, #0
			if (diff != v[index][i]) {
 1025a94:	429a      	cmp	r2, r3
				borrow = (diff > v[index][i]);
 1025a96:	bf18      	it	ne
 1025a98:	4659      	movne	r1, fp
			v[1 - index][i] = diff;
 1025a9a:	f85e 2c88 	ldr.w	r2, [lr, #-136]
 1025a9e:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
		for (i = 0; i < num_words * 2; ++i) {
 1025aa2:	fa4f f08c 	sxtb.w	r0, ip
 1025aa6:	4540      	cmp	r0, r8
 1025aa8:	dbe2      	blt.n	1025a70 <uECC_vli_mmod+0xb4>
		index = !(index ^ borrow);
 1025aaa:	1a73      	subs	r3, r6, r1
 1025aac:	425e      	negs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
 1025aae:	4629      	mov	r1, r5
 1025ab0:	a804      	add	r0, sp, #16
		index = !(index ^ borrow);
 1025ab2:	415e      	adcs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
 1025ab4:	f7ff fe33 	bl	102571e <uECC_vli_rshift1>
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 1025ab8:	f109 0390 	add.w	r3, r9, #144	; 0x90
 1025abc:	446b      	add	r3, sp
 1025abe:	f853 2c80 	ldr.w	r2, [r3, #-128]
 1025ac2:	f857 3c80 	ldr.w	r3, [r7, #-128]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1025ac6:	4629      	mov	r1, r5
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 1025ac8:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1025acc:	9800      	ldr	r0, [sp, #0]
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 1025ace:	f847 3c80 	str.w	r3, [r7, #-128]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1025ad2:	3c01      	subs	r4, #1
 1025ad4:	f7ff fe23 	bl	102571e <uECC_vli_rshift1>
	for (index = 1; shift >= 0; --shift) {
 1025ad8:	b224      	sxth	r4, r4
 1025ada:	e7a9      	b.n	1025a30 <uECC_vli_mmod+0x74>
 1025adc:	f04f 0c00 	mov.w	ip, #0
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 1025ae0:	ab24      	add	r3, sp, #144	; 0x90
			v[1 - index][i] = diff;
 1025ae2:	f1c6 0e01 	rsb	lr, r6, #1
		uECC_word_t borrow = 0;
 1025ae6:	4661      	mov	r1, ip
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 1025ae8:	eb03 0a86 	add.w	sl, r3, r6, lsl #2
			v[1 - index][i] = diff;
 1025aec:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
 1025af0:	e7d7      	b.n	1025aa2 <uECC_vli_mmod+0xe6>

01025af2 <uECC_vli_modMult_fast>:
{
 1025af2:	b530      	push	{r4, r5, lr}
 1025af4:	4605      	mov	r5, r0
 1025af6:	461c      	mov	r4, r3
 1025af8:	b091      	sub	sp, #68	; 0x44
	uECC_vli_mult(product, left, right, curve->num_words);
 1025afa:	4668      	mov	r0, sp
 1025afc:	f993 3000 	ldrsb.w	r3, [r3]
 1025b00:	f7ff fe3a 	bl	1025778 <uECC_vli_mult>
	curve->mmod_fast(result, product);
 1025b04:	4669      	mov	r1, sp
 1025b06:	4628      	mov	r0, r5
 1025b08:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 1025b0c:	4798      	blx	r3
}
 1025b0e:	b011      	add	sp, #68	; 0x44
 1025b10:	bd30      	pop	{r4, r5, pc}

01025b12 <uECC_vli_modSquare_fast>:
{
 1025b12:	4613      	mov	r3, r2
	uECC_vli_modMult_fast(result, left, left, curve);
 1025b14:	460a      	mov	r2, r1
 1025b16:	f7ff bfec 	b.w	1025af2 <uECC_vli_modMult_fast>

01025b1a <double_jacobian_default>:
{
 1025b1a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	wordcount_t num_words = curve->num_words;
 1025b1e:	f993 6000 	ldrsb.w	r6, [r3]
{
 1025b22:	4604      	mov	r4, r0
 1025b24:	4689      	mov	r9, r1
 1025b26:	b092      	sub	sp, #72	; 0x48
	if (uECC_vli_isZero(Z1, num_words)) {
 1025b28:	4631      	mov	r1, r6
 1025b2a:	4610      	mov	r0, r2
{
 1025b2c:	4615      	mov	r5, r2
 1025b2e:	461f      	mov	r7, r3
	if (uECC_vli_isZero(Z1, num_words)) {
 1025b30:	f7ff fe93 	bl	102585a <uECC_vli_isZero>
 1025b34:	2800      	cmp	r0, #0
 1025b36:	f040 8091 	bne.w	1025c5c <double_jacobian_default+0x142>
	uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
 1025b3a:	463a      	mov	r2, r7
 1025b3c:	4649      	mov	r1, r9
 1025b3e:	a802      	add	r0, sp, #8
 1025b40:	f7ff ffe7 	bl	1025b12 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
 1025b44:	463b      	mov	r3, r7
 1025b46:	4621      	mov	r1, r4
 1025b48:	aa02      	add	r2, sp, #8
 1025b4a:	a80a      	add	r0, sp, #40	; 0x28
 1025b4c:	f7ff ffd1 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
 1025b50:	a902      	add	r1, sp, #8
 1025b52:	4608      	mov	r0, r1
 1025b54:	463a      	mov	r2, r7
 1025b56:	f7ff ffdc 	bl	1025b12 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
 1025b5a:	463b      	mov	r3, r7
 1025b5c:	462a      	mov	r2, r5
 1025b5e:	4649      	mov	r1, r9
 1025b60:	4648      	mov	r0, r9
 1025b62:	f7ff ffc6 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
 1025b66:	f107 0804 	add.w	r8, r7, #4
	uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */
 1025b6a:	463a      	mov	r2, r7
 1025b6c:	4629      	mov	r1, r5
 1025b6e:	4628      	mov	r0, r5
 1025b70:	f7ff ffcf 	bl	1025b12 <uECC_vli_modSquare_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
 1025b74:	4643      	mov	r3, r8
 1025b76:	462a      	mov	r2, r5
 1025b78:	4621      	mov	r1, r4
 1025b7a:	4620      	mov	r0, r4
 1025b7c:	9600      	str	r6, [sp, #0]
 1025b7e:	f7ff fef2 	bl	1025966 <uECC_vli_modAdd>
	uECC_vli_modAdd(Z1, Z1, Z1, curve->p, num_words); /* t3 = 2*z1^2 */
 1025b82:	4643      	mov	r3, r8
 1025b84:	462a      	mov	r2, r5
 1025b86:	4629      	mov	r1, r5
 1025b88:	4628      	mov	r0, r5
 1025b8a:	9600      	str	r6, [sp, #0]
 1025b8c:	f7ff feeb 	bl	1025966 <uECC_vli_modAdd>
	uECC_vli_modSub(Z1, X1, Z1, curve->p, num_words); /* t3 = x1 - z1^2 */
 1025b90:	4643      	mov	r3, r8
 1025b92:	462a      	mov	r2, r5
 1025b94:	4621      	mov	r1, r4
 1025b96:	4628      	mov	r0, r5
 1025b98:	9600      	str	r6, [sp, #0]
 1025b9a:	f7ff fefd 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, Z1, curve); /* t1 = x1^2 - z1^4 */
 1025b9e:	463b      	mov	r3, r7
 1025ba0:	462a      	mov	r2, r5
 1025ba2:	4621      	mov	r1, r4
 1025ba4:	4620      	mov	r0, r4
 1025ba6:	f7ff ffa4 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
 1025baa:	4643      	mov	r3, r8
 1025bac:	4622      	mov	r2, r4
 1025bae:	4621      	mov	r1, r4
 1025bb0:	4628      	mov	r0, r5
 1025bb2:	9600      	str	r6, [sp, #0]
 1025bb4:	f7ff fed7 	bl	1025966 <uECC_vli_modAdd>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
 1025bb8:	4643      	mov	r3, r8
 1025bba:	462a      	mov	r2, r5
 1025bbc:	4621      	mov	r1, r4
 1025bbe:	4620      	mov	r0, r4
 1025bc0:	9600      	str	r6, [sp, #0]
 1025bc2:	f7ff fed0 	bl	1025966 <uECC_vli_modAdd>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 1025bc6:	6823      	ldr	r3, [r4, #0]
	if (uECC_vli_testBit(X1, 0)) {
 1025bc8:	07db      	lsls	r3, r3, #31
 1025bca:	d54a      	bpl.n	1025c62 <double_jacobian_default+0x148>
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
 1025bcc:	4633      	mov	r3, r6
 1025bce:	4642      	mov	r2, r8
 1025bd0:	4621      	mov	r1, r4
 1025bd2:	4620      	mov	r0, r4
 1025bd4:	f7ff fd89 	bl	10256ea <uECC_vli_add>
 1025bd8:	4682      	mov	sl, r0
		uECC_vli_rshift1(X1, num_words);
 1025bda:	4631      	mov	r1, r6
 1025bdc:	4620      	mov	r0, r4
 1025bde:	f7ff fd9e 	bl	102571e <uECC_vli_rshift1>
		X1[num_words - 1] |= l_carry << (uECC_WORD_BITS - 1);
 1025be2:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
 1025be6:	3b01      	subs	r3, #1
 1025be8:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 1025bec:	ea42 72ca 	orr.w	r2, r2, sl, lsl #31
 1025bf0:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
	uECC_vli_modSquare_fast(Z1, X1, curve); /* t3 = B^2 */
 1025bf4:	463a      	mov	r2, r7
 1025bf6:	4621      	mov	r1, r4
 1025bf8:	4628      	mov	r0, r5
 1025bfa:	f7ff ff8a 	bl	1025b12 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - A */
 1025bfe:	4643      	mov	r3, r8
 1025c00:	4629      	mov	r1, r5
 1025c02:	4628      	mov	r0, r5
 1025c04:	aa0a      	add	r2, sp, #40	; 0x28
 1025c06:	9600      	str	r6, [sp, #0]
 1025c08:	f7ff fec6 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - 2A = x3 */
 1025c0c:	4643      	mov	r3, r8
 1025c0e:	4629      	mov	r1, r5
 1025c10:	4628      	mov	r0, r5
 1025c12:	aa0a      	add	r2, sp, #40	; 0x28
 1025c14:	9600      	str	r6, [sp, #0]
 1025c16:	f7ff febf 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, Z1, curve->p, num_words); /* t5 = A - x3 */
 1025c1a:	a90a      	add	r1, sp, #40	; 0x28
 1025c1c:	4608      	mov	r0, r1
 1025c1e:	4643      	mov	r3, r8
 1025c20:	462a      	mov	r2, r5
 1025c22:	9600      	str	r6, [sp, #0]
 1025c24:	f7ff feb8 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = B * (A - x3) */
 1025c28:	463b      	mov	r3, r7
 1025c2a:	4621      	mov	r1, r4
 1025c2c:	4620      	mov	r0, r4
 1025c2e:	aa0a      	add	r2, sp, #40	; 0x28
 1025c30:	f7ff ff5f 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modSub(t4, X1, t4, curve->p, num_words);
 1025c34:	aa02      	add	r2, sp, #8
 1025c36:	4643      	mov	r3, r8
 1025c38:	4610      	mov	r0, r2
 1025c3a:	4621      	mov	r1, r4
 1025c3c:	9600      	str	r6, [sp, #0]
 1025c3e:	f7ff feab 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_set(X1, Z1, num_words);
 1025c42:	4632      	mov	r2, r6
 1025c44:	4629      	mov	r1, r5
 1025c46:	4620      	mov	r0, r4
 1025c48:	f7ff fe3f 	bl	10258ca <uECC_vli_set>
	uECC_vli_set(Z1, Y1, num_words);
 1025c4c:	4649      	mov	r1, r9
 1025c4e:	4628      	mov	r0, r5
 1025c50:	f7ff fe3b 	bl	10258ca <uECC_vli_set>
	uECC_vli_set(Y1, t4, num_words);
 1025c54:	4648      	mov	r0, r9
 1025c56:	a902      	add	r1, sp, #8
 1025c58:	f7ff fe37 	bl	10258ca <uECC_vli_set>
}
 1025c5c:	b012      	add	sp, #72	; 0x48
 1025c5e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uECC_vli_rshift1(X1, num_words);
 1025c62:	4631      	mov	r1, r6
 1025c64:	4620      	mov	r0, r4
 1025c66:	f7ff fd5a 	bl	102571e <uECC_vli_rshift1>
 1025c6a:	e7c3      	b.n	1025bf4 <double_jacobian_default+0xda>

01025c6c <x_side_default>:
{
 1025c6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1025c70:	4615      	mov	r5, r2
 1025c72:	b08a      	sub	sp, #40	; 0x28
 1025c74:	4604      	mov	r4, r0
 1025c76:	460e      	mov	r6, r1
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
 1025c78:	221c      	movs	r2, #28
 1025c7a:	2100      	movs	r1, #0
 1025c7c:	a803      	add	r0, sp, #12
 1025c7e:	f000 fe84 	bl	102698a <memset>
 1025c82:	2303      	movs	r3, #3
	wordcount_t num_words = curve->num_words;
 1025c84:	f995 8000 	ldrsb.w	r8, [r5]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
 1025c88:	462a      	mov	r2, r5
 1025c8a:	4631      	mov	r1, r6
 1025c8c:	4620      	mov	r0, r4
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
 1025c8e:	1d2f      	adds	r7, r5, #4
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
 1025c90:	9302      	str	r3, [sp, #8]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
 1025c92:	f7ff ff3e 	bl	1025b12 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
 1025c96:	463b      	mov	r3, r7
 1025c98:	4621      	mov	r1, r4
 1025c9a:	4620      	mov	r0, r4
 1025c9c:	aa02      	add	r2, sp, #8
 1025c9e:	f8cd 8000 	str.w	r8, [sp]
 1025ca2:	f7ff fe79 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modMult_fast(result, result, x, curve); /* r = x^3 - 3x */
 1025ca6:	462b      	mov	r3, r5
 1025ca8:	4632      	mov	r2, r6
 1025caa:	4621      	mov	r1, r4
 1025cac:	4620      	mov	r0, r4
 1025cae:	f7ff ff20 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(result, result, curve->b, curve->p, num_words);
 1025cb2:	463b      	mov	r3, r7
 1025cb4:	4621      	mov	r1, r4
 1025cb6:	4620      	mov	r0, r4
 1025cb8:	f8cd 8000 	str.w	r8, [sp]
 1025cbc:	f105 0284 	add.w	r2, r5, #132	; 0x84
 1025cc0:	f7ff fe51 	bl	1025966 <uECC_vli_modAdd>
}
 1025cc4:	b00a      	add	sp, #40	; 0x28
 1025cc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

01025cca <XYcZ_addC>:
   or P => P - Q, Q => P + Q
 */
static void XYcZ_addC(uECC_word_t * X1, uECC_word_t * Y1,
		      uECC_word_t * X2, uECC_word_t * Y2,
		      uECC_Curve curve)
{
 1025cca:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1025cce:	b09a      	sub	sp, #104	; 0x68
 1025cd0:	f8dd 8088 	ldr.w	r8, [sp, #136]	; 0x88
 1025cd4:	4616      	mov	r6, r2
	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
	uECC_word_t t5[NUM_ECC_WORDS];
	uECC_word_t t6[NUM_ECC_WORDS];
	uECC_word_t t7[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
 1025cd6:	4644      	mov	r4, r8
{
 1025cd8:	4607      	mov	r7, r0
 1025cda:	4699      	mov	r9, r3
 1025cdc:	468a      	mov	sl, r1
	wordcount_t num_words = curve->num_words;
 1025cde:	f914 5b04 	ldrsb.w	r5, [r4], #4

	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
 1025ce2:	4602      	mov	r2, r0
 1025ce4:	4623      	mov	r3, r4
 1025ce6:	4631      	mov	r1, r6
 1025ce8:	a802      	add	r0, sp, #8
 1025cea:	9500      	str	r5, [sp, #0]
 1025cec:	f7ff fe54 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
 1025cf0:	a902      	add	r1, sp, #8
 1025cf2:	4642      	mov	r2, r8
 1025cf4:	4608      	mov	r0, r1
 1025cf6:	f7ff ff0c 	bl	1025b12 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
 1025cfa:	4643      	mov	r3, r8
 1025cfc:	4639      	mov	r1, r7
 1025cfe:	4638      	mov	r0, r7
 1025d00:	aa02      	add	r2, sp, #8
 1025d02:	f7ff fef6 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
 1025d06:	4643      	mov	r3, r8
 1025d08:	4631      	mov	r1, r6
 1025d0a:	4630      	mov	r0, r6
 1025d0c:	aa02      	add	r2, sp, #8
 1025d0e:	f7ff fef0 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */
 1025d12:	4623      	mov	r3, r4
 1025d14:	4652      	mov	r2, sl
 1025d16:	4649      	mov	r1, r9
 1025d18:	a802      	add	r0, sp, #8
 1025d1a:	9500      	str	r5, [sp, #0]
 1025d1c:	f7ff fe23 	bl	1025966 <uECC_vli_modAdd>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
 1025d20:	4623      	mov	r3, r4
 1025d22:	4652      	mov	r2, sl
 1025d24:	4649      	mov	r1, r9
 1025d26:	4648      	mov	r0, r9
 1025d28:	9500      	str	r5, [sp, #0]
 1025d2a:	f7ff fe35 	bl	1025998 <uECC_vli_modSub>

	uECC_vli_modSub(t6, X2, X1, curve->p, num_words); /* t6 = C - B */
 1025d2e:	4623      	mov	r3, r4
 1025d30:	463a      	mov	r2, r7
 1025d32:	4631      	mov	r1, r6
 1025d34:	a80a      	add	r0, sp, #40	; 0x28
 1025d36:	9500      	str	r5, [sp, #0]
 1025d38:	f7ff fe2e 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, t6, curve); /* t2 = y1 * (C - B) = E */
 1025d3c:	4643      	mov	r3, r8
 1025d3e:	4651      	mov	r1, sl
 1025d40:	4650      	mov	r0, sl
 1025d42:	aa0a      	add	r2, sp, #40	; 0x28
 1025d44:	f7ff fed5 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t6, X1, X2, curve->p, num_words); /* t6 = B + C */
 1025d48:	4623      	mov	r3, r4
 1025d4a:	4632      	mov	r2, r6
 1025d4c:	4639      	mov	r1, r7
 1025d4e:	a80a      	add	r0, sp, #40	; 0x28
 1025d50:	9500      	str	r5, [sp, #0]
 1025d52:	f7ff fe08 	bl	1025966 <uECC_vli_modAdd>
	uECC_vli_modSquare_fast(X2, Y2, curve); /* t3 = (y2 - y1)^2 = D */
 1025d56:	4642      	mov	r2, r8
 1025d58:	4649      	mov	r1, r9
 1025d5a:	4630      	mov	r0, r6
 1025d5c:	f7ff fed9 	bl	1025b12 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(X2, X2, t6, curve->p, num_words); /* t3 = D - (B + C) = x3 */
 1025d60:	4623      	mov	r3, r4
 1025d62:	4631      	mov	r1, r6
 1025d64:	4630      	mov	r0, r6
 1025d66:	aa0a      	add	r2, sp, #40	; 0x28
 1025d68:	9500      	str	r5, [sp, #0]
 1025d6a:	f7ff fe15 	bl	1025998 <uECC_vli_modSub>

	uECC_vli_modSub(t7, X1, X2, curve->p, num_words); /* t7 = B - x3 */
 1025d6e:	4623      	mov	r3, r4
 1025d70:	4632      	mov	r2, r6
 1025d72:	4639      	mov	r1, r7
 1025d74:	a812      	add	r0, sp, #72	; 0x48
 1025d76:	9500      	str	r5, [sp, #0]
 1025d78:	f7ff fe0e 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, t7, curve); /* t4 = (y2 - y1)*(B - x3) */
 1025d7c:	4643      	mov	r3, r8
 1025d7e:	4649      	mov	r1, r9
 1025d80:	4648      	mov	r0, r9
 1025d82:	aa12      	add	r2, sp, #72	; 0x48
 1025d84:	f7ff feb5 	bl	1025af2 <uECC_vli_modMult_fast>
	/* t4 = (y2 - y1)*(B - x3) - E = y3: */
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words);
 1025d88:	4623      	mov	r3, r4
 1025d8a:	4652      	mov	r2, sl
 1025d8c:	4649      	mov	r1, r9
 1025d8e:	4648      	mov	r0, r9
 1025d90:	9500      	str	r5, [sp, #0]
 1025d92:	f7ff fe01 	bl	1025998 <uECC_vli_modSub>

	uECC_vli_modSquare_fast(t7, t5, curve); /* t7 = (y2 + y1)^2 = F */
 1025d96:	4642      	mov	r2, r8
 1025d98:	a902      	add	r1, sp, #8
 1025d9a:	a812      	add	r0, sp, #72	; 0x48
 1025d9c:	f7ff feb9 	bl	1025b12 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t7, t7, t6, curve->p, num_words); /* t7 = F - (B + C) = x3' */
 1025da0:	a912      	add	r1, sp, #72	; 0x48
 1025da2:	4623      	mov	r3, r4
 1025da4:	4608      	mov	r0, r1
 1025da6:	aa0a      	add	r2, sp, #40	; 0x28
 1025da8:	9500      	str	r5, [sp, #0]
 1025daa:	f7ff fdf5 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modSub(t6, t7, X1, curve->p, num_words); /* t6 = x3' - B */
 1025dae:	4623      	mov	r3, r4
 1025db0:	463a      	mov	r2, r7
 1025db2:	a912      	add	r1, sp, #72	; 0x48
 1025db4:	a80a      	add	r0, sp, #40	; 0x28
 1025db6:	9500      	str	r5, [sp, #0]
 1025db8:	f7ff fdee 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modMult_fast(t6, t6, t5, curve); /* t6 = (y2+y1)*(x3' - B) */
 1025dbc:	a90a      	add	r1, sp, #40	; 0x28
 1025dbe:	4643      	mov	r3, r8
 1025dc0:	4608      	mov	r0, r1
 1025dc2:	aa02      	add	r2, sp, #8
 1025dc4:	f7ff fe95 	bl	1025af2 <uECC_vli_modMult_fast>
	/* t2 = (y2+y1)*(x3' - B) - E = y3': */
	uECC_vli_modSub(Y1, t6, Y1, curve->p, num_words);
 1025dc8:	4623      	mov	r3, r4
 1025dca:	4652      	mov	r2, sl
 1025dcc:	4650      	mov	r0, sl
 1025dce:	a90a      	add	r1, sp, #40	; 0x28
 1025dd0:	9500      	str	r5, [sp, #0]
 1025dd2:	f7ff fde1 	bl	1025998 <uECC_vli_modSub>

	uECC_vli_set(X1, t7, num_words);
 1025dd6:	462a      	mov	r2, r5
 1025dd8:	4638      	mov	r0, r7
 1025dda:	a912      	add	r1, sp, #72	; 0x48
 1025ddc:	f7ff fd75 	bl	10258ca <uECC_vli_set>
}
 1025de0:	b01a      	add	sp, #104	; 0x68
 1025de2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

01025de6 <uECC_vli_modInv>:
{
 1025de6:	b5f0      	push	{r4, r5, r6, r7, lr}
 1025de8:	460f      	mov	r7, r1
 1025dea:	4606      	mov	r6, r0
 1025dec:	b0a1      	sub	sp, #132	; 0x84
	if (uECC_vli_isZero(input, num_words)) {
 1025dee:	4619      	mov	r1, r3
 1025df0:	4638      	mov	r0, r7
{
 1025df2:	4615      	mov	r5, r2
 1025df4:	461c      	mov	r4, r3
	if (uECC_vli_isZero(input, num_words)) {
 1025df6:	f7ff fd30 	bl	102585a <uECC_vli_isZero>
 1025dfa:	b128      	cbz	r0, 1025e08 <uECC_vli_modInv+0x22>
		uECC_vli_clear(result, num_words);
 1025dfc:	4630      	mov	r0, r6
}
 1025dfe:	b021      	add	sp, #132	; 0x84
 1025e00:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		uECC_vli_clear(result, num_words);
 1025e04:	f7ff bd1e 	b.w	1025844 <uECC_vli_clear>
	uECC_vli_set(a, input, num_words);
 1025e08:	4622      	mov	r2, r4
 1025e0a:	4639      	mov	r1, r7
 1025e0c:	4668      	mov	r0, sp
 1025e0e:	f7ff fd5c 	bl	10258ca <uECC_vli_set>
	uECC_vli_set(b, mod, num_words);
 1025e12:	4629      	mov	r1, r5
 1025e14:	a808      	add	r0, sp, #32
 1025e16:	f7ff fd58 	bl	10258ca <uECC_vli_set>
	uECC_vli_clear(u, num_words);
 1025e1a:	a810      	add	r0, sp, #64	; 0x40
 1025e1c:	4621      	mov	r1, r4
 1025e1e:	f7ff fd11 	bl	1025844 <uECC_vli_clear>
	u[0] = 1;
 1025e22:	2301      	movs	r3, #1
	uECC_vli_clear(v, num_words);
 1025e24:	a818      	add	r0, sp, #96	; 0x60
	u[0] = 1;
 1025e26:	9310      	str	r3, [sp, #64]	; 0x40
	uECC_vli_clear(v, num_words);
 1025e28:	f7ff fd0c 	bl	1025844 <uECC_vli_clear>
	while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {
 1025e2c:	4622      	mov	r2, r4
 1025e2e:	4668      	mov	r0, sp
 1025e30:	a908      	add	r1, sp, #32
 1025e32:	f7ff fd56 	bl	10258e2 <uECC_vli_cmp_unsafe>
 1025e36:	b930      	cbnz	r0, 1025e46 <uECC_vli_modInv+0x60>
  	uECC_vli_set(result, u, num_words);
 1025e38:	4622      	mov	r2, r4
 1025e3a:	4630      	mov	r0, r6
 1025e3c:	a910      	add	r1, sp, #64	; 0x40
 1025e3e:	f7ff fd44 	bl	10258ca <uECC_vli_set>
}
 1025e42:	b021      	add	sp, #132	; 0x84
 1025e44:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (EVEN(a)) {
 1025e46:	9b00      	ldr	r3, [sp, #0]
 1025e48:	07da      	lsls	r2, r3, #31
 1025e4a:	d409      	bmi.n	1025e60 <uECC_vli_modInv+0x7a>
			uECC_vli_rshift1(a, num_words);
 1025e4c:	4621      	mov	r1, r4
 1025e4e:	4668      	mov	r0, sp
 1025e50:	f7ff fc65 	bl	102571e <uECC_vli_rshift1>
      			vli_modInv_update(u, mod, num_words);
 1025e54:	4622      	mov	r2, r4
 1025e56:	4629      	mov	r1, r5
 1025e58:	a810      	add	r0, sp, #64	; 0x40
      			vli_modInv_update(v, mod, num_words);
 1025e5a:	f7ff fc6d 	bl	1025738 <vli_modInv_update>
 1025e5e:	e7e5      	b.n	1025e2c <uECC_vli_modInv+0x46>
    		} else if (EVEN(b)) {
 1025e60:	9b08      	ldr	r3, [sp, #32]
 1025e62:	07db      	lsls	r3, r3, #31
 1025e64:	d407      	bmi.n	1025e76 <uECC_vli_modInv+0x90>
			uECC_vli_rshift1(b, num_words);
 1025e66:	4621      	mov	r1, r4
 1025e68:	a808      	add	r0, sp, #32
 1025e6a:	f7ff fc58 	bl	102571e <uECC_vli_rshift1>
      			vli_modInv_update(v, mod, num_words);
 1025e6e:	4622      	mov	r2, r4
 1025e70:	4629      	mov	r1, r5
 1025e72:	a818      	add	r0, sp, #96	; 0x60
 1025e74:	e7f1      	b.n	1025e5a <uECC_vli_modInv+0x74>
		} else if (cmpResult > 0) {
 1025e76:	2800      	cmp	r0, #0
			uECC_vli_sub(a, a, b, num_words);
 1025e78:	4623      	mov	r3, r4
		} else if (cmpResult > 0) {
 1025e7a:	dd1c      	ble.n	1025eb6 <uECC_vli_modInv+0xd0>
			uECC_vli_sub(a, a, b, num_words);
 1025e7c:	aa08      	add	r2, sp, #32
 1025e7e:	4669      	mov	r1, sp
 1025e80:	4668      	mov	r0, sp
 1025e82:	f7ff fd55 	bl	1025930 <uECC_vli_sub>
			uECC_vli_rshift1(a, num_words);
 1025e86:	4621      	mov	r1, r4
 1025e88:	4668      	mov	r0, sp
 1025e8a:	f7ff fc48 	bl	102571e <uECC_vli_rshift1>
			if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {
 1025e8e:	4622      	mov	r2, r4
 1025e90:	a918      	add	r1, sp, #96	; 0x60
 1025e92:	a810      	add	r0, sp, #64	; 0x40
 1025e94:	f7ff fd25 	bl	10258e2 <uECC_vli_cmp_unsafe>
 1025e98:	2800      	cmp	r0, #0
 1025e9a:	da05      	bge.n	1025ea8 <uECC_vli_modInv+0xc2>
        			uECC_vli_add(u, u, mod, num_words);
 1025e9c:	a910      	add	r1, sp, #64	; 0x40
 1025e9e:	4623      	mov	r3, r4
 1025ea0:	462a      	mov	r2, r5
 1025ea2:	4608      	mov	r0, r1
 1025ea4:	f7ff fc21 	bl	10256ea <uECC_vli_add>
      			uECC_vli_sub(u, u, v, num_words);
 1025ea8:	a910      	add	r1, sp, #64	; 0x40
 1025eaa:	4623      	mov	r3, r4
 1025eac:	4608      	mov	r0, r1
 1025eae:	aa18      	add	r2, sp, #96	; 0x60
 1025eb0:	f7ff fd3e 	bl	1025930 <uECC_vli_sub>
 1025eb4:	e7ce      	b.n	1025e54 <uECC_vli_modInv+0x6e>
      			uECC_vli_sub(b, b, a, num_words);
 1025eb6:	466a      	mov	r2, sp
 1025eb8:	a808      	add	r0, sp, #32
 1025eba:	f7ff fd39 	bl	1025930 <uECC_vli_sub>
      			uECC_vli_rshift1(b, num_words);
 1025ebe:	4621      	mov	r1, r4
 1025ec0:	a808      	add	r0, sp, #32
 1025ec2:	f7ff fc2c 	bl	102571e <uECC_vli_rshift1>
      			if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {
 1025ec6:	4622      	mov	r2, r4
 1025ec8:	a910      	add	r1, sp, #64	; 0x40
 1025eca:	a818      	add	r0, sp, #96	; 0x60
 1025ecc:	f7ff fd09 	bl	10258e2 <uECC_vli_cmp_unsafe>
 1025ed0:	2800      	cmp	r0, #0
 1025ed2:	da05      	bge.n	1025ee0 <uECC_vli_modInv+0xfa>
        			uECC_vli_add(v, v, mod, num_words);
 1025ed4:	a918      	add	r1, sp, #96	; 0x60
 1025ed6:	4623      	mov	r3, r4
 1025ed8:	462a      	mov	r2, r5
 1025eda:	4608      	mov	r0, r1
 1025edc:	f7ff fc05 	bl	10256ea <uECC_vli_add>
      			uECC_vli_sub(v, v, u, num_words);
 1025ee0:	a918      	add	r1, sp, #96	; 0x60
 1025ee2:	4623      	mov	r3, r4
 1025ee4:	4608      	mov	r0, r1
 1025ee6:	aa10      	add	r2, sp, #64	; 0x40
 1025ee8:	f7ff fd22 	bl	1025930 <uECC_vli_sub>
 1025eec:	e7bf      	b.n	1025e6e <uECC_vli_modInv+0x88>

01025eee <EccPoint_isZero>:
	return uECC_vli_isZero(point, curve->num_words * 2);
 1025eee:	7809      	ldrb	r1, [r1, #0]
 1025ef0:	0049      	lsls	r1, r1, #1
 1025ef2:	b249      	sxtb	r1, r1
 1025ef4:	f7ff bcb1 	b.w	102585a <uECC_vli_isZero>

01025ef8 <apply_z>:
{
 1025ef8:	b5f0      	push	{r4, r5, r6, r7, lr}
 1025efa:	4615      	mov	r5, r2
 1025efc:	461c      	mov	r4, r3
 1025efe:	4607      	mov	r7, r0
 1025f00:	460e      	mov	r6, r1
 1025f02:	b089      	sub	sp, #36	; 0x24
	uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */
 1025f04:	461a      	mov	r2, r3
 1025f06:	4629      	mov	r1, r5
 1025f08:	4668      	mov	r0, sp
 1025f0a:	f7ff fe02 	bl	1025b12 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */
 1025f0e:	4623      	mov	r3, r4
 1025f10:	466a      	mov	r2, sp
 1025f12:	4639      	mov	r1, r7
 1025f14:	4638      	mov	r0, r7
 1025f16:	f7ff fdec 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */
 1025f1a:	4623      	mov	r3, r4
 1025f1c:	462a      	mov	r2, r5
 1025f1e:	4669      	mov	r1, sp
 1025f20:	4668      	mov	r0, sp
 1025f22:	f7ff fde6 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */
 1025f26:	4623      	mov	r3, r4
 1025f28:	466a      	mov	r2, sp
 1025f2a:	4631      	mov	r1, r6
 1025f2c:	4630      	mov	r0, r6
 1025f2e:	f7ff fde0 	bl	1025af2 <uECC_vli_modMult_fast>
}
 1025f32:	b009      	add	sp, #36	; 0x24
 1025f34:	bdf0      	pop	{r4, r5, r6, r7, pc}

01025f36 <XYcZ_add>:
{
 1025f36:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1025f3a:	b08a      	sub	sp, #40	; 0x28
 1025f3c:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
 1025f40:	4614      	mov	r4, r2
	wordcount_t num_words = curve->num_words;
 1025f42:	4655      	mov	r5, sl
{
 1025f44:	4680      	mov	r8, r0
 1025f46:	461f      	mov	r7, r3
 1025f48:	4689      	mov	r9, r1
	wordcount_t num_words = curve->num_words;
 1025f4a:	f915 6b04 	ldrsb.w	r6, [r5], #4
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
 1025f4e:	4602      	mov	r2, r0
 1025f50:	462b      	mov	r3, r5
 1025f52:	4621      	mov	r1, r4
 1025f54:	a802      	add	r0, sp, #8
 1025f56:	9600      	str	r6, [sp, #0]
 1025f58:	f7ff fd1e 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
 1025f5c:	a902      	add	r1, sp, #8
 1025f5e:	4652      	mov	r2, sl
 1025f60:	4608      	mov	r0, r1
 1025f62:	f7ff fdd6 	bl	1025b12 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
 1025f66:	4653      	mov	r3, sl
 1025f68:	4641      	mov	r1, r8
 1025f6a:	4640      	mov	r0, r8
 1025f6c:	aa02      	add	r2, sp, #8
 1025f6e:	f7ff fdc0 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
 1025f72:	4653      	mov	r3, sl
 1025f74:	4621      	mov	r1, r4
 1025f76:	4620      	mov	r0, r4
 1025f78:	aa02      	add	r2, sp, #8
 1025f7a:	f7ff fdba 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
 1025f7e:	462b      	mov	r3, r5
 1025f80:	464a      	mov	r2, r9
 1025f82:	4639      	mov	r1, r7
 1025f84:	4638      	mov	r0, r7
 1025f86:	9600      	str	r6, [sp, #0]
 1025f88:	f7ff fd06 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, Y2, curve); /* t5 = (y2 - y1)^2 = D */
 1025f8c:	4652      	mov	r2, sl
 1025f8e:	4639      	mov	r1, r7
 1025f90:	a802      	add	r0, sp, #8
 1025f92:	f7ff fdbe 	bl	1025b12 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */
 1025f96:	a902      	add	r1, sp, #8
 1025f98:	462b      	mov	r3, r5
 1025f9a:	4642      	mov	r2, r8
 1025f9c:	4608      	mov	r0, r1
 1025f9e:	9600      	str	r6, [sp, #0]
 1025fa0:	f7ff fcfa 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */
 1025fa4:	a902      	add	r1, sp, #8
 1025fa6:	462b      	mov	r3, r5
 1025fa8:	4622      	mov	r2, r4
 1025faa:	4608      	mov	r0, r1
 1025fac:	9600      	str	r6, [sp, #0]
 1025fae:	f7ff fcf3 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */
 1025fb2:	462b      	mov	r3, r5
 1025fb4:	4642      	mov	r2, r8
 1025fb6:	4621      	mov	r1, r4
 1025fb8:	4620      	mov	r0, r4
 1025fba:	9600      	str	r6, [sp, #0]
 1025fbc:	f7ff fcec 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, X2, curve); /* t2 = y1*(C - B) */
 1025fc0:	4653      	mov	r3, sl
 1025fc2:	4622      	mov	r2, r4
 1025fc4:	4649      	mov	r1, r9
 1025fc6:	4648      	mov	r0, r9
 1025fc8:	f7ff fd93 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */
 1025fcc:	462b      	mov	r3, r5
 1025fce:	4641      	mov	r1, r8
 1025fd0:	4620      	mov	r0, r4
 1025fd2:	aa02      	add	r2, sp, #8
 1025fd4:	9600      	str	r6, [sp, #0]
 1025fd6:	f7ff fcdf 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, X2, curve); /* t4 = (y2 - y1)*(B - x3) */
 1025fda:	4653      	mov	r3, sl
 1025fdc:	4622      	mov	r2, r4
 1025fde:	4639      	mov	r1, r7
 1025fe0:	4638      	mov	r0, r7
 1025fe2:	f7ff fd86 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */
 1025fe6:	462b      	mov	r3, r5
 1025fe8:	464a      	mov	r2, r9
 1025fea:	4639      	mov	r1, r7
 1025fec:	4638      	mov	r0, r7
 1025fee:	9600      	str	r6, [sp, #0]
 1025ff0:	f7ff fcd2 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_set(X2, t5, num_words);
 1025ff4:	4632      	mov	r2, r6
 1025ff6:	4620      	mov	r0, r4
 1025ff8:	a902      	add	r1, sp, #8
 1025ffa:	f7ff fc66 	bl	10258ca <uECC_vli_set>
}
 1025ffe:	b00a      	add	sp, #40	; 0x28
 1026000:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

01026004 <EccPoint_mult>:

void EccPoint_mult(uECC_word_t * result, const uECC_word_t * point,
		   const uECC_word_t * scalar,
		   const uECC_word_t * initial_Z,
		   bitcount_t num_bits, uECC_Curve curve) 
{
 1026004:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1026008:	461d      	mov	r5, r3
 102600a:	b0af      	sub	sp, #188	; 0xbc
 102600c:	9c39      	ldr	r4, [sp, #228]	; 0xe4
 102600e:	9002      	str	r0, [sp, #8]
	uECC_word_t Rx[2][NUM_ECC_WORDS];
	uECC_word_t Ry[2][NUM_ECC_WORDS];
	uECC_word_t z[NUM_ECC_WORDS];
	bitcount_t i;
	uECC_word_t nb;
	wordcount_t num_words = curve->num_words;
 1026010:	f994 6000 	ldrsb.w	r6, [r4]

	uECC_vli_set(Rx[1], point, num_words);
 1026014:	a816      	add	r0, sp, #88	; 0x58
{
 1026016:	4691      	mov	r9, r2
	uECC_vli_set(Rx[1], point, num_words);
 1026018:	4632      	mov	r2, r6
 102601a:	f7ff fc56 	bl	10258ca <uECC_vli_set>
  	uECC_vli_set(Ry[1], point + num_words, num_words);
 102601e:	00b3      	lsls	r3, r6, #2
 1026020:	9303      	str	r3, [sp, #12]
 1026022:	eb01 0386 	add.w	r3, r1, r6, lsl #2
{
 1026026:	4688      	mov	r8, r1
  	uECC_vli_set(Ry[1], point + num_words, num_words);
 1026028:	a826      	add	r0, sp, #152	; 0x98
 102602a:	4619      	mov	r1, r3
 102602c:	9304      	str	r3, [sp, #16]
 102602e:	f7ff fc4c 	bl	10258ca <uECC_vli_set>
	if (initial_Z) {
 1026032:	2d00      	cmp	r5, #0
 1026034:	f000 8081 	beq.w	102613a <EccPoint_mult+0x136>
		uECC_vli_set(z, initial_Z, num_words);
 1026038:	4629      	mov	r1, r5
 102603a:	a806      	add	r0, sp, #24
 102603c:	f7ff fc45 	bl	10258ca <uECC_vli_set>
	uECC_vli_set(X2, X1, num_words);
 1026040:	4632      	mov	r2, r6
 1026042:	a916      	add	r1, sp, #88	; 0x58
 1026044:	a80e      	add	r0, sp, #56	; 0x38
 1026046:	f7ff fc40 	bl	10258ca <uECC_vli_set>
	uECC_vli_set(Y2, Y1, num_words);
 102604a:	a926      	add	r1, sp, #152	; 0x98
 102604c:	a81e      	add	r0, sp, #120	; 0x78
 102604e:	f7ff fc3c 	bl	10258ca <uECC_vli_set>
	apply_z(X1, Y1, z, curve);
 1026052:	4623      	mov	r3, r4
 1026054:	aa06      	add	r2, sp, #24
 1026056:	a816      	add	r0, sp, #88	; 0x58
 1026058:	f7ff ff4e 	bl	1025ef8 <apply_z>
	curve->double_jacobian(X1, Y1, z, curve);
 102605c:	4623      	mov	r3, r4
 102605e:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
 1026062:	aa06      	add	r2, sp, #24
 1026064:	a926      	add	r1, sp, #152	; 0x98
 1026066:	a816      	add	r0, sp, #88	; 0x58
 1026068:	47a8      	blx	r5
	apply_z(X2, Y2, z, curve);
 102606a:	4623      	mov	r3, r4
 102606c:	aa06      	add	r2, sp, #24
 102606e:	a91e      	add	r1, sp, #120	; 0x78
 1026070:	a80e      	add	r0, sp, #56	; 0x38
 1026072:	f7ff ff41 	bl	1025ef8 <apply_z>

	XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);

	for (i = num_bits - 2; i > 0; --i) {
 1026076:	f9bd 50e0 	ldrsh.w	r5, [sp, #224]	; 0xe0
 102607a:	3d02      	subs	r5, #2
 102607c:	b22d      	sxth	r5, r5
 102607e:	2d00      	cmp	r5, #0
 1026080:	dc62      	bgt.n	1026148 <EccPoint_mult+0x144>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 1026082:	f8d9 5000 	ldr.w	r5, [r9]
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
	}

	nb = !uECC_vli_testBit(scalar, 0);
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 1026086:	ab0e      	add	r3, sp, #56	; 0x38
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 1026088:	f005 0701 	and.w	r7, r5, #1
 102608c:	43ed      	mvns	r5, r5
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 102608e:	eb03 1947 	add.w	r9, r3, r7, lsl #5
 1026092:	ab1e      	add	r3, sp, #120	; 0x78
 1026094:	eb03 1747 	add.w	r7, r3, r7, lsl #5
 1026098:	f005 0501 	and.w	r5, r5, #1
 102609c:	ab0e      	add	r3, sp, #56	; 0x38
 102609e:	eb03 1a45 	add.w	sl, r3, r5, lsl #5
 10260a2:	ab1e      	add	r3, sp, #120	; 0x78
 10260a4:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 10260a8:	462b      	mov	r3, r5
 10260aa:	4652      	mov	r2, sl
 10260ac:	4639      	mov	r1, r7
 10260ae:	4648      	mov	r0, r9

	/* Find final 1/Z value. */
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
 10260b0:	f104 0b04 	add.w	fp, r4, #4
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 10260b4:	9400      	str	r4, [sp, #0]
 10260b6:	f7ff fe08 	bl	1025cca <XYcZ_addC>
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
 10260ba:	465b      	mov	r3, fp
 10260bc:	aa0e      	add	r2, sp, #56	; 0x38
 10260be:	a916      	add	r1, sp, #88	; 0x58
 10260c0:	a806      	add	r0, sp, #24
 10260c2:	9600      	str	r6, [sp, #0]
 10260c4:	f7ff fc68 	bl	1025998 <uECC_vli_modSub>
	uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve); /* Yb * (X1 - X0) */
 10260c8:	a906      	add	r1, sp, #24
 10260ca:	4623      	mov	r3, r4
 10260cc:	463a      	mov	r2, r7
 10260ce:	4608      	mov	r0, r1
 10260d0:	f7ff fd0f 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(z, z, point, curve); /* xP * Yb * (X1 - X0) */
 10260d4:	a906      	add	r1, sp, #24
 10260d6:	4623      	mov	r3, r4
 10260d8:	4642      	mov	r2, r8
 10260da:	4608      	mov	r0, r1
 10260dc:	f7ff fd09 	bl	1025af2 <uECC_vli_modMult_fast>
	uECC_vli_modInv(z, z, curve->p, num_words); /* 1 / (xP * Yb * (X1 - X0))*/
 10260e0:	a906      	add	r1, sp, #24
 10260e2:	4633      	mov	r3, r6
 10260e4:	465a      	mov	r2, fp
 10260e6:	4608      	mov	r0, r1
 10260e8:	f7ff fe7d 	bl	1025de6 <uECC_vli_modInv>
	/* yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, point + num_words, curve);
 10260ec:	a906      	add	r1, sp, #24
 10260ee:	4623      	mov	r3, r4
 10260f0:	4608      	mov	r0, r1
 10260f2:	9a04      	ldr	r2, [sp, #16]
 10260f4:	f7ff fcfd 	bl	1025af2 <uECC_vli_modMult_fast>
	/* Xb * yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve);
 10260f8:	a906      	add	r1, sp, #24
 10260fa:	4623      	mov	r3, r4
 10260fc:	464a      	mov	r2, r9
 10260fe:	4608      	mov	r0, r1
 1026100:	f7ff fcf7 	bl	1025af2 <uECC_vli_modMult_fast>
	/* End 1/Z calculation */

	XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
 1026104:	463b      	mov	r3, r7
 1026106:	464a      	mov	r2, r9
 1026108:	4629      	mov	r1, r5
 102610a:	4650      	mov	r0, sl
 102610c:	9400      	str	r4, [sp, #0]
 102610e:	f7ff ff12 	bl	1025f36 <XYcZ_add>
	apply_z(Rx[0], Ry[0], z, curve);
 1026112:	4623      	mov	r3, r4
 1026114:	aa06      	add	r2, sp, #24
 1026116:	a91e      	add	r1, sp, #120	; 0x78
 1026118:	a80e      	add	r0, sp, #56	; 0x38
 102611a:	f7ff feed 	bl	1025ef8 <apply_z>

	uECC_vli_set(result, Rx[0], num_words);
 102611e:	4632      	mov	r2, r6
 1026120:	9802      	ldr	r0, [sp, #8]
 1026122:	a90e      	add	r1, sp, #56	; 0x38
 1026124:	f7ff fbd1 	bl	10258ca <uECC_vli_set>
	uECC_vli_set(result + num_words, Ry[0], num_words);
 1026128:	e9dd 0302 	ldrd	r0, r3, [sp, #8]
 102612c:	a91e      	add	r1, sp, #120	; 0x78
 102612e:	4418      	add	r0, r3
 1026130:	f7ff fbcb 	bl	10258ca <uECC_vli_set>
}
 1026134:	b02f      	add	sp, #188	; 0xbc
 1026136:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uECC_vli_clear(z, num_words);
 102613a:	4631      	mov	r1, r6
 102613c:	a806      	add	r0, sp, #24
 102613e:	f7ff fb81 	bl	1025844 <uECC_vli_clear>
		z[0] = 1;
 1026142:	2301      	movs	r3, #1
 1026144:	9306      	str	r3, [sp, #24]
 1026146:	e77b      	b.n	1026040 <EccPoint_mult+0x3c>
		nb = !uECC_vli_testBit(scalar, i);
 1026148:	4629      	mov	r1, r5
 102614a:	4648      	mov	r0, r9
 102614c:	f7ff fb94 	bl	1025878 <uECC_vli_testBit>
 1026150:	fab0 f780 	clz	r7, r0
 1026154:	097f      	lsrs	r7, r7, #5
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 1026156:	f1c7 0101 	rsb	r1, r7, #1
 102615a:	ab0e      	add	r3, sp, #56	; 0x38
 102615c:	eb03 1b41 	add.w	fp, r3, r1, lsl #5
 1026160:	ab1e      	add	r3, sp, #120	; 0x78
 1026162:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 1026166:	ab0e      	add	r3, sp, #56	; 0x38
 1026168:	eb03 1a47 	add.w	sl, r3, r7, lsl #5
 102616c:	ab1e      	add	r3, sp, #120	; 0x78
 102616e:	eb03 1747 	add.w	r7, r3, r7, lsl #5
 1026172:	463b      	mov	r3, r7
 1026174:	4652      	mov	r2, sl
 1026176:	4658      	mov	r0, fp
 1026178:	9400      	str	r4, [sp, #0]
 102617a:	9105      	str	r1, [sp, #20]
 102617c:	f7ff fda5 	bl	1025cca <XYcZ_addC>
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
 1026180:	9905      	ldr	r1, [sp, #20]
 1026182:	465a      	mov	r2, fp
 1026184:	460b      	mov	r3, r1
 1026186:	4650      	mov	r0, sl
 1026188:	4639      	mov	r1, r7
 102618a:	9400      	str	r4, [sp, #0]
 102618c:	f7ff fed3 	bl	1025f36 <XYcZ_add>
	for (i = num_bits - 2; i > 0; --i) {
 1026190:	3d01      	subs	r5, #1
 1026192:	e773      	b.n	102607c <EccPoint_mult+0x78>

01026194 <regularize_k>:

uECC_word_t regularize_k(const uECC_word_t * const k, uECC_word_t *k0,
			 uECC_word_t *k1, uECC_Curve curve)
{
 1026194:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1026198:	460f      	mov	r7, r1

	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 102619a:	f9b3 9002 	ldrsh.w	r9, [r3, #2]

	bitcount_t num_n_bits = curve->num_n_bits;

	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 102619e:	f103 0524 	add.w	r5, r3, #36	; 0x24
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 10261a2:	f119 061f 	adds.w	r6, r9, #31
 10261a6:	bf48      	it	mi
 10261a8:	f109 063e 	addmi.w	r6, r9, #62	; 0x3e
 10261ac:	f346 1647 	sbfx	r6, r6, #5, #8
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 10261b0:	4601      	mov	r1, r0
{
 10261b2:	4690      	mov	r8, r2
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 10261b4:	4633      	mov	r3, r6
 10261b6:	462a      	mov	r2, r5
 10261b8:	4638      	mov	r0, r7
 10261ba:	f7ff fa96 	bl	10256ea <uECC_vli_add>
 10261be:	4604      	mov	r4, r0
 10261c0:	b990      	cbnz	r0, 10261e8 <regularize_k+0x54>
 10261c2:	ebb9 1f46 	cmp.w	r9, r6, lsl #5
 10261c6:	da06      	bge.n	10261d6 <regularize_k+0x42>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
			     uECC_vli_testBit(k0, num_n_bits));
 10261c8:	4649      	mov	r1, r9
 10261ca:	4638      	mov	r0, r7
 10261cc:	f7ff fb54 	bl	1025878 <uECC_vli_testBit>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
 10261d0:	1e04      	subs	r4, r0, #0
 10261d2:	bf18      	it	ne
 10261d4:	2401      	movne	r4, #1

	uECC_vli_add(k1, k0, curve->n, num_n_words);
 10261d6:	4633      	mov	r3, r6
 10261d8:	462a      	mov	r2, r5
 10261da:	4639      	mov	r1, r7
 10261dc:	4640      	mov	r0, r8
 10261de:	f7ff fa84 	bl	10256ea <uECC_vli_add>

	return carry;
}
 10261e2:	4620      	mov	r0, r4
 10261e4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 10261e8:	2401      	movs	r4, #1
 10261ea:	e7f4      	b.n	10261d6 <regularize_k+0x42>

010261ec <EccPoint_compute_public_key>:

uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
					uECC_word_t *private_key,
					uECC_Curve curve)
{
 10261ec:	b530      	push	{r4, r5, lr}
 10261ee:	4614      	mov	r4, r2
 10261f0:	b095      	sub	sp, #84	; 0x54
 10261f2:	4605      	mov	r5, r0

	uECC_word_t tmp1[NUM_ECC_WORDS];
 	uECC_word_t tmp2[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {tmp1, tmp2};
 10261f4:	aa0c      	add	r2, sp, #48	; 0x30
	uECC_word_t carry;

	/* Regularize the bitcount for the private key so that attackers cannot
	 * use a side channel attack to learn the number of leading zeros. */
	carry = regularize_k(private_key, tmp1, tmp2, curve);
 10261f6:	4623      	mov	r3, r4
{
 10261f8:	4608      	mov	r0, r1
	uECC_word_t *p2[2] = {tmp1, tmp2};
 10261fa:	a904      	add	r1, sp, #16
 10261fc:	9102      	str	r1, [sp, #8]
 10261fe:	9203      	str	r2, [sp, #12]
	carry = regularize_k(private_key, tmp1, tmp2, curve);
 1026200:	f7ff ffc8 	bl	1026194 <regularize_k>

	EccPoint_mult(result, curve->G, p2[!carry], 0, curve->num_n_bits + 1, curve);
 1026204:	fab0 f380 	clz	r3, r0
 1026208:	9401      	str	r4, [sp, #4]
 102620a:	095b      	lsrs	r3, r3, #5
 102620c:	aa14      	add	r2, sp, #80	; 0x50
 102620e:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 1026212:	8863      	ldrh	r3, [r4, #2]
 1026214:	4628      	mov	r0, r5
 1026216:	3301      	adds	r3, #1
 1026218:	b21b      	sxth	r3, r3
 102621a:	9300      	str	r3, [sp, #0]
 102621c:	f852 2c48 	ldr.w	r2, [r2, #-72]
 1026220:	2300      	movs	r3, #0
 1026222:	f104 0144 	add.w	r1, r4, #68	; 0x44
 1026226:	f7ff feed 	bl	1026004 <EccPoint_mult>

	if (EccPoint_isZero(result, curve)) {
 102622a:	4621      	mov	r1, r4
 102622c:	4628      	mov	r0, r5
 102622e:	f7ff fe5e 	bl	1025eee <EccPoint_isZero>
		return 0;
	}
	return 1;
}
 1026232:	fab0 f080 	clz	r0, r0
 1026236:	0940      	lsrs	r0, r0, #5
 1026238:	b015      	add	sp, #84	; 0x54
 102623a:	bd30      	pop	{r4, r5, pc}

0102623c <uECC_vli_nativeToBytes>:

/* Converts an integer in uECC native format to big-endian bytes. */
void uECC_vli_nativeToBytes(uint8_t *bytes, int num_bytes,
			    const unsigned int *native)
{
 102623c:	b5f0      	push	{r4, r5, r6, r7, lr}
	wordcount_t i;
	for (i = 0; i < num_bytes; ++i) {
 102623e:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
 1026240:	1e4f      	subs	r7, r1, #1
 1026242:	b26c      	sxtb	r4, r5
	for (i = 0; i < num_bytes; ++i) {
 1026244:	428c      	cmp	r4, r1
 1026246:	f105 0501 	add.w	r5, r5, #1
 102624a:	db00      	blt.n	102624e <uECC_vli_nativeToBytes+0x12>
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
	}
}
 102624c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
 102624e:	1b3b      	subs	r3, r7, r4
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
 1026250:	f023 0603 	bic.w	r6, r3, #3
 1026254:	5996      	ldr	r6, [r2, r6]
 1026256:	f003 0303 	and.w	r3, r3, #3
 102625a:	00db      	lsls	r3, r3, #3
 102625c:	fa26 f303 	lsr.w	r3, r6, r3
 1026260:	5503      	strb	r3, [r0, r4]
	for (i = 0; i < num_bytes; ++i) {
 1026262:	e7ee      	b.n	1026242 <uECC_vli_nativeToBytes+0x6>

01026264 <uECC_vli_bytesToNative>:

/* Converts big-endian bytes to an integer in uECC native format. */
void uECC_vli_bytesToNative(unsigned int *native, const uint8_t *bytes,
			    int num_bytes)
{
 1026264:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1026266:	460e      	mov	r6, r1
	wordcount_t i;
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 1026268:	1cd1      	adds	r1, r2, #3
 102626a:	bf48      	it	mi
 102626c:	1d91      	addmi	r1, r2, #6
{
 102626e:	4614      	mov	r4, r2
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 1026270:	f341 0187 	sbfx	r1, r1, #2, #8
 1026274:	f7ff fae6 	bl	1025844 <uECC_vli_clear>
	for (i = 0; i < num_bytes; ++i) {
 1026278:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
 102627a:	1e67      	subs	r7, r4, #1
 102627c:	b26a      	sxtb	r2, r5
	for (i = 0; i < num_bytes; ++i) {
 102627e:	42a2      	cmp	r2, r4
 1026280:	f105 0501 	add.w	r5, r5, #1
 1026284:	db00      	blt.n	1026288 <uECC_vli_bytesToNative+0x24>
		native[b / uECC_WORD_SIZE] |=
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
  	}
}
 1026286:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
 1026288:	1abb      	subs	r3, r7, r2
		native[b / uECC_WORD_SIZE] |=
 102628a:	f023 0103 	bic.w	r1, r3, #3
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
 102628e:	5cb2      	ldrb	r2, [r6, r2]
 1026290:	f003 0303 	and.w	r3, r3, #3
 1026294:	00db      	lsls	r3, r3, #3
 1026296:	409a      	lsls	r2, r3
		native[b / uECC_WORD_SIZE] |=
 1026298:	5843      	ldr	r3, [r0, r1]
 102629a:	4313      	orrs	r3, r2
 102629c:	5043      	str	r3, [r0, r1]
	for (i = 0; i < num_bytes; ++i) {
 102629e:	e7ed      	b.n	102627c <uECC_vli_bytesToNative+0x18>

010262a0 <uECC_valid_point>:
	return 0;
}


int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve)
{
 10262a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 10262a2:	b091      	sub	sp, #68	; 0x44
 10262a4:	4605      	mov	r5, r0
 10262a6:	460c      	mov	r4, r1
	uECC_word_t tmp1[NUM_ECC_WORDS];
	uECC_word_t tmp2[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
 10262a8:	f991 6000 	ldrsb.w	r6, [r1]

	/* The point at infinity is invalid. */
	if (EccPoint_isZero(point, curve)) {
 10262ac:	f7ff fe1f 	bl	1025eee <EccPoint_isZero>
 10262b0:	bb28      	cbnz	r0, 10262fe <uECC_valid_point+0x5e>
		return -1;
	}

	/* x and y must be smaller than p. */
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
 10262b2:	1d27      	adds	r7, r4, #4
 10262b4:	4632      	mov	r2, r6
 10262b6:	4629      	mov	r1, r5
 10262b8:	4638      	mov	r0, r7
 10262ba:	f7ff fb12 	bl	10258e2 <uECC_vli_cmp_unsafe>
 10262be:	2801      	cmp	r0, #1
 10262c0:	d120      	bne.n	1026304 <uECC_valid_point+0x64>
		uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {
 10262c2:	4632      	mov	r2, r6
 10262c4:	4638      	mov	r0, r7
 10262c6:	eb05 0186 	add.w	r1, r5, r6, lsl #2
 10262ca:	f7ff fb0a 	bl	10258e2 <uECC_vli_cmp_unsafe>
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
 10262ce:	2801      	cmp	r0, #1
 10262d0:	d118      	bne.n	1026304 <uECC_valid_point+0x64>
		return -2;
	}

	uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
 10262d2:	4622      	mov	r2, r4
 10262d4:	4668      	mov	r0, sp
 10262d6:	f7ff fc1c 	bl	1025b12 <uECC_vli_modSquare_fast>
	curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
 10262da:	4622      	mov	r2, r4
 10262dc:	4629      	mov	r1, r5
 10262de:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 10262e2:	a808      	add	r0, sp, #32
 10262e4:	4798      	blx	r3

	/* Make sure that y^2 == x^3 + ax + b */
	if (uECC_vli_equal(tmp1, tmp2, num_words) != 0)
 10262e6:	4632      	mov	r2, r6
 10262e8:	4668      	mov	r0, sp
 10262ea:	a908      	add	r1, sp, #32
 10262ec:	f7ff fb0e 	bl	102590c <uECC_vli_equal>
		return -3;

	return 0;
 10262f0:	2800      	cmp	r0, #0
 10262f2:	bf14      	ite	ne
 10262f4:	f06f 0002 	mvnne.w	r0, #2
 10262f8:	2000      	moveq	r0, #0
}
 10262fa:	b011      	add	sp, #68	; 0x44
 10262fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -1;
 10262fe:	f04f 30ff 	mov.w	r0, #4294967295
 1026302:	e7fa      	b.n	10262fa <uECC_valid_point+0x5a>
		return -2;
 1026304:	f06f 0001 	mvn.w	r0, #1
 1026308:	e7f7      	b.n	10262fa <uECC_valid_point+0x5a>

0102630a <uECC_valid_public_key>:

int uECC_valid_public_key(const uint8_t *public_key, uECC_Curve curve)
{
 102630a:	b5f0      	push	{r4, r5, r6, r7, lr}
 102630c:	460c      	mov	r4, r1

	uECC_word_t _public[NUM_ECC_WORDS * 2];

	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
	uECC_vli_bytesToNative(
	_public + curve->num_words,
 102630e:	4626      	mov	r6, r4
{
 1026310:	4605      	mov	r5, r0
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
 1026312:	f991 7001 	ldrsb.w	r7, [r1, #1]
{
 1026316:	b091      	sub	sp, #68	; 0x44
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
 1026318:	4601      	mov	r1, r0
 102631a:	463a      	mov	r2, r7
 102631c:	4668      	mov	r0, sp
 102631e:	f7ff ffa1 	bl	1026264 <uECC_vli_bytesToNative>
	_public + curve->num_words,
 1026322:	f916 0b44 	ldrsb.w	r0, [r6], #68
	uECC_vli_bytesToNative(
 1026326:	463a      	mov	r2, r7
 1026328:	19e9      	adds	r1, r5, r7
 102632a:	eb0d 0080 	add.w	r0, sp, r0, lsl #2
 102632e:	f7ff ff99 	bl	1026264 <uECC_vli_bytesToNative>
	public_key + curve->num_bytes,
	curve->num_bytes);

	if (uECC_vli_cmp_unsafe(_public, curve->G, NUM_ECC_WORDS * 2) == 0) {
 1026332:	2210      	movs	r2, #16
 1026334:	4631      	mov	r1, r6
 1026336:	4668      	mov	r0, sp
 1026338:	f7ff fad3 	bl	10258e2 <uECC_vli_cmp_unsafe>
 102633c:	b128      	cbz	r0, 102634a <uECC_valid_public_key+0x40>
		return -4;
	}

	return uECC_valid_point(_public, curve);
 102633e:	4621      	mov	r1, r4
 1026340:	4668      	mov	r0, sp
 1026342:	f7ff ffad 	bl	10262a0 <uECC_valid_point>
}
 1026346:	b011      	add	sp, #68	; 0x44
 1026348:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -4;
 102634a:	f06f 0003 	mvn.w	r0, #3
 102634e:	e7fa      	b.n	1026346 <uECC_valid_public_key+0x3c>

01026350 <add_round_key>:
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
 1026350:	78cb      	ldrb	r3, [r1, #3]
 1026352:	7802      	ldrb	r2, [r0, #0]
 1026354:	4053      	eors	r3, r2
 1026356:	7003      	strb	r3, [r0, #0]
 1026358:	884b      	ldrh	r3, [r1, #2]
 102635a:	7842      	ldrb	r2, [r0, #1]
 102635c:	4053      	eors	r3, r2
 102635e:	7043      	strb	r3, [r0, #1]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
 1026360:	680a      	ldr	r2, [r1, #0]
 1026362:	7883      	ldrb	r3, [r0, #2]
 1026364:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
 1026368:	7083      	strb	r3, [r0, #2]
 102636a:	680a      	ldr	r2, [r1, #0]
 102636c:	78c3      	ldrb	r3, [r0, #3]
 102636e:	4053      	eors	r3, r2
 1026370:	70c3      	strb	r3, [r0, #3]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
 1026372:	79cb      	ldrb	r3, [r1, #7]
 1026374:	7902      	ldrb	r2, [r0, #4]
 1026376:	4053      	eors	r3, r2
 1026378:	7103      	strb	r3, [r0, #4]
 102637a:	88cb      	ldrh	r3, [r1, #6]
 102637c:	7942      	ldrb	r2, [r0, #5]
 102637e:	4053      	eors	r3, r2
 1026380:	7143      	strb	r3, [r0, #5]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
 1026382:	684a      	ldr	r2, [r1, #4]
 1026384:	7983      	ldrb	r3, [r0, #6]
 1026386:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
 102638a:	7183      	strb	r3, [r0, #6]
 102638c:	684a      	ldr	r2, [r1, #4]
 102638e:	79c3      	ldrb	r3, [r0, #7]
 1026390:	4053      	eors	r3, r2
 1026392:	71c3      	strb	r3, [r0, #7]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
 1026394:	7acb      	ldrb	r3, [r1, #11]
 1026396:	7a02      	ldrb	r2, [r0, #8]
 1026398:	4053      	eors	r3, r2
 102639a:	7203      	strb	r3, [r0, #8]
 102639c:	7a42      	ldrb	r2, [r0, #9]
 102639e:	894b      	ldrh	r3, [r1, #10]
 10263a0:	4053      	eors	r3, r2
 10263a2:	7243      	strb	r3, [r0, #9]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
 10263a4:	688a      	ldr	r2, [r1, #8]
 10263a6:	7a83      	ldrb	r3, [r0, #10]
 10263a8:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
 10263ac:	7283      	strb	r3, [r0, #10]
 10263ae:	688a      	ldr	r2, [r1, #8]
 10263b0:	7ac3      	ldrb	r3, [r0, #11]
 10263b2:	4053      	eors	r3, r2
 10263b4:	72c3      	strb	r3, [r0, #11]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
 10263b6:	7bcb      	ldrb	r3, [r1, #15]
 10263b8:	7b02      	ldrb	r2, [r0, #12]
 10263ba:	4053      	eors	r3, r2
 10263bc:	7303      	strb	r3, [r0, #12]
 10263be:	89cb      	ldrh	r3, [r1, #14]
 10263c0:	7b42      	ldrb	r2, [r0, #13]
 10263c2:	4053      	eors	r3, r2
 10263c4:	7343      	strb	r3, [r0, #13]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
 10263c6:	68ca      	ldr	r2, [r1, #12]
 10263c8:	7b83      	ldrb	r3, [r0, #14]
 10263ca:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
 10263ce:	7383      	strb	r3, [r0, #14]
 10263d0:	68ca      	ldr	r2, [r1, #12]
 10263d2:	7bc3      	ldrb	r3, [r0, #15]
 10263d4:	4053      	eors	r3, r2
 10263d6:	73c3      	strb	r3, [r0, #15]
}
 10263d8:	4770      	bx	lr

010263da <shift_rows>:
/*
 * This shift_rows also implements the matrix flip required for mix_columns, but
 * performs it here to reduce the number of memory operations.
 */
static inline void shift_rows(uint8_t *s)
{
 10263da:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	uint8_t t[Nb * Nk];

	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
 10263dc:	7802      	ldrb	r2, [r0, #0]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
 10263de:	7ac3      	ldrb	r3, [r0, #11]
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
 10263e0:	f88d 2000 	strb.w	r2, [sp]
 10263e4:	7942      	ldrb	r2, [r0, #5]
 10263e6:	f88d 2001 	strb.w	r2, [sp, #1]
 10263ea:	7a82      	ldrb	r2, [r0, #10]
 10263ec:	f88d 2002 	strb.w	r2, [sp, #2]
 10263f0:	7bc2      	ldrb	r2, [r0, #15]
 10263f2:	f88d 2003 	strb.w	r2, [sp, #3]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
 10263f6:	7902      	ldrb	r2, [r0, #4]
 10263f8:	f88d 2004 	strb.w	r2, [sp, #4]
 10263fc:	7a42      	ldrb	r2, [r0, #9]
 10263fe:	f88d 2005 	strb.w	r2, [sp, #5]
 1026402:	7b82      	ldrb	r2, [r0, #14]
 1026404:	f88d 2006 	strb.w	r2, [sp, #6]
 1026408:	78c2      	ldrb	r2, [r0, #3]
 102640a:	f88d 2007 	strb.w	r2, [sp, #7]
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
 102640e:	7a02      	ldrb	r2, [r0, #8]
 1026410:	f88d 2008 	strb.w	r2, [sp, #8]
 1026414:	7b42      	ldrb	r2, [r0, #13]
 1026416:	f88d 2009 	strb.w	r2, [sp, #9]
 102641a:	7882      	ldrb	r2, [r0, #2]
 102641c:	f88d 200a 	strb.w	r2, [sp, #10]
 1026420:	79c2      	ldrb	r2, [r0, #7]
 1026422:	f88d 200b 	strb.w	r2, [sp, #11]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
 1026426:	7b02      	ldrb	r2, [r0, #12]
 1026428:	f88d 200c 	strb.w	r2, [sp, #12]
 102642c:	7842      	ldrb	r2, [r0, #1]
 102642e:	f88d 200d 	strb.w	r2, [sp, #13]
 1026432:	7982      	ldrb	r2, [r0, #6]
 1026434:	f88d 200e 	strb.w	r2, [sp, #14]
 1026438:	f88d 300f 	strb.w	r3, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
 102643c:	2310      	movs	r3, #16
 102643e:	466a      	mov	r2, sp
 1026440:	4619      	mov	r1, r3
 1026442:	f7ff f88e 	bl	1025562 <_copy>
}
 1026446:	b005      	add	sp, #20
 1026448:	f85d fb04 	ldr.w	pc, [sp], #4

0102644c <mult_row_column>:
{
 102644c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 102644e:	4606      	mov	r6, r0
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
 1026450:	7808      	ldrb	r0, [r1, #0]
{
 1026452:	460c      	mov	r4, r1
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
 1026454:	f7ff f894 	bl	1025580 <_double_byte>
 1026458:	4605      	mov	r5, r0
 102645a:	7860      	ldrb	r0, [r4, #1]
 102645c:	f7ff f890 	bl	1025580 <_double_byte>
 1026460:	78a2      	ldrb	r2, [r4, #2]
 1026462:	7863      	ldrb	r3, [r4, #1]
 1026464:	4053      	eors	r3, r2
 1026466:	78e2      	ldrb	r2, [r4, #3]
 1026468:	4053      	eors	r3, r2
 102646a:	405d      	eors	r5, r3
 102646c:	4068      	eors	r0, r5
 102646e:	7030      	strb	r0, [r6, #0]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
 1026470:	7860      	ldrb	r0, [r4, #1]
 1026472:	7827      	ldrb	r7, [r4, #0]
 1026474:	f7ff f884 	bl	1025580 <_double_byte>
 1026478:	4605      	mov	r5, r0
 102647a:	78a0      	ldrb	r0, [r4, #2]
 102647c:	f7ff f880 	bl	1025580 <_double_byte>
 1026480:	78a3      	ldrb	r3, [r4, #2]
 1026482:	405f      	eors	r7, r3
 1026484:	78e3      	ldrb	r3, [r4, #3]
 1026486:	405f      	eors	r7, r3
 1026488:	407d      	eors	r5, r7
 102648a:	4068      	eors	r0, r5
 102648c:	7070      	strb	r0, [r6, #1]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
 102648e:	7863      	ldrb	r3, [r4, #1]
 1026490:	7827      	ldrb	r7, [r4, #0]
 1026492:	78a0      	ldrb	r0, [r4, #2]
 1026494:	405f      	eors	r7, r3
 1026496:	f7ff f873 	bl	1025580 <_double_byte>
 102649a:	4605      	mov	r5, r0
 102649c:	78e0      	ldrb	r0, [r4, #3]
 102649e:	f7ff f86f 	bl	1025580 <_double_byte>
 10264a2:	78e3      	ldrb	r3, [r4, #3]
 10264a4:	405f      	eors	r7, r3
 10264a6:	407d      	eors	r5, r7
 10264a8:	4068      	eors	r0, r5
 10264aa:	70b0      	strb	r0, [r6, #2]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
 10264ac:	7820      	ldrb	r0, [r4, #0]
 10264ae:	f7ff f867 	bl	1025580 <_double_byte>
 10264b2:	7862      	ldrb	r2, [r4, #1]
 10264b4:	7823      	ldrb	r3, [r4, #0]
 10264b6:	4053      	eors	r3, r2
 10264b8:	78a2      	ldrb	r2, [r4, #2]
 10264ba:	4053      	eors	r3, r2
 10264bc:	ea80 0503 	eor.w	r5, r0, r3
 10264c0:	78e0      	ldrb	r0, [r4, #3]
 10264c2:	f7ff f85d 	bl	1025580 <_double_byte>
 10264c6:	b2ed      	uxtb	r5, r5
 10264c8:	4045      	eors	r5, r0
 10264ca:	70f5      	strb	r5, [r6, #3]
}
 10264cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

010264ce <tc_aes_encrypt>:

int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
 10264ce:	b570      	push	{r4, r5, r6, lr}
 10264d0:	4614      	mov	r4, r2
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
 10264d2:	4605      	mov	r5, r0
{
 10264d4:	b088      	sub	sp, #32
	if (out == (uint8_t *) 0) {
 10264d6:	2800      	cmp	r0, #0
 10264d8:	d049      	beq.n	102656e <tc_aes_encrypt+0xa0>
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
 10264da:	2900      	cmp	r1, #0
 10264dc:	d049      	beq.n	1026572 <tc_aes_encrypt+0xa4>
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
 10264de:	2a00      	cmp	r2, #0
 10264e0:	d049      	beq.n	1026576 <tc_aes_encrypt+0xa8>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
 10264e2:	2310      	movs	r3, #16
 10264e4:	460a      	mov	r2, r1
 10264e6:	4668      	mov	r0, sp
 10264e8:	4619      	mov	r1, r3
 10264ea:	f7ff f83a 	bl	1025562 <_copy>
	add_round_key(state, s->words);
 10264ee:	4621      	mov	r1, r4
 10264f0:	4668      	mov	r0, sp
 10264f2:	f7ff ff2d 	bl	1026350 <add_round_key>

	for (i = 0; i < (Nr - 1); ++i) {
 10264f6:	3410      	adds	r4, #16
 10264f8:	f101 06a0 	add.w	r6, r1, #160	; 0xa0
		sub_bytes(state);
 10264fc:	4668      	mov	r0, sp
 10264fe:	f7df fb8f 	bl	1005c20 <sub_bytes>
		shift_rows(state);
 1026502:	4668      	mov	r0, sp
 1026504:	f7ff ff69 	bl	10263da <shift_rows>
	mult_row_column(t, s);
 1026508:	4669      	mov	r1, sp
 102650a:	a804      	add	r0, sp, #16
 102650c:	f7ff ff9e 	bl	102644c <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
 1026510:	a901      	add	r1, sp, #4
 1026512:	a805      	add	r0, sp, #20
 1026514:	f7ff ff9a 	bl	102644c <mult_row_column>
	mult_row_column(&t[2 * Nb], s + (2 * Nb));
 1026518:	a902      	add	r1, sp, #8
 102651a:	a806      	add	r0, sp, #24
 102651c:	f7ff ff96 	bl	102644c <mult_row_column>
	mult_row_column(&t[3 * Nb], s + (3 * Nb));
 1026520:	a903      	add	r1, sp, #12
 1026522:	a807      	add	r0, sp, #28
 1026524:	f7ff ff92 	bl	102644c <mult_row_column>
	(void) _copy(s, sizeof(t), t, sizeof(t));
 1026528:	2310      	movs	r3, #16
 102652a:	4668      	mov	r0, sp
 102652c:	4619      	mov	r1, r3
 102652e:	eb0d 0203 	add.w	r2, sp, r3
 1026532:	f7ff f816 	bl	1025562 <_copy>
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
 1026536:	4621      	mov	r1, r4
 1026538:	4668      	mov	r0, sp
	for (i = 0; i < (Nr - 1); ++i) {
 102653a:	3410      	adds	r4, #16
		add_round_key(state, s->words + Nb*(i+1));
 102653c:	f7ff ff08 	bl	1026350 <add_round_key>
	for (i = 0; i < (Nr - 1); ++i) {
 1026540:	42b4      	cmp	r4, r6
 1026542:	d1db      	bne.n	10264fc <tc_aes_encrypt+0x2e>
	}

	sub_bytes(state);
 1026544:	f7df fb6c 	bl	1005c20 <sub_bytes>
	shift_rows(state);
 1026548:	4668      	mov	r0, sp
 102654a:	f7ff ff46 	bl	10263da <shift_rows>
	add_round_key(state, s->words + Nb*(i+1));
 102654e:	4621      	mov	r1, r4
 1026550:	4668      	mov	r0, sp
 1026552:	f7ff fefd 	bl	1026350 <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
 1026556:	2310      	movs	r3, #16
 1026558:	466a      	mov	r2, sp
 102655a:	4619      	mov	r1, r3
 102655c:	4628      	mov	r0, r5
 102655e:	f7ff f800 	bl	1025562 <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
 1026562:	4668      	mov	r0, sp
 1026564:	2210      	movs	r2, #16
 1026566:	2100      	movs	r1, #0
 1026568:	f7ff f808 	bl	102557c <_set>

	return TC_CRYPTO_SUCCESS;
 102656c:	2001      	movs	r0, #1
}
 102656e:	b008      	add	sp, #32
 1026570:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
 1026572:	4608      	mov	r0, r1
 1026574:	e7fb      	b.n	102656e <tc_aes_encrypt+0xa0>
 1026576:	4610      	mov	r0, r2
 1026578:	e7f9      	b.n	102656e <tc_aes_encrypt+0xa0>

0102657a <gf_double>:

	/* start with low order byte */
	uint8_t *x = in + (TC_AES_BLOCK_SIZE - 1);

	/* if msb == 1, we need to add the gf_wrap value, otherwise add 0 */
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
 102657a:	460a      	mov	r2, r1
{
 102657c:	b510      	push	{r4, lr}
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
 102657e:	f912 3b10 	ldrsb.w	r3, [r2], #16

	out += (TC_AES_BLOCK_SIZE - 1);
 1026582:	300f      	adds	r0, #15
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
 1026584:	2b00      	cmp	r3, #0
 1026586:	bfac      	ite	ge
 1026588:	2300      	movge	r3, #0
 102658a:	2387      	movlt	r3, #135	; 0x87
	for (;;) {
		*out-- = (*x << 1) ^ carry;
 102658c:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
 1026590:	ea83 0344 	eor.w	r3, r3, r4, lsl #1
		if (x == in) {
 1026594:	428a      	cmp	r2, r1
		*out-- = (*x << 1) ^ carry;
 1026596:	f800 3901 	strb.w	r3, [r0], #-1
		if (x == in) {
 102659a:	d002      	beq.n	10265a2 <gf_double+0x28>
			break;
		}
		carry = *x-- >> 7;
 102659c:	7813      	ldrb	r3, [r2, #0]
 102659e:	09db      	lsrs	r3, r3, #7
		*out-- = (*x << 1) ^ carry;
 10265a0:	e7f4      	b.n	102658c <gf_double+0x12>
	}
}
 10265a2:	bd10      	pop	{r4, pc}

010265a4 <tc_cmac_erase>:

	return TC_CRYPTO_SUCCESS;
}

int tc_cmac_erase(TCCmacState_t s)
{
 10265a4:	b508      	push	{r3, lr}
	if (s == (TCCmacState_t) 0) {
 10265a6:	b120      	cbz	r0, 10265b2 <tc_cmac_erase+0xe>
		return TC_CRYPTO_FAIL;
	}

	/* destroy the current state */
	_set(s, 0, sizeof(*s));
 10265a8:	2258      	movs	r2, #88	; 0x58
 10265aa:	2100      	movs	r1, #0
 10265ac:	f7fe ffe6 	bl	102557c <_set>
 10265b0:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
 10265b2:	bd08      	pop	{r3, pc}

010265b4 <tc_cmac_init>:

int tc_cmac_init(TCCmacState_t s)
{
 10265b4:	b510      	push	{r4, lr}
	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
 10265b6:	4604      	mov	r4, r0
 10265b8:	b188      	cbz	r0, 10265de <tc_cmac_init+0x2a>
		return TC_CRYPTO_FAIL;
	}

	/* CMAC starts with an all zero initialization vector */
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
 10265ba:	2210      	movs	r2, #16
 10265bc:	2100      	movs	r1, #0
 10265be:	f7fe ffdd 	bl	102557c <_set>

	/* and the leftover buffer is empty */
	_set(s->leftover, 0, TC_AES_BLOCK_SIZE);
 10265c2:	2210      	movs	r2, #16
 10265c4:	f104 0030 	add.w	r0, r4, #48	; 0x30
 10265c8:	2100      	movs	r1, #0
 10265ca:	f7fe ffd7 	bl	102557c <_set>
	s->leftover_offset = 0;
 10265ce:	2300      	movs	r3, #0

	/* Set countdown to max number of calls allowed before re-keying: */
	s->countdown = MAX_CALLS;
 10265d0:	2200      	movs	r2, #0
	s->leftover_offset = 0;
 10265d2:	6463      	str	r3, [r4, #68]	; 0x44
	s->countdown = MAX_CALLS;
 10265d4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 10265d8:	2001      	movs	r0, #1
 10265da:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50

	return TC_CRYPTO_SUCCESS;
}
 10265de:	bd10      	pop	{r4, pc}

010265e0 <tc_cmac_setup>:
{
 10265e0:	b570      	push	{r4, r5, r6, lr}
 10265e2:	4604      	mov	r4, r0
 10265e4:	460d      	mov	r5, r1
 10265e6:	4616      	mov	r6, r2
	if (s == (TCCmacState_t) 0 ||
 10265e8:	b310      	cbz	r0, 1026630 <tc_cmac_setup+0x50>
 10265ea:	b311      	cbz	r1, 1026632 <tc_cmac_setup+0x52>
	_set(s, 0, sizeof(*s));
 10265ec:	2258      	movs	r2, #88	; 0x58
 10265ee:	2100      	movs	r1, #0
 10265f0:	f7fe ffc4 	bl	102557c <_set>
	tc_aes128_set_encrypt_key(s->sched, key);
 10265f4:	4629      	mov	r1, r5
 10265f6:	4630      	mov	r0, r6
	s->sched = sched;
 10265f8:	64a6      	str	r6, [r4, #72]	; 0x48
	tc_aes128_set_encrypt_key(s->sched, key);
 10265fa:	f7df fb1d 	bl	1005c38 <tc_aes128_set_encrypt_key>
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
 10265fe:	2210      	movs	r2, #16
 1026600:	2100      	movs	r1, #0
 1026602:	4620      	mov	r0, r4
 1026604:	f7fe ffba 	bl	102557c <_set>
	gf_double (s->K1, s->iv);
 1026608:	f104 0510 	add.w	r5, r4, #16
	tc_aes_encrypt(s->iv, s->iv, s->sched);
 102660c:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 102660e:	4621      	mov	r1, r4
 1026610:	4620      	mov	r0, r4
 1026612:	f7ff ff5c 	bl	10264ce <tc_aes_encrypt>
	gf_double (s->K1, s->iv);
 1026616:	4621      	mov	r1, r4
 1026618:	4628      	mov	r0, r5
 102661a:	f7ff ffae 	bl	102657a <gf_double>
	gf_double (s->K2, s->K1);
 102661e:	4629      	mov	r1, r5
 1026620:	f104 0020 	add.w	r0, r4, #32
 1026624:	f7ff ffa9 	bl	102657a <gf_double>
	tc_cmac_init(s);
 1026628:	4620      	mov	r0, r4
 102662a:	f7ff ffc3 	bl	10265b4 <tc_cmac_init>
	return TC_CRYPTO_SUCCESS;
 102662e:	2001      	movs	r0, #1
}
 1026630:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
 1026632:	4608      	mov	r0, r1
 1026634:	e7fc      	b.n	1026630 <tc_cmac_setup+0x50>

01026636 <tc_cmac_update>:

int tc_cmac_update(TCCmacState_t s, const uint8_t *data, size_t data_length)
{
 1026636:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 102663a:	460e      	mov	r6, r1
 102663c:	4615      	mov	r5, r2
	unsigned int i;

	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
 102663e:	4604      	mov	r4, r0
 1026640:	2800      	cmp	r0, #0
 1026642:	d060      	beq.n	1026706 <tc_cmac_update+0xd0>
		return TC_CRYPTO_FAIL;
	}
	if (data_length == 0) {
 1026644:	b1fa      	cbz	r2, 1026686 <tc_cmac_update+0x50>
		return  TC_CRYPTO_SUCCESS;
	}
	if (data == (const uint8_t *) 0) {
 1026646:	2900      	cmp	r1, #0
 1026648:	d05d      	beq.n	1026706 <tc_cmac_update+0xd0>
		return TC_CRYPTO_FAIL;
	}

	if (s->countdown == 0) {
 102664a:	e9d0 3214 	ldrd	r3, r2, [r0, #80]	; 0x50
 102664e:	ea53 0102 	orrs.w	r1, r3, r2
 1026652:	d058      	beq.n	1026706 <tc_cmac_update+0xd0>
		return TC_CRYPTO_FAIL;
	}

	s->countdown--;
 1026654:	3b01      	subs	r3, #1

	if (s->leftover_offset > 0) {
 1026656:	f8d0 8044 	ldr.w	r8, [r0, #68]	; 0x44
	s->countdown--;
 102665a:	f142 32ff 	adc.w	r2, r2, #4294967295
 102665e:	e9c0 3214 	strd	r3, r2, [r0, #80]	; 0x50
	if (s->leftover_offset > 0) {
 1026662:	f1b8 0f00 	cmp.w	r8, #0
 1026666:	d02c      	beq.n	10266c2 <tc_cmac_update+0x8c>
		/* last data added to s didn't end on a TC_AES_BLOCK_SIZE byte boundary */
		size_t remaining_space = TC_AES_BLOCK_SIZE - s->leftover_offset;
 1026668:	f1c8 0710 	rsb	r7, r8, #16

		if (data_length < remaining_space) {
			/* still not enough data to encrypt this time either */
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
 102666c:	f108 0030 	add.w	r0, r8, #48	; 0x30
		if (data_length < remaining_space) {
 1026670:	42bd      	cmp	r5, r7
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
 1026672:	4420      	add	r0, r4
		if (data_length < remaining_space) {
 1026674:	d20a      	bcs.n	102668c <tc_cmac_update+0x56>
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
 1026676:	462b      	mov	r3, r5
 1026678:	4632      	mov	r2, r6
 102667a:	4629      	mov	r1, r5
 102667c:	f7fe ff71 	bl	1025562 <_copy>
			s->leftover_offset += data_length;
 1026680:	6c63      	ldr	r3, [r4, #68]	; 0x44
 1026682:	442b      	add	r3, r5
 1026684:	6463      	str	r3, [r4, #68]	; 0x44
		return  TC_CRYPTO_SUCCESS;
 1026686:	2001      	movs	r0, #1
		_copy(s->leftover, data_length, data, data_length);
		s->leftover_offset = data_length;
	}

	return TC_CRYPTO_SUCCESS;
}
 1026688:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		_copy(&s->leftover[s->leftover_offset],
 102668c:	463b      	mov	r3, r7
 102668e:	4632      	mov	r2, r6
 1026690:	4639      	mov	r1, r7
 1026692:	f7fe ff66 	bl	1025562 <_copy>
		s->leftover_offset = 0;
 1026696:	2300      	movs	r3, #0
 1026698:	3d10      	subs	r5, #16
 102669a:	6463      	str	r3, [r4, #68]	; 0x44
		data_length -= remaining_space;
 102669c:	4445      	add	r5, r8
		data += remaining_space;
 102669e:	443e      	add	r6, r7
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
 10266a0:	1e63      	subs	r3, r4, #1
 10266a2:	f104 010f 	add.w	r1, r4, #15
			s->iv[i] ^= s->leftover[i];
 10266a6:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 10266aa:	f893 0030 	ldrb.w	r0, [r3, #48]	; 0x30
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
 10266ae:	428b      	cmp	r3, r1
			s->iv[i] ^= s->leftover[i];
 10266b0:	ea82 0200 	eor.w	r2, r2, r0
 10266b4:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
 10266b6:	d1f6      	bne.n	10266a6 <tc_cmac_update+0x70>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
 10266b8:	4621      	mov	r1, r4
 10266ba:	4620      	mov	r0, r4
 10266bc:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 10266be:	f7ff ff06 	bl	10264ce <tc_aes_encrypt>
 10266c2:	f104 070f 	add.w	r7, r4, #15
	while (data_length > TC_AES_BLOCK_SIZE) {
 10266c6:	2d10      	cmp	r5, #16
 10266c8:	d80a      	bhi.n	10266e0 <tc_cmac_update+0xaa>
	if (data_length > 0) {
 10266ca:	2d00      	cmp	r5, #0
 10266cc:	d0db      	beq.n	1026686 <tc_cmac_update+0x50>
		_copy(s->leftover, data_length, data, data_length);
 10266ce:	462b      	mov	r3, r5
 10266d0:	4632      	mov	r2, r6
 10266d2:	4629      	mov	r1, r5
 10266d4:	f104 0030 	add.w	r0, r4, #48	; 0x30
 10266d8:	f7fe ff43 	bl	1025562 <_copy>
		s->leftover_offset = data_length;
 10266dc:	6465      	str	r5, [r4, #68]	; 0x44
 10266de:	e7d2      	b.n	1026686 <tc_cmac_update+0x50>
 10266e0:	1e63      	subs	r3, r4, #1
 10266e2:	1e71      	subs	r1, r6, #1
			s->iv[i] ^= data[i];
 10266e4:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 10266e8:	f811 0f01 	ldrb.w	r0, [r1, #1]!
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
 10266ec:	42bb      	cmp	r3, r7
			s->iv[i] ^= data[i];
 10266ee:	ea82 0200 	eor.w	r2, r2, r0
 10266f2:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
 10266f4:	d1f6      	bne.n	10266e4 <tc_cmac_update+0xae>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
 10266f6:	4621      	mov	r1, r4
 10266f8:	4620      	mov	r0, r4
 10266fa:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 10266fc:	f7ff fee7 	bl	10264ce <tc_aes_encrypt>
		data += TC_AES_BLOCK_SIZE;
 1026700:	3610      	adds	r6, #16
		data_length  -= TC_AES_BLOCK_SIZE;
 1026702:	3d10      	subs	r5, #16
 1026704:	e7df      	b.n	10266c6 <tc_cmac_update+0x90>
		return TC_CRYPTO_FAIL;
 1026706:	2000      	movs	r0, #0
 1026708:	e7be      	b.n	1026688 <tc_cmac_update+0x52>

0102670a <tc_cmac_final>:

int tc_cmac_final(uint8_t *tag, TCCmacState_t s)
{
 102670a:	b570      	push	{r4, r5, r6, lr}
 102670c:	460c      	mov	r4, r1
	uint8_t *k;
	unsigned int i;

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
 102670e:	4605      	mov	r5, r0
 1026710:	b1f0      	cbz	r0, 1026750 <tc_cmac_final+0x46>
 1026712:	b371      	cbz	r1, 1026772 <tc_cmac_final+0x68>
	    s == (TCCmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	if (s->leftover_offset == TC_AES_BLOCK_SIZE) {
 1026714:	6c4a      	ldr	r2, [r1, #68]	; 0x44
 1026716:	2a10      	cmp	r2, #16
 1026718:	d11b      	bne.n	1026752 <tc_cmac_final+0x48>
		/* the last message block is a full-sized block */
		k = (uint8_t *) s->K1;
 102671a:	3110      	adds	r1, #16

		_set(&s->leftover[s->leftover_offset], 0, remaining);
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
		k = (uint8_t *) s->K2;
	}
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
 102671c:	1e63      	subs	r3, r4, #1
 102671e:	3901      	subs	r1, #1
 1026720:	f104 000f 	add.w	r0, r4, #15
		s->iv[i] ^= s->leftover[i] ^ k[i];
 1026724:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 1026728:	f893 6030 	ldrb.w	r6, [r3, #48]	; 0x30
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
 102672c:	4298      	cmp	r0, r3
		s->iv[i] ^= s->leftover[i] ^ k[i];
 102672e:	ea82 0206 	eor.w	r2, r2, r6
 1026732:	f811 6f01 	ldrb.w	r6, [r1, #1]!
 1026736:	ea82 0206 	eor.w	r2, r2, r6
 102673a:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
 102673c:	d1f2      	bne.n	1026724 <tc_cmac_final+0x1a>
	}

	tc_aes_encrypt(tag, s->iv, s->sched);
 102673e:	4621      	mov	r1, r4
 1026740:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 1026742:	4628      	mov	r0, r5
 1026744:	f7ff fec3 	bl	10264ce <tc_aes_encrypt>

	/* erasing state: */
	tc_cmac_erase(s);
 1026748:	4620      	mov	r0, r4
 102674a:	f7ff ff2b 	bl	10265a4 <tc_cmac_erase>

	return TC_CRYPTO_SUCCESS;
 102674e:	2001      	movs	r0, #1
}
 1026750:	bd70      	pop	{r4, r5, r6, pc}
		_set(&s->leftover[s->leftover_offset], 0, remaining);
 1026752:	f102 0030 	add.w	r0, r2, #48	; 0x30
 1026756:	2100      	movs	r1, #0
 1026758:	f1c2 0210 	rsb	r2, r2, #16
 102675c:	4420      	add	r0, r4
 102675e:	f7fe ff0d 	bl	102557c <_set>
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
 1026762:	2280      	movs	r2, #128	; 0x80
 1026764:	6c63      	ldr	r3, [r4, #68]	; 0x44
		k = (uint8_t *) s->K2;
 1026766:	f104 0120 	add.w	r1, r4, #32
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
 102676a:	4423      	add	r3, r4
 102676c:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
		k = (uint8_t *) s->K2;
 1026770:	e7d4      	b.n	102671c <tc_cmac_final+0x12>
		return TC_CRYPTO_FAIL;
 1026772:	4608      	mov	r0, r1
 1026774:	e7ec      	b.n	1026750 <tc_cmac_final+0x46>

01026776 <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
 1026776:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
 1026778:	6800      	ldr	r0, [r0, #0]
 102677a:	f7df bacf 	b.w	1005d1c <z_arm_fatal_error>

0102677e <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
 102677e:	2100      	movs	r1, #0
 1026780:	2001      	movs	r0, #1
 1026782:	f7df bacb 	b.w	1005d1c <z_arm_fatal_error>

01026786 <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
 1026786:	b508      	push	{r3, lr}
	handler();
 1026788:	f7df fb90 	bl	1005eac <z_SysNmiOnReset>
	z_arm_int_exit();
}
 102678c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
 1026790:	f7df bc40 	b.w	1006014 <z_arm_exc_exit>

01026794 <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 1026794:	6e83      	ldr	r3, [r0, #104]	; 0x68
 1026796:	f383 880b 	msr	PSPLIM, r3
}
 102679a:	4770      	bx	lr

0102679c <z_log_msg_static_create.constprop.0>:
 102679c:	2300      	movs	r3, #0
 102679e:	f7dd bfb3 	b.w	1004708 <z_impl_z_log_msg_static_create>

010267a2 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
 10267a2:	e840 f300 	tt	r3, r0
int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
		return addr_info.flags.mpu_region;
 10267a6:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 10267aa:	b2d8      	uxtb	r0, r3
	}

	return -EINVAL;
}
 10267ac:	bf08      	it	eq
 10267ae:	f06f 0015 	mvneq.w	r0, #21
 10267b2:	4770      	bx	lr

010267b4 <mpu_configure_region>:
{
 10267b4:	b530      	push	{r4, r5, lr}
	p_attr->rbar = attr->rbar &
 10267b6:	890a      	ldrh	r2, [r1, #8]
 10267b8:	894d      	ldrh	r5, [r1, #10]
	region_conf.base = new_region->start;
 10267ba:	680b      	ldr	r3, [r1, #0]
		&new_region->attr, new_region->start, new_region->size);
 10267bc:	684c      	ldr	r4, [r1, #4]
 10267be:	f002 021f 	and.w	r2, r2, #31
{
 10267c2:	b085      	sub	sp, #20
 10267c4:	ea42 1245 	orr.w	r2, r2, r5, lsl #5
	region_conf.base = new_region->start;
 10267c8:	9300      	str	r3, [sp, #0]
 10267ca:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
 10267ce:	f023 031f 	bic.w	r3, r3, #31
 10267d2:	1e62      	subs	r2, r4, #1
 10267d4:	4413      	add	r3, r2
 10267d6:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1U)) {
 10267da:	2807      	cmp	r0, #7
 10267dc:	9303      	str	r3, [sp, #12]
 10267de:	d904      	bls.n	10267ea <mpu_configure_region+0x36>
}
 10267e0:	b005      	add	sp, #20
 10267e2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 10267e6:	f7e0 b807 	b.w	10067f8 <region_allocate_and_init.part.0>
	region_init(index, region_conf);
 10267ea:	4669      	mov	r1, sp
 10267ec:	f7df ffea 	bl	10067c4 <region_init>
}
 10267f0:	b005      	add	sp, #20
 10267f2:	bd30      	pop	{r4, r5, pc}

010267f4 <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
 10267f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10267f8:	4684      	mov	ip, r0
 10267fa:	460f      	mov	r7, r1
	register const char *s = nptr;
 10267fc:	4604      	mov	r4, r0

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
 10267fe:	4621      	mov	r1, r4
 1026800:	f814 3b01 	ldrb.w	r3, [r4], #1
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
 1026804:	2b20      	cmp	r3, #32
 1026806:	d0fa      	beq.n	10267fe <strtoul+0xa>
 1026808:	f1a3 0009 	sub.w	r0, r3, #9
 102680c:	2804      	cmp	r0, #4
 102680e:	d9f6      	bls.n	10267fe <strtoul+0xa>
	} while (isspace((unsigned char)c));
	if (c == '-') {
 1026810:	2b2d      	cmp	r3, #45	; 0x2d
 1026812:	d125      	bne.n	1026860 <strtoul+0x6c>
		neg = 1;
 1026814:	f04f 0e01 	mov.w	lr, #1
		c = *s++;
 1026818:	784b      	ldrb	r3, [r1, #1]
 102681a:	1c8c      	adds	r4, r1, #2
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
 102681c:	bb3a      	cbnz	r2, 102686e <strtoul+0x7a>
 102681e:	2b30      	cmp	r3, #48	; 0x30
 1026820:	d032      	beq.n	1026888 <strtoul+0x94>
		s += 2;
		base = 16;
	}

	if (base == 0) {
		base = c == '0' ? 8 : 10;
 1026822:	220a      	movs	r2, #10
	}

	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
 1026824:	f04f 31ff 	mov.w	r1, #4294967295
 1026828:	fbb1 f1f2 	udiv	r1, r1, r2
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
 102682c:	2500      	movs	r5, #0
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
 102682e:	fb02 f801 	mul.w	r8, r2, r1
	for (acc = 0, any = 0;; c = *s++) {
 1026832:	4628      	mov	r0, r5
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
 1026834:	ea6f 0808 	mvn.w	r8, r8
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
 1026838:	f1a3 0630 	sub.w	r6, r3, #48	; 0x30
		if (isdigit((unsigned char)c)) {
 102683c:	2e09      	cmp	r6, #9
 102683e:	d82a      	bhi.n	1026896 <strtoul+0xa2>
			c -= '0';
 1026840:	4633      	mov	r3, r6
		} else if (isalpha((unsigned char)c)) {
			c -= isupper((unsigned char)c) ? 'A' - 10 : 'a' - 10;
		} else {
			break;
		}
		if (c >= base) {
 1026842:	429a      	cmp	r2, r3
 1026844:	dd37      	ble.n	10268b6 <strtoul+0xc2>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
 1026846:	1c6e      	adds	r6, r5, #1
 1026848:	d007      	beq.n	102685a <strtoul+0x66>
 102684a:	4288      	cmp	r0, r1
 102684c:	d830      	bhi.n	10268b0 <strtoul+0xbc>
 102684e:	d101      	bne.n	1026854 <strtoul+0x60>
 1026850:	4543      	cmp	r3, r8
 1026852:	dc2d      	bgt.n	10268b0 <strtoul+0xbc>
			any = -1;
		} else {
			any = 1;
 1026854:	2501      	movs	r5, #1
			acc *= base;
			acc += c;
 1026856:	fb00 3002 	mla	r0, r0, r2, r3
	for (acc = 0, any = 0;; c = *s++) {
 102685a:	f814 3b01 	ldrb.w	r3, [r4], #1
		if (isdigit((unsigned char)c)) {
 102685e:	e7eb      	b.n	1026838 <strtoul+0x44>
	} else if (c == '+') {
 1026860:	2b2b      	cmp	r3, #43	; 0x2b
	register int neg = 0, any, cutlim;
 1026862:	f04f 0e00 	mov.w	lr, #0
		c = *s++;
 1026866:	bf04      	itt	eq
 1026868:	784b      	ldrbeq	r3, [r1, #1]
 102686a:	1c8c      	addeq	r4, r1, #2
 102686c:	e7d6      	b.n	102681c <strtoul+0x28>
	if ((base == 0 || base == 16) &&
 102686e:	2a10      	cmp	r2, #16
 1026870:	d1d8      	bne.n	1026824 <strtoul+0x30>
 1026872:	2b30      	cmp	r3, #48	; 0x30
 1026874:	d1d6      	bne.n	1026824 <strtoul+0x30>
	    c == '0' && (*s == 'x' || *s == 'X')) {
 1026876:	7821      	ldrb	r1, [r4, #0]
 1026878:	f001 01df 	and.w	r1, r1, #223	; 0xdf
 102687c:	2958      	cmp	r1, #88	; 0x58
 102687e:	d1d1      	bne.n	1026824 <strtoul+0x30>
		c = s[1];
 1026880:	7863      	ldrb	r3, [r4, #1]
		base = 16;
 1026882:	2210      	movs	r2, #16
		s += 2;
 1026884:	3402      	adds	r4, #2
	if (base == 0) {
 1026886:	e7cd      	b.n	1026824 <strtoul+0x30>
	    c == '0' && (*s == 'x' || *s == 'X')) {
 1026888:	7822      	ldrb	r2, [r4, #0]
 102688a:	f002 02df 	and.w	r2, r2, #223	; 0xdf
 102688e:	2a58      	cmp	r2, #88	; 0x58
 1026890:	d0f6      	beq.n	1026880 <strtoul+0x8c>
		base = c == '0' ? 8 : 10;
 1026892:	2208      	movs	r2, #8
 1026894:	e7c6      	b.n	1026824 <strtoul+0x30>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
 1026896:	f043 0620 	orr.w	r6, r3, #32
 102689a:	3e61      	subs	r6, #97	; 0x61
		} else if (isalpha((unsigned char)c)) {
 102689c:	2e19      	cmp	r6, #25
 102689e:	d80a      	bhi.n	10268b6 <strtoul+0xc2>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
 10268a0:	f1a3 0641 	sub.w	r6, r3, #65	; 0x41
			c -= isupper((unsigned char)c) ? 'A' - 10 : 'a' - 10;
 10268a4:	2e1a      	cmp	r6, #26
 10268a6:	bf34      	ite	cc
 10268a8:	2637      	movcc	r6, #55	; 0x37
 10268aa:	2657      	movcs	r6, #87	; 0x57
 10268ac:	1b9b      	subs	r3, r3, r6
 10268ae:	e7c8      	b.n	1026842 <strtoul+0x4e>
			any = -1;
 10268b0:	f04f 35ff 	mov.w	r5, #4294967295
 10268b4:	e7d1      	b.n	102685a <strtoul+0x66>
		}
	}
	if (any < 0) {
 10268b6:	1c6b      	adds	r3, r5, #1
 10268b8:	d107      	bne.n	10268ca <strtoul+0xd6>
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
 10268ba:	f7f9 ff55 	bl	1020768 <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
 10268be:	2322      	movs	r3, #34	; 0x22
 10268c0:	6003      	str	r3, [r0, #0]
		acc = ULONG_MAX;
 10268c2:	4628      	mov	r0, r5
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
 10268c4:	b947      	cbnz	r7, 10268d8 <strtoul+0xe4>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
 10268c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (neg) {
 10268ca:	f1be 0f00 	cmp.w	lr, #0
 10268ce:	d000      	beq.n	10268d2 <strtoul+0xde>
		acc = -acc;
 10268d0:	4240      	negs	r0, r0
	if (endptr != NULL) {
 10268d2:	2f00      	cmp	r7, #0
 10268d4:	d0f7      	beq.n	10268c6 <strtoul+0xd2>
		*endptr = (char *)(any ? s - 1 : nptr);
 10268d6:	b10d      	cbz	r5, 10268dc <strtoul+0xe8>
 10268d8:	f104 3cff 	add.w	ip, r4, #4294967295
 10268dc:	f8c7 c000 	str.w	ip, [r7]
	return acc;
 10268e0:	e7f1      	b.n	10268c6 <strtoul+0xd2>

010268e2 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
 10268e2:	4603      	mov	r3, r0
 10268e4:	3901      	subs	r1, #1
 10268e6:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 10268ea:	b90a      	cbnz	r2, 10268f0 <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
 10268ec:	701a      	strb	r2, [r3, #0]

	return dest;
}
 10268ee:	4770      	bx	lr
		*d = *s;
 10268f0:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
 10268f4:	e7f7      	b.n	10268e6 <strcpy+0x4>

010268f6 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
 10268f6:	4603      	mov	r3, r0
	size_t n = 0;
 10268f8:	2000      	movs	r0, #0

	while (*s != '\0') {
 10268fa:	5c1a      	ldrb	r2, [r3, r0]
 10268fc:	b902      	cbnz	r2, 1026900 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
 10268fe:	4770      	bx	lr
		n++;
 1026900:	3001      	adds	r0, #1
 1026902:	e7fa      	b.n	10268fa <strlen+0x4>

01026904 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
 1026904:	4603      	mov	r3, r0
	size_t n = 0;
 1026906:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
 1026908:	5c1a      	ldrb	r2, [r3, r0]
 102690a:	b10a      	cbz	r2, 1026910 <strnlen+0xc>
 102690c:	4288      	cmp	r0, r1
 102690e:	d100      	bne.n	1026912 <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
 1026910:	4770      	bx	lr
		n++;
 1026912:	3001      	adds	r0, #1
 1026914:	e7f8      	b.n	1026908 <strnlen+0x4>

01026916 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
 1026916:	1e43      	subs	r3, r0, #1
 1026918:	3901      	subs	r1, #1
 102691a:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 102691e:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 1026922:	4282      	cmp	r2, r0
 1026924:	d101      	bne.n	102692a <strcmp+0x14>
 1026926:	2a00      	cmp	r2, #0
 1026928:	d1f7      	bne.n	102691a <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
 102692a:	1a10      	subs	r0, r2, r0
 102692c:	4770      	bx	lr

0102692e <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
 102692e:	b570      	push	{r4, r5, r6, lr}
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
 1026930:	460b      	mov	r3, r1
 1026932:	4605      	mov	r5, r0
 1026934:	b162      	cbz	r2, 1026950 <strncmp+0x22>
 1026936:	f810 6b01 	ldrb.w	r6, [r0], #1
 102693a:	781c      	ldrb	r4, [r3, #0]
 102693c:	3101      	adds	r1, #1
 102693e:	42b4      	cmp	r4, r6
 1026940:	d100      	bne.n	1026944 <strncmp+0x16>
 1026942:	b91c      	cbnz	r4, 102694c <strncmp+0x1e>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
 1026944:	782a      	ldrb	r2, [r5, #0]
 1026946:	781b      	ldrb	r3, [r3, #0]
 1026948:	1ad0      	subs	r0, r2, r3
 102694a:	e002      	b.n	1026952 <strncmp+0x24>
		n--;
 102694c:	3a01      	subs	r2, #1
 102694e:	e7ef      	b.n	1026930 <strncmp+0x2>
	return (n == 0) ? 0 : (*s1 - *s2);
 1026950:	4610      	mov	r0, r2
}
 1026952:	bd70      	pop	{r4, r5, r6, pc}

01026954 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
 1026954:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
 1026956:	b15a      	cbz	r2, 1026970 <memcmp+0x1c>
 1026958:	3901      	subs	r1, #1
 102695a:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
 102695c:	f810 2b01 	ldrb.w	r2, [r0], #1
 1026960:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 1026964:	42a0      	cmp	r0, r4
 1026966:	d001      	beq.n	102696c <memcmp+0x18>
 1026968:	429a      	cmp	r2, r3
 102696a:	d0f7      	beq.n	102695c <memcmp+0x8>
		c1++;
		c2++;
	}

	return *c1 - *c2;
 102696c:	1ad0      	subs	r0, r2, r3
}
 102696e:	bd10      	pop	{r4, pc}
		return 0;
 1026970:	4610      	mov	r0, r2
 1026972:	e7fc      	b.n	102696e <memcmp+0x1a>

01026974 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
 1026974:	b510      	push	{r4, lr}
 1026976:	1e43      	subs	r3, r0, #1
 1026978:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
 102697a:	4291      	cmp	r1, r2
 102697c:	d100      	bne.n	1026980 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
 102697e:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
 1026980:	f811 4b01 	ldrb.w	r4, [r1], #1
 1026984:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
 1026988:	e7f7      	b.n	102697a <memcpy+0x6>

0102698a <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
 102698a:	4603      	mov	r3, r0
	unsigned char c_byte = (unsigned char)c;
 102698c:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
 102698e:	4402      	add	r2, r0
 1026990:	4293      	cmp	r3, r2
 1026992:	d100      	bne.n	1026996 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
 1026994:	4770      	bx	lr
		*(d_byte++) = c_byte;
 1026996:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
 102699a:	e7f9      	b.n	1026990 <memset+0x6>

0102699c <_stdout_hook_default>:
}
 102699c:	f04f 30ff 	mov.w	r0, #4294967295
 10269a0:	4770      	bx	lr

010269a2 <sprintf_out>:
	if (p->len > 1) { /* need to reserve a byte for EOS */
 10269a2:	684b      	ldr	r3, [r1, #4]
 10269a4:	2b01      	cmp	r3, #1
 10269a6:	dd07      	ble.n	10269b8 <sprintf_out+0x16>
		*(p->ptr) = c;
 10269a8:	680b      	ldr	r3, [r1, #0]
 10269aa:	7018      	strb	r0, [r3, #0]
		p->ptr += 1;
 10269ac:	680b      	ldr	r3, [r1, #0]
 10269ae:	3301      	adds	r3, #1
 10269b0:	600b      	str	r3, [r1, #0]
		p->len -= 1;
 10269b2:	684b      	ldr	r3, [r1, #4]
 10269b4:	3b01      	subs	r3, #1
 10269b6:	604b      	str	r3, [r1, #4]
}
 10269b8:	2000      	movs	r0, #0
 10269ba:	4770      	bx	lr

010269bc <bt_rpa_irk_matches>:

	LOG_DBG("irk %s", bt_hex(irk, 16));
	LOG_DBG("r %s", bt_hex(r, 3));

	/* r' = padding || r */
	memcpy(res, r, 3);
 10269bc:	2203      	movs	r2, #3
	return 0;
}

#if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CTLR_PRIVACY)
bool bt_rpa_irk_matches(const uint8_t irk[16], const bt_addr_t *addr)
{
 10269be:	b530      	push	{r4, r5, lr}
 10269c0:	4605      	mov	r5, r0
 10269c2:	b087      	sub	sp, #28
 10269c4:	460c      	mov	r4, r1
	memcpy(res, r, 3);
 10269c6:	a802      	add	r0, sp, #8
 10269c8:	4411      	add	r1, r2
 10269ca:	f7ff ffd3 	bl	1026974 <memcpy>
	(void)memset(res + 3, 0, 13);
 10269ce:	220d      	movs	r2, #13
 10269d0:	2100      	movs	r1, #0
 10269d2:	f10d 000b 	add.w	r0, sp, #11
 10269d6:	f7ff ffd8 	bl	102698a <memset>
	return bt_encrypt_le(key, plaintext, enc_data);
 10269da:	aa02      	add	r2, sp, #8
 10269dc:	4611      	mov	r1, r2
 10269de:	4628      	mov	r0, r5
 10269e0:	f7ec ffa8 	bl	1013934 <bt_encrypt_le>
	if (err) {
 10269e4:	b110      	cbz	r0, 10269ec <bt_rpa_irk_matches+0x30>

	LOG_DBG("IRK %s bdaddr %s", bt_hex(irk, 16), bt_addr_str(addr));

	err = ah(irk, addr->val + 3, hash);
	if (err) {
		return false;
 10269e6:	2000      	movs	r0, #0
	}

	return !memcmp(addr->val, hash, 3);
}
 10269e8:	b007      	add	sp, #28
 10269ea:	bd30      	pop	{r4, r5, pc}
	memcpy(out, res, 3);
 10269ec:	2203      	movs	r2, #3
 10269ee:	a902      	add	r1, sp, #8
 10269f0:	a801      	add	r0, sp, #4
 10269f2:	f7ff ffbf 	bl	1026974 <memcpy>
	return !memcmp(addr->val, hash, 3);
 10269f6:	2203      	movs	r2, #3
 10269f8:	4620      	mov	r0, r4
 10269fa:	a901      	add	r1, sp, #4
 10269fc:	f7ff ffaa 	bl	1026954 <memcmp>
 1026a00:	fab0 f080 	clz	r0, r0
 1026a04:	0940      	lsrs	r0, r0, #5
 1026a06:	e7ef      	b.n	10269e8 <bt_rpa_irk_matches+0x2c>

01026a08 <send_cmd_status>:
{
 1026a08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
 1026a0c:	f04f 32ff 	mov.w	r2, #4294967295
{
 1026a10:	4606      	mov	r6, r0
 1026a12:	460d      	mov	r5, r1
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
 1026a14:	f04f 33ff 	mov.w	r3, #4294967295
 1026a18:	2100      	movs	r1, #0
 1026a1a:	200f      	movs	r0, #15
 1026a1c:	f7e0 fcf2 	bl	1007404 <bt_buf_get_evt>
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
 1026a20:	2701      	movs	r7, #1
	return net_buf_simple_add(&buf->b, len);
 1026a22:	f100 080c 	add.w	r8, r0, #12
 1026a26:	4604      	mov	r4, r0
 1026a28:	7607      	strb	r7, [r0, #24]
 1026a2a:	2102      	movs	r1, #2
 1026a2c:	4640      	mov	r0, r8
 1026a2e:	f7f7 fc33 	bl	101e298 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
 1026a32:	230f      	movs	r3, #15
	hdr->len = sizeof(*evt);
 1026a34:	2104      	movs	r1, #4
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
 1026a36:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*evt);
 1026a38:	7041      	strb	r1, [r0, #1]
 1026a3a:	4640      	mov	r0, r8
 1026a3c:	f7f7 fc2c 	bl	101e298 <net_buf_simple_add>
	evt->ncmd = 1U;
 1026a40:	7047      	strb	r7, [r0, #1]
	evt->opcode = sys_cpu_to_le16(opcode);
 1026a42:	8046      	strh	r6, [r0, #2]
	evt->status = status;
 1026a44:	7005      	strb	r5, [r0, #0]
		bt_recv_prio(buf);
 1026a46:	4620      	mov	r0, r4
}
 1026a48:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		bt_recv_prio(buf);
 1026a4c:	f7e1 beb8 	b.w	10087c0 <bt_recv_prio>

01026a50 <bt_hci_ecc_supported_commands>:
void bt_hci_ecc_supported_commands(uint8_t *supported_commands)
{
	/* LE Read Local P-256 Public Key */
	supported_commands[34] |= BIT(1);
	/* LE Generate DH Key v1 */
	supported_commands[34] |= BIT(2);
 1026a50:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
 1026a54:	f043 0306 	orr.w	r3, r3, #6
 1026a58:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
	/* LE Generate DH Key v2 */
	supported_commands[41] |= BIT(2);
 1026a5c:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 1026a60:	f043 0304 	orr.w	r3, r3, #4
 1026a64:	f880 3029 	strb.w	r3, [r0, #41]	; 0x29
}
 1026a68:	4770      	bx	lr

01026a6a <default_CSPRNG>:

int default_CSPRNG(uint8_t *dst, unsigned int len)
{
 1026a6a:	b508      	push	{r3, lr}
	return !bt_rand(dst, len);
 1026a6c:	f7ec ff60 	bl	1013930 <bt_rand>
}
 1026a70:	fab0 f080 	clz	r0, r0
 1026a74:	0940      	lsrs	r0, r0, #5
 1026a76:	bd08      	pop	{r3, pc}

01026a78 <bt_settings_decode_key>:
{
 1026a78:	b570      	push	{r4, r5, r6, lr}
 1026a7a:	460d      	mov	r5, r1
	if (settings_name_next(key, NULL) != 13) {
 1026a7c:	2100      	movs	r1, #0
{
 1026a7e:	4604      	mov	r4, r0
	if (settings_name_next(key, NULL) != 13) {
 1026a80:	f7fe fca0 	bl	10253c4 <settings_name_next>
 1026a84:	280d      	cmp	r0, #13
 1026a86:	d118      	bne.n	1026aba <bt_settings_decode_key+0x42>
	if (key[12] == '0') {
 1026a88:	7b23      	ldrb	r3, [r4, #12]
 1026a8a:	2b30      	cmp	r3, #48	; 0x30
 1026a8c:	d013      	beq.n	1026ab6 <bt_settings_decode_key+0x3e>
	} else if (key[12] == '1') {
 1026a8e:	2b31      	cmp	r3, #49	; 0x31
 1026a90:	d113      	bne.n	1026aba <bt_settings_decode_key+0x42>
 1026a92:	2301      	movs	r3, #1
		addr->type = BT_ADDR_LE_PUBLIC;
 1026a94:	f805 3b06 	strb.w	r3, [r5], #6
 1026a98:	f104 060c 	add.w	r6, r4, #12
		hex2bin(&key[i * 2], 2, &addr->a.val[5 - i], 1);
 1026a9c:	462a      	mov	r2, r5
 1026a9e:	4620      	mov	r0, r4
 1026aa0:	2301      	movs	r3, #1
 1026aa2:	2102      	movs	r1, #2
	for (uint8_t i = 0; i < 6; i++) {
 1026aa4:	3402      	adds	r4, #2
		hex2bin(&key[i * 2], 2, &addr->a.val[5 - i], 1);
 1026aa6:	f7fd fe3f 	bl	1024728 <hex2bin>
	for (uint8_t i = 0; i < 6; i++) {
 1026aaa:	42b4      	cmp	r4, r6
 1026aac:	f105 35ff 	add.w	r5, r5, #4294967295
 1026ab0:	d1f4      	bne.n	1026a9c <bt_settings_decode_key+0x24>
	return 0;
 1026ab2:	2000      	movs	r0, #0
}
 1026ab4:	bd70      	pop	{r4, r5, r6, pc}
 1026ab6:	2300      	movs	r3, #0
 1026ab8:	e7ec      	b.n	1026a94 <bt_settings_decode_key+0x1c>
		return -EINVAL;
 1026aba:	f06f 0015 	mvn.w	r0, #21
 1026abe:	e7f9      	b.n	1026ab4 <bt_settings_decode_key+0x3c>

01026ac0 <bt_uuid_cmp>:

	return memcmp(uuid1.val, uuid2.val, 16);
}

int bt_uuid_cmp(const struct bt_uuid *u1, const struct bt_uuid *u2)
{
 1026ac0:	b510      	push	{r4, lr}
 1026ac2:	460c      	mov	r4, r1
	/* Convert to 128 bit if types don't match */
	if (u1->type != u2->type) {
 1026ac4:	7801      	ldrb	r1, [r0, #0]
 1026ac6:	7822      	ldrb	r2, [r4, #0]
{
 1026ac8:	b08a      	sub	sp, #40	; 0x28
	if (u1->type != u2->type) {
 1026aca:	428a      	cmp	r2, r1
 1026acc:	d00f      	beq.n	1026aee <bt_uuid_cmp+0x2e>
	uuid_to_uuid128(u1, &uuid1);
 1026ace:	4669      	mov	r1, sp
 1026ad0:	f7e0 fc1c 	bl	100730c <uuid_to_uuid128>
	uuid_to_uuid128(u2, &uuid2);
 1026ad4:	4620      	mov	r0, r4
 1026ad6:	a905      	add	r1, sp, #20
 1026ad8:	f7e0 fc18 	bl	100730c <uuid_to_uuid128>
	return memcmp(uuid1.val, uuid2.val, 16);
 1026adc:	2210      	movs	r2, #16
 1026ade:	f10d 0115 	add.w	r1, sp, #21
 1026ae2:	f10d 0001 	add.w	r0, sp, #1
 1026ae6:	f7ff ff35 	bl	1026954 <memcmp>
	case BT_UUID_TYPE_128:
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
	}

	return -EINVAL;
}
 1026aea:	b00a      	add	sp, #40	; 0x28
 1026aec:	bd10      	pop	{r4, pc}
	switch (u1->type) {
 1026aee:	2a01      	cmp	r2, #1
 1026af0:	d006      	beq.n	1026b00 <bt_uuid_cmp+0x40>
 1026af2:	2a02      	cmp	r2, #2
 1026af4:	d007      	beq.n	1026b06 <bt_uuid_cmp+0x46>
 1026af6:	b972      	cbnz	r2, 1026b16 <bt_uuid_cmp+0x56>
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
 1026af8:	8840      	ldrh	r0, [r0, #2]
 1026afa:	8863      	ldrh	r3, [r4, #2]
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
 1026afc:	1ac0      	subs	r0, r0, r3
 1026afe:	e7f4      	b.n	1026aea <bt_uuid_cmp+0x2a>
 1026b00:	6840      	ldr	r0, [r0, #4]
 1026b02:	6863      	ldr	r3, [r4, #4]
 1026b04:	e7fa      	b.n	1026afc <bt_uuid_cmp+0x3c>
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
 1026b06:	2210      	movs	r2, #16
 1026b08:	1c61      	adds	r1, r4, #1
 1026b0a:	3001      	adds	r0, #1
}
 1026b0c:	b00a      	add	sp, #40	; 0x28
 1026b0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
 1026b12:	f7ff bf1f 	b.w	1026954 <memcmp>
	switch (u1->type) {
 1026b16:	f06f 0015 	mvn.w	r0, #21
 1026b1a:	e7e6      	b.n	1026aea <bt_uuid_cmp+0x2a>

01026b1c <bt_uuid_create>:

bool bt_uuid_create(struct bt_uuid *uuid, const uint8_t *data, uint8_t data_len)
{
	/* Copy UUID from packet data/internal variable to internal bt_uuid */
	switch (data_len) {
 1026b1c:	2a04      	cmp	r2, #4
{
 1026b1e:	b510      	push	{r4, lr}
	switch (data_len) {
 1026b20:	d00a      	beq.n	1026b38 <bt_uuid_create+0x1c>
 1026b22:	2a10      	cmp	r2, #16
 1026b24:	d00d      	beq.n	1026b42 <bt_uuid_create+0x26>
 1026b26:	2a02      	cmp	r2, #2
 1026b28:	f04f 0300 	mov.w	r3, #0
 1026b2c:	d10f      	bne.n	1026b4e <bt_uuid_create+0x32>
	case BT_UUID_SIZE_16:
		uuid->type = BT_UUID_TYPE_16;
 1026b2e:	7003      	strb	r3, [r0, #0]
		BT_UUID_16(uuid)->val = sys_get_le16(data);
 1026b30:	880b      	ldrh	r3, [r1, #0]
 1026b32:	8043      	strh	r3, [r0, #2]
		memcpy(&BT_UUID_128(uuid)->val, data, 16);
		break;
	default:
		return false;
	}
	return true;
 1026b34:	2001      	movs	r0, #1
}
 1026b36:	bd10      	pop	{r4, pc}
		uuid->type = BT_UUID_TYPE_32;
 1026b38:	2301      	movs	r3, #1
 1026b3a:	7003      	strb	r3, [r0, #0]
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
 1026b3c:	680b      	ldr	r3, [r1, #0]
		BT_UUID_32(uuid)->val = sys_get_le32(data);
 1026b3e:	6043      	str	r3, [r0, #4]
		break;
 1026b40:	e7f8      	b.n	1026b34 <bt_uuid_create+0x18>
		uuid->type = BT_UUID_TYPE_128;
 1026b42:	2302      	movs	r3, #2
 1026b44:	f800 3b01 	strb.w	r3, [r0], #1
		memcpy(&BT_UUID_128(uuid)->val, data, 16);
 1026b48:	f7ff ff14 	bl	1026974 <memcpy>
		break;
 1026b4c:	e7f2      	b.n	1026b34 <bt_uuid_create+0x18>
	switch (data_len) {
 1026b4e:	4618      	mov	r0, r3
 1026b50:	e7f1      	b.n	1026b36 <bt_uuid_create+0x1a>

01026b52 <bt_addr_le_create_static>:
#include <zephyr/bluetooth/addr.h>
#include <zephyr/bluetooth/crypto.h>

static inline int create_random_addr(bt_addr_le_t *addr)
{
	addr->type = BT_ADDR_LE_RANDOM;
 1026b52:	2301      	movs	r3, #1

	return 0;
}

int bt_addr_le_create_static(bt_addr_le_t *addr)
{
 1026b54:	b510      	push	{r4, lr}
	return bt_rand(addr->a.val, 6);
 1026b56:	2106      	movs	r1, #6
{
 1026b58:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
 1026b5a:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
 1026b5e:	f7ec fee7 	bl	1013930 <bt_rand>
	int err;

	err = create_random_addr(addr);
	if (err) {
 1026b62:	b918      	cbnz	r0, 1026b6c <bt_addr_le_create_static+0x1a>
		return err;
	}

	BT_ADDR_SET_STATIC(&addr->a);
 1026b64:	79a3      	ldrb	r3, [r4, #6]
 1026b66:	f063 033f 	orn	r3, r3, #63	; 0x3f
 1026b6a:	71a3      	strb	r3, [r4, #6]

	return 0;
}
 1026b6c:	bd10      	pop	{r4, pc}

01026b6e <bt_hci_evt_get_flags>:
 *
 * @return HCI event flags for the specified event.
 */
static inline uint8_t bt_hci_evt_get_flags(uint8_t evt)
{
	switch (evt) {
 1026b6e:	280f      	cmp	r0, #15
 1026b70:	d807      	bhi.n	1026b82 <bt_hci_evt_get_flags+0x14>
 1026b72:	280d      	cmp	r0, #13
 1026b74:	d80b      	bhi.n	1026b8e <bt_hci_evt_get_flags+0x20>
#endif /* CONFIG_BT_CONN ||  CONFIG_BT_ISO */
	case BT_HCI_EVT_CMD_COMPLETE:
	case BT_HCI_EVT_CMD_STATUS:
		return BT_HCI_EVT_FLAG_RECV_PRIO;
	default:
		return BT_HCI_EVT_FLAG_RECV;
 1026b76:	2805      	cmp	r0, #5
 1026b78:	bf08      	it	eq
 1026b7a:	2003      	moveq	r0, #3
 1026b7c:	bf18      	it	ne
 1026b7e:	2002      	movne	r0, #2
 1026b80:	4770      	bx	lr
	switch (evt) {
 1026b82:	2813      	cmp	r0, #19
 1026b84:	d003      	beq.n	1026b8e <bt_hci_evt_get_flags+0x20>
		return BT_HCI_EVT_FLAG_RECV;
 1026b86:	281a      	cmp	r0, #26
 1026b88:	bf08      	it	eq
 1026b8a:	2001      	moveq	r0, #1
 1026b8c:	e7f6      	b.n	1026b7c <bt_hci_evt_get_flags+0xe>
	switch (evt) {
 1026b8e:	2001      	movs	r0, #1
	}
}
 1026b90:	4770      	bx	lr

01026b92 <update_sec_level>:
	if (conn->le.keys && (conn->le.keys->flags & BT_KEYS_AUTHENTICATED)) {
 1026b92:	f8d0 30c0 	ldr.w	r3, [r0, #192]	; 0xc0
 1026b96:	b183      	cbz	r3, 1026bba <update_sec_level+0x28>
 1026b98:	7b5a      	ldrb	r2, [r3, #13]
 1026b9a:	07d1      	lsls	r1, r2, #31
 1026b9c:	d50d      	bpl.n	1026bba <update_sec_level+0x28>
		if (conn->le.keys->flags & BT_KEYS_SC &&
 1026b9e:	06d2      	lsls	r2, r2, #27
 1026ba0:	d50d      	bpl.n	1026bbe <update_sec_level+0x2c>
 1026ba2:	7b1b      	ldrb	r3, [r3, #12]
 1026ba4:	2b10      	cmp	r3, #16
 1026ba6:	bf14      	ite	ne
 1026ba8:	2303      	movne	r3, #3
 1026baa:	2304      	moveq	r3, #4
			conn->sec_level = BT_SECURITY_L3;
 1026bac:	7243      	strb	r3, [r0, #9]
	return !(conn->required_sec_level > conn->sec_level);
 1026bae:	7a80      	ldrb	r0, [r0, #10]
}
 1026bb0:	4298      	cmp	r0, r3
 1026bb2:	bf8c      	ite	hi
 1026bb4:	2000      	movhi	r0, #0
 1026bb6:	2001      	movls	r0, #1
 1026bb8:	4770      	bx	lr
 1026bba:	2302      	movs	r3, #2
 1026bbc:	e7f6      	b.n	1026bac <update_sec_level+0x1a>
 1026bbe:	2303      	movs	r3, #3
 1026bc0:	e7f4      	b.n	1026bac <update_sec_level+0x1a>

01026bc2 <hci_vendor_event>:
}
 1026bc2:	4770      	bx	lr

01026bc4 <bt_addr_le_copy>:
	memcpy(dst, src, sizeof(*dst));
 1026bc4:	2207      	movs	r2, #7
 1026bc6:	f7ff bed5 	b.w	1026974 <memcpy>

01026bca <atomic_or>:
{
 1026bca:	4603      	mov	r3, r0
 1026bcc:	b510      	push	{r4, lr}
}
 1026bce:	e8d3 0fef 	ldaex	r0, [r3]
 1026bd2:	ea40 0201 	orr.w	r2, r0, r1
 1026bd6:	e8c3 2fe4 	stlex	r4, r2, [r3]
 1026bda:	2c00      	cmp	r4, #0
 1026bdc:	d1f7      	bne.n	1026bce <atomic_or+0x4>
 1026bde:	bd10      	pop	{r4, pc}

01026be0 <z_log_msg_static_create.constprop.0>:
 1026be0:	2300      	movs	r3, #0
 1026be2:	f7dd bd91 	b.w	1004708 <z_impl_z_log_msg_static_create>

01026be6 <atomic_and.isra.0>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1026be6:	e8d0 3fef 	ldaex	r3, [r0]
 1026bea:	400b      	ands	r3, r1
 1026bec:	e8c0 3fe2 	stlex	r2, r3, [r0]
 1026bf0:	2a00      	cmp	r2, #0
 1026bf2:	d1f8      	bne.n	1026be6 <atomic_and.isra.0>
}
 1026bf4:	4770      	bx	lr

01026bf6 <sys_put_le64>:
	dst[1] = val >> 8;
 1026bf6:	f3c0 2307 	ubfx	r3, r0, #8, #8
 1026bfa:	7053      	strb	r3, [r2, #1]
	dst[0] = val;
 1026bfc:	2300      	movs	r3, #0
 1026bfe:	7010      	strb	r0, [r2, #0]
	dst[1] = val >> 8;
 1026c00:	0e00      	lsrs	r0, r0, #24
 1026c02:	70d0      	strb	r0, [r2, #3]
 1026c04:	f3c1 2007 	ubfx	r0, r1, #8, #8
 1026c08:	0e09      	lsrs	r1, r1, #24
	dst[0] = val;
 1026c0a:	7093      	strb	r3, [r2, #2]
 1026c0c:	7113      	strb	r3, [r2, #4]
	dst[1] = val >> 8;
 1026c0e:	7150      	strb	r0, [r2, #5]
	dst[0] = val;
 1026c10:	7193      	strb	r3, [r2, #6]
	dst[1] = val >> 8;
 1026c12:	71d1      	strb	r1, [r2, #7]
}
 1026c14:	4770      	bx	lr

01026c16 <le_conn_param_neg_reply>:
{
 1026c16:	b570      	push	{r4, r5, r6, lr}
 1026c18:	4606      	mov	r6, r0
 1026c1a:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY,
 1026c1c:	f242 0021 	movw	r0, #8225	; 0x2021
 1026c20:	2103      	movs	r1, #3
 1026c22:	f7e1 f833 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 1026c26:	4604      	mov	r4, r0
 1026c28:	b918      	cbnz	r0, 1026c32 <le_conn_param_neg_reply+0x1c>
}
 1026c2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 1026c2e:	f7e0 bc67 	b.w	1007500 <le_conn_param_neg_reply.part.0>
 1026c32:	2103      	movs	r1, #3
 1026c34:	300c      	adds	r0, #12
 1026c36:	f7f7 fb2f 	bl	101e298 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(handle);
 1026c3a:	8006      	strh	r6, [r0, #0]
	cp->reason = sys_cpu_to_le16(reason);
 1026c3c:	7085      	strb	r5, [r0, #2]
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
 1026c3e:	4621      	mov	r1, r4
}
 1026c40:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
 1026c44:	f242 0021 	movw	r0, #8225	; 0x2021
 1026c48:	f7e1 b86e 	b.w	1007d28 <bt_hci_cmd_send>

01026c4c <bt_hci_disconnect>:
{
 1026c4c:	b570      	push	{r4, r5, r6, lr}
 1026c4e:	4606      	mov	r6, r0
 1026c50:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_DISCONNECT, sizeof(*disconn));
 1026c52:	f240 4006 	movw	r0, #1030	; 0x406
 1026c56:	2103      	movs	r1, #3
 1026c58:	f7e1 f818 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 1026c5c:	4604      	mov	r4, r0
 1026c5e:	b168      	cbz	r0, 1026c7c <bt_hci_disconnect+0x30>
 1026c60:	2103      	movs	r1, #3
 1026c62:	300c      	adds	r0, #12
 1026c64:	f7f7 fb18 	bl	101e298 <net_buf_simple_add>
	disconn->handle = sys_cpu_to_le16(handle);
 1026c68:	8006      	strh	r6, [r0, #0]
	disconn->reason = reason;
 1026c6a:	7085      	strb	r5, [r0, #2]
	return bt_hci_cmd_send_sync(BT_HCI_OP_DISCONNECT, buf, NULL);
 1026c6c:	4621      	mov	r1, r4
}
 1026c6e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_DISCONNECT, buf, NULL);
 1026c72:	2200      	movs	r2, #0
 1026c74:	f240 4006 	movw	r0, #1030	; 0x406
 1026c78:	f7e1 b95e 	b.w	1007f38 <bt_hci_cmd_send_sync>
}
 1026c7c:	f06f 0068 	mvn.w	r0, #104	; 0x68
 1026c80:	bd70      	pop	{r4, r5, r6, pc}

01026c82 <bt_le_set_data_len>:
{
 1026c82:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1026c84:	4607      	mov	r7, r0
 1026c86:	460e      	mov	r6, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_DATA_LEN, sizeof(*cp));
 1026c88:	f242 0022 	movw	r0, #8226	; 0x2022
 1026c8c:	2106      	movs	r1, #6
{
 1026c8e:	4615      	mov	r5, r2
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_DATA_LEN, sizeof(*cp));
 1026c90:	f7e0 fffc 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 1026c94:	4604      	mov	r4, r0
 1026c96:	b178      	cbz	r0, 1026cb8 <bt_le_set_data_len+0x36>
 1026c98:	2106      	movs	r1, #6
 1026c9a:	300c      	adds	r0, #12
 1026c9c:	f7f7 fafc 	bl	101e298 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
 1026ca0:	883b      	ldrh	r3, [r7, #0]
	cp->tx_octets = sys_cpu_to_le16(tx_octets);
 1026ca2:	8046      	strh	r6, [r0, #2]
	cp->handle = sys_cpu_to_le16(conn->handle);
 1026ca4:	8003      	strh	r3, [r0, #0]
	cp->tx_time = sys_cpu_to_le16(tx_time);
 1026ca6:	8085      	strh	r5, [r0, #4]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_DATA_LEN, buf, NULL);
 1026ca8:	4621      	mov	r1, r4
}
 1026caa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_DATA_LEN, buf, NULL);
 1026cae:	2200      	movs	r2, #0
 1026cb0:	f242 0022 	movw	r0, #8226	; 0x2022
 1026cb4:	f7e1 b940 	b.w	1007f38 <bt_hci_cmd_send_sync>
}
 1026cb8:	f06f 0068 	mvn.w	r0, #104	; 0x68
 1026cbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

01026cbe <bt_le_set_phy>:
{
 1026cbe:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1026cc2:	4681      	mov	r9, r0
 1026cc4:	4688      	mov	r8, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
 1026cc6:	f242 0032 	movw	r0, #8242	; 0x2032
 1026cca:	2107      	movs	r1, #7
{
 1026ccc:	4617      	mov	r7, r2
 1026cce:	461e      	mov	r6, r3
 1026cd0:	f89d a020 	ldrb.w	sl, [sp, #32]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
 1026cd4:	f7e0 ffda 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 1026cd8:	4605      	mov	r5, r0
 1026cda:	b1a0      	cbz	r0, 1026d06 <bt_le_set_phy+0x48>
 1026cdc:	2107      	movs	r1, #7
 1026cde:	300c      	adds	r0, #12
 1026ce0:	f7f7 fada 	bl	101e298 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
 1026ce4:	f8b9 3000 	ldrh.w	r3, [r9]
	cp->all_phys = all_phys;
 1026ce8:	f880 8002 	strb.w	r8, [r0, #2]
	cp->handle = sys_cpu_to_le16(conn->handle);
 1026cec:	8003      	strh	r3, [r0, #0]
	cp->tx_phys = pref_tx_phy;
 1026cee:	70c7      	strb	r7, [r0, #3]
	cp->rx_phys = pref_rx_phy;
 1026cf0:	7106      	strb	r6, [r0, #4]
	cp->phy_opts = phy_opts;
 1026cf2:	f8a0 a005 	strh.w	sl, [r0, #5]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PHY, buf, NULL);
 1026cf6:	4629      	mov	r1, r5
}
 1026cf8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PHY, buf, NULL);
 1026cfc:	2200      	movs	r2, #0
 1026cfe:	f242 0032 	movw	r0, #8242	; 0x2032
 1026d02:	f7e1 b919 	b.w	1007f38 <bt_hci_cmd_send_sync>
}
 1026d06:	f06f 0068 	mvn.w	r0, #104	; 0x68
 1026d0a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

01026d0e <le_enh_conn_complete>:
	bt_hci_le_enh_conn_complete(evt);
 1026d0e:	68c0      	ldr	r0, [r0, #12]
 1026d10:	f7e1 b9e2 	b.w	10080d8 <bt_hci_le_enh_conn_complete>

01026d14 <bt_le_conn_params_valid>:
{
 1026d14:	b510      	push	{r4, lr}
	if (param->interval_min > param->interval_max ||
 1026d16:	8803      	ldrh	r3, [r0, #0]
 1026d18:	8842      	ldrh	r2, [r0, #2]
 1026d1a:	4293      	cmp	r3, r2
 1026d1c:	d819      	bhi.n	1026d52 <bt_le_conn_params_valid+0x3e>
 1026d1e:	2b05      	cmp	r3, #5
 1026d20:	d917      	bls.n	1026d52 <bt_le_conn_params_valid+0x3e>
	    param->interval_min < 6 || param->interval_max > 3200) {
 1026d22:	f5b2 6f48 	cmp.w	r2, #3200	; 0xc80
 1026d26:	d814      	bhi.n	1026d52 <bt_le_conn_params_valid+0x3e>
	if (param->latency > 499) {
 1026d28:	8883      	ldrh	r3, [r0, #4]
 1026d2a:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 1026d2e:	d210      	bcs.n	1026d52 <bt_le_conn_params_valid+0x3e>
	if (param->timeout < 10 || param->timeout > 3200 ||
 1026d30:	f640 4476 	movw	r4, #3190	; 0xc76
 1026d34:	88c0      	ldrh	r0, [r0, #6]
 1026d36:	f1a0 010a 	sub.w	r1, r0, #10
 1026d3a:	b289      	uxth	r1, r1
 1026d3c:	42a1      	cmp	r1, r4
 1026d3e:	d808      	bhi.n	1026d52 <bt_le_conn_params_valid+0x3e>
	     ((1U + param->latency) * param->interval_max))) {
 1026d40:	3301      	adds	r3, #1
 1026d42:	b29b      	uxth	r3, r3
 1026d44:	4353      	muls	r3, r2
	if (param->timeout < 10 || param->timeout > 3200 ||
 1026d46:	ebb3 0f80 	cmp.w	r3, r0, lsl #2
 1026d4a:	bf34      	ite	cc
 1026d4c:	2001      	movcc	r0, #1
 1026d4e:	2000      	movcs	r0, #0
}
 1026d50:	bd10      	pop	{r4, pc}
		return false;
 1026d52:	2000      	movs	r0, #0
 1026d54:	e7fc      	b.n	1026d50 <bt_le_conn_params_valid+0x3c>

01026d56 <bt_send>:
		return bt_hci_ecc_send(buf);
 1026d56:	f7e0 b915 	b.w	1006f84 <bt_hci_ecc_send>

01026d5a <bt_get_appearance>:
#if defined(CONFIG_BT_DEVICE_APPEARANCE_DYNAMIC)
	return bt_dev.appearance;
#else
	return CONFIG_BT_DEVICE_APPEARANCE;
#endif
}
 1026d5a:	2000      	movs	r0, #0
 1026d5c:	4770      	bx	lr

01026d5e <bt_addr_le_is_bonded>:
	return 0;
}
#endif

bool bt_addr_le_is_bonded(uint8_t id, const bt_addr_le_t *addr)
{
 1026d5e:	b508      	push	{r3, lr}
	if (IS_ENABLED(CONFIG_BT_SMP)) {
		struct bt_keys *keys = bt_keys_find_addr(id, addr);
 1026d60:	f7e9 fd9e 	bl	10108a0 <bt_keys_find_addr>

		/* if there are any keys stored then device is bonded */
		return keys && keys->keys;
 1026d64:	b118      	cbz	r0, 1026d6e <bt_addr_le_is_bonded+0x10>
 1026d66:	89c0      	ldrh	r0, [r0, #14]
 1026d68:	3800      	subs	r0, #0
 1026d6a:	bf18      	it	ne
 1026d6c:	2001      	movne	r0, #1
	} else {
		return false;
	}
}
 1026d6e:	bd08      	pop	{r3, pc}

01026d70 <bt_hci_evt_create>:
#include <stdint.h>
#include <zephyr/sys/byteorder.h>
#include <zephyr/drivers/bluetooth/hci_driver.h>

struct net_buf *bt_hci_evt_create(uint8_t evt, uint8_t len)
{
 1026d70:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_hdr *hdr;
	struct net_buf *buf;

	buf = bt_buf_get_evt(evt, false, K_FOREVER);
 1026d72:	f04f 32ff 	mov.w	r2, #4294967295
{
 1026d76:	460d      	mov	r5, r1
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
 1026d78:	f04f 33ff 	mov.w	r3, #4294967295
 1026d7c:	2100      	movs	r1, #0
{
 1026d7e:	4606      	mov	r6, r0
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
 1026d80:	f7e0 fb40 	bl	1007404 <bt_buf_get_evt>
 1026d84:	2102      	movs	r1, #2
 1026d86:	4604      	mov	r4, r0
 1026d88:	300c      	adds	r0, #12
 1026d8a:	f7f7 fa85 	bl	101e298 <net_buf_simple_add>

	hdr = net_buf_add(buf, sizeof(*hdr));
	hdr->evt = evt;
 1026d8e:	7006      	strb	r6, [r0, #0]
	hdr->len = len;
 1026d90:	7045      	strb	r5, [r0, #1]

	return buf;
}
 1026d92:	4620      	mov	r0, r4
 1026d94:	bd70      	pop	{r4, r5, r6, pc}

01026d96 <bt_hci_cmd_complete_create>:
struct net_buf *bt_hci_cmd_complete_create(uint16_t op, uint8_t plen)
{
	struct net_buf *buf;
	struct bt_hci_evt_cmd_complete *cc;

	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
 1026d96:	3103      	adds	r1, #3
{
 1026d98:	b538      	push	{r3, r4, r5, lr}
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
 1026d9a:	b2c9      	uxtb	r1, r1
{
 1026d9c:	4605      	mov	r5, r0
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
 1026d9e:	200e      	movs	r0, #14
 1026da0:	f7ff ffe6 	bl	1026d70 <bt_hci_evt_create>
 1026da4:	2103      	movs	r1, #3
 1026da6:	4604      	mov	r4, r0
 1026da8:	300c      	adds	r0, #12
 1026daa:	f7f7 fa75 	bl	101e298 <net_buf_simple_add>

	cc = net_buf_add(buf, sizeof(*cc));
	cc->ncmd = 1U;
 1026dae:	2301      	movs	r3, #1
	cc->opcode = sys_cpu_to_le16(op);
 1026db0:	f8a0 5001 	strh.w	r5, [r0, #1]
	cc->ncmd = 1U;
 1026db4:	7003      	strb	r3, [r0, #0]

	return buf;
}
 1026db6:	4620      	mov	r0, r4
 1026db8:	bd38      	pop	{r3, r4, r5, pc}

01026dba <bt_hci_cmd_status_create>:

struct net_buf *bt_hci_cmd_status_create(uint16_t op, uint8_t status)
{
 1026dba:	b570      	push	{r4, r5, r6, lr}
 1026dbc:	4605      	mov	r5, r0
 1026dbe:	460e      	mov	r6, r1
	struct net_buf *buf;
	struct bt_hci_evt_cmd_status *cs;

	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
 1026dc0:	200f      	movs	r0, #15
 1026dc2:	2104      	movs	r1, #4
 1026dc4:	f7ff ffd4 	bl	1026d70 <bt_hci_evt_create>
 1026dc8:	2104      	movs	r1, #4
 1026dca:	4604      	mov	r4, r0
 1026dcc:	300c      	adds	r0, #12
 1026dce:	f7f7 fa63 	bl	101e298 <net_buf_simple_add>

	cs = net_buf_add(buf, sizeof(*cs));
	cs->status = status;
	cs->ncmd = 1U;
 1026dd2:	2201      	movs	r2, #1
	cs->status = status;
 1026dd4:	7006      	strb	r6, [r0, #0]
	cs->ncmd = 1U;
 1026dd6:	7042      	strb	r2, [r0, #1]
	cs->opcode = sys_cpu_to_le16(op);
 1026dd8:	8045      	strh	r5, [r0, #2]

	return buf;
}
 1026dda:	4620      	mov	r0, r4
 1026ddc:	bd70      	pop	{r4, r5, r6, pc}

01026dde <bt_addr_le_eq>:
	return memcmp(a, b, sizeof(*a));
 1026dde:	2207      	movs	r2, #7
{
 1026de0:	b508      	push	{r3, lr}
	return memcmp(a, b, sizeof(*a));
 1026de2:	f7ff fdb7 	bl	1026954 <memcmp>
}
 1026de6:	fab0 f080 	clz	r0, r0
 1026dea:	0940      	lsrs	r0, r0, #5
 1026dec:	bd08      	pop	{r3, pc}

01026dee <bt_addr_le_copy>:
	memcpy(dst, src, sizeof(*dst));
 1026dee:	2207      	movs	r2, #7
 1026df0:	f7ff bdc0 	b.w	1026974 <memcpy>

01026df4 <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1026df4:	e8d0 0faf 	lda	r0, [r0]
}
 1026df8:	4770      	bx	lr

01026dfa <hci_id_add>:
{
 1026dfa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1026dfe:	4688      	mov	r8, r1
 1026e00:	4617      	mov	r7, r2
	if (id >= CONFIG_BT_ID_MAX) {
 1026e02:	4605      	mov	r5, r0
 1026e04:	bb08      	cbnz	r0, 1026e4a <hci_id_add+0x50>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_ADD_DEV_TO_RL, sizeof(*cp));
 1026e06:	2127      	movs	r1, #39	; 0x27
 1026e08:	f242 0027 	movw	r0, #8231	; 0x2027
 1026e0c:	f7e0 ff3e 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 1026e10:	4604      	mov	r4, r0
 1026e12:	b1f0      	cbz	r0, 1026e52 <hci_id_add+0x58>
 1026e14:	2127      	movs	r1, #39	; 0x27
 1026e16:	300c      	adds	r0, #12
 1026e18:	f7f7 fa3e 	bl	101e298 <net_buf_simple_add>
 1026e1c:	4606      	mov	r6, r0
	bt_addr_le_copy(&cp->peer_id_addr, addr);
 1026e1e:	4641      	mov	r1, r8
 1026e20:	f7ff ffe5 	bl	1026dee <bt_addr_le_copy>
	memcpy(cp->peer_irk, peer_irk, 16);
 1026e24:	4639      	mov	r1, r7
 1026e26:	2210      	movs	r2, #16
 1026e28:	1df0      	adds	r0, r6, #7
 1026e2a:	f7ff fda3 	bl	1026974 <memcpy>
	(void)memset(cp->local_irk, 0, 16);
 1026e2e:	4629      	mov	r1, r5
 1026e30:	2210      	movs	r2, #16
 1026e32:	f106 0017 	add.w	r0, r6, #23
 1026e36:	f7ff fda8 	bl	102698a <memset>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_ADD_DEV_TO_RL, buf, NULL);
 1026e3a:	462a      	mov	r2, r5
 1026e3c:	4621      	mov	r1, r4
}
 1026e3e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_ADD_DEV_TO_RL, buf, NULL);
 1026e42:	f242 0027 	movw	r0, #8231	; 0x2027
 1026e46:	f7e1 b877 	b.w	1007f38 <bt_hci_cmd_send_sync>
		return -EINVAL;
 1026e4a:	f06f 0015 	mvn.w	r0, #21
}
 1026e4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOBUFS;
 1026e52:	f06f 0068 	mvn.w	r0, #104	; 0x68
 1026e56:	e7fa      	b.n	1026e4e <hci_id_add+0x54>

01026e58 <keys_add_id>:
	if (keys->state & BT_KEYS_ID_ADDED) {
 1026e58:	7a03      	ldrb	r3, [r0, #8]
{
 1026e5a:	4602      	mov	r2, r0
	if (keys->state & BT_KEYS_ID_ADDED) {
 1026e5c:	075b      	lsls	r3, r3, #29
 1026e5e:	d505      	bpl.n	1026e6c <keys_add_id+0x14>
		hci_id_add(keys->id, &keys->addr, keys->irk.val);
 1026e60:	4601      	mov	r1, r0
 1026e62:	322a      	adds	r2, #42	; 0x2a
 1026e64:	f811 0b01 	ldrb.w	r0, [r1], #1
 1026e68:	f7ff bfc7 	b.w	1026dfa <hci_id_add>
}
 1026e6c:	4770      	bx	lr

01026e6e <z_log_msg_static_create.constprop.0>:
 1026e6e:	2300      	movs	r3, #0
 1026e70:	f7dd bc4a 	b.w	1004708 <z_impl_z_log_msg_static_create>

01026e74 <addr_res_enable>:
{
 1026e74:	b538      	push	{r3, r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE, 1);
 1026e76:	2101      	movs	r1, #1
{
 1026e78:	4605      	mov	r5, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE, 1);
 1026e7a:	f242 002d 	movw	r0, #8237	; 0x202d
 1026e7e:	f7e0 ff05 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 1026e82:	4604      	mov	r4, r0
 1026e84:	b158      	cbz	r0, 1026e9e <addr_res_enable+0x2a>
	return net_buf_simple_add_u8(&buf->b, val);
 1026e86:	4629      	mov	r1, r5
 1026e88:	300c      	adds	r0, #12
 1026e8a:	f001 ff8d 	bl	1028da8 <net_buf_simple_add_u8>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE,
 1026e8e:	4621      	mov	r1, r4
}
 1026e90:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE,
 1026e94:	2200      	movs	r2, #0
 1026e96:	f242 002d 	movw	r0, #8237	; 0x202d
 1026e9a:	f7e1 b84d 	b.w	1007f38 <bt_hci_cmd_send_sync>
}
 1026e9e:	f06f 0068 	mvn.w	r0, #104	; 0x68
 1026ea2:	bd38      	pop	{r3, r4, r5, pc}

01026ea4 <adv_unpause_enabled>:
{
 1026ea4:	b410      	push	{r4}
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1026ea6:	f100 0310 	add.w	r3, r0, #16
 1026eaa:	e8d3 2fef 	ldaex	r2, [r3]
 1026eae:	f422 4100 	bic.w	r1, r2, #32768	; 0x8000
 1026eb2:	e8c3 1fe4 	stlex	r4, r1, [r3]
 1026eb6:	2c00      	cmp	r4, #0
 1026eb8:	d1f7      	bne.n	1026eaa <adv_unpause_enabled+0x6>
	if (atomic_test_and_clear_bit(adv->flags, BT_ADV_PAUSED)) {
 1026eba:	0413      	lsls	r3, r2, #16
 1026ebc:	d503      	bpl.n	1026ec6 <adv_unpause_enabled+0x22>
		bt_le_adv_set_enable(adv, true);
 1026ebe:	2101      	movs	r1, #1
}
 1026ec0:	bc10      	pop	{r4}
		bt_le_adv_set_enable(adv, true);
 1026ec2:	f000 b932 	b.w	102712a <bt_le_adv_set_enable>
}
 1026ec6:	bc10      	pop	{r4}
 1026ec8:	4770      	bx	lr

01026eca <adv_pause_enabled>:
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
 1026eca:	f100 0210 	add.w	r2, r0, #16
{
 1026ece:	b508      	push	{r3, lr}
 1026ed0:	4603      	mov	r3, r0
 1026ed2:	4610      	mov	r0, r2
 1026ed4:	f7ff ff8e 	bl	1026df4 <atomic_get>
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
 1026ed8:	0601      	lsls	r1, r0, #24
 1026eda:	d50d      	bpl.n	1026ef8 <adv_pause_enabled+0x2e>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1026edc:	e8d2 0fef 	ldaex	r0, [r2]
 1026ee0:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
 1026ee4:	e8c2 0fe1 	stlex	r1, r0, [r2]
 1026ee8:	2900      	cmp	r1, #0
 1026eea:	d1f7      	bne.n	1026edc <adv_pause_enabled+0x12>
		bt_le_adv_set_enable(adv, false);
 1026eec:	4618      	mov	r0, r3
}
 1026eee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		bt_le_adv_set_enable(adv, false);
 1026ef2:	2100      	movs	r1, #0
 1026ef4:	f000 b919 	b.w	102712a <bt_le_adv_set_enable>
}
 1026ef8:	bd08      	pop	{r3, pc}

01026efa <bt_lookup_id_addr>:
{
 1026efa:	b510      	push	{r4, lr}
 1026efc:	460c      	mov	r4, r1
	CHECKIF(id >= CONFIG_BT_ID_MAX || addr == NULL) {
 1026efe:	b930      	cbnz	r0, 1026f0e <bt_lookup_id_addr+0x14>
 1026f00:	b119      	cbz	r1, 1026f0a <bt_lookup_id_addr+0x10>
		keys = bt_keys_find_irk(id, addr);
 1026f02:	f7e9 fc6b 	bl	10107dc <bt_keys_find_irk>
		if (keys) {
 1026f06:	b100      	cbz	r0, 1026f0a <bt_lookup_id_addr+0x10>
			return &keys->addr;
 1026f08:	1c44      	adds	r4, r0, #1
}
 1026f0a:	4620      	mov	r0, r4
 1026f0c:	bd10      	pop	{r4, pc}
		return NULL;
 1026f0e:	2400      	movs	r4, #0
 1026f10:	e7fb      	b.n	1026f0a <bt_lookup_id_addr+0x10>

01026f12 <bt_id_set_adv_random_addr>:
	CHECKIF(adv == NULL || addr == NULL) {
 1026f12:	b118      	cbz	r0, 1026f1c <bt_id_set_adv_random_addr+0xa>
 1026f14:	b111      	cbz	r1, 1026f1c <bt_id_set_adv_random_addr+0xa>
		return set_random_address(addr);
 1026f16:	4608      	mov	r0, r1
 1026f18:	f7e1 bd92 	b.w	1008a40 <set_random_address>
}
 1026f1c:	f06f 0015 	mvn.w	r0, #21
 1026f20:	4770      	bx	lr

01026f22 <bt_id_set_adv_private_addr>:
{
 1026f22:	b513      	push	{r0, r1, r4, lr}
	CHECKIF(adv == NULL) {
 1026f24:	4604      	mov	r4, r0
 1026f26:	b180      	cbz	r0, 1026f4a <bt_id_set_adv_private_addr+0x28>
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
 1026f28:	2106      	movs	r1, #6
 1026f2a:	4668      	mov	r0, sp
 1026f2c:	f7ec fd00 	bl	1013930 <bt_rand>
	if (err) {
 1026f30:	b948      	cbnz	r0, 1026f46 <bt_id_set_adv_private_addr+0x24>
	BT_ADDR_SET_NRPA(&nrpa);
 1026f32:	f89d 3005 	ldrb.w	r3, [sp, #5]
	err = bt_id_set_adv_random_addr(adv, &nrpa);
 1026f36:	4669      	mov	r1, sp
	BT_ADDR_SET_NRPA(&nrpa);
 1026f38:	f003 033f 	and.w	r3, r3, #63	; 0x3f
	err = bt_id_set_adv_random_addr(adv, &nrpa);
 1026f3c:	4620      	mov	r0, r4
	BT_ADDR_SET_NRPA(&nrpa);
 1026f3e:	f88d 3005 	strb.w	r3, [sp, #5]
	err = bt_id_set_adv_random_addr(adv, &nrpa);
 1026f42:	f7ff ffe6 	bl	1026f12 <bt_id_set_adv_random_addr>
}
 1026f46:	b002      	add	sp, #8
 1026f48:	bd10      	pop	{r4, pc}
		return -EINVAL;
 1026f4a:	f06f 0015 	mvn.w	r0, #21
 1026f4e:	e7fa      	b.n	1026f46 <bt_id_set_adv_private_addr+0x24>

01026f50 <bt_id_adv_random_addr_check>:
}
 1026f50:	3800      	subs	r0, #0
 1026f52:	bf18      	it	ne
 1026f54:	2001      	movne	r0, #1
 1026f56:	4770      	bx	lr

01026f58 <pending_id_update>:
	if (keys->state & BT_KEYS_ID_PENDING_ADD) {
 1026f58:	7a03      	ldrb	r3, [r0, #8]
 1026f5a:	07d9      	lsls	r1, r3, #31
 1026f5c:	d504      	bpl.n	1026f68 <pending_id_update+0x10>
		keys->state &= ~BT_KEYS_ID_PENDING_ADD;
 1026f5e:	f023 0301 	bic.w	r3, r3, #1
 1026f62:	7203      	strb	r3, [r0, #8]
		bt_id_add(keys);
 1026f64:	f7e1 bedc 	b.w	1008d20 <bt_id_add>
	if (keys->state & BT_KEYS_ID_PENDING_DEL) {
 1026f68:	0799      	lsls	r1, r3, #30
 1026f6a:	d504      	bpl.n	1026f76 <pending_id_update+0x1e>
		keys->state &= ~BT_KEYS_ID_PENDING_DEL;
 1026f6c:	f023 0302 	bic.w	r3, r3, #2
 1026f70:	7203      	strb	r3, [r0, #8]
		bt_id_del(keys);
 1026f72:	f7e1 beef 	b.w	1008d54 <bt_id_del>
}
 1026f76:	4770      	bx	lr

01026f78 <bt_id_init>:
#if defined(CONFIG_BT_PRIVACY)
	k_work_init_delayable(&bt_dev.rpa_update, rpa_timeout);
#endif

	return 0;
}
 1026f78:	2000      	movs	r0, #0
 1026f7a:	4770      	bx	lr

01026f7c <get_adv_channel_map>:
{
 1026f7c:	4603      	mov	r3, r0
		channel_map &= ~0x01;
 1026f7e:	f410 4f00 	tst.w	r0, #32768	; 0x8000
 1026f82:	bf0c      	ite	eq
 1026f84:	2007      	moveq	r0, #7
 1026f86:	2006      	movne	r0, #6
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_38) {
 1026f88:	03da      	lsls	r2, r3, #15
		channel_map &= ~0x02;
 1026f8a:	bf48      	it	mi
 1026f8c:	f000 0005 	andmi.w	r0, r0, #5
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_39) {
 1026f90:	039b      	lsls	r3, r3, #14
		channel_map &= ~0x04;
 1026f92:	bf48      	it	mi
 1026f94:	f000 00fb 	andmi.w	r0, r0, #251	; 0xfb
}
 1026f98:	4770      	bx	lr

01026f9a <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1026f9a:	e8d0 0faf 	lda	r0, [r0]
}
 1026f9e:	4770      	bx	lr

01026fa0 <atomic_and>:
{
 1026fa0:	4603      	mov	r3, r0
 1026fa2:	b510      	push	{r4, lr}
}
 1026fa4:	e8d3 0fef 	ldaex	r0, [r3]
 1026fa8:	ea00 0201 	and.w	r2, r0, r1
 1026fac:	e8c3 2fe4 	stlex	r4, r2, [r3]
 1026fb0:	2c00      	cmp	r4, #0
 1026fb2:	d1f7      	bne.n	1026fa4 <atomic_and+0x4>
 1026fb4:	bd10      	pop	{r4, pc}

01026fb6 <atomic_set_bit_to>:
	atomic_val_t mask = ATOMIC_MASK(bit);
 1026fb6:	2301      	movs	r3, #1
{
 1026fb8:	b410      	push	{r4}
	atomic_val_t mask = ATOMIC_MASK(bit);
 1026fba:	fa03 f101 	lsl.w	r1, r3, r1
{
 1026fbe:	4604      	mov	r4, r0
	if (val) {
 1026fc0:	b142      	cbz	r2, 1026fd4 <atomic_set_bit_to+0x1e>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1026fc2:	e8d4 3fef 	ldaex	r3, [r4]
 1026fc6:	430b      	orrs	r3, r1
 1026fc8:	e8c4 3fe2 	stlex	r2, r3, [r4]
 1026fcc:	2a00      	cmp	r2, #0
 1026fce:	d1f8      	bne.n	1026fc2 <atomic_set_bit_to+0xc>
	}
}
 1026fd0:	bc10      	pop	{r4}
 1026fd2:	4770      	bx	lr
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 1026fd4:	43c9      	mvns	r1, r1
}
 1026fd6:	bc10      	pop	{r4}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 1026fd8:	f7ff bfe2 	b.w	1026fa0 <atomic_and>

01026fdc <le_adv_update.constprop.0>:
static int le_adv_update(struct bt_le_ext_adv *adv,
 1026fdc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1026fe0:	b087      	sub	sp, #28
 1026fe2:	f89d 6048 	ldrb.w	r6, [sp, #72]	; 0x48
 1026fe6:	4605      	mov	r5, r0
 1026fe8:	460c      	mov	r4, r1
 1026fea:	4690      	mov	r8, r2
	struct bt_ad d[2] = {};
 1026fec:	2100      	movs	r1, #0
 1026fee:	2210      	movs	r2, #16
 1026ff0:	a802      	add	r0, sp, #8
static int le_adv_update(struct bt_le_ext_adv *adv,
 1026ff2:	461f      	mov	r7, r3
 1026ff4:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
 1026ff8:	f89d a044 	ldrb.w	sl, [sp, #68]	; 0x44
	struct bt_ad d[2] = {};
 1026ffc:	f7ff fcc5 	bl	102698a <memset>
	if (name_type != ADV_NAME_TYPE_NONE) {
 1027000:	b9ce      	cbnz	r6, 1027036 <le_adv_update.constprop.0+0x5a>
		d[0].len = ad_len;
 1027002:	e9cd 4802 	strd	r4, r8, [sp, #8]
		d_len = 1;
 1027006:	2201      	movs	r2, #1
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
 1027008:	f242 0008 	movw	r0, #8200	; 0x2008
 102700c:	a902      	add	r1, sp, #8
 102700e:	f7e2 f8e9 	bl	10091e4 <hci_set_ad>
		if (err) {
 1027012:	4604      	mov	r4, r0
 1027014:	b958      	cbnz	r0, 102702e <le_adv_update.constprop.0+0x52>
	if (scannable) {
 1027016:	f1ba 0f00 	cmp.w	sl, #0
 102701a:	d13a      	bne.n	1027092 <le_adv_update.constprop.0+0xb6>
 102701c:	3510      	adds	r5, #16
 102701e:	e8d5 3fef 	ldaex	r3, [r5]
 1027022:	f043 0304 	orr.w	r3, r3, #4
 1027026:	e8c5 3fe2 	stlex	r2, r3, [r5]
 102702a:	2a00      	cmp	r2, #0
 102702c:	d1f7      	bne.n	102701e <le_adv_update.constprop.0+0x42>
}
 102702e:	4620      	mov	r0, r4
 1027030:	b007      	add	sp, #28
 1027032:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		const char *name = bt_get_name();
 1027036:	f7e1 fcaf 	bl	1008998 <bt_get_name>
 102703a:	4683      	mov	fp, r0
		if ((ad && ad_has_name(ad, ad_len)) ||
 102703c:	b9e4      	cbnz	r4, 1027078 <le_adv_update.constprop.0+0x9c>
 102703e:	bb37      	cbnz	r7, 102708e <le_adv_update.constprop.0+0xb2>
		data = (struct bt_data)BT_DATA(
 1027040:	4658      	mov	r0, fp
 1027042:	f7ff fc58 	bl	10268f6 <strlen>
 1027046:	2309      	movs	r3, #9
		if (name_type == ADV_NAME_TYPE_AD) {
 1027048:	2e01      	cmp	r6, #1
		d[0].data = ad;
 102704a:	e9cd b401 	strd	fp, r4, [sp, #4]
		data = (struct bt_data)BT_DATA(
 102704e:	f88d 3000 	strb.w	r3, [sp]
 1027052:	f88d 0001 	strb.w	r0, [sp, #1]
		d[0].len = ad_len;
 1027056:	f8cd 800c 	str.w	r8, [sp, #12]
		if (name_type == ADV_NAME_TYPE_AD) {
 102705a:	d1d4      	bne.n	1027006 <le_adv_update.constprop.0+0x2a>
			d_len = 2;
 102705c:	2202      	movs	r2, #2
			d[1].data = &data;
 102705e:	f8cd d010 	str.w	sp, [sp, #16]
			d[1].len = 1;
 1027062:	9605      	str	r6, [sp, #20]
			d_len = 2;
 1027064:	e7d0      	b.n	1027008 <le_adv_update.constprop.0+0x2c>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
 1027066:	f814 2033 	ldrb.w	r2, [r4, r3, lsl #3]
 102706a:	3a08      	subs	r2, #8
 102706c:	2a01      	cmp	r2, #1
 102706e:	d924      	bls.n	10270ba <le_adv_update.constprop.0+0xde>
	for (i = 0; i < ad_len; i++) {
 1027070:	3301      	adds	r3, #1
 1027072:	4598      	cmp	r8, r3
 1027074:	d1f7      	bne.n	1027066 <le_adv_update.constprop.0+0x8a>
 1027076:	e7e2      	b.n	102703e <le_adv_update.constprop.0+0x62>
 1027078:	2300      	movs	r3, #0
 102707a:	e7fa      	b.n	1027072 <le_adv_update.constprop.0+0x96>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
 102707c:	f817 2033 	ldrb.w	r2, [r7, r3, lsl #3]
 1027080:	3a08      	subs	r2, #8
 1027082:	2a01      	cmp	r2, #1
 1027084:	d919      	bls.n	10270ba <le_adv_update.constprop.0+0xde>
	for (i = 0; i < ad_len; i++) {
 1027086:	3301      	adds	r3, #1
 1027088:	4599      	cmp	r9, r3
 102708a:	d1f7      	bne.n	102707c <le_adv_update.constprop.0+0xa0>
 102708c:	e7d8      	b.n	1027040 <le_adv_update.constprop.0+0x64>
 102708e:	2300      	movs	r3, #0
 1027090:	e7fa      	b.n	1027088 <le_adv_update.constprop.0+0xac>
		d[0].data = sd;
 1027092:	2201      	movs	r2, #1
		if (name_type == ADV_NAME_TYPE_SD) {
 1027094:	2e02      	cmp	r6, #2
			d[1].len = 1;
 1027096:	bf08      	it	eq
 1027098:	9205      	streq	r2, [sp, #20]
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
 102709a:	f242 0009 	movw	r0, #8201	; 0x2009
			d_len = 2;
 102709e:	bf08      	it	eq
 10270a0:	4632      	moveq	r2, r6
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
 10270a2:	a902      	add	r1, sp, #8
			d[1].data = &data;
 10270a4:	bf08      	it	eq
 10270a6:	f8cd d010 	streq.w	sp, [sp, #16]
		d[0].len = sd_len;
 10270aa:	e9cd 7902 	strd	r7, r9, [sp, #8]
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
 10270ae:	f7e2 f899 	bl	10091e4 <hci_set_ad>
		if (err) {
 10270b2:	2800      	cmp	r0, #0
 10270b4:	d0b2      	beq.n	102701c <le_adv_update.constprop.0+0x40>
 10270b6:	4604      	mov	r4, r0
 10270b8:	e7b9      	b.n	102702e <le_adv_update.constprop.0+0x52>
			return -EINVAL;
 10270ba:	f06f 0415 	mvn.w	r4, #21
 10270be:	e7b6      	b.n	102702e <le_adv_update.constprop.0+0x52>

010270c0 <get_adv_name_type_param>:
	if (param->options & BT_LE_ADV_OPT_USE_NAME) {
 10270c0:	6843      	ldr	r3, [r0, #4]
 10270c2:	f013 0008 	ands.w	r0, r3, #8
 10270c6:	d00a      	beq.n	10270de <get_adv_name_type_param+0x1e>
		if (param->options & BT_LE_ADV_OPT_FORCE_NAME_IN_AD) {
 10270c8:	035a      	lsls	r2, r3, #13
 10270ca:	d407      	bmi.n	10270dc <get_adv_name_type_param+0x1c>
		if ((param->options & BT_LE_ADV_OPT_EXT_ADV) &&
 10270cc:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
			return ADV_NAME_TYPE_AD;
 10270d0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 10270d4:	bf14      	ite	ne
 10270d6:	2002      	movne	r0, #2
 10270d8:	2001      	moveq	r0, #1
 10270da:	4770      	bx	lr
 10270dc:	2001      	movs	r0, #1
}
 10270de:	4770      	bx	lr

010270e0 <bt_le_adv_set_enable_legacy>:
{
 10270e0:	b570      	push	{r4, r5, r6, lr}
 10270e2:	4606      	mov	r6, r0
 10270e4:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
 10270e6:	f242 000a 	movw	r0, #8202	; 0x200a
 10270ea:	2101      	movs	r1, #1
{
 10270ec:	b086      	sub	sp, #24
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
 10270ee:	f7e0 fdcd 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 10270f2:	4604      	mov	r4, r0
 10270f4:	b1b0      	cbz	r0, 1027124 <bt_le_adv_set_enable_legacy+0x44>
 10270f6:	300c      	adds	r0, #12
	if (enable) {
 10270f8:	b195      	cbz	r5, 1027120 <bt_le_adv_set_enable_legacy+0x40>
 10270fa:	2101      	movs	r1, #1
 10270fc:	f001 fe54 	bl	1028da8 <net_buf_simple_add_u8>
	bt_hci_cmd_state_set_init(buf, &state, adv->flags, BT_ADV_ENABLED, enable);
 1027100:	4620      	mov	r0, r4
 1027102:	f106 0210 	add.w	r2, r6, #16
 1027106:	a903      	add	r1, sp, #12
 1027108:	2307      	movs	r3, #7
 102710a:	9500      	str	r5, [sp, #0]
 102710c:	f7e0 fdac 	bl	1007c68 <bt_hci_cmd_state_set_init>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
 1027110:	2200      	movs	r2, #0
 1027112:	4621      	mov	r1, r4
 1027114:	f242 000a 	movw	r0, #8202	; 0x200a
 1027118:	f7e0 ff0e 	bl	1007f38 <bt_hci_cmd_send_sync>
}
 102711c:	b006      	add	sp, #24
 102711e:	bd70      	pop	{r4, r5, r6, pc}
 1027120:	4629      	mov	r1, r5
 1027122:	e7eb      	b.n	10270fc <bt_le_adv_set_enable_legacy+0x1c>
		return -ENOBUFS;
 1027124:	f06f 0068 	mvn.w	r0, #104	; 0x68
 1027128:	e7f8      	b.n	102711c <bt_le_adv_set_enable_legacy+0x3c>

0102712a <bt_le_adv_set_enable>:
	return bt_le_adv_set_enable_legacy(adv, enable);
 102712a:	f7ff bfd9 	b.w	10270e0 <bt_le_adv_set_enable_legacy>

0102712e <bt_le_lim_adv_cancel_timeout>:
	return k_work_cancel_delayable(&adv->lim_adv_timeout_work);
 102712e:	3018      	adds	r0, #24
 1027130:	f7fb b80e 	b.w	1022150 <k_work_cancel_delayable>

01027134 <sys_slist_find_and_remove>:
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 1027134:	2200      	movs	r2, #0
	return list->head;
 1027136:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 1027138:	b90b      	cbnz	r3, 102713e <sys_slist_find_and_remove+0xa>
 102713a:	4618      	mov	r0, r3
 102713c:	4770      	bx	lr
 102713e:	428b      	cmp	r3, r1
 1027140:	d110      	bne.n	1027164 <sys_slist_find_and_remove+0x30>
	return node->next;
 1027142:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
 1027144:	b942      	cbnz	r2, 1027158 <sys_slist_find_and_remove+0x24>
 1027146:	6842      	ldr	r2, [r0, #4]
	list->head = node;
 1027148:	6003      	str	r3, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
 102714a:	4291      	cmp	r1, r2
 102714c:	d100      	bne.n	1027150 <sys_slist_find_and_remove+0x1c>
	list->tail = node;
 102714e:	6043      	str	r3, [r0, #4]
	parent->next = child;
 1027150:	2300      	movs	r3, #0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 1027152:	2001      	movs	r0, #1
	parent->next = child;
 1027154:	600b      	str	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
 1027156:	4770      	bx	lr
	parent->next = child;
 1027158:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
 102715a:	6843      	ldr	r3, [r0, #4]
 102715c:	4299      	cmp	r1, r3
	list->tail = node;
 102715e:	bf08      	it	eq
 1027160:	6042      	streq	r2, [r0, #4]
}
 1027162:	e7f5      	b.n	1027150 <sys_slist_find_and_remove+0x1c>
	return node->next;
 1027164:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 1027166:	681b      	ldr	r3, [r3, #0]
 1027168:	e7e6      	b.n	1027138 <sys_slist_find_and_remove+0x4>

0102716a <atomic_and>:
{
 102716a:	4603      	mov	r3, r0
 102716c:	b510      	push	{r4, lr}
}
 102716e:	e8d3 0fef 	ldaex	r0, [r3]
 1027172:	ea00 0201 	and.w	r2, r0, r1
 1027176:	e8c3 2fe4 	stlex	r4, r2, [r3]
 102717a:	2c00      	cmp	r4, #0
 102717c:	d1f7      	bne.n	102716e <atomic_and+0x4>
 102717e:	bd10      	pop	{r4, pc}

01027180 <z_log_msg_static_create.constprop.0>:
 1027180:	2300      	movs	r3, #0
 1027182:	f7dd bac1 	b.w	1004708 <z_impl_z_log_msg_static_create>

01027186 <tx_complete_work>:
	tx_notify(conn);
 1027186:	3828      	subs	r0, #40	; 0x28
 1027188:	f7e2 bc98 	b.w	1009abc <tx_notify>

0102718c <bt_conn_reset_rx_state>:
{
 102718c:	b510      	push	{r4, lr}
 102718e:	4604      	mov	r4, r0
	if (!conn->rx) {
 1027190:	6900      	ldr	r0, [r0, #16]
 1027192:	b118      	cbz	r0, 102719c <bt_conn_reset_rx_state+0x10>
	net_buf_unref(conn->rx);
 1027194:	f7f6 ff24 	bl	101dfe0 <net_buf_unref>
	conn->rx = NULL;
 1027198:	2300      	movs	r3, #0
 102719a:	6123      	str	r3, [r4, #16]
}
 102719c:	bd10      	pop	{r4, pc}

0102719e <conn_lookup_handle>:
{
 102719e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 10271a2:	4607      	mov	r7, r0
 10271a4:	460e      	mov	r6, r1
 10271a6:	4690      	mov	r8, r2
	for (i = 0; i < size; i++) {
 10271a8:	2400      	movs	r4, #0
		struct bt_conn *conn = bt_conn_ref(&conns[i]);
 10271aa:	f04f 09c8 	mov.w	r9, #200	; 0xc8
	for (i = 0; i < size; i++) {
 10271ae:	42b4      	cmp	r4, r6
 10271b0:	d103      	bne.n	10271ba <conn_lookup_handle+0x1c>
	return NULL;
 10271b2:	2300      	movs	r3, #0
}
 10271b4:	4618      	mov	r0, r3
 10271b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		struct bt_conn *conn = bt_conn_ref(&conns[i]);
 10271ba:	fb09 7004 	mla	r0, r9, r4, r7
 10271be:	f7e2 ff45 	bl	100a04c <bt_conn_ref>
 10271c2:	4603      	mov	r3, r0
		if (!conn) {
 10271c4:	b158      	cbz	r0, 10271de <conn_lookup_handle+0x40>
		if (!bt_conn_is_handle_valid(conn)) {
 10271c6:	7b45      	ldrb	r5, [r0, #13]
/* Look up an existing connection */
struct bt_conn *bt_conn_lookup_handle(uint16_t handle);

static inline bool bt_conn_is_handle_valid(struct bt_conn *conn)
{
	switch (conn->state) {
 10271c8:	2d01      	cmp	r5, #1
 10271ca:	d002      	beq.n	10271d2 <conn_lookup_handle+0x34>
 10271cc:	3d07      	subs	r5, #7
 10271ce:	2d01      	cmp	r5, #1
 10271d0:	d803      	bhi.n	10271da <conn_lookup_handle+0x3c>
		if (conn->handle != handle) {
 10271d2:	881a      	ldrh	r2, [r3, #0]
 10271d4:	4542      	cmp	r2, r8
 10271d6:	d0ed      	beq.n	10271b4 <conn_lookup_handle+0x16>
			bt_conn_unref(conn);
 10271d8:	4618      	mov	r0, r3
 10271da:	f7e2 ff5f 	bl	100a09c <bt_conn_unref>
	for (i = 0; i < size; i++) {
 10271de:	3401      	adds	r4, #1
 10271e0:	e7e5      	b.n	10271ae <conn_lookup_handle+0x10>

010271e2 <bt_conn_connected>:
{
 10271e2:	b510      	push	{r4, lr}
 10271e4:	4604      	mov	r4, r0
	bt_l2cap_connected(conn);
 10271e6:	f7e3 ffbf 	bl	100b168 <bt_l2cap_connected>
	notify_connected(conn);
 10271ea:	4620      	mov	r0, r4
}
 10271ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	notify_connected(conn);
 10271f0:	f7e2 bc2e 	b.w	1009a50 <notify_connected>

010271f4 <bt_conn_disconnect>:
{
 10271f4:	b510      	push	{r4, lr}
	switch (conn->state) {
 10271f6:	7b43      	ldrb	r3, [r0, #13]
{
 10271f8:	4604      	mov	r4, r0
	switch (conn->state) {
 10271fa:	3b02      	subs	r3, #2
 10271fc:	2b06      	cmp	r3, #6
 10271fe:	d816      	bhi.n	102722e <bt_conn_disconnect+0x3a>
 1027200:	e8df f003 	tbb	[pc, r3]
 1027204:	15151504 	.word	0x15151504
 1027208:	0b09      	.short	0x0b09
 102720a:	09          	.byte	0x09
 102720b:	00          	.byte	0x00
		conn->err = reason;
 102720c:	7301      	strb	r1, [r0, #12]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
 102720e:	2100      	movs	r1, #0
		bt_conn_set_state(conn, BT_CONN_DISCONNECTING);
 1027210:	4620      	mov	r0, r4
 1027212:	f7e2 ff7b 	bl	100a10c <bt_conn_set_state>
{
 1027216:	2000      	movs	r0, #0
}
 1027218:	bd10      	pop	{r4, pc}
	err = bt_hci_disconnect(conn->handle, reason);
 102721a:	8800      	ldrh	r0, [r0, #0]
 102721c:	f7ff fd16 	bl	1026c4c <bt_hci_disconnect>
	if (err) {
 1027220:	2800      	cmp	r0, #0
 1027222:	d1f9      	bne.n	1027218 <bt_conn_disconnect+0x24>
	if (conn->state == BT_CONN_CONNECTED) {
 1027224:	7b63      	ldrb	r3, [r4, #13]
 1027226:	2b07      	cmp	r3, #7
 1027228:	d1f5      	bne.n	1027216 <bt_conn_disconnect+0x22>
		bt_conn_set_state(conn, BT_CONN_DISCONNECTING);
 102722a:	2108      	movs	r1, #8
 102722c:	e7f0      	b.n	1027210 <bt_conn_disconnect+0x1c>
		return -ENOTCONN;
 102722e:	f06f 007f 	mvn.w	r0, #127	; 0x7f
 1027232:	e7f1      	b.n	1027218 <bt_conn_disconnect+0x24>

01027234 <bt_conn_set_security>:
{
 1027234:	b538      	push	{r3, r4, r5, lr}
	if (conn->state != BT_CONN_CONNECTED) {
 1027236:	7b43      	ldrb	r3, [r0, #13]
{
 1027238:	4604      	mov	r4, r0
	if (conn->state != BT_CONN_CONNECTED) {
 102723a:	2b07      	cmp	r3, #7
{
 102723c:	460d      	mov	r5, r1
	if (conn->state != BT_CONN_CONNECTED) {
 102723e:	d122      	bne.n	1027286 <bt_conn_set_security+0x52>
	if (conn->sec_level >= sec || conn->required_sec_level >= sec) {
 1027240:	7a43      	ldrb	r3, [r0, #9]
 1027242:	428b      	cmp	r3, r1
 1027244:	d215      	bcs.n	1027272 <bt_conn_set_security+0x3e>
 1027246:	7a83      	ldrb	r3, [r0, #10]
 1027248:	428b      	cmp	r3, r1
 102724a:	d212      	bcs.n	1027272 <bt_conn_set_security+0x3e>
	if (val) {
 102724c:	060b      	lsls	r3, r1, #24
	atomic_set_bit_to(conn->flags, BT_CONN_FORCE_PAIR,
 102724e:	f100 0004 	add.w	r0, r0, #4
 1027252:	d510      	bpl.n	1027276 <bt_conn_set_security+0x42>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1027254:	e8d0 3fef 	ldaex	r3, [r0]
 1027258:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 102725c:	e8c0 3fe2 	stlex	r2, r3, [r0]
 1027260:	2a00      	cmp	r2, #0
 1027262:	d1f7      	bne.n	1027254 <bt_conn_set_security+0x20>
	conn->required_sec_level = sec & ~BT_SECURITY_FORCE_PAIR;
 1027264:	f005 057f 	and.w	r5, r5, #127	; 0x7f
		return bt_smp_start_security(conn);
 1027268:	4620      	mov	r0, r4
	conn->required_sec_level = sec & ~BT_SECURITY_FORCE_PAIR;
 102726a:	72a5      	strb	r5, [r4, #10]
		return bt_smp_start_security(conn);
 102726c:	f7e8 fbbe 	bl	100f9ec <bt_smp_start_security>
	if (err) {
 1027270:	b930      	cbnz	r0, 1027280 <bt_conn_set_security+0x4c>
		return -ENOTCONN;
 1027272:	2000      	movs	r0, #0
}
 1027274:	bd38      	pop	{r3, r4, r5, pc}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 1027276:	f46f 6100 	mvn.w	r1, #2048	; 0x800
 102727a:	f7ff ff76 	bl	102716a <atomic_and>
 102727e:	e7f1      	b.n	1027264 <bt_conn_set_security+0x30>
		conn->required_sec_level = conn->sec_level;
 1027280:	7a63      	ldrb	r3, [r4, #9]
 1027282:	72a3      	strb	r3, [r4, #10]
 1027284:	e7f6      	b.n	1027274 <bt_conn_set_security+0x40>
		return -ENOTCONN;
 1027286:	f06f 007f 	mvn.w	r0, #127	; 0x7f
 102728a:	e7f3      	b.n	1027274 <bt_conn_set_security+0x40>

0102728c <bt_conn_get_security>:
}
 102728c:	7a40      	ldrb	r0, [r0, #9]
 102728e:	4770      	bx	lr

01027290 <bt_conn_is_peer_addr_le>:
{
 1027290:	b538      	push	{r3, r4, r5, lr}
	if (id != conn->id) {
 1027292:	7a03      	ldrb	r3, [r0, #8]
{
 1027294:	4604      	mov	r4, r0
	if (id != conn->id) {
 1027296:	428b      	cmp	r3, r1
{
 1027298:	4615      	mov	r5, r2
	if (id != conn->id) {
 102729a:	d115      	bne.n	10272c8 <bt_conn_is_peer_addr_le+0x38>
	return memcmp(a, b, sizeof(*a));
 102729c:	f100 0190 	add.w	r1, r0, #144	; 0x90
 10272a0:	2207      	movs	r2, #7
 10272a2:	4628      	mov	r0, r5
 10272a4:	f7ff fb56 	bl	1026954 <memcmp>
	if (bt_addr_le_eq(peer, &conn->le.dst)) {
 10272a8:	b180      	cbz	r0, 10272cc <bt_conn_is_peer_addr_le+0x3c>
	if (conn->role == BT_HCI_ROLE_CENTRAL) {
 10272aa:	78e3      	ldrb	r3, [r4, #3]
 10272ac:	2207      	movs	r2, #7
 10272ae:	b943      	cbnz	r3, 10272c2 <bt_conn_is_peer_addr_le+0x32>
 10272b0:	f104 019e 	add.w	r1, r4, #158	; 0x9e
 10272b4:	4628      	mov	r0, r5
 10272b6:	f7ff fb4d 	bl	1026954 <memcmp>
	return bt_addr_le_cmp(a, b) == 0;
 10272ba:	fab0 f080 	clz	r0, r0
 10272be:	0940      	lsrs	r0, r0, #5
}
 10272c0:	bd38      	pop	{r3, r4, r5, pc}
	return memcmp(a, b, sizeof(*a));
 10272c2:	f104 0197 	add.w	r1, r4, #151	; 0x97
 10272c6:	e7f5      	b.n	10272b4 <bt_conn_is_peer_addr_le+0x24>
		return false;
 10272c8:	2000      	movs	r0, #0
 10272ca:	e7f9      	b.n	10272c0 <bt_conn_is_peer_addr_le+0x30>
		return true;
 10272cc:	2001      	movs	r0, #1
 10272ce:	e7f7      	b.n	10272c0 <bt_conn_is_peer_addr_le+0x30>

010272d0 <bt_conn_get_dst>:
}
 10272d0:	3090      	adds	r0, #144	; 0x90
 10272d2:	4770      	bx	lr

010272d4 <bt_conn_le_conn_update>:
{
 10272d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10272d6:	4607      	mov	r7, r0
 10272d8:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE,
 10272da:	f242 0013 	movw	r0, #8211	; 0x2013
 10272de:	210e      	movs	r1, #14
 10272e0:	f7e0 fcd4 	bl	1007c8c <bt_hci_cmd_create>
	if (!buf) {
 10272e4:	4606      	mov	r6, r0
 10272e6:	b1d0      	cbz	r0, 102731e <bt_conn_le_conn_update+0x4a>
	return net_buf_simple_add(&buf->b, len);
 10272e8:	210e      	movs	r1, #14
 10272ea:	300c      	adds	r0, #12
 10272ec:	f7f6 ffd4 	bl	101e298 <net_buf_simple_add>
 10272f0:	4604      	mov	r4, r0
	(void)memset(conn_update, 0, sizeof(*conn_update));
 10272f2:	220e      	movs	r2, #14
 10272f4:	2100      	movs	r1, #0
 10272f6:	f7ff fb48 	bl	102698a <memset>
	conn_update->handle = sys_cpu_to_le16(conn->handle);
 10272fa:	883b      	ldrh	r3, [r7, #0]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
 10272fc:	4631      	mov	r1, r6
	conn_update->handle = sys_cpu_to_le16(conn->handle);
 10272fe:	8023      	strh	r3, [r4, #0]
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
 1027300:	882b      	ldrh	r3, [r5, #0]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
 1027302:	2200      	movs	r2, #0
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
 1027304:	8063      	strh	r3, [r4, #2]
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
 1027306:	886b      	ldrh	r3, [r5, #2]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
 1027308:	f242 0013 	movw	r0, #8211	; 0x2013
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
 102730c:	80a3      	strh	r3, [r4, #4]
	conn_update->conn_latency = sys_cpu_to_le16(param->latency);
 102730e:	88ab      	ldrh	r3, [r5, #4]
 1027310:	80e3      	strh	r3, [r4, #6]
	conn_update->supervision_timeout = sys_cpu_to_le16(param->timeout);
 1027312:	88eb      	ldrh	r3, [r5, #6]
 1027314:	8123      	strh	r3, [r4, #8]
}
 1027316:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
 102731a:	f7e0 be0d 	b.w	1007f38 <bt_hci_cmd_send_sync>
}
 102731e:	f06f 0068 	mvn.w	r0, #104	; 0x68
 1027322:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

01027324 <sys_slist_remove>:
	return node->next;
 1027324:	6813      	ldr	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
 1027326:	b939      	cbnz	r1, 1027338 <sys_slist_remove+0x14>
 1027328:	6841      	ldr	r1, [r0, #4]
	list->head = node;
 102732a:	6003      	str	r3, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
 102732c:	428a      	cmp	r2, r1
 102732e:	d100      	bne.n	1027332 <sys_slist_remove+0xe>
	list->tail = node;
 1027330:	6043      	str	r3, [r0, #4]
	parent->next = child;
 1027332:	2300      	movs	r3, #0
 1027334:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
 1027336:	4770      	bx	lr
	parent->next = child;
 1027338:	600b      	str	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
 102733a:	6843      	ldr	r3, [r0, #4]
 102733c:	429a      	cmp	r2, r3
	list->tail = node;
 102733e:	bf08      	it	eq
 1027340:	6041      	streq	r1, [r0, #4]
}
 1027342:	e7f6      	b.n	1027332 <sys_slist_remove+0xe>

01027344 <net_buf_frags_len>:
 * @param buf Buffer to start off with.
 *
 * @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
 1027344:	4603      	mov	r3, r0
	size_t bytes = 0;
 1027346:	2000      	movs	r0, #0

	while (buf) {
 1027348:	b903      	cbnz	r3, 102734c <net_buf_frags_len+0x8>
		bytes += buf->len;
		buf = buf->frags;
	}

	return bytes;
}
 102734a:	4770      	bx	lr
		bytes += buf->len;
 102734c:	8a1a      	ldrh	r2, [r3, #16]
		buf = buf->frags;
 102734e:	685b      	ldr	r3, [r3, #4]
		bytes += buf->len;
 1027350:	4410      	add	r0, r2
		buf = buf->frags;
 1027352:	e7f9      	b.n	1027348 <net_buf_frags_len+0x4>

01027354 <__l2cap_lookup_ident>:
{
 1027354:	b538      	push	{r3, r4, r5, lr}
 1027356:	4603      	mov	r3, r0
	return list->head;
 1027358:	6d40      	ldr	r0, [r0, #84]	; 0x54
 102735a:	460d      	mov	r5, r1
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 102735c:	b170      	cbz	r0, 102737c <__l2cap_lookup_ident+0x28>
 102735e:	2100      	movs	r1, #0
 1027360:	f1a0 0408 	sub.w	r4, r0, #8
		if (BT_L2CAP_LE_CHAN(chan)->ident == ident) {
 1027364:	f894 0098 	ldrb.w	r0, [r4, #152]	; 0x98
 1027368:	42a8      	cmp	r0, r5
 102736a:	d108      	bne.n	102737e <__l2cap_lookup_ident+0x2a>
			if (remove) {
 102736c:	b12a      	cbz	r2, 102737a <__l2cap_lookup_ident+0x26>
				sys_slist_remove(&conn->channels, prev,
 102736e:	f104 0208 	add.w	r2, r4, #8
 1027372:	f103 0054 	add.w	r0, r3, #84	; 0x54
 1027376:	f7ff ffd5 	bl	1027324 <sys_slist_remove>
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 102737a:	4620      	mov	r0, r4
}
 102737c:	bd38      	pop	{r3, r4, r5, pc}
	return node->next;
 102737e:	68a0      	ldr	r0, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 1027380:	2800      	cmp	r0, #0
 1027382:	d0fb      	beq.n	102737c <__l2cap_lookup_ident+0x28>
		prev = &chan->node;
 1027384:	f104 0108 	add.w	r1, r4, #8
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 1027388:	f1a0 0408 	sub.w	r4, r0, #8
 102738c:	e7ea      	b.n	1027364 <__l2cap_lookup_ident+0x10>

0102738e <l2cap_remove_rx_cid>:
	if (!L2CAP_LE_CID_IS_DYN(cid)) {
 102738e:	f1a1 0240 	sub.w	r2, r1, #64	; 0x40
 1027392:	2a3f      	cmp	r2, #63	; 0x3f
{
 1027394:	b538      	push	{r3, r4, r5, lr}
 1027396:	460b      	mov	r3, r1
	if (!L2CAP_LE_CID_IS_DYN(cid)) {
 1027398:	d813      	bhi.n	10273c2 <l2cap_remove_rx_cid+0x34>
	return list->head;
 102739a:	6d44      	ldr	r4, [r0, #84]	; 0x54
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 102739c:	b14c      	cbz	r4, 10273b2 <l2cap_remove_rx_cid+0x24>
 102739e:	2100      	movs	r1, #0
 10273a0:	3c08      	subs	r4, #8
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
 10273a2:	8aa5      	ldrh	r5, [r4, #20]
			sys_slist_remove(&conn->channels, prev, &chan->node);
 10273a4:	f104 0208 	add.w	r2, r4, #8
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
 10273a8:	429d      	cmp	r5, r3
 10273aa:	d104      	bne.n	10273b6 <l2cap_remove_rx_cid+0x28>
			sys_slist_remove(&conn->channels, prev, &chan->node);
 10273ac:	3054      	adds	r0, #84	; 0x54
 10273ae:	f7ff ffb9 	bl	1027324 <sys_slist_remove>
}
 10273b2:	4620      	mov	r0, r4
 10273b4:	bd38      	pop	{r3, r4, r5, pc}
	return node->next;
 10273b6:	68a4      	ldr	r4, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 10273b8:	2c00      	cmp	r4, #0
 10273ba:	d0fa      	beq.n	10273b2 <l2cap_remove_rx_cid+0x24>
			sys_slist_remove(&conn->channels, prev, &chan->node);
 10273bc:	4611      	mov	r1, r2
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 10273be:	3c08      	subs	r4, #8
 10273c0:	e7ef      	b.n	10273a2 <l2cap_remove_rx_cid+0x14>
		return NULL;
 10273c2:	2400      	movs	r4, #0
 10273c4:	e7f5      	b.n	10273b2 <l2cap_remove_rx_cid+0x24>

010273c6 <l2cap_alloc_frag>:
	frag = chan->chan.ops->alloc_buf(&chan->chan);
 10273c6:	6853      	ldr	r3, [r2, #4]
{
 10273c8:	4610      	mov	r0, r2
	frag = chan->chan.ops->alloc_buf(&chan->chan);
 10273ca:	691b      	ldr	r3, [r3, #16]
 10273cc:	4718      	bx	r3

010273ce <l2cap_connected>:
}
 10273ce:	4770      	bx	lr

010273d0 <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 10273d0:	e8d0 0faf 	lda	r0, [r0]
}
 10273d4:	4770      	bx	lr

010273d6 <l2cap_chan_tx_resume>:
{
 10273d6:	b508      	push	{r3, lr}
 10273d8:	4603      	mov	r3, r0
	if (!atomic_get(&ch->tx.credits) ||
 10273da:	302c      	adds	r0, #44	; 0x2c
 10273dc:	f7ff fff8 	bl	10273d0 <atomic_get>
 10273e0:	b148      	cbz	r0, 10273f6 <l2cap_chan_tx_resume+0x20>
 10273e2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 10273e4:	b90a      	cbnz	r2, 10273ea <l2cap_chan_tx_resume+0x14>
	    (k_fifo_is_empty(&ch->tx_queue) && !ch->tx_buf)) {
 10273e6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 10273e8:	b12a      	cbz	r2, 10273f6 <l2cap_chan_tx_resume+0x20>
	k_work_submit(&ch->tx_work);
 10273ea:	f103 0050 	add.w	r0, r3, #80	; 0x50
}
 10273ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	k_work_submit(&ch->tx_work);
 10273f2:	f7fa bd03 	b.w	1021dfc <k_work_submit>
}
 10273f6:	bd08      	pop	{r3, pc}

010273f8 <resume_all_channels>:
{
 10273f8:	b510      	push	{r4, lr}
	return list->head;
 10273fa:	6d44      	ldr	r4, [r0, #84]	; 0x54
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 10273fc:	b12c      	cbz	r4, 102740a <resume_all_channels+0x12>
 10273fe:	3c08      	subs	r4, #8
		l2cap_chan_tx_resume(BT_L2CAP_LE_CHAN(chan));
 1027400:	4620      	mov	r0, r4
 1027402:	f7ff ffe8 	bl	10273d6 <l2cap_chan_tx_resume>
	return node->next;
 1027406:	68a4      	ldr	r4, [r4, #8]
 1027408:	e7f8      	b.n	10273fc <resume_all_channels+0x4>
}
 102740a:	bd10      	pop	{r4, pc}

0102740c <l2cap_disconnected>:
	(void)k_work_cancel_delayable(&le_chan->rtx_work);
 102740c:	30a0      	adds	r0, #160	; 0xa0
 102740e:	f7fa be9f 	b.w	1022150 <k_work_cancel_delayable>

01027412 <l2cap_chan_destroy>:
{
 1027412:	b570      	push	{r4, r5, r6, lr}
 1027414:	4604      	mov	r4, r0
	return z_impl_z_current_get();
 1027416:	f7fc f81d 	bl	1023454 <z_impl_z_current_get>
 102741a:	4603      	mov	r3, r0
	if (k_current_get() != &le_chan->rtx_work.queue->thread) {
 102741c:	f8d4 20c8 	ldr.w	r2, [r4, #200]	; 0xc8
		k_work_cancel_delayable_sync(&le_chan->rtx_work, &le_chan->rtx_sync);
 1027420:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
	if (k_current_get() != &le_chan->rtx_work.queue->thread) {
 1027424:	429a      	cmp	r2, r3
 1027426:	d022      	beq.n	102746e <l2cap_chan_destroy+0x5c>
		k_work_cancel_delayable_sync(&le_chan->rtx_work, &le_chan->rtx_sync);
 1027428:	f104 01d0 	add.w	r1, r4, #208	; 0xd0
 102742c:	f7fa feea 	bl	1022204 <k_work_cancel_delayable_sync>
	if (le_chan->tx_buf) {
 1027430:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 1027432:	b118      	cbz	r0, 102743c <l2cap_chan_destroy+0x2a>
		net_buf_unref(le_chan->tx_buf);
 1027434:	f7f6 fdd4 	bl	101dfe0 <net_buf_unref>
		le_chan->tx_buf = NULL;
 1027438:	2300      	movs	r3, #0
 102743a:	64e3      	str	r3, [r4, #76]	; 0x4c
	while ((buf = net_buf_get(&le_chan->tx_queue, K_NO_WAIT))) {
 102743c:	f104 0530 	add.w	r5, r4, #48	; 0x30
 1027440:	2200      	movs	r2, #0
 1027442:	2300      	movs	r3, #0
 1027444:	4628      	mov	r0, r5
 1027446:	f001 fc84 	bl	1028d52 <net_buf_get>
 102744a:	b998      	cbnz	r0, 1027474 <l2cap_chan_destroy+0x62>
	while ((buf = net_buf_get(&le_chan->rx_queue, K_NO_WAIT))) {
 102744c:	f104 0678 	add.w	r6, r4, #120	; 0x78
 1027450:	2200      	movs	r2, #0
 1027452:	2300      	movs	r3, #0
 1027454:	4630      	mov	r0, r6
 1027456:	f001 fc7c 	bl	1028d52 <net_buf_get>
 102745a:	4605      	mov	r5, r0
 102745c:	b968      	cbnz	r0, 102747a <l2cap_chan_destroy+0x68>
	if (le_chan->_sdu) {
 102745e:	6e20      	ldr	r0, [r4, #96]	; 0x60
 1027460:	b120      	cbz	r0, 102746c <l2cap_chan_destroy+0x5a>
		net_buf_unref(le_chan->_sdu);
 1027462:	f7f6 fdbd 	bl	101dfe0 <net_buf_unref>
		le_chan->_sdu = NULL;
 1027466:	6625      	str	r5, [r4, #96]	; 0x60
		le_chan->_sdu_len = 0U;
 1027468:	f8a4 5064 	strh.w	r5, [r4, #100]	; 0x64
}
 102746c:	bd70      	pop	{r4, r5, r6, pc}
		k_work_cancel_delayable(&le_chan->rtx_work);
 102746e:	f7fa fe6f 	bl	1022150 <k_work_cancel_delayable>
 1027472:	e7dd      	b.n	1027430 <l2cap_chan_destroy+0x1e>
		net_buf_unref(buf);
 1027474:	f7f6 fdb4 	bl	101dfe0 <net_buf_unref>
 1027478:	e7e2      	b.n	1027440 <l2cap_chan_destroy+0x2e>
		net_buf_unref(buf);
 102747a:	f7f6 fdb1 	bl	101dfe0 <net_buf_unref>
 102747e:	e7e7      	b.n	1027450 <l2cap_chan_destroy+0x3e>

01027480 <z_log_msg_static_create.constprop.0>:
 1027480:	2300      	movs	r3, #0
 1027482:	f7dd b941 	b.w	1004708 <z_impl_z_log_msg_static_create>

01027486 <atomic_add.isra.0>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 1027486:	e8d0 3fef 	ldaex	r3, [r0]
 102748a:	440b      	add	r3, r1
 102748c:	e8c0 3fe2 	stlex	r2, r3, [r0]
 1027490:	2a00      	cmp	r2, #0
 1027492:	d1f8      	bne.n	1027486 <atomic_add.isra.0>
}
 1027494:	4770      	bx	lr

01027496 <l2cap_chan_tx_give_credits>:
{
 1027496:	b510      	push	{r4, lr}
 1027498:	4604      	mov	r4, r0
	atomic_add(&chan->tx.credits, credits);
 102749a:	302c      	adds	r0, #44	; 0x2c
 102749c:	f7ff fff3 	bl	1027486 <atomic_add.isra.0>
	if (!atomic_test_and_set_bit(chan->chan.status, BT_L2CAP_STATUS_OUT) &&
 10274a0:	f104 0110 	add.w	r1, r4, #16
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 10274a4:	e8d1 3fef 	ldaex	r3, [r1]
 10274a8:	f043 0201 	orr.w	r2, r3, #1
 10274ac:	e8c1 2fe0 	stlex	r0, r2, [r1]
 10274b0:	2800      	cmp	r0, #0
 10274b2:	d1f7      	bne.n	10274a4 <l2cap_chan_tx_give_credits+0xe>
 10274b4:	07db      	lsls	r3, r3, #31
 10274b6:	d406      	bmi.n	10274c6 <l2cap_chan_tx_give_credits+0x30>
	    chan->chan.ops->status) {
 10274b8:	6863      	ldr	r3, [r4, #4]
 10274ba:	69db      	ldr	r3, [r3, #28]
	if (!atomic_test_and_set_bit(chan->chan.status, BT_L2CAP_STATUS_OUT) &&
 10274bc:	b11b      	cbz	r3, 10274c6 <l2cap_chan_tx_give_credits+0x30>
		chan->chan.ops->status(&chan->chan, chan->chan.status);
 10274be:	4620      	mov	r0, r4
}
 10274c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		chan->chan.ops->status(&chan->chan, chan->chan.status);
 10274c4:	4718      	bx	r3
}
 10274c6:	bd10      	pop	{r4, pc}

010274c8 <bt_l2cap_chan_remove>:
{
 10274c8:	b410      	push	{r4}
	return list->head;
 10274ca:	6d43      	ldr	r3, [r0, #84]	; 0x54
 10274cc:	460c      	mov	r4, r1
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 10274ce:	b173      	cbz	r3, 10274ee <bt_l2cap_chan_remove+0x26>
 10274d0:	2100      	movs	r1, #0
 10274d2:	3b08      	subs	r3, #8
		if (chan == ch) {
 10274d4:	429c      	cmp	r4, r3
			sys_slist_remove(&conn->channels, prev, &chan->node);
 10274d6:	f103 0208 	add.w	r2, r3, #8
		if (chan == ch) {
 10274da:	d103      	bne.n	10274e4 <bt_l2cap_chan_remove+0x1c>
}
 10274dc:	bc10      	pop	{r4}
			sys_slist_remove(&conn->channels, prev, &chan->node);
 10274de:	3054      	adds	r0, #84	; 0x54
 10274e0:	f7ff bf20 	b.w	1027324 <sys_slist_remove>
	return node->next;
 10274e4:	689b      	ldr	r3, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 10274e6:	b113      	cbz	r3, 10274ee <bt_l2cap_chan_remove+0x26>
			sys_slist_remove(&conn->channels, prev, &chan->node);
 10274e8:	4611      	mov	r1, r2
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 10274ea:	3b08      	subs	r3, #8
 10274ec:	e7f2      	b.n	10274d4 <bt_l2cap_chan_remove+0xc>
}
 10274ee:	bc10      	pop	{r4}
 10274f0:	4770      	bx	lr

010274f2 <bt_l2cap_chan_del>:
{
 10274f2:	b570      	push	{r4, r5, r6, lr}
 10274f4:	4604      	mov	r4, r0
	if (!chan->conn) {
 10274f6:	e9d0 3500 	ldrd	r3, r5, [r0]
 10274fa:	b123      	cbz	r3, 1027506 <bt_l2cap_chan_del+0x14>
	if (ops->disconnected) {
 10274fc:	686b      	ldr	r3, [r5, #4]
 10274fe:	b103      	cbz	r3, 1027502 <bt_l2cap_chan_del+0x10>
		ops->disconnected(chan);
 1027500:	4798      	blx	r3
	chan->conn = NULL;
 1027502:	2300      	movs	r3, #0
 1027504:	6023      	str	r3, [r4, #0]
	BT_L2CAP_LE_CHAN(chan)->state = state;
 1027506:	2300      	movs	r3, #0
 1027508:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
	BT_L2CAP_LE_CHAN(chan)->psm = 0U;
 102750c:	f8a4 3096 	strh.w	r3, [r4, #150]	; 0x96
	if (chan->destroy) {
 1027510:	68e3      	ldr	r3, [r4, #12]
 1027512:	b10b      	cbz	r3, 1027518 <bt_l2cap_chan_del+0x26>
		chan->destroy(chan);
 1027514:	4620      	mov	r0, r4
 1027516:	4798      	blx	r3
	if (ops->released) {
 1027518:	6a2b      	ldr	r3, [r5, #32]
 102751a:	b11b      	cbz	r3, 1027524 <bt_l2cap_chan_del+0x32>
		ops->released(chan);
 102751c:	4620      	mov	r0, r4
}
 102751e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		ops->released(chan);
 1027522:	4718      	bx	r3
}
 1027524:	bd70      	pop	{r4, r5, r6, pc}

01027526 <bt_l2cap_disconnected>:
{
 1027526:	b538      	push	{r3, r4, r5, lr}
	return list->head;
 1027528:	6d40      	ldr	r0, [r0, #84]	; 0x54
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
 102752a:	b130      	cbz	r0, 102753a <bt_l2cap_disconnected+0x14>
	return node->next;
 102752c:	f850 4908 	ldr.w	r4, [r0], #-8
 1027530:	b104      	cbz	r4, 1027534 <bt_l2cap_disconnected+0xe>
 1027532:	3c08      	subs	r4, #8
		bt_l2cap_chan_del(chan);
 1027534:	f7ff ffdd 	bl	10274f2 <bt_l2cap_chan_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
 1027538:	b904      	cbnz	r4, 102753c <bt_l2cap_disconnected+0x16>
}
 102753a:	bd38      	pop	{r3, r4, r5, pc}
 102753c:	68a5      	ldr	r5, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
 102753e:	b12d      	cbz	r5, 102754c <bt_l2cap_disconnected+0x26>
		bt_l2cap_chan_del(chan);
 1027540:	4620      	mov	r0, r4
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
 1027542:	3d08      	subs	r5, #8
		bt_l2cap_chan_del(chan);
 1027544:	f7ff ffd5 	bl	10274f2 <bt_l2cap_chan_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
 1027548:	462c      	mov	r4, r5
 102754a:	e7f7      	b.n	102753c <bt_l2cap_disconnected+0x16>
		bt_l2cap_chan_del(chan);
 102754c:	4620      	mov	r0, r4
}
 102754e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		bt_l2cap_chan_del(chan);
 1027552:	f7ff bfce 	b.w	10274f2 <bt_l2cap_chan_del>

01027556 <bt_l2cap_create_pdu_timeout>:
	return bt_conn_create_pdu_timeout(pool,
 1027556:	3104      	adds	r1, #4
 1027558:	f7e2 bf14 	b.w	100a384 <bt_conn_create_pdu_timeout>

0102755c <bt_l2cap_send_cb>:
{
 102755c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1027560:	4614      	mov	r4, r2
 1027562:	4605      	mov	r5, r0
 1027564:	460f      	mov	r7, r1
	return net_buf_simple_push(&buf->b, len);
 1027566:	f102 000c 	add.w	r0, r2, #12
 102756a:	2104      	movs	r1, #4
 102756c:	461e      	mov	r6, r3
 102756e:	f8dd 8018 	ldr.w	r8, [sp, #24]
 1027572:	f7f6 fe35 	bl	101e1e0 <net_buf_simple_push>
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
 1027576:	8a22      	ldrh	r2, [r4, #16]
	hdr->cid = sys_cpu_to_le16(cid);
 1027578:	8047      	strh	r7, [r0, #2]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
 102757a:	3a04      	subs	r2, #4
 102757c:	8002      	strh	r2, [r0, #0]
	return bt_conn_send_cb(conn, buf, cb, user_data);
 102757e:	4643      	mov	r3, r8
 1027580:	4632      	mov	r2, r6
 1027582:	4621      	mov	r1, r4
 1027584:	4628      	mov	r0, r5
}
 1027586:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_conn_send_cb(conn, buf, cb, user_data);
 102758a:	f7e2 bcb7 	b.w	1009efc <bt_conn_send_cb>

0102758e <l2cap_chan_le_send_sdu>:
{
 102758e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	total_len = net_buf_frags_len(*buf) + sent;
 1027592:	680c      	ldr	r4, [r1, #0]
{
 1027594:	4607      	mov	r7, r0
	total_len = net_buf_frags_len(*buf) + sent;
 1027596:	4620      	mov	r0, r4
{
 1027598:	4616      	mov	r6, r2
	total_len = net_buf_frags_len(*buf) + sent;
 102759a:	f7ff fed3 	bl	1027344 <net_buf_frags_len>
	if (total_len > ch->tx.mtu) {
 102759e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
	total_len = net_buf_frags_len(*buf) + sent;
 10275a0:	eb06 0900 	add.w	r9, r6, r0
	if (total_len > ch->tx.mtu) {
 10275a4:	454b      	cmp	r3, r9
{
 10275a6:	4688      	mov	r8, r1
	if (total_len > ch->tx.mtu) {
 10275a8:	db2f      	blt.n	102760a <l2cap_chan_le_send_sdu+0x7c>
	if (!frag->len && frag->frags) {
 10275aa:	8a23      	ldrh	r3, [r4, #16]
 10275ac:	b91b      	cbnz	r3, 10275b6 <l2cap_chan_le_send_sdu+0x28>
 10275ae:	6863      	ldr	r3, [r4, #4]
 10275b0:	2b00      	cmp	r3, #0
 10275b2:	bf18      	it	ne
 10275b4:	461c      	movne	r4, r3
	if (!sent) {
 10275b6:	b98e      	cbnz	r6, 10275dc <l2cap_chan_le_send_sdu+0x4e>
		ret = l2cap_chan_le_send(ch, frag, BT_L2CAP_SDU_HDR_SIZE);
 10275b8:	2202      	movs	r2, #2
 10275ba:	4621      	mov	r1, r4
 10275bc:	4638      	mov	r0, r7
 10275be:	f7e3 fbb3 	bl	100ad28 <l2cap_chan_le_send>
		if (ret < 0) {
 10275c2:	1e05      	subs	r5, r0, #0
 10275c4:	da09      	bge.n	10275da <l2cap_chan_le_send_sdu+0x4c>
			if (ret == -EAGAIN) {
 10275c6:	f115 0f0b 	cmn.w	r5, #11
				l2cap_tx_meta_data(frag)->sent = sent;
 10275ca:	bf04      	itt	eq
 10275cc:	69a3      	ldreq	r3, [r4, #24]
 10275ce:	601e      	streq	r6, [r3, #0]
			*buf = frag;
 10275d0:	f8c8 4000 	str.w	r4, [r8]
}
 10275d4:	4628      	mov	r0, r5
 10275d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		sent = ret;
 10275da:	b2ae      	uxth	r6, r5
	if (!frag->len && frag->frags) {
 10275dc:	2500      	movs	r5, #0
	for (ret = 0; sent < total_len; sent += ret) {
 10275de:	454e      	cmp	r6, r9
 10275e0:	db03      	blt.n	10275ea <l2cap_chan_le_send_sdu+0x5c>
	net_buf_unref(frag);
 10275e2:	4620      	mov	r0, r4
 10275e4:	f7f6 fcfc 	bl	101dfe0 <net_buf_unref>
	return ret;
 10275e8:	e7f4      	b.n	10275d4 <l2cap_chan_le_send_sdu+0x46>
		if (!frag->len) {
 10275ea:	8a20      	ldrh	r0, [r4, #16]
 10275ec:	b918      	cbnz	r0, 10275f6 <l2cap_chan_le_send_sdu+0x68>
			frag = net_buf_frag_del(NULL, frag);
 10275ee:	4621      	mov	r1, r4
 10275f0:	f7f6 fdba 	bl	101e168 <net_buf_frag_del>
 10275f4:	4604      	mov	r4, r0
		ret = l2cap_chan_le_send(ch, frag, 0);
 10275f6:	2200      	movs	r2, #0
 10275f8:	4621      	mov	r1, r4
 10275fa:	4638      	mov	r0, r7
 10275fc:	f7e3 fb94 	bl	100ad28 <l2cap_chan_le_send>
		if (ret < 0) {
 1027600:	1e05      	subs	r5, r0, #0
 1027602:	dbe0      	blt.n	10275c6 <l2cap_chan_le_send_sdu+0x38>
	for (ret = 0; sent < total_len; sent += ret) {
 1027604:	442e      	add	r6, r5
 1027606:	b2b6      	uxth	r6, r6
 1027608:	e7e9      	b.n	10275de <l2cap_chan_le_send_sdu+0x50>
		return -EMSGSIZE;
 102760a:	f06f 0579 	mvn.w	r5, #121	; 0x79
 102760e:	e7e1      	b.n	10275d4 <l2cap_chan_le_send_sdu+0x46>

01027610 <l2cap_chan_tx_process>:
{
 1027610:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1027612:	4604      	mov	r4, r0
		ch->tx_buf = NULL;
 1027614:	2700      	movs	r7, #0
	ch = CONTAINER_OF(work, struct bt_l2cap_le_chan, tx_work);
 1027616:	f1a0 0650 	sub.w	r6, r0, #80	; 0x50
	return net_buf_get(&ch->tx_queue, K_NO_WAIT);
 102761a:	f1a0 0520 	sub.w	r5, r0, #32
	if (ch->tx_buf) {
 102761e:	f854 0c04 	ldr.w	r0, [r4, #-4]
 1027622:	b1b0      	cbz	r0, 1027652 <l2cap_chan_tx_process+0x42>
		ch->tx_buf = NULL;
 1027624:	f844 7c04 	str.w	r7, [r4, #-4]
	while ((buf = l2cap_chan_le_get_tx_buf(ch))) {
 1027628:	9001      	str	r0, [sp, #4]
		int sent = l2cap_tx_meta_data(buf)->sent;
 102762a:	6983      	ldr	r3, [r0, #24]
		sent = l2cap_chan_le_send_sdu(ch, &buf, sent);
 102762c:	a901      	add	r1, sp, #4
 102762e:	881a      	ldrh	r2, [r3, #0]
 1027630:	4630      	mov	r0, r6
 1027632:	f7ff ffac 	bl	102758e <l2cap_chan_le_send_sdu>
		if (sent < 0) {
 1027636:	1e03      	subs	r3, r0, #0
 1027638:	daf1      	bge.n	102761e <l2cap_chan_tx_process+0xe>
			if (sent == -EAGAIN) {
 102763a:	330b      	adds	r3, #11
				ch->tx_buf = buf;
 102763c:	9801      	ldr	r0, [sp, #4]
			if (sent == -EAGAIN) {
 102763e:	d103      	bne.n	1027648 <l2cap_chan_tx_process+0x38>
				ch->tx_buf = buf;
 1027640:	f844 0c04 	str.w	r0, [r4, #-4]
}
 1027644:	b003      	add	sp, #12
 1027646:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1027648:	b003      	add	sp, #12
 102764a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
				net_buf_unref(buf);
 102764e:	f7f6 bcc7 	b.w	101dfe0 <net_buf_unref>
	return net_buf_get(&ch->tx_queue, K_NO_WAIT);
 1027652:	2200      	movs	r2, #0
 1027654:	2300      	movs	r3, #0
 1027656:	4628      	mov	r0, r5
 1027658:	f001 fb7b 	bl	1028d52 <net_buf_get>
	while ((buf = l2cap_chan_le_get_tx_buf(ch))) {
 102765c:	9001      	str	r0, [sp, #4]
 102765e:	2800      	cmp	r0, #0
 1027660:	d1e3      	bne.n	102762a <l2cap_chan_tx_process+0x1a>
 1027662:	e7ef      	b.n	1027644 <l2cap_chan_tx_process+0x34>

01027664 <l2cap_send.constprop.0>:
 1027664:	2300      	movs	r3, #0
static inline void l2cap_send(struct bt_conn *conn, uint16_t cid,
 1027666:	b513      	push	{r0, r1, r4, lr}
 1027668:	460a      	mov	r2, r1
 102766a:	460c      	mov	r4, r1
 102766c:	9300      	str	r3, [sp, #0]
 102766e:	2105      	movs	r1, #5
 1027670:	f7ff ff74 	bl	102755c <bt_l2cap_send_cb>
	if (bt_l2cap_send(conn, cid, buf)) {
 1027674:	b128      	cbz	r0, 1027682 <l2cap_send.constprop.0+0x1e>
		net_buf_unref(buf);
 1027676:	4620      	mov	r0, r4
}
 1027678:	b002      	add	sp, #8
 102767a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		net_buf_unref(buf);
 102767e:	f7f6 bcaf 	b.w	101dfe0 <net_buf_unref>
}
 1027682:	b002      	add	sp, #8
 1027684:	bd10      	pop	{r4, pc}

01027686 <l2cap_chan_send_req>:
{
 1027686:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1027688:	461e      	mov	r6, r3
 102768a:	2300      	movs	r3, #0
 102768c:	9300      	str	r3, [sp, #0]
 102768e:	4604      	mov	r4, r0
 1027690:	460d      	mov	r5, r1
 1027692:	4617      	mov	r7, r2
 1027694:	6800      	ldr	r0, [r0, #0]
 1027696:	460a      	mov	r2, r1
 1027698:	2105      	movs	r1, #5
 102769a:	f7ff ff5f 	bl	102755c <bt_l2cap_send_cb>
	if (bt_l2cap_send(chan->conn, BT_L2CAP_CID_LE_SIG, buf)) {
 102769e:	b128      	cbz	r0, 10276ac <l2cap_chan_send_req+0x26>
		net_buf_unref(buf);
 10276a0:	4628      	mov	r0, r5
}
 10276a2:	b003      	add	sp, #12
 10276a4:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		net_buf_unref(buf);
 10276a8:	f7f6 bc9a 	b.w	101dfe0 <net_buf_unref>
	k_work_reschedule(&(BT_L2CAP_LE_CHAN(chan)->rtx_work), timeout);
 10276ac:	463a      	mov	r2, r7
 10276ae:	4633      	mov	r3, r6
 10276b0:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
}
 10276b4:	b003      	add	sp, #12
 10276b6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_work_reschedule(&(BT_L2CAP_LE_CHAN(chan)->rtx_work), timeout);
 10276ba:	f7fa bd43 	b.w	1022144 <k_work_reschedule>

010276be <l2cap_le_conn_req>:
{
 10276be:	b538      	push	{r3, r4, r5, lr}
 10276c0:	4604      	mov	r4, r0
	ch->ident = get_ident();
 10276c2:	f7e3 fa2f 	bl	100ab24 <get_ident>
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_LE_CONN_REQ,
 10276c6:	220a      	movs	r2, #10
	ch->ident = get_ident();
 10276c8:	4601      	mov	r1, r0
 10276ca:	f884 0098 	strb.w	r0, [r4, #152]	; 0x98
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_LE_CONN_REQ,
 10276ce:	2014      	movs	r0, #20
 10276d0:	f7e3 fa4a 	bl	100ab68 <l2cap_create_le_sig_pdu.constprop.0>
	if (!buf) {
 10276d4:	4605      	mov	r5, r0
 10276d6:	b1b8      	cbz	r0, 1027708 <l2cap_le_conn_req+0x4a>
	return net_buf_simple_add(&buf->b, len);
 10276d8:	210a      	movs	r1, #10
 10276da:	300c      	adds	r0, #12
 10276dc:	f7f6 fddc 	bl	101e298 <net_buf_simple_add>
	req->psm = sys_cpu_to_le16(ch->psm);
 10276e0:	f8b4 3096 	ldrh.w	r3, [r4, #150]	; 0x96
	l2cap_chan_send_req(&ch->chan, buf, L2CAP_CONN_TIMEOUT);
 10276e4:	f44f 12a0 	mov.w	r2, #1310720	; 0x140000
	req->psm = sys_cpu_to_le16(ch->psm);
 10276e8:	8003      	strh	r3, [r0, #0]
	req->scid = sys_cpu_to_le16(ch->rx.cid);
 10276ea:	8aa3      	ldrh	r3, [r4, #20]
	l2cap_chan_send_req(&ch->chan, buf, L2CAP_CONN_TIMEOUT);
 10276ec:	4629      	mov	r1, r5
	req->scid = sys_cpu_to_le16(ch->rx.cid);
 10276ee:	8043      	strh	r3, [r0, #2]
	req->mtu = sys_cpu_to_le16(ch->rx.mtu);
 10276f0:	8ae3      	ldrh	r3, [r4, #22]
 10276f2:	8083      	strh	r3, [r0, #4]
	req->mps = sys_cpu_to_le16(ch->rx.mps);
 10276f4:	8b23      	ldrh	r3, [r4, #24]
 10276f6:	80c3      	strh	r3, [r0, #6]
	req->credits = sys_cpu_to_le16(ch->rx.init_credits);
 10276f8:	8b63      	ldrh	r3, [r4, #26]
 10276fa:	8103      	strh	r3, [r0, #8]
	l2cap_chan_send_req(&ch->chan, buf, L2CAP_CONN_TIMEOUT);
 10276fc:	4620      	mov	r0, r4
 10276fe:	2300      	movs	r3, #0
 1027700:	f7ff ffc1 	bl	1027686 <l2cap_chan_send_req>
	return 0;
 1027704:	2000      	movs	r0, #0
}
 1027706:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOMEM;
 1027708:	f06f 000b 	mvn.w	r0, #11
 102770c:	e7fb      	b.n	1027706 <l2cap_le_conn_req+0x48>

0102770e <bt_l2cap_security_changed>:
{
 102770e:	b570      	push	{r4, r5, r6, lr}
	return list->head;
 1027710:	6d44      	ldr	r4, [r0, #84]	; 0x54
 1027712:	460e      	mov	r6, r1
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
 1027714:	b364      	cbz	r4, 1027770 <bt_l2cap_security_changed+0x62>
	return node->next;
 1027716:	6825      	ldr	r5, [r4, #0]
 1027718:	b105      	cbz	r5, 102771c <bt_l2cap_security_changed+0xe>
 102771a:	3d08      	subs	r5, #8
 102771c:	3c08      	subs	r4, #8
 102771e:	e001      	b.n	1027724 <bt_l2cap_security_changed+0x16>
{
 1027720:	462c      	mov	r4, r5
 1027722:	461d      	mov	r5, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1027724:	f104 0310 	add.w	r3, r4, #16
 1027728:	e8d3 2fef 	ldaex	r2, [r3]
 102772c:	f022 0104 	bic.w	r1, r2, #4
 1027730:	e8c3 1fe0 	stlex	r0, r1, [r3]
 1027734:	2800      	cmp	r0, #0
 1027736:	d1f7      	bne.n	1027728 <bt_l2cap_security_changed+0x1a>
	if (!atomic_test_and_clear_bit(chan->status,
 1027738:	0753      	lsls	r3, r2, #29
 102773a:	d507      	bpl.n	102774c <bt_l2cap_security_changed+0x3e>
	if (status) {
 102773c:	b196      	cbz	r6, 1027764 <bt_l2cap_security_changed+0x56>
	bt_l2cap_chan_remove(chan->conn, chan);
 102773e:	6820      	ldr	r0, [r4, #0]
 1027740:	4621      	mov	r1, r4
 1027742:	f7ff fec1 	bl	10274c8 <bt_l2cap_chan_remove>
	bt_l2cap_chan_del(chan);
 1027746:	4620      	mov	r0, r4
 1027748:	f7ff fed3 	bl	10274f2 <bt_l2cap_chan_del>
		if (chan->ops->encrypt_change) {
 102774c:	6863      	ldr	r3, [r4, #4]
 102774e:	689b      	ldr	r3, [r3, #8]
 1027750:	b113      	cbz	r3, 1027758 <bt_l2cap_security_changed+0x4a>
			chan->ops->encrypt_change(chan, hci_status);
 1027752:	4631      	mov	r1, r6
 1027754:	4620      	mov	r0, r4
 1027756:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
 1027758:	b155      	cbz	r5, 1027770 <bt_l2cap_security_changed+0x62>
 102775a:	68ab      	ldr	r3, [r5, #8]
 102775c:	2b00      	cmp	r3, #0
 102775e:	d0df      	beq.n	1027720 <bt_l2cap_security_changed+0x12>
 1027760:	3b08      	subs	r3, #8
 1027762:	e7dd      	b.n	1027720 <bt_l2cap_security_changed+0x12>
	err = l2cap_le_conn_req(le);
 1027764:	4620      	mov	r0, r4
 1027766:	f7ff ffaa 	bl	10276be <l2cap_le_conn_req>
	if (err) {
 102776a:	2800      	cmp	r0, #0
 102776c:	d0ee      	beq.n	102774c <bt_l2cap_security_changed+0x3e>
 102776e:	e7e6      	b.n	102773e <bt_l2cap_security_changed+0x30>
}
 1027770:	bd70      	pop	{r4, r5, r6, pc}

01027772 <bt_l2cap_le_lookup_tx_cid>:
	return list->head;
 1027772:	6d40      	ldr	r0, [r0, #84]	; 0x54
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 1027774:	b128      	cbz	r0, 1027782 <bt_l2cap_le_lookup_tx_cid+0x10>
		if (BT_L2CAP_LE_CHAN(chan)->tx.cid == cid) {
 1027776:	8b83      	ldrh	r3, [r0, #28]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 1027778:	3808      	subs	r0, #8
		if (BT_L2CAP_LE_CHAN(chan)->tx.cid == cid) {
 102777a:	428b      	cmp	r3, r1
 102777c:	d001      	beq.n	1027782 <bt_l2cap_le_lookup_tx_cid+0x10>
	return node->next;
 102777e:	6880      	ldr	r0, [r0, #8]
 1027780:	e7f8      	b.n	1027774 <bt_l2cap_le_lookup_tx_cid+0x2>
}
 1027782:	4770      	bx	lr

01027784 <l2cap_chan_seg_sent>:
{
 1027784:	b508      	push	{r3, lr}
	if (err) {
 1027786:	b93a      	cbnz	r2, 1027798 <l2cap_chan_seg_sent+0x14>
	chan = bt_l2cap_le_lookup_tx_cid(conn, data->cid);
 1027788:	8889      	ldrh	r1, [r1, #4]
 102778a:	f7ff fff2 	bl	1027772 <bt_l2cap_le_lookup_tx_cid>
	if (!chan) {
 102778e:	b118      	cbz	r0, 1027798 <l2cap_chan_seg_sent+0x14>
}
 1027790:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	l2cap_chan_tx_resume(BT_L2CAP_LE_CHAN(chan));
 1027794:	f7ff be1f 	b.w	10273d6 <l2cap_chan_tx_resume>
}
 1027798:	bd08      	pop	{r3, pc}

0102779a <bt_l2cap_le_lookup_rx_cid>:
	return list->head;
 102779a:	6d40      	ldr	r0, [r0, #84]	; 0x54
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 102779c:	b128      	cbz	r0, 10277aa <bt_l2cap_le_lookup_rx_cid+0x10>
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
 102779e:	8983      	ldrh	r3, [r0, #12]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 10277a0:	3808      	subs	r0, #8
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
 10277a2:	428b      	cmp	r3, r1
 10277a4:	d001      	beq.n	10277aa <bt_l2cap_le_lookup_rx_cid+0x10>
	return node->next;
 10277a6:	6880      	ldr	r0, [r0, #8]
 10277a8:	e7f8      	b.n	102779c <bt_l2cap_le_lookup_rx_cid+0x2>
}
 10277aa:	4770      	bx	lr

010277ac <bt_l2cap_update_conn_param>:
{
 10277ac:	b573      	push	{r0, r1, r4, r5, r6, lr}
 10277ae:	4606      	mov	r6, r0
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
 10277b0:	f7e3 f9b8 	bl	100ab24 <get_ident>
{
 10277b4:	460d      	mov	r5, r1
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
 10277b6:	2208      	movs	r2, #8
 10277b8:	4601      	mov	r1, r0
 10277ba:	2012      	movs	r0, #18
 10277bc:	f7e3 f9d4 	bl	100ab68 <l2cap_create_le_sig_pdu.constprop.0>
	if (!buf) {
 10277c0:	4604      	mov	r4, r0
 10277c2:	b1d0      	cbz	r0, 10277fa <bt_l2cap_update_conn_param+0x4e>
 10277c4:	2108      	movs	r1, #8
 10277c6:	300c      	adds	r0, #12
 10277c8:	f7f6 fd66 	bl	101e298 <net_buf_simple_add>
	req->min_interval = sys_cpu_to_le16(param->interval_min);
 10277cc:	882b      	ldrh	r3, [r5, #0]
 10277ce:	4622      	mov	r2, r4
 10277d0:	8003      	strh	r3, [r0, #0]
	req->max_interval = sys_cpu_to_le16(param->interval_max);
 10277d2:	886b      	ldrh	r3, [r5, #2]
 10277d4:	2105      	movs	r1, #5
 10277d6:	8043      	strh	r3, [r0, #2]
	req->latency = sys_cpu_to_le16(param->latency);
 10277d8:	88ab      	ldrh	r3, [r5, #4]
 10277da:	8083      	strh	r3, [r0, #4]
	req->timeout = sys_cpu_to_le16(param->timeout);
 10277dc:	88eb      	ldrh	r3, [r5, #6]
 10277de:	80c3      	strh	r3, [r0, #6]
 10277e0:	2300      	movs	r3, #0
 10277e2:	4630      	mov	r0, r6
 10277e4:	9300      	str	r3, [sp, #0]
 10277e6:	f7ff feb9 	bl	102755c <bt_l2cap_send_cb>
	if (err) {
 10277ea:	4605      	mov	r5, r0
 10277ec:	b110      	cbz	r0, 10277f4 <bt_l2cap_update_conn_param+0x48>
		net_buf_unref(buf);
 10277ee:	4620      	mov	r0, r4
 10277f0:	f7f6 fbf6 	bl	101dfe0 <net_buf_unref>
}
 10277f4:	4628      	mov	r0, r5
 10277f6:	b002      	add	sp, #8
 10277f8:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOMEM;
 10277fa:	f06f 050b 	mvn.w	r5, #11
 10277fe:	e7f9      	b.n	10277f4 <bt_l2cap_update_conn_param+0x48>

01027800 <bt_l2cap_chan_disconnect>:

	return l2cap_le_connect(conn, le_chan, psm);
}

int bt_l2cap_chan_disconnect(struct bt_l2cap_chan *chan)
{
 1027800:	b538      	push	{r3, r4, r5, lr}
	struct bt_conn *conn = chan->conn;
	struct net_buf *buf;
	struct bt_l2cap_disconn_req *req;
	struct bt_l2cap_le_chan *le_chan;

	if (!conn) {
 1027802:	6803      	ldr	r3, [r0, #0]
{
 1027804:	4604      	mov	r4, r0
	if (!conn) {
 1027806:	b1f3      	cbz	r3, 1027846 <bt_l2cap_chan_disconnect+0x46>

	le_chan = BT_L2CAP_LE_CHAN(chan);

	LOG_DBG("chan %p scid 0x%04x dcid 0x%04x", chan, le_chan->rx.cid, le_chan->tx.cid);

	le_chan->ident = get_ident();
 1027808:	f7e3 f98c 	bl	100ab24 <get_ident>

	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_DISCONN_REQ,
 102780c:	2204      	movs	r2, #4
	le_chan->ident = get_ident();
 102780e:	4601      	mov	r1, r0
 1027810:	f884 0098 	strb.w	r0, [r4, #152]	; 0x98
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_DISCONN_REQ,
 1027814:	2006      	movs	r0, #6
 1027816:	f7e3 f9a7 	bl	100ab68 <l2cap_create_le_sig_pdu.constprop.0>
				      le_chan->ident, sizeof(*req));
	if (!buf) {
 102781a:	4605      	mov	r5, r0
 102781c:	b1b0      	cbz	r0, 102784c <bt_l2cap_chan_disconnect+0x4c>
 102781e:	2104      	movs	r1, #4
 1027820:	300c      	adds	r0, #12
 1027822:	f7f6 fd39 	bl	101e298 <net_buf_simple_add>
		return -ENOMEM;
	}

	req = net_buf_add(buf, sizeof(*req));
	req->dcid = sys_cpu_to_le16(le_chan->tx.cid);
 1027826:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
	req->scid = sys_cpu_to_le16(le_chan->rx.cid);

	l2cap_chan_send_req(chan, buf, L2CAP_DISC_TIMEOUT);
 1027828:	f44f 3280 	mov.w	r2, #65536	; 0x10000
	req->dcid = sys_cpu_to_le16(le_chan->tx.cid);
 102782c:	8003      	strh	r3, [r0, #0]
	req->scid = sys_cpu_to_le16(le_chan->rx.cid);
 102782e:	8aa3      	ldrh	r3, [r4, #20]
	l2cap_chan_send_req(chan, buf, L2CAP_DISC_TIMEOUT);
 1027830:	4629      	mov	r1, r5
	req->scid = sys_cpu_to_le16(le_chan->rx.cid);
 1027832:	8043      	strh	r3, [r0, #2]
	l2cap_chan_send_req(chan, buf, L2CAP_DISC_TIMEOUT);
 1027834:	2300      	movs	r3, #0
 1027836:	4620      	mov	r0, r4
 1027838:	f7ff ff25 	bl	1027686 <l2cap_chan_send_req>
	BT_L2CAP_LE_CHAN(chan)->state = state;
 102783c:	2304      	movs	r3, #4
	bt_l2cap_chan_set_state(chan, BT_L2CAP_DISCONNECTING);

	return 0;
 102783e:	2000      	movs	r0, #0
	BT_L2CAP_LE_CHAN(chan)->state = state;
 1027840:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
}
 1027844:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOTCONN;
 1027846:	f06f 007f 	mvn.w	r0, #127	; 0x7f
 102784a:	e7fb      	b.n	1027844 <bt_l2cap_chan_disconnect+0x44>
		return -ENOMEM;
 102784c:	f06f 000b 	mvn.w	r0, #11
 1027850:	e7f8      	b.n	1027844 <bt_l2cap_chan_disconnect+0x44>

01027852 <l2cap_rx_process>:
{
 1027852:	b570      	push	{r4, r5, r6, lr}
	struct bt_l2cap_le_chan *ch = CHAN_RX(work);
 1027854:	f1a0 0668 	sub.w	r6, r0, #104	; 0x68
	while ((buf = net_buf_get(&ch->rx_queue, K_NO_WAIT))) {
 1027858:	f100 0410 	add.w	r4, r0, #16
 102785c:	2200      	movs	r2, #0
 102785e:	2300      	movs	r3, #0
 1027860:	4620      	mov	r0, r4
 1027862:	f001 fa76 	bl	1028d52 <net_buf_get>
 1027866:	4605      	mov	r5, r0
 1027868:	b900      	cbnz	r0, 102786c <l2cap_rx_process+0x1a>
}
 102786a:	bd70      	pop	{r4, r5, r6, pc}
		l2cap_chan_le_recv(ch, buf);
 102786c:	4630      	mov	r0, r6
 102786e:	4629      	mov	r1, r5
 1027870:	f7e3 fdb2 	bl	100b3d8 <l2cap_chan_le_recv>
		net_buf_unref(buf);
 1027874:	4628      	mov	r0, r5
 1027876:	f7f6 fbb3 	bl	101dfe0 <net_buf_unref>
 102787a:	e7ef      	b.n	102785c <l2cap_rx_process+0xa>

0102787c <sys_slist_get>:
Z_GENLIST_GET(slist, snode)
 102787c:	4603      	mov	r3, r0
	return list->head;
 102787e:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_GET(slist, snode)
 1027880:	b128      	cbz	r0, 102788e <sys_slist_get+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1027882:	6859      	ldr	r1, [r3, #4]
	return node->next;
 1027884:	6802      	ldr	r2, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1027886:	4288      	cmp	r0, r1
	list->head = node;
 1027888:	601a      	str	r2, [r3, #0]
	list->tail = node;
 102788a:	bf08      	it	eq
 102788c:	605a      	streq	r2, [r3, #4]
Z_GENLIST_GET(slist, snode)
 102788e:	4770      	bx	lr

01027890 <net_buf_frags_len>:
{
 1027890:	4603      	mov	r3, r0
	size_t bytes = 0;
 1027892:	2000      	movs	r0, #0
	while (buf) {
 1027894:	b903      	cbnz	r3, 1027898 <net_buf_frags_len+0x8>
}
 1027896:	4770      	bx	lr
		bytes += buf->len;
 1027898:	8a1a      	ldrh	r2, [r3, #16]
		buf = buf->frags;
 102789a:	685b      	ldr	r3, [r3, #4]
		bytes += buf->len;
 102789c:	4410      	add	r0, r2
		buf = buf->frags;
 102789e:	e7f9      	b.n	1027894 <net_buf_frags_len+0x4>

010278a0 <attr_read_type_cb>:
{
 10278a0:	b510      	push	{r4, lr}
	if (!data->rsp->len) {
 10278a2:	68d4      	ldr	r4, [r2, #12]
 10278a4:	3102      	adds	r1, #2
 10278a6:	7823      	ldrb	r3, [r4, #0]
 10278a8:	b913      	cbnz	r3, 10278b0 <attr_read_type_cb+0x10>
		data->rsp->len = read + sizeof(*data->item);
 10278aa:	7021      	strb	r1, [r4, #0]
	return true;
 10278ac:	2001      	movs	r0, #1
}
 10278ae:	bd10      	pop	{r4, pc}
	} else if (data->rsp->len != read + sizeof(*data->item)) {
 10278b0:	428b      	cmp	r3, r1
 10278b2:	d0fb      	beq.n	10278ac <attr_read_type_cb+0xc>
		frag->len -= sizeof(*data->item);
 10278b4:	8a03      	ldrh	r3, [r0, #16]
 10278b6:	3b02      	subs	r3, #2
 10278b8:	8203      	strh	r3, [r0, #16]
		data->item = NULL;
 10278ba:	2000      	movs	r0, #0
 10278bc:	6110      	str	r0, [r2, #16]
		return false;
 10278be:	e7f6      	b.n	10278ae <attr_read_type_cb+0xe>

010278c0 <att_prepare_write_req>:
}
 10278c0:	2006      	movs	r0, #6
 10278c2:	4770      	bx	lr

010278c4 <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 10278c4:	e8d0 0faf 	lda	r0, [r0]
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
 10278c8:	4108      	asrs	r0, r1
}
 10278ca:	f000 0001 	and.w	r0, r0, #1
 10278ce:	4770      	bx	lr

010278d0 <write_cb>:
{
 10278d0:	b573      	push	{r0, r1, r4, r5, r6, lr}
 10278d2:	4614      	mov	r4, r2
	data->err = bt_gatt_check_perm(data->conn, attr,
 10278d4:	4601      	mov	r1, r0
{
 10278d6:	4605      	mov	r5, r0
	data->err = bt_gatt_check_perm(data->conn, attr,
 10278d8:	f44f 7295 	mov.w	r2, #298	; 0x12a
 10278dc:	6820      	ldr	r0, [r4, #0]
 10278de:	f000 fe5b 	bl	1028598 <bt_gatt_check_perm>
 10278e2:	7520      	strb	r0, [r4, #20]
	if (data->err) {
 10278e4:	bb00      	cbnz	r0, 1027928 <write_cb+0x58>
	if (!data->req) {
 10278e6:	7a23      	ldrb	r3, [r4, #8]
 10278e8:	b1b3      	cbz	r3, 1027918 <write_cb+0x48>
	} else if (data->req == BT_ATT_OP_EXEC_WRITE_REQ) {
 10278ea:	f1a3 0218 	sub.w	r2, r3, #24
 10278ee:	4253      	negs	r3, r2
 10278f0:	4153      	adcs	r3, r2
 10278f2:	009b      	lsls	r3, r3, #2
	write = attr->write(data->conn, attr, data->value, data->len,
 10278f4:	9301      	str	r3, [sp, #4]
 10278f6:	8a63      	ldrh	r3, [r4, #18]
 10278f8:	4629      	mov	r1, r5
 10278fa:	9300      	str	r3, [sp, #0]
 10278fc:	68ae      	ldr	r6, [r5, #8]
 10278fe:	8a23      	ldrh	r3, [r4, #16]
 1027900:	68e2      	ldr	r2, [r4, #12]
 1027902:	6820      	ldr	r0, [r4, #0]
 1027904:	47b0      	blx	r6
	if (write < 0 || write != data->len) {
 1027906:	2800      	cmp	r0, #0
 1027908:	db08      	blt.n	102791c <write_cb+0x4c>
 102790a:	8a23      	ldrh	r3, [r4, #16]
 102790c:	4298      	cmp	r0, r3
 102790e:	d10e      	bne.n	102792e <write_cb+0x5e>
	data->err = 0U;
 1027910:	2300      	movs	r3, #0
	return BT_GATT_ITER_CONTINUE;
 1027912:	2001      	movs	r0, #1
	data->err = 0U;
 1027914:	7523      	strb	r3, [r4, #20]
	return BT_GATT_ITER_CONTINUE;
 1027916:	e008      	b.n	102792a <write_cb+0x5a>
		flags |= BT_GATT_WRITE_FLAG_CMD;
 1027918:	2302      	movs	r3, #2
 102791a:	e7eb      	b.n	10278f4 <write_cb+0x24>
	if (err < 0 && err >= -0xff) {
 102791c:	f110 0fff 	cmn.w	r0, #255	; 0xff
 1027920:	d305      	bcc.n	102792e <write_cb+0x5e>
		return -err;
 1027922:	4240      	negs	r0, r0
 1027924:	b2c0      	uxtb	r0, r0
		data->err = err_to_att(write);
 1027926:	7520      	strb	r0, [r4, #20]
		return BT_GATT_ITER_STOP;
 1027928:	2000      	movs	r0, #0
}
 102792a:	b002      	add	sp, #8
 102792c:	bd70      	pop	{r4, r5, r6, pc}
	return BT_ATT_ERR_UNLIKELY;
 102792e:	200e      	movs	r0, #14
 1027930:	e7f9      	b.n	1027926 <write_cb+0x56>

01027932 <bt_gatt_foreach_attr>:
{
 1027932:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
 1027934:	e9cd 2301 	strd	r2, r3, [sp, #4]
 1027938:	2300      	movs	r3, #0
 102793a:	461a      	mov	r2, r3
 102793c:	9300      	str	r3, [sp, #0]
 102793e:	f7e6 f89b 	bl	100da78 <bt_gatt_foreach_attr_type>
}
 1027942:	b005      	add	sp, #20
 1027944:	f85d fb04 	ldr.w	pc, [sp], #4

01027948 <find_info_cb>:
{
 1027948:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!data->rsp) {
 102794a:	6893      	ldr	r3, [r2, #8]
{
 102794c:	4605      	mov	r5, r0
 102794e:	460e      	mov	r6, r1
 1027950:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
 1027952:	6817      	ldr	r7, [r2, #0]
	if (!data->rsp) {
 1027954:	b963      	cbnz	r3, 1027970 <find_info_cb+0x28>
	return net_buf_simple_add(&buf->b, len);
 1027956:	6850      	ldr	r0, [r2, #4]
 1027958:	2101      	movs	r1, #1
 102795a:	300c      	adds	r0, #12
 102795c:	f7f6 fc9c 	bl	101e298 <net_buf_simple_add>
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
 1027960:	60a0      	str	r0, [r4, #8]
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
 1027962:	682b      	ldr	r3, [r5, #0]
 1027964:	781b      	ldrb	r3, [r3, #0]
 1027966:	2b00      	cmp	r3, #0
 1027968:	bf14      	ite	ne
 102796a:	2302      	movne	r3, #2
 102796c:	2301      	moveq	r3, #1
 102796e:	7003      	strb	r3, [r0, #0]
	switch (data->rsp->format) {
 1027970:	68a3      	ldr	r3, [r4, #8]
 1027972:	781b      	ldrb	r3, [r3, #0]
 1027974:	2b01      	cmp	r3, #1
 1027976:	d003      	beq.n	1027980 <find_info_cb+0x38>
 1027978:	2b02      	cmp	r3, #2
 102797a:	d019      	beq.n	10279b0 <find_info_cb+0x68>
 102797c:	2000      	movs	r0, #0
 102797e:	e016      	b.n	10279ae <find_info_cb+0x66>
		if (attr->uuid->type != BT_UUID_TYPE_16) {
 1027980:	682b      	ldr	r3, [r5, #0]
 1027982:	781b      	ldrb	r3, [r3, #0]
 1027984:	2b00      	cmp	r3, #0
 1027986:	d1f9      	bne.n	102797c <find_info_cb+0x34>
 1027988:	6860      	ldr	r0, [r4, #4]
 102798a:	2104      	movs	r1, #4
 102798c:	300c      	adds	r0, #12
 102798e:	f7f6 fc83 	bl	101e298 <net_buf_simple_add>
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
 1027992:	60e0      	str	r0, [r4, #12]
		data->info16->handle = sys_cpu_to_le16(handle);
 1027994:	8006      	strh	r6, [r0, #0]
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
 1027996:	682a      	ldr	r2, [r5, #0]
 1027998:	68e3      	ldr	r3, [r4, #12]
 102799a:	8852      	ldrh	r2, [r2, #2]
 102799c:	805a      	strh	r2, [r3, #2]
		if (chan->chan.tx.mtu - data->buf->len >
 102799e:	6863      	ldr	r3, [r4, #4]
 10279a0:	8df8      	ldrh	r0, [r7, #46]	; 0x2e
 10279a2:	8a1b      	ldrh	r3, [r3, #16]
 10279a4:	1ac0      	subs	r0, r0, r3
 10279a6:	2804      	cmp	r0, #4
		if (chan->chan.tx.mtu - data->buf->len >
 10279a8:	bf94      	ite	ls
 10279aa:	2000      	movls	r0, #0
 10279ac:	2001      	movhi	r0, #1
}
 10279ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (attr->uuid->type != BT_UUID_TYPE_128) {
 10279b0:	682b      	ldr	r3, [r5, #0]
 10279b2:	781b      	ldrb	r3, [r3, #0]
 10279b4:	2b02      	cmp	r3, #2
 10279b6:	d1e1      	bne.n	102797c <find_info_cb+0x34>
 10279b8:	6860      	ldr	r0, [r4, #4]
 10279ba:	2112      	movs	r1, #18
 10279bc:	300c      	adds	r0, #12
 10279be:	f7f6 fc6b 	bl	101e298 <net_buf_simple_add>
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
 10279c2:	60e0      	str	r0, [r4, #12]
		data->info128->handle = sys_cpu_to_le16(handle);
 10279c4:	8006      	strh	r6, [r0, #0]
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
 10279c6:	6829      	ldr	r1, [r5, #0]
 10279c8:	68e0      	ldr	r0, [r4, #12]
 10279ca:	2210      	movs	r2, #16
 10279cc:	3101      	adds	r1, #1
 10279ce:	3002      	adds	r0, #2
 10279d0:	f7fe ffd0 	bl	1026974 <memcpy>
		if (chan->chan.tx.mtu - data->buf->len >
 10279d4:	6863      	ldr	r3, [r4, #4]
 10279d6:	8df8      	ldrh	r0, [r7, #46]	; 0x2e
 10279d8:	8a1b      	ldrh	r3, [r3, #16]
 10279da:	1ac0      	subs	r0, r0, r3
 10279dc:	2812      	cmp	r0, #18
 10279de:	e7e3      	b.n	10279a8 <find_info_cb+0x60>

010279e0 <att_chan_mtu_updated>:
{
 10279e0:	b470      	push	{r4, r5, r6}
	struct bt_att *att = updated_chan->att;
 10279e2:	6805      	ldr	r5, [r0, #0]
	return list->head;
 10279e4:	6aaa      	ldr	r2, [r5, #40]	; 0x28
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 10279e6:	b362      	cbz	r2, 1027a42 <att_chan_mtu_updated+0x62>
	return node->next;
 10279e8:	6813      	ldr	r3, [r2, #0]
 10279ea:	b10b      	cbz	r3, 10279f0 <att_chan_mtu_updated+0x10>
 10279ec:	f5a3 73ac 	sub.w	r3, r3, #344	; 0x158
 10279f0:	f5a2 74ac 	sub.w	r4, r2, #344	; 0x158
 10279f4:	2200      	movs	r2, #0
 10279f6:	4611      	mov	r1, r2
 10279f8:	e001      	b.n	10279fe <att_chan_mtu_updated+0x1e>
 10279fa:	f5a3 73ac 	sub.w	r3, r3, #344	; 0x158
		if (chan == updated_chan) {
 10279fe:	4284      	cmp	r4, r0
 1027a00:	d007      	beq.n	1027a12 <att_chan_mtu_updated+0x32>
		max_tx = MAX(max_tx, chan->chan.tx.mtu);
 1027a02:	8de6      	ldrh	r6, [r4, #46]	; 0x2e
		max_rx = MAX(max_rx, chan->chan.rx.mtu);
 1027a04:	8be4      	ldrh	r4, [r4, #30]
		max_tx = MAX(max_tx, chan->chan.tx.mtu);
 1027a06:	42b1      	cmp	r1, r6
 1027a08:	bf38      	it	cc
 1027a0a:	4631      	movcc	r1, r6
		max_rx = MAX(max_rx, chan->chan.rx.mtu);
 1027a0c:	42a2      	cmp	r2, r4
 1027a0e:	bf38      	it	cc
 1027a10:	4622      	movcc	r2, r4
 1027a12:	461c      	mov	r4, r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 1027a14:	b12b      	cbz	r3, 1027a22 <att_chan_mtu_updated+0x42>
 1027a16:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
 1027a1a:	2b00      	cmp	r3, #0
 1027a1c:	d1ed      	bne.n	10279fa <att_chan_mtu_updated+0x1a>
		if (chan == updated_chan) {
 1027a1e:	4284      	cmp	r4, r0
 1027a20:	d1ef      	bne.n	1027a02 <att_chan_mtu_updated+0x22>
	if ((updated_chan->chan.tx.mtu > max_tx) ||
 1027a22:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
	    (updated_chan->chan.rx.mtu > max_rx)) {
 1027a24:	8bc0      	ldrh	r0, [r0, #30]
	if ((updated_chan->chan.tx.mtu > max_tx) ||
 1027a26:	428b      	cmp	r3, r1
 1027a28:	d801      	bhi.n	1027a2e <att_chan_mtu_updated+0x4e>
 1027a2a:	4290      	cmp	r0, r2
 1027a2c:	d90b      	bls.n	1027a46 <att_chan_mtu_updated+0x66>
		bt_gatt_att_max_mtu_changed(att->conn, max_tx, max_rx);
 1027a2e:	4282      	cmp	r2, r0
 1027a30:	bf38      	it	cc
 1027a32:	4602      	movcc	r2, r0
 1027a34:	4299      	cmp	r1, r3
 1027a36:	6828      	ldr	r0, [r5, #0]
 1027a38:	bf38      	it	cc
 1027a3a:	4619      	movcc	r1, r3
}
 1027a3c:	bc70      	pop	{r4, r5, r6}
		bt_gatt_att_max_mtu_changed(att->conn, max_tx, max_rx);
 1027a3e:	f7e6 bfe7 	b.w	100ea10 <bt_gatt_att_max_mtu_changed>
 1027a42:	4611      	mov	r1, r2
 1027a44:	e7ed      	b.n	1027a22 <att_chan_mtu_updated+0x42>
}
 1027a46:	bc70      	pop	{r4, r5, r6}
 1027a48:	4770      	bx	lr

01027a4a <attr_read_group_cb>:
	if (!data->rsp->len) {
 1027a4a:	68d0      	ldr	r0, [r2, #12]
 1027a4c:	3104      	adds	r1, #4
 1027a4e:	7803      	ldrb	r3, [r0, #0]
 1027a50:	b913      	cbnz	r3, 1027a58 <attr_read_group_cb+0xe>
		data->rsp->len = read + sizeof(*data->group);
 1027a52:	7001      	strb	r1, [r0, #0]
	return true;
 1027a54:	2001      	movs	r0, #1
 1027a56:	4770      	bx	lr
	} else if (data->rsp->len != read + sizeof(*data->group)) {
 1027a58:	428b      	cmp	r3, r1
 1027a5a:	d0fb      	beq.n	1027a54 <attr_read_group_cb+0xa>
		data->group = NULL;
 1027a5c:	2000      	movs	r0, #0
		data->buf->len -= sizeof(*data->group);
 1027a5e:	6891      	ldr	r1, [r2, #8]
 1027a60:	8a0b      	ldrh	r3, [r1, #16]
 1027a62:	3b04      	subs	r3, #4
 1027a64:	820b      	strh	r3, [r1, #16]
		data->group = NULL;
 1027a66:	6110      	str	r0, [r2, #16]
}
 1027a68:	4770      	bx	lr

01027a6a <z_log_msg_static_create.constprop.0>:
 1027a6a:	2300      	movs	r3, #0
 1027a6c:	f7dc be4c 	b.w	1004708 <z_impl_z_log_msg_static_create>

01027a70 <chan_req_send>:
{
 1027a70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1027a72:	4605      	mov	r5, r0
	if (chan->chan.tx.mtu < net_buf_frags_len(req->buf)) {
 1027a74:	6888      	ldr	r0, [r1, #8]
 1027a76:	f7ff ff0b 	bl	1027890 <net_buf_frags_len>
 1027a7a:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
{
 1027a7c:	460c      	mov	r4, r1
	if (chan->chan.tx.mtu < net_buf_frags_len(req->buf)) {
 1027a7e:	4283      	cmp	r3, r0
 1027a80:	d30d      	bcc.n	1027a9e <chan_req_send+0x2e>
	req->buf = NULL;
 1027a82:	2600      	movs	r6, #0
	chan->req = req;
 1027a84:	f8c5 1104 	str.w	r1, [r5, #260]	; 0x104
	buf = req->buf;
 1027a88:	688f      	ldr	r7, [r1, #8]
	return chan_send(chan, buf);
 1027a8a:	4628      	mov	r0, r5
	req->buf = NULL;
 1027a8c:	608e      	str	r6, [r1, #8]
	return chan_send(chan, buf);
 1027a8e:	4639      	mov	r1, r7
 1027a90:	f7e4 f954 	bl	100bd3c <chan_send>
	if (err) {
 1027a94:	b110      	cbz	r0, 1027a9c <chan_req_send+0x2c>
		req->buf = buf;
 1027a96:	60a7      	str	r7, [r4, #8]
		chan->req = NULL;
 1027a98:	f8c5 6104 	str.w	r6, [r5, #260]	; 0x104
}
 1027a9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -EMSGSIZE;
 1027a9e:	f06f 0079 	mvn.w	r0, #121	; 0x79
 1027aa2:	e7fb      	b.n	1027a9c <chan_req_send+0x2c>

01027aa4 <process_queue>:
{
 1027aa4:	b570      	push	{r4, r5, r6, lr}
		return net_buf_get(fifo, K_NO_WAIT);
 1027aa6:	2200      	movs	r2, #0
{
 1027aa8:	4604      	mov	r4, r0
		return net_buf_get(fifo, K_NO_WAIT);
 1027aaa:	2300      	movs	r3, #0
 1027aac:	4608      	mov	r0, r1
{
 1027aae:	460e      	mov	r6, r1
		return net_buf_get(fifo, K_NO_WAIT);
 1027ab0:	f001 f94f 	bl	1028d52 <net_buf_get>
	if (buf) {
 1027ab4:	4605      	mov	r5, r0
 1027ab6:	b158      	cbz	r0, 1027ad0 <process_queue+0x2c>
	return chan_send(chan, buf);
 1027ab8:	4601      	mov	r1, r0
 1027aba:	4620      	mov	r0, r4
 1027abc:	f7e4 f93e 	bl	100bd3c <chan_send>
		if (err) {
 1027ac0:	4604      	mov	r4, r0
 1027ac2:	b118      	cbz	r0, 1027acc <process_queue+0x28>
			k_queue_prepend(&queue->_queue, buf);
 1027ac4:	4629      	mov	r1, r5
 1027ac6:	4630      	mov	r0, r6
 1027ac8:	f001 fc1b 	bl	1029302 <k_queue_prepend>
}
 1027acc:	4620      	mov	r0, r4
 1027ace:	bd70      	pop	{r4, r5, r6, pc}
	return -ENOENT;
 1027ad0:	f06f 0401 	mvn.w	r4, #1
 1027ad4:	e7fa      	b.n	1027acc <process_queue+0x28>

01027ad6 <bt_att_chan_send_rsp>:
{
 1027ad6:	b538      	push	{r3, r4, r5, lr}
 1027ad8:	4604      	mov	r4, r0
 1027ada:	460d      	mov	r5, r1
	err = chan_send(chan, buf);
 1027adc:	f7e4 f92e 	bl	100bd3c <chan_send>
	if (err) {
 1027ae0:	b130      	cbz	r0, 1027af0 <bt_att_chan_send_rsp+0x1a>
		net_buf_put(&chan->tx_queue, buf);
 1027ae2:	4629      	mov	r1, r5
 1027ae4:	f504 7084 	add.w	r0, r4, #264	; 0x108
}
 1027ae8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		net_buf_put(&chan->tx_queue, buf);
 1027aec:	f7f6 ba52 	b.w	101df94 <net_buf_put>
}
 1027af0:	bd38      	pop	{r3, r4, r5, pc}

01027af2 <att_chan_read>:
{
 1027af2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1027af6:	4680      	mov	r8, r0
 1027af8:	b085      	sub	sp, #20
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
 1027afa:	4610      	mov	r0, r2
{
 1027afc:	4699      	mov	r9, r3
 1027afe:	4616      	mov	r6, r2
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
 1027b00:	f7ff fec6 	bl	1027890 <net_buf_frags_len>
 1027b04:	f8b8 302e 	ldrh.w	r3, [r8, #46]	; 0x2e
{
 1027b08:	468b      	mov	fp, r1
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
 1027b0a:	4283      	cmp	r3, r0
 1027b0c:	d97a      	bls.n	1027c04 <att_chan_read+0x112>
	struct bt_conn *conn = chan->chan.chan.conn;
 1027b0e:	f8d8 3008 	ldr.w	r3, [r8, #8]
	frag = net_buf_frag_last(buf);
 1027b12:	4630      	mov	r0, r6
	struct bt_conn *conn = chan->chan.chan.conn;
 1027b14:	9303      	str	r3, [sp, #12]
	frag = net_buf_frag_last(buf);
 1027b16:	f7f6 fabd 	bl	101e094 <net_buf_frag_last>
	size_t len, total = 0;
 1027b1a:	f04f 0a00 	mov.w	sl, #0
	frag = net_buf_frag_last(buf);
 1027b1e:	4605      	mov	r5, r0
		len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
 1027b20:	4630      	mov	r0, r6
 1027b22:	f7ff feb5 	bl	1027890 <net_buf_frags_len>
 1027b26:	f8b8 402e 	ldrh.w	r4, [r8, #46]	; 0x2e
	return net_buf_simple_tailroom(&buf->b);
 1027b2a:	f105 070c 	add.w	r7, r5, #12
 1027b2e:	1a24      	subs	r4, r4, r0
 1027b30:	4638      	mov	r0, r7
 1027b32:	f001 f925 	bl	1028d80 <net_buf_simple_tailroom>
 1027b36:	4284      	cmp	r4, r0
 1027b38:	d211      	bcs.n	1027b5e <att_chan_read+0x6c>
 1027b3a:	4630      	mov	r0, r6
 1027b3c:	f7ff fea8 	bl	1027890 <net_buf_frags_len>
 1027b40:	f8b8 402e 	ldrh.w	r4, [r8, #46]	; 0x2e
 1027b44:	1a24      	subs	r4, r4, r0
		if (!len) {
 1027b46:	bb34      	cbnz	r4, 1027b96 <att_chan_read+0xa4>
			frag = net_buf_alloc(net_buf_pool_get(buf->pool_id),
 1027b48:	7ab0      	ldrb	r0, [r6, #10]
 1027b4a:	f7f6 f8d5 	bl	101dcf8 <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
 1027b4e:	2200      	movs	r2, #0
 1027b50:	2300      	movs	r3, #0
 1027b52:	f001 f8f9 	bl	1028d48 <net_buf_alloc_fixed>
			if (!frag) {
 1027b56:	4605      	mov	r5, r0
 1027b58:	b930      	cbnz	r0, 1027b68 <att_chan_read+0x76>
	return total;
 1027b5a:	4657      	mov	r7, sl
 1027b5c:	e02c      	b.n	1027bb8 <att_chan_read+0xc6>
	return net_buf_simple_tailroom(&buf->b);
 1027b5e:	4638      	mov	r0, r7
 1027b60:	f001 f90e 	bl	1028d80 <net_buf_simple_tailroom>
 1027b64:	4604      	mov	r4, r0
 1027b66:	e7ee      	b.n	1027b46 <att_chan_read+0x54>
			net_buf_frag_add(buf, frag);
 1027b68:	4601      	mov	r1, r0
 1027b6a:	4630      	mov	r0, r6
 1027b6c:	f7f6 fad8 	bl	101e120 <net_buf_frag_add>
			len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
 1027b70:	4630      	mov	r0, r6
 1027b72:	f7ff fe8d 	bl	1027890 <net_buf_frags_len>
 1027b76:	f8b8 402e 	ldrh.w	r4, [r8, #46]	; 0x2e
 1027b7a:	f105 070c 	add.w	r7, r5, #12
 1027b7e:	1a24      	subs	r4, r4, r0
 1027b80:	4638      	mov	r0, r7
 1027b82:	f001 f8fd 	bl	1028d80 <net_buf_simple_tailroom>
 1027b86:	4284      	cmp	r4, r0
 1027b88:	d21a      	bcs.n	1027bc0 <att_chan_read+0xce>
 1027b8a:	4630      	mov	r0, r6
 1027b8c:	f7ff fe80 	bl	1027890 <net_buf_frags_len>
 1027b90:	f8b8 402e 	ldrh.w	r4, [r8, #46]	; 0x2e
 1027b94:	1a24      	subs	r4, r4, r0
		read = attr->read(conn, attr, frag->data + frag->len, len,
 1027b96:	68e9      	ldr	r1, [r5, #12]
 1027b98:	8a2a      	ldrh	r2, [r5, #16]
 1027b9a:	f8cd 9000 	str.w	r9, [sp]
 1027b9e:	f8db 7004 	ldr.w	r7, [fp, #4]
 1027ba2:	440a      	add	r2, r1
 1027ba4:	9803      	ldr	r0, [sp, #12]
 1027ba6:	4659      	mov	r1, fp
 1027ba8:	b2a3      	uxth	r3, r4
 1027baa:	47b8      	blx	r7
		if (read < 0) {
 1027bac:	1e07      	subs	r7, r0, #0
 1027bae:	da0c      	bge.n	1027bca <att_chan_read+0xd8>
				return total;
 1027bb0:	f1ba 0f00 	cmp.w	sl, #0
 1027bb4:	bf18      	it	ne
 1027bb6:	4657      	movne	r7, sl
}
 1027bb8:	4638      	mov	r0, r7
 1027bba:	b005      	add	sp, #20
 1027bbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1027bc0:	4638      	mov	r0, r7
 1027bc2:	f001 f8dd 	bl	1028d80 <net_buf_simple_tailroom>
 1027bc6:	4604      	mov	r4, r0
 1027bc8:	e7e5      	b.n	1027b96 <att_chan_read+0xa4>
		if (cb && !cb(frag, read, user_data)) {
 1027bca:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 1027bcc:	b993      	cbnz	r3, 1027bf4 <att_chan_read+0x102>
	return net_buf_simple_add(&buf->b, len);
 1027bce:	4639      	mov	r1, r7
 1027bd0:	f105 000c 	add.w	r0, r5, #12
 1027bd4:	f7f6 fb60 	bl	101e298 <net_buf_simple_add>
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
 1027bd8:	4630      	mov	r0, r6
 1027bda:	f7ff fe59 	bl	1027890 <net_buf_frags_len>
 1027bde:	f8b8 302e 	ldrh.w	r3, [r8, #46]	; 0x2e
		offset += read;
 1027be2:	44b9      	add	r9, r7
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
 1027be4:	4283      	cmp	r3, r0
		total += read;
 1027be6:	44ba      	add	sl, r7
		offset += read;
 1027be8:	fa1f f989 	uxth.w	r9, r9
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
 1027bec:	d9b5      	bls.n	1027b5a <att_chan_read+0x68>
 1027bee:	42a7      	cmp	r7, r4
 1027bf0:	d096      	beq.n	1027b20 <att_chan_read+0x2e>
 1027bf2:	e7b2      	b.n	1027b5a <att_chan_read+0x68>
		if (cb && !cb(frag, read, user_data)) {
 1027bf4:	4639      	mov	r1, r7
 1027bf6:	4628      	mov	r0, r5
 1027bf8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 1027bfa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 1027bfc:	4798      	blx	r3
 1027bfe:	2800      	cmp	r0, #0
 1027c00:	d1e5      	bne.n	1027bce <att_chan_read+0xdc>
 1027c02:	e7aa      	b.n	1027b5a <att_chan_read+0x68>
		return 0;
 1027c04:	2700      	movs	r7, #0
 1027c06:	e7d7      	b.n	1027bb8 <att_chan_read+0xc6>

01027c08 <sys_slist_find_and_remove.isra.0>:
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 1027c08:	2200      	movs	r2, #0
	return list->head;
 1027c0a:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 1027c0c:	b903      	cbnz	r3, 1027c10 <sys_slist_find_and_remove.isra.0+0x8>
 1027c0e:	4770      	bx	lr
 1027c10:	428b      	cmp	r3, r1
 1027c12:	d10f      	bne.n	1027c34 <sys_slist_find_and_remove.isra.0+0x2c>
	return node->next;
 1027c14:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
 1027c16:	b93a      	cbnz	r2, 1027c28 <sys_slist_find_and_remove.isra.0+0x20>
 1027c18:	6842      	ldr	r2, [r0, #4]
	list->head = node;
 1027c1a:	6003      	str	r3, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
 1027c1c:	4291      	cmp	r1, r2
 1027c1e:	d100      	bne.n	1027c22 <sys_slist_find_and_remove.isra.0+0x1a>
	list->tail = node;
 1027c20:	6043      	str	r3, [r0, #4]
	parent->next = child;
 1027c22:	2300      	movs	r3, #0
 1027c24:	600b      	str	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
 1027c26:	4770      	bx	lr
	parent->next = child;
 1027c28:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
 1027c2a:	6843      	ldr	r3, [r0, #4]
 1027c2c:	4299      	cmp	r1, r3
	list->tail = node;
 1027c2e:	bf08      	it	eq
 1027c30:	6042      	streq	r2, [r0, #4]
}
 1027c32:	e7f6      	b.n	1027c22 <sys_slist_find_and_remove.isra.0+0x1a>
	return node->next;
 1027c34:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 1027c36:	681b      	ldr	r3, [r3, #0]
 1027c38:	e7e8      	b.n	1027c0c <sys_slist_find_and_remove.isra.0+0x4>

01027c3a <att_exec_write_req>:
static uint8_t att_exec_write_req(struct bt_att_chan *chan, struct net_buf *buf)
 1027c3a:	2006      	movs	r0, #6
 1027c3c:	4770      	bx	lr

01027c3e <atomic_test_and_set_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
 1027c3e:	2301      	movs	r3, #1
{
 1027c40:	b510      	push	{r4, lr}
	atomic_val_t mask = ATOMIC_MASK(bit);
 1027c42:	fa03 f101 	lsl.w	r1, r3, r1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1027c46:	e8d0 3fef 	ldaex	r3, [r0]
 1027c4a:	ea43 0201 	orr.w	r2, r3, r1
 1027c4e:	e8c0 2fe4 	stlex	r4, r2, [r0]
 1027c52:	2c00      	cmp	r4, #0
 1027c54:	d1f7      	bne.n	1027c46 <atomic_test_and_set_bit+0x8>
	return (old & mask) != 0;
 1027c56:	4219      	tst	r1, r3
}
 1027c58:	bf14      	ite	ne
 1027c5a:	2001      	movne	r0, #1
 1027c5c:	2000      	moveq	r0, #0
 1027c5e:	bd10      	pop	{r4, pc}

01027c60 <read_cb>:
{
 1027c60:	b573      	push	{r0, r1, r4, r5, r6, lr}
	data->err = 0x00;
 1027c62:	2300      	movs	r3, #0
{
 1027c64:	4605      	mov	r5, r0
	struct bt_att_chan *chan = data->chan;
 1027c66:	6816      	ldr	r6, [r2, #0]
{
 1027c68:	4614      	mov	r4, r2
	struct bt_conn *conn = chan->chan.chan.conn;
 1027c6a:	68b0      	ldr	r0, [r6, #8]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
 1027c6c:	4629      	mov	r1, r5
	data->err = 0x00;
 1027c6e:	7313      	strb	r3, [r2, #12]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
 1027c70:	2295      	movs	r2, #149	; 0x95
 1027c72:	f000 fc91 	bl	1028598 <bt_gatt_check_perm>
 1027c76:	7320      	strb	r0, [r4, #12]
	if (data->err) {
 1027c78:	b980      	cbnz	r0, 1027c9c <read_cb+0x3c>
	ret = att_chan_read(chan, attr, data->buf, data->offset, NULL, NULL);
 1027c7a:	e9cd 0000 	strd	r0, r0, [sp]
 1027c7e:	4629      	mov	r1, r5
 1027c80:	4630      	mov	r0, r6
 1027c82:	88a3      	ldrh	r3, [r4, #4]
 1027c84:	68a2      	ldr	r2, [r4, #8]
 1027c86:	f7ff ff34 	bl	1027af2 <att_chan_read>
	if (ret < 0) {
 1027c8a:	2800      	cmp	r0, #0
 1027c8c:	da09      	bge.n	1027ca2 <read_cb+0x42>
	if (err < 0 && err >= -0xff) {
 1027c8e:	f110 0fff 	cmn.w	r0, #255	; 0xff
	return BT_ATT_ERR_UNLIKELY;
 1027c92:	bf32      	itee	cc
 1027c94:	200e      	movcc	r0, #14
		return -err;
 1027c96:	4240      	negcs	r0, r0
 1027c98:	b2c0      	uxtbcs	r0, r0
		data->err = err_to_att(ret);
 1027c9a:	7320      	strb	r0, [r4, #12]
		return BT_GATT_ITER_STOP;
 1027c9c:	2000      	movs	r0, #0
}
 1027c9e:	b002      	add	sp, #8
 1027ca0:	bd70      	pop	{r4, r5, r6, pc}
	return BT_GATT_ITER_CONTINUE;
 1027ca2:	2001      	movs	r0, #1
 1027ca4:	e7fb      	b.n	1027c9e <read_cb+0x3e>

01027ca6 <read_vl_cb>:
{
 1027ca6:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	data->err = 0x00;
 1027caa:	2300      	movs	r3, #0
{
 1027cac:	4606      	mov	r6, r0
	struct bt_att_chan *chan = data->chan;
 1027cae:	f8d2 8000 	ldr.w	r8, [r2]
{
 1027cb2:	4614      	mov	r4, r2
	struct bt_conn *conn = chan->chan.chan.conn;
 1027cb4:	f8d8 0008 	ldr.w	r0, [r8, #8]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
 1027cb8:	4631      	mov	r1, r6
	data->err = 0x00;
 1027cba:	7313      	strb	r3, [r2, #12]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
 1027cbc:	2295      	movs	r2, #149	; 0x95
 1027cbe:	f000 fc6b 	bl	1028598 <bt_gatt_check_perm>
 1027cc2:	4605      	mov	r5, r0
 1027cc4:	7320      	strb	r0, [r4, #12]
	if (data->err) {
 1027cc6:	b9e0      	cbnz	r0, 1027d02 <read_vl_cb+0x5c>
	if (chan->chan.tx.mtu - data->buf->len < 2) {
 1027cc8:	68a0      	ldr	r0, [r4, #8]
 1027cca:	f8b8 302e 	ldrh.w	r3, [r8, #46]	; 0x2e
 1027cce:	8a02      	ldrh	r2, [r0, #16]
 1027cd0:	1a9b      	subs	r3, r3, r2
 1027cd2:	2b01      	cmp	r3, #1
 1027cd4:	dd15      	ble.n	1027d02 <read_vl_cb+0x5c>
 1027cd6:	2102      	movs	r1, #2
 1027cd8:	300c      	adds	r0, #12
 1027cda:	f7f6 fadd 	bl	101e298 <net_buf_simple_add>
	read = att_chan_read(chan, attr, data->buf, data->offset, NULL, NULL);
 1027cde:	e9cd 5500 	strd	r5, r5, [sp]
 1027ce2:	4607      	mov	r7, r0
 1027ce4:	88a3      	ldrh	r3, [r4, #4]
 1027ce6:	4631      	mov	r1, r6
 1027ce8:	4640      	mov	r0, r8
 1027cea:	68a2      	ldr	r2, [r4, #8]
 1027cec:	f7ff ff01 	bl	1027af2 <att_chan_read>
	if (read < 0) {
 1027cf0:	1e03      	subs	r3, r0, #0
 1027cf2:	da0a      	bge.n	1027d0a <read_vl_cb+0x64>
	if (err < 0 && err >= -0xff) {
 1027cf4:	f113 0fff 	cmn.w	r3, #255	; 0xff
	return BT_ATT_ERR_UNLIKELY;
 1027cf8:	bf32      	itee	cc
 1027cfa:	230e      	movcc	r3, #14
		return -err;
 1027cfc:	425b      	negcs	r3, r3
 1027cfe:	b2db      	uxtbcs	r3, r3
		data->err = err_to_att(read);
 1027d00:	7323      	strb	r3, [r4, #12]
		return BT_GATT_ITER_STOP;
 1027d02:	2000      	movs	r0, #0
}
 1027d04:	b002      	add	sp, #8
 1027d06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return BT_GATT_ITER_CONTINUE;
 1027d0a:	2001      	movs	r0, #1
	rsp->len = read;
 1027d0c:	803b      	strh	r3, [r7, #0]
	return BT_GATT_ITER_CONTINUE;
 1027d0e:	e7f9      	b.n	1027d04 <read_vl_cb+0x5e>

01027d10 <bt_att_sent>:
{
 1027d10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1027d12:	4605      	mov	r5, r0
	struct bt_att *att = chan->att;
 1027d14:	f850 4c08 	ldr.w	r4, [r0, #-8]
	struct bt_att_chan *chan = ATT_CHAN(ch);
 1027d18:	f1a0 0708 	sub.w	r7, r0, #8
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1027d1c:	f100 03f8 	add.w	r3, r0, #248	; 0xf8
 1027d20:	e8d3 1fef 	ldaex	r1, [r3]
 1027d24:	f021 0110 	bic.w	r1, r1, #16
 1027d28:	e8c3 1fe2 	stlex	r2, r1, [r3]
 1027d2c:	2a00      	cmp	r2, #0
 1027d2e:	d1f7      	bne.n	1027d20 <bt_att_sent+0x10>
	if (!att) {
 1027d30:	b30c      	cbz	r4, 1027d76 <bt_att_sent+0x66>
	if (!chan->req && !sys_slist_is_empty(&att->reqs)) {
 1027d32:	f8d5 30fc 	ldr.w	r3, [r5, #252]	; 0xfc
 1027d36:	b98b      	cbnz	r3, 1027d5c <bt_att_sent+0x4c>
 1027d38:	6863      	ldr	r3, [r4, #4]
 1027d3a:	b17b      	cbz	r3, 1027d5c <bt_att_sent+0x4c>
		sys_snode_t *node = sys_slist_get(&att->reqs);
 1027d3c:	1d20      	adds	r0, r4, #4
 1027d3e:	f7ff fd9d 	bl	102787c <sys_slist_get>
		if (chan_req_send(chan, ATT_REQ(node)) >= 0) {
 1027d42:	4601      	mov	r1, r0
		sys_snode_t *node = sys_slist_get(&att->reqs);
 1027d44:	4606      	mov	r6, r0
		if (chan_req_send(chan, ATT_REQ(node)) >= 0) {
 1027d46:	4638      	mov	r0, r7
 1027d48:	f7ff fe92 	bl	1027a70 <chan_req_send>
 1027d4c:	2800      	cmp	r0, #0
 1027d4e:	da12      	bge.n	1027d76 <bt_att_sent+0x66>
	return list->head;
 1027d50:	6863      	ldr	r3, [r4, #4]
	parent->next = child;
 1027d52:	6033      	str	r3, [r6, #0]
Z_GENLIST_PREPEND(slist, snode)
 1027d54:	68a3      	ldr	r3, [r4, #8]
	list->head = node;
 1027d56:	6066      	str	r6, [r4, #4]
Z_GENLIST_PREPEND(slist, snode)
 1027d58:	b903      	cbnz	r3, 1027d5c <bt_att_sent+0x4c>
	list->tail = node;
 1027d5a:	60a6      	str	r6, [r4, #8]
	err = process_queue(chan, &chan->tx_queue);
 1027d5c:	4638      	mov	r0, r7
 1027d5e:	f505 7180 	add.w	r1, r5, #256	; 0x100
 1027d62:	f7ff fe9f 	bl	1027aa4 <process_queue>
	if (!err) {
 1027d66:	b130      	cbz	r0, 1027d76 <bt_att_sent+0x66>
	(void)process_queue(chan, &att->tx_queue);
 1027d68:	4638      	mov	r0, r7
 1027d6a:	f104 010c 	add.w	r1, r4, #12
}
 1027d6e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	(void)process_queue(chan, &att->tx_queue);
 1027d72:	f7ff be97 	b.w	1027aa4 <process_queue>
}
 1027d76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

01027d78 <att_req_send_process>:
{
 1027d78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return list->head;
 1027d7c:	6a83      	ldr	r3, [r0, #40]	; 0x28
 1027d7e:	4605      	mov	r5, r0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 1027d80:	2b00      	cmp	r3, #0
 1027d82:	d03a      	beq.n	1027dfa <att_req_send_process+0x82>
	return node->next;
 1027d84:	681e      	ldr	r6, [r3, #0]
 1027d86:	f5a3 77ac 	sub.w	r7, r3, #344	; 0x158
 1027d8a:	b10e      	cbz	r6, 1027d90 <att_req_send_process+0x18>
 1027d8c:	f5a6 76ac 	sub.w	r6, r6, #344	; 0x158
{
 1027d90:	2300      	movs	r3, #0
		req = get_first_req_matching_chan(&att->reqs, chan);
 1027d92:	f105 0804 	add.w	r8, r5, #4
{
 1027d96:	461c      	mov	r4, r3
 1027d98:	e014      	b.n	1027dc4 <att_req_send_process+0x4c>
		if (!req && prev &&
 1027d9a:	b1cb      	cbz	r3, 1027dd0 <att_req_send_process+0x58>
		    (atomic_test_bit(chan->flags, ATT_ENHANCED) ==
 1027d9c:	2103      	movs	r1, #3
 1027d9e:	f507 7080 	add.w	r0, r7, #256	; 0x100
 1027da2:	f7ff fd8f 	bl	10278c4 <atomic_test_bit>
 1027da6:	4602      	mov	r2, r0
		     atomic_test_bit(prev->flags, ATT_ENHANCED))) {
 1027da8:	f503 7080 	add.w	r0, r3, #256	; 0x100
 1027dac:	f7ff fd8a 	bl	10278c4 <atomic_test_bit>
		if (!req && prev &&
 1027db0:	4282      	cmp	r2, r0
 1027db2:	d10d      	bne.n	1027dd0 <att_req_send_process+0x58>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 1027db4:	b30e      	cbz	r6, 1027dfa <att_req_send_process+0x82>
 1027db6:	f8d6 2158 	ldr.w	r2, [r6, #344]	; 0x158
 1027dba:	b10a      	cbz	r2, 1027dc0 <att_req_send_process+0x48>
 1027dbc:	f5a2 72ac 	sub.w	r2, r2, #344	; 0x158
{
 1027dc0:	4637      	mov	r7, r6
 1027dc2:	4616      	mov	r6, r2
		if (chan->req) {
 1027dc4:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 1027dc8:	2a00      	cmp	r2, #0
 1027dca:	d1f3      	bne.n	1027db4 <att_req_send_process+0x3c>
		if (!req && prev &&
 1027dcc:	2c00      	cmp	r4, #0
 1027dce:	d0e4      	beq.n	1027d9a <att_req_send_process+0x22>
	sys_snode_t *node = sys_slist_get(reqs);
 1027dd0:	4640      	mov	r0, r8
 1027dd2:	f7ff fd53 	bl	102787c <sys_slist_get>
	if (node) {
 1027dd6:	4604      	mov	r4, r0
 1027dd8:	b908      	cbnz	r0, 1027dde <att_req_send_process+0x66>
 1027dda:	463b      	mov	r3, r7
 1027ddc:	e7ea      	b.n	1027db4 <att_req_send_process+0x3c>
		if (bt_att_chan_req_send(chan, req) >= 0) {
 1027dde:	4601      	mov	r1, r0
 1027de0:	4638      	mov	r0, r7
 1027de2:	f7e4 f81f 	bl	100be24 <bt_att_chan_req_send>
 1027de6:	2800      	cmp	r0, #0
 1027de8:	da07      	bge.n	1027dfa <att_req_send_process+0x82>
	return list->head;
 1027dea:	686b      	ldr	r3, [r5, #4]
	parent->next = child;
 1027dec:	6023      	str	r3, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
 1027dee:	68ab      	ldr	r3, [r5, #8]
	list->head = node;
 1027df0:	606c      	str	r4, [r5, #4]
Z_GENLIST_PREPEND(slist, snode)
 1027df2:	2b00      	cmp	r3, #0
 1027df4:	d1f1      	bne.n	1027dda <att_req_send_process+0x62>
	list->tail = node;
 1027df6:	60ac      	str	r4, [r5, #8]
}
 1027df8:	e7ef      	b.n	1027dda <att_req_send_process+0x62>
}
 1027dfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

01027dfe <bt_att_status>:
{
 1027dfe:	b538      	push	{r3, r4, r5, lr}
 1027e00:	4605      	mov	r5, r0
 1027e02:	4608      	mov	r0, r1
	if (!atomic_test_bit(status, BT_L2CAP_STATUS_OUT)) {
 1027e04:	2100      	movs	r1, #0
 1027e06:	f7ff fd5d 	bl	10278c4 <atomic_test_bit>
 1027e0a:	b1c8      	cbz	r0, 1027e40 <bt_att_status+0x42>
	if (!chan->att) {
 1027e0c:	f855 0c08 	ldr.w	r0, [r5, #-8]
 1027e10:	b1b0      	cbz	r0, 1027e40 <bt_att_status+0x42>
	if (chan->req) {
 1027e12:	f8d5 30fc 	ldr.w	r3, [r5, #252]	; 0xfc
 1027e16:	b99b      	cbnz	r3, 1027e40 <bt_att_status+0x42>
	node = sys_slist_get(&chan->att->reqs);
 1027e18:	3004      	adds	r0, #4
 1027e1a:	f7ff fd2f 	bl	102787c <sys_slist_get>
	if (!node) {
 1027e1e:	4604      	mov	r4, r0
 1027e20:	b170      	cbz	r0, 1027e40 <bt_att_status+0x42>
	if (bt_att_chan_req_send(chan, ATT_REQ(node)) >= 0) {
 1027e22:	4601      	mov	r1, r0
 1027e24:	f1a5 0008 	sub.w	r0, r5, #8
 1027e28:	f7e3 fffc 	bl	100be24 <bt_att_chan_req_send>
 1027e2c:	2800      	cmp	r0, #0
 1027e2e:	da07      	bge.n	1027e40 <bt_att_status+0x42>
	sys_slist_prepend(&chan->att->reqs, node);
 1027e30:	f855 3c08 	ldr.w	r3, [r5, #-8]
	return list->head;
 1027e34:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
 1027e36:	6022      	str	r2, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
 1027e38:	689a      	ldr	r2, [r3, #8]
	list->head = node;
 1027e3a:	605c      	str	r4, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
 1027e3c:	b902      	cbnz	r2, 1027e40 <bt_att_status+0x42>
	list->tail = node;
 1027e3e:	609c      	str	r4, [r3, #8]
}
 1027e40:	bd38      	pop	{r3, r4, r5, pc}

01027e42 <att_sent>:
	struct bt_att_chan *att_chan = data->att_chan;
 1027e42:	6808      	ldr	r0, [r1, #0]
	if (chan->ops->sent) {
 1027e44:	68c3      	ldr	r3, [r0, #12]
 1027e46:	699b      	ldr	r3, [r3, #24]
 1027e48:	b10b      	cbz	r3, 1027e4e <att_sent+0xc>
		chan->ops->sent(chan);
 1027e4a:	3008      	adds	r0, #8
 1027e4c:	4718      	bx	r3
}
 1027e4e:	4770      	bx	lr

01027e50 <att_tx_complete>:
{
 1027e50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1027e54:	4606      	mov	r6, r0
 1027e56:	460d      	mov	r5, r1
	if (!err) {
 1027e58:	4614      	mov	r4, r2
 1027e5a:	b122      	cbz	r2, 1027e66 <att_tx_complete+0x16>
}
 1027e5c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	tx_meta_data_free(data);
 1027e60:	4608      	mov	r0, r1
 1027e62:	f7e3 be8b 	b.w	100bb7c <tx_meta_data_free>
		att_sent(conn, user_data);
 1027e66:	f7ff ffec 	bl	1027e42 <att_sent>
	bt_gatt_complete_func_t func = data->func;
 1027e6a:	68af      	ldr	r7, [r5, #8]
	tx_meta_data_free(data);
 1027e6c:	4628      	mov	r0, r5
	uint16_t attr_count = data->attr_count;
 1027e6e:	f8b5 8004 	ldrh.w	r8, [r5, #4]
	void *ud = data->user_data;
 1027e72:	f8d5 900c 	ldr.w	r9, [r5, #12]
	tx_meta_data_free(data);
 1027e76:	f7e3 fe81 	bl	100bb7c <tx_meta_data_free>
	if (!err && func) {
 1027e7a:	b92f      	cbnz	r7, 1027e88 <att_tx_complete+0x38>
}
 1027e7c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			func(conn, ud);
 1027e80:	4649      	mov	r1, r9
 1027e82:	4630      	mov	r0, r6
 1027e84:	47b8      	blx	r7
		for (uint16_t i = 0; i < attr_count; i++) {
 1027e86:	3401      	adds	r4, #1
 1027e88:	b2a3      	uxth	r3, r4
 1027e8a:	4543      	cmp	r3, r8
 1027e8c:	d3f8      	bcc.n	1027e80 <att_tx_complete+0x30>
 1027e8e:	e7f5      	b.n	1027e7c <att_tx_complete+0x2c>

01027e90 <att_req_sent>:
{
 1027e90:	b510      	push	{r4, lr}
 1027e92:	460c      	mov	r4, r1
	if (!err) {
 1027e94:	b90a      	cbnz	r2, 1027e9a <att_req_sent+0xa>
		att_sent(conn, user_data);
 1027e96:	f7ff ffd4 	bl	1027e42 <att_sent>
	struct bt_att_chan *chan = data->att_chan;
 1027e9a:	6820      	ldr	r0, [r4, #0]
	if (chan->req) {
 1027e9c:	f8d0 3104 	ldr.w	r3, [r0, #260]	; 0x104
 1027ea0:	b133      	cbz	r3, 1027eb0 <att_req_sent+0x20>
		k_work_reschedule(&chan->timeout_work, BT_ATT_TIMEOUT);
 1027ea2:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
 1027ea6:	2300      	movs	r3, #0
 1027ea8:	f500 7094 	add.w	r0, r0, #296	; 0x128
 1027eac:	f7fa f94a 	bl	1022144 <k_work_reschedule>
	tx_meta_data_free(user_data);
 1027eb0:	4620      	mov	r0, r4
}
 1027eb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	tx_meta_data_free(user_data);
 1027eb6:	f7e3 be61 	b.w	100bb7c <tx_meta_data_free>

01027eba <att_cfm_sent>:
{
 1027eba:	b510      	push	{r4, lr}
 1027ebc:	460c      	mov	r4, r1
	if (!err) {
 1027ebe:	b90a      	cbnz	r2, 1027ec4 <att_cfm_sent+0xa>
		att_sent(conn, user_data);
 1027ec0:	f7ff ffbf 	bl	1027e42 <att_sent>
 1027ec4:	6823      	ldr	r3, [r4, #0]
 1027ec6:	f503 7380 	add.w	r3, r3, #256	; 0x100
 1027eca:	e8d3 1fef 	ldaex	r1, [r3]
 1027ece:	f021 0102 	bic.w	r1, r1, #2
 1027ed2:	e8c3 1fe2 	stlex	r2, r1, [r3]
 1027ed6:	2a00      	cmp	r2, #0
 1027ed8:	d1f7      	bne.n	1027eca <att_cfm_sent+0x10>
	tx_meta_data_free(data);
 1027eda:	4620      	mov	r0, r4
}
 1027edc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	tx_meta_data_free(data);
 1027ee0:	f7e3 be4c 	b.w	100bb7c <tx_meta_data_free>

01027ee4 <att_rsp_sent>:
{
 1027ee4:	b510      	push	{r4, lr}
 1027ee6:	460c      	mov	r4, r1
	if (!err) {
 1027ee8:	b90a      	cbnz	r2, 1027eee <att_rsp_sent+0xa>
		att_sent(conn, user_data);
 1027eea:	f7ff ffaa 	bl	1027e42 <att_sent>
 1027eee:	6823      	ldr	r3, [r4, #0]
 1027ef0:	f503 7380 	add.w	r3, r3, #256	; 0x100
 1027ef4:	e8d3 1fef 	ldaex	r1, [r3]
 1027ef8:	f021 0101 	bic.w	r1, r1, #1
 1027efc:	e8c3 1fe2 	stlex	r2, r1, [r3]
 1027f00:	2a00      	cmp	r2, #0
 1027f02:	d1f7      	bne.n	1027ef4 <att_rsp_sent+0x10>
	tx_meta_data_free(data);
 1027f04:	4620      	mov	r0, r4
}
 1027f06:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	tx_meta_data_free(data);
 1027f0a:	f7e3 be37 	b.w	100bb7c <tx_meta_data_free>

01027f0e <send_err_rsp.part.0>:
static void send_err_rsp(struct bt_att_chan *chan, uint8_t req, uint16_t handle,
 1027f0e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1027f12:	4688      	mov	r8, r1
 1027f14:	4617      	mov	r7, r2
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
 1027f16:	2101      	movs	r1, #1
 1027f18:	2204      	movs	r2, #4
static void send_err_rsp(struct bt_att_chan *chan, uint8_t req, uint16_t handle,
 1027f1a:	4605      	mov	r5, r0
 1027f1c:	461e      	mov	r6, r3
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
 1027f1e:	f7e4 f959 	bl	100c1d4 <bt_att_chan_create_pdu>
	if (!buf) {
 1027f22:	4604      	mov	r4, r0
 1027f24:	b170      	cbz	r0, 1027f44 <send_err_rsp.part.0+0x36>
 1027f26:	2104      	movs	r1, #4
 1027f28:	300c      	adds	r0, #12
 1027f2a:	f7f6 f9b5 	bl	101e298 <net_buf_simple_add>
	rsp->request = req;
 1027f2e:	f880 8000 	strb.w	r8, [r0]
	rsp->handle = sys_cpu_to_le16(handle);
 1027f32:	f8a0 7001 	strh.w	r7, [r0, #1]
	rsp->error = err;
 1027f36:	70c6      	strb	r6, [r0, #3]
	bt_att_chan_send_rsp(chan, buf);
 1027f38:	4621      	mov	r1, r4
 1027f3a:	4628      	mov	r0, r5
}
 1027f3c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	bt_att_chan_send_rsp(chan, buf);
 1027f40:	f7ff bdc9 	b.w	1027ad6 <bt_att_chan_send_rsp>
}
 1027f44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

01027f48 <att_write_req>:
{
 1027f48:	b537      	push	{r0, r1, r2, r4, r5, lr}
 1027f4a:	460c      	mov	r4, r1
 1027f4c:	4605      	mov	r5, r0
	return net_buf_simple_pull_le16(&buf->b);
 1027f4e:	f101 000c 	add.w	r0, r1, #12
 1027f52:	f000 ff09 	bl	1028d68 <net_buf_simple_pull_le16>
	return att_write_rsp(chan, BT_ATT_OP_WRITE_REQ, BT_ATT_OP_WRITE_RSP,
 1027f56:	8a22      	ldrh	r2, [r4, #16]
 1027f58:	4603      	mov	r3, r0
 1027f5a:	9201      	str	r2, [sp, #4]
 1027f5c:	68e2      	ldr	r2, [r4, #12]
 1027f5e:	2112      	movs	r1, #18
 1027f60:	9200      	str	r2, [sp, #0]
 1027f62:	4628      	mov	r0, r5
 1027f64:	2213      	movs	r2, #19
 1027f66:	f7e4 fa4f 	bl	100c408 <att_write_rsp.constprop.0>
}
 1027f6a:	b003      	add	sp, #12
 1027f6c:	bd30      	pop	{r4, r5, pc}

01027f6e <att_write_cmd>:
{
 1027f6e:	b537      	push	{r0, r1, r2, r4, r5, lr}
 1027f70:	460c      	mov	r4, r1
 1027f72:	4605      	mov	r5, r0
 1027f74:	f101 000c 	add.w	r0, r1, #12
 1027f78:	f000 fef6 	bl	1028d68 <net_buf_simple_pull_le16>
	return att_write_rsp(chan, 0, 0, handle, 0, buf->data, buf->len);
 1027f7c:	8a22      	ldrh	r2, [r4, #16]
 1027f7e:	4603      	mov	r3, r0
 1027f80:	9201      	str	r2, [sp, #4]
 1027f82:	68e2      	ldr	r2, [r4, #12]
 1027f84:	4628      	mov	r0, r5
 1027f86:	9200      	str	r2, [sp, #0]
 1027f88:	2200      	movs	r2, #0
 1027f8a:	4611      	mov	r1, r2
 1027f8c:	f7e4 fa3c 	bl	100c408 <att_write_rsp.constprop.0>
}
 1027f90:	b003      	add	sp, #12
 1027f92:	bd30      	pop	{r4, r5, pc}

01027f94 <att_read_blob_req>:
{
 1027f94:	b507      	push	{r0, r1, r2, lr}
	req = (void *)buf->data;
 1027f96:	68ca      	ldr	r2, [r1, #12]
	return att_read_rsp(chan, BT_ATT_OP_READ_BLOB_REQ,
 1027f98:	210c      	movs	r1, #12
 1027f9a:	8813      	ldrh	r3, [r2, #0]
 1027f9c:	8852      	ldrh	r2, [r2, #2]
 1027f9e:	9200      	str	r2, [sp, #0]
 1027fa0:	220d      	movs	r2, #13
 1027fa2:	f7e4 fbf9 	bl	100c798 <att_read_rsp>
}
 1027fa6:	b003      	add	sp, #12
 1027fa8:	f85d fb04 	ldr.w	pc, [sp], #4

01027fac <att_read_req>:
{
 1027fac:	b507      	push	{r0, r1, r2, lr}
	return att_read_rsp(chan, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
 1027fae:	2200      	movs	r2, #0
	handle = sys_le16_to_cpu(req->handle);
 1027fb0:	68cb      	ldr	r3, [r1, #12]
	return att_read_rsp(chan, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
 1027fb2:	210a      	movs	r1, #10
 1027fb4:	881b      	ldrh	r3, [r3, #0]
 1027fb6:	9200      	str	r2, [sp, #0]
 1027fb8:	220b      	movs	r2, #11
 1027fba:	f7e4 fbed 	bl	100c798 <att_read_rsp>
}
 1027fbe:	b003      	add	sp, #12
 1027fc0:	f85d fb04 	ldr.w	pc, [sp], #4

01027fc4 <att_mtu_req>:
{
 1027fc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_conn *conn = chan->att->conn;
 1027fc6:	6802      	ldr	r2, [r0, #0]
{
 1027fc8:	4605      	mov	r5, r0
 1027fca:	460b      	mov	r3, r1
	if (atomic_test_bit(chan->flags, ATT_ENHANCED)) {
 1027fcc:	f500 7080 	add.w	r0, r0, #256	; 0x100
 1027fd0:	2103      	movs	r1, #3
	struct bt_conn *conn = chan->att->conn;
 1027fd2:	6817      	ldr	r7, [r2, #0]
	if (atomic_test_bit(chan->flags, ATT_ENHANCED)) {
 1027fd4:	f7ff fc76 	bl	10278c4 <atomic_test_bit>
 1027fd8:	4604      	mov	r4, r0
 1027fda:	bb10      	cbnz	r0, 1028022 <att_mtu_req+0x5e>
	mtu_client = sys_le16_to_cpu(req->mtu);
 1027fdc:	68db      	ldr	r3, [r3, #12]
 1027fde:	881e      	ldrh	r6, [r3, #0]
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
 1027fe0:	2e16      	cmp	r6, #22
 1027fe2:	d920      	bls.n	1028026 <att_mtu_req+0x62>
	pdu = bt_att_create_pdu(conn, BT_ATT_OP_MTU_RSP, sizeof(*rsp));
 1027fe4:	4638      	mov	r0, r7
 1027fe6:	2202      	movs	r2, #2
 1027fe8:	f7e4 fa72 	bl	100c4d0 <bt_att_create_pdu>
	if (!pdu) {
 1027fec:	4607      	mov	r7, r0
 1027fee:	b1e0      	cbz	r0, 102802a <att_mtu_req+0x66>
	return net_buf_simple_add(&buf->b, len);
 1027ff0:	2102      	movs	r1, #2
 1027ff2:	300c      	adds	r0, #12
 1027ff4:	f7f6 f950 	bl	101e298 <net_buf_simple_add>
	rsp->mtu = sys_cpu_to_le16(mtu_server);
 1027ff8:	f06f 0313 	mvn.w	r3, #19
 1027ffc:	7003      	strb	r3, [r0, #0]
 1027ffe:	2301      	movs	r3, #1
	bt_att_chan_send_rsp(chan, pdu);
 1028000:	4639      	mov	r1, r7
	rsp->mtu = sys_cpu_to_le16(mtu_server);
 1028002:	7043      	strb	r3, [r0, #1]
	bt_att_chan_send_rsp(chan, pdu);
 1028004:	4628      	mov	r0, r5
 1028006:	f7ff fd66 	bl	1027ad6 <bt_att_chan_send_rsp>
	chan->chan.rx.mtu = MIN(mtu_client, mtu_server);
 102800a:	f5b6 7ff6 	cmp.w	r6, #492	; 0x1ec
 102800e:	bf28      	it	cs
 1028010:	f44f 76f6 	movcs.w	r6, #492	; 0x1ec
	att_chan_mtu_updated(chan);
 1028014:	4628      	mov	r0, r5
	chan->chan.rx.mtu = MIN(mtu_client, mtu_server);
 1028016:	83ee      	strh	r6, [r5, #30]
	chan->chan.tx.mtu = chan->chan.rx.mtu;
 1028018:	85ee      	strh	r6, [r5, #46]	; 0x2e
	att_chan_mtu_updated(chan);
 102801a:	f7ff fce1 	bl	10279e0 <att_chan_mtu_updated>
	return 0;
 102801e:	4620      	mov	r0, r4
}
 1028020:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_ATT_ERR_NOT_SUPPORTED;
 1028022:	2006      	movs	r0, #6
 1028024:	e7fc      	b.n	1028020 <att_mtu_req+0x5c>
		return BT_ATT_ERR_INVALID_PDU;
 1028026:	2004      	movs	r0, #4
 1028028:	e7fa      	b.n	1028020 <att_mtu_req+0x5c>
		return BT_ATT_ERR_UNLIKELY;
 102802a:	200e      	movs	r0, #14
 102802c:	e7f8      	b.n	1028020 <att_mtu_req+0x5c>

0102802e <bt_att_get_mtu>:
{
 102802e:	b508      	push	{r3, lr}
	att = att_get(conn);
 1028030:	f7e3 ff3a 	bl	100bea8 <att_get>
	if (!att) {
 1028034:	b148      	cbz	r0, 102804a <bt_att_get_mtu+0x1c>
	return list->head;
 1028036:	6a80      	ldr	r0, [r0, #40]	; 0x28
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 1028038:	b138      	cbz	r0, 102804a <bt_att_get_mtu+0x1c>
	return node->next;
 102803a:	6803      	ldr	r3, [r0, #0]
 102803c:	b10b      	cbz	r3, 1028042 <bt_att_get_mtu+0x14>
 102803e:	f5a3 73ac 	sub.w	r3, r3, #344	; 0x158
		if (chan->chan.tx.mtu > mtu) {
 1028042:	f5a0 70ac 	sub.w	r0, r0, #344	; 0x158
 1028046:	8dc0      	ldrh	r0, [r0, #46]	; 0x2e
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 1028048:	b903      	cbnz	r3, 102804c <bt_att_get_mtu+0x1e>
}
 102804a:	bd08      	pop	{r3, pc}
 102804c:	f8d3 2158 	ldr.w	r2, [r3, #344]	; 0x158
 1028050:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 1028052:	4298      	cmp	r0, r3
 1028054:	bf38      	it	cc
 1028056:	4618      	movcc	r0, r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
 1028058:	2a00      	cmp	r2, #0
 102805a:	d0f6      	beq.n	102804a <bt_att_get_mtu+0x1c>
 102805c:	f5a2 73ac 	sub.w	r3, r2, #344	; 0x158
 1028060:	e7f4      	b.n	102804c <bt_att_get_mtu+0x1e>

01028062 <att_confirm>:
	return att_handle_rsp(chan, buf->data, buf->len, 0);
 1028062:	8a0a      	ldrh	r2, [r1, #16]
 1028064:	2300      	movs	r3, #0
 1028066:	68c9      	ldr	r1, [r1, #12]
 1028068:	f7e4 bd42 	b.w	100caf0 <att_handle_rsp>

0102806c <bt_att_encrypt_change>:
{
 102806c:	b570      	push	{r4, r5, r6, lr}
	struct bt_att_chan *att_chan = ATT_CHAN(chan);
 102806e:	4606      	mov	r6, r0
	if (!att_chan->att) {
 1028070:	f850 3c08 	ldr.w	r3, [r0, #-8]
{
 1028074:	4604      	mov	r4, r0
	struct bt_conn *conn = le_chan->chan.conn;
 1028076:	f856 5908 	ldr.w	r5, [r6], #-8
	if (!att_chan->att) {
 102807a:	2b00      	cmp	r3, #0
 102807c:	d038      	beq.n	10280f0 <bt_att_encrypt_change+0x84>
	if (hci_status) {
 102807e:	b141      	cbz	r1, 1028092 <bt_att_encrypt_change+0x26>
		if (att_chan->req && att_chan->req->retrying) {
 1028080:	f8d0 30fc 	ldr.w	r3, [r0, #252]	; 0xfc
 1028084:	2b00      	cmp	r3, #0
 1028086:	d033      	beq.n	10280f0 <bt_att_encrypt_change+0x84>
 1028088:	7c1b      	ldrb	r3, [r3, #16]
 102808a:	07da      	lsls	r2, r3, #31
 102808c:	d530      	bpl.n	10280f0 <bt_att_encrypt_change+0x84>
		return BT_ATT_ERR_AUTHENTICATION;
 102808e:	2305      	movs	r3, #5
 1028090:	e021      	b.n	10280d6 <bt_att_encrypt_change+0x6a>
	bt_gatt_encrypt_change(conn);
 1028092:	4628      	mov	r0, r5
 1028094:	f7e6 fcd0 	bl	100ea38 <bt_gatt_encrypt_change>
	if (conn->sec_level == BT_SECURITY_L1) {
 1028098:	7a6b      	ldrb	r3, [r5, #9]
 102809a:	2b01      	cmp	r3, #1
 102809c:	d028      	beq.n	10280f0 <bt_att_encrypt_change+0x84>
	if (!(att_chan->req && att_chan->req->retrying)) {
 102809e:	f8d4 50fc 	ldr.w	r5, [r4, #252]	; 0xfc
 10280a2:	b32d      	cbz	r5, 10280f0 <bt_att_encrypt_change+0x84>
 10280a4:	7c2b      	ldrb	r3, [r5, #16]
 10280a6:	07db      	lsls	r3, r3, #31
 10280a8:	d522      	bpl.n	10280f0 <bt_att_encrypt_change+0x84>
	if (!req->encode) {
 10280aa:	68eb      	ldr	r3, [r5, #12]
 10280ac:	2b00      	cmp	r3, #0
 10280ae:	d0ee      	beq.n	102808e <bt_att_encrypt_change+0x22>
	buf = bt_att_chan_create_pdu(att_chan, req->att_op, req->len);
 10280b0:	4630      	mov	r0, r6
 10280b2:	696a      	ldr	r2, [r5, #20]
 10280b4:	7c69      	ldrb	r1, [r5, #17]
 10280b6:	f7e4 f88d 	bl	100c1d4 <bt_att_chan_create_pdu>
	if (!buf) {
 10280ba:	4604      	mov	r4, r0
 10280bc:	b150      	cbz	r0, 10280d4 <bt_att_encrypt_change+0x68>
	if (req->encode(buf, req->len, req->user_data)) {
 10280be:	e9d5 1205 	ldrd	r1, r2, [r5, #20]
 10280c2:	68eb      	ldr	r3, [r5, #12]
 10280c4:	4798      	blx	r3
 10280c6:	b168      	cbz	r0, 10280e4 <bt_att_encrypt_change+0x78>
		tx_meta_data_free(bt_att_tx_meta_data(buf));
 10280c8:	69a0      	ldr	r0, [r4, #24]
 10280ca:	f7e3 fd57 	bl	100bb7c <tx_meta_data_free>
		net_buf_unref(buf);
 10280ce:	4620      	mov	r0, r4
 10280d0:	f7f5 ff86 	bl	101dfe0 <net_buf_unref>
		return BT_ATT_ERR_UNLIKELY;
 10280d4:	230e      	movs	r3, #14
		att_handle_rsp(att_chan, NULL, 0, err);
 10280d6:	2200      	movs	r2, #0
 10280d8:	4630      	mov	r0, r6
}
 10280da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		att_handle_rsp(att_chan, NULL, 0, err);
 10280de:	4611      	mov	r1, r2
 10280e0:	f7e4 bd06 	b.w	100caf0 <att_handle_rsp>
	if (chan_send(att_chan, buf)) {
 10280e4:	4621      	mov	r1, r4
 10280e6:	4630      	mov	r0, r6
 10280e8:	f7e3 fe28 	bl	100bd3c <chan_send>
 10280ec:	2800      	cmp	r0, #0
 10280ee:	d1eb      	bne.n	10280c8 <bt_att_encrypt_change+0x5c>
}
 10280f0:	bd70      	pop	{r4, r5, r6, pc}

010280f2 <bt_att_fixed_chan_only>:
#if defined(CONFIG_BT_EATT)
	return bt_eatt_count(conn) == 0;
#else
	return true;
#endif /* CONFIG_BT_EATT */
}
 10280f2:	2001      	movs	r0, #1
 10280f4:	4770      	bx	lr

010280f6 <bt_att_clear_out_of_sync_sent>:

void bt_att_clear_out_of_sync_sent(struct bt_conn *conn)
{
 10280f6:	b508      	push	{r3, lr}
	struct bt_att *att = att_get(conn);
 10280f8:	f7e3 fed6 	bl	100bea8 <att_get>
	struct bt_att_chan *chan;

	if (!att) {
 10280fc:	b180      	cbz	r0, 1028120 <bt_att_clear_out_of_sync_sent+0x2a>
	return list->head;
 10280fe:	6a83      	ldr	r3, [r0, #40]	; 0x28
		return;
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
 1028100:	b173      	cbz	r3, 1028120 <bt_att_clear_out_of_sync_sent+0x2a>
 1028102:	f5a3 73ac 	sub.w	r3, r3, #344	; 0x158
 1028106:	f503 7280 	add.w	r2, r3, #256	; 0x100
 102810a:	e8d2 0fef 	ldaex	r0, [r2]
 102810e:	f020 0020 	bic.w	r0, r0, #32
 1028112:	e8c2 0fe1 	stlex	r1, r0, [r2]
 1028116:	2900      	cmp	r1, #0
 1028118:	d1f7      	bne.n	102810a <bt_att_clear_out_of_sync_sent+0x14>
	return node->next;
 102811a:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
 102811e:	e7ef      	b.n	1028100 <bt_att_clear_out_of_sync_sent+0xa>
		atomic_clear_bit(chan->flags, ATT_OUT_OF_SYNC_SENT);
	}
}
 1028120:	bd08      	pop	{r3, pc}

01028122 <bt_att_out_of_sync_sent_on_fixed>:

bool bt_att_out_of_sync_sent_on_fixed(struct bt_conn *conn)
{
 1028122:	b508      	push	{r3, lr}
	struct bt_l2cap_chan *l2cap_chan;
	struct bt_att_chan *att_chan;

	l2cap_chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
 1028124:	2104      	movs	r1, #4
 1028126:	f7ff fb38 	bl	102779a <bt_l2cap_le_lookup_rx_cid>
	if (!l2cap_chan) {
 102812a:	b128      	cbz	r0, 1028138 <bt_att_out_of_sync_sent_on_fixed+0x16>
		return false;
	}

	att_chan = ATT_CHAN(l2cap_chan);
	return atomic_test_bit(att_chan->flags, ATT_OUT_OF_SYNC_SENT);
}
 102812c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return atomic_test_bit(att_chan->flags, ATT_OUT_OF_SYNC_SENT);
 1028130:	2105      	movs	r1, #5
 1028132:	30f8      	adds	r0, #248	; 0xf8
 1028134:	f7ff bbc6 	b.w	10278c4 <atomic_test_bit>
}
 1028138:	bd08      	pop	{r3, pc}

0102813a <bt_att_set_tx_meta_data>:

void bt_att_set_tx_meta_data(struct net_buf *buf, bt_gatt_complete_func_t func, void *user_data,
			     enum bt_att_chan_opt chan_opt)
{
	struct bt_att_tx_meta_data *data = bt_att_tx_meta_data(buf);
 102813a:	6980      	ldr	r0, [r0, #24]

	data->func = func;
	data->user_data = user_data;
 102813c:	e9c0 1202 	strd	r1, r2, [r0, #8]
	data->attr_count = 1;
 1028140:	2201      	movs	r2, #1
	data->chan_opt = chan_opt;
 1028142:	7403      	strb	r3, [r0, #16]
	data->attr_count = 1;
 1028144:	8082      	strh	r2, [r0, #4]
}
 1028146:	4770      	bx	lr

01028148 <found_attr>:
	*found = attr;
 1028148:	6010      	str	r0, [r2, #0]
}
 102814a:	2000      	movs	r0, #0
 102814c:	4770      	bx	lr

0102814e <gatt_ccc_changed>:
{
 102814e:	460b      	mov	r3, r1
 1028150:	460a      	mov	r2, r1
 1028152:	b430      	push	{r4, r5}
 1028154:	f101 0450 	add.w	r4, r1, #80	; 0x50
	uint16_t value = 0x0000;
 1028158:	2100      	movs	r1, #0
		if (ccc->cfg[i].value > value) {
 102815a:	8915      	ldrh	r5, [r2, #8]
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
 102815c:	320a      	adds	r2, #10
 102815e:	42a9      	cmp	r1, r5
 1028160:	bf38      	it	cc
 1028162:	4629      	movcc	r1, r5
 1028164:	42a2      	cmp	r2, r4
 1028166:	d1f8      	bne.n	102815a <gatt_ccc_changed+0xc>
	if (value != ccc->value) {
 1028168:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
 102816c:	428a      	cmp	r2, r1
 102816e:	d005      	beq.n	102817c <gatt_ccc_changed+0x2e>
		ccc->value = value;
 1028170:	f8a3 1050 	strh.w	r1, [r3, #80]	; 0x50
		if (ccc->cfg_changed) {
 1028174:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 1028176:	b10b      	cbz	r3, 102817c <gatt_ccc_changed+0x2e>
}
 1028178:	bc30      	pop	{r4, r5}
			ccc->cfg_changed(attr, value);
 102817a:	4718      	bx	r3
}
 102817c:	bc30      	pop	{r4, r5}
 102817e:	4770      	bx	lr

01028180 <gatt_indicate_rsp>:
{
 1028180:	b510      	push	{r4, lr}
 1028182:	9c02      	ldr	r4, [sp, #8]
 1028184:	460a      	mov	r2, r1
	if (params->func) {
 1028186:	68a3      	ldr	r3, [r4, #8]
 1028188:	b10b      	cbz	r3, 102818e <gatt_indicate_rsp+0xe>
		params->func(conn, params, err);
 102818a:	4621      	mov	r1, r4
 102818c:	4798      	blx	r3
	params->_ref--;
 102818e:	7da3      	ldrb	r3, [r4, #22]
	if (params->destroy && (params->_ref == 0)) {
 1028190:	68e2      	ldr	r2, [r4, #12]
	params->_ref--;
 1028192:	3b01      	subs	r3, #1
 1028194:	b2db      	uxtb	r3, r3
 1028196:	75a3      	strb	r3, [r4, #22]
	if (params->destroy && (params->_ref == 0)) {
 1028198:	b122      	cbz	r2, 10281a4 <gatt_indicate_rsp+0x24>
 102819a:	b91b      	cbnz	r3, 10281a4 <gatt_indicate_rsp+0x24>
		params->destroy(params);
 102819c:	4620      	mov	r0, r4
}
 102819e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		params->destroy(params);
 10281a2:	4710      	bx	r2
}
 10281a4:	bd10      	pop	{r4, pc}

010281a6 <match_uuid>:
	data->attr = attr;
 10281a6:	6010      	str	r0, [r2, #0]
	data->handle = handle;
 10281a8:	8091      	strh	r1, [r2, #4]
}
 10281aa:	2000      	movs	r0, #0
 10281ac:	4770      	bx	lr

010281ae <ccc_set_cb>:
}
 10281ae:	2000      	movs	r0, #0
 10281b0:	4770      	bx	lr

010281b2 <gen_hash_m>:
{
 10281b2:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (attr->uuid->type != BT_UUID_TYPE_16)
 10281b4:	6807      	ldr	r7, [r0, #0]
{
 10281b6:	4606      	mov	r6, r0
	if (attr->uuid->type != BT_UUID_TYPE_16)
 10281b8:	783d      	ldrb	r5, [r7, #0]
{
 10281ba:	4614      	mov	r4, r2
 10281bc:	b089      	sub	sp, #36	; 0x24
	if (attr->uuid->type != BT_UUID_TYPE_16)
 10281be:	b9dd      	cbnz	r5, 10281f8 <gen_hash_m+0x46>
	switch (u16->val) {
 10281c0:	887b      	ldrh	r3, [r7, #2]
 10281c2:	f5b3 5f24 	cmp.w	r3, #10496	; 0x2900
 10281c6:	d004      	beq.n	10281d2 <gen_hash_m+0x20>
 10281c8:	d810      	bhi.n	10281ec <gen_hash_m+0x3a>
 10281ca:	f5a3 5320 	sub.w	r3, r3, #10240	; 0x2800
 10281ce:	2b03      	cmp	r3, #3
 10281d0:	d812      	bhi.n	10281f8 <gen_hash_m+0x46>
		value = sys_cpu_to_le16(handle);
 10281d2:	f8ad 100a 	strh.w	r1, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
 10281d6:	2202      	movs	r2, #2
 10281d8:	4620      	mov	r0, r4
 10281da:	f10d 010a 	add.w	r1, sp, #10
 10281de:	f7fe fa2a 	bl	1026636 <tc_cmac_update>
 10281e2:	b968      	cbnz	r0, 1028200 <gen_hash_m+0x4e>
			return BT_GATT_ITER_STOP;
 10281e4:	f06f 0215 	mvn.w	r2, #21
			state->err = -EINVAL;
 10281e8:	65a2      	str	r2, [r4, #88]	; 0x58
 10281ea:	e006      	b.n	10281fa <gen_hash_m+0x48>
	switch (u16->val) {
 10281ec:	f503 4356 	add.w	r3, r3, #54784	; 0xd600
 10281f0:	33ff      	adds	r3, #255	; 0xff
 10281f2:	b29b      	uxth	r3, r3
 10281f4:	2b04      	cmp	r3, #4
 10281f6:	d91e      	bls.n	1028236 <gen_hash_m+0x84>
			return BT_GATT_ITER_STOP;
 10281f8:	2501      	movs	r5, #1
}
 10281fa:	4628      	mov	r0, r5
 10281fc:	b009      	add	sp, #36	; 0x24
 10281fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
		value = sys_cpu_to_le16(u16->val);
 1028200:	887b      	ldrh	r3, [r7, #2]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
 1028202:	2202      	movs	r2, #2
 1028204:	4620      	mov	r0, r4
 1028206:	f10d 010a 	add.w	r1, sp, #10
		value = sys_cpu_to_le16(u16->val);
 102820a:	f8ad 300a 	strh.w	r3, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
 102820e:	f7fe fa12 	bl	1026636 <tc_cmac_update>
 1028212:	2800      	cmp	r0, #0
 1028214:	d0e6      	beq.n	10281e4 <gen_hash_m+0x32>
		len = attr->read(NULL, attr, data, sizeof(data), 0);
 1028216:	2000      	movs	r0, #0
 1028218:	9000      	str	r0, [sp, #0]
 102821a:	aa03      	add	r2, sp, #12
 102821c:	2313      	movs	r3, #19
 102821e:	4631      	mov	r1, r6
 1028220:	6877      	ldr	r7, [r6, #4]
 1028222:	47b8      	blx	r7
		if (len < 0) {
 1028224:	1e02      	subs	r2, r0, #0
 1028226:	dbdf      	blt.n	10281e8 <gen_hash_m+0x36>
		if (tc_cmac_update(&state->state, data, len) ==
 1028228:	a903      	add	r1, sp, #12
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
 102822a:	4620      	mov	r0, r4
 102822c:	f7fe fa03 	bl	1026636 <tc_cmac_update>
 1028230:	2800      	cmp	r0, #0
 1028232:	d1e1      	bne.n	10281f8 <gen_hash_m+0x46>
 1028234:	e7d6      	b.n	10281e4 <gen_hash_m+0x32>
		value = sys_cpu_to_le16(handle);
 1028236:	f8ad 100a 	strh.w	r1, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
 102823a:	2202      	movs	r2, #2
 102823c:	4620      	mov	r0, r4
 102823e:	f10d 010a 	add.w	r1, sp, #10
 1028242:	f7fe f9f8 	bl	1026636 <tc_cmac_update>
 1028246:	2800      	cmp	r0, #0
 1028248:	d0cc      	beq.n	10281e4 <gen_hash_m+0x32>
		value = sys_cpu_to_le16(u16->val);
 102824a:	887b      	ldrh	r3, [r7, #2]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
 102824c:	2202      	movs	r2, #2
		value = sys_cpu_to_le16(u16->val);
 102824e:	f8ad 300a 	strh.w	r3, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
 1028252:	f10d 010a 	add.w	r1, sp, #10
 1028256:	e7e8      	b.n	102822a <gen_hash_m+0x78>

01028258 <bt_addr_le_eq>:
 1028258:	2207      	movs	r2, #7
{
 102825a:	b508      	push	{r3, lr}
	return memcmp(a, b, sizeof(*a));
 102825c:	f7fe fb7a 	bl	1026954 <memcmp>
}
 1028260:	fab0 f080 	clz	r0, r0
 1028264:	0940      	lsrs	r0, r0, #5
 1028266:	bd08      	pop	{r3, pc}

01028268 <ccc_find_cfg>:
{
 1028268:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 102826c:	4604      	mov	r4, r0
 102826e:	460f      	mov	r7, r1
 1028270:	4690      	mov	r8, r2
 1028272:	2500      	movs	r5, #0
 1028274:	1c46      	adds	r6, r0, #1
		if (id == ccc->cfg[i].id &&
 1028276:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 102827a:	4543      	cmp	r3, r8
 102827c:	d107      	bne.n	102828e <ccc_find_cfg+0x26>
		    bt_addr_le_eq(&ccc->cfg[i].peer, addr)) {
 102827e:	4639      	mov	r1, r7
 1028280:	4630      	mov	r0, r6
 1028282:	f7ff ffe9 	bl	1028258 <bt_addr_le_eq>
		if (id == ccc->cfg[i].id &&
 1028286:	b110      	cbz	r0, 102828e <ccc_find_cfg+0x26>
			return &ccc->cfg[i];
 1028288:	1960      	adds	r0, r4, r5
}
 102828a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (size_t i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
 102828e:	350a      	adds	r5, #10
 1028290:	2d50      	cmp	r5, #80	; 0x50
 1028292:	f106 060a 	add.w	r6, r6, #10
 1028296:	d1ee      	bne.n	1028276 <ccc_find_cfg+0xe>
	return NULL;
 1028298:	2000      	movs	r0, #0
 102829a:	e7f6      	b.n	102828a <ccc_find_cfg+0x22>

0102829c <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 102829c:	e8d0 0faf 	lda	r0, [r0]
}
 10282a0:	4770      	bx	lr

010282a2 <atomic_or>:
{
 10282a2:	4603      	mov	r3, r0
 10282a4:	b510      	push	{r4, lr}
}
 10282a6:	e8d3 0fef 	ldaex	r0, [r3]
 10282aa:	ea40 0201 	orr.w	r2, r0, r1
 10282ae:	e8c3 2fe4 	stlex	r4, r2, [r3]
 10282b2:	2c00      	cmp	r4, #0
 10282b4:	d1f7      	bne.n	10282a6 <atomic_or+0x4>
 10282b6:	bd10      	pop	{r4, pc}

010282b8 <bt_addr_le_copy>:
	memcpy(dst, src, sizeof(*dst));
 10282b8:	2207      	movs	r2, #7
 10282ba:	f7fe bb5b 	b.w	1026974 <memcpy>

010282be <atomic_and>:
{
 10282be:	4603      	mov	r3, r0
 10282c0:	b510      	push	{r4, lr}
}
 10282c2:	e8d3 0fef 	ldaex	r0, [r3]
 10282c6:	ea00 0201 	and.w	r2, r0, r1
 10282ca:	e8c3 2fe4 	stlex	r4, r2, [r3]
 10282ce:	2c00      	cmp	r4, #0
 10282d0:	d1f7      	bne.n	10282c2 <atomic_and+0x4>
 10282d2:	bd10      	pop	{r4, pc}

010282d4 <gatt_foreach_iter>:
{
 10282d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (handle > end_handle) {
 10282d6:	4299      	cmp	r1, r3
{
 10282d8:	4604      	mov	r4, r0
 10282da:	e9dd 0706 	ldrd	r0, r7, [sp, #24]
 10282de:	460d      	mov	r5, r1
 10282e0:	9e08      	ldr	r6, [sp, #32]
	if (handle > end_handle) {
 10282e2:	d901      	bls.n	10282e8 <gatt_foreach_iter+0x14>
		return BT_GATT_ITER_STOP;
 10282e4:	2000      	movs	r0, #0
}
 10282e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (handle < start_handle) {
 10282e8:	4291      	cmp	r1, r2
 10282ea:	d201      	bcs.n	10282f0 <gatt_foreach_iter+0x1c>
		return BT_GATT_ITER_CONTINUE;
 10282ec:	2001      	movs	r0, #1
 10282ee:	e7fa      	b.n	10282e6 <gatt_foreach_iter+0x12>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
 10282f0:	b960      	cbnz	r0, 102830c <gatt_foreach_iter+0x38>
	if (attr_data && attr_data != attr->user_data) {
 10282f2:	b98f      	cbnz	r7, 1028318 <gatt_foreach_iter+0x44>
	*num_matches -= 1;
 10282f4:	8833      	ldrh	r3, [r6, #0]
	result = func(attr, handle, user_data);
 10282f6:	4629      	mov	r1, r5
	*num_matches -= 1;
 10282f8:	3b01      	subs	r3, #1
 10282fa:	8033      	strh	r3, [r6, #0]
	result = func(attr, handle, user_data);
 10282fc:	4620      	mov	r0, r4
 10282fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 1028300:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 1028302:	4798      	blx	r3
	if (!*num_matches) {
 1028304:	8833      	ldrh	r3, [r6, #0]
 1028306:	2b00      	cmp	r3, #0
 1028308:	d1ed      	bne.n	10282e6 <gatt_foreach_iter+0x12>
 102830a:	e7eb      	b.n	10282e4 <gatt_foreach_iter+0x10>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
 102830c:	6821      	ldr	r1, [r4, #0]
 102830e:	f7fe fbd7 	bl	1026ac0 <bt_uuid_cmp>
 1028312:	2800      	cmp	r0, #0
 1028314:	d0ed      	beq.n	10282f2 <gatt_foreach_iter+0x1e>
 1028316:	e7e9      	b.n	10282ec <gatt_foreach_iter+0x18>
	if (attr_data && attr_data != attr->user_data) {
 1028318:	68e3      	ldr	r3, [r4, #12]
 102831a:	42bb      	cmp	r3, r7
 102831c:	d1e6      	bne.n	10282ec <gatt_foreach_iter+0x18>
 102831e:	e7e9      	b.n	10282f4 <gatt_foreach_iter+0x20>

01028320 <z_log_msg_static_create.constprop.0>:
 1028320:	2300      	movs	r3, #0
 1028322:	f7dc b9f1 	b.w	1004708 <z_impl_z_log_msg_static_create>

01028326 <find_next>:
static uint8_t find_next(const struct bt_gatt_attr *attr, uint16_t handle,
 1028326:	6010      	str	r0, [r2, #0]
 1028328:	2000      	movs	r0, #0
 102832a:	4770      	bx	lr

0102832c <sc_ccc_cfg_write>:
	if (value == BT_GATT_CCC_INDICATE) {
 102832c:	2a02      	cmp	r2, #2
{
 102832e:	b510      	push	{r4, lr}
	if (value == BT_GATT_CCC_INDICATE) {
 1028330:	d108      	bne.n	1028344 <sc_ccc_cfg_write+0x18>
		sc_save(conn->id, &conn->le.dst, 0, 0);
 1028332:	2300      	movs	r3, #0
 1028334:	f100 0190 	add.w	r1, r0, #144	; 0x90
 1028338:	461a      	mov	r2, r3
 102833a:	7a00      	ldrb	r0, [r0, #8]
 102833c:	f7e4 ff66 	bl	100d20c <sc_save>
}
 1028340:	2002      	movs	r0, #2
 1028342:	bd10      	pop	{r4, pc}
		sc_clear(conn);
 1028344:	f7e5 f9b4 	bl	100d6b0 <sc_clear>
 1028348:	e7fa      	b.n	1028340 <sc_ccc_cfg_write+0x14>

0102834a <read_appearance>:
{
 102834a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 102834c:	4615      	mov	r5, r2
 102834e:	f8bd 6020 	ldrh.w	r6, [sp, #32]
 1028352:	461f      	mov	r7, r3
	uint16_t appearance = sys_cpu_to_le16(bt_get_appearance());
 1028354:	f7fe fd01 	bl	1026d5a <bt_get_appearance>
	if (offset > value_len) {
 1028358:	2e02      	cmp	r6, #2
	uint16_t appearance = sys_cpu_to_le16(bt_get_appearance());
 102835a:	f8ad 0006 	strh.w	r0, [sp, #6]
	if (offset > value_len) {
 102835e:	d80e      	bhi.n	102837e <read_appearance+0x34>
	len = MIN(buf_len, value_len - offset);
 1028360:	f1c6 0402 	rsb	r4, r6, #2
 1028364:	42bc      	cmp	r4, r7
 1028366:	bfa8      	it	ge
 1028368:	463c      	movge	r4, r7
	memcpy(buf, (uint8_t *)value + offset, len);
 102836a:	f10d 0306 	add.w	r3, sp, #6
 102836e:	4622      	mov	r2, r4
 1028370:	4628      	mov	r0, r5
 1028372:	1999      	adds	r1, r3, r6
 1028374:	f7fe fafe 	bl	1026974 <memcpy>
}
 1028378:	4620      	mov	r0, r4
 102837a:	b003      	add	sp, #12
 102837c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 102837e:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
 1028382:	e7f9      	b.n	1028378 <read_appearance+0x2e>

01028384 <read_name>:
{
 1028384:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1028388:	4698      	mov	r8, r3
 102838a:	4615      	mov	r5, r2
 102838c:	f8bd 6018 	ldrh.w	r6, [sp, #24]
	const char *name = bt_get_name();
 1028390:	f7e0 fb02 	bl	1008998 <bt_get_name>
 1028394:	4607      	mov	r7, r0
				 strlen(name));
 1028396:	f7fe faae 	bl	10268f6 <strlen>
	if (offset > value_len) {
 102839a:	b283      	uxth	r3, r0
 102839c:	42b3      	cmp	r3, r6
 102839e:	d30c      	bcc.n	10283ba <read_name+0x36>
	len = MIN(buf_len, value_len - offset);
 10283a0:	1b9c      	subs	r4, r3, r6
 10283a2:	4544      	cmp	r4, r8
 10283a4:	bfa8      	it	ge
 10283a6:	4644      	movge	r4, r8
 10283a8:	b2a4      	uxth	r4, r4
	memcpy(buf, (uint8_t *)value + offset, len);
 10283aa:	4622      	mov	r2, r4
 10283ac:	4628      	mov	r0, r5
 10283ae:	19b9      	adds	r1, r7, r6
 10283b0:	f7fe fae0 	bl	1026974 <memcpy>
}
 10283b4:	4620      	mov	r0, r4
 10283b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 10283ba:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
 10283be:	e7f9      	b.n	10283b4 <read_name+0x30>

010283c0 <cf_read>:
{
 10283c0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 10283c2:	461f      	mov	r7, r3
	uint8_t data[1] = {};
 10283c4:	2300      	movs	r3, #0
{
 10283c6:	4615      	mov	r5, r2
 10283c8:	f8bd 6020 	ldrh.w	r6, [sp, #32]
	uint8_t data[1] = {};
 10283cc:	f88d 3004 	strb.w	r3, [sp, #4]
	cfg = find_cf_cfg(conn);
 10283d0:	f7e4 fcea 	bl	100cda8 <find_cf_cfg>
	if (cfg) {
 10283d4:	b128      	cbz	r0, 10283e2 <cf_read+0x22>
		memcpy(data, cfg->data, sizeof(data));
 10283d6:	f100 0108 	add.w	r1, r0, #8
 10283da:	2201      	movs	r2, #1
 10283dc:	a801      	add	r0, sp, #4
 10283de:	f7fe fac9 	bl	1026974 <memcpy>
	if (offset > value_len) {
 10283e2:	2e01      	cmp	r6, #1
 10283e4:	d80d      	bhi.n	1028402 <cf_read+0x42>
	len = MIN(buf_len, value_len - offset);
 10283e6:	f1c6 0401 	rsb	r4, r6, #1
 10283ea:	42bc      	cmp	r4, r7
 10283ec:	bfa8      	it	ge
 10283ee:	463c      	movge	r4, r7
	memcpy(buf, (uint8_t *)value + offset, len);
 10283f0:	ab01      	add	r3, sp, #4
 10283f2:	4622      	mov	r2, r4
 10283f4:	4628      	mov	r0, r5
 10283f6:	1999      	adds	r1, r3, r6
 10283f8:	f7fe fabc 	bl	1026974 <memcpy>
}
 10283fc:	4620      	mov	r0, r4
 10283fe:	b003      	add	sp, #12
 1028400:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 1028402:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, data,
 1028406:	e7f9      	b.n	10283fc <cf_read+0x3c>

01028408 <bt_gatt_attr_read_service>:
{
 1028408:	b513      	push	{r0, r1, r4, lr}
	struct bt_uuid *uuid = attr->user_data;
 102840a:	68c9      	ldr	r1, [r1, #12]
{
 102840c:	4610      	mov	r0, r2
	if (uuid->type == BT_UUID_TYPE_16) {
 102840e:	780a      	ldrb	r2, [r1, #0]
{
 1028410:	461c      	mov	r4, r3
 1028412:	f8bd 3010 	ldrh.w	r3, [sp, #16]
	if (uuid->type == BT_UUID_TYPE_16) {
 1028416:	b992      	cbnz	r2, 102843e <bt_gatt_attr_read_service+0x36>
		uint16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
 1028418:	884a      	ldrh	r2, [r1, #2]
	if (offset > value_len) {
 102841a:	2b02      	cmp	r3, #2
		uint16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
 102841c:	f8ad 2006 	strh.w	r2, [sp, #6]
	if (offset > value_len) {
 1028420:	d818      	bhi.n	1028454 <bt_gatt_attr_read_service+0x4c>
	len = MIN(buf_len, value_len - offset);
 1028422:	f1c3 0202 	rsb	r2, r3, #2
 1028426:	4294      	cmp	r4, r2
 1028428:	bfa8      	it	ge
 102842a:	4614      	movge	r4, r2
	memcpy(buf, (uint8_t *)value + offset, len);
 102842c:	4622      	mov	r2, r4
 102842e:	f10d 0106 	add.w	r1, sp, #6
 1028432:	4419      	add	r1, r3
 1028434:	f7fe fa9e 	bl	1026974 <memcpy>
}
 1028438:	4620      	mov	r0, r4
 102843a:	b002      	add	sp, #8
 102843c:	bd10      	pop	{r4, pc}
	if (offset > value_len) {
 102843e:	2b10      	cmp	r3, #16
				 BT_UUID_128(uuid)->val, 16);
 1028440:	f101 0101 	add.w	r1, r1, #1
	if (offset > value_len) {
 1028444:	d806      	bhi.n	1028454 <bt_gatt_attr_read_service+0x4c>
	len = MIN(buf_len, value_len - offset);
 1028446:	f1c3 0210 	rsb	r2, r3, #16
 102844a:	4294      	cmp	r4, r2
 102844c:	bfa8      	it	ge
 102844e:	4614      	movge	r4, r2
	memcpy(buf, (uint8_t *)value + offset, len);
 1028450:	4622      	mov	r2, r4
 1028452:	e7ee      	b.n	1028432 <bt_gatt_attr_read_service+0x2a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 1028454:	f06f 0406 	mvn.w	r4, #6
 1028458:	e7ee      	b.n	1028438 <bt_gatt_attr_read_service+0x30>

0102845a <bt_gatt_attr_read_ccc>:
{
 102845a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	cfg = find_ccc_cfg(conn, ccc);
 102845c:	68c9      	ldr	r1, [r1, #12]
{
 102845e:	4615      	mov	r5, r2
 1028460:	461f      	mov	r7, r3
 1028462:	f8bd 6020 	ldrh.w	r6, [sp, #32]
	cfg = find_ccc_cfg(conn, ccc);
 1028466:	f7e4 fcdd 	bl	100ce24 <find_ccc_cfg>
	if (cfg) {
 102846a:	b100      	cbz	r0, 102846e <bt_gatt_attr_read_ccc+0x14>
		value = sys_cpu_to_le16(cfg->value);
 102846c:	8900      	ldrh	r0, [r0, #8]
	if (offset > value_len) {
 102846e:	2e02      	cmp	r6, #2
 1028470:	f8ad 0006 	strh.w	r0, [sp, #6]
 1028474:	d80e      	bhi.n	1028494 <bt_gatt_attr_read_ccc+0x3a>
	len = MIN(buf_len, value_len - offset);
 1028476:	f1c6 0402 	rsb	r4, r6, #2
 102847a:	42bc      	cmp	r4, r7
 102847c:	bfa8      	it	ge
 102847e:	463c      	movge	r4, r7
	memcpy(buf, (uint8_t *)value + offset, len);
 1028480:	f10d 0306 	add.w	r3, sp, #6
 1028484:	4622      	mov	r2, r4
 1028486:	4628      	mov	r0, r5
 1028488:	1999      	adds	r1, r3, r6
 102848a:	f7fe fa73 	bl	1026974 <memcpy>
}
 102848e:	4620      	mov	r0, r4
 1028490:	b003      	add	sp, #12
 1028492:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 1028494:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
 1028498:	e7f9      	b.n	102848e <bt_gatt_attr_read_ccc+0x34>

0102849a <sc_restore_rsp>:
{
 102849a:	b538      	push	{r3, r4, r5, lr}
 102849c:	4604      	mov	r4, r0
 102849e:	4615      	mov	r5, r2
	if (bt_att_fixed_chan_only(conn)) {
 10284a0:	f7ff fe27 	bl	10280f2 <bt_att_fixed_chan_only>
 10284a4:	b150      	cbz	r0, 10284bc <sc_restore_rsp+0x22>
		cfg = find_cf_cfg(conn);
 10284a6:	4620      	mov	r0, r4
 10284a8:	f7e4 fc7e 	bl	100cda8 <find_cf_cfg>
		if (cfg && CF_ROBUST_CACHING(cfg)) {
 10284ac:	b130      	cbz	r0, 10284bc <sc_restore_rsp+0x22>
 10284ae:	7a03      	ldrb	r3, [r0, #8]
 10284b0:	07db      	lsls	r3, r3, #31
 10284b2:	d503      	bpl.n	10284bc <sc_restore_rsp+0x22>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
 10284b4:	2101      	movs	r1, #1
 10284b6:	300c      	adds	r0, #12
 10284b8:	f7ff fef3 	bl	10282a2 <atomic_or>
	if (!err && IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED)) {
 10284bc:	b985      	cbnz	r5, 10284e0 <sc_restore_rsp+0x46>
		struct gatt_sc_cfg *sc_cfg = find_sc_cfg(conn->id, &conn->le.dst);
 10284be:	7a20      	ldrb	r0, [r4, #8]
 10284c0:	f104 0190 	add.w	r1, r4, #144	; 0x90
 10284c4:	f7e4 fc92 	bl	100cdec <find_sc_cfg>
		if (sc_cfg) {
 10284c8:	4604      	mov	r4, r0
 10284ca:	b148      	cbz	r0, 10284e0 <sc_restore_rsp+0x46>
	memset(&cfg->data, 0, sizeof(cfg->data));
 10284cc:	4629      	mov	r1, r5
 10284ce:	2204      	movs	r2, #4
 10284d0:	3008      	adds	r0, #8
 10284d2:	f7fe fa5a 	bl	102698a <memset>
		sc_store(cfg);
 10284d6:	4620      	mov	r0, r4
}
 10284d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		sc_store(cfg);
 10284dc:	f7e4 be62 	b.w	100d1a4 <sc_store>
}
 10284e0:	bd38      	pop	{r3, r4, r5, pc}

010284e2 <bt_gatt_attr_value_handle>:
{
 10284e2:	b513      	push	{r0, r1, r4, lr}
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
 10284e4:	4604      	mov	r4, r0
 10284e6:	b910      	cbnz	r0, 10284ee <bt_gatt_attr_value_handle+0xc>
	uint16_t handle = 0;
 10284e8:	2000      	movs	r0, #0
}
 10284ea:	b002      	add	sp, #8
 10284ec:	bd10      	pop	{r4, pc}
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
 10284ee:	2300      	movs	r3, #0
 10284f0:	f88d 3004 	strb.w	r3, [sp, #4]
 10284f4:	f642 0303 	movw	r3, #10243	; 0x2803
 10284f8:	6800      	ldr	r0, [r0, #0]
 10284fa:	a901      	add	r1, sp, #4
 10284fc:	f8ad 3006 	strh.w	r3, [sp, #6]
 1028500:	f7fe fade 	bl	1026ac0 <bt_uuid_cmp>
 1028504:	2800      	cmp	r0, #0
 1028506:	d1ef      	bne.n	10284e8 <bt_gatt_attr_value_handle+0x6>
		handle = chrc->value_handle;
 1028508:	68e3      	ldr	r3, [r4, #12]
 102850a:	8898      	ldrh	r0, [r3, #4]
		if (handle == 0) {
 102850c:	2800      	cmp	r0, #0
 102850e:	d1ec      	bne.n	10284ea <bt_gatt_attr_value_handle+0x8>
			handle = bt_gatt_attr_get_handle(attr) + 1U;
 1028510:	4620      	mov	r0, r4
 1028512:	f7e5 fa69 	bl	100d9e8 <bt_gatt_attr_get_handle>
 1028516:	3001      	adds	r0, #1
 1028518:	b280      	uxth	r0, r0
	return handle;
 102851a:	e7e6      	b.n	10284ea <bt_gatt_attr_value_handle+0x8>

0102851c <bt_gatt_attr_read_chrc>:
{
 102851c:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_gatt_chrc *chrc = attr->user_data;
 102851e:	68cc      	ldr	r4, [r1, #12]
{
 1028520:	461f      	mov	r7, r3
	pdu.properties = chrc->properties;
 1028522:	79a3      	ldrb	r3, [r4, #6]
{
 1028524:	b087      	sub	sp, #28
 1028526:	4608      	mov	r0, r1
	pdu.properties = chrc->properties;
 1028528:	f88d 3004 	strb.w	r3, [sp, #4]
{
 102852c:	4615      	mov	r5, r2
 102852e:	f8bd 6030 	ldrh.w	r6, [sp, #48]	; 0x30
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
 1028532:	f7ff ffd6 	bl	10284e2 <bt_gatt_attr_value_handle>
 1028536:	f8ad 0005 	strh.w	r0, [sp, #5]
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
 102853a:	6821      	ldr	r1, [r4, #0]
 102853c:	780b      	ldrb	r3, [r1, #0]
 102853e:	b99b      	cbnz	r3, 1028568 <bt_gatt_attr_read_chrc+0x4c>
		value_len += 2U;
 1028540:	2405      	movs	r4, #5
		pdu.uuid16 = sys_cpu_to_le16(BT_UUID_16(chrc->uuid)->val);
 1028542:	884b      	ldrh	r3, [r1, #2]
 1028544:	f8ad 3007 	strh.w	r3, [sp, #7]
	if (offset > value_len) {
 1028548:	42b4      	cmp	r4, r6
 102854a:	d315      	bcc.n	1028578 <bt_gatt_attr_read_chrc+0x5c>
	len = MIN(buf_len, value_len - offset);
 102854c:	1ba4      	subs	r4, r4, r6
 102854e:	42bc      	cmp	r4, r7
 1028550:	bfa8      	it	ge
 1028552:	463c      	movge	r4, r7
	memcpy(buf, (uint8_t *)value + offset, len);
 1028554:	ab01      	add	r3, sp, #4
 1028556:	b2a4      	uxth	r4, r4
 1028558:	4622      	mov	r2, r4
 102855a:	4628      	mov	r0, r5
 102855c:	1999      	adds	r1, r3, r6
 102855e:	f7fe fa09 	bl	1026974 <memcpy>
}
 1028562:	4620      	mov	r0, r4
 1028564:	b007      	add	sp, #28
 1028566:	bdf0      	pop	{r4, r5, r6, r7, pc}
		memcpy(pdu.uuid, BT_UUID_128(chrc->uuid)->val, 16);
 1028568:	2210      	movs	r2, #16
 102856a:	3101      	adds	r1, #1
 102856c:	f10d 0007 	add.w	r0, sp, #7
 1028570:	f7fe fa00 	bl	1026974 <memcpy>
		value_len += 16U;
 1028574:	2413      	movs	r4, #19
 1028576:	e7e7      	b.n	1028548 <bt_gatt_attr_read_chrc+0x2c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 1028578:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &pdu, value_len);
 102857c:	e7f1      	b.n	1028562 <bt_gatt_attr_read_chrc+0x46>

0102857e <bt_gatt_foreach_attr>:
{
 102857e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
 1028580:	e9cd 2301 	strd	r2, r3, [sp, #4]
 1028584:	2300      	movs	r3, #0
 1028586:	461a      	mov	r2, r3
 1028588:	9300      	str	r3, [sp, #0]
 102858a:	f7e5 fa75 	bl	100da78 <bt_gatt_foreach_attr_type>
}
 102858e:	b005      	add	sp, #20
 1028590:	f85d fb04 	ldr.w	pc, [sp], #4

01028594 <bt_gatt_get_mtu>:
	return bt_att_get_mtu(conn);
 1028594:	f7ff bd4b 	b.w	102802e <bt_att_get_mtu>

01028598 <bt_gatt_check_perm>:
{
 1028598:	b538      	push	{r3, r4, r5, lr}
	if ((mask & BT_GATT_PERM_READ) &&
 102859a:	07d4      	lsls	r4, r2, #31
{
 102859c:	4605      	mov	r5, r0
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
 102859e:	8a4b      	ldrh	r3, [r1, #18]
	if ((mask & BT_GATT_PERM_READ) &&
 10285a0:	d504      	bpl.n	10285ac <bt_gatt_check_perm+0x14>
 10285a2:	f013 0f95 	tst.w	r3, #149	; 0x95
 10285a6:	d027      	beq.n	10285f8 <bt_gatt_check_perm+0x60>
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
 10285a8:	6848      	ldr	r0, [r1, #4]
 10285aa:	b328      	cbz	r0, 10285f8 <bt_gatt_check_perm+0x60>
	if ((mask & BT_GATT_PERM_WRITE) &&
 10285ac:	0790      	lsls	r0, r2, #30
 10285ae:	d504      	bpl.n	10285ba <bt_gatt_check_perm+0x22>
 10285b0:	f413 7f95 	tst.w	r3, #298	; 0x12a
 10285b4:	d022      	beq.n	10285fc <bt_gatt_check_perm+0x64>
	    (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {
 10285b6:	6889      	ldr	r1, [r1, #8]
 10285b8:	b301      	cbz	r1, 10285fc <bt_gatt_check_perm+0x64>
	mask &= attr->perm;
 10285ba:	ea02 0403 	and.w	r4, r2, r3
	if (mask & BT_GATT_PERM_LESC_MASK) {
 10285be:	f414 7fc0 	tst.w	r4, #384	; 0x180
 10285c2:	d007      	beq.n	10285d4 <bt_gatt_check_perm+0x3c>
		if (!IS_ENABLED(CONFIG_BT_SMP) || !conn->le.keys ||
 10285c4:	f8d5 30c0 	ldr.w	r3, [r5, #192]	; 0xc0
 10285c8:	b90b      	cbnz	r3, 10285ce <bt_gatt_check_perm+0x36>
			return BT_ATT_ERR_AUTHENTICATION;
 10285ca:	2005      	movs	r0, #5
}
 10285cc:	bd38      	pop	{r3, r4, r5, pc}
		if (!IS_ENABLED(CONFIG_BT_SMP) || !conn->le.keys ||
 10285ce:	7b5b      	ldrb	r3, [r3, #13]
 10285d0:	06db      	lsls	r3, r3, #27
 10285d2:	d5fa      	bpl.n	10285ca <bt_gatt_check_perm+0x32>
	if (mask & BT_GATT_PERM_AUTHEN_MASK) {
 10285d4:	f014 0f30 	tst.w	r4, #48	; 0x30
 10285d8:	d108      	bne.n	10285ec <bt_gatt_check_perm+0x54>
	if ((mask & BT_GATT_PERM_ENCRYPT_MASK)) {
 10285da:	f014 000c 	ands.w	r0, r4, #12
 10285de:	d0f5      	beq.n	10285cc <bt_gatt_check_perm+0x34>
		if (!conn->encrypt) {
 10285e0:	7aeb      	ldrb	r3, [r5, #11]
			return BT_ATT_ERR_INSUFFICIENT_ENCRYPTION;
 10285e2:	2b00      	cmp	r3, #0
 10285e4:	bf14      	ite	ne
 10285e6:	2000      	movne	r0, #0
 10285e8:	200f      	moveq	r0, #15
 10285ea:	e7ef      	b.n	10285cc <bt_gatt_check_perm+0x34>
		if (bt_conn_get_security(conn) < BT_SECURITY_L3) {
 10285ec:	4628      	mov	r0, r5
 10285ee:	f7fe fe4d 	bl	102728c <bt_conn_get_security>
 10285f2:	2802      	cmp	r0, #2
 10285f4:	d8f1      	bhi.n	10285da <bt_gatt_check_perm+0x42>
 10285f6:	e7e8      	b.n	10285ca <bt_gatt_check_perm+0x32>
		return BT_ATT_ERR_READ_NOT_PERMITTED;
 10285f8:	2002      	movs	r0, #2
 10285fa:	e7e7      	b.n	10285cc <bt_gatt_check_perm+0x34>
		return BT_ATT_ERR_WRITE_NOT_PERMITTED;
 10285fc:	2003      	movs	r0, #3
 10285fe:	e7e5      	b.n	10285cc <bt_gatt_check_perm+0x34>

01028600 <bt_gatt_change_aware>:
{
 1028600:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1028602:	4605      	mov	r5, r0
 1028604:	460f      	mov	r7, r1
	cfg = find_cf_cfg(conn);
 1028606:	f7e4 fbcf 	bl	100cda8 <find_cf_cfg>
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
 102860a:	b1d0      	cbz	r0, 1028642 <bt_gatt_change_aware+0x42>
 102860c:	7a03      	ldrb	r3, [r0, #8]
 102860e:	07db      	lsls	r3, r3, #31
 1028610:	d517      	bpl.n	1028642 <bt_gatt_change_aware+0x42>
	if (atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
 1028612:	f100 040c 	add.w	r4, r0, #12
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
 1028616:	4620      	mov	r0, r4
 1028618:	f7ff fe40 	bl	102829c <atomic_get>
 102861c:	f010 0601 	ands.w	r6, r0, #1
 1028620:	d10f      	bne.n	1028642 <bt_gatt_change_aware+0x42>
	if (!req) {
 1028622:	b17f      	cbz	r7, 1028644 <bt_gatt_change_aware+0x44>
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 1028624:	f06f 0102 	mvn.w	r1, #2
 1028628:	4620      	mov	r0, r4
 102862a:	f7ff fe48 	bl	10282be <atomic_and>
	if (atomic_test_and_clear_bit(cfg->flags, CF_DB_HASH_READ)) {
 102862e:	f010 0f02 	tst.w	r0, #2
		bt_att_clear_out_of_sync_sent(conn);
 1028632:	4628      	mov	r0, r5
	if (atomic_test_and_clear_bit(cfg->flags, CF_DB_HASH_READ)) {
 1028634:	d008      	beq.n	1028648 <bt_gatt_change_aware+0x48>
		bt_att_clear_out_of_sync_sent(conn);
 1028636:	f7ff fd5e 	bl	10280f6 <bt_att_clear_out_of_sync_sent>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
 102863a:	2101      	movs	r1, #1
 102863c:	4620      	mov	r0, r4
 102863e:	f7ff fe30 	bl	10282a2 <atomic_or>
		return true;
 1028642:	2601      	movs	r6, #1
}
 1028644:	4630      	mov	r0, r6
 1028646:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (bt_att_fixed_chan_only(conn) && bt_att_out_of_sync_sent_on_fixed(conn)) {
 1028648:	f7ff fd53 	bl	10280f2 <bt_att_fixed_chan_only>
 102864c:	2800      	cmp	r0, #0
 102864e:	d0f9      	beq.n	1028644 <bt_gatt_change_aware+0x44>
 1028650:	4628      	mov	r0, r5
 1028652:	f7ff fd66 	bl	1028122 <bt_att_out_of_sync_sent_on_fixed>
 1028656:	2800      	cmp	r0, #0
 1028658:	d0f4      	beq.n	1028644 <bt_gatt_change_aware+0x44>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 102865a:	f06f 0102 	mvn.w	r1, #2
 102865e:	4620      	mov	r0, r4
 1028660:	f7ff fe2d 	bl	10282be <atomic_and>
		bt_att_clear_out_of_sync_sent(conn);
 1028664:	4628      	mov	r0, r5
 1028666:	e7e6      	b.n	1028636 <bt_gatt_change_aware+0x36>

01028668 <ccc_delayed_store>:
{
 1028668:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
			ccc_store->conn_list[i] = NULL;
 102866c:	f04f 0800 	mov.w	r8, #0
 1028670:	f1a0 0624 	sub.w	r6, r0, #36	; 0x24
 1028674:	1f04      	subs	r4, r0, #4
		struct bt_conn *conn = ccc_store->conn_list[i];
 1028676:	f856 5f04 	ldr.w	r5, [r6, #4]!
		if (!conn) {
 102867a:	b17d      	cbz	r5, 102869c <ccc_delayed_store+0x34>
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
 102867c:	f105 0790 	add.w	r7, r5, #144	; 0x90
 1028680:	4639      	mov	r1, r7
 1028682:	7a28      	ldrb	r0, [r5, #8]
 1028684:	f7fe fb6b 	bl	1026d5e <bt_addr_le_is_bonded>
 1028688:	b140      	cbz	r0, 102869c <ccc_delayed_store+0x34>
			ccc_store->conn_list[i] = NULL;
 102868a:	f8c6 8000 	str.w	r8, [r6]
			bt_gatt_store_ccc(conn->id, &conn->le.dst);
 102868e:	4639      	mov	r1, r7
 1028690:	7a28      	ldrb	r0, [r5, #8]
 1028692:	f7e6 f9e1 	bl	100ea58 <bt_gatt_store_ccc>
			bt_conn_unref(conn);
 1028696:	4628      	mov	r0, r5
 1028698:	f7e1 fd00 	bl	100a09c <bt_conn_unref>
	for (size_t i = 0; i < CONFIG_BT_MAX_CONN; i++) {
 102869c:	42a6      	cmp	r6, r4
 102869e:	d1ea      	bne.n	1028676 <ccc_delayed_store+0xe>
}
 10286a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

010286a4 <smp_pairing_rsp>:
}
 10286a4:	2007      	movs	r0, #7
 10286a6:	4770      	bx	lr

010286a8 <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 10286a8:	e8d0 0faf 	lda	r0, [r0]
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
 10286ac:	4108      	asrs	r0, r1
}
 10286ae:	f000 0001 	and.w	r0, r0, #1
 10286b2:	4770      	bx	lr

010286b4 <update_keys_check>:
{
 10286b4:	4603      	mov	r3, r0
 10286b6:	b510      	push	{r4, lr}
	if (!keys ||
 10286b8:	b1d9      	cbz	r1, 10286f2 <update_keys_check+0x3e>
	    !(keys->keys & (BT_KEYS_LTK_P256 | BT_KEYS_LTK))) {
 10286ba:	89c8      	ldrh	r0, [r1, #14]
	if (!keys ||
 10286bc:	f010 0f24 	tst.w	r0, #36	; 0x24
 10286c0:	d017      	beq.n	10286f2 <update_keys_check+0x3e>
	return MIN(req->max_key_size, rsp->max_key_size);
 10286c2:	7d1a      	ldrb	r2, [r3, #20]
 10286c4:	7b5c      	ldrb	r4, [r3, #13]
	if (keys->enc_size > get_encryption_key_size(smp)) {
 10286c6:	7b09      	ldrb	r1, [r1, #12]
 10286c8:	42a2      	cmp	r2, r4
 10286ca:	bf28      	it	cs
 10286cc:	4622      	movcs	r2, r4
 10286ce:	4291      	cmp	r1, r2
 10286d0:	d901      	bls.n	10286d6 <update_keys_check+0x22>
			return false;
 10286d2:	2000      	movs	r0, #0
}
 10286d4:	bd10      	pop	{r4, pc}
	if ((keys->keys & BT_KEYS_LTK_P256) &&
 10286d6:	0682      	lsls	r2, r0, #26
 10286d8:	d404      	bmi.n	10286e4 <update_keys_check+0x30>
	if ((keys->flags & BT_KEYS_AUTHENTICATED) &&
 10286da:	7a18      	ldrb	r0, [r3, #8]
 10286dc:	3800      	subs	r0, #0
 10286de:	bf18      	it	ne
 10286e0:	2001      	movne	r0, #1
 10286e2:	e7f7      	b.n	10286d4 <update_keys_check+0x20>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 10286e4:	2105      	movs	r1, #5
 10286e6:	1d18      	adds	r0, r3, #4
 10286e8:	f7ff ffde 	bl	10286a8 <atomic_test_bit>
	if ((keys->keys & BT_KEYS_LTK_P256) &&
 10286ec:	2800      	cmp	r0, #0
 10286ee:	d1f4      	bne.n	10286da <update_keys_check+0x26>
 10286f0:	e7ef      	b.n	10286d2 <update_keys_check+0x1e>
	return true;
 10286f2:	2001      	movs	r0, #1
 10286f4:	e7ee      	b.n	10286d4 <update_keys_check+0x20>

010286f6 <atomic_clear_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
 10286f6:	2301      	movs	r3, #1
 10286f8:	408b      	lsls	r3, r1
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 10286fa:	43db      	mvns	r3, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 10286fc:	e8d0 2fef 	ldaex	r2, [r0]
 1028700:	401a      	ands	r2, r3
 1028702:	e8c0 2fe1 	stlex	r1, r2, [r0]
 1028706:	2900      	cmp	r1, #0
 1028708:	d1f8      	bne.n	10286fc <atomic_clear_bit+0x6>
}
 102870a:	4770      	bx	lr

0102870c <smp_security_request>:
static uint8_t smp_security_request(struct bt_smp *smp, struct net_buf *buf)
 102870c:	2007      	movs	r0, #7
 102870e:	4770      	bx	lr

01028710 <smp_send.constprop.0>:
static void smp_send(struct bt_smp *smp, struct net_buf *buf,
 1028710:	b537      	push	{r0, r1, r2, r4, r5, lr}
 1028712:	4613      	mov	r3, r2
	if (bt_l2cap_send_cb(smp->chan.chan.conn, BT_L2CAP_CID_SMP, buf, cb, NULL)) {
 1028714:	2200      	movs	r2, #0
 1028716:	9200      	str	r2, [sp, #0]
static void smp_send(struct bt_smp *smp, struct net_buf *buf,
 1028718:	4604      	mov	r4, r0
 102871a:	460d      	mov	r5, r1
	if (bt_l2cap_send_cb(smp->chan.chan.conn, BT_L2CAP_CID_SMP, buf, cb, NULL)) {
 102871c:	460a      	mov	r2, r1
 102871e:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
 1028722:	2106      	movs	r1, #6
 1028724:	f7fe ff1a 	bl	102755c <bt_l2cap_send_cb>
 1028728:	b128      	cbz	r0, 1028736 <smp_send.constprop.0+0x26>
		net_buf_unref(buf);
 102872a:	4628      	mov	r0, r5
}
 102872c:	b003      	add	sp, #12
 102872e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		net_buf_unref(buf);
 1028732:	f7f5 bc55 	b.w	101dfe0 <net_buf_unref>
	k_work_reschedule(&smp->work, SMP_TIMEOUT);
 1028736:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
 102873a:	2300      	movs	r3, #0
 102873c:	f504 70f4 	add.w	r0, r4, #488	; 0x1e8
}
 1028740:	b003      	add	sp, #12
 1028742:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	k_work_reschedule(&smp->work, SMP_TIMEOUT);
 1028746:	f7f9 bcfd 	b.w	1022144 <k_work_reschedule>

0102874a <z_log_msg_static_create.constprop.0>:
 102874a:	2300      	movs	r3, #0
 102874c:	f7db bfdc 	b.w	1004708 <z_impl_z_log_msg_static_create>

01028750 <smp_chan_get>:
{
 1028750:	b508      	push	{r3, lr}
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_SMP);
 1028752:	2106      	movs	r1, #6
 1028754:	f7ff f821 	bl	102779a <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
 1028758:	b918      	cbnz	r0, 1028762 <smp_chan_get+0x12>
}
 102875a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 102875e:	f7e6 bb1b 	b.w	100ed98 <smp_chan_get.part.0>
 1028762:	38f0      	subs	r0, #240	; 0xf0
 1028764:	bd08      	pop	{r3, pc}

01028766 <atomic_set_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
 1028766:	2301      	movs	r3, #1
 1028768:	408b      	lsls	r3, r1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 102876a:	e8d0 2fef 	ldaex	r2, [r0]
 102876e:	431a      	orrs	r2, r3
 1028770:	e8c0 2fe1 	stlex	r1, r2, [r0]
 1028774:	2900      	cmp	r1, #0
 1028776:	d1f8      	bne.n	102876a <atomic_set_bit+0x4>
}
 1028778:	4770      	bx	lr

0102877a <smp_keypress_notif>:
{
 102877a:	b508      	push	{r3, lr}
	atomic_set_bit(smp->allowed_cmds, BT_SMP_KEYPRESS_NOTIFICATION);
 102877c:	210e      	movs	r1, #14
 102877e:	f7ff fff2 	bl	1028766 <atomic_set_bit>
}
 1028782:	2000      	movs	r0, #0
 1028784:	bd08      	pop	{r3, pc}

01028786 <smp_create_pdu.constprop.0>:
static struct net_buf *smp_create_pdu(struct bt_smp *smp, uint8_t op, size_t len)
 1028786:	b570      	push	{r4, r5, r6, lr}
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
 1028788:	1d05      	adds	r5, r0, #4
static struct net_buf *smp_create_pdu(struct bt_smp *smp, uint8_t op, size_t len)
 102878a:	460e      	mov	r6, r1
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
 102878c:	4628      	mov	r0, r5
 102878e:	2104      	movs	r1, #4
 1028790:	f7ff ff8a 	bl	10286a8 <atomic_test_bit>
 1028794:	b168      	cbz	r0, 10287b2 <smp_create_pdu.constprop.0+0x2c>
		timeout = K_NO_WAIT;
 1028796:	2200      	movs	r2, #0
	buf = bt_l2cap_create_pdu_timeout(NULL, 0, timeout);
 1028798:	2100      	movs	r1, #0
		timeout = SMP_TIMEOUT;
 102879a:	2300      	movs	r3, #0
	buf = bt_l2cap_create_pdu_timeout(NULL, 0, timeout);
 102879c:	4608      	mov	r0, r1
 102879e:	f7fe feda 	bl	1027556 <bt_l2cap_create_pdu_timeout>
	if (!buf) {
 10287a2:	4604      	mov	r4, r0
 10287a4:	b940      	cbnz	r0, 10287b8 <smp_create_pdu.constprop.0+0x32>
		atomic_set_bit(smp->flags, SMP_FLAG_TIMEOUT);
 10287a6:	2104      	movs	r1, #4
 10287a8:	4628      	mov	r0, r5
 10287aa:	f7ff ffdc 	bl	1028766 <atomic_set_bit>
}
 10287ae:	4620      	mov	r0, r4
 10287b0:	bd70      	pop	{r4, r5, r6, pc}
		timeout = SMP_TIMEOUT;
 10287b2:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
 10287b6:	e7ef      	b.n	1028798 <smp_create_pdu.constprop.0+0x12>
 10287b8:	2101      	movs	r1, #1
 10287ba:	300c      	adds	r0, #12
 10287bc:	f7f5 fd6c 	bl	101e298 <net_buf_simple_add>
	hdr->code = op;
 10287c0:	7006      	strb	r6, [r0, #0]
	return buf;
 10287c2:	e7f4      	b.n	10287ae <smp_create_pdu.constprop.0+0x28>

010287c4 <send_pairing_rsp>:
{
 10287c4:	b538      	push	{r3, r4, r5, lr}
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RSP, sizeof(*rsp));
 10287c6:	2102      	movs	r1, #2
{
 10287c8:	4605      	mov	r5, r0
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RSP, sizeof(*rsp));
 10287ca:	f7ff ffdc 	bl	1028786 <smp_create_pdu.constprop.0>
	if (!rsp_buf) {
 10287ce:	4604      	mov	r4, r0
 10287d0:	b178      	cbz	r0, 10287f2 <send_pairing_rsp+0x2e>
 10287d2:	2106      	movs	r1, #6
 10287d4:	300c      	adds	r0, #12
 10287d6:	f7f5 fd5f 	bl	101e298 <net_buf_simple_add>
	memcpy(rsp, smp->prsp + 1, sizeof(*rsp));
 10287da:	2206      	movs	r2, #6
 10287dc:	f105 0111 	add.w	r1, r5, #17
 10287e0:	f7fe f8c8 	bl	1026974 <memcpy>
	smp_send(smp, rsp_buf, NULL, NULL);
 10287e4:	4628      	mov	r0, r5
 10287e6:	2200      	movs	r2, #0
 10287e8:	4621      	mov	r1, r4
 10287ea:	f7ff ff91 	bl	1028710 <smp_send.constprop.0>
	return 0;
 10287ee:	2000      	movs	r0, #0
}
 10287f0:	bd38      	pop	{r3, r4, r5, pc}
		return BT_SMP_ERR_UNSPECIFIED;
 10287f2:	2008      	movs	r0, #8
 10287f4:	e7fc      	b.n	10287f0 <send_pairing_rsp+0x2c>

010287f6 <smp_send_pairing_random>:
{
 10287f6:	b538      	push	{r3, r4, r5, lr}
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RANDOM, sizeof(*req));
 10287f8:	2104      	movs	r1, #4
{
 10287fa:	4605      	mov	r5, r0
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RANDOM, sizeof(*req));
 10287fc:	f7ff ffc3 	bl	1028786 <smp_create_pdu.constprop.0>
	if (!rsp_buf) {
 1028800:	4604      	mov	r4, r0
 1028802:	b178      	cbz	r0, 1028824 <smp_send_pairing_random+0x2e>
 1028804:	2110      	movs	r1, #16
 1028806:	300c      	adds	r0, #12
 1028808:	f7f5 fd46 	bl	101e298 <net_buf_simple_add>
	memcpy(req->val, smp->prnd, sizeof(req->val));
 102880c:	2210      	movs	r2, #16
 102880e:	f105 0127 	add.w	r1, r5, #39	; 0x27
 1028812:	f7fe f8af 	bl	1026974 <memcpy>
	smp_send(smp, rsp_buf, NULL, NULL);
 1028816:	4628      	mov	r0, r5
 1028818:	2200      	movs	r2, #0
 102881a:	4621      	mov	r1, r4
 102881c:	f7ff ff78 	bl	1028710 <smp_send.constprop.0>
	return 0;
 1028820:	2000      	movs	r0, #0
}
 1028822:	bd38      	pop	{r3, r4, r5, pc}
		return BT_SMP_ERR_UNSPECIFIED;
 1028824:	2008      	movs	r0, #8
 1028826:	e7fc      	b.n	1028822 <smp_send_pairing_random+0x2c>

01028828 <smp_dhkey_check>:
{
 1028828:	b570      	push	{r4, r5, r6, lr}
	if (smp->chan.chan.conn->role == BT_HCI_ROLE_PERIPHERAL) {
 102882a:	f8d0 30f0 	ldr.w	r3, [r0, #240]	; 0xf0
{
 102882e:	4604      	mov	r4, r0
	if (smp->chan.chan.conn->role == BT_HCI_ROLE_PERIPHERAL) {
 1028830:	78db      	ldrb	r3, [r3, #3]
 1028832:	2b01      	cmp	r3, #1
 1028834:	d114      	bne.n	1028860 <smp_dhkey_check+0x38>
	struct bt_smp_dhkey_check *req = (void *)buf->data;
 1028836:	68ce      	ldr	r6, [r1, #12]
		atomic_clear_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
 1028838:	1d05      	adds	r5, r0, #4
 102883a:	2110      	movs	r1, #16
 102883c:	4628      	mov	r0, r5
 102883e:	f7ff ff5a 	bl	10286f6 <atomic_clear_bit>
		memcpy(smp->e, req->e, sizeof(smp->e));
 1028842:	4631      	mov	r1, r6
 1028844:	2210      	movs	r2, #16
 1028846:	f104 00b7 	add.w	r0, r4, #183	; 0xb7
 102884a:	f7fe f893 	bl	1026974 <memcpy>
		if (atomic_test_bit(smp->flags, SMP_FLAG_DHKEY_PENDING)) {
 102884e:	2107      	movs	r1, #7
 1028850:	4628      	mov	r0, r5
 1028852:	f7ff ff29 	bl	10286a8 <atomic_test_bit>
 1028856:	b128      	cbz	r0, 1028864 <smp_dhkey_check+0x3c>
			atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
 1028858:	2109      	movs	r1, #9
 102885a:	4628      	mov	r0, r5
 102885c:	f7ff ff83 	bl	1028766 <atomic_set_bit>
}
 1028860:	2000      	movs	r0, #0
 1028862:	bd70      	pop	{r4, r5, r6, pc}
		if (atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
 1028864:	210a      	movs	r1, #10
 1028866:	4628      	mov	r0, r5
 1028868:	f7ff ff1e 	bl	10286a8 <atomic_test_bit>
 102886c:	2800      	cmp	r0, #0
 102886e:	d1f3      	bne.n	1028858 <smp_dhkey_check+0x30>
		return compute_and_check_and_send_periph_dhcheck(smp);
 1028870:	4620      	mov	r0, r4
}
 1028872:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return compute_and_check_and_send_periph_dhcheck(smp);
 1028876:	f7e6 be8b 	b.w	100f590 <compute_and_check_and_send_periph_dhcheck>

0102887a <smp_signing_info>:
static uint8_t smp_signing_info(struct bt_smp *smp, struct net_buf *buf)
 102887a:	2007      	movs	r0, #7
 102887c:	4770      	bx	lr

0102887e <atomic_test_and_clear_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
 102887e:	2301      	movs	r3, #1
 1028880:	fa03 f101 	lsl.w	r1, r3, r1
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 1028884:	43ca      	mvns	r2, r1
{
 1028886:	b530      	push	{r4, r5, lr}
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1028888:	e8d0 3fef 	ldaex	r3, [r0]
 102888c:	ea03 0402 	and.w	r4, r3, r2
 1028890:	e8c0 4fe5 	stlex	r5, r4, [r0]
 1028894:	2d00      	cmp	r5, #0
 1028896:	d1f7      	bne.n	1028888 <atomic_test_and_clear_bit+0xa>
	return (old & mask) != 0;
 1028898:	4219      	tst	r1, r3
}
 102889a:	bf14      	ite	ne
 102889c:	2001      	movne	r0, #1
 102889e:	2000      	moveq	r0, #0
 10288a0:	bd30      	pop	{r4, r5, pc}

010288a2 <smp_reset>:
{
 10288a2:	b538      	push	{r3, r4, r5, lr}
 10288a4:	4604      	mov	r4, r0
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 10288a6:	2500      	movs	r5, #0
 10288a8:	1d03      	adds	r3, r0, #4
 10288aa:	e8d3 2fef 	ldaex	r2, [r3]
 10288ae:	e8c3 5fe1 	stlex	r1, r5, [r3]
 10288b2:	2900      	cmp	r1, #0
 10288b4:	d1f9      	bne.n	10288aa <smp_reset+0x8>
	(void)k_work_cancel_delayable(&smp->work);
 10288b6:	f504 70f4 	add.w	r0, r4, #488	; 0x1e8
 10288ba:	f7f9 fc49 	bl	1022150 <k_work_cancel_delayable>
	smp->method = JUST_WORKS;
 10288be:	7225      	strb	r5, [r4, #8]
 10288c0:	e8d4 3fef 	ldaex	r3, [r4]
 10288c4:	e8c4 5fe2 	stlex	r2, r5, [r4]
 10288c8:	2a00      	cmp	r2, #0
 10288ca:	d1f9      	bne.n	10288c0 <smp_reset+0x1e>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
 10288cc:	4620      	mov	r0, r4
}
 10288ce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
 10288d2:	2101      	movs	r1, #1
 10288d4:	f7ff bf47 	b.w	1028766 <atomic_set_bit>

010288d8 <smp_c1>:
{
 10288d8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 10288dc:	4699      	mov	r9, r3
 10288de:	b089      	sub	sp, #36	; 0x24
 10288e0:	e9dd 7810 	ldrd	r7, r8, [sp, #64]	; 0x40
	p1[0] = ia->type;
 10288e4:	783b      	ldrb	r3, [r7, #0]
{
 10288e6:	460c      	mov	r4, r1
	p1[0] = ia->type;
 10288e8:	f88d 3000 	strb.w	r3, [sp]
	p1[1] = ra->type;
 10288ec:	f898 3000 	ldrb.w	r3, [r8]
{
 10288f0:	4611      	mov	r1, r2
 10288f2:	9d12      	ldr	r5, [sp, #72]	; 0x48
	memcpy(p1 + 2, preq, 7);
 10288f4:	2207      	movs	r2, #7
{
 10288f6:	4606      	mov	r6, r0
	memcpy(p1 + 2, preq, 7);
 10288f8:	f10d 0002 	add.w	r0, sp, #2
	p1[1] = ra->type;
 10288fc:	f88d 3001 	strb.w	r3, [sp, #1]
	memcpy(p1 + 2, preq, 7);
 1028900:	f7fe f838 	bl	1026974 <memcpy>
	memcpy(p1 + 9, pres, 7);
 1028904:	2207      	movs	r2, #7
 1028906:	4649      	mov	r1, r9
 1028908:	f10d 0009 	add.w	r0, sp, #9
 102890c:	f7fe f832 	bl	1026974 <memcpy>
 1028910:	462a      	mov	r2, r5
 1028912:	4669      	mov	r1, sp
 1028914:	f104 0010 	add.w	r0, r4, #16
		*r++ = *p++ ^ *q++;
 1028918:	f814 3b01 	ldrb.w	r3, [r4], #1
 102891c:	f811 cb01 	ldrb.w	ip, [r1], #1
	while (len--) {
 1028920:	4284      	cmp	r4, r0
		*r++ = *p++ ^ *q++;
 1028922:	ea83 030c 	eor.w	r3, r3, ip
 1028926:	f802 3b01 	strb.w	r3, [r2], #1
	while (len--) {
 102892a:	d1f5      	bne.n	1028918 <smp_c1+0x40>
	err = bt_encrypt_le(k, enc_data, enc_data);
 102892c:	462a      	mov	r2, r5
 102892e:	4629      	mov	r1, r5
 1028930:	4630      	mov	r0, r6
 1028932:	f7ea ffff 	bl	1013934 <bt_encrypt_le>
	if (err) {
 1028936:	4604      	mov	r4, r0
 1028938:	bb20      	cbnz	r0, 1028984 <smp_c1+0xac>
	memcpy(p2, ra->a.val, 6);
 102893a:	2206      	movs	r2, #6
 102893c:	f108 0101 	add.w	r1, r8, #1
 1028940:	a804      	add	r0, sp, #16
 1028942:	f7fe f817 	bl	1026974 <memcpy>
	memcpy(p2 + 6, ia->a.val, 6);
 1028946:	2206      	movs	r2, #6
 1028948:	1c79      	adds	r1, r7, #1
 102894a:	f10d 0016 	add.w	r0, sp, #22
 102894e:	f7fe f811 	bl	1026974 <memcpy>
	(void)memset(p2 + 12, 0, 4);
 1028952:	2204      	movs	r2, #4
 1028954:	4621      	mov	r1, r4
 1028956:	a807      	add	r0, sp, #28
 1028958:	f7fe f817 	bl	102698a <memset>
 102895c:	462a      	mov	r2, r5
 102895e:	f105 0010 	add.w	r0, r5, #16
 1028962:	ab04      	add	r3, sp, #16
		*r++ = *p++ ^ *q++;
 1028964:	f812 1b01 	ldrb.w	r1, [r2], #1
 1028968:	f813 4b01 	ldrb.w	r4, [r3], #1
	while (len--) {
 102896c:	4282      	cmp	r2, r0
		*r++ = *p++ ^ *q++;
 102896e:	ea81 0104 	eor.w	r1, r1, r4
 1028972:	f802 1c01 	strb.w	r1, [r2, #-1]
	while (len--) {
 1028976:	d1f5      	bne.n	1028964 <smp_c1+0x8c>
	return bt_encrypt_le(k, enc_data, enc_data);
 1028978:	462a      	mov	r2, r5
 102897a:	4629      	mov	r1, r5
 102897c:	4630      	mov	r0, r6
 102897e:	f7ea ffd9 	bl	1013934 <bt_encrypt_le>
 1028982:	4604      	mov	r4, r0
}
 1028984:	4620      	mov	r0, r4
 1028986:	b009      	add	sp, #36	; 0x24
 1028988:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0102898c <legacy_pairing_confirm>:
{
 102898c:	b5f0      	push	{r4, r5, r6, r7, lr}
		if (!atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
 102898e:	1d07      	adds	r7, r0, #4
{
 1028990:	4604      	mov	r4, r0
 1028992:	b085      	sub	sp, #20
		if (!atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
 1028994:	210a      	movs	r1, #10
 1028996:	4638      	mov	r0, r7
 1028998:	f7ff fe86 	bl	10286a8 <atomic_test_bit>
 102899c:	bb88      	cbnz	r0, 1028a02 <legacy_pairing_confirm+0x76>
			atomic_set_bit(smp->allowed_cmds,
 102899e:	2104      	movs	r1, #4
 10289a0:	4620      	mov	r0, r4
 10289a2:	f7ff fee0 	bl	1028766 <atomic_set_bit>
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_CONFIRM, sizeof(*req));
 10289a6:	2103      	movs	r1, #3
	struct bt_conn *conn = smp->chan.chan.conn;
 10289a8:	f8d4 60f0 	ldr.w	r6, [r4, #240]	; 0xf0
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_CONFIRM, sizeof(*req));
 10289ac:	f7ff feeb 	bl	1028786 <smp_create_pdu.constprop.0>
	if (!buf) {
 10289b0:	4605      	mov	r5, r0
 10289b2:	b1c0      	cbz	r0, 10289e6 <legacy_pairing_confirm+0x5a>
 10289b4:	2110      	movs	r1, #16
 10289b6:	300c      	adds	r0, #12
 10289b8:	f7f5 fc6e 	bl	101e298 <net_buf_simple_add>
		   &conn->le.init_addr, &conn->le.resp_addr, req->val)) {
 10289bc:	f106 039e 	add.w	r3, r6, #158	; 0x9e
 10289c0:	3697      	adds	r6, #151	; 0x97
	if (smp_c1(smp->tk, smp->prnd, smp->preq, smp->prsp,
 10289c2:	9002      	str	r0, [sp, #8]
 10289c4:	9301      	str	r3, [sp, #4]
 10289c6:	9600      	str	r6, [sp, #0]
 10289c8:	f104 0310 	add.w	r3, r4, #16
 10289cc:	f104 0209 	add.w	r2, r4, #9
 10289d0:	f104 0127 	add.w	r1, r4, #39	; 0x27
 10289d4:	f104 0047 	add.w	r0, r4, #71	; 0x47
 10289d8:	f7ff ff7e 	bl	10288d8 <smp_c1>
 10289dc:	4606      	mov	r6, r0
 10289de:	b128      	cbz	r0, 10289ec <legacy_pairing_confirm+0x60>
		net_buf_unref(buf);
 10289e0:	4628      	mov	r0, r5
 10289e2:	f7f5 fafd 	bl	101dfe0 <net_buf_unref>
		return BT_SMP_ERR_UNSPECIFIED;
 10289e6:	2008      	movs	r0, #8
}
 10289e8:	b005      	add	sp, #20
 10289ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
	smp_send(smp, buf, NULL, NULL);
 10289ec:	4602      	mov	r2, r0
 10289ee:	4629      	mov	r1, r5
 10289f0:	4620      	mov	r0, r4
 10289f2:	f7ff fe8d 	bl	1028710 <smp_send.constprop.0>
	atomic_clear_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
 10289f6:	4631      	mov	r1, r6
 10289f8:	4638      	mov	r0, r7
 10289fa:	f7ff fe7c 	bl	10286f6 <atomic_clear_bit>
	return 0;
 10289fe:	2000      	movs	r0, #0
 1028a00:	e7f2      	b.n	10289e8 <legacy_pairing_confirm+0x5c>
		atomic_set_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
 1028a02:	2100      	movs	r1, #0
 1028a04:	4638      	mov	r0, r7
 1028a06:	f7ff feae 	bl	1028766 <atomic_set_bit>
	return 0;
 1028a0a:	e7f8      	b.n	10289fe <legacy_pairing_confirm+0x72>

01028a0c <bt_smp_request_ltk>:
{
 1028a0c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 1028a10:	9f09      	ldr	r7, [sp, #36]	; 0x24
 1028a12:	4604      	mov	r4, r0
 1028a14:	e9cd 2300 	strd	r2, r3, [sp]
	smp = smp_chan_get(conn);
 1028a18:	f7ff fe9a 	bl	1028750 <smp_chan_get>
	if (!smp) {
 1028a1c:	4605      	mov	r5, r0
 1028a1e:	2800      	cmp	r0, #0
 1028a20:	d07c      	beq.n	1028b1c <bt_smp_request_ltk+0x110>
	if (ediv == 0U && rand == 0U &&
 1028a22:	f8bd 8020 	ldrh.w	r8, [sp, #32]
	    atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) &&
 1028a26:	1d06      	adds	r6, r0, #4
	if (ediv == 0U && rand == 0U &&
 1028a28:	f1b8 0f00 	cmp.w	r8, #0
 1028a2c:	d128      	bne.n	1028a80 <bt_smp_request_ltk+0x74>
 1028a2e:	e9dd 3200 	ldrd	r3, r2, [sp]
 1028a32:	4313      	orrs	r3, r2
 1028a34:	d124      	bne.n	1028a80 <bt_smp_request_ltk+0x74>
	    atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) &&
 1028a36:	2103      	movs	r1, #3
 1028a38:	4630      	mov	r0, r6
 1028a3a:	f7ff fe35 	bl	10286a8 <atomic_test_bit>
	if (ediv == 0U && rand == 0U &&
 1028a3e:	b1f8      	cbz	r0, 1028a80 <bt_smp_request_ltk+0x74>
	    atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
 1028a40:	2101      	movs	r1, #1
 1028a42:	4630      	mov	r0, r6
 1028a44:	f7ff fe30 	bl	10286a8 <atomic_test_bit>
	    atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) &&
 1028a48:	b1d0      	cbz	r0, 1028a80 <bt_smp_request_ltk+0x74>
	return MIN(req->max_key_size, rsp->max_key_size);
 1028a4a:	7d2c      	ldrb	r4, [r5, #20]
 1028a4c:	7b6b      	ldrb	r3, [r5, #13]
		memcpy(ltk, smp->tk, enc_size);
 1028a4e:	f105 0147 	add.w	r1, r5, #71	; 0x47
	return MIN(req->max_key_size, rsp->max_key_size);
 1028a52:	429c      	cmp	r4, r3
 1028a54:	bf28      	it	cs
 1028a56:	461c      	movcs	r4, r3
		memcpy(ltk, smp->tk, enc_size);
 1028a58:	4622      	mov	r2, r4
		memcpy(ltk, conn->le.keys->ltk.val, enc_size);
 1028a5a:	4638      	mov	r0, r7
 1028a5c:	f7fd ff8a 	bl	1026974 <memcpy>
		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
 1028a60:	2c0f      	cmp	r4, #15
 1028a62:	d805      	bhi.n	1028a70 <bt_smp_request_ltk+0x64>
			(void)memset(ltk + enc_size, 0,
 1028a64:	4641      	mov	r1, r8
 1028a66:	f1c4 0210 	rsb	r2, r4, #16
 1028a6a:	1938      	adds	r0, r7, r4
 1028a6c:	f7fd ff8d 	bl	102698a <memset>
		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
 1028a70:	4630      	mov	r0, r6
 1028a72:	2101      	movs	r1, #1
 1028a74:	f7ff fe77 	bl	1028766 <atomic_set_bit>
		return true;
 1028a78:	2001      	movs	r0, #1
}
 1028a7a:	b002      	add	sp, #8
 1028a7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!conn->le.keys) {
 1028a80:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 1028a84:	b983      	cbnz	r3, 1028aa8 <bt_smp_request_ltk+0x9c>
					     &conn->le.dst);
 1028a86:	f104 0890 	add.w	r8, r4, #144	; 0x90
		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256, conn->id,
 1028a8a:	4642      	mov	r2, r8
 1028a8c:	2020      	movs	r0, #32
 1028a8e:	7a21      	ldrb	r1, [r4, #8]
 1028a90:	f7e7 fe6e 	bl	1010770 <bt_keys_find>
 1028a94:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
		if (!conn->le.keys) {
 1028a98:	b930      	cbnz	r0, 1028aa8 <bt_smp_request_ltk+0x9c>
			conn->le.keys = bt_keys_find(BT_KEYS_PERIPH_LTK,
 1028a9a:	4642      	mov	r2, r8
 1028a9c:	2001      	movs	r0, #1
 1028a9e:	7a21      	ldrb	r1, [r4, #8]
 1028aa0:	f7e7 fe66 	bl	1010770 <bt_keys_find>
 1028aa4:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
	if (ediv == 0U && rand == 0U &&
 1028aa8:	f8bd 8020 	ldrh.w	r8, [sp, #32]
	    conn->le.keys && (conn->le.keys->keys & BT_KEYS_LTK_P256)) {
 1028aac:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
	if (ediv == 0U && rand == 0U &&
 1028ab0:	f1b8 0f00 	cmp.w	r8, #0
 1028ab4:	d10c      	bne.n	1028ad0 <bt_smp_request_ltk+0xc4>
 1028ab6:	e9dd 3200 	ldrd	r3, r2, [sp]
 1028aba:	4313      	orrs	r3, r2
 1028abc:	d108      	bne.n	1028ad0 <bt_smp_request_ltk+0xc4>
 1028abe:	b300      	cbz	r0, 1028b02 <bt_smp_request_ltk+0xf6>
	    conn->le.keys && (conn->le.keys->keys & BT_KEYS_LTK_P256)) {
 1028ac0:	89c3      	ldrh	r3, [r0, #14]
 1028ac2:	069a      	lsls	r2, r3, #26
 1028ac4:	d505      	bpl.n	1028ad2 <bt_smp_request_ltk+0xc6>
		enc_size = conn->le.keys->enc_size;
 1028ac6:	7b04      	ldrb	r4, [r0, #12]
		memcpy(ltk, conn->le.keys->ltk.val, enc_size);
 1028ac8:	f100 011a 	add.w	r1, r0, #26
 1028acc:	4622      	mov	r2, r4
 1028ace:	e7c4      	b.n	1028a5a <bt_smp_request_ltk+0x4e>
	if (conn->le.keys && (conn->le.keys->keys & BT_KEYS_PERIPH_LTK) &&
 1028ad0:	b1b8      	cbz	r0, 1028b02 <bt_smp_request_ltk+0xf6>
 1028ad2:	89c3      	ldrh	r3, [r0, #14]
 1028ad4:	07db      	lsls	r3, r3, #31
 1028ad6:	d514      	bpl.n	1028b02 <bt_smp_request_ltk+0xf6>
	    !memcmp(conn->le.keys->periph_ltk.rand, &rand, 8) &&
 1028ad8:	2208      	movs	r2, #8
 1028ada:	4669      	mov	r1, sp
 1028adc:	3040      	adds	r0, #64	; 0x40
 1028ade:	f7fd ff39 	bl	1026954 <memcmp>
	if (conn->le.keys && (conn->le.keys->keys & BT_KEYS_PERIPH_LTK) &&
 1028ae2:	b970      	cbnz	r0, 1028b02 <bt_smp_request_ltk+0xf6>
	    !memcmp(conn->le.keys->periph_ltk.ediv, &ediv, 2)) {
 1028ae4:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
 1028ae8:	2202      	movs	r2, #2
 1028aea:	a908      	add	r1, sp, #32
 1028aec:	3048      	adds	r0, #72	; 0x48
 1028aee:	f7fd ff31 	bl	1026954 <memcmp>
	    !memcmp(conn->le.keys->periph_ltk.rand, &rand, 8) &&
 1028af2:	4680      	mov	r8, r0
 1028af4:	b928      	cbnz	r0, 1028b02 <bt_smp_request_ltk+0xf6>
		enc_size = conn->le.keys->enc_size;
 1028af6:	f8d4 10c0 	ldr.w	r1, [r4, #192]	; 0xc0
 1028afa:	7b0c      	ldrb	r4, [r1, #12]
		memcpy(ltk, conn->le.keys->periph_ltk.val, enc_size);
 1028afc:	314a      	adds	r1, #74	; 0x4a
 1028afe:	4622      	mov	r2, r4
 1028b00:	e7ab      	b.n	1028a5a <bt_smp_request_ltk+0x4e>
	if (atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ)) {
 1028b02:	210f      	movs	r1, #15
 1028b04:	4630      	mov	r0, r6
 1028b06:	f7ff fdcf 	bl	10286a8 <atomic_test_bit>
 1028b0a:	b120      	cbz	r0, 1028b16 <bt_smp_request_ltk+0x10a>
		bt_conn_security_changed(conn, BT_HCI_ERR_PIN_OR_KEY_MISSING,
 1028b0c:	2202      	movs	r2, #2
 1028b0e:	2106      	movs	r1, #6
 1028b10:	4620      	mov	r0, r4
 1028b12:	f7e1 fd65 	bl	100a5e0 <bt_conn_security_changed>
	smp_reset(smp);
 1028b16:	4628      	mov	r0, r5
 1028b18:	f7ff fec3 	bl	10288a2 <smp_reset>
		return false;
 1028b1c:	2000      	movs	r0, #0
 1028b1e:	e7ac      	b.n	1028a7a <bt_smp_request_ltk+0x6e>

01028b20 <bt_smp_sign>:
int bt_smp_sign(struct bt_conn *conn, struct net_buf *buf)
 1028b20:	f06f 0085 	mvn.w	r0, #133	; 0x85
 1028b24:	4770      	bx	lr

01028b26 <bt_smp_dhkey_ready>:
{
 1028b26:	b570      	push	{r4, r5, r6, lr}
 1028b28:	4606      	mov	r6, r0
	struct bt_smp *smp = smp_find(SMP_FLAG_DHKEY_GEN);
 1028b2a:	2008      	movs	r0, #8
 1028b2c:	f7e6 f87c 	bl	100ec28 <smp_find>
	if (smp) {
 1028b30:	4604      	mov	r4, r0
 1028b32:	b1b8      	cbz	r0, 1028b64 <bt_smp_dhkey_ready+0x3e>
		atomic_clear_bit(smp->flags, SMP_FLAG_DHKEY_GEN);
 1028b34:	1d05      	adds	r5, r0, #4
 1028b36:	2108      	movs	r1, #8
 1028b38:	4628      	mov	r0, r5
 1028b3a:	f7ff fddc 	bl	10286f6 <atomic_clear_bit>
	if (!dhkey) {
 1028b3e:	b38e      	cbz	r6, 1028ba4 <bt_smp_dhkey_ready+0x7e>
	atomic_clear_bit(smp->flags, SMP_FLAG_DHKEY_PENDING);
 1028b40:	2107      	movs	r1, #7
 1028b42:	f7ff fdd8 	bl	10286f6 <atomic_clear_bit>
	memcpy(smp->dhkey, dhkey, BT_DH_KEY_LEN);
 1028b46:	4631      	mov	r1, r6
 1028b48:	2220      	movs	r2, #32
 1028b4a:	f104 0097 	add.w	r0, r4, #151	; 0x97
 1028b4e:	f7fd ff11 	bl	1026974 <memcpy>
	if (atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
 1028b52:	210a      	movs	r1, #10
 1028b54:	4628      	mov	r0, r5
 1028b56:	f7ff fda7 	bl	10286a8 <atomic_test_bit>
 1028b5a:	b168      	cbz	r0, 1028b78 <bt_smp_dhkey_ready+0x52>
		atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
 1028b5c:	2109      	movs	r1, #9
		atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
 1028b5e:	4628      	mov	r0, r5
 1028b60:	f7ff fe01 	bl	1028766 <atomic_set_bit>
		smp = smp_find(SMP_FLAG_DHKEY_PENDING);
 1028b64:	2007      	movs	r0, #7
 1028b66:	f7e6 f85f 	bl	100ec28 <smp_find>
		if (smp) {
 1028b6a:	4604      	mov	r4, r0
 1028b6c:	b118      	cbz	r0, 1028b76 <bt_smp_dhkey_ready+0x50>
			err = smp_dhkey_generate(smp);
 1028b6e:	f7e6 f943 	bl	100edf8 <smp_dhkey_generate>
			if (err) {
 1028b72:	4601      	mov	r1, r0
 1028b74:	b990      	cbnz	r0, 1028b9c <bt_smp_dhkey_ready+0x76>
}
 1028b76:	bd70      	pop	{r4, r5, r6, pc}
	if (atomic_test_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT)) {
 1028b78:	2110      	movs	r1, #16
 1028b7a:	4628      	mov	r0, r5
 1028b7c:	f7ff fd94 	bl	10286a8 <atomic_test_bit>
		atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
 1028b80:	2109      	movs	r1, #9
	if (atomic_test_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT)) {
 1028b82:	2800      	cmp	r0, #0
 1028b84:	d1eb      	bne.n	1028b5e <bt_smp_dhkey_ready+0x38>
	if (atomic_test_bit(smp->flags, SMP_FLAG_DHKEY_SEND)) {
 1028b86:	4628      	mov	r0, r5
 1028b88:	f7ff fd8e 	bl	10286a8 <atomic_test_bit>
 1028b8c:	2800      	cmp	r0, #0
 1028b8e:	d0e9      	beq.n	1028b64 <bt_smp_dhkey_ready+0x3e>
		return  compute_and_check_and_send_periph_dhcheck(smp);
 1028b90:	4620      	mov	r0, r4
 1028b92:	f7e6 fcfd 	bl	100f590 <compute_and_check_and_send_periph_dhcheck>
		if (err) {
 1028b96:	4601      	mov	r1, r0
 1028b98:	2800      	cmp	r0, #0
 1028b9a:	d0e3      	beq.n	1028b64 <bt_smp_dhkey_ready+0x3e>
			smp_error(smp, err);
 1028b9c:	4620      	mov	r0, r4
 1028b9e:	f7e7 f86f 	bl	100fc80 <smp_error>
 1028ba2:	e7df      	b.n	1028b64 <bt_smp_dhkey_ready+0x3e>
		return BT_SMP_ERR_DHKEY_CHECK_FAILED;
 1028ba4:	210b      	movs	r1, #11
 1028ba6:	e7f9      	b.n	1028b9c <bt_smp_dhkey_ready+0x76>

01028ba8 <bt_smp_disconnected>:
{
 1028ba8:	b570      	push	{r4, r5, r6, lr}
 1028baa:	4604      	mov	r4, r0
	struct bt_smp *smp = CONTAINER_OF(chan, struct bt_smp, chan);
 1028bac:	f1a0 06f0 	sub.w	r6, r0, #240	; 0xf0
	struct bt_keys *keys = chan->conn->le.keys;
 1028bb0:	f850 3bf8 	ldr.w	r3, [r0], #248
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) ||
 1028bb4:	3cec      	subs	r4, #236	; 0xec
	struct bt_keys *keys = chan->conn->le.keys;
 1028bb6:	f8d3 50c0 	ldr.w	r5, [r3, #192]	; 0xc0
	(void)k_work_cancel_delayable(&smp->work);
 1028bba:	f7f9 fac9 	bl	1022150 <k_work_cancel_delayable>
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) ||
 1028bbe:	2103      	movs	r1, #3
 1028bc0:	4620      	mov	r0, r4
 1028bc2:	f7ff fd71 	bl	10286a8 <atomic_test_bit>
 1028bc6:	b1a0      	cbz	r0, 1028bf2 <bt_smp_disconnected+0x4a>
		smp_pairing_complete(smp, BT_SMP_ERR_UNSPECIFIED);
 1028bc8:	2108      	movs	r1, #8
 1028bca:	4630      	mov	r0, r6
 1028bcc:	f7e6 ffd4 	bl	100fb78 <smp_pairing_complete>
	if (keys) {
 1028bd0:	b13d      	cbz	r5, 1028be2 <bt_smp_disconnected+0x3a>
		if (!keys->keys || (!IS_ENABLED(CONFIG_BT_STORE_DEBUG_KEYS) &&
 1028bd2:	89eb      	ldrh	r3, [r5, #14]
 1028bd4:	b113      	cbz	r3, 1028bdc <bt_smp_disconnected+0x34>
 1028bd6:	7b6b      	ldrb	r3, [r5, #13]
 1028bd8:	079b      	lsls	r3, r3, #30
 1028bda:	d502      	bpl.n	1028be2 <bt_smp_disconnected+0x3a>
			bt_keys_clear(keys);
 1028bdc:	4628      	mov	r0, r5
 1028bde:	f7e7 fecd 	bl	101097c <bt_keys_clear>
	(void)memset(smp, 0, sizeof(*smp));
 1028be2:	4630      	mov	r0, r6
}
 1028be4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	(void)memset(smp, 0, sizeof(*smp));
 1028be8:	f44f 7208 	mov.w	r2, #544	; 0x220
 1028bec:	2100      	movs	r1, #0
 1028bee:	f7fd becc 	b.w	102698a <memset>
	    atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING) ||
 1028bf2:	2101      	movs	r1, #1
 1028bf4:	4620      	mov	r0, r4
 1028bf6:	f7ff fd57 	bl	10286a8 <atomic_test_bit>
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) ||
 1028bfa:	2800      	cmp	r0, #0
 1028bfc:	d1e4      	bne.n	1028bc8 <bt_smp_disconnected+0x20>
	    atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ)) {
 1028bfe:	210f      	movs	r1, #15
 1028c00:	4620      	mov	r0, r4
 1028c02:	f7ff fd51 	bl	10286a8 <atomic_test_bit>
	    atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING) ||
 1028c06:	2800      	cmp	r0, #0
 1028c08:	d1de      	bne.n	1028bc8 <bt_smp_disconnected+0x20>
 1028c0a:	e7e1      	b.n	1028bd0 <bt_smp_disconnected+0x28>

01028c0c <sys_mem_swap.constprop.0>:
static inline void sys_mem_swap(void *buf, size_t length)
 1028c0c:	b510      	push	{r4, lr}
 1028c0e:	1e43      	subs	r3, r0, #1
 1028c10:	f100 0210 	add.w	r2, r0, #16
 1028c14:	3007      	adds	r0, #7
		uint8_t tmp = ((uint8_t *)buf)[i];
 1028c16:	f813 1f01 	ldrb.w	r1, [r3, #1]!
		((uint8_t *)buf)[i] = ((uint8_t *)buf)[length - 1 - i];
 1028c1a:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
	for (i = 0; i < (length/2); i++) {
 1028c1e:	4283      	cmp	r3, r0
		((uint8_t *)buf)[i] = ((uint8_t *)buf)[length - 1 - i];
 1028c20:	701c      	strb	r4, [r3, #0]
		((uint8_t *)buf)[length - 1 - i] = tmp;
 1028c22:	7011      	strb	r1, [r2, #0]
	for (i = 0; i < (length/2); i++) {
 1028c24:	d1f7      	bne.n	1028c16 <sys_mem_swap.constprop.0+0xa>
	}
}
 1028c26:	bd10      	pop	{r4, pc}

01028c28 <bt_crypto_aes_cmac>:
{
 1028c28:	b570      	push	{r4, r5, r6, lr}
 1028c2a:	b0c2      	sub	sp, #264	; 0x108
 1028c2c:	460d      	mov	r5, r1
 1028c2e:	4616      	mov	r6, r2
	if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
 1028c30:	4601      	mov	r1, r0
 1028c32:	aa16      	add	r2, sp, #88	; 0x58
 1028c34:	4668      	mov	r0, sp
{
 1028c36:	461c      	mov	r4, r3
	if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
 1028c38:	f7fd fcd2 	bl	10265e0 <tc_cmac_setup>
 1028c3c:	b918      	cbnz	r0, 1028c46 <bt_crypto_aes_cmac+0x1e>
		return -EIO;
 1028c3e:	f06f 0004 	mvn.w	r0, #4
}
 1028c42:	b042      	add	sp, #264	; 0x108
 1028c44:	bd70      	pop	{r4, r5, r6, pc}
	if (tc_cmac_update(&state, in, len) == TC_CRYPTO_FAIL) {
 1028c46:	4632      	mov	r2, r6
 1028c48:	4629      	mov	r1, r5
 1028c4a:	4668      	mov	r0, sp
 1028c4c:	f7fd fcf3 	bl	1026636 <tc_cmac_update>
 1028c50:	2800      	cmp	r0, #0
 1028c52:	d0f4      	beq.n	1028c3e <bt_crypto_aes_cmac+0x16>
	if (tc_cmac_final(out, &state) == TC_CRYPTO_FAIL) {
 1028c54:	4669      	mov	r1, sp
 1028c56:	4620      	mov	r0, r4
 1028c58:	f7fd fd57 	bl	102670a <tc_cmac_final>
 1028c5c:	2800      	cmp	r0, #0
 1028c5e:	d0ee      	beq.n	1028c3e <bt_crypto_aes_cmac+0x16>
	return 0;
 1028c60:	2000      	movs	r0, #0
 1028c62:	e7ee      	b.n	1028c42 <bt_crypto_aes_cmac+0x1a>

01028c64 <bt_crypto_f4>:
{
 1028c64:	b5f0      	push	{r4, r5, r6, r7, lr}
 1028c66:	460e      	mov	r6, r1
 1028c68:	4614      	mov	r4, r2
 1028c6a:	461d      	mov	r5, r3
 1028c6c:	b097      	sub	sp, #92	; 0x5c
	sys_memcpy_swap(m, u, 32);
 1028c6e:	4601      	mov	r1, r0
 1028c70:	2220      	movs	r2, #32
 1028c72:	a805      	add	r0, sp, #20
{
 1028c74:	9f1c      	ldr	r7, [sp, #112]	; 0x70
	sys_memcpy_swap(m, u, 32);
 1028c76:	f7e7 ffdf 	bl	1010c38 <sys_memcpy_swap>
	sys_memcpy_swap(m + 32, v, 32);
 1028c7a:	2220      	movs	r2, #32
 1028c7c:	4631      	mov	r1, r6
 1028c7e:	a80d      	add	r0, sp, #52	; 0x34
 1028c80:	f7e7 ffda 	bl	1010c38 <sys_memcpy_swap>
	sys_memcpy_swap(xs, x, 16);
 1028c84:	4621      	mov	r1, r4
 1028c86:	2210      	movs	r2, #16
 1028c88:	a801      	add	r0, sp, #4
	m[64] = z;
 1028c8a:	f88d 5054 	strb.w	r5, [sp, #84]	; 0x54
	sys_memcpy_swap(xs, x, 16);
 1028c8e:	f7e7 ffd3 	bl	1010c38 <sys_memcpy_swap>
	err = bt_crypto_aes_cmac(xs, m, sizeof(m), res);
 1028c92:	463b      	mov	r3, r7
 1028c94:	2241      	movs	r2, #65	; 0x41
 1028c96:	a905      	add	r1, sp, #20
 1028c98:	a801      	add	r0, sp, #4
 1028c9a:	f7ff ffc5 	bl	1028c28 <bt_crypto_aes_cmac>
	if (err) {
 1028c9e:	4604      	mov	r4, r0
 1028ca0:	b910      	cbnz	r0, 1028ca8 <bt_crypto_f4+0x44>
	sys_mem_swap(res, 16);
 1028ca2:	4638      	mov	r0, r7
 1028ca4:	f7ff ffb2 	bl	1028c0c <sys_mem_swap.constprop.0>
}
 1028ca8:	4620      	mov	r0, r4
 1028caa:	b017      	add	sp, #92	; 0x5c
 1028cac:	bdf0      	pop	{r4, r5, r6, r7, pc}

01028cae <bt_crypto_f6>:
{
 1028cae:	b5f0      	push	{r4, r5, r6, r7, lr}
 1028cb0:	4616      	mov	r6, r2
 1028cb2:	461c      	mov	r4, r3
 1028cb4:	4605      	mov	r5, r0
 1028cb6:	b097      	sub	sp, #92	; 0x5c
	sys_memcpy_swap(m, n1, 16);
 1028cb8:	2210      	movs	r2, #16
 1028cba:	a805      	add	r0, sp, #20
{
 1028cbc:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
	sys_memcpy_swap(m, n1, 16);
 1028cbe:	f7e7 ffbb 	bl	1010c38 <sys_memcpy_swap>
	sys_memcpy_swap(m + 16, n2, 16);
 1028cc2:	2210      	movs	r2, #16
 1028cc4:	4631      	mov	r1, r6
 1028cc6:	a809      	add	r0, sp, #36	; 0x24
 1028cc8:	f7e7 ffb6 	bl	1010c38 <sys_memcpy_swap>
	sys_memcpy_swap(m + 32, r, 16);
 1028ccc:	4621      	mov	r1, r4
 1028cce:	2210      	movs	r2, #16
 1028cd0:	a80d      	add	r0, sp, #52	; 0x34
 1028cd2:	f7e7 ffb1 	bl	1010c38 <sys_memcpy_swap>
	sys_memcpy_swap(m + 48, iocap, 3);
 1028cd6:	2203      	movs	r2, #3
 1028cd8:	991c      	ldr	r1, [sp, #112]	; 0x70
 1028cda:	a811      	add	r0, sp, #68	; 0x44
 1028cdc:	f7e7 ffac 	bl	1010c38 <sys_memcpy_swap>
	m[51] = a1->type;
 1028ce0:	9c1d      	ldr	r4, [sp, #116]	; 0x74
	memcpy(m + 52, a1->a.val, 6);
 1028ce2:	2206      	movs	r2, #6
	m[51] = a1->type;
 1028ce4:	f814 3b01 	ldrb.w	r3, [r4], #1
	memcpy(m + 52, a1->a.val, 6);
 1028ce8:	a812      	add	r0, sp, #72	; 0x48
 1028cea:	4621      	mov	r1, r4
	m[51] = a1->type;
 1028cec:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
	memcpy(m + 52, a1->a.val, 6);
 1028cf0:	f7fd fe40 	bl	1026974 <memcpy>
	sys_memcpy_swap(m + 52, a1->a.val, 6);
 1028cf4:	4621      	mov	r1, r4
 1028cf6:	2206      	movs	r2, #6
 1028cf8:	a812      	add	r0, sp, #72	; 0x48
 1028cfa:	f7e7 ff9d 	bl	1010c38 <sys_memcpy_swap>
	m[58] = a2->type;
 1028cfe:	9c1e      	ldr	r4, [sp, #120]	; 0x78
	memcpy(m + 59, a2->a.val, 6);
 1028d00:	2206      	movs	r2, #6
	m[58] = a2->type;
 1028d02:	f814 3b01 	ldrb.w	r3, [r4], #1
	memcpy(m + 59, a2->a.val, 6);
 1028d06:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
 1028d0a:	4621      	mov	r1, r4
	m[58] = a2->type;
 1028d0c:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
	memcpy(m + 59, a2->a.val, 6);
 1028d10:	f7fd fe30 	bl	1026974 <memcpy>
	sys_memcpy_swap(m + 59, a2->a.val, 6);
 1028d14:	4621      	mov	r1, r4
 1028d16:	2206      	movs	r2, #6
 1028d18:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
 1028d1c:	f7e7 ff8c 	bl	1010c38 <sys_memcpy_swap>
	sys_memcpy_swap(ws, w, 16);
 1028d20:	2210      	movs	r2, #16
 1028d22:	4629      	mov	r1, r5
 1028d24:	a801      	add	r0, sp, #4
 1028d26:	f7e7 ff87 	bl	1010c38 <sys_memcpy_swap>
	err = bt_crypto_aes_cmac(ws, m, sizeof(m), check);
 1028d2a:	463b      	mov	r3, r7
 1028d2c:	2241      	movs	r2, #65	; 0x41
 1028d2e:	a905      	add	r1, sp, #20
 1028d30:	a801      	add	r0, sp, #4
 1028d32:	f7ff ff79 	bl	1028c28 <bt_crypto_aes_cmac>
	if (err) {
 1028d36:	4604      	mov	r4, r0
 1028d38:	b910      	cbnz	r0, 1028d40 <bt_crypto_f6+0x92>
	sys_mem_swap(check, 16);
 1028d3a:	4638      	mov	r0, r7
 1028d3c:	f7ff ff66 	bl	1028c0c <sys_mem_swap.constprop.0>
}
 1028d40:	4620      	mov	r0, r4
 1028d42:	b017      	add	sp, #92	; 0x5c
 1028d44:	bdf0      	pop	{r4, r5, r6, r7, pc}

01028d46 <fixed_data_unref>:
}
 1028d46:	4770      	bx	lr

01028d48 <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 1028d48:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
 1028d4a:	6849      	ldr	r1, [r1, #4]
 1028d4c:	6809      	ldr	r1, [r1, #0]
 1028d4e:	f7f5 b805 	b.w	101dd5c <net_buf_alloc_len>

01028d52 <net_buf_get>:
	return z_impl_k_queue_get(queue, timeout);
 1028d52:	f7f8 bc3b 	b.w	10215cc <z_impl_k_queue_get>

01028d56 <net_buf_simple_push_le16>:
{
 1028d56:	b510      	push	{r4, lr}
 1028d58:	460c      	mov	r4, r1
	sys_put_le16(val, net_buf_simple_push(buf, sizeof(val)));
 1028d5a:	2102      	movs	r1, #2
 1028d5c:	f7f5 fa40 	bl	101e1e0 <net_buf_simple_push>
	dst[0] = val;
 1028d60:	7004      	strb	r4, [r0, #0]
	dst[1] = val >> 8;
 1028d62:	0a24      	lsrs	r4, r4, #8
 1028d64:	7044      	strb	r4, [r0, #1]
}
 1028d66:	bd10      	pop	{r4, pc}

01028d68 <net_buf_simple_pull_le16>:
{
 1028d68:	b510      	push	{r4, lr}
	val = UNALIGNED_GET((uint16_t *)buf->data);
 1028d6a:	6803      	ldr	r3, [r0, #0]
	net_buf_simple_pull(buf, sizeof(val));
 1028d6c:	2102      	movs	r1, #2
	val = UNALIGNED_GET((uint16_t *)buf->data);
 1028d6e:	881c      	ldrh	r4, [r3, #0]
	net_buf_simple_pull(buf, sizeof(val));
 1028d70:	f7f5 fa56 	bl	101e220 <net_buf_simple_pull>
}
 1028d74:	4620      	mov	r0, r4
 1028d76:	bd10      	pop	{r4, pc}

01028d78 <net_buf_simple_headroom>:
	return buf->data - buf->__buf;
 1028d78:	6802      	ldr	r2, [r0, #0]
 1028d7a:	6880      	ldr	r0, [r0, #8]
}
 1028d7c:	1a10      	subs	r0, r2, r0
 1028d7e:	4770      	bx	lr

01028d80 <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
 1028d80:	8883      	ldrh	r3, [r0, #4]
 1028d82:	88c2      	ldrh	r2, [r0, #6]
	return buf->data - buf->__buf;
 1028d84:	6881      	ldr	r1, [r0, #8]
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
 1028d86:	1ad2      	subs	r2, r2, r3
	return buf->data - buf->__buf;
 1028d88:	6803      	ldr	r3, [r0, #0]
 1028d8a:	1a5b      	subs	r3, r3, r1
}
 1028d8c:	1ad0      	subs	r0, r2, r3
 1028d8e:	4770      	bx	lr

01028d90 <net_buf_simple_add_mem>:
{
 1028d90:	b538      	push	{r3, r4, r5, lr}
 1028d92:	460d      	mov	r5, r1
 1028d94:	4614      	mov	r4, r2
	return memcpy(net_buf_simple_add(buf, len), mem, len);
 1028d96:	4611      	mov	r1, r2
 1028d98:	f7f5 fa7e 	bl	101e298 <net_buf_simple_add>
 1028d9c:	4622      	mov	r2, r4
 1028d9e:	4629      	mov	r1, r5
}
 1028da0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return memcpy(net_buf_simple_add(buf, len), mem, len);
 1028da4:	f7fd bde6 	b.w	1026974 <memcpy>

01028da8 <net_buf_simple_add_u8>:
{
 1028da8:	b510      	push	{r4, lr}
 1028daa:	460c      	mov	r4, r1
	u8 = net_buf_simple_add(buf, 1);
 1028dac:	2101      	movs	r1, #1
 1028dae:	f7f5 fa73 	bl	101e298 <net_buf_simple_add>
	*u8 = val;
 1028db2:	7004      	strb	r4, [r0, #0]
}
 1028db4:	bd10      	pop	{r4, pc}

01028db6 <net_buf_simple_add_le16>:
{
 1028db6:	b510      	push	{r4, lr}
 1028db8:	460c      	mov	r4, r1
	sys_put_le16(val, net_buf_simple_add(buf, sizeof(val)));
 1028dba:	2102      	movs	r1, #2
 1028dbc:	f7f5 fa6c 	bl	101e298 <net_buf_simple_add>
	dst[0] = val;
 1028dc0:	7004      	strb	r4, [r0, #0]
	dst[1] = val >> 8;
 1028dc2:	0a24      	lsrs	r4, r4, #8
 1028dc4:	7044      	strb	r4, [r0, #1]
}
 1028dc6:	bd10      	pop	{r4, pc}

01028dc8 <set_on_state>:
	__asm__ volatile(
 1028dc8:	f04f 0320 	mov.w	r3, #32
 1028dcc:	f3ef 8211 	mrs	r2, BASEPRI
 1028dd0:	f383 8812 	msr	BASEPRI_MAX, r3
 1028dd4:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
 1028dd8:	6803      	ldr	r3, [r0, #0]
 1028dda:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 1028dde:	f043 0302 	orr.w	r3, r3, #2
 1028de2:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
 1028de4:	f382 8811 	msr	BASEPRI, r2
 1028de8:	f3bf 8f6f 	isb	sy
}
 1028dec:	4770      	bx	lr

01028dee <async_start>:
{
 1028dee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1028df0:	9f06      	ldr	r7, [sp, #24]
	struct nrf_clock_control_data *data = dev->data;
 1028df2:	6904      	ldr	r4, [r0, #16]
	return &data->subsys[type];
 1028df4:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
 1028df6:	f04f 0520 	mov.w	r5, #32
 1028dfa:	f3ef 8611 	mrs	r6, BASEPRI
 1028dfe:	f385 8812 	msr	BASEPRI_MAX, r5
 1028e02:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
 1028e06:	250c      	movs	r5, #12
 1028e08:	4369      	muls	r1, r5
 1028e0a:	440c      	add	r4, r1
 1028e0c:	6ca5      	ldr	r5, [r4, #72]	; 0x48
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
 1028e0e:	f005 0c07 	and.w	ip, r5, #7
 1028e12:	f1bc 0f01 	cmp.w	ip, #1
 1028e16:	d10b      	bne.n	1028e30 <async_start+0x42>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
 1028e18:	64a7      	str	r7, [r4, #72]	; 0x48
	__asm__ volatile(
 1028e1a:	f386 8811 	msr	BASEPRI, r6
 1028e1e:	f3bf 8f6f 	isb	sy
	subdata->user_data = user_data;
 1028e22:	e9c4 2310 	strd	r2, r3, [r4, #64]	; 0x40
	 get_sub_config(dev, type)->start();
 1028e26:	6843      	ldr	r3, [r0, #4]
 1028e28:	585b      	ldr	r3, [r3, r1]
 1028e2a:	4798      	blx	r3
	return 0;
 1028e2c:	2000      	movs	r0, #0
}
 1028e2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t current_ctx = GET_CTX(*flags);
 1028e30:	f005 05c0 	and.w	r5, r5, #192	; 0xc0
	} else if (current_ctx != ctx) {
 1028e34:	42af      	cmp	r7, r5
 1028e36:	f386 8811 	msr	BASEPRI, r6
 1028e3a:	f3bf 8f6f 	isb	sy
		err = -EALREADY;
 1028e3e:	bf0c      	ite	eq
 1028e40:	f06f 0077 	mvneq.w	r0, #119	; 0x77
		err = -EPERM;
 1028e44:	f04f 30ff 	movne.w	r0, #4294967295
 1028e48:	e7f1      	b.n	1028e2e <async_start+0x40>

01028e4a <api_start>:
{
 1028e4a:	b513      	push	{r0, r1, r4, lr}
	return async_start(dev, subsys, cb, user_data, CTX_API);
 1028e4c:	2480      	movs	r4, #128	; 0x80
 1028e4e:	9400      	str	r4, [sp, #0]
 1028e50:	f7ff ffcd 	bl	1028dee <async_start>
}
 1028e54:	b002      	add	sp, #8
 1028e56:	bd10      	pop	{r4, pc}

01028e58 <onoff_started_callback>:
	return &data->mgr[type];
 1028e58:	6900      	ldr	r0, [r0, #16]
 1028e5a:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
 1028e5c:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 1028e60:	2100      	movs	r1, #0
 1028e62:	4710      	bx	r2

01028e64 <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
 1028e64:	2000      	movs	r0, #0
 1028e66:	f7f6 be2f 	b.w	101fac8 <nrfx_clock_start>

01028e6a <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
 1028e6a:	2000      	movs	r0, #0
 1028e6c:	f7f6 be8e 	b.w	101fb8c <nrfx_clock_stop>

01028e70 <blocking_start_callback>:
{
 1028e70:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
 1028e72:	f7f8 bc15 	b.w	10216a0 <z_impl_k_sem_give>

01028e76 <api_stop>:
	return stop(dev, subsys, CTX_API);
 1028e76:	2280      	movs	r2, #128	; 0x80
 1028e78:	f7f5 bab2 	b.w	101e3e0 <stop>

01028e7c <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1028e7c:	6843      	ldr	r3, [r0, #4]
}
 1028e7e:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1028e80:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
 1028e82:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
 1028e84:	600b      	str	r3, [r1, #0]
}
 1028e86:	4770      	bx	lr

01028e88 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1028e88:	6843      	ldr	r3, [r0, #4]
	const uint32_t set_mask = value & mask;
 1028e8a:	ea02 0001 	and.w	r0, r2, r1
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1028e8e:	685b      	ldr	r3, [r3, #4]
	const uint32_t clear_mask = (~set_mask) & mask;
 1028e90:	ea21 0102 	bic.w	r1, r1, r2
    p_reg->OUTSET = set_mask;
 1028e94:	6098      	str	r0, [r3, #8]
}
 1028e96:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
 1028e98:	60d9      	str	r1, [r3, #12]
 1028e9a:	4770      	bx	lr

01028e9c <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1028e9c:	6843      	ldr	r3, [r0, #4]
}
 1028e9e:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1028ea0:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
 1028ea2:	6099      	str	r1, [r3, #8]
}
 1028ea4:	4770      	bx	lr

01028ea6 <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1028ea6:	6843      	ldr	r3, [r0, #4]
}
 1028ea8:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1028eaa:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
 1028eac:	60d9      	str	r1, [r3, #12]
}
 1028eae:	4770      	bx	lr

01028eb0 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1028eb0:	6843      	ldr	r3, [r0, #4]
 1028eb2:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
 1028eb4:	6853      	ldr	r3, [r2, #4]
	const uint32_t set_mask = value & mask;
 1028eb6:	ea21 0003 	bic.w	r0, r1, r3
	const uint32_t clear_mask = (~value) & mask;
 1028eba:	400b      	ands	r3, r1
    p_reg->OUTSET = set_mask;
 1028ebc:	6090      	str	r0, [r2, #8]
}
 1028ebe:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
 1028ec0:	60d3      	str	r3, [r2, #12]
 1028ec2:	4770      	bx	lr

01028ec4 <erase_op>:
{
 1028ec4:	b570      	push	{r4, r5, r6, lr}
 1028ec6:	4604      	mov	r4, r0
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
 1028ec8:	f000 f954 	bl	1029174 <nrfx_nvmc_flash_page_size_get>
	if (e_ctx->enable_time_limit) {
 1028ecc:	7b23      	ldrb	r3, [r4, #12]
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
 1028ece:	4605      	mov	r5, r0
	if (e_ctx->enable_time_limit) {
 1028ed0:	b10b      	cbz	r3, 1028ed6 <erase_op+0x12>
		nrf_flash_sync_get_timestamp_begin();
 1028ed2:	f7f6 f913 	bl	101f0fc <nrf_flash_sync_get_timestamp_begin>
{
 1028ed6:	2600      	movs	r6, #0
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
 1028ed8:	6860      	ldr	r0, [r4, #4]
 1028eda:	f7f7 faf5 	bl	10204c8 <nrfx_nvmc_page_erase>
		e_ctx->len -= pg_size;
 1028ede:	68a3      	ldr	r3, [r4, #8]
		i++;
 1028ee0:	3601      	adds	r6, #1
		e_ctx->len -= pg_size;
 1028ee2:	1b5b      	subs	r3, r3, r5
 1028ee4:	60a3      	str	r3, [r4, #8]
		e_ctx->flash_addr += pg_size;
 1028ee6:	6863      	ldr	r3, [r4, #4]
 1028ee8:	442b      	add	r3, r5
 1028eea:	6063      	str	r3, [r4, #4]
		if (e_ctx->enable_time_limit) {
 1028eec:	7b23      	ldrb	r3, [r4, #12]
 1028eee:	b93b      	cbnz	r3, 1028f00 <erase_op+0x3c>
	} while (e_ctx->len > 0);
 1028ef0:	68a3      	ldr	r3, [r4, #8]
 1028ef2:	2b00      	cmp	r3, #0
 1028ef4:	d1f0      	bne.n	1028ed8 <erase_op+0x14>
	return (e_ctx->len > 0) ? FLASH_OP_ONGOING : FLASH_OP_DONE;
 1028ef6:	68a0      	ldr	r0, [r4, #8]
}
 1028ef8:	3800      	subs	r0, #0
 1028efa:	bf18      	it	ne
 1028efc:	2001      	movne	r0, #1
 1028efe:	bd70      	pop	{r4, r5, r6, pc}
			if (nrf_flash_sync_check_time_limit(i)) {
 1028f00:	4630      	mov	r0, r6
 1028f02:	f7d8 fb81 	bl	1001608 <nrf_flash_sync_check_time_limit>
 1028f06:	2800      	cmp	r0, #0
 1028f08:	d0f2      	beq.n	1028ef0 <erase_op+0x2c>
 1028f0a:	e7f4      	b.n	1028ef6 <erase_op+0x32>

01028f0c <is_regular_addr_valid>:
{
 1028f0c:	b538      	push	{r3, r4, r5, lr}
 1028f0e:	4605      	mov	r5, r0
 1028f10:	460c      	mov	r4, r1
	return is_within_bounds(addr, len, 0, nrfx_nvmc_flash_size_get());
 1028f12:	f000 f92c 	bl	102916e <nrfx_nvmc_flash_size_get>
			(addr < (boundary_start + boundary_size)) &&
 1028f16:	2d00      	cmp	r5, #0
 1028f18:	db07      	blt.n	1028f2a <is_regular_addr_valid+0x1e>
	return (addr >= boundary_start &&
 1028f1a:	42a8      	cmp	r0, r5
 1028f1c:	d905      	bls.n	1028f2a <is_regular_addr_valid+0x1e>
			(len <= (boundary_start + boundary_size - addr)));
 1028f1e:	1b40      	subs	r0, r0, r5
			(addr < (boundary_start + boundary_size)) &&
 1028f20:	4284      	cmp	r4, r0
 1028f22:	bf8c      	ite	hi
 1028f24:	2000      	movhi	r0, #0
 1028f26:	2001      	movls	r0, #1
}
 1028f28:	bd38      	pop	{r3, r4, r5, pc}
			(addr < (boundary_start + boundary_size)) &&
 1028f2a:	2000      	movs	r0, #0
 1028f2c:	e7fc      	b.n	1028f28 <is_regular_addr_valid+0x1c>

01028f2e <flash_nrf_read>:
{
 1028f2e:	b570      	push	{r4, r5, r6, lr}
 1028f30:	460d      	mov	r5, r1
	if (is_regular_addr_valid(addr, len)) {
 1028f32:	4619      	mov	r1, r3
 1028f34:	4628      	mov	r0, r5
{
 1028f36:	4616      	mov	r6, r2
 1028f38:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
 1028f3a:	f7ff ffe7 	bl	1028f0c <is_regular_addr_valid>
 1028f3e:	b140      	cbz	r0, 1028f52 <flash_nrf_read+0x24>
	if (!len) {
 1028f40:	b12c      	cbz	r4, 1028f4e <flash_nrf_read+0x20>
	memcpy(data, (void *)addr, len);
 1028f42:	4622      	mov	r2, r4
 1028f44:	4630      	mov	r0, r6
 1028f46:	f105 7180 	add.w	r1, r5, #16777216	; 0x1000000
 1028f4a:	f7fd fd13 	bl	1026974 <memcpy>
}
 1028f4e:	2000      	movs	r0, #0
 1028f50:	bd70      	pop	{r4, r5, r6, pc}
 1028f52:	4621      	mov	r1, r4
 1028f54:	4628      	mov	r0, r5
 1028f56:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 1028f5a:	f7f5 be65 	b.w	101ec28 <flash_nrf_read.part.0>

01028f5e <nrf_flash_sync_is_required>:
	return ticker_is_initialized(0);
 1028f5e:	2000      	movs	r0, #0
 1028f60:	f7e9 b830 	b.w	1011fc4 <ticker_is_initialized>

01028f64 <flash_get_page_info>:

#include <zephyr/drivers/flash.h>

static int flash_get_page_info(const struct device *dev, off_t offs,
			       uint32_t index, struct flash_pages_info *info)
{
 1028f64:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1028f66:	461c      	mov	r4, r3
	const struct flash_driver_api *api = dev->api;
	const struct flash_pages_layout *layout;
	size_t layout_size;
	uint32_t index_jmp;

	info->start_offset = 0;
 1028f68:	2300      	movs	r3, #0
{
 1028f6a:	4616      	mov	r6, r2
	const struct flash_driver_api *api = dev->api;
 1028f6c:	6882      	ldr	r2, [r0, #8]
	info->start_offset = 0;
 1028f6e:	6023      	str	r3, [r4, #0]
	info->index = 0U;
 1028f70:	60a3      	str	r3, [r4, #8]
{
 1028f72:	460d      	mov	r5, r1

	api->page_layout(dev, &layout, &layout_size);
 1028f74:	6913      	ldr	r3, [r2, #16]
 1028f76:	4669      	mov	r1, sp
 1028f78:	aa01      	add	r2, sp, #4
 1028f7a:	4798      	blx	r3

	while (layout_size--) {
 1028f7c:	9b01      	ldr	r3, [sp, #4]
 1028f7e:	1e5a      	subs	r2, r3, #1
 1028f80:	9201      	str	r2, [sp, #4]
 1028f82:	b91b      	cbnz	r3, 1028f8c <flash_get_page_info+0x28>
		}

		layout++;
	}

	return -EINVAL; /* page at offs or idx doesn't exist */
 1028f84:	f06f 0015 	mvn.w	r0, #21
}
 1028f88:	b003      	add	sp, #12
 1028f8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		info->size = layout->pages_size;
 1028f8c:	9800      	ldr	r0, [sp, #0]
			index_jmp = index - info->index;
 1028f8e:	68a2      	ldr	r2, [r4, #8]
		info->size = layout->pages_size;
 1028f90:	6847      	ldr	r7, [r0, #4]
			index_jmp = (offs - info->start_offset) / info->size;
 1028f92:	6821      	ldr	r1, [r4, #0]
		info->size = layout->pages_size;
 1028f94:	6067      	str	r7, [r4, #4]
		if (offs == 0) {
 1028f96:	b985      	cbnz	r5, 1028fba <flash_get_page_info+0x56>
			index_jmp = index - info->index;
 1028f98:	1ab3      	subs	r3, r6, r2
		index_jmp = MIN(index_jmp, layout->pages_count);
 1028f9a:	f8d0 c000 	ldr.w	ip, [r0]
 1028f9e:	4563      	cmp	r3, ip
 1028fa0:	bf28      	it	cs
 1028fa2:	4663      	movcs	r3, ip
		info->start_offset += (index_jmp * info->size);
 1028fa4:	fb03 1107 	mla	r1, r3, r7, r1
		info->index += index_jmp;
 1028fa8:	441a      	add	r2, r3
		info->start_offset += (index_jmp * info->size);
 1028faa:	6021      	str	r1, [r4, #0]
		info->index += index_jmp;
 1028fac:	60a2      	str	r2, [r4, #8]
		if (index_jmp < layout->pages_count) {
 1028fae:	6802      	ldr	r2, [r0, #0]
 1028fb0:	429a      	cmp	r2, r3
 1028fb2:	d806      	bhi.n	1028fc2 <flash_get_page_info+0x5e>
		layout++;
 1028fb4:	3008      	adds	r0, #8
 1028fb6:	9000      	str	r0, [sp, #0]
 1028fb8:	e7e0      	b.n	1028f7c <flash_get_page_info+0x18>
			index_jmp = (offs - info->start_offset) / info->size;
 1028fba:	1a6b      	subs	r3, r5, r1
 1028fbc:	fbb3 f3f7 	udiv	r3, r3, r7
 1028fc0:	e7eb      	b.n	1028f9a <flash_get_page_info+0x36>
			return 0;
 1028fc2:	2000      	movs	r0, #0
 1028fc4:	e7e0      	b.n	1028f88 <flash_get_page_info+0x24>

01028fc6 <z_impl_flash_get_page_info_by_offs>:

int z_impl_flash_get_page_info_by_offs(const struct device *dev, off_t offs,
				       struct flash_pages_info *info)
{
 1028fc6:	4613      	mov	r3, r2
	return flash_get_page_info(dev, offs, 0U, info);
 1028fc8:	2200      	movs	r2, #0
 1028fca:	f7ff bfcb 	b.w	1028f64 <flash_get_page_info>

01028fce <flash_page_foreach>:
	return count;
}

void flash_page_foreach(const struct device *dev, flash_page_cb cb,
			void *data)
{
 1028fce:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	const struct flash_driver_api *api = dev->api;
	const struct flash_pages_layout *layout;
	struct flash_pages_info page_info;
	size_t block, num_blocks, page = 0, i;
	off_t off = 0;
 1028fd2:	2400      	movs	r4, #0

	api->page_layout(dev, &layout, &num_blocks);
 1028fd4:	6883      	ldr	r3, [r0, #8]
{
 1028fd6:	b086      	sub	sp, #24
 1028fd8:	4688      	mov	r8, r1
 1028fda:	4691      	mov	r9, r2
	api->page_layout(dev, &layout, &num_blocks);
 1028fdc:	691b      	ldr	r3, [r3, #16]
 1028fde:	aa02      	add	r2, sp, #8
 1028fe0:	a901      	add	r1, sp, #4
 1028fe2:	4798      	blx	r3
	size_t block, num_blocks, page = 0, i;
 1028fe4:	46a2      	mov	sl, r4

	for (block = 0; block < num_blocks; block++) {
 1028fe6:	4625      	mov	r5, r4
 1028fe8:	9b02      	ldr	r3, [sp, #8]
 1028fea:	42ab      	cmp	r3, r5
 1028fec:	d802      	bhi.n	1028ff4 <flash_page_foreach+0x26>

			off += page_info.size;
			page++;
		}
	}
}
 1028fee:	b006      	add	sp, #24
 1028ff0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		for (i = 0; i < l->pages_count; i++) {
 1028ff4:	2600      	movs	r6, #0
		const struct flash_pages_layout *l = &layout[block];
 1028ff6:	9f01      	ldr	r7, [sp, #4]
 1028ff8:	eb07 07c5 	add.w	r7, r7, r5, lsl #3
		page_info.size = l->pages_size;
 1028ffc:	687b      	ldr	r3, [r7, #4]
 1028ffe:	9304      	str	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
 1029000:	683a      	ldr	r2, [r7, #0]
 1029002:	eb0a 0306 	add.w	r3, sl, r6
 1029006:	42b2      	cmp	r2, r6
 1029008:	d802      	bhi.n	1029010 <flash_page_foreach+0x42>
	for (block = 0; block < num_blocks; block++) {
 102900a:	469a      	mov	sl, r3
 102900c:	3501      	adds	r5, #1
 102900e:	e7eb      	b.n	1028fe8 <flash_page_foreach+0x1a>
			if (!cb(&page_info, data)) {
 1029010:	4649      	mov	r1, r9
			page_info.start_offset = off;
 1029012:	9403      	str	r4, [sp, #12]
			page_info.index = page;
 1029014:	9305      	str	r3, [sp, #20]
			if (!cb(&page_info, data)) {
 1029016:	a803      	add	r0, sp, #12
 1029018:	47c0      	blx	r8
 102901a:	2800      	cmp	r0, #0
 102901c:	d0e7      	beq.n	1028fee <flash_page_foreach+0x20>
			off += page_info.size;
 102901e:	9b04      	ldr	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
 1029020:	3601      	adds	r6, #1
			off += page_info.size;
 1029022:	441c      	add	r4, r3
		for (i = 0; i < l->pages_count; i++) {
 1029024:	e7ec      	b.n	1029000 <flash_page_foreach+0x32>

01029026 <entropy_bt_init>:

static int entropy_bt_init(const struct device *dev)
{
	/* Nothing to do */
	return 0;
}
 1029026:	2000      	movs	r0, #0
 1029028:	4770      	bx	lr

0102902a <entropy_bt_get_entropy>:

static int entropy_bt_get_entropy(const struct device *dev,
				  uint8_t *buffer, uint16_t length)
{
 102902a:	b538      	push	{r3, r4, r5, lr}
 102902c:	460c      	mov	r4, r1
 102902e:	4615      	mov	r5, r2
	if (!bt_is_ready()) {
 1029030:	f7df fcaa 	bl	1008988 <bt_is_ready>
 1029034:	b128      	cbz	r0, 1029042 <entropy_bt_get_entropy+0x18>
		return -EAGAIN;
	}

	return bt_hci_le_rand(buffer, length);
 1029036:	4629      	mov	r1, r5
 1029038:	4620      	mov	r0, r4
}
 102903a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_hci_le_rand(buffer, length);
 102903e:	f7df b81f 	b.w	1008080 <bt_hci_le_rand>
}
 1029042:	f06f 000a 	mvn.w	r0, #10
 1029046:	bd38      	pop	{r3, r4, r5, pc}

01029048 <sys_clock_cycle_get_32>:
{
 1029048:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
 102904a:	f7f6 fa33 	bl	101f4b4 <z_nrf_rtc_timer_read>
}
 102904e:	bd08      	pop	{r3, pc}

01029050 <nrfx_isr>:
#include <zephyr/kernel.h>
#include <soc/nrfx_coredep.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
 1029050:	4700      	bx	r0

01029052 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
 1029052:	f000 ba0b 	b.w	102946c <z_impl_k_busy_wait>

01029056 <nrf_gpio_pin_present_check>:
    switch (port)
 1029056:	0943      	lsrs	r3, r0, #5
 1029058:	d00b      	beq.n	1029072 <nrf_gpio_pin_present_check+0x1c>
    uint32_t mask = 0;
 102905a:	2b01      	cmp	r3, #1
 102905c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 1029060:	bf18      	it	ne
 1029062:	2300      	movne	r3, #0
    pin_number &= 0x1F;
 1029064:	f000 001f 	and.w	r0, r0, #31
    return (mask & (1UL << pin_number)) ? true : false;
 1029068:	fa23 f000 	lsr.w	r0, r3, r0
}
 102906c:	f000 0001 	and.w	r0, r0, #1
 1029070:	4770      	bx	lr
    switch (port)
 1029072:	f04f 33ff 	mov.w	r3, #4294967295
 1029076:	e7f5      	b.n	1029064 <nrf_gpio_pin_present_check+0xe>

01029078 <pin_is_task_output>:
{
 1029078:	b508      	push	{r3, lr}
 102907a:	4602      	mov	r2, r0
    return pin_is_output(pin) && pin_in_use_by_te(pin);
 102907c:	f7f6 fdec 	bl	101fc58 <pin_is_output>
 1029080:	b110      	cbz	r0, 1029088 <pin_is_task_output+0x10>
 1029082:	4610      	mov	r0, r2
 1029084:	f7f6 fdd2 	bl	101fc2c <pin_in_use_by_te>
}
 1029088:	f000 0001 	and.w	r0, r0, #1
 102908c:	bd08      	pop	{r3, pc}

0102908e <nrf_gpio_reconfigure>:
{
 102908e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 1029092:	4617      	mov	r7, r2
 1029094:	e9dd 5808 	ldrd	r5, r8, [sp, #32]
 1029098:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 102909a:	a801      	add	r0, sp, #4
{
 102909c:	460c      	mov	r4, r1
 102909e:	461e      	mov	r6, r3
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 10290a0:	f7f6 fe5e 	bl	101fd60 <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number];
 10290a4:	9b01      	ldr	r3, [sp, #4]
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
 10290a6:	1e39      	subs	r1, r7, #0
 10290a8:	bf18      	it	ne
 10290aa:	2101      	movne	r1, #1
 10290ac:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
 10290b0:	1e23      	subs	r3, r4, #0
 10290b2:	bf18      	it	ne
 10290b4:	2301      	movne	r3, #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
 10290b6:	2e00      	cmp	r6, #0
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
 10290b8:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
 10290bc:	bf14      	ite	ne
 10290be:	210c      	movne	r1, #12
 10290c0:	2100      	moveq	r1, #0
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
 10290c2:	2d00      	cmp	r5, #0
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
 10290c4:	ea43 0301 	orr.w	r3, r3, r1
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
 10290c8:	bf14      	ite	ne
 10290ca:	f44f 6170 	movne.w	r1, #3840	; 0xf00
 10290ce:	2100      	moveq	r1, #0
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
 10290d0:	f1b8 0f00 	cmp.w	r8, #0
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
 10290d4:	ea43 0301 	orr.w	r3, r3, r1
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
 10290d8:	bf14      	ite	ne
 10290da:	f44f 3140 	movne.w	r1, #196608	; 0x30000
 10290de:	2100      	moveq	r1, #0
    uint32_t cnf = reg->PIN_CNF[pin_number];
 10290e0:	f8d0 2200 	ldr.w	r2, [r0, #512]	; 0x200
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
 10290e4:	430b      	orrs	r3, r1
    cnf &= ~to_update;
 10290e6:	ea22 0303 	bic.w	r3, r2, r3
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
 10290ea:	b104      	cbz	r4, 10290ee <nrf_gpio_reconfigure+0x60>
 10290ec:	7824      	ldrb	r4, [r4, #0]
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
 10290ee:	b10f      	cbz	r7, 10290f4 <nrf_gpio_reconfigure+0x66>
 10290f0:	783f      	ldrb	r7, [r7, #0]
 10290f2:	007f      	lsls	r7, r7, #1
 10290f4:	431c      	orrs	r4, r3
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
 10290f6:	b10e      	cbz	r6, 10290fc <nrf_gpio_reconfigure+0x6e>
 10290f8:	7836      	ldrb	r6, [r6, #0]
 10290fa:	00b6      	lsls	r6, r6, #2
 10290fc:	433c      	orrs	r4, r7
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
 10290fe:	b18d      	cbz	r5, 1029124 <nrf_gpio_reconfigure+0x96>
 1029100:	7829      	ldrb	r1, [r5, #0]
 1029102:	0209      	lsls	r1, r1, #8
 1029104:	4334      	orrs	r4, r6
           ((uint32_t)(p_sense ? *p_sense : 0)<< GPIO_PIN_CNF_SENSE_Pos);
 1029106:	f1b8 0f00 	cmp.w	r8, #0
 102910a:	d003      	beq.n	1029114 <nrf_gpio_reconfigure+0x86>
 102910c:	f898 8000 	ldrb.w	r8, [r8]
 1029110:	ea4f 4808 	mov.w	r8, r8, lsl #16
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
 1029114:	4321      	orrs	r1, r4
 1029116:	ea41 0108 	orr.w	r1, r1, r8
    reg->PIN_CNF[pin_number] = cnf;
 102911a:	f8c0 1200 	str.w	r1, [r0, #512]	; 0x200
}
 102911e:	b002      	add	sp, #8
 1029120:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
 1029124:	4629      	mov	r1, r5
 1029126:	e7ed      	b.n	1029104 <nrf_gpio_reconfigure+0x76>

01029128 <nrf_gpio_cfg_sense_set>:
{
 1029128:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
 102912a:	f10d 030f 	add.w	r3, sp, #15
 102912e:	9301      	str	r3, [sp, #4]
 1029130:	2300      	movs	r3, #0
{
 1029132:	f88d 100f 	strb.w	r1, [sp, #15]
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
 1029136:	461a      	mov	r2, r3
 1029138:	4619      	mov	r1, r3
 102913a:	9300      	str	r3, [sp, #0]
 102913c:	f7ff ffa7 	bl	102908e <nrf_gpio_reconfigure>
}
 1029140:	b005      	add	sp, #20
 1029142:	f85d fb04 	ldr.w	pc, [sp], #4

01029146 <is_valid_address>:
{
 1029146:	4603      	mov	r3, r0
    if ((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get())
 1029148:	f103 427f 	add.w	r2, r3, #4278190080	; 0xff000000
 102914c:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
{
 1029150:	4608      	mov	r0, r1
    if ((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get())
 1029152:	d30a      	bcc.n	102916a <is_valid_address+0x24>
    if (uicr_allowed &&
 1029154:	b151      	cbz	r1, 102916c <is_valid_address+0x26>
        (addr - (uint32_t)NRF_UICR) < sizeof(NRF_UICR_Type))
 1029156:	f103 407e 	add.w	r0, r3, #4261412864	; 0xfe000000
 102915a:	f500 4000 	add.w	r0, r0, #32768	; 0x8000
    if (uicr_allowed &&
 102915e:	f5b0 7f60 	cmp.w	r0, #896	; 0x380
 1029162:	bf2c      	ite	cs
 1029164:	2000      	movcs	r0, #0
 1029166:	2001      	movcc	r0, #1
 1029168:	4770      	bx	lr
        return true;
 102916a:	2001      	movs	r0, #1
}
 102916c:	4770      	bx	lr

0102916e <nrfx_nvmc_flash_size_get>:
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    return flash_total_size_get();
}
 102916e:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 1029172:	4770      	bx	lr

01029174 <nrfx_nvmc_flash_page_size_get>:

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    return flash_page_size_get();
}
 1029174:	f44f 6000 	mov.w	r0, #2048	; 0x800
 1029178:	4770      	bx	lr

0102917a <nrfx_nvmc_flash_page_count_get>:

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    return flash_page_count_get();
}
 102917a:	2080      	movs	r0, #128	; 0x80
 102917c:	4770      	bx	lr

0102917e <_GetAvailWriteSpace>:
  RdOff = pRing->RdOff;
 102917e:	6903      	ldr	r3, [r0, #16]
  WrOff = pRing->WrOff;
 1029180:	68c2      	ldr	r2, [r0, #12]
  if (RdOff <= WrOff) {
 1029182:	4293      	cmp	r3, r2
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
 1029184:	bf9c      	itt	ls
 1029186:	6881      	ldrls	r1, [r0, #8]
 1029188:	185b      	addls	r3, r3, r1
    r = RdOff - WrOff - 1u;
 102918a:	3b01      	subs	r3, #1
 102918c:	1a98      	subs	r0, r3, r2
}
 102918e:	4770      	bx	lr

01029190 <_WriteNoCheck>:
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
 1029190:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1029194:	4605      	mov	r5, r0
  Rem = pRing->SizeOfBuffer - WrOff;
 1029196:	e9d0 8402 	ldrd	r8, r4, [r0, #8]
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 102919a:	6840      	ldr	r0, [r0, #4]
  Rem = pRing->SizeOfBuffer - WrOff;
 102919c:	eba8 0604 	sub.w	r6, r8, r4
  if (Rem > NumBytes) {
 10291a0:	4296      	cmp	r6, r2
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 10291a2:	4420      	add	r0, r4
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
 10291a4:	460f      	mov	r7, r1
    pRing->WrOff = WrOff + NumBytes;
 10291a6:	4414      	add	r4, r2
  if (Rem > NumBytes) {
 10291a8:	d904      	bls.n	10291b4 <_WriteNoCheck+0x24>
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
 10291aa:	f7fd fbe3 	bl	1026974 <memcpy>
    pRing->WrOff = WrOff + NumBytes;
 10291ae:	60ec      	str	r4, [r5, #12]
}
 10291b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
 10291b4:	4632      	mov	r2, r6
    NumBytesAtOnce = NumBytes - Rem;
 10291b6:	eba4 0408 	sub.w	r4, r4, r8
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
 10291ba:	f7fd fbdb 	bl	1026974 <memcpy>
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
 10291be:	4622      	mov	r2, r4
 10291c0:	6868      	ldr	r0, [r5, #4]
 10291c2:	19b9      	adds	r1, r7, r6
 10291c4:	e7f1      	b.n	10291aa <_WriteNoCheck+0x1a>

010291c6 <_WriteBlocking>:
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
 10291c6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 10291ca:	4606      	mov	r6, r0
 10291cc:	4689      	mov	r9, r1
 10291ce:	4617      	mov	r7, r2
  NumBytesWritten = 0u;
 10291d0:	f04f 0800 	mov.w	r8, #0
  WrOff = pRing->WrOff;
 10291d4:	68c5      	ldr	r5, [r0, #12]
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
 10291d6:	6933      	ldr	r3, [r6, #16]
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
 10291d8:	68b4      	ldr	r4, [r6, #8]
    if (RdOff > WrOff) {
 10291da:	429d      	cmp	r5, r3
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
 10291dc:	bf28      	it	cs
 10291de:	191b      	addcs	r3, r3, r4
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
 10291e0:	1b64      	subs	r4, r4, r5
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
 10291e2:	42bc      	cmp	r4, r7
 10291e4:	bf28      	it	cs
 10291e6:	463c      	movcs	r4, r7
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
 10291e8:	3b01      	subs	r3, #1
 10291ea:	1b5b      	subs	r3, r3, r5
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
 10291ec:	429c      	cmp	r4, r3
 10291ee:	bf28      	it	cs
 10291f0:	461c      	movcs	r4, r3
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 10291f2:	6870      	ldr	r0, [r6, #4]
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
 10291f4:	4649      	mov	r1, r9
 10291f6:	4428      	add	r0, r5
 10291f8:	4622      	mov	r2, r4
 10291fa:	f7fd fbbb 	bl	1026974 <memcpy>
    if (WrOff == pRing->SizeOfBuffer) {
 10291fe:	68b3      	ldr	r3, [r6, #8]
    WrOff           += NumBytesToWrite;
 1029200:	4425      	add	r5, r4
      WrOff = 0u;
 1029202:	42ab      	cmp	r3, r5
 1029204:	bf08      	it	eq
 1029206:	2500      	moveq	r5, #0
  } while (NumBytes);
 1029208:	1b3f      	subs	r7, r7, r4
    NumBytesWritten += NumBytesToWrite;
 102920a:	44a0      	add	r8, r4
    pBuffer         += NumBytesToWrite;
 102920c:	44a1      	add	r9, r4
    pRing->WrOff = WrOff;
 102920e:	60f5      	str	r5, [r6, #12]
  } while (NumBytes);
 1029210:	d1e1      	bne.n	10291d6 <_WriteBlocking+0x10>
}
 1029212:	4640      	mov	r0, r8
 1029214:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

01029218 <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
 1029218:	f7f7 b9be 	b.w	1020598 <_DoInit>

0102921c <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(const struct device *unused)
{
 102921c:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
 102921e:	f7ff fffb 	bl	1029218 <SEGGER_RTT_Init>

	return 0;
}
 1029222:	2000      	movs	r0, #0
 1029224:	bd08      	pop	{r3, pc}

01029226 <z_device_state_init>:
}
 1029226:	4770      	bx	lr

01029228 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
 1029228:	b140      	cbz	r0, 102923c <z_device_is_ready+0x14>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
 102922a:	68c3      	ldr	r3, [r0, #12]
 102922c:	7858      	ldrb	r0, [r3, #1]
 102922e:	f010 0001 	ands.w	r0, r0, #1
 1029232:	bf1e      	ittt	ne
 1029234:	7818      	ldrbne	r0, [r3, #0]
 1029236:	fab0 f080 	clzne	r0, r0
 102923a:	0940      	lsrne	r0, r0, #5
}
 102923c:	4770      	bx	lr

0102923e <z_early_memset>:
	(void) memset(dst, c, n);
 102923e:	f7fd bba4 	b.w	102698a <memset>

01029242 <z_early_memcpy>:
	(void) memcpy(dst, src, n);
 1029242:	f7fd bb97 	b.w	1026974 <memcpy>

01029246 <k_heap_init>:
{
 1029246:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
 1029248:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
 102924c:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
 1029250:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
 1029252:	f7d9 bd19 	b.w	1002c88 <sys_heap_init>

01029256 <create_free_list>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
 1029256:	e9d0 3204 	ldrd	r3, r2, [r0, #16]
 102925a:	4313      	orrs	r3, r2
 102925c:	f013 0303 	ands.w	r3, r3, #3
 1029260:	d10c      	bne.n	102927c <create_free_list+0x26>
	slab->free_list = NULL;
 1029262:	6183      	str	r3, [r0, #24]
	for (j = 0U; j < slab->num_blocks; j++) {
 1029264:	68c1      	ldr	r1, [r0, #12]
 1029266:	4299      	cmp	r1, r3
 1029268:	d801      	bhi.n	102926e <create_free_list+0x18>
	return 0;
 102926a:	2000      	movs	r0, #0
 102926c:	4770      	bx	lr
		*(char **)p = slab->free_list;
 102926e:	6981      	ldr	r1, [r0, #24]
	for (j = 0U; j < slab->num_blocks; j++) {
 1029270:	3301      	adds	r3, #1
		*(char **)p = slab->free_list;
 1029272:	6011      	str	r1, [r2, #0]
		p += slab->block_size;
 1029274:	6901      	ldr	r1, [r0, #16]
		slab->free_list = p;
 1029276:	6182      	str	r2, [r0, #24]
		p += slab->block_size;
 1029278:	440a      	add	r2, r1
	for (j = 0U; j < slab->num_blocks; j++) {
 102927a:	e7f3      	b.n	1029264 <create_free_list+0xe>
		return -EINVAL;
 102927c:	f06f 0015 	mvn.w	r0, #21
}
 1029280:	4770      	bx	lr

01029282 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 1029282:	f3ef 8005 	mrs	r0, IPSR
}
 1029286:	3800      	subs	r0, #0
 1029288:	bf18      	it	ne
 102928a:	2001      	movne	r0, #1
 102928c:	4770      	bx	lr

0102928e <z_impl_k_thread_name_set>:
}
 102928e:	f06f 0057 	mvn.w	r0, #87	; 0x57
 1029292:	4770      	bx	lr

01029294 <k_thread_name_get>:
}
 1029294:	2000      	movs	r0, #0
 1029296:	4770      	bx	lr

01029298 <z_impl_k_thread_start>:
	z_sched_start(thread);
 1029298:	f7f9 ba08 	b.w	10226ac <z_sched_start>

0102929c <adjust_owner_prio.isra.0>:
	if (mutex->owner->base.prio != new_prio) {
 102929c:	f990 300e 	ldrsb.w	r3, [r0, #14]
 10292a0:	428b      	cmp	r3, r1
 10292a2:	d001      	beq.n	10292a8 <adjust_owner_prio.isra.0+0xc>
		return z_set_prio(mutex->owner, new_prio);
 10292a4:	f7f9 bd04 	b.w	1022cb0 <z_set_prio>
}
 10292a8:	2000      	movs	r0, #0
 10292aa:	4770      	bx	lr

010292ac <z_impl_k_mutex_init>:
{
 10292ac:	4603      	mov	r3, r0
	mutex->owner = NULL;
 10292ae:	2000      	movs	r0, #0
 10292b0:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
 10292b4:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
 10292b8:	4770      	bx	lr

010292ba <z_queue_node_peek>:
{
 10292ba:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
 10292bc:	4604      	mov	r4, r0
 10292be:	b130      	cbz	r0, 10292ce <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 10292c0:	6802      	ldr	r2, [r0, #0]
 10292c2:	0793      	lsls	r3, r2, #30
 10292c4:	d003      	beq.n	10292ce <z_queue_node_peek+0x14>
		ret = anode->data;
 10292c6:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
 10292c8:	b109      	cbz	r1, 10292ce <z_queue_node_peek+0x14>
			k_free(anode);
 10292ca:	f000 f9bc 	bl	1029646 <k_free>
}
 10292ce:	4620      	mov	r0, r4
 10292d0:	bd10      	pop	{r4, pc}

010292d2 <z_impl_k_queue_init>:
	list->head = NULL;
 10292d2:	2300      	movs	r3, #0
	list->tail = NULL;
 10292d4:	e9c0 3300 	strd	r3, r3, [r0]
	queue->lock = (struct k_spinlock) {};
 10292d8:	6083      	str	r3, [r0, #8]
 10292da:	f100 030c 	add.w	r3, r0, #12
 10292de:	e9c0 3303 	strd	r3, r3, [r0, #12]
	sys_dlist_init(&queue->poll_events);
 10292e2:	f100 0314 	add.w	r3, r0, #20
 10292e6:	e9c0 3305 	strd	r3, r3, [r0, #20]
}
 10292ea:	4770      	bx	lr

010292ec <k_queue_append>:
	(void)queue_insert(queue, NULL, data, false, true);
 10292ec:	2301      	movs	r3, #1
{
 10292ee:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, true);
 10292f0:	9300      	str	r3, [sp, #0]
 10292f2:	2300      	movs	r3, #0
{
 10292f4:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, true);
 10292f6:	4619      	mov	r1, r3
 10292f8:	f7f8 f890 	bl	102141c <queue_insert>
}
 10292fc:	b003      	add	sp, #12
 10292fe:	f85d fb04 	ldr.w	pc, [sp], #4

01029302 <k_queue_prepend>:
	(void)queue_insert(queue, NULL, data, false, false);
 1029302:	2300      	movs	r3, #0
{
 1029304:	b507      	push	{r0, r1, r2, lr}
 1029306:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, false);
 1029308:	9300      	str	r3, [sp, #0]
 102930a:	4619      	mov	r1, r3
 102930c:	f7f8 f886 	bl	102141c <queue_insert>
}
 1029310:	b003      	add	sp, #12
 1029312:	f85d fb04 	ldr.w	pc, [sp], #4

01029316 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
 1029316:	b15a      	cbz	r2, 1029330 <z_impl_k_sem_init+0x1a>
 1029318:	428a      	cmp	r2, r1
 102931a:	d309      	bcc.n	1029330 <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
 102931c:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
 1029320:	e9c0 1202 	strd	r1, r2, [r0, #8]
 1029324:	e9c0 0000 	strd	r0, r0, [r0]
 1029328:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
 102932c:	2000      	movs	r0, #0
 102932e:	4770      	bx	lr
		return -EINVAL;
 1029330:	f06f 0015 	mvn.w	r0, #21
}
 1029334:	4770      	bx	lr

01029336 <flag_test_and_clear>:
	*flagp &= ~BIT(bit);
 1029336:	2301      	movs	r3, #1
	return (*flagp & BIT(bit)) != 0U;
 1029338:	6802      	ldr	r2, [r0, #0]
	*flagp &= ~BIT(bit);
 102933a:	408b      	lsls	r3, r1
 102933c:	ea22 0303 	bic.w	r3, r2, r3
 1029340:	6003      	str	r3, [r0, #0]
	return (*flagp & BIT(bit)) != 0U;
 1029342:	fa22 f001 	lsr.w	r0, r2, r1
}
 1029346:	f000 0001 	and.w	r0, r0, #1
 102934a:	4770      	bx	lr

0102934c <unschedule_locked>:
{
 102934c:	b538      	push	{r3, r4, r5, lr}
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
 102934e:	2103      	movs	r1, #3
{
 1029350:	4605      	mov	r5, r0
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
 1029352:	300c      	adds	r0, #12
 1029354:	f7ff ffef 	bl	1029336 <flag_test_and_clear>
 1029358:	4604      	mov	r4, r0
 102935a:	b118      	cbz	r0, 1029364 <unschedule_locked+0x18>
		z_abort_timeout(&dwork->timeout);
 102935c:	f105 0010 	add.w	r0, r5, #16
 1029360:	f7fa fae4 	bl	102392c <z_abort_timeout>
}
 1029364:	4620      	mov	r0, r4
 1029366:	bd38      	pop	{r3, r4, r5, pc}

01029368 <notify_queue_locked.isra.0>:
	if (queue != NULL) {
 1029368:	b120      	cbz	r0, 1029374 <notify_queue_locked.isra.0+0xc>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
 102936a:	2200      	movs	r2, #0
 102936c:	3088      	adds	r0, #136	; 0x88
 102936e:	4611      	mov	r1, r2
 1029370:	f7fa b93e 	b.w	10235f0 <z_sched_wake>
}
 1029374:	4770      	bx	lr

01029376 <cancel_async_locked>:
{
 1029376:	b570      	push	{r4, r5, r6, lr}
	return (*flagp & BIT(bit)) != 0U;
 1029378:	68c3      	ldr	r3, [r0, #12]
{
 102937a:	4604      	mov	r4, r0
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 102937c:	f3c3 0640 	ubfx	r6, r3, #1, #1
 1029380:	079b      	lsls	r3, r3, #30
 1029382:	d416      	bmi.n	10293b2 <cancel_async_locked+0x3c>
		queue_remove_locked(work->queue, work);
 1029384:	6885      	ldr	r5, [r0, #8]
	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
 1029386:	2102      	movs	r1, #2
 1029388:	300c      	adds	r0, #12
 102938a:	f7ff ffd4 	bl	1029336 <flag_test_and_clear>
 102938e:	b180      	cbz	r0, 10293b2 <cancel_async_locked+0x3c>
	return list->head;
 1029390:	f8d5 2080 	ldr.w	r2, [r5, #128]	; 0x80
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 1029394:	b16a      	cbz	r2, 10293b2 <cancel_async_locked+0x3c>
 1029396:	4294      	cmp	r4, r2
 1029398:	d11d      	bne.n	10293d6 <cancel_async_locked+0x60>
	return node->next;
 102939a:	6822      	ldr	r2, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
 102939c:	b99e      	cbnz	r6, 10293c6 <cancel_async_locked+0x50>
 102939e:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
	list->head = node;
 10293a2:	f8c5 2080 	str.w	r2, [r5, #128]	; 0x80
Z_GENLIST_REMOVE(slist, snode)
 10293a6:	429c      	cmp	r4, r3
 10293a8:	d101      	bne.n	10293ae <cancel_async_locked+0x38>
	list->tail = node;
 10293aa:	f8c5 2084 	str.w	r2, [r5, #132]	; 0x84
	parent->next = child;
 10293ae:	2300      	movs	r3, #0
 10293b0:	6023      	str	r3, [r4, #0]
	return *flagp;
 10293b2:	68e3      	ldr	r3, [r4, #12]
	if (ret != 0) {
 10293b4:	f013 000f 	ands.w	r0, r3, #15
	*flagp |= BIT(bit);
 10293b8:	bf1e      	ittt	ne
 10293ba:	f043 0302 	orrne.w	r3, r3, #2
 10293be:	60e3      	strne	r3, [r4, #12]
	return flags_get(&work->flags) & K_WORK_MASK;
 10293c0:	f040 0002 	orrne.w	r0, r0, #2
}
 10293c4:	bd70      	pop	{r4, r5, r6, pc}
 10293c6:	6032      	str	r2, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
 10293c8:	f8d5 2084 	ldr.w	r2, [r5, #132]	; 0x84
 10293cc:	4294      	cmp	r4, r2
	list->tail = node;
 10293ce:	bf08      	it	eq
 10293d0:	f8c5 6084 	streq.w	r6, [r5, #132]	; 0x84
}
 10293d4:	e7eb      	b.n	10293ae <cancel_async_locked+0x38>
	return node->next;
 10293d6:	4616      	mov	r6, r2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 10293d8:	6812      	ldr	r2, [r2, #0]
 10293da:	e7db      	b.n	1029394 <cancel_async_locked+0x1e>

010293dc <k_work_submit_to_queue>:
{
 10293dc:	b510      	push	{r4, lr}
	int ret = z_work_submit_to_queue(queue, work);
 10293de:	f7f8 fcb3 	bl	1021d48 <z_work_submit_to_queue>
	if (ret > 0) {
 10293e2:	1e04      	subs	r4, r0, #0
 10293e4:	dd09      	ble.n	10293fa <k_work_submit_to_queue+0x1e>
	__asm__ volatile(
 10293e6:	f04f 0320 	mov.w	r3, #32
 10293ea:	f3ef 8011 	mrs	r0, BASEPRI
 10293ee:	f383 8812 	msr	BASEPRI_MAX, r3
 10293f2:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
 10293f6:	f000 f80d 	bl	1029414 <z_reschedule_irqlock>
}
 10293fa:	4620      	mov	r0, r4
 10293fc:	bd10      	pop	{r4, pc}

010293fe <k_work_delayable_busy_get>:
int k_work_delayable_busy_get(const struct k_work_delayable *dwork)
 10293fe:	f7f8 bc5d 	b.w	1021cbc <k_work_busy_get>

01029402 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
 1029402:	f990 300e 	ldrsb.w	r3, [r0, #14]
	int32_t b2 = thread_2->base.prio;
 1029406:	f991 000e 	ldrsb.w	r0, [r1, #14]
	if (b1 != b2) {
 102940a:	4283      	cmp	r3, r0
		return b2 - b1;
 102940c:	bf14      	ite	ne
 102940e:	1ac0      	subne	r0, r0, r3
	return 0;
 1029410:	2000      	moveq	r0, #0
}
 1029412:	4770      	bx	lr

01029414 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
 1029414:	4603      	mov	r3, r0
 1029416:	b920      	cbnz	r0, 1029422 <z_reschedule_irqlock+0xe>
 1029418:	f3ef 8205 	mrs	r2, IPSR
 102941c:	b90a      	cbnz	r2, 1029422 <z_reschedule_irqlock+0xe>
 102941e:	f7dc bd5f 	b.w	1005ee0 <arch_swap>
	__asm__ volatile(
 1029422:	f383 8811 	msr	BASEPRI, r3
 1029426:	f3bf 8f6f 	isb	sy
}
 102942a:	4770      	bx	lr

0102942c <z_reschedule_unlocked>:
	__asm__ volatile(
 102942c:	f04f 0320 	mov.w	r3, #32
 1029430:	f3ef 8011 	mrs	r0, BASEPRI
 1029434:	f383 8812 	msr	BASEPRI_MAX, r3
 1029438:	f3bf 8f6f 	isb	sy
 102943c:	f7ff bfea 	b.w	1029414 <z_reschedule_irqlock>

01029440 <z_unpend_all>:
{
 1029440:	b538      	push	{r3, r4, r5, lr}
 1029442:	4605      	mov	r5, r0
	int need_sched = 0;
 1029444:	2000      	movs	r0, #0
	return list->head == list;
 1029446:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1029448:	42a5      	cmp	r5, r4
 102944a:	d000      	beq.n	102944e <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
 102944c:	b904      	cbnz	r4, 1029450 <z_unpend_all+0x10>
}
 102944e:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
 1029450:	4620      	mov	r0, r4
 1029452:	f7f9 fd47 	bl	1022ee4 <z_unpend_thread>
		z_ready_thread(thread);
 1029456:	4620      	mov	r0, r4
 1029458:	f7f9 f85a 	bl	1022510 <z_ready_thread>
		need_sched = 1;
 102945c:	2001      	movs	r0, #1
 102945e:	e7f2      	b.n	1029446 <z_unpend_all+0x6>

01029460 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
 1029460:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
 1029462:	f7fa fb9f 	bl	1023ba4 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
 1029466:	bd08      	pop	{r3, pc}

01029468 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
 1029468:	f7fa bb9c 	b.w	1023ba4 <sys_clock_tick_get>

0102946c <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
 102946c:	b108      	cbz	r0, 1029472 <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
 102946e:	f7da bddb 	b.w	1004028 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
 1029472:	4770      	bx	lr

01029474 <sys_clock_timeout_end_calc>:
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 1029474:	f1b1 3fff 	cmp.w	r1, #4294967295
 1029478:	bf08      	it	eq
 102947a:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
 102947e:	b538      	push	{r3, r4, r5, lr}
 1029480:	460c      	mov	r4, r1
 1029482:	4605      	mov	r5, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 1029484:	d014      	beq.n	10294b0 <sys_clock_timeout_end_calc+0x3c>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 1029486:	4308      	orrs	r0, r1
 1029488:	d103      	bne.n	1029492 <sys_clock_timeout_end_calc+0x1e>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
 102948a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
 102948e:	f7fa bb89 	b.w	1023ba4 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
 1029492:	f06f 0001 	mvn.w	r0, #1
 1029496:	f04f 33ff 	mov.w	r3, #4294967295
 102949a:	1b40      	subs	r0, r0, r5
 102949c:	eb63 0101 	sbc.w	r1, r3, r1
 10294a0:	2900      	cmp	r1, #0
 10294a2:	da04      	bge.n	10294ae <sys_clock_timeout_end_calc+0x3a>
		return sys_clock_tick_get() + MAX(1, dt);
 10294a4:	f7fa fb7e 	bl	1023ba4 <sys_clock_tick_get>
 10294a8:	1940      	adds	r0, r0, r5
 10294aa:	eb41 0104 	adc.w	r1, r1, r4
}
 10294ae:	bd38      	pop	{r3, r4, r5, pc}
		return UINT64_MAX;
 10294b0:	f04f 30ff 	mov.w	r0, #4294967295
 10294b4:	4601      	mov	r1, r0
 10294b6:	e7fa      	b.n	10294ae <sys_clock_timeout_end_calc+0x3a>

010294b8 <k_timer_init>:
	timer->status = 0U;
 10294b8:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
 10294ba:	e9c0 1208 	strd	r1, r2, [r0, #32]
 10294be:	f100 0218 	add.w	r2, r0, #24
	list->tail = (sys_dnode_t *)list;
 10294c2:	e9c0 2206 	strd	r2, r2, [r0, #24]
	node->prev = NULL;
 10294c6:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
 10294ca:	6303      	str	r3, [r0, #48]	; 0x30
	timer->user_data = NULL;
 10294cc:	6343      	str	r3, [r0, #52]	; 0x34
}
 10294ce:	4770      	bx	lr

010294d0 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
 10294d0:	b510      	push	{r4, lr}
 10294d2:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	bool inactive = (z_abort_timeout(&timer->timeout) != 0);
 10294d4:	f7fa fa2a 	bl	102392c <z_abort_timeout>

	if (inactive) {
 10294d8:	b9b0      	cbnz	r0, 1029508 <z_impl_k_timer_stop+0x38>
		return;
	}

	if (timer->stop_fn != NULL) {
 10294da:	6a63      	ldr	r3, [r4, #36]	; 0x24
 10294dc:	b10b      	cbz	r3, 10294e2 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
 10294de:	4620      	mov	r0, r4
 10294e0:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
 10294e2:	f104 0018 	add.w	r0, r4, #24
 10294e6:	f7f9 fd9f 	bl	1023028 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
 10294ea:	b168      	cbz	r0, 1029508 <z_impl_k_timer_stop+0x38>
			z_ready_thread(pending_thread);
 10294ec:	f7f9 f810 	bl	1022510 <z_ready_thread>
 10294f0:	f04f 0320 	mov.w	r3, #32
 10294f4:	f3ef 8011 	mrs	r0, BASEPRI
 10294f8:	f383 8812 	msr	BASEPRI_MAX, r3
 10294fc:	f3bf 8f6f 	isb	sy
			z_reschedule_unlocked();
		}
	}
}
 1029500:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 1029504:	f7ff bf86 	b.w	1029414 <z_reschedule_irqlock>
 1029508:	bd10      	pop	{r4, pc}

0102950a <add_event>:
{
 102950a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 102950c:	460d      	mov	r5, r1
	return sys_dlist_is_empty(list) ? NULL : list->tail;
 102950e:	e9d0 1300 	ldrd	r1, r3, [r0]
 1029512:	4288      	cmp	r0, r1
 1029514:	4604      	mov	r4, r0
 1029516:	d105      	bne.n	1029524 <add_event+0x1a>
	sys_dnode_t *const tail = list->tail;
 1029518:	6863      	ldr	r3, [r4, #4]
	node->prev = tail;
 102951a:	e9c5 4300 	strd	r4, r3, [r5]
	tail->next = node;
 102951e:	601d      	str	r5, [r3, #0]
	list->tail = node;
 1029520:	6065      	str	r5, [r4, #4]
 1029522:	e01d      	b.n	1029560 <add_event+0x56>
	if ((pending == NULL) ||
 1029524:	2b00      	cmp	r3, #0
 1029526:	d0f7      	beq.n	1029518 <add_event+0xe>
		(z_sched_prio_cmp(poller_thread(pending->poller),
 1029528:	6898      	ldr	r0, [r3, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
 102952a:	b100      	cbz	r0, 102952e <add_event+0x24>
 102952c:	3860      	subs	r0, #96	; 0x60
 102952e:	f1a2 0760 	sub.w	r7, r2, #96	; 0x60
		(z_sched_prio_cmp(poller_thread(pending->poller),
 1029532:	4639      	mov	r1, r7
 1029534:	f7ff ff65 	bl	1029402 <z_sched_prio_cmp>
	if ((pending == NULL) ||
 1029538:	2800      	cmp	r0, #0
 102953a:	dced      	bgt.n	1029518 <add_event+0xe>
	return list->head == list;
 102953c:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 102953e:	42b4      	cmp	r4, r6
 1029540:	d0ea      	beq.n	1029518 <add_event+0xe>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
 1029542:	2e00      	cmp	r6, #0
 1029544:	d0e8      	beq.n	1029518 <add_event+0xe>
		if (z_sched_prio_cmp(poller_thread(poller),
 1029546:	68b1      	ldr	r1, [r6, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
 1029548:	b101      	cbz	r1, 102954c <add_event+0x42>
 102954a:	3960      	subs	r1, #96	; 0x60
		if (z_sched_prio_cmp(poller_thread(poller),
 102954c:	4638      	mov	r0, r7
 102954e:	f7ff ff58 	bl	1029402 <z_sched_prio_cmp>
 1029552:	2800      	cmp	r0, #0
 1029554:	dd05      	ble.n	1029562 <add_event+0x58>
	sys_dnode_t *const prev = successor->prev;
 1029556:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
 1029558:	e9c5 6300 	strd	r6, r3, [r5]
	prev->next = node;
 102955c:	601d      	str	r5, [r3, #0]
	successor->prev = node;
 102955e:	6075      	str	r5, [r6, #4]
}
 1029560:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
 1029562:	6863      	ldr	r3, [r4, #4]
 1029564:	429e      	cmp	r6, r3
 1029566:	d0d7      	beq.n	1029518 <add_event+0xe>
 1029568:	6836      	ldr	r6, [r6, #0]
 102956a:	e7ea      	b.n	1029542 <add_event+0x38>

0102956c <signal_poll_event>:
{
 102956c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct z_poller *poller = event->poller;
 1029570:	6884      	ldr	r4, [r0, #8]
{
 1029572:	4605      	mov	r5, r0
 1029574:	460e      	mov	r6, r1
	if (poller != NULL) {
 1029576:	b144      	cbz	r4, 102958a <signal_poll_event+0x1e>
		if (poller->mode == MODE_POLL) {
 1029578:	7863      	ldrb	r3, [r4, #1]
 102957a:	2b01      	cmp	r3, #1
 102957c:	d12e      	bne.n	10295dc <signal_poll_event+0x70>
	if (!z_is_thread_pending(thread)) {
 102957e:	f814 3c53 	ldrb.w	r3, [r4, #-83]
 1029582:	f013 0302 	ands.w	r3, r3, #2
 1029586:	d10a      	bne.n	102959e <signal_poll_event+0x32>
		poller->is_polling = false;
 1029588:	7023      	strb	r3, [r4, #0]
	event->poller = NULL;
 102958a:	2000      	movs	r0, #0
	event->state |= state;
 102958c:	68eb      	ldr	r3, [r5, #12]
	event->poller = NULL;
 102958e:	60a8      	str	r0, [r5, #8]
	event->state |= state;
 1029590:	f3c3 3286 	ubfx	r2, r3, #14, #7
 1029594:	4316      	orrs	r6, r2
 1029596:	f366 3394 	bfi	r3, r6, #14, #7
 102959a:	60eb      	str	r3, [r5, #12]
	return retcode;
 102959c:	e03e      	b.n	102961c <signal_poll_event+0xb0>
	if (z_is_thread_timeout_expired(thread)) {
 102959e:	e954 230e 	ldrd	r2, r3, [r4, #-56]	; 0x38
 10295a2:	f1b3 3fff 	cmp.w	r3, #4294967295
 10295a6:	bf08      	it	eq
 10295a8:	f112 0f02 	cmneq.w	r2, #2
 10295ac:	d032      	beq.n	1029614 <signal_poll_event+0xa8>
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
 10295ae:	f1a4 0860 	sub.w	r8, r4, #96	; 0x60
	z_unpend_thread(thread);
 10295b2:	4640      	mov	r0, r8
 10295b4:	f7f9 fc96 	bl	1022ee4 <z_unpend_thread>
	arch_thread_return_value_set(thread,
 10295b8:	2e08      	cmp	r6, #8
 10295ba:	bf0c      	ite	eq
 10295bc:	f06f 0303 	mvneq.w	r3, #3
 10295c0:	2300      	movne	r3, #0
 10295c2:	61e3      	str	r3, [r4, #28]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 10295c4:	f814 3c53 	ldrb.w	r3, [r4, #-83]
 10295c8:	06db      	lsls	r3, r3, #27
 10295ca:	d109      	bne.n	10295e0 <signal_poll_event+0x74>
 10295cc:	f854 7c48 	ldr.w	r7, [r4, #-72]
 10295d0:	b937      	cbnz	r7, 10295e0 <signal_poll_event+0x74>
	z_ready_thread(thread);
 10295d2:	4640      	mov	r0, r8
 10295d4:	f7f8 ff9c 	bl	1022510 <z_ready_thread>
		poller->is_polling = false;
 10295d8:	7027      	strb	r7, [r4, #0]
		if (retcode < 0) {
 10295da:	e7d6      	b.n	102958a <signal_poll_event+0x1e>
		} else if (poller->mode == MODE_TRIGGERED) {
 10295dc:	2b02      	cmp	r3, #2
 10295de:	d001      	beq.n	10295e4 <signal_poll_event+0x78>
		poller->is_polling = false;
 10295e0:	2300      	movs	r3, #0
 10295e2:	e7d1      	b.n	1029588 <signal_poll_event+0x1c>
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
 10295e4:	7823      	ldrb	r3, [r4, #0]
 10295e6:	2b00      	cmp	r3, #0
 10295e8:	d0cf      	beq.n	102958a <signal_poll_event+0x1e>
 10295ea:	f854 7c04 	ldr.w	r7, [r4, #-4]
 10295ee:	2f00      	cmp	r7, #0
 10295f0:	d0f2      	beq.n	10295d8 <signal_poll_event+0x6c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
		twork->poll_result = 0;
 10295f2:	f04f 0800 	mov.w	r8, #0
		z_abort_timeout(&twork->timeout);
 10295f6:	f1a4 0914 	sub.w	r9, r4, #20
 10295fa:	f104 0014 	add.w	r0, r4, #20
 10295fe:	f7fa f995 	bl	102392c <z_abort_timeout>
		z_work_submit_to_queue(work_q, &twork->work);
 1029602:	4649      	mov	r1, r9
 1029604:	4638      	mov	r0, r7
		twork->poll_result = 0;
 1029606:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
		z_work_submit_to_queue(work_q, &twork->work);
 102960a:	f7f8 fb9d 	bl	1021d48 <z_work_submit_to_queue>
		poller->is_polling = false;
 102960e:	f884 8000 	strb.w	r8, [r4]
		if (retcode < 0) {
 1029612:	e7ba      	b.n	102958a <signal_poll_event+0x1e>
		poller->is_polling = false;
 1029614:	2300      	movs	r3, #0
		return -EAGAIN;
 1029616:	f06f 000a 	mvn.w	r0, #10
		poller->is_polling = false;
 102961a:	7023      	strb	r3, [r4, #0]
}
 102961c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

01029620 <z_handle_obj_poll_events>:
{
 1029620:	4603      	mov	r3, r0
	return list->head == list;
 1029622:	6800      	ldr	r0, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
 1029624:	4283      	cmp	r3, r0
 1029626:	d008      	beq.n	102963a <z_handle_obj_poll_events+0x1a>
	sys_dnode_t *const next = node->next;
 1029628:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
 102962c:	6013      	str	r3, [r2, #0]
	next->prev = prev;
 102962e:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 1029630:	2300      	movs	r3, #0
	node->prev = NULL;
 1029632:	e9c0 3300 	strd	r3, r3, [r0]
		(void) signal_poll_event(poll_event, state);
 1029636:	f7ff bf99 	b.w	102956c <signal_poll_event>
}
 102963a:	4770      	bx	lr

0102963c <z_impl_k_poll_signal_init>:
	sig->signaled = 0U;
 102963c:	2300      	movs	r3, #0
	list->tail = (sys_dnode_t *)list;
 102963e:	e9c0 0000 	strd	r0, r0, [r0]
 1029642:	6083      	str	r3, [r0, #8]
}
 1029644:	4770      	bx	lr

01029646 <k_free>:
	if (ptr != NULL) {
 1029646:	b120      	cbz	r0, 1029652 <k_free+0xc>
		k_heap_free(*heap_ref, ptr);
 1029648:	1f01      	subs	r1, r0, #4
 102964a:	f850 0c04 	ldr.w	r0, [r0, #-4]
 102964e:	f7f7 badb 	b.w	1020c08 <k_heap_free>
}
 1029652:	4770      	bx	lr

01029654 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
 1029654:	4770      	bx	lr
	...
